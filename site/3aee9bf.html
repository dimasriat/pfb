<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d03e4e4d3118b566270e63ecaca9737fe69b957b878458807b467c4f4d32c5f368cc47010bde043cf7860bf27466fe5ebc1595dd17b5a92cf1786edc782d2e86dce8b38a73c8cb268994a7486204fe63792cee15f397c7c30b4ad6ac313d76e6dc23fb53b628ad78386d1c170ddc6cfe350c496a8b53f5bc484aae6fc4952db65def985fd85cca60fe4086002b7f6823da0503ed12d82dc30b6f3300dbace44154abb9bd0889d1cc414d251d037cbc57b0386aa5a15406390218c127c369be6bdeb429c846bc1b6a18a249366639bc6c6e356e725c60ec25d7938eebc9ec987209b76eb132d342049b48c0ab9a2c55aa61f2f4f64309fb73ee17a60ee2ae06a54292ec3bbcccf240b8c90191182bc151a231d11402597c51cc355af38b5b76ea1fcf285b48b20d4ccb58b3a4e942cce4ae1cae6cf2fdc6a4ced8496cad8ae25964f891baa3e9df535f809bdf1d7ad7379d93b1bad414333242adbc7f0e02475869b4b2cccd6b5cecdacb9c860b7302c012e0c92f0b56abcb31355b021766da12d9a93c92b6ff8d167d5ff47d132699691a73ef0265e0f4fa42146d50c3f2538c9051b80fccf8f7307732e5a6a90f56498e1fcc51740111124ba6a557dfa90ac0a7e078320c775a221fe8f0a858b66b2b6d565da83ebdf45b4e253e1f64004c2e3c0e8d2e1af1273c3f7c40ce74bcafe868119b9feb11e309f23272b7cca1d4660b0f8eda80ef1073a4d0ea61a84306495a0fe7f04d09aaef3f787d72a95c578e9bd8c754fac14a30da62e114e37c20e1091e339392a1b6edc0978255952760ac542f347317c5ac2936a0c7bb8deec2b23e7776d776fc9283b68ebfb5dd884621d51d1e6da3c3c2ae36c9650e79786d045f28587fd642dac604b355cb677ed68eb9556dc310dd650cf48b9b23bac4daed9ddc28d815e6dff8d952d26a0ebe566da23afa7ae99cc4f9b8341359385c4d4d792690893edcaa832b7f63863f5b82670a0d14e4bedef6b325d155d2b13df704effc443a83ec79f2ce8f84453351ddab6ef76c56bac5793a322bbee72ce53b092861148d1361ccf5d47554a25f132b49662a780d8b19c38674fa068a7d0022ea45b84988194975710645551f717d93ff8621aa3d74d2ec3f73df9ff9755cae3183c719236d1c951e554255b0653b12d088b138a71cf01c04a02ccdf70d4213e19ec6383f1f3afb464e8a1ec8dfaa80cfae4bde9a14febb3193bcf58a4c767486bc3b149e9bae15f0a8d59b9c71f61d089f55d2299327a578ebff91b4f002b808a9ee89f079f269b29ce401ef0a9cf299cb7beb249eb3346ed6635d0f477eb679b03fbc6bc6b2755c8278272193edc8bd88b6966e2c575d2c4f06d63ab7f750efcc7e5e2c3c3149be4d918bc05de691c2ff1b72c9d6691b54c28542cafec7b7d26e2fe10738ebd10240be9a2fbdb4b056d1cf959f9ba5052c021fd7a0e7ab1111ec84fbfcef04e8229bec7848deef550a423ef782babbfae387eeab33275456efffac390b05734f1cec024323d0900260deabf77ed50877f814b03d0ede8677bdde7d9062d96f2ef38488d9135bfc4f79647a54d6f34320f8238b11abb4f9cace3b83eb71b4bd2a79760d1b7e4146029303ab8b793ccb23771cf367cee9863599f1f115cb3905f5eb4f26a541a39f8873fe02ed50909e9d5e100668616aa971a33f86153a0b4445e4be0f8acdf037312a587c6eb446d5c6b54f74574b55d75277522c6110af3c2317875fa2df8278d333fbb598323c99278ffdd491d2a11ed16f18ebcb029652bd43e220bd6464164628ace19eb74619378430054b26ac3ca8f7a7325d921ae5505f60ad014af6cd72044d5c69da5c714c51b6b6f1a2a89d371539e6484014d2fb88c9bfebbccd1835a3d5290cfcb96119e89dea95ce722018d871b7f92eaaf52b8ae30fcaeeba9fc995167ca2daaccaaf9781aed108c246272477f4638f4a5915872b2694e466c7cf9c99daf06329ee47d8029d4d9de310d9246c7d4536ebf1e293b30f9cb98dd2216f0905b8020831f3f811f587bd07259e203f1b9e925a0dffa0a6f76999ce65447376ec583646e79844ee2686f212f0f171eab2b1d980c94a22e958c02d5b662cb7dc4497dbeed0bd587a340325927b958d26b91fb2a7592b34ed8377571eb93760680d822edec54e7b1c795ee502a00b53d696d66d281e061bb81cd8fe4b5043854e2f931c90d6d0b44a3e7949ff56b263bf167aab3a36d4e41f8a6c2d41b5e65545cdecc9dae8ac63d5e081ff6fa851319683b8b3716ea7d18071d6c2a552deb1896e9d0dcf80f5644c98e1d3fb586cd2e268dd83fe925b5ed7e1c0ae6d2f7e5af1223c8f10d93ee369a532bf42cccc0690b5c289ca14933ad712db834f539212c70306b9cf403a81fc8ff0ac2d6185caec9b17b30fe88afc0919ad3b2b5eb24d4283a00e5c61f169f8dfad9ecec99486cac8d2e02c05dfa3be5f18cef8f40a3f8af825e6e930db8b2ad0a597548599ff83a0d41cb9a1032019d4f1c5ae3282bde940421d610f7e7de76229d4bb1e37df58a65f00f1de31b461a84e7fa26bf9ce6836846a74d3a668a6bd7327cac245144626e52ee621b8934e70c8184e9db502f0d08d4d66a52b492ee7388586488c10736a001f7317c3b632d9b35234708773ddd6dcfe1ee20c6612b3ba3c2e2625cc28ffca157cfccd041a6b7750c29a223a857bcabd00ebd1980ce8f8428318e4b5b29182b7a808125a432c33304b07c34caf60cdd7ed7435a3b28ec78038d570ffde7fb0ef3e3fb082e63a69813970395894ac38999fe447d42d37cd1c6d5df3422523325bcf6037d6ac7361c318d492866db1faee1e683c3950943bba7a23ad2dfdcaddf09bc44ca408f4a03ecc7624bf89a4690264def8f55b1eea3bbe8b020f080a8d0cf56b9ec1ccd93c1aa0937d945b2cce2a51f8e43933b616c264afb7cf8fbcc478bf7578bdbc03ac90d1a5f2936e182813ba2099162fea5ea8a4078faa0e46db88353d479747474f916cebb317753855c7d732a10bf5d4c6ebfb382afab6b4629cb83790ff693dc9c57c8ae97d7e884337afb8c28c329ecec44ef5e93d90ff85aef8fee04fec3d34a570fb6ef418f4732b47e5102b8085a5ab916f4a1fb84491d494df92c395e961f0752e94f5e1dec1e4245be1d56f80c9c959fe8f20d9582549a4f7e4123147df0a02d44657c2412a8a9cc76631ebe17de08c85862134cedfe6272575502b44821c71632621dda664c9e83a4954e5fe8e52cb7f5ac911c6007b272a8301e16fac2854570c4802d0c543f9ae3d3ca4068289ac7dd7a8ae028368747932818b6855e9052437dc646b1aa6f0944860b518bfa2d3bbe30afc785a3da82185fdeec8b145fc8efa610f1a608bc435fddc381458b2bf85616d96f377e3adf3c8d25d71d69d174b6217193b27e3ee821a1fcc1a9f304bc2be5af6be23efc6681da8bee74ac1df6cdbcabd2145503da7d8725a2c244fff9cddd61e7ea24add7fd474ccc8651d0614ed6bc8ce89055c18503a7476e6a780cc6e6a6d3208f091c83fd1e312e130b32493d5fb39252941ad747d2a6307cf9e2662304c2fb701e20008a788ad7ae627007144c186a007cc2db9c3befb38ee5ced93aa8394367b2eccf70fcb347fc54f4749fa9e52f84ca84de5653a1b2a2fdccd9ab085b6af37596723fe336b1fad895fade12c55eb91b9adcdf7767484a26e7525c9c1ddea6d8135269c5b082fb71f33ecb510d8ba428e12cbab681a82a5e6e2188cb809eaf553842e749e4006f6dd310138ab83d9604b11d3cf9d5b839be4650d6e9d5714c35c984a46d0fdb587063a51e43e20acb5cd659ce8fea614e505ef050aa60585ca17511777d5d3a95652dfbc758660d39130b1e1dab07ca0002d499e771cb96184cdfeb770ac2e1633b96bb76b932e5aae068cf7481cd7bc1e9aefddf5483c8c95440755c8a5a246b2a13947b041ea5b8aa905398ae2cc942be0154c31c803937f40693f8ee07988ff630787a07293ffb6c925ad326eb7ae3871ff0cf868cc69dd7770a5ad66f403f4aeb7781a5c260463b872039fd447ab140d7bee383d181653d2e0acb8713a9ae28b120c507334ef955dabf6658527ad8b94590867a2080f193df35cb3de78b9bbf28a4edebe59781e5f28991345ecb6f4617cfef6992ef02975c9629d6e93f9ca7727be897dc8e6eb25131475a8a75cac1922ef12e64a8d9efa5ae1851894200dad5e7204e61a55aed1947ba62184ee92dcd82da655b1be77f740e680b97760771849b2dbd63278a58342a5b5b0c6784989194e778ef1255088f1a37499580949d611d30265de750ee97b64b3be31201231ef8ab084166e7a90747385c81edf073e61fa76bcf09bb4b7fe31920c771529d0ebba8292ac2d09e739b15590eb549302a45ee1b3490e0e02fa377c6a1c36e4bb17248a7c6688fe3bebea48512286f0a96ba9fb9560224ae87f9ae1ef5f38cda12ca187a991f0ed7e4f3a40a500fa436d36393c58b130b596ff6f57609e3127c9c19964ff853122b6e0868c0640092812166b9419ddd59453370703a2250e813136ca437817385eddd0c550e37f01e2267b53b4e6528b3fade761314f7614c63fdef4de59d3d3b5d1a5eeec8ef6d3b760c7a1d045826667b9607af20846d538eb72fdca8c2cccd921856082a006d9d6a2c3d6d9329c5d10ce4e5e22a0787011d510f636d0b9a3af686fdd6452f3d1208d95b9edecc2e6492c9099260e1dc90038d720c4544502e1381f85205a41c274bde2fa273318645a125eb3ce54f45c8231576d9e8c568c602443c824257871a09c7de491a0e6418b306476a435bfdfbcb483f204f9d1aa56f486d1cc567885deb62e9f270d07d04d6a5f440b7d768951abd8ffe53230857a7e73a4428c2e1d2be882bf25c694cb2cea680c30d7e0f850bad14fc1943fa50804021423f7a8476411128740b4498b21d66f9022dd674674a17455073a6991fb8152938d8b9021340229b9dfb5122f762985818dac3b6eea2da5a73ac18eb96c57ae9064af19a4335dd80013f3e701de000636cd5dca80530fa2fc1539a4a40fed3ab247fbf3872a4869d17a54708e2148ecc158962635eaff66030558a9d05022bab147afa9bd25993ab8e5bdfbfc652c70f78d0f29f03493a1c2319faf09dd8ff02b1c305e110bf4e4bfe87c81e2b24f21c22f7236c9ee8860e15bd383b468ea53b6d18fd60e16634d850ccccba0bf732acbb0492c7fed5a68b2e280637139285bc7a74894d5697301d06dfd21636b379b01edac04337c06cd573573de1230b477839fa34c2cc910754c65286621bfbe49df4ee5b723f28ac1d173f1cf06d780bd709cab81531415445716ad247c21b99cda35329e8576606f5300586f9dac0e31f608fe5e113a78214901fa28540986b91b777bb1656618cd3983a8d5356903d409b7f5da1ddc9b04fdecbef70994b9857c1313c487ca0ecb9d9518f9ffcb089b83c53d1159ad3d9c890aeefe0a07496d6773b3f7b6bd7da78bff73f36651ef24ad34496b3404269b314d20e11ebf9aaa523b5464f021da617ac50d77c56f6af3a777f4939a586e652911e030ab643158d9a646a023d34ced22b255b85bf29ca4ed83e9393baf9a5290056cbfd526b3991c519941b7639d59ae907c2d563ba82f4585c842b72572290670d7d69f452c4f89cac9ff3a7c8e3840b45d21b311e2f2352e5665fae5834d34d0dacac48c51a05747e39f58f6902b3342186998e0a7906774a35d19dc9ee2e9c1ee045d7d7585b81f371933a87872a430f7d424bb44740de442b4f2f0ef6594adcae3312f565605f122a545eb0ee88d73c7b5fd6685b6bd7ebc9fd6fff25ae33e89f145d88eda76ef203ecf35de95bde8befdc3ba1d4c9a46db4b20df21534f257bbc36fd9baf75405c4bafa38b76a5f4c9cdc91fb0f387d5e9120cd136be38209d0a1f4ee929b128646873e6b8bc6a4bac100f043fb3f5b41235f735f18610c8f865ca9d17d43e35a338aeb71e00b916506f8927c38671aa7faca287bab3f008041deffca9f9b010e9e4c20dd5a0f8f924da46fd843991e21f16e03e833d6d2a663297782c8267bad7b7b56419c442c613dbbbf8a2a303bd1806d6d7083a4c38e45ac711ba565caa9cfb0acb20ef40c9218c50c2fa834d5d3d8afc7347542f19e14ad51f0afc94d7980cfb648a573f1b9b610fe96247c043ea138d1952058cb34739da3a2c5e0b2905118e7ab9c827cfb0edf3614686c008cd932f46823d2a739d193d203c6b3204eb9a89dd90608b366ec33dc629cf9f419a23be1162ba043f78229d74465b4e1c39e53948d7718a071f5ae2819522d8e6ba2249ffe5174e1d3b21ed212056ba538823b2790447d4eb0250620c4966c7ee25307a05c5db5cdfe078f742b5aa715c9ae8072bf5d3b7379622de60b41a8a4fdb910e821abbf2b8037cce0bd645c6eb045c9ce34a6ea0637df09e11a68440ef8df65bc442f50f6521d901be49be32c1e3023572c87682e10108538bf7b15c2562228b43812c70dcb17330b77dd024b19fc5be6c1af1f7647aa604d6869d004f19ce01be51a657575609cd8a36ef65e3ede3d54c114181267ee9bb10143358e395becfe69c1ca56c6812442ffa5df8001e097c29f682f467a42bbf2a691f3da95556547139e6ee12d3ca5cba85be210575a1da78cf22cb899ade01439a32f2d41c5b44348fb2887a8e492409c7ef3b692292827cbe075e80679564a9b3f6b88a5d3d7c3d6fd31f0da003c5fbf2a8feb008ae2d916935d8e3dfc41376e901633be239372e68db276ba54266e71727ea7b2063328be6f649540272a4007a06ffd4d30bde57849d0110cd67d613156b2038b6ba40ed1d15b82305efc847745858ec41d97fd2a427460fcd638aa52cf1a0d875f5688a53baac0af4e4bf499128cf4ce3a358ac36a66c3b871fab7994ab318afd823dd5a24883b70a54003162d51719dd0c69832623cdba0925d9612798d3063630b4db1710203a9ede130203638591e9f646b32739fc6f6c29800301b7f087d7a34f563285fb756b237dc51ff57a8da63a5bbfdf696ecbef7edcb7bc7b657c1a5eed53ce547000a2960151fe80abef167755d49d6569ed53f4e7d5424aaabe3dc1f1b8142bf5e2e700f29ed6793239f2cd339531924fa4ce8215e8b6bd2cc283be69215a6b2542afbb247c39fa6214a4f519ba81cb6ffda7013659e14387e9f2b8dffa088f006ddaf1739ef18aa100854ac9136fd520d17e06eda5c41508519f68615a6b3578875dfeac2223bafa9df9b43f7f990b447d9c1fa886894085e53bd66a76d8c26c874e5bd656229183268e97d8f746920c8aa57d1d7e8a8cb18c40a91e8fdca53369a1e80bd57070e9ac8c344eaf5086044f87803ec77b835be52fe820b04476180781347e8b8cf05176143a2fab4824e7ebf08917de993d5be4c3e3497ab7be005660fbb597f7f02a46a7ce875a9b7f0175916f8ec6fc67f6f04a19489958c4198476735f41aa0486b02522c165adaf03c7f86ef8d56aebf6dd7544393622b959a6cde12bfa2547b0406ebd8683e34bfeb1c83a4f575dc060d03b0cff4348bfdd4ec0f910d2dc1385f6ce86b9e4ffc0d5efec0bd7d4e801ffa310fdb8b02b234251f73544b4d051a8db719ce150ff4bdcc891baa9616d4e7ba7d3165f200029112a71ac1364b7fcd16a9096314cff462c0055df564de6c50915ce7daf6235339b2e84a91433bf5216b2c81ac4dba914aefe8e530a76ed82dfc1ab15a7fce871cd8b0be4e0411162121f444ad26ab1a196b0c84e3f61c76cad685aa94b536d010f69c7ec6fc89226a5f4d4e6d480fa686c58321f0b496f81744fd98ffde93c093f7966df7804f510ecc9109dd4d23f3bd434002fbc3400bf24eb4d9ffd93a7324539860c8b24e4634a54a8dc4acea654d49bd026148460749552ac54df62d2ed43aab0821ebfde79a9c3a966a80c64a6fde88ea44c9e7681f72140c6f44cc832670d3b00b0d7559db2cdbbafb3a463985ddcb02ee6f958b326c925cc78651395ce207156ca7fe2888a39c58a259884b1383da2a7eedce7f8797542d630f1158c53b1faac4b263231fb8988b6543299bd65b9c0d6908ddae87e3581e3f7ce6670ae16159e6c111aedb609526168a5874a858f2b226057a841d27e9f49ccaad0568e7de93f7537f7c3a9c8ee52f30ce18f556b5c48845552e76da63136fd41cf15b73625d238f135f82f856e7c217c74a64fd118869f3d8cb8a543292ae553f5095b76228fad16c4656eae123c9926b6cf54cab3fba7cd2297628d2a5085a6b358f150d51cf03c99d223f4ada4383688ccc0bc681b12c7a4eb768e2287a4375ea996ab5cc70b2bd770e5f0777debe224a9ad563da0108dbbbdb9ac215982e794f52bae8669e5038ae5ba4cd1e5d94f1c41f7bf8698d977455e7db348b05314d1660cfca582ec11e289dd7637014131cae4bf6d8a81848572ef3122129b336c0ccf3a306a65975e2c7dd3c2905e02797197e06d4c4514e3246f3657438439a87c5190b731f4cd35bc0de5b4236837b5f93261141c073496c44bb2bd97dea43f5e48b9d9a3e9f77cec6df169fe4f0cdb03996870a26549dd07d4cf8b0285b8cad59edf4fdf1648eef56e0cf8e45d3767f9605258705531183a7da9b96dcf55b69f79b089ee79c4720f1046acf545170c19fecf9cfd9bf294c58e17e440b989593f9634595360a9dae999b8ee4707ecd3f4836b3d816d280ccd12d64fdc5823a78b80585a7d3d2feffba46c8b8f38fc8fd97dd0b60d5137140b4131cfa82f3eb87546392d3941ed27e356c6a71224b6981cc9eb0f1faf97ae23b25519dca642beb488c3af5c33401553b32711fb72e51a742896793d7eba548614acfcdb391c77470d0af3a2b4c41ae77796b44c7e8b22d069e96d108dc75cae374c1d7e8e3acfea4edd19a35562090e951e106201aa64c0de2eb6dd70bef3e6182e06b396e1176125a08f5ea9269fb8b3d7dc9a90581a796f15f00a9739657d814b0312a7541491d23c8128bf4a0990bd6bfb94b2648dcda448168da16268d621fe3de5b5e676fd86a032204ab092ca2975322f8eb6dc2a66ed64e58082fb22be3e2e89bb432a68ef2dbdc424b635a72555e74a4daa028b9aa469474568d6dd06b1f55f168fef92f1b5dec23f64529cd7409ed15233cabb76263529edeeae3768c076c019742222e76a1c93e83b588430dc6b9f4dd62625b7a9a6f95b1f50d602eb519d9d50badb6f1755aa56cdd300eaf69c6361c3931593d3a96ec94e9905fcd005c612ddffb5eaae680c128e25c2b8c20cd74d44baf627a16c7287c41ef12b6b18bf1e9878481a335b0479d179689539bad157502f174752d5c3f5c68c9486b2f8fbd9998e9b8e191b1398ee0c648a1973298a99d9ea288aed553ae992a63953f527ec2b127d92cc741f4347a375b5fa16705813240a2d24599d2311527de09c962306fe0e24e2908f616f1b776f2b7678d2f1a0243fa8df704875fe532ae58b0d4319cb7c07de6d67dfee30f262c4e6aab631fc37853b1210df38690dccd38a5da33788d78987239f5cf27cd693f1dcb955381e9f9b42c3df8a9e9cab64bb390173f417dbaff942094c22b0f55395a947d82cdb7ece57f0a3c68a49310825455be08c54a410e1caee0c07f9108ed52664ed907f24fecab5aa6692241f37b943d308733cace3e5da72b0850ed4ef2fe63a96ef36230e99014b89fb54e8ce564321d7a64f2d9bfad967f3c6c9ca1193573a1b911afc141bc373d1fc36d7fee20da8bddcb05bb17c482aab8dc6b78290d641e2c867e8e0bdc9d8714fa835441351226c13a3d21051e434916af52b62bb15bc80a698669244a314aee425959ff6dabdb6b205619815a80ca82a20f24ba2c1f0a0a672143670bac45002ff2978dfbbcb5baffb2089b0f797235ca6078fce120c1c604d0a4a84ddf79907bb61bb14b879532af620dc5ecfaa3fa4d2130e321d36063302c021e8d6a2dbb3ce943287d3a7f9464e915dd5374544a42e456cae0b592750d34a39028a59c0d8297df3edf01a354224b694705d4e45448d93831d98c241040281ec7e4afc823d0ee443d3e8fe4bef9b0da69b187521594d16b6499d58d0e9d4d339985c1346509ae188ad5d17ae8a47a6e6ddc741c7d971287601c16799de09397059c75de92f3cc74aab8a0ffe46f1cfe2956d81bbadc0c8fa8b99177ad3252106cd4453b8bda21bbd9ba990bc432cf271fe70d93e8a93766cf469133222337b3f77d8521a8cafe27e8784f1d7b62b03e8b9a16dacb09df87094d6974125a0d896a1ca4ded3345167491aa44b436df27b619c0a0b041896dce30cdaf455aa35d6e2e230922b8da251748a0f62baabccfffe160efcfaefa4fd8b179f5acf1a8f9c1555f4a194fb4826dd654d7a6fd6e6bbed8a8f4e650301716b803f0c995fbe55bc2ae34341e6756e040ace1ad3be67a1ebd3231ba5bceb08a3b0f23712289f6e02323c8264acf6567faa33ea44d252b3eeff2d2ebce7875e34eca673b9144ebfb12722b21887e3f921c5700e1207ac69318f9d5c266be7f919b168e8166ecbc3e9b45d3ad11350c35fc16b08dba20c5820f65c5989f8a347fd3f73b618d67f2fd44f81b5824612672ea3bdc239a78744908bd15c0e4995d916745712e1bf6b4e3e549157e471374585366722d13f9d9ca852693982ccb353073989db2f5523ea08ac191cdbc4b5a7fb6387435a02e541a141222a681188b57c298cfbe9c64cb8f9584a7231190df0fa98cb1c66c9a880153d7c40746dd356ff9fe8b066f679bd70281a9181a7716ad272857e9cce8fe0b2749b77845adcddea278e364cee83b099a2248255767efc9b1547d3ccdb3522af45f6ba8a76e08370e255a57e6c0f5d48f039013cc78ab8e117b07ca225c4a1cbb17a9cf9eb17a8eeaaa57aaddb232d2a4a5cda689e684679b98207506efb0bb5d4d5bf7a7047980d587fee75ae1663dfba25ccd8a333edeeedefc09f9db151c9556f4949eedd4312f9f20ed4d57fc11e2143daf4cb9349b7970d68604d06ad27ffc7b7f620f465b9a6f03c14c18953c55604eefe2c5992dd6e1018f755ad037d903dc09fc18b6785132d7e5c4555b122ee1bc4e6ec6eaed0b2e1b418b2c7ad4a1c87544b928b6fae6334b052dbd4e231b523cc7667a0c8fded4789f7e2d7c751d99c5151edef83dc0f5c59296d8dca41723aea40aca1ef20aef41e8637724eb2a5798ea5953a9a31da8598321e84d10a022ee6ff2193479ff38f742bdb8dc1c6178a8950bb3edfbdc1e82b517884d259341b356d4ca089129cc9dbd8bc76e7198893ea8e4d7e8b45ba5f7eb996712a8d3d0ee8d2a03be41dbd150a83281a8000f5b89cf2c24e03359475efa970319fdb4fb8e7b9e1c3c29ac5b9e7f47f395f7468267c585d8f46732c19941db3c18a8df64616403a970b40ada76ecb5a5b5eee85d1f1d99f1f9e4ee38ee75a4f7ab6a75e93a68deeb8249018ebc54c10371d4f2ed64c4ad8d5f3fb8efbc02b33af67bf0814b0aaa2b36fbfd1a3f43beff1c41bdc10ae22c8901caa84af5ba411aa3f85ff7595fe649d5c2fa7ec5f59c8cc21dbb3e074d7fcea539d4fd0c1501f6040a2b16e50133b0718cef8e6910809d8e05f2a28745af9fcdf892d02d69feb3c3fd07ada3c4192a241dfd0b5434f3f48c6a6e90901f44485a2b59c7c19ae8040293adf77ded07beb7c0161e667785e9ae4b16fcfa93ff8151f42ba5630d2e0470910bfbd4ef8cc87dca9e33bc790735140ac7780c85b2910441c6a9f2078a3572c185ee90049c99199a436b066112e39b6e5cd6ddd5b0f2e1591c046639479107f65f20c48e610d21602c19f36e5f015706c1e474185c989ccaa2287b20d7893605b9d812cb75ddaacc97eec86603d7f6cc895ce0c841f3862ce5c93040033d8940cbd806451b54ed8650c6423f7c72cac35833efc9a9a7cc6f7f3b6fd6b98f2f5f2326ef87d44a24d0ff3a4dc355ed228e56ea3004c484ffa1f3d344d96afe3ef23dbb1f79a971dccf823c70ee860bd7fa19c9484686cc1257fdc66dde44cbc8cb09749384dc45de67732fbddfcc8e4b4df24859288d15372d3722b5e48166b53fc86f26ae88c1d7d483132bb9981eee71cd14cce82e6d2eb858ec1614c9c1ef5fecf653211c03fd8932cee879e84fe625dceed8f115e37bd62f95f4a5325ec639ba8ba252a2494ed969ea626741181c94c339bb5886c80b54fe1903bfa2b5cd35f325f72caf334d9a602b0d1c29b6b0451ae1f5f20f3f6584ddbc3612cdf75d4fe84c1ed9a412375ae9b3a56df130c2ac351d39827efb1e03b47e493484c4cdbfebc4bb419909d725326eeba6f82788cdf521f9ffd80d5fc2ca5091227511eb00b88d043f503710dd3f07327784bb9588a1550ab530f506910fbed9a5138e592140860ceb39168c963db98571e156ac1a3e5f6e51b4b0b067157470be935edfce98f39227d480eb501350a1898b4433f0f276d854b6558fd4d7a06d320923fdf893b89f8024b74e6f260ccb5d4c5c0be26d8e13bffc05c81c0e7a40db1e5030cab0fe7c6a4fafc1bb09e4f159b52edcb0de8940cf5b4fb661f662b4ea370105b7721b77e98a9bf9907e51824d18d40b30d56d92fca56a619e9e4a5a5b3a3369b0b9228d5adc3a6baf19bb3367dfff70f8dbd395a86f901ece75a54f8ad3d56838532535e1e7d35f3e8772e84a4a277ff964686398b3b7b82a74fb5277f308af3e670fc88c84345874eafbb48b3763e660dc72c8ccfadb20c8a84bf615973068e2673ae19b0cc01f8dd804322f22857de29b018bfafb0a8ec83895fb8e7b335944d4fe54df4933268497b8eee53d87409f43ea7d300353b097e07860e7c923bdaf969489b351a14b4bf1ef4677a907eaea04c539efad2686b0b4232370b3ba394af0859bd23097bcf10f71d3d5d1e882ec77ebb725580e0aaff64daec6f93bdb46440b69a90d889b226b3c3ac84150f258a25dd6c13c40a8a650c5f7cd789e52ffcec1b7e6fab7349a8a1d3be56f8a5e2d5ad5b8c8b95be5c287ef6e4f191606c8ad7b7ee918087095fb0a84fee5523a0d878222002d274e3858d3c8013d461f06236f2af7b407701f8ed42c512c667799543a2fca62762a644cee42079827ee5c1ca84ffbf2ab2b6b4ff6feb0d452804bfec0ac2a9317ef8dcd1803dd443379747024a92ab34a160bc237020999cff53d468d7b40581832360e061c5ade4348b7d8118d20c9cf174e02e68666822d4ce7731a527766df5db39aa779e28d5ef72d42be4acc6298f8ec10073eb45d6f0a8641afb249e9186aee5c3322de036dee26496896756bcef0f5df9ec361fd6784881fd54a981088e7e3178d38b4c7a5382f1ba9a965aec1ef27bcce07de20a1c93ffff290c60b4e9499b5339e008588fb8579b86427b5a4c305fb0c59c78ef04281ea732e6bdc45aa7a7e60b692f6a555468e9fb73b384ee5b662c698b12f6f67ca8f45172761233c0e27b63f7ae4c84054f6d7cb80ab91851a786bf24a3322b857d33e9b45d50b2a0e227f92890174f2c2c066d0511736a5a375d6575e96c652b0f0e88b05d6d5956d9064c1d0980b833410be73907a0e81f2037042651a5ce69e9637ea3f72f1a29ad7d99b3ccf8794f7572013cd69e5205ab24d32926ae7d1f8065216a595fb96bcfba536ab215534f933f7adfe663f04887019e6c1285186875d56be35ad1d024a759b8e93efc2c192132d9e7fc8decb0bef9a2e9ac829e0d22f640a16c30d7ecd69b6b878f10de44bdb5705b489c17ea943fc07a1428cffcc487ec5aafe3c28269400410a8ea8bd37f75e44b29100a649977c4159e41e3b7f2133b412e058531313b4df7f3e5a416754d2e10493cb700dc4ef120399f7533d062dd83190d64e79f7efdacdf4da4d1c81818226a63402302a703e8a9c3e3c9b7e0b9dc52021786ab00e791df4f14023f7da56ed4517480556acfad7d922e66729ed59748aabfcdf2e6bc729d616e7798008b425394699f8f19afa836cb58a72dfa84a8e8525e342c3cc2e8acb015f111f251cf5a2d7ce82f260dc1bfafb5de3fff48f31e55b06f907b1da37629e0e41b135ea795404c5cd81ccbed06bff7b4f3e33944a402f37b59181e82377d8c213ffcd4f4ee188262ae1211f81fc11648699da0fd44fbe74b3b905cf9ec388e98756c6706ab3c3913816b0d6c4b992381ca1038e5fd1c450a43cc9365660b75b75595b10518eaa42c0c808d84ec90656606f0c7c5fde4ddffabc89bba9e874cb80534fd217d0a97d7379226b77367387d306a384a712c3757bb7f0c766cb84f0887e2775306e084a9508601db86e8d556ca5d48deaa26e9d237c768b009f0d8f668ea8ec5fda880ecc437b5603403d079665e7ef6aadddda54861c7cbab7f5df6a75d35a45fe32aad707bce7a5fcec50a54349e2c5726c5b68f28857c271afc41696da318c92c140f34fd8fd99f84d40e2bb77b24e209e5ecfca68cc6a16161d90b5841725399eca5df3d7a3ba55ba7e1ad91fc9c8d7ed64c798181ba896b816d8cd1f331e417f48ff5405c5087f38a3d85dfaa5a483319aea55992822d487328037c9379a3f55cd8ea0cb032e1451550d636682bf6dc98d988fed6f14020ee898e33e8a1a276db3e005ce9653b42b43036c43f1d02620bbbe09815f7a6975d7558f2290db3cd5afd49aef74c9d820c5fa9dc0249323ca865539d99ff33d6d3e225a792194c2f11d848d1ecaad5fc79fce9e03c0e28253dd42a412669c56f68b984500eb3ac0e4c5574609abc68f776ac4c4667fef9643df874f407596111264557ddfa65874133f0f8db5bef1e88c95f75d57050049377d14681102dc10906a0fef59c2aa921e08b0e326e2ac209f654d85ff90b6587f879c03c59adc7b7b1429d3d544fd7f0b77f5311224f7c34796bc680dbbad3c552f01474eb1e335751cb388d1ec0d05a63dea5e6ff428f3e8677fa82870cba39f2af60c29a8d8192c871ca4f2b3fd06369bf3504da8c3400d513a46cc1191056e4eeefe6af1f11e22175f2cf5f881ac5ed17674c4fa368209b03f5114fa9d765aa83ccbfc2d8004fa9c63612eb5dc266287c9670806f2f8ee34146bb9a8a52501134bb19c4f4f2d2419132979995a12ed8789ab703fc7c892ecef56d6a49de58342c3ecd28743140161ed19e78e1707af9bd9aa2a4a32be55c616e3e21e8cd35f8d6290c0d99f1208d469c8eea09904acba60f84eb95daf3accb7e8b1cee407279d4ec8f72473524f03d9d91d1a02320a3be9a570cd7a63c9369b69252237127fdeb5c8862c9215971d278894ee0810d9f98beca23d2cfb798a4f7111157beb9e0d3d9db69eb787da7537b7955e85df7e91fe4af8bdf9d9d637fd18d22b29d76568331a4a3ef89354ea600dbb48732110844351ab281cd1b11c3464a5e7ba0903a69dc4c7da876dfb59893e53b156b8f1f3ae431e6945a10985f5ec1275060befad0f620de621ba319bb19e462294443065c1a79ce20cf8127d4ed73d90","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
