<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"145a2ac11b8bfd163aab1248a859f2d06f569bc15965683d60fed8de2ef379d7d726751395e9468774416db7e2d0075a22781e72c03d92441d0a3db97b4d434421da4d0a3513f3ce2868716699e2ce042abc09cd20ef6e723ace130e332de4718d89001bfe08f481194983356862c7653c8b1453e9f08d7ccc7db2e725bde5b2941c5e537d37beecdba93ca43aeb92cbd3da675d5e15036e0dfa93d08947cb606c2d2a258e7eb267c7c07047a135ba2a6193744c2f93cf9cfc083d12d66f0e9d59838db54c8b1740a7e192a0dec25d50dae2075fcb47633f7bb3e5121f3604c940e98c1fdb2c8b6c663dcfb4a03879b30c42996602e6993e89969f3510b7aee8eac165b487e05e31d31aaeb956709c4cd14f675d9553a04ce0e6360aa99a453d7455102d58c52611148c62b8e7aca845d963677b94c5643d0a669a24905fb6983b3e3e5e548608ff86ec0a61c648617627e4815ab217566c7c32caf03bb85d0f0dcc82fb3f2052226514f91dcd1c3e5348c0eee033a2dcd7605317785c9869d7b8e6f4633a42f965b3d8a2e0a5fe235c6965b6c01f092ca8ee214f179fb4ed372287e56e462bf295e708a2a360fed0f28db5cc83c90b04534c7018a2613ed9a5a81df03672f12b934f08e0a03f47d9209b043130cbb5e407f751db155dc00214cdf0b22f9b8464ebc3555a3a348da5461f36219126d69cda62890e463c6d4cf67ae500169a4eed354e703550f9cf14d0ebf0b89d10c2a0d6446f5647c991ffae98b0c2eaf3b76005d9b040c82be12ff8f1ded86e1c2a77b0e4a2d8fbcd5814288eab7ff21b2fe21258a9d9d80878e40f5571a064f31274f3509a386c19d31d11768547ac3f1bbc73ca3ce48f0217d8a010720e0a6e0a50b978038623a6f624056226dcc8efe4c6896c99d381042b83854d02914def79c7d6a67b46225eab29d220d7245759d454176e02bd29c947ee2d92f867998881135c28d6ef330f7d4f2e1717f0565abad975cdb70342dcbcf97949927166ad5c5a628189ee0dc1fb8170c18a527388ef3cb20c41b2be9076d91f32e8382c424f25300e873c4af88de403289aa7d3f54a95eaa377ef7cdfb63ab24c430fad2dcf6c0f88710a222df159e387698a9798ad4f88bbd66ae1c59d5c3ec130792c8c000354e8cdb8330f1f73a34ee3059aa46bc629d4a0c6c1e22491cf92acde1e9d07cfea1f5b6b9767deb9a961872dae0b01056113b5f401471ca0b778b7e182255f136693654bb00be04179e0f36dc038fe3ce270b911d0be1ee91324ff35aba4348a4d0d4879946d467b5517c336b0f133a3312bd4b055a71c075087ea78ee0ded8b4073a9bcaa358f76ac447ee69b023576d4e406c60a13b1fc6c59585496f7e69311def4e09bc2daabf5cca125409aa8a543ded19983d0c5513c9b4e7f79b3a627addc8c4bdc470371665679a7d67831f965d022a421788309c6285d858bea086cf6dd509b3594d65a37e1d78509eae06bcc843aebce8b55aa003bb2b012c9480d54ac5a3bb5f0cea21a305f41199212d837eb7fb199ec8375b3fc6b914186de36ad88214bc4d5748396c20d2e39829a5c1d47f7e7c3044557eb4632a4ac77d2c2f1be3c38c95a9d9631096e3911d69621dcd1e5fc457722d5e14d9b5326b5b5981b523dde5fa350361311b1e234f924a07634035d8bdb756f169c38fcf8d4981907425f75a5646d2e6a9409d4f170e66c381c3b5edb87f43c21e77cb8936c19e7b20c3886386a3155d36ea5a355b330959d97f7c990e2bc715e553f60da9cb3881f8ad541856a1fe95e9fe2a9c125c8742cdd98db9dc3a520b95f277ed226015b121e0101beda0ab8a5701fd26ab0a51de2126d3ec85ba9692026d7196c60ff89068b98b96785100bc61cae0a49fd1c9278cc0a23cd68868655d565e50b654b79d7598792f80b2c97779106d8a918d870b85eb5980ebc3ad6e141370a2b1bdf46ae93f0afba3a012d3a8dace19d671d928e2dacd4841496b08d77d6a3311ebcb7d87bd2b883c5ee9dc10a98f80aaf52c96e90b17e73644e4253b8eca7ae23986f1fdd5b29f9e83ae8903c7eb1df77f1b89e8802da36910740ad7e104c8bc5edf664c2b88fd5a982b870fe51b77bcdbf73cb042d0f4aea737442438051470492452447f3d7f66c531cdabf9db17eaacce45847121f2af85bbd744f874d1ac21dd094f2b84709795408480d77336d31ae8ec823dad4f42d1357442bfe7b8139854917b51215319744c6029f3ff09d7b5685d7702e992390b33adbe94b5295a3bc7277fdd77fa8128e8410606373e3415dc7737e7b8900907207a3b972239f17fb5ada11497bdf70d6dccc2173f03972a0bdc26ef44c7ba8727fcf0f7cf0babcae05184f0d1765fdc9b42f454c4fce054aa9a32448157d16763c684451b32800c515a47826f4e09b36db4b06bf228f88c3dd39dc23bb097b3a9515b29a298f78e6c53cda50e13499f6525b042226e92ea5a8cb7fcb7ef0f444dee08ca209437459985c50bb316554bb0e06216fc9b924dd229265f24792bd2f56f5b1f1f7d655206eebe2d745c86349d07f2845e745da199ec90321876e84a23610f774f24adae82032e7ee17c3dde41750cc84b46c2a237849363851e81f62b3b6f0047103819145f555b90224ab54af04c7a86f019e5e9d8013dc27b48c9c83d0ffd013865f8e539849d6017d7957e46a5d78a802d95c097082ceacb1052112cf5ee2473026aba59de4340ea8bdf768ccbe465e1e730ae00c305294450d3ef03c70c6cd99246032bb394ede42e51999aad88d8041ea2ef8857cbaf89f829a43d7fae01eeb7972245f16f3f5ef5ff9bdd17602ef8863b958ff0c98f4f2c8d3cbd5bc0f63b7695411ab72ecc04d5e33f3703338368655b902f8f834a16215d72b56e2fc18a8e71e8145740e00dbe44e22f98f881c7978b81f4299d1de41ba84f5babd14aaebd560d46b09e04edf4940f56615635a6ed193fd44ea8141d0a92fc90e3eb32c2e71c124f7d0e81a3a4d47b4a6fa36d75b84296b4dd265ba230d42aa0680be69838a95a6387c0878036063d006b347ec2d8cdee39e0a889592556dda827e09bfce3d395d378d896bfe74607cd9a29b113adf8adda569f3aae65f6dfd1d6c853faf89af92978ccf788935838fb86fc67319f6eed9e96944931d9e545381aca18dd40499e2f4ee58d51a33d6c2a5d77ad4c6e529c25757314b9a942e5027ef24200f29268bfbdddb22aa2b22ca8da446e767cea0d059dd4f5bb60282164f0f40fc06b78b3ae504cc061fb11af1dd109ff33e09450ae71a7d83895856d1796d6821d1eb916d24a5c6f8c524f1ea1a4bb623a87b5ec1b0c122bbdfebce11479923ba0ebd503716981d39a6410561017c9cf799a4d2795aa31d021311c84004140b992ff3fe26b767763800830fa4c39acc2f19102b357b5ea1d450d9aa88ea21e1c27b5fff71cb0059357cada533a6300af72cd50d4c68a4639a5f43ee50d6bce4ff38e81b07868cd27f8d28b4add92c04a77254e101e1a0c62f09b16d60e7e64235644748a60a1e91487ea89572a233f611b9eaacc0a86604fe69d9d3166da07697f1a77cdfb6740f5d9b465709ec0ba8e50db3c348af60991796ae7ca3045f90590ab633dc4084be637b57f5f5485af427b53c0d7c611332d6d083f68864063397dd8a2b0b38295d1fa4bbf3a7378cd6feb794368bdf4d8f831ca93b9e3cf622038a7426109008eb446d6d065f4d09d87b19edf72c86923ea7a9ceb22a8521055a6bf66a034fbaa413579b748c9821ec4652e74a3927e5b0b7717cefd57362049e0d691e3aa91f208f7a79bac7ee570eba53577d6515388b906b1dcbed1b1a16a6f4d9bcf267ee7d939cf8cf4ee23403c0390f7f5c2405c3ccc56d208affa18077ab990e93687516c55edf051867107cd4eed139053f2f7357da49dd860cf38066636677a655dfaff0dfb575a0b67c050aa92188297cc3ff2d5e3eb56fbff88d7cf6ffa60fb53fb4920306a8e88b9471674debb28839dfd372aa08be0038ba01e649c5828409458a9ceba247dab2510c26617f38293114bb1e962cd36cf8d5fb5b2b54bd549c148df2681d4a1b401276398d15b1df2856688cb2a39910b782331a9d9a30322b97325dffe62df8bccfdae76de6f454d7adbac007a085193a9d25fe7ee9c7d4dc3e74641e3227bcfb55cd6d46d3464bd23c63f00285fce5aabf426a05d9af1d4d9c9743e6b2727689fe0ec24b265e51b0bd2fced554371745dbba1b35a9e7fd18bf0b98eec78885a2d84033d0fb05e98c67031d8db3bfb901d5e2274225a4363db2f96e9074f6e0d107c4530047bb6e4256c5541d48d89cdd6217a7f69ec8d7565c376b39c5023cf3e064e020188606a3200e1454486286d64bea57f564961d21c03da4e5811b9b9464c59e9bf6325c2703426473c580aa2ccae55fe071e228396b22d6e62df05166504c0c9d6c3d86b7a9a3946dcd8a27b16acc4f4157d6d8b0e47edf546bcd38c017a020319f921b7b3f8665308b36c74240d732528aa8217cc9c50fe16c67e0a8a849eac711e671c53c4515b2e6a88f9d70dbe1543f78df7a021e20d22d9bac59044227288c174e64990a7c2b5abedb93b8377c68cb8c0602a9e76fff4e2ff67e86bdb8994019b1942b2b0dccc7a479c1ceb9bafb1634c66265284851d3e2ecde5c1e580d050479316273be63500394321f76e18656abe7c5fe79ed835387ea055ad30e8de4d2ad7f02276aa3a118de1b545e9ae73a7fe6bb3b2b40ab3c9aa06da617f7c6fbd26159f36e2911b9277cecdfb54f6962f6c3b2e8c6d6a476bdc6e969da306a960c1cda8258b6f19526b9f4322c2b27c56edbfb500be561f35a477d17156277765f89eacbd4271745eec83287fc7e4162db79f510fd032d9cbbf2149407007572e2128f58b1200315bb5a251d024a22070604d7469d8aab474eb71d0ac0cdcef99d77cf3c71a36d1d85c6cc2f52fcadb977f8b265fad4c695606a1f30339bf64bde19be5a8a7bd7292f132b7bde3ec2f70fe0c67891dade669923583d99c9805efd2fc034b817b01752dcafa115afd26e5077ca2ffe07774004fe6b6e8c888e790a32a1c742708db93679cbb873730b29cf591f72c36599e3ac7d73c644b1b3c156afb3ed71e609f39cb92cf344f800a2ee9797863b272fd8685acd67b261b9ce333ae2ebaea182d73cec765d49fbfff5ea4861510947b9244fc41f1fc4bea75734e8a5700344e0577390fa4138378a165c5d7946fdd4447cfa7195267f4461005f6baeff31644ffe90977733dc798a4fc4858c71e2cbcc7a06ef142059609f74fd809d41d8aea21dcf2af06fa8885dee255b90c3ed44006e5a91abfca8fa42d5198b11b7d47ae67ffe6d8ac2f280106b2508fc53fc7655bc7de7116da8c0d06d05e055aa4a7449023d1695f8aea956ef059f8cfc9d6f02ebef4f63366e29b283aac484574b31d7a80e8dac307ac1acbd4b0349180412d04b5b7530ed1456ce4460f469fbd91a24452611faa959057ebd48f1217e4a89c974c81071069c4cbf4ff99020d9395bd75fe2aa822f46bb46fee30a810a22b39fbee185ae2f5d902cb789064771c3134bdb052ff1004a1860c2063ef88e5d511fd314ae82dd1573d062643b3b74a08275e7f3ff4ac502ac8ec803b8381da1789bf15890ae47ad247b56a69d5e00cb134ec2c0fc5874c745dae43addfa0de8fc0f0724b712d4e2e1ea4ec3f8e5d01078f59b7887438870459e6128c129ef5d4af9fb1db7b34805871fd68db555a66d4530aab056a4533d1738ef94aeab1f6ef3fbc309c7f03584a3132ed527d9b9fc5276e9f24fcda538ea08dec6e7f8544064d42aa6d54a551f63bfc4a75d95c7196b93aab5a4c72663485947448a79490b9be115ddc53df1796d7c3ec4c4535ebaebd46ef314ea8e7cb9c7c97bb719e746cedc7764c570e81c13a830ae941b810987b32a164b57c07fc272d653821a0be94e3906e95fa437de86025465f877b0ebd76ab51a7c0a8350823bb47a641986ed07c06d20c56508423650586ee4058a3542593a3fe42d3f48801ea03ce4f38af9b95d79411e08424aa6833b962ba004fd12da48d75cbe2e3919279f20d741e589e043e979c66433578bd2f5827cd83f8dd14eb6fe010321064ff8e232596ae9bd1eadb1928911ec258fa14a98e7b36b9499107cb8b5710b68185f32266a859946d99ea6de18d6fbfc82445e8b80b1e552377cddc7f1ea5d0b71504b27c39842f0285f97ac235b768774486208c73096276a4a40c7513ff92396ecd766346423f11b6d26f44eaef7b14c09960cb904441d90eaafd3c4feb7f2cecb436c5223da69b13495a4247989384016db176acf0e6b65925b8f8eec2f3b9c6488c7272f621e53593c109e1813cbfbd6b8a96c28038c021f0e16b6aef8affc4733dc2d64578d9d2b690cdb4282afb8c194b547f71936a8f119f7e03f3f32da04c9385f9a13b4547fbed8a686fb9ffe29f0834ed97e431594af8698dc579b212aeac603eeea61b366ef049b755825b08fa325b29be88df8fb72069a30b0cc3fea54e3150acc94500359f368976ca46893d8789bf7bf447e17ccca6518e313e552ee92d837dd9e8cffe71208755f828aaa182e4e52fbe17b0fa8d23fe729b7f966235c0ca3ef2bc40d38de78d50bb11e003274a206fa9001b5ce5b7c25d04a18cf918cf57f8608b88552895e4874f261370c2fda09304ce69a9213431e758abc8797b9d9054df51b156f86bcf0345e889b5162d89ba496553f9975fc2a912c18d41c62e27000777732c423727f0dbcb7dde6ed9e60a56a8259f708930e4829d483d3764b4ec3869e44ee013e3da70f8e6e0191fa5842ada1748b0be4380df3ec643fa4feea882a4c20da6072df2c7c95fd5986db8fcadae232149a99e0948c96680837b8f32395f38e0ee97dc20007f30c4cc01ba5588fda9a9038a5c91bc2fbafe2f7e413b7a880a10a20c903fb6ada8d723cfbc359962ec85e7467074d64d4b2faa32356633495021cdd1a08e3e33038b7b5a87cb94180a44c8cee09b889bdbf5528f6f9d58dbfbb88a16e5291e5dff056245b6e343552f7c223bc0e9f5e55ff2f34182e93d2f8d8645a13f59dd3291ce402625028d85dc62d0e26b6c51e694988d90ed71b74c9f40ebd69dea526d89e18c838de95972330a553d9d37b40321406b808992c537b7d7f11d128830cd479d586d6061057066d9f50caf537f433f1c6f059a81ceb7f3eca73969db3f118a459fb470208e5521d949eb3c1484325f344907abe7cc1a6e7c441f0d182c2606df72d7902f1f3aea7ca0637afab83b1e9a382e300dcc0926a38d88bb8d233dcf73cc6fcec7f76eb1ada39a8ce9125a4a75508924d3d6604511ad68246ab1bca21d90ccfc16d96977d25700260ca68094d28cc5e14131a997e5528111f26c9112acaf6c4c87c2b5ac972606396e4f4d020d1a07c48f5ba9ddb5410733c7ad1e98a881cf30cc6974d7422d7b0e5b2c6529ff0bed91eefe9b7420f5b9a63e1787045a4fa955f8fd0e89d3c78a49c177e1ead84a0c243ae87d4ad8f95171371d8f630520341af35cc2c3e3f9fdbf2281b5ab303b73f49242323bfe804d5ee0793e823c77223c9790729cf210468b28e05e656e696121dc5c2927bdcdda1eb12b53d59cf6638690899038b49ea323b5a0d41b66b200430c8bcc970c8fa0d8181ff755901871e1024eb03f6cb7fafe31cf0a304a7af1b10dd686a1d607d54ab451d3cc13247a589b15bbe45de930c20ee3957b526f1fd09ec2540cd0877a83232278a1dde67f17db8b1ac17fcbdc47141df438480c69f76e1639e0e0f5729535444db2c84ab091e401f5e0df04aefb519d48d17cddb8af0509b2d6c14894a01987104b0840d4d65ad90d4844b6adf49be16088251b0783c981ada82ba37ff4ecee333a31a05d035831fbf3618f9f93fc7bf242003fb6411007e0b8437f39aa6bda50254ceac2dafd2bf65dfb923a20e5a1eee97241c547d9eea42a7df3e9fff32377dfa71c20968ec1acca468b1d141f72186adb394a177f9627510403f2bb45ab0e5fbf47a460da9e30e8444af8d3bd39f77a839fef7c79922dc820dba7a5cf66ac1029a100543ac15290c4854ca8f449867e271c56441ff8344ef1bd4493be7092434e676f86913b9f00df74471a094ceed7ad146b3c0a9da915835c91b0dd9a2f030f0e7b62cb279ab0fb95ae504d09d6515dfd717ce0dd43878e938ec73eb6f5dd4db443669dba9fa6eb7951d221cb978bea63556d8b500c2d3cde27826b961c101c7cf1c108023d8b5bb820685956f39595280fb3404618a3d0c2d9a9d4281d6c93ecd35fe4062e11fd034fe67854aa0e24b3f7ea994c11bdeb0d8c8a51e805e5d9f949b24f3cfc1b8bf675f3e271e87a72956faf2db8c36d191f69494185ea41e4b136824eec269a2aba0036b2ccafe80d4c07cd5ada8c4a40c81100f8c44a9cd413fb3a5a3f76dd5274a8de649968cb75516290c9b7f3738d0ebb8da7d1910551a46bf73cddcb3b301ffeae8c906d529197706c39a93e1023dd1af88d7e1070b457e7b87c4cb6e9093dcbd1c52842d825f316f92062bb29ea00c7c8d27fb56af8511f42a6a1347942352dd952cf93db6a150906f8ba55c058983e2880e6aea8ed134ba3b9ea425482755aa95a175ab615a693816ced74982f785b9f48b2ff6cfcd67864586172ef5c4c106e06908796a52cd9a39d21abe456768d61091975f8edee8583df2736c6d4ef6892d9636523139f450f797220f5c2c50701039c9be86cbb0457574ec9698c086428d05d6b49792882f6e34269236c2118988157d4bb7f9fa5a949400d253cb829156eadee48e60441549eeb064d3b8685dde88d59b25c348e3a4026efdc3120644a4bd943d93595bb32bb95682bafff621dd543e47569d0a4a9b55bcb729fd506df918a5f1c119c9b11a9b7dd5abb062ffc33774aa5de0dab5ed2f1715b9b6334ac7f3dae85c3eee2e80b91284bb0ab385fa579e98f34b2c3f8cca01fd8c6764865dba475c50202b7ce6b2485cb6b47082fad83a2c2c03f93d918ed008c59554ac2e74373e568573e0ed48bfea2bd1e557f0da64b66c83e680cb930a75626be8fe2faa9ac26f1d5db066f964e160e754611e66d0686b5d1c6523b99a2eabb4e4bbac96adefaa9b6adbebab576d8e5670e03bb109a0bc8c29080876e1bcbb2b9c7ec04d60b9e4f599b8f968dd425b7265ba62ea50f2c0911226cc464fd0033ba550cc5e785dacf95757271b6e9fcdb639a0b0bb2a893e3e44689fe9ac60598afb8073fc84199c802429ca5a9c2abba3b664abf08c3c9fa4377f7ab5eb5ab54e390e51dac2e39b2423bd68b72dd11c780606e17d05aaf9bb6bbbb2420e0b4164fe81fef9a911a577ce8a99a8cea9d4d8f410d14ab8a7db69d7b7e6abfb3ec26d376752e0b0aa0c173cf2b3f9771e9fa211b317561d00c8fd2e46f5f5f23d97d3cdb7c0dff1dd67d5150f6139078d884a1e90893f7ffd2a062907864428e4d81160af8a4b83482c02d90c28770c3e4a2e181a83c9d648b031978ce3cafb90628a93ac0e97ec49bf04fb99974be901fc076f8c92f1f8cdeb2961cbe73d6539ada58252701e50bcc255a0e454256eb263e53748b324a0d611686296470364f939639b2de6916247dc035579fec4fda6296cf5420f23f52a3f299c9f6a69f35ed03e27f38d0fdfcd08600231b11acef22747428204eba43d78959edb278a3a67a0603a50307e8ea13189f88abcef0ffebeab66f35ea76c936f78facfe30096f914d4788eab36323a2f63061015f5aa8f98e6cf03e093fee3955734abcffd6753845332539cdbe8ee7414deb1ee5a5d6f6feecbc79d2ba115c46246895052a23fd060315fe953ef6c67e54042fbeeb92c2d7d9ec77d29485ad05bd8c2db7fa74b0f962e4a47e1791d80b2666f754d6df5df23570ccecc8e34d114c35e7737a00699f588a88584ed2e72bc32e3aa993269ebcfe6e3f0a7dca8746d08ded6562544f2318310a94a2fc40cd93ab2b6ac043c451ec134a882d50faa2dc081a49fef992f6632a1ffb9355dbf8e1d0a223882a0494d6f08d8f2f68b767017fb7c8cceb6512aedc176830f5112bbae61cc0c79e66a605cb1f55262799c4e73625ded98ceb60ebe8996b2f9ed3ea18af7a253c24b216e265a3678652accfa3752af14bd1d2a0bd61906bee2048d437ccabb234cb0848f8ff60ecb05766f6692ebbfe85257ce5484dea1d515a2aeb49da67c3a4f26857752bc79133e2e70ccde9c76962ef352f011a91baddc12b40fdd408f6830d24a16a35b784b1738b3afe2f9cda40e241f3908b83973a44b657912377dc0aefffe43d039fe296ef198e1f5e4b06e0e8f52f2de01701c2fd6e49b747eca65cf77ca1e86ce3586c016be432fc2ccba552d5b32daed879ec2a36bf607d0276eb0226319f4f82920628c5ed15eb1a46de48c61eecab4c77e2f29ffe04695dad32ab0c7eddc2a2c19bbca8e00fd74c97ee57b2b6572bb38402d3e67d61e54605ce26b9678d510318bd3483ee60a63c7d93de11a6966f07393ac20ba81c8c22879364ffa1979cb0b74a661fb11a375736a7eae88521b60229abe1065414cb11a5be86123a4ce6ca3188fb7d54af26a4d2e573d26dcc884ca37f1c91cca293e9900e267d67bfe865f5eb5fb9b5931dbfa2a47da695aabf4c51547f0d42f1002d50b7780a1b60162ccca61c485850d3b2fc0d8b255600c21c029c6c088cdf94cf6407199e57e5b5c2fe8a3e9d49179aa795d47a6655deb4456b2192ab5d538fec589193911aa9a06c3c835c15d8294bb01bdd06ed06ffb04facb1da8b7ada44b5256d40b2c3762e7c5ab2b95e8d2cc32cc73f2693da6cfbd1e47ded90706ebae915c4cbd4bbdbb961551c28f669fa9a640e222a77fe2c5b70e8d009c744508c400c30e38b864597fb64059dac5b53c703d0cd7b25291ee56253cf25943b76f7896702a86d7a8c46ad4793cf88a4cd1a399bd4ec4052bc50b99b75feef40096438f5410d5eb8e92d90ab3169da51a22eb7f07767aa73bbbe3c8163f309351eaa4b952339c53eea1840b6826f24c42114236c43b74a1d469987c12febeff19b64c342f8f0f845a0940de2255b01ae467ddb7d399a36351a7d0e62c8b6595959dad6f5bec8ffc45dd70ad0f4d855f678ce621d19617b518e6fea9deb15c3653aacd3e9fbb3e021ef0edd70db6c0999b97f4619ad6c038cd5fb823541d4533c59e0063350cea08f7e8043bd18a6df680dd40de33aa190e37173e4d6514efe5ba517d115d9299fd02f6f7377bc9513b4f7e5713ded33f54d7aba0cb086faa2a243ce6395b9b6fc57cd58f65b7d915c47266c6eab761e4e19e8eb13a4bdbb8bda1c7268c85faa39d4f881846e0b55814e69f6f15c5fadb91cf0dc60a5e6c1572b74af5aea6ddd0dd1e5e3a96857b4731e514922423f6ac94af9a42859df9bd4ffb6e1ac06fb46a5a863d4c3821ebe96dfacb0392e2e6c5816ab73da238086f55200707b68738e524717124860cc3b598b168e9fdc0d40fec5851bd3ccd9896da5515450a2687cff271e31edd6a727537788e2d896fce2808267a77909809423f3f3dd80d63a69e85b665e11daf496fba47c1154645d8b8b1b092856d51fd788f568d817f69c11fc9841d1c42ee9602768f8b9aec759f75176d50402f5065b4d3e1146d79da8d5c9eb96519592a63e6732721a473be2e406b8cbc95c73650a28b2c41419d57793102882a071e6f61cb10f1996a79d414e1653cb6bc380fe917220925b8c5118e4ee78230b7aeda85b6580d020455c6639214514ff992d9fe62ed387e353e6360cb8c0fc391b7da1c3f7f4568fcc58cb3990d8a5c3d5d3c03d82b62d96e77f8d38191710c80039164a9f33a13296dc73e78c866e221001b39ad81ffbf838d9d40ff65ffeb399df89c02036386c377b56a590d458839fab4a25c97f4aa7f547397444a560ae1d62b3b1a1d27c06dac2f228b9dbf8017ab944c00b962ee7f5eb614dac72583bbbea85f675f9f7f92badadfda64c1b738fb12dc054361bdca32837cb156b2037a8359cd9bd3c858300d43a6c2ae3a9db8fdcf584bfbb9fcb54b30557b4776dc57c32e226c6998eb55223f4ff73ae8af316340063c5d2a20ebdb02da47c78a2374d123decb423910adc363c275201d06cc5b3f110d336da0f50c81011a1332d7a62ac8019d495d41b2deb4d377fb8f113f0b7c7a99ddd64546bc6325b15e5edc0a09795cd4506c88a9de41d492cd509fc9efbd6e1fef78e0fcbb2f0579a25fabeab61d41d479610d7493881457f3cc569367e6c3c9755062d268569b51ef9cc30dc1db622ebbc1402395288b18dc923082d274efe4aee40c4956e4fa292f6fa4eee1878300c85775c6570a107f97a4a806e93d10202fd46aecee469437ee7e914fb34fe7ffbb5182ba27d36b989f4319ba7547a4899aba7a2b31469e8c9ab7bf45f32acb3572fe6857e5fe437be42675cd2aa04dd0d2684c95d54953613651e4b092c49427e5fed9b648019f1e36e399c543abc03ac8972921c433e1acc931ad4449b95763c3665b132f724dd39b1dad218a30ac3e614f149a2cc18095571aa6d27ab4e3a24ce1deb98442dccabdee088e6463d6bda927d874611387f05767cdc8adbc4f5f71f7fa209f27f7955ecfa12efeb2d17c9d748c477d82aab68ff02d55327b979b774deeb71e4f2b63720c44e4916ffbca7cb45f33c3375fa8265401b748395b7a6aef495a33e81fb3a1472fba1785bf5421464a56c24bd25e76429172c287d474caa7bd0319943412e6ac6ea52611a5072fa1cc0501415a6925f8ad86360a813adb973b46b9e720cf61916c6a324697c13dad008f5bc439bf71ae0ecab31500dd27abb9cd00a306c432aa8bfeef4df036b8871c3a3bb4c03143bede00537bff23e47898ac292da889736f56e8082165c1a7d56e5c0bc1754e6483162accc70499ddb2fcc7375714f7f99abcb672beeee877fd5fd182fa3588eb2f493cbc9a47e92325d9bf2e3f57e796a1cc8d2ac920eec2dc391a609f3f4c7791e48999824cf0c6157658101256fae383b78e8141934d746d78b3914458d01136d079cb616af9bf0f7efdfde1df981d78ed02c083f4acba2a8d44f3e5e3445b1425f1b9dd29107c6d2a2e061109b7c9405867ad74401fea46fb702ae35f25043f5a178f3fc68d6f089996f41ceab48f52eacb1c19a4b95f82e7dfcccb02d1576af6d3b03dbce30ab32b90105eda0ae0336dda4743ab50d62ba4c488f76d0ff1ad740acada8228aab3abc001475734028c349a7cdea3972779473c07d6ba7f43cb00bebb9cd7885c8f608678c1fcc8f06621f2c5f9d91be617cb66c5db8c422e062585b367e29979a0d2cd1a03a5f1fe18db4cef53b13c830cac50bd61de78baba3063a01c05a72f9106b88fa4282b1749a63ff178709685a123240e5d002962a74e161ef01f68b9b567a2b08324906d6c4677dbec9655bba59bf2061105f848e5750370717e955fb8595561662e19db1b9c9375ecf912268ead21918e525d0b1752247a293904301249f4daf6a0dda8b1af41666aa5dbaa7adec1ea3dc03385bfe3f37943047f824ee84a4a5a8520d11feb75ea5456025f9f1e00a876bc4941bdad164ac0ca1535d72c5f7be0beb0fbf934a63248777e24989fd13669d5ca7325552e86e5fa38eb77470f6a12172db8fb0cb1aea4ca134b537e737f46f2c6928d05bfc014bde4aee2499b03e1d7d19da19a1bb5fbc18d76d611f150df24c9b21956961e8e4362a2c0c9f5dae4949f907aba33346a872a94b02a9ce80ec1aa92cc80459b9d2b1afecdca4d32013534842b43fe414f48ae71dfd1c1364b51cc6e47845d92a65a37149ec49df4e160ae7f98050e4d42806b5117be401cca0827564c782429","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
