<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"752d95bcd4af1cfbf1eed22b0ec0f8397bef656408ad875f00767d87d21203226fcd93f01c3b7c26009ae5e140a0eb5390e72575812eed158ca0704ec26300feae66f7c032a201ae8376943b2acb7cb2705fcfde767d017cc7de1e6ee12c12bccc0a8a38679fc3e71e002049f05cb8bdd3a9acf0516a72685002817ed806f46396db45ad8a812916f9fa4e6bd5aa7e5396e2cf5655e2b07bf2584c01ec84460bc83260a5df2e2b0d8bdf986abcec30898e33858db131c69c422560d33e584f39eec1c28cb555426e791b16c5fcac5b22bfc43137611c3c270cd15f90ca3f1bc7fcb4ffa711ed50ca4786a55bc52db27c2de92de1258558f3e3765a809c1b42a8848c318be5c1ebdde38a987386962734f0095623c7dc61281b2108e87cc446f756e0b9bca10c26093d835794c72edcc2d7dbce8c261ac8816ded70e6d6ad5abf2003f159f7b10a039dccdb8c18aa78191410731d184a578fe001300c988392092a908e77ecd91feb49b2df780123b67e8e90f86d4df949ec41fd9404e362870037b58a1ed1cffb4bafb77605531556cfd38c332b53a1c696b6c4630da563975135b83567ce246d68a81e4c83e67a74c1030675ee4a01fa0bb625ad561d79acbcb26974a85bbb31b793dab9badf93d65ade22014dff83cce0340984174cc952246c514b13ae298c9dd6292ff442c207f8c214d7aaf60fdfa949db9699cb597c5efb67aeccc1ba1053a93f60107f2edabf717d94493c82f50900074cba1c59de2be0d4b5a68e853a77c4ed6dcfe62672e90ca75bce7c76ebf1cd5212239f76efc3e46ce9a40eb0116a377eb3a7346a9e8c497d1d694315ccd43e9a9c12d842dbb8ae8f27aa06a2e9a58e41d07e7e3fa5cf1c75c06ff66189031b5f061eb825d54f1fabf176dcd08b69f1c8c8f63c5db7cd19e64aa794d076a0e23743402e163f659254a2e849946abb00beeb35cefe6f94a8b1c296f3ecfef132277986637d09e149396684ba03b0d7ccc31a125eed226a06905665c9ab46e1fcafe9791d98a91ad4c049d2626b90db56ce052eee46c855dad3e9e3529fa9b7f00f62b6123fb13f5d9d20700ac1ac2d1f09100fed962305429ca211936ab04ca017807e63026c32e17384faeafb94ea14c7a41b36e9ef49cb8d15080d7599438f8a598076af50ef24415a140d086071201b8d9f0d28c1786a8eaf941fee0fa2dc85f648ee66fd102e31979522f706142a24e80c30831729993aa938b0b80cd26f57c93af8a561f793d3eba8ef50d3d7bed71fbcdca3bda832ae70e46b1ff5723d6733544496d24beb8fd1c08ae560ff888bda0025b39bcc7fe6db11b28a442d21b742812b7de13a5be06971c267ffb6d15aed3dd2facda6b98af68582b68365a7af191a6b5f3ccc2c6ca60e3aa4f0e32498f5b14b8563ae972a5c0a5094aa1ebc04594cb417ee2ce6737d4bb62c265f056edee01db7bff209ec01f1680097a29864332e9d2a9e5f6cc7a159b188fa966c35c4e97fbdcd10e12bcc938b602da359c2053cce2fb9e67aef47ef0789e746433bd310984d6b115aa5f8895fbf38d9213a5d6b3fb4f65e911139c5dc86c26fe2449adb86d7af778c83db66d716b7e88bca0acefe74f7da467a633e4e1820766b9ab4c3026b4c77803c2c21d1b360468280b93defa9f252f9d1e4a82376533d3e6ba884982cdd392cc3d64bffd3e26181879cf0f2fa180571a3e4caaba1920f1104b7ab80583c5c83aa618fe3dacdda673566ae4a55b0620dc8600ed7fe7a5bdb07a2c8a79fb9a7b0fe32a7e2063402b57417f2548c1d912425f5fbfe07385ad2c2a1679b6f532d9ca2d46987f5ab1c383b62a2c56f74cfdb5a0aeb55e9d6a31327ed2c38b25f8aee03bafb285df50c28fed97f320687970711ac765b7e204d91280b7e8c15a9393a5a6d12036ec252c264bf2f103a7bfa215c67337eec26eddbe8f7c5270b1a548592226cf89c82be603f9c416ba4d63c6f749a5f7d677837257ab39354c240221f2f1803eb1a78c44007f7949bf3a4f41b7079312839ccc02981d3a4f578c53edf698508ee1fba5fdd040c398ad36f70cce08565780d957e21b02b1e8a83034a1e3ab674a59bfad928b3fe2df528e2f139d0304449f09d49427e96ece2905096b65317360a00b36ac9526a70b5bbbe1109f7198c1acd7c032573c5ca58b41b300fcf6e45e993966e5de87e20efdc5a6538bc28961f9aeeb44119d6248d67ee09eac5e2b07a0d76d53ae65b95848b6d24d5274a5b68b3dc336391031b86c9375f06f095a291c00bc2d5a8ad4e941b0ec88633bbb350c0baee7f15f6277aba8a42428dd6d19458ad1348d6935182f264d47b996630a38900172bb2e68a50f063928f11f3b8d10f38c4d57537369de8b5e7a42e46f91fd97f0cdd636089a6165e45d4fc57ef6ca4a44e54a86dfaedca235ad6b5e9346f35230dc83ac7689a72e8d3558bed23bd05e44770b449aa21acc65085edf163717ddefea896661665880230979e78c078ed4063388db5ef0e6a87f958d95a471d589bc562e0bb881569885a3d1123472b4e84f1a0e4b561737cc030a2c83e8ff0177fef6830f1e7bf83a74fbd1c415d827a8ad1f4810db9d37e3b72e93425382b806a89be9376e75bc14943bd565ddb4e166435f426be7a5732f66c6768c4bf6c4f414d34e4e4fb85aabe2642fd527787e5ebc06f4ea66783f60b5151bebc645ce5eb238ee3cf7eac755744891f6a66f1e3335ff3b20cd3367bfa4debd282437ed4cf036dc0e2b8f36662c80f53a21e9c8af5072e0de0550efe4547b64f1e5564e39331b3b32033ea6fb08fb0f7c3e8a8b22365b3207fa1e157d578879ef9638133e9e1f73059f4c84654bb3a2685cf42df54381e67020c6ac127bd9619931dc546f9fef70005999d7d5d3e11b2b771d3b2e9b098f909bc923776920dbae10ead9f7c227f24dff095c9b65c93110846045e4be6ea4b357598f32994d97ab9b3e754f528707496d0c9951cc147612cbd943301dc5904723a9d2f02d8bb45a1d1e718fff0c25a994f57ae513af587330362f98428eb46097990c89abb806da731c8af9fb5e40bf6bb8fe26652f103f12faccac8317ef75e50537035b9d44ebd782bf60457647245d3a61bb9606073fc01a6b6a2c192abfcc47fe366c71a47a66ce4deb8326828788bab94efcda0c6ed9b5efb9ceed6b1ac271a8bab6113c349722b70d25ab5ac3a137a321d7e2e20f10ce05551aa4ee2e49de1817f22b5e8b8a314be8c588e507d944053c070761efcba5dc858d65a6ce9200bbd055e7b0c3b4e88a0cf34389412a106d7f7db17641b8e4803af2ba2f84e1e9f20d58f073372379dc8492229d914dd7d5d542fbd51444590e12cb692af9dc72b0aa8dfe947c9ff1b17d6d152a2dc5c1be95704d83af3ebb5bf603687d5b5a583c2a421ec223f8fff74af34007fb32c0469206de17aa396213380809d9a960b71b3d827de569998ae7b5b3ed493912d15afcfe444037da96038c3285f31980682c7ef9c095cb15fde0418e9ee8871f6bb3b56f8e1ddd509e422ebee42c47a5d40decb5446d4fb2c304e66c85e481c460e1e13b072ae52fcfdfe77c4e3a04c380550b0ec405dcd1237f51456263083d35789a1a3ad44fe837fe635f0a2fe7871bd285a89932432ff425385a759df6dc0045228155d6fbc3aa7fee0b46af4e3b2db5bec8924907f86d0367fbe56f174b6391544d53a1f1df2c6005ce7070173fc0531df39909a8c191207a52b3e16670ba06ee883e27687101edc3777a76ce91aa8fef2a25b912e942f683f8c0020a3ffe68cdd04d36c188beec180185190fa5757bbd92028cdb9b3a988f5796810274fcd0ec859c24287b059d7ad81d07326ddd9650830982e385def31233bd397e900b0d3400ab1f866481127dd4de0400bc2799976d10d3500356faaca0420f4cf72f8b12015b210ce658563c7ae5490ba948ebec56917800c9d8f1f46a56ca359a784b59eb687090b8d2569c7fd4c95d9a6f190b512cd78dc04af414185fe09fa89657f6fce16c58f5a441b6ed5288b64a4588f671329934a582e88dbd815c3e566b03684e40b8e4751c91a994ab191878169a82b70547f0955b723843b7834b0cc76d712a2350843d204757a827de6f4bd7b0a2960b9d572b5de3d8c083c6c2962f25cfb0f3b0403f9d1cdf0e2d675956ab7958e9bf05cf56ac4fd0f654961fe14698ef5104b34adf1b0765f21a3fe599c7856c0dc93baf6e98113440eb668d09cb5932131b071c7f51c7dcc1d50971840d31e670b0e252d43ddf23878417d11ff4451bc3341127197de2e8b2da2acdf656fbf1b9289cbebdb922dc1ff1ab26773aa008969c8ef344b3020a636f6c683a1ad56b45231f5201d20e482c70c6370fc5d7befc79e34e9e89df74819e3d2b13ee3bed44a78583a012e5b5ff9fcd34feecb8877a57881feafb408e1af98ccccd8e05bdf5de371925549a66c2f822fc5cd8b45f16fe5fb4f5b5e4024ced294c55e74b6f00bbe9abdddecb5de397033d754802642fc16c364811e216a703d1d8d7fa8a50419f416a30aa3bc476a59d136cf8d5a9c58131e96a63624b16db62524589b5c52b71fa06a66f7857c54bfb0ac3f15ae2c478bf560f2438bb2e82a8efb8ad39a3957c107b6c3ad004db01a99df04510db9052008791737fc4e4ef7f0b6cb23009d7dbcc94d0a0fe4bdf4d677459abe03b4e4804802d5296bfaf919321ef10118c2d4459dc146fa9a7d69b1575bc1dc4a814bd46bb3377f66033a237be222a675e5231d90c4e17634548280d8781b13c03265f8762b34a0ef8d2a15aa771769694f23a1021b8d337891da6438abf79ff18ce47f946ba1e5fb02cee3737ed3a3ec06f468c01077d3711459e359d6bd79d0dcfd9bdf4b5a742e209f7d4679e3253fa1a3ca3c09811817b17dc3f2ec08d3736379a9da249bef253ed382f1e44f7810472657cb8e9adccead4c8af4cedc12dcb92e4d8f2e287d9d0109b6fb35901c69a8ee1c4cb748fb78bab3a16b5a9319bf5b0abc73e8d09f1251b0005a10a1cacf2b19627293f8448b0f40dcf2d6fd39621a1c13336e681cae90b3130b253a9637c8f77eca3232d370aea6deb358f7afc466ce655755a736dc93d48f9c37038f3bcd99b08ed82d590cdc7e35e6fdf1292a703c44df1690f023ea185225865de775f506312f94c7b00f95bf9e07c1d4eff7c998845cf9ad3c820d0f323f9c55548283a9084c85707a312416f7e3cb5f0df49e9e36a9f6b8a20878d193dc90b4ac54f302b9cdb86f45f4c866cc2b16c56ac8f40df9ccba99add9da55366195d6b4b24877023755925fac5f0934fa274bd322e67c1dcf9d98844652caa29dbe6b802086b8c726d5ba80a3bb0bcfd3bb5470dba7a1fdfa8139736d972d185f0249058604f3baaaf7f308d5d189ae0b101e998ea14bb2f2bbd4241c330daa33b4a45f9ce2bac631b21c2704f8928264cc281c470038ed93928decb1c71777cf773a3777b7e0d41aa5d73ca8b11366dfc97d881bba101350f7d7aa35c752e1800cc73b607a4d713cfba2284b3d4ce8dd53a7b74fb6ad536445d1b1794d8738a95c50bd745bb6f0890daecbc1104aa8bf53c36346ae0cd6847b8a7a971e9738e78624d05eeda71d39978236609bb7f2a3e25b3c02512fd7b1e4686c6d966002df76c2441451f6d992dcc1c4e6789e0cf0ae43860f5ccf4fc9c42808688a7185395f424cf917e7f67a501f7161b2f0efdfea7105b65f6921fd40ddbe4cca9fa9f8c95fd126d6ac1307970542faf24add2b68cdc1785b9471d8bf7ecde0122f48231b008ebb0c8eb9d193efd1a3210488130efa435deb7588619dc80a0367d34faac43dade84de5756304fa06452ec415aa41f33afaad9d710893212d579928a9c7fdad51aff9b415a5c951dc3557349b97b20623165c8c4f218f413b641d6ff591a4d944765e8967ebf185707b634e42ec94bd012dc036b3af6f23da93494676e5b71789dc4ec09ec4a51a8bdbc49a790490263dc04de240f75e8b23a48163bd0218de90a5f50c58ad379be3e36c0e6244d8604adf27d9b773b86129ca13b1d8ee864903569bef48ad902b807b923dce26c597da103ac08e72b658ae54b48f86323e63c0e297c13974cc37f171fd0e3da388473b16484df75b3af9060d554e34327f631a7c8b3c05620a829918d372e8fc9fbcf67266f1216c464ea7763b4151bd3758c2ab913223510b246a6cedb7ee73c75b3a2d463c2cf52d4513b6c85d072bb6c43bc26d3a64d2dd033bc63df12926bbf85ddfd3b511dcd84a53f077e0a903e59c827305eb2a219f38db97ef1c7e12f1eea0017f9a29fef4243d6531a60a177844023b9739360c7ac266fe9851d91245ed645234ff0ee76879368ab858194e2113f247636d4e0b4dfdf668ad2381eaef2242d3da2dec581736105ac978306686a2a3edc0ca2148542cb2dd0813d99e9459ac9b5f01fd8bce44d3fa9dd43a8d19954f40867cd03e351a5936eb989b37930a05c1f8f032023f034f69b9e98ec071e1a6c8648e392b5eb759769403ef1debd7117d99645a5810b796e71ce78e10c71cf2b28628a33d5842c5b3d462beac3ddec4054a390ff9080f2c4fb38cf367d34673b3d53f3c2d141d7f223ada2c487ccbdab7e02ca078c70a389ad55e1ad4ceba5bc614b48430efc44ff533282dcb65e680be0f35eadcb3e65b052030f039dbf94ebd6641549c15e812ecb6b5a9cf204e4b58408f151fc848a1d5e19b8012bd999b751fd9962deeac3094768088594b86b33372b7c90ccce1688bebca073bc3abb505f9a185d8b25bd82ee330b59ef403a1ab1e17f988528140ca220c9fa1a8fef8b82527266777267e025374de48b812556035217515061b1bcc0c25910578b5f20fd2f07bc0c9bcd9f15f890a3668a6618f0f2d2216fef57cd12e8b41792183f07499d0d373c17277aacfa5aa178ca0cb95ce97d5bb677977ba4c160669ac2a408ba3ea71e5169023efc0d3b8321b40b025f4d76222e9ae5626997abc3ebbfacb8d98d27d82fa675bcd6c966d8d23c28e2825d94a635c6c7ee5086247de95e96b42bdc97dac26bc7d86bb50451235e4523adb0c8ad2b1252cc3808edb9c94a3909e2ee09ba134506944fd11ccbd8e6a2f035bc69c5711ee219b54e5bea99144e86a4f204ccbf820e8b3e546ea7fe4db3ec59fc4ca9bf6a59442f56a8850ada0e350fc950da8fa056ab7e9be58fec752a69e862da393011d698f1b7f440343e1c1a38ac334e76929db8432af21c7fc022b1e39c88f64b69ce2385e289f1ee358aa5c13ef0f484f2ed263640846bfd033eba7101732b8ee63d55caad099350b566ad63c4fe752fb2ebc7e6648e3747dfc0c4ad91f4e307575d2c51ef31bfd0392c1f9eb766e5e9743fe1bf4709657a74143e344a8abbf24a026226659970f4209ea824e05e5e0a8eb4e4ec8466edb5bc0b20c1be958695e2121207e814c541a9cf0aae5c8187ee6c8a93549eef6d7f296fecabd79676cdb9602549e4a8674a1140e8f7d2b7a0582eb9f8945f780d1057058bbe58028f630598118030ad2fa128771cf0c65ccaee1ad114d2994b2879fa2b96b5fdacd132b5d71dcd6e265cb0fb691915531629606c564d0aa73564d28563ecf0da915340092a3344e30b2447896281a7a2e95f9979c98ba8ea5738d40f4711222d8b41eb4f744fb92d8bc905728c91b4fff5a4e83ba7178ebd077a8b81b2bd102ee3eeaf7a754adb4981a841c906940752a138e0145576230dd8ff117cdabb88782c23faba0aeefd7d8b4f4540c68a807825ae767bedcbc1611d3fa6322daa28e1ffd5a0dbac161cf8bfc854a7f2b961f6c5eae9fcf1864efe7a66b1475daf318bbea364be90955b9b0238a35d126fba4e87d4417d35a3a7d95cbc45514e78b6bd7cf3b5b3b87f9754127a05054864d02661899dc532bc42a2bc5ab8fc3a47fdc36093e47d77e38962904a5845171a95afd6d0373d0d6955ce93d5e39385c430aaa805b610221f0b236d45c644cbdc3391941880f89a2762e690211b50e2c0fb681bba8bc00fbb8a5eeecd9fed5b2cae5ad3409c39c1b477d12be6fdd6d584b57cc2b9618b0a828323b61bfacb871356f19ace9a08f3d786c5cda94542320912db7e4e0ec0b35f073cb51fb708de0621fe4e9fd4ae782e9088c016f16a4fc2797c3af44174aec5e5dbdec01696a49862f3918a5127d250b7e7a40bc391542905511b083996a963f73687359a189529626524c5bb855e58fed13f6fec32a4e4ef891d8c95ec932b0361214027d6055d7a6edca33db55fa4a9d6dc5018cac1cf8e55dac2d0e4893cd58d74bf71aac0b7226d3f81ba6af2a14d4be6ece282d181781aa185f8da63f6e0667517ead9783d9176fc29afca66253d4566b74bf2dcf35d558d66a63ae3a97d81d03de1163b51e0d48b10223ff4fc618c8b571520c8d7e30b4fee4055ea6f5064166eb5e8c027d286fa61fdba8422a83bdc8b8004dd5cbefd77372a1c51bab27a0cece490372865eb22c28c414d5f2123100d8e9fcdfe94f6c78a9dde4d38ba0e8da04143989d35899bbdce750a699b457fe9b70d242af6fbb02d52755f5fd21c60522f66f1e65dd1c9b0aa71a5047763b4b68032e0dda80bb2c98d556b7e3140f298b9aba911bfc8a88b2958175670388b64ddb430d0f914cd3096081433f59678151cf5774cc3cad88d2be909fe3e028df9c4474c50b176a2fc8eaa0fb42283f49f082fdce0a798da0fb2a6ab41d1dd51fb539cd3f97ae4956adeeeb5b91b742076a4dde8ad4b4f8d2930ac339f33b5d45f3e3d2621801c1e9f5533cd86168daa60dbb5e70bcdb3d096dff3abc6fdf36dff5e1c81e6d698a3002c64ac477b42d31b9501d3110ff09d44b14bba7f1299fcec22dac7d464977f7d97b361c97bac0c08a1f8d9a9e5167e827100912bb377f71b0adcdd23b17d9f68acd7cda22dd1bea96073f2a7b36ce30bacf9c4b5a2bb871b33862a41d1d203709c286776be06ed99cfb2c70d75bbdeea64139f201c0c36479e4fbe0251ef97ed30f914eda809701a43c38e6f089e6159513708d6abafeb842ae8821cfda75a42688aed189461e922eb6cb91f3cc1724e6dab703f3dbe3a641e6f8f0a1f79533c82422fac83ad238891604b163438a9f7ed4b5c5cdc075ca03d0e04cb9afce9ed3466d613a4debc1bd3506c66c7106b89181e8cf3f6c17f0c46541a6356fa1cd699ac0a5b542243c069dac49c456dd6b24cb358f27967ec50cd487d1400e233888290cc683982f825b6ed5aa5d20b5a2e0e2ba607f68e4ce74e824c25150f0af514bc73547a184d6260770fa4848222a8fbb45bb1937f62a89ff6d1939066adccde61e5b9493b66d50a381a4b62b0e1070f0bef86e66083dac1962dd4d8543773d130291d0c20a95e00669ab24ced1dbd7cdeae2e689d812e177151a5b5a56a0fc65344f79819fadd996cd32c22020f92cc24357a822b9904b93e77b867b20802475bf0904f01065273236c26095bf19c14bafa9fac9b0902fd0bb5679eb2a3a0addef0f85ff990f09d7bb0eaf98394ec8ce62c6447a99d5dc5fc5811c0d28c552526b99ba812b402cdc91b047cffec9a83bf3ec301821e23b80da13b27a80a84b90a629e1b97936b6af80d6e93ee5f2ae4c39d5182f8321bcb19756bb7f92cba3efeb363f44870892cb7339312bec3aa67ba82e03ea694f4aa98615322d6745d935280f6713f2088bd4e3d7c3c2cbddb11d55b23eb22f800f1a472b3534233087bd8c62d7da032b7816ec54e6e10a3b2433ed237e90a459977ec0d42fc416ec2cc5b8b9c8ad1cd18615d880df9313c39e61d203f3da0fab4c3b9b23409fa00ce13fbd42d4a3135a7d07a0bff51642fae5a27536e34265bf050c1be8e7dc178a9b8d4b08c7f2f338301f70b93e564f950443cbe1c4a5fde29ec88923ca4c70c29fd2a6fca134c221311ffb03b4b4fa18670823634bb43ef42ad6e33c5d70441b5725bd8f2e8495488582c098e53304f18dbfd4cc432a6c8d54808e56bd955042f5870a34c84631f40b96a46ce151d6a17a5b8e6b93f4e452e47b0bf5b9566f1ec4de2000807beaea7599cda552b8794a1dc6ed80936e800e3fbc4735f691768de92e1a0f1bb79ee3439f5104ccd2d933e7431e658badac0d2c874c1619cf4cf92859bb525a67d2cc065e5a5e6c59b75b5f9b686f28a001e9e869b1be9e3e584c3ec543d0e2d58616bf15f934c020cb5051269e5cea589f543f366ea8b7500e778badc07b9b5da8c83692d02de94bd713c5caf5d9a81e837b4360cd3108286bce7442ab51b9f50b7db083d61caa8f904de4448d3d416099f449dc6c434b3a1d779177e6245d0d6eff0bcddd2416b28ef887d5b17489a387a47bcb93729e967fe33c51c7c9cb1a0379d6bc4c771f54bd3af41e73260986ab3743683ff2746ae721a794791fa9534ceeb533d4d5f2f24d9d2576a74fa71e5702dadf0d95b554978ed5bbb6adb6241d57e735506809a552c03ebc7a580bac845d72eecdbd6126a3e0651f7eac1bdbc42dfae1cd845830ea5e2f330f6a59288edae67b57c33ec62233dbe400048ff95bce36e655e8083094c04b70568f938e0f71e7ee2c8a0e8f66bdf994c3c9656ac258c6a47c65e1dde8e5d775f84a40f6922364e705e43d625ebaf15798f808d54914b3ddd86f795336e4c5501e092f87370c2d7aee6eaf9cca635a82f96d353bcb9b0a6c9c972880d2e469f2b6d24f8d80e1e4ab5a85b07372d6a2ef36b619bd35a53aabe3a634c04e7ee82a316ff9581d472be6cf5e0450982a41bb76e7e7c4572ff02205a78b1664eb029a19b60f618f981a883f2be127b5485c97637672140967ffb5c8018aec2bb86ea5ef571760e958b40034003553fb79e2616e5be19bc63d5f769fb02d012e828735ec0d8f7f9a70c3aa42747f6ecc24208bbcf9894fdbbe25ed26cad363e213be967bcd38d9cd29083ef2ea5a638063e1399284d25ec2888e9359b309da7e1ebfbbf52e3478b640f6c807b83489797c26c721906d8b8039e0b67ebc962b8d5a94ced99cf512de7fb6c38dfb281586e5004871ee041df5bbcdefc0db6e29f09afe8b9ab70d3c75a25a11715bae30fb9b3a8fa3f7ddedd72961a62078bea5b605d79c5158e5447a9add7c64eff9705df85796809cb226001959da9bc746a2e05de42584792d64886c6427ba1d1029c83571943126e051cee00ede92eaa09b2a4327cc3bde470ee693f5680fc5400029f2e734e1260b1d6cb11827fea466eb71535b33423b5677f41143756f2feb85041a722d97acf99839c73b0eb2b3ed31aa7164fe05c1658b08248eb540bbe16a5efafe0429acdb9963d93f131a501ed1bdb740da00c35a47cd25f63a8135118174deba80aa846b5fad7fa74862160c5af1fbb9336d50d9edc054f0fefd4961f023eb68757d1af0c87bad6ed7427dd592c192ae820290ff714cab9782f7a2a8ef0576daa3efd162199a7b9184f10f95739075e089398a7dfc8144533f453400f3135d26e968785c9a2e21235f9af0117aaa31e47e091485e39170f32f0d4c4d3cc0c19400209e330586107d381bad896b83ed5cce023caf5a4cc07e676f984887b3e056519833de97d11c45bbdaa7e1063d49ed5e3958ff6358971302b544ed554756d2bd2aaa02322c4521d44943dfd9356567c4fd114d017bbad9ad9153eaaf473edec5802ba7268b3d04ae8ec1957ef8f9977f940d5a37d538beb107823ab9263b6ed5ca45dbb8d20ea60c4c4aa0f54bfd567fc548386f22e8045ce23fd3dcd1f7a3de7b81b66275f3324cfe5ae3c7f33b94783a79bc6d47d116524efc21287e4ca18b7774320d02802a81cdbc3e0a09b331de87d76dcc27509156b8adef2cc03ce42f89fa34c468fe0651abfe21d28934321a44b6722d9ef3c9f5dada4603c01b3a28d306e3a1de0692f0579fdd1772e0cde7177d99a21448af2dae4c0c503158265595884d8279385f2433dc6c29a8c1d75c9664ad9d247d3a71d677540c0e0181cc4276c8f467345bc7922b9c75ece9993bb7642d69193d13cd1b3b957048e2ec4069edc2aaba2f36e957ddf6a26c67fd0a89c6d81f266f675d887fc9010f69dae79eb515b718ec233c7fc52a5be67656b53a66a4c00059dc10073875a2c0ae4b84ba9bc09ffc4ad7c8a7d04510b69e558131376db4ef3ead42fa88b164a1d0a5c028cf4cdf262c452d64b062dbbd14995e56aec908a29b884fbc107f235e8ba6db1d93dfa7b095ef33963e1390b9e6ac7f083f4dd51d89ffd3e5ae4e7c39e27d92178060c77a909b93adad0f3d77ebf01b875608aa7aa92e274fdaf6ae99e7640840ccfcc00778654cf058a7a115cc477254b3201db91da07279f7c9225917b9128fe5136ce40502b93a6a00ad2990985e941d23950044eb011eee8a61351f3be724c0bd91436dbd6ae70c1781cbaf9d960ecd4689bb887545027f0bb6182448443345dacdd79bdb1e44777dcea1ff2ba74edd92dffa6d20450fee87648a59fa13348eb397d46749c57ef836461adf748fac2b866152325b45defd5efd999899404b80d38de3a041bc1bf738d6830b18bc749ffc98ba3c63ae416c8d09cf1cdaea17217da45b579c7a3d9ad3721f2aa63d30bb16ef31c8c883fc6fd8fa981a5e26b0ee4bcb0e05f301c88556af277d08ddc0ebace38c39598d15af8863ef42297041e4c6abf092315769aaf2baa17bfa8d6f45216970fd265c077744917cae1e70be51a466116e4c94b34aace9c7a0c2d0f2160e0aec897d802740780cbe086cd92d6fc9794b2ca990b7d90bea7be6c06ad40fba0ebea7fb23c96cd2e08c6c2c8f58e0a5174dc39d236f4c8a15841510e28cec5fc643c6fd2bb952e10fc69711b2844f5c9f890f030015459dadfc564358484e9e4496a2afa034052599604728436877f5124e1f485e641615e33d9361e6a1b7a4a1756d6a3e883b65d299683408d3defc381f037f57d79db13348cfbd45fec2e89113610a4907edf11121fc7cd3875378a913f49f8dfce22c227716cd4ccf42d7246d70d2edd6135d30d5767066b6772a465bc6541e6d01d1e93b492bdffd710de66a160a244391c0e874efe7d65afc2925bfc6c73e948766416a5af07086bcebd6c247fe87421c998baf64bcf06aa1cf8309e15ee30c5b7027d6ec1021e9c00e0ec730aee1455f8f379836ec95fc270e67c393f014ab161ec4fd8a41ee5c60ed70f95dc5080500610b5403025ba6a72994611cf88306f47a2cb755650509398057e333b1761940e6f6f1126f766b97fe427012cadbe0c740c958f7fbef32a16f07b9b3cc579600a2c0133962222230da97155798c40707b43d36a14c452d369e89939d47d28f095770e46fa13a7f35ea1f2d1e52d9670417e4a31f4bf38663ecc520aefc93419afec9127a898ed50a1d1ab8ce82134350abf67a23f83c72261b7ad0c006e96ce82e1fc99856084f1c9ea6274cb8af09052c16ce694409c7a388bb4c6e967080b353842c1710fdd0447f270a67c13f139a7eef11e123eff1aa9789f01e8b2309f9f613ad949a1463ac89eb15773ca9d75645ea807e736884cb3a330d52ef2802f5c01dc266988b8b12f3dd95bf6eb827f55d33f905af5887dfc99b1ea319336258f1c56a0ec485adeb4f75bd3eb1e1d557590594bc69db325ef213718ed65c11cfd83368eb0fc21f3e38ed7488d1e1f1bb8469b637368c306ed26fb408cf016dad1697699d316e6b4a419776e9fd2dbe1a736c10cc5cd33cc499e4289b8972687e154cc299ee90ddad026686e9fcc104e761dd87f4689534c6a4b07b79950f249a21d94663221420cec4001a4c78dc3fdf1237d7a39ef3f5d84bab82e8af761219ea82e3b304f8854893804fdec9145dd24d329092e7e9ee7b8624cbd794ecb6daeaf2f495b90f620be03bd1e4116894829e463ca0528dd1514947ff49fdf939394b7ec57084604ae5bc3af63839802a552e74368c1d4c6cf278ec97dda5f42b28becb1d1e77bffe73afbdd5298edd18c86917c1dc6549d14a23299039ccf3bbad518516b158bbb3eb2c7f4228d87967be23fe27b21ff137959d78ca18778fe4ff8d6727cc7cac8cf4c4fc595c58e4208a3b4efe44fbe32a4614719811872f9481a1dd90e04a005fd89933c0ad4aabaa9492f5f047edf1cb7aa80458644f5d104bb1f2c6edcca9cf76926ecaa621b63f4a6e22f898473a70b8686f636c41818acee2854cefbe3af68fb59283e093576980dcc87f48c35c92c8e3d6b0d20fe93929d199378d3978886ab34a8978aefabfe51ea643a5f5021c84bd82fd046c67976622204db51f9bf615ca8d7467bc91c2a976d7e3a97b17a5489e7d6216c97feef72ada2a3bc4d70cdcbc3d128322dd44ed65861152c69981d9efc1b1988c4ae063d015dae455933d19b3ad3349f5dcc48683ba3d9a9e0d91401245e3bdc19f155c87ba61fb476d29e1ea2b581d267ca86670180c2e48b79f247f5490622aac1df6274a4d7957d71d9056341bd766366eb21c4026a5cf352106b477a1a1bf8576fe00e71623117308c2239c90235ad68f81ac8f5cb50f51d91489612bf3089c63a7a5adaeadb89b95a85226423dd9673656e2460fa660d978940ccd6e0b1d6d4d90fb039982e3ec15785135d7e9efcd226dd52bc19d123285db5307de1972d7b0a4996f59f1246df65ca4b2eac45e44f0f2e0176b9dd25cf7d07d828867aec45dd509ecf74724664be04e95d75ced2f5f068afbdd89b4b06ac6cff22a743fdbe1874608ac19073d903d8b5e4cc81cee97ddee1cfa4f55be831448f6928baa38efc92b6b917250b86a751417edea8823af7dbbe5e5c4c767adb2d00ca99b99da04b26965ab254772aadd77196586fe58124d91dd43863059eff0c8f50390f56d4191b30fb68e3bf1bad24408bf758379acca7528b8e6f45c168d93c9048725a219f7f983d9bfa91e898ca721b416fa1e3f7f27962f63abd3fa82794b12ca14980b1b30d1ca5b1067667bd0d4f079df6467c8a70a72ae97ba504a2df1eb5b2e217d86c915e8cf424a39a7cce895e6a68034be5e5bbe5646687cb3e764b474aeb16d817fe5fe028c9206aba13d20da0fae5bd2e2665352ad2de1d5effa070ea439eaa3a2bf0dfae1537c46635eb7de05535283695b0575eb1530630ab0c206e2879db4ab7ac238369c3744a98ccf0c0233b5655ae2d3fbeaaa67f56a5a3a39c48f94b5d34c374e3920e5441c4f52d9677e52a54eb5cdd1c7457c55f8823ca2e82b230d45c96e265c8dd16794de2ccffee68bc8c7cd051fc25785dd33c7b33982668ae80f9dcec8a0f91e3c473756fca85f18ac7cf2d5cc4408e9513b87464bdd31095ef5a7cedc5be04bcab1289ca955bbccc26bfac5be2bdcab82101b678406b20a9801bdfea20658ed5394880baf17bb9874dbadbc49ad66117bb88aebb68bb558921392a6f18cf52c6b04c2e1f7391c6d27d119c7f0400323798ecb5d64c2a1edff9f1c1b9d09f0efbbea51f817cc79d4e7a408c8b1c78ed2eeda70ce42a287d7acb3b4c0","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
