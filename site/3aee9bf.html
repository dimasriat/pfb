<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c9b926fe787166724f8064f8557cbdc14346f6ee9c06f5478949e90f3384738a7cfb3925ced00a29b7266caf485e6a9632b3e94b7f86f34f2ecbd113ffffe0c09d1c284f1ddbceaa90cfd57a722c6184b43f91c4afeb08603dfed046113b06594d91f74a51ac1ea95dd97fb0cc94a2d266113e2b29b0c0e81e7a8c56226ea6fb764e96dfe9b355538d5b43d76aaf65c9d486a299c9378385b4d57028c1e21aa33846460a80eaaf615792ecc4f59da261d47e4f73c3394e3d94cf504024657f7f7a4f5390caec1901525d41d3dd4f93586169e4080fd93f845858ea4b08c421a0f4dcfe92346ab01645f9e000e27030afb94d8b584ef54413223debaf359c4043f7998eff0c32f5ae3d00e2a020f7212b658f062ac26cb3a97e833987124140709fe051a1e0079cc45eb6a2ac77ff993b93741ce274cb7befad00d070eb0cfff2821df6e7e3aef96280e161999dbc0c375571d8ebf3b60a55f01812f9846bfe5ead766663d0e9a05ea8a7f950a2aba3795995c3e0fb65f87c93b2e4290e99adbc22410e5c2337e770b31e5a540ba16526131a7b7d6bb138d17b52b614a7d3feec92b4d97c1ef08e49acadfbe8a344f874fafb8e69b7c1dbaf1969720daf48575f3dc43a541ceb131d0d2569d6a5ce850e1174b139bd9c9a7610b1e1d4b89928d0d13594da6774a84528fe01f32d67066ec9b4cefb19d77beb9a82f17db69cd161d7616f366800c1e649f45994c692280750499b9452f7e4edb6824dd9a70cf2cd32d62a3c0a36371b019ecf423a2ed15e1bbcaae2df03a112f905686b039adab29f3b31c647f23fb17d55a9c19950a5524d4bcada1a1fe3fc1fccc15fb508d6226ac4f3c406de79257ca45b9571f947001c2d32ab27662c1a8758eb366572e20bb42476808bc3433080ee8057df9e63f84af3c29a84d32bca4766d495e09b6ccc82268d805eebfc9304854beb09cb0c4a8faa9da9bb5402cc8a737908417e4ed66c28651eb485f4b37e51d50cb7ca0f74aabe5f205c91c5035aa7e963f7e1b76b05f4b475139df83463539c0a193a22d8104acbc9eb82c6444f17ea407517a025ddaf9c85a777e7ca1e52411cc85fc5ea3ac97e434fdcea01767a83e31f79108ab5fb1b144c79c97c7b9e35bbe3eb8823dc210f03beb35905b0458a2a77083146e4897dcc0734339a651975bb911420a74e21af6853d84b1828449afce131a3b88765fee1220a7b673c53d116442d2ed0984ecf003d634e65a2db743cf87c15b903129cb1e10f3699f7a3edf5a9b6bade32dc6727ac8b225c9d28d91d6c84e06d48d6e9bda0e392f0837bc854e1cf7bb3945ddd8eb130235cfe07a4472ece55670b8218eee326421c86ee7969dd3569e6c036634e75e837119fff609d29833b0781d04e89c571be30829b07169fb336fed7126b99c2c7f333c884374d32c8625e288bca2f327610a4d6b4e7744cca9614d07f4360a2820e3191b736a1c8848ed92b7005cab9a9427212400284db8f1795f329352ff3217f0c58c26ed012aa0a33073723286a349335bc4bc9fcbfdb8dac51b8f0c60537e3bfd973c55e7af6a714475eaf4de700f4bb627bfe59140795f9186633090899793bda39845b22d1d3e7e5f656200d6a3da95c426d65b63cc80c8056a8418713a0004a42e298cee284f26534eed10a9b73f92296419fff8fa714ea95c3682fd404b6bbe6a0ba7386ea1128aa31e95f9a9eb3e52cc5e678591be884d810a0746aafdefd511c667d0589f0ff2f9dcfa3a171b8dd69f4cd04cbead1078054ce46c2da981732c724d95056956563df482a818aa005fd4b5007d17fa5e2be8338d17b67d508f95329147292822707df05a0a4641e0be9c656649b76dcee1350a7ce1cd24f49b1e7ef0a1a49ed51604a840310c07f735669a27ed15de0817cfbcea4f705d474d8430ccf9f474ea761da7139f9efc09d0857b838763f0a17b5aac2604559502ca0371824855c69432f7e67ba8bd7cf9ad9de0727acce04e6d83f8d7f4e4ca01c27a20982267fde2880b2e7193c8c1b3c53cf5cdd05d01f21bd6e68f58cc3d21cec60fb8614bc13d4a27bca9bc12fa06636666f2ee81af9b242854e611d9da16b733b1e1fc20abb7018d5114af1f6116c03c2cd09f476b109bfc84dfb44f32114c09bdc169149069015f0cd53eb705091b39fad5b917e340981f49573d493468afe65271bea4902a0a1e7bc90e023e7531009b501cfa33846831fb930c74b7a23f7e1b66af0cd9658a9c16f59e961ee7a8a664d71771cae5221489e152e2ab51a5620101c422e34da437bca760dce1f426ed40e4e9fe9f267cf66ad6bc26b31a0895be18827f626e8d5751deebcdda89ce4a9196c5ef0284ba8bba72f83ee9817f83c2ce83d422cff4d086976699166926de8f658123f02fcf16d225d8bca228f5eb5bdd7eef7491bbec7d1bace7764de5aba2bd142116946f1df60776a17640b1f20f46378ba0f1ada13e2d8b37b623148e3996b4e96d1d14215d92d36e4551f7104672ba248b7d9b609c83ec91a73fce45cbea501eaf3dd903c608b76cb9dab79aceda227812cae44eab8e77c0e19e6b6b35b7bec9ac8fdde224f2639a4779d11b19b9d378d5d590f8871ba5d3b5ce19066c1936c8fe04fd1d65258a27213427dfc9ebd1111fa18146379294d2cc624dae3d3d412109ecbc4fa6c0074b8936623d9bb1a40294b8002771b88f04fb17062f8c6860804ff9746f995b87da5dfaf6f9f5d01c0f916b0951faf6c1f88c7fa71927e766f2b49875ea4497ab8f970b8b33c7df1cafe99892a0310feb71b53d1ccacbdc06247e8b919cca2665d8ddb14be98d1373e7e5cc4349a8be499a17c7aa8059b2d6affd50646eb11ad53ab74d0b9da345ad9c1a46893112d61a6b7394db876e0d149b8d80c21c83ac1036f03775378f396d8ef85857beb1edef47bcd933b43432d556cb61c07dd4348e64d30c2226bd63b4d6586f1d32998f1044db03dcc038dc03b820a6247c73a21ee8cc7bad59d6515fd3fd70c5b9e1013291c4f099aec9d2bb9c12fa17d0453cc884c6057df0384eca533cb6961e046891e23416a3b2425a72c33aba2f31f37943699c086a6873c176fc4e47f256d32e02ffbdc1641d4e7c145bcbbdd04d9d8869a025ec29a139f73b679909e9ae932706b717f6baa3d8385f219a37729b37a490edfe6313833c412e657b661cbc95ee2c45bf73c3ec629311645a44498970815c0eb283c1c18096ddc6ada827bc95f6870dc3807aa9df65303a5b41b104fa462faefd0b3c1a2b9b09a63ed59bc882cb0fe8eb0f1a132128159d7f1473b39788a408dd0485e6fad1841c4ee1f35c6393d987731b342aed53e144703a1e8ecbfe4f692b0638971cbc6b33e3cf5e1fc823d4208a6e80210632415b11d4607f16765c43e49def7b734afd3fa60b52d9f10a063072b76570410546ecd20b0a3d2742998f72fe1a2123bcea1f1965c24a0c36334791412b02306d51b8b804a66369ea03c0173fbe5443052cf23483a1be07930e4fc6b587395951e83058de75fe2d96da83ab6c05d445b4ca46999b67daa960f6f0fc246a72a21ce202260f7d9b5803bf148fd2bef90d2677eb98800be8cbf67d656f4f52a388f6a09267972f0ee497f8f95b63432d17797a8ab456085c3f312bd406bb38c646ba6ba72bd4158b9947e6ea2a5ab393ce00455a88639541ec428bf147fc902b520fe566355f87b053fd2a8b044b963e0ae35369bb20dbd87398d5449f05115fe16f5c76cfe48dfe3841f6738d07722a368dbcdadce213de74ae712a68bbf055cb4ed3c51b3bc6b14d9645a2d5d71393b7603694e72e6a74ba41c068a051527d2046d84bf11140f396eb2aca9d228a461e60c7faa25855a94eda964af2545023b01d02523cac478a2a7b7f4bb7d2212fcc7c15a5938f0b01b877175ad451a6aa3cf953753729b19d8f68491a044153a4eb04187910b124ef92318a51c66f306aa02614129eae63b3271826a337d42ec00978ac35a4bb5011b38be3ed670abd006e71774299211203fb0d655d62597d4839c2bff560707da372049395972d0ab81a710a9cd9dc609010ffc747f4698d302ed04ca8cbe4511126d5277b3c58a8a958299fd78d62b8e16815ff78af308de8ea591c7b8dcf87eb09da732fc17550670f13cfb8631cd522f8db2248652283bd3e05a457328842a44f43564e91ff6085e9a69ed1379364a68a96a5d83231236219e425e7cd3d19cb3c29f9f2f779df9e05b299573a50e0931649bc6e4621cb84a50e96f114bd699d9e5cc4bf99fe5493769ff657643d0b0fa7a9ce9a921385dad6f30be935adccac2eded05f44be6a64580a2e06b39a62ece9883b16ca920c5a67be33511a0f6122b96c6ae1cc21f1ba31309fe0620bafd1ff2e3a204c6a5603c3f00b0696169c09bd440c1ed2ea877a49213a3db10a0c4c05963b8cc89098bd596778fd658b68ed0f5478817e584ed930fa9b96e2a459f636d65b7764354bd2612a4960a92f8d692d4948eb7031d186679f15ed0f9accd53b1d0d1193696efbad56a934a4ae3ff31cba258ef19c6b4a5561cbf4eebe599b96cbfba4396839a43bb21fbed35800489d1b1f1c8781cd28ea4065258ebf96f90e7f303f349f141bd9a11f8ec23f89cd8d9f511ec498b5b0ca2c6c966ea4c4163497b60e8fb02c517fd3c2bbdc08c0357d8f9a083b00bd04ab24094f915d7e5afb0f0a7a512817daa9b8bf4e79afa358b9ec6104c6b42ed638b9a10bc4681a55256ce32d7de384f102e37c1c3d7b3a7ec117555852a8368e81169b99974f00461870ed281d7bee1db1451d71b9934086ff61e8b25e30d2310cc7f972e896da7a5824257295b5321ef882cd0e82c2f3aa0a51046b10c4467c64d4677ce7b8ad78f425ead7f5e373c3ba9ada4eb149a7fd7c65b4d233341c0627d71974738ba616e1728e14b021ce8a287458fc9dc74f5a2123b5ecd9948238dd6994164381d1de0e36701e78b6990bb1f55225fbd617d7552bc4e383c572be09f9a6ab130c9b08acd9f49ffab4f76f38f79141c1e062af1f0c7b30bea4d70f7a3bf77ea0a192fb72211c5a49285c53c962048ab4103db213d42dad14534e5ed57d57e4cfdbcd917ebfe759ee2459b040c382ec96979d3be76ebbfdac7a1924b904eab170315891c8c297576029c540248a923f2aeeb7f8e9279d674901d5c9d915521ebfa55c58d4eea659f3662d56ce414eb5880b3b00bac4a97db22752ca9c62210acdb505b86e660aedc24bbb65058c63ebcc8344c83c33e42c424b11084c4467f4bd92779eeee7933c28c14a30d4c4a529f52784218bf8b978914b96bea85dd665e8bee8c8d0b197df571fd8eafbaeeb52dc2e219180b2f14b4fa5ce87152be5e795ce229ef124eca64f7ff4fec4e2864ee6ffa1b30231e01184e5bc52da4fa54a7354c17ac9462925ed689f242211fd09301e32e45e04a7fcd42d762bc492634c661a01e553a3ecc51e0ed5a7c79496d075e9bee8921ca03f2b1e6444721e1ae140178bcc536bafa91faada6082cb8b4edfd6ed0782ae340758fbfa9c02e1cae3f7d5facb9d6539099b642ea912851c32c520f546906ff30d02e10f564e5b975766f61998d845120fc158ba92273212c0686c059672b09fc54b5c4e6f99c48dd6b84b495d347fd5302c5bd709251eeba490861431a5b9ffb9c93372ba833625456b837bde23a77fac7691a645f5e6641468f74b26c16fac14f92bbda2e49bafde99e7f843101703ece0b4265716dfd88c4f2304f65586d449be3fb135e22b1b42b7bd8d1fd8521750a441beb225ca716071729b868c7b304a6a39800ffee7a147746e1d8f7fe3af798806492d47c5bbc2eacbfaefae012bf25ee928de603bf9284d5172e9a290e6217e265d8a0fbcde908e88cc8fab6945470c01252e524d2c9e3bb462f17538f4b3e5a7dd56e48f94d87932284770432a2de48670f1aca65f319526851a1cea6c7085be0066559200bec3750c88e6c4a3b9b04602dbda452bf40ee10e17360efc3f6efed4f21f668cb5b72b7b56413ea65c8adb2416e4e0234adf4e33d1c31c8f505989c26a2de6eeea3a299b9b7c0cd105fa49808f05c5f3e029e40d47c9e0cf923fe73fcd40b44b3298c3caac4dc3bb90d2d8f2d1ad5b30d22505375d2c0f908a9f1b7d03de31609e1ab244854463d1224c9779d57fe1d6ae358d6662ef588326c83149e8f93f068e9c818d5539e1e1fea13de1726580dc33aad786ae75395eab6d59375e433849d93fb5a27f55b9c99ff14d1350828b14d2b964ba69c17730187266fe602d871d43fd9c20a33bf40e9b428161dcd4fc6608089e2b5d5ca9e01d54caae2e8c3259dc0e89108c87a153b7e7e2f9ec724507b30d5d7e1179479d204da6f7f47ead93647854ee48dc58ceff4d85fa5e08b1266e32f71c4885a8e68d95826c3b808301697d2a356d9dff7ab3a56bf5093aaadf360501f1b7b177e3598b84e84ab041d547e8572027c26f0292ee75e0ab11c6181b132a35154864ba52ee18ae78bc098b85ee57bf19387621404240e9317117b8792c26f99000c62a1407b0f05dfab669f05c765f76fb4a1ee263c05247121d6089817f1cd5ef3f9d8cd472d532968b89d37d2a52d72e1551556f5418f357b94a5b2441973903de977dbf3a05a85d570c188f2d4300ef794b1072212d20d7dd2f64cf5fa05a213db82b76c7ace957b54bf858aaaee793adce95d82b8506cc37388750489b9e4a0febb38af2be1bed31733aa0faa4000d69047e219de7b9ea90a2e7d1cd44b30101c109c6b607ed3d63603b96fbb857d4d4a7d7705041d5e9a4bd59f8c6dd460a45f90f26995c2e6e8d5c41effbe3a6c29d45d5dba1784a71fc841f7577fb664a8ac054eb2662db6b116e07df606e0c5aa675b4bf3dcf843eeb37a97a43804316bcb2ad72ae4465e37ceb7d5742db1f9230aa20314b33f86c0cab66c0e9103809f38b66d2f7fc9745b3cc786b5c07f9af021da170bfa5cd468c49b8fda15e8ff4190aebe84a65f959cc79cb8a92b9bcdf04a732a76b3c1288678934c3d5889e3caea4e847f94ee23e7c33204a2f18beae2e8da532e819f44a09dc347a4a8ac7738a6e13d676b82ea2770168bd762c78fb5bb452138b873ab25ce62a82105e9f6340b03bebfe4ed44e3067a41b37f202327a873cf2d3113e67aa686a50e94c7345a03848e4ae38d32f07e509f36f1fad0545814f25726425ac51bbde2b65915ccef0cd8b8007c82ac2778ab31c43da3a0f5f13afb76157fbad639c6dbdaa94edb946d9589e82ea2e9355be9fc8c98d3999c0a3f1bdc5af3b4d3cac765faa6544ab42bf34509e9cf2aa6ffaa06ddf360f1e83677be7948d6b4421430024b6f6ec55090756a735f21996350f8e352b579831de5deee224a818f3d8727082cdb757008f7a0a51706ce03911319a5fe428c5e31af5e761b619b3fcd49be112ac261f6cd5c9c3d66d10cc3a1184002fc5c0237bbadef087fb37f775dfb0deee2c869676382f10e8741fb4afe9d29f9bc3fc6eec3421a62638e63378cfcb619a6e188a97b75086333d00374286818f0a19ae9465a6721e17a9f6f87ecf54411e03186e6bbeaa17a8e41eff8b9cef2aa084cb08be4700ff3e617d64fedb2338edd3b081ec57771802e7b818c304641df4b45cafecf932125aaafcd0db034d748d27a049cc5ef783d9fc0c99901384b5cd906986da752866d47183f60c17d5cca7109ada1694f8ecfacb35954dfcc0084555a51b5d16a397c583ba68d4cc7d65fec63a794ce0cebbfd27fc3222a7a476c2e42e8ed070bbccda08e5945c027dd2325f0eddf3dfff098123e87f9fafea3101cda6c2860350eda3bba18e71ba5f00b02bbfc783d5d490c9e4de8626924e0843f8978ad79de2abce1ecce88c6b87689e25d38e4fbd0c7df1745110e0c35e296740f41e40fe128fcdcaa952b5930afd62a259a661c5487849e95ad0b060436a964ca9789b087b610da20899cf5040d20155f7398f8d5599908ecd8d101b97cc8b755e47ee32d76afa06b13777ca6d59ee779ac6c12c6a842d876db126681eb25c01ff2dc5c451903fdc4e39efeae0fde10b8727af0c4dd22c2cdd0b1215fdaca265b130e6f8939e85d4ae0a0b20cc3b63a21cd63908fae5aaec5a2ff225061a6001f04c0255555c06452a6d72ac189435da12d5f263ee89e978a402046d7f72ff40359714d3122fdd09139ed75eef1c5c123345383103905b0fe556af33d845cd0131e3f4ef484aab2e5523989b883cc1e9b7ec4501a3a298d20c355c3022ceb20b96536e20567aba2a3c98c0fd3a16407976f97a83ba59d6f5c55d45ec1bc3bed8bcbb5ba9b1aa3ebbeca47126e14c5f4eb0d2e24a10e5fe1000c5e956156d15f02c41d8952957294cb5dee4eb51c4c7a82f3b1390993e5d602080d74b7413668cb99e63d3d86ffde8a31e52bfbeb13ceae8d27549c6107f4cdbbab6288585642749670ae11d25038a0bbf3c66e1ca28a8fbee4519775cfbae9b3817945ba8123caf09eea8c90e6f93593533f3d92977ec77d04c116f23ee8d4ec90b90cfce366276aaf5ff0cd04387c5517d2540aeb9e924c50916511a2cdf44a5006efcb456626f54126ab9b8725735f9ae6b9aec147b1f649d8fb83c37a53694fe1e336a0e90ee5e58e13e0937f5f52ebb0dd6b5ad3fa2b9d41d236b85a3756a994a1608528547908b87f986e9b34abdfebfe9f2c5d0633d982228a8af5bf35bbb6779327fd2a4aa4326362ac3af2a846c03fe8f9d15e4034e6c583452c13f4748911ff4edd37c28da6f5493bfd6b45dafefef8a9c23392252def6aa4271348f46f374c582303c423fd157b3535a753e9c2afcb83029803832d780222b33181260ba5c6617721b4821b9c22dbe3b6086a6ae3138e7f3d07bc93b3bff92cebb97bf2f72d6b2401bb46e35ee8cd13f9694dd67e724e27e6dfa623195e2a6a1fa0712352c4372f5ce423e4741805ba30586ee9a2869abfc8fe341cff65b04caf726cf3c3e1062444b40da8222a6b881b7859a5c5078cdc0ffb37f820ba078f9b5d2e24a4523ac3cfa3061099178ddf3d38611091cf6c744bd01a9fc653861b91e2f8467b4f3a83639c8edd657bee63f21de491dc38ff1caf44c8aafca0242c73165a4d20277c5072abd9bae0cc5c7dc98db186963547fa8a5a091db456abc3cbd1b948d87acce6597038e2f419ec980da7712bbbc599736d31ea07d9f31cd2508a798a09e85100082aff23f66fc921f6485fc68345ff330ceaecef66c8675d0e4942eac70604713777b2f17144fc509245ba45b7a1f588ea91a4f93293c5cef4f025d824efaeeb9bcce8f28b2fec01c66ed45b7d96e15cb5962fbf7d51ca95c9c18403ee58a5032f5fe3e7b9db54c8b3dfd4452c4fc4e15f01336f9a239661b25b77c35adc4c4837ce783435b90bae3fef67d670b0ee7dba9ac39b7e6cc72c7da22e738bca74bd82d969f18e23ce21c7a0506bf31145e886720bfce22c7fafd09b57bcea9c89358b47cc0065271dfb4815e84f247ce14ff2935f6023d1bf91e8ae2f7234b9529fdad3ab3538228c485f2d91562493032fda9d029fd2e2cc290fb1eb58a3bee5fe5f017f653ae6ce85c7ec12986dd67035f8acf715ec71a2861cb3e4bccd8c3a16cdabe52502b809ae763f23405287c4cc7504c5f32dc4411215f0303fca07455dca9eae78785e0b280d261e644814777f57daeb5052f4f0a2f28ff0e89eef546cda01f04c60f7da95289118ea3dabf9385eb608adba6ac188de67f1f8ebdccc0b0da4c83e92ce35640f086b153275c72d63421fdf2fa2a745aed9f093550f2e5f453a890f4d2e624bd93e74f7b93e67715db7cabe46572b63e06c65362541237b04ee05600dddc7c902b4fc02c8436ae2e515447355b2a36ceed1a13acc2d51cc7c3ac761a8f74a249578822d57bd928696c6dc75a542fb273d45199c69c9c09a8bf7f1efc150eb90edac07518b53b336fcb4f27b48176483bcc66f324dcafdf83d112239a9f1e061fde6b86b4d7e989fbf2aa15d80cfc0abe655618c972bd94b0269ad56c81c48ee2bd46689b7727151da3400618f5b81aee36324549c74b1ba800db1d01076035a4e1212b044ffd72cfd231cd6f999ba1a7ac2323bebc9f8f95fffa5597cc9d827e2f08860c068db02fe53b4102b2c586507421d707495e460a73df91597bdf8b5c50f0eaa30dcd28ba22c030c005b64ce9c4a6d9997ff447dcc1744b1f1d7c0e25a241ba42515c3e54ebbdd7fca4921672f4970c82e88e3cc01c6395fcc7b5f9c2a8a1e7c17ec3d1923dba46d5550e13828a3240426aa4e42be64a87222a77940f7eacffc8ec8ecb8bd66a847f73a037a1c853a2b45e8e1f0ef2747434df1e1e693dad49cc3a2084b88a0bfb5b1c65d883687d73b10c303aeb81c3de2f040f0efcbe159f514781498ceae400695aca7295cbc8591faa15c0981619f5bf742bc6f537bf8e8f95225797cad133493b5ea60f1d120e00ea733c40fe900d0e9c1761545cfc3b038d9bed47e31407ecada538c8fa9e536a938379f0d83dff259906aa96267785e1a09558f6f702209476a3554047f33c5a1b491baf06a0ce66742110ee59ee85e8d2609159e86296a4741f032fb8f969f6604201037885a791c5efa247b72c3eba0072753c6b80c634f8469d8a855ed6637da489cbc3d9ee1202420c0cec83bc8ba6880b7fcb5be97baca0771dd3b61c8ef3c9aae9711566ea40bafcc9e1578af4665759edfc5eda0765a0d9c18e5f62ce746073b54280d6e72cf4662feb4eacd5654ed28aaff28a43205e7a39f9b95b42ea6da93660f8a7d96d45f53a809ba0658322991448a06a980d5ac0a32ba1a1c2231d13075dade9c1f7b55544711b2ff5af9f38bffd1b4dc1ced7e24deeefa00918502b2abbe47bef96e10e8b66c64e9186769766043477c7703967d8d7277e3161bf5a53d12f3f9bec63d980208fbc76343d637b485032fd05bc981aca5b0dce042213d2777e5dc4380bb5c650d08b6cdc546a7f358706a3679c7425a26cf576fbcf7ca51355aaed4a247401540c4df4075163f935344cfb631c6e1f896aa4f3d1a4d557d5b43a200e913b08b1e550ef70fd6a23f82d494755ed66e0b3e12e6bc928cf007e85bc4864778b55da08e933780007e31f47ccda0baabf83ffad26477507ddd823627f75112052d5c77af4359da6c9d0bb343c7daa5d57b7cc42b24329fcdc6ad97db71c553afd0e401f546ad1cd325a16f4c685801483c475f1805ea69d04998b934548a865810f3068e5b54d525528aa7323973e8751cf5f49ebf99690ac8559685ab5dda623942f5f3ecd05fd1331c196bca658a399ae9a0ba88937b200539d7766cd2a7638a84ab84a0c25bf349f7302052ac1969dc92feb22a4a2abbd366a22d773b42b21a517f44933cf9f895766ae898d693cbc5b3c0a6fb82ebd8876490249d9b123c4fed16bce4565879b1b90e5ee4054948e6434edc399822bf559d99635618739d17cf9d61661caf81930de950b0cbfc727d92ff4795f4e2d44824a3c649af80e41296d29a4e13e7fa79267e57d2afe44725378574ebb94e58b63d6f1231095c7f5113a02b96ec31381a41c0660d47151707a8ae6f8fb09080255ce88dee61d9c2ddae35f762ce822b45c19079d9bd1d6125f3e7ffa6b798acb4819b23319273cfecf8aa8b0428dbc2d57f4d733e600572d44fb2c4d501fe670a55973649a8e1ae4afc1c0e709d1bbaedcdf994a05f21b87382e2bab3704eb36beb1022010ff2c2528a64ffb86db86d6f77cf680d2567f613afce24e7ef1c79c393cf964c0e8a0d9c5c1abec606f577f0e4c11079ee51d63f73239e6f65a82fa5b58111a273d40e6b8276e0e15a15c5e9c9de0efdfe42c1bd4ce3e323cda9f0daf18506dacd8997ea88d457110cc0a2185b99aa650241c1b888cc734f65ebe1b0561345d99ad4beb1f89628b399ee79e4bf55db1c8990a54b637dddbaf470c1ba618fa742a6a4abbbea756567291c64eaa2525f91e6dfb9bbb3ee7d5c29145b7c0e3f83abed2ab6a8c8d1ff5539420a631f88fe077be0534479c74ea787fbea728b49675d48e09375ad963953dcd2a9b7ab20f07f09775d316908f28ef8ef7d7598deeb91f00f6b9e84f074a29277e2162463e322681f26e5d098011549a03f17b905653b9b5622a6e777d152a1d4e757f832c87d7b285ce6ce6e2c29484628aea4336d2a94b0588e9779b7817dd61de0fe910e786e7606df7e836523fcae2a97a95be2605fef56a7334418799309204fb2365afe7e932f22b89f0488dfe0775d229fe5b4805bd7bd63eec6aa1886f512cad51001b252437f3c90877f75dd78d34bc4e8911b531252a554e2fcf380e213c019a86361f90e4c3a3abd36a2be1800bf57f5d3cd4adb91ff5c2d0ec4ded6ef75443193698d6971e4bb90dc1f1e0dc5c7d70e5bb57ea6e0a5cfaf52cd152a2434d4397d66dd3bdefc9f28a69df5896092f11693324fad8dc890dd6c52bd5e8e9b8648e797c889aa21fcae17c9882ba0dbb3087243654915d457104f2325a7816ac1841054b3d41fc823d337036dd99b160c70881a70feae11f509896b09fb9772784368682034981640769641e8e8b0c09d9e3a5bfe2b165b9517bfc5212d724947f711279f0ca8e7eb85fd9c76312192dacf6e61624afc0e74b92e86d4aa2f03891cff3340c8ca61b22979bcb76094bd9864d5a3c36382d6f91de8cf64576ab04cba75ce421abc5b5ce4f9911f72f220f009896638aceb753675a2133ba37dba922d02fe0fe3ae0d6d534f07778b0f9de2b39a8b5a73ccc7751ee7919eb417c5c0d2ab4649958b7dafd3396f3a2ad9d10d006164e78b679bb3815010e2e76ebd38c13dd65d849a1df0bd27f7ee30f3756e61fbb31a347745ef9597d62a9c3326e829a07b0d4a5626fc550d5efc85da7b93348dad8541a698d3999ff812ec16dd1907eb90a2503dfd04c178a0ec840eae2ce7f27b2b70be576572dd578c2beaf4d8a0c9f6c78e19037f4025d0aae65f16df948d72c1262be9c62bbc75574159db7c0625497a11f96090063ec4409fddccef8f42e44a725ab217a627f53f339f8c593477d806539dad383b50fdecf61b6f916d7cbb0a769ab1df5570fddccfdce21f59517d429c6cf049633855fdb257e68b860b82e9e9badf134b4fa1399e4efd8b1d6922f258e8e330013b2973094c333b1b96ccbde9e968f6aecfbbc912b4c3f0fe3c8b3df62f4fa1762b4673de857501ef0b0fa042e93bc28303da7796e7600ea23502268a9fad8ce42aca3c97e768d0efeb2e7bb0f83b17bcf0b2e5004810d8621c7afffd90a903748da6080b39dd3955d74f973cff1b3b2240f1cd0cc5c29636f2ebed0d5bd82769b70f6b8ce5b8b9c3ec8cc2812063dc0ee286fa31cf8bc2ce87b8917eb4252408f0f74dcc5a5da272a6382e69e1d3a3958051903e07af0d3f4e9b0170e88bea160c766870a41852132c67bb1be03a57e6e7d057e931d5b986eecf96febdb40a60ddb6a4f6f352f7b81bebed79dc27a3448e54c9596449a45fa8296573c43f99d1b15e8150cc1c6799f0a52eb432efdc610d04b63a1d4dc2c3017c013c1ffa17b8d7433d644f98ddc884c6ec749ad8bab4c76b0f45ed832a1d0121b61fc365f4e45416c453b9af669a1ed273b48713370840401f3beb3ae6575f88b4204e1d1ce2fdf5648eda5555684dcd98190f05bc49df835dab6996bab2dad928133f5af62b84a886fe7d91c091fd463567a426456793135ef6fe827088a2728a8b665f56eb2c5054e03a65f5b0f36d95942c8823ce0d199129d62d1cd030b48dab053463520fe163bc6bd2bb9a597ffd2e1f586f06f42a595470f4660fdf8cd5fab5571c3dde0fe50e858306a395118d979b1c499ccc6a23c5024f2735bf4578a07bf67d8c973baef74cf3ffcbabf7e2fa2580953f5a4578a9979751526a4a17b5125e5c5fc8ee9cbcb538aba076b78b23e4b3b01fc026c07a3bb79c9fe647d398d43bc33b6ed22793cb0720d5a64aa6d266b2b48623fd01f39069703cf1c40283f8dc93faaf8e23d45f220b76abc0f1a02c513b2f217c08494f14f90ace7d251ea47aa12571b228ae315e066a4a3703e9924774d897eb010ad9b7b050fcff0cb2f27711b317796eba809a525f8d4aac14894024c220ad1c6d9cc24d05178e5920465560f9afda56f6fed21d1bbae07931605e2833f149d679ea43a5867a4a250026078085db4af44d23c672a4d00ebe7ea9e87e89c1e9b94bacf8bf309f193298316050e926acb81d624cfb22021e071b026735eb88b5294b5de5f293f9984cd3a36fcbdb04dc91297a06584cd8d390eb1e87ba8a888f9ecd2691c5135f9d22dc94dfd4ad41acdade62d0a2b5cc1001d59233dfa43874c47ecd537b9b252c03861561fa38fd5b674bc9892f57958c8e9360b17ccbd85b23fe38efbe440d2b008a1eadc80bdcb356106f00ae430659a534d1f7e98c098d0ed1d9f9617fd9b4d430a1f44e6904b6e621cab1d012b9a18962216a57ae0625491cbe0a87fee801255fbff4b3ce4f24812c0b945998a87ffd2701b4142a2a917e3cb201b4686ad7e4214b4c28eaa185167e3912b9e38567ee88218c8d738626739255de4c8d6027c20bcdfe6c7f6b48a95e6cfbe18cbcb013dcf6eea3f667a5d26bf63a6440f9b45db3d6e0305938c07aad1dfe8aaa2928905c8e5191bd5b2f3a8addbb5e96e7d758eb620ca7d541c308d5d259e66c7b49d9d80a20688ef3e2494ca1eda12b737f5dea55f2a96700f091c521212362b34f59417cfe326ff722858f838cc70abf94106dba222a311aabaa24fa729d208d55421646006a05b7ca31a1fc15a5c5ac144a53bd92e0b282d4277544045166002497f463cdb46a9ff07d28e400c19f8ec28c0ebd67b4a6103ad6de8a75b3ddd0a72b6f3719444adf363acc732317d8d4f6ff9fe53e58cfb8a842ad6c3af8b546e5d61d2e33a6fe4a17d663224a6a2d298468135734a28f405cb33649fdf985bc46353e6c997cf5ccedcda06d8c7c25696ae0b8871c9bf5f16626e9116f9c4b6839bb61231e5c9c2b7ff4ef5e85ed6c88bb63ff1b224e23f3206babdef2076abdf0d1675ad5a5d0796c5d02039fb2a37b46aeb88f521267dae636097085661c60e186980a00aadf6c153b6cc9a246518312b8ae6a44f721d19a15323","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
