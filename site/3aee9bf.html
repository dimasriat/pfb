<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8bb58bd7204929c6210bea10ba7459e0a9cbb78642df5471d0da898c6667187ffce89e52ad2246757bea22f25e585fae62537b643576d47bc3a8bc30932a6395feaa38a4fab570c75dcaf721aa974c2eb1a3113ef4e64b112e3b019a5133ea24531389d65d4fd485a66c914ef74b9846157d6edafb2106804e57854330c8594551280eff8398b05267ca70b0d806277c69bee7603fd005f10e49942ed08886bfef36eef879cef8303cf4adfbb614d8900093547e81d8fe12e37c7fd13b7a2a264ee374e7b5d1baaea81e93bb4ea521d02dabd7c4df7c546c58c488aacb1f17b608a22a3df474650bc772c3817e563e7355ea88f4dff802a9209ea618c497a436c39766d9cab023b836919bb5bc92c33eea1b141e9b90b688f0de240dd87ee659718ca6ca4d49907aee90a973b63413755e67192458c7f501f96258e80cd1014c4534cb641b0ee59d5a93029bd48f7cce5072b9284823df760886c86cb69267da71f9437ae1a53ac16e52aebdd65530752f89d6a547b3df9452fd8684100bcf82a98e635fc72f49a5b990132eb134140dd7e38b455125212787d9fca0fce187e186c2c45ffef748a1655c2b3624c5518ad525b1d19030d17befd19c10d850e183a38e1216f9899b666519838efa649e665900f0c3d6cfa94c4d527a6046c8c6e722a02ca1b5403e799e365607e71c2536f5ddb9855fa0642556d358433f2d599da8b80421d0e7e52e588aadde84152f70a68c35c33c0d56ba0258479be15ba72faa81b29aa7502c4c9ed38afe5a6b34446ff2a6c7988d259d5a0755cca69cba0921009a26c907e0a44eb5f6091301febfbfb950e48c2b5124ab8b09b4f748584eeedcc8491fc03294b214835dfb65cc616445a91597a81c11f522df2acfbe1c0f3e54b19901ba3ed840a41b20ce778b0f8d16ff67dc2d9f57c28bc4a205faa3d504fafb5971108ea5c7cf10136dc55259def13a46fb8aaac00440fa38b77e497ef195b64c1e41822a124f0b4aa0606565721e24cc503ec051ea46e05b6dc90d4c22950f7a25cc1e2bb17eb2718e436deec7867dc990519f64e87c031f2519e895b54b2e1f75d31c7ad9334f6e5320156426abd3b9e4d0d6ed237b9bb6b922c9dc58715e0cc908d1fac2db2881a9840e0d4d6fa362683ce643407f2b6592aef9e3b0b0a2c53f6dedb64a3f8d371136b7455c2636928a14a36d4529ac98fd5e6176b5f13fd335cb4fc5c8bbfba64d8921e152a45d73cdf2f0864cf3b1e56ba3a9f579b84967c54c85ed05ca09641a8edece41c529539513d790af10bab6c172f9a1a5fbc5cba6939a257deb24ea6e5db3026913b42510a1311448323d43c04e0eaf3967b06526d56ab4d65b7949134321037330f5aa1472a7489ec9d84ae4923beadeadc20b1b82111059658864d9a2fd44f8d4da4b2ff1f799f957e3a88bfe8468cfa75465ce21edf1f48540b0eac58052de785246bf13f88c0f23b587be031f75944a18e4c4d2dc6be639c0bc1258d5128e6cda3a8c954cce26447df788fde9d7752e1d0cbc8983170396e0e6d933db1983a0a4537e50e1524d73de438787e52dc39c6dc152c7a8f550df7df6e70a2ef6d2ce2b930e8bcea0cb1d34f5398b525f89eddaf15bf6fb54e9ad5949a267e53a032de7251e8eef6e74c6e719dd44f63fa376720da495982a9288487a08cd1c85d314cccc8ac408d8303256896b9d27e35103b59a4bca65ffb2d1a93e691844e59d00234cecee68822968986f0e66cb288facf70d84a73144c9b54b793805c9267832a121f70763fee8b57fe3a382a923f8a5d874feb43a5134f0e78ef2c5c8328c2976be041624e6ecad6f8b06769ffe4153b68c47250d0b5043c3ed55595dbaf117c6024361d6d88467741c1cd42a1e0e5995445ae1043ecb0e3cd82af14dfc750bcaa788da7a0665ae7d149a8bf745421b264efab0261010097bc65337b2df3e1b0f8996ce0de9867e11898d34b6da47074098ad8c53c3bfe1add20d29ad59d8115e7b529728d082e4ebb6117991f57b2f8f0e463f321e9343413a7c73104bfc0cfb09ff0b639114fe9119554ccdbe398a5e056f59402b95c420ccc1b906446877aa7d9a8b927f80c32f84421422596fc09336cd05c920fe777000a2f6131c2e712e936ac3a658c0c231a28a798d33b244ace34f47254c73848c0a33db9fe4d89a51ec9e224eaf210025d6123f9b0ba87ed9bb5fd2ec5b782cb3d1c38a424f7ff085705b97f267779f321c95106c2f42abc99425800b7b9a1cf9f382e9197f06be7c5382e5a348cd7733b4cc29f04a9a71780ea8eb8dd58d5b733266ef3bcacd892b51410390467dff906b4765262a65e32151e35a98bbcb26b53deb35e263e20f63b911bab56edce9fd3643e7e922b3f73497b1007b5857a853080e8c52ef6aa85c3a003044a636ffee07e88e2cb8be7efe16d213ea4703376d6368178466173e1e08542012ab1fa5a04ce6c697f2127e2daee3958da80b4d7c60e63f0451b0f6818b19e2a6691842adfb4046814b423baa57c161cc7d741262d0ac3866d2ae7d4b66a97e591ddd181ddc8516649f530ddec72d6c4b9d8c4d029f4833c62fbe4eceef83e3d121c5cc40bbbb5f8390d6597c340741205703486d1a79d74e04b19de352b4d416fc24afe676a33957531e39879b162603abb14f2e25fd19e8c17fb7c592f5769162cff49180d0e5f43aa3b6a3e0eeccad33cb4ee5da7ec6d41835647bfc37f547539ab4ec244319071d1c19b90711f2565d412c9859a6139d9ee4a694b2b5c7950995bb03d837b7cd0170bba85f10bff6839aa01d518873410059192cdb8282ba2186286f62774c745ddd5a6594130b52e1d069816c4b3f05d25324036b59c24a8839316512b5958de283e69959f2f461bde862b7624255263de22103b9b88e8ade7ece66954a62a7874f42b2cf5758cd290d639bcf12e4ba9e8dffe54a58f122e5d2ce1ce97e02e3f68abfcb0b82f7570a686680996c4d38a3bf5f7c15ccb65bd6e4c14f7b660bfd2111d06d2f4227eccdda38f26b1001259a72d8eac2854c2e0c7bb2c71eac652c61643b82bb7fc09c5f14377073e358b45d4db1ff0d12a034a22130ddd829ccb2c88dd41c6b434dd47ce0bd84507f00251f6e169a8926f866f33fbdf5455b90b2bf11b6480c49e06ca5ba4a62bf805cf426a0feca06d1f769c0b2361a01835bf5dc46a6f39094b906d688336fd017abf4cd726661369fbd1b345c051cc177a14302db54121cdfcdcd792a6e40e9ca0056fac394b2acf214fd2c15c9730eab85d677880c33524110ebbf41bcbd1610c44ec7de77d80f92e265d17bfaddd5654efa01ada49c892ac93111abebbab871f7058c3724febe34a68e5c989426f44be876d9848596cf07a98c1c3654f83415a26b7bcf667b7c7840fb949b86ce5f09e2706773ca29ab267dceaea1e13bf6d8b65a87eadd294343ef440477b2fe64c9d0d4cb992895096d64897a4b28c6c46e12ee876895f63c2c2d7e5723664320cf7b1d485f86e2c7e90cefc09eb813c37419b3fc5f52c9c15176c10dee2a655e16d8860dd8482b5a5e01d8574fbbfb6bd4fb15daa62cb663c14ceedeed5fa4e8faefa2d13c692b2b3d5902e2e5817a0b2258c479340fd5f74f535897b862565f4018f5b7df4a689cf00e9d475f358f0fc58f0a1ad4fd193591b3370cdb0883f6b7044dd3def28bbe81873dce91d2ea2160d9a4134b908b45c8a71c0599cc0e66c388fa5de5d6e1f418469a461d994441f8da59277430fb07ee99dc72460cc52a2f8e38a00e3befcaae2a82f16294413f611e4deb43bfd5d9d0c20acfa5d6a3ef13fe72584c8c7cf9e3a3b9211324e690f3708eac46761386ce0c5304b7f006548b46a2e174e4d6a78a1218c66cac7b2db7c75a2ba0392d5da408bf483fc840d3437fb33aed5bccc86052efaf1a4266dc53b249a8467511d20775bc578fb1a1fc41757af950add6db6fa07adca5bb9587efd60169c94ceddaba6b18bd7e6da17d1d769a8830e33015e228cfa59720bd5202a92096e72d9388b12154b172ebdcedafc8c53424b4e5307ec65846a492590a9948094699d18f4eaabf755e8465187cc944e689d1a534558c3761d6856129a251ce77c5c0a32d15d46cc75551e9153fe540714b15b6869b71b4b97d8fe72d6dc83ecb59432f48dedc1eb96f20ded28ed380cc83002562dcc2c30aaaaf9a95a390848f4aed5dcd7a94da80541822f32ff923062eaa9793b15bd99b0501a97dc20ddf962a57c1224060d4008a9cc085b2fad220586625cbc9c3cb04ff7a9e8b5cba4abe2c9133edef34437f8fee067a75ffeae6c75fb607cf9aef473f0a009d3c04e12576a7efee574ac38e393186de5acc2c2e62a2fd9cd26f2348feac9e89675a0251f1edf2edab80d9ea48804d489049a329681394aff4e6754238339e0d92c93f9262582c57f0671a781e2184191a2a08664d984765e8a76ab918d0c7ecdcf878e29ceb7d34231ac671dcdaaec0b0d35fb9d6216258dfa57b9f2521f0049bc2d0c51032e53b8c449e19ab8d48a1f8747bcfdf7e8c12e472432c1d21f1287cf48a6ac806f9c236c04d78f7848f47348683131c187f9ae48c280eb968e3898bd8ebb43c2890f5387fe2ce61ae1549b885f500b2426ed3144e88cf729cb300c0626240c17a89fd52967142a56ebf78eaea9b2de890395429045ad9262bf3e0e0c7d964da1924c2e0f8483f3b53b89a69d9ab8911cc33fd36c2d31c77e0515e2a3965f6d1d8b1b21c1f523af224c74a0017348ea2df06cf04fce777ea92f8086dd522079ccc297f0bf9753629e1d8b2136b87446b046f575004aba0994c6fbcf487f64d622a17c0869765fac3d14602da66e33874f1fb2c1b8a4528385911fcf04e399e612e6eccc82b066ac79d48f470cebe02f425a648e37a8cab636dac6c185e077f2c0a196ee4b6b348fae8a10c3ce90995fcad0d0df23ce608929544a6df8e31a4d6130bd2be7aa038a31d10e2980af5d6493272674adbd741e1f2387fb38d30fd01f9c5c8ed06955d1863dab2657033c1e4fe840a116a55c2ff95de4d8c9292f4b8fe48b40bf514bea02ee2631793209a0ebf8e97cefe905d5c1b3706ba66f6209f7404ad5cea52ba40c76af23b0cc4cd04c9063f01597eef8e3939e9df3b1d5e6bdb5e7f1cacd4a475e84bb344db9ede2d78202afd0e272ba5592e8636f8c1e370fa51c26697856a35c1957faf749a30005b9014e4d2e1422261b899d5fb99f9f9c831417ae39aaa726e402f73bb4073d93b054aaac435cc615b33b450a4d7e10136c6f26409bfde7c651a7b2d9148d510f7247a43984e783d45f76a2beb33bc037b05ed02cb69e022e7b13c9394504e12ac71170e0e524324c10054642c3e309a60b6264e06fabfa9f839222db7aba1a63724104db7c31f71a8cd6f9fd30009202cafb4b71eb0308844e84d0edac5be80aa333eb31c394fd0b7ef10338f3f78c70c0524dfabcc12ba5cbd6b619f3fd8d588aa978ca79f9d2fb3b4f1e413ea6731cba38c1d622f204601cb5740d3ede6179d73bb7c6f11a663a4f4701e4d0d002f334448de27f1118d8947d6fb2d2be74e402e642b56a344f41904db336d8cdb0e75cbe25bf3c63a35702c51011facfcb608341a395150b94013af42df2a16aa78eec3aab859fd71b13eb99a5996e360ac4730702594baabe33e940e9d380d8097bfebd51bba7bf63002690d983afeda16af10058532caa1042ef81499713d98759afefecb3c3f2fe706e1243b60504e51d8ce8e25733e1cab4f8fbdcb85e228eada2be443f1d60497cf0a3b7af78a234b67b89e2955d5fabc723c6866111e88c137cd358529212713f56600cdb6d709bbe513c1e9eefc04705b9c6c83a4845346a5d23661916a9e35cf051ecba5125bafda34afdbc842a59c9611dde0b2a7bc7b28014134644fe6da48997c177bf75810bbfc7869ff643326aa6d1514313fcf913376a7d8dfc62dfd77ca0e7729961af9f026f4537ae98b9e31124dd1e1a340dea61eb74b7e05851de2618261474647d7677cbdff76220981d4dfd76108a43c928dd32e372f45778e97dccb2c74db400ad21ba6ca984c45119c107d0f8d5d385d1c13850ff4db4a34d2080409194af840e5f733d25aaf7479eaf7bdbdf92fa535c52d2bc15f962af21fbb2d65b979a248d988c4d8263d884236e02ae4c3e5ab8ba0ab0efb895deb1cf00517a4ef4a8209db4a20cd8edac5e40ce291132210e426d016712e396563705d618bcf26acb1bc5d0c612a5ee83fce10cca96f30b5c8985dec22b1d68257096e899f7a88774d6bd78f0fdd47e7bcd60b8754c1836c4585b97e18b2fbece7f7210da3a398c40327325232b7af48a66a9235e059bb663489d897b5f3d9eaead98c8186d481a8740e5172f8ddd6dd5ab1780242d68eafaabc43554c2ed49f3fee21cbba618eca5657fc00d3538cab9158b1d44da51331bc3fe9e355cbb94bf62ac05b188ffb463e0a5da71ecea8301462fc66c7a839640dcb078d7008f7af4dcf2289dcfe0b984e7e0156317b6e1a3fb24e7f5d122446951c23f04a5428ceb95146d637c573da91efd91960c7a9c2b65254b1d20e3ddfbd3600bff593e206e8822ea9fd651b39c6e60252a2c0248af007ea963332b104bfea81cb035bed0987155a61ff4cc42d400b67c55d7a89b54a926c9b1a5119832fe641b4063d7307fe7a7dd36c8984edcd0d68b994067752bd92b63c127a31aeac3a22aedcf86debe45e1ae16f55c042233710eb2bf88d4b7743fd9fbad537e2a4794489dd198fb08e921bf0dc9d359f2bd421870528fed19f58a9d2354cc05c0969fbca5a5395916b82f0d2cc519566f7db38afd775a7e563d063e1a524db143e03f7ef71e975e15307a1dce06221b9fe7ff6b094675abbc3d43eb7ed7df4587696fec4cb68bfbbe6266d548e3e9df1edc0f76fb604a00b9ac45f6267f64001c67043e212678c0e1a205ef72de46c5a5e69b47956440a3c5297aa56573e4cd4181a73874da4d52772c2b8ee88b351331faa7edcea847ba7c5739f29d501c3be43a21f70277e2fe35d5509124663e012976119f7b0f42b9e932148b82c0746476aad38e156d88172b3cf68104d0934f0c3dd678da5e89606b5a956d42025d1ddced26da9e9e89da8345d8166dc86ba19ad7feef38dcf9f45e197a2308e3bc5db716fb0612d98cdae0ab4999df72e50f97b7f742e5bbbb88f009f08bb172995a91243336e4ccccbe398706e115587b14ebd44417877be80123a4f0e85cf16bd448a520000fd2fd88ca43df53f351507316bd6f1c3adbe31d31b0fb30e523532051d1807d7fbee2d7949ed6377958beabaf48f93ae91dcfeb7014be076771986e59c696a71fbec8d3424ad72bebee278e890b011d3bdc5c276ed40b593d518280745ce226938ba2efed4e12f2b14d0af6250fd47172048182839c9e27aa011771ba4bd870eb75022839d5f1fb134ef3329bbbe850e488ce1e4081834f9a10a748393f8c91effe5ce00e8f20845ebda07438ab6376309a99ee7fbdb64a5df2c828bcf085de33f902f4b02899da99f56cddd9542cc8f385ffb0a4458b0992f1eaff31a6702cdfa0690b1a865b3b4485d26454b2545712e500aab921b729543a91594718fec0be12a62143d7825a227015a28f44bcfc217d665b27e4eb8c1f91cf411fb37382aa63c2932d6e00e205b70aa0a7199eb11854f17d2fda96f50539de90a776fd6113f9106403278d8e1af7a03205730d98711ca428d4617573d409ccd4ee57b6d3df1bf3397c8dc8d376b38726fe90cbc869575040089a858c2cefff13ca23c482867415a43546052d906432730004b4cabd5ee7230cdabf711c0e30539fab8f18687e29add02ab22a9827a7bd88b937846d300d8bd4bd77069216a6c1f0cfeb3de410d58bcddc3536d492e87521995295424610a8e6eeaf211d9932a3fac38c5ae95d41009c2d7821a610ba94e56c510ca79d2c269a3c499b021150aade266617c721d320f4bee01a14e564f3989ddeb58bf1d13eaab1d326c91a3dd7c31ff9fa5cc2575877c169c4776039ca28c6c600a5e9d60d7ab77897e9fe86447db2f4b45de0fcdd6a2fc6ad8703455d41200736af8ab79745e8a1ba827bcaf6a1b0071dbb2556850c176f640ddf8fb70334e5261281a9be848f3de296c387f0b17e25f3273778eee3518fcc0403e4ca125c4a828553ca6ed1ac919fd8bb37329689a1a9ce5bb014825e66e1382c4c3bb15ccfcad6c9b225e7ab70dc9f2d7a0230545579af7c5bbb0d97568f441934ffc588adb342c69b51d56da58dbab6f752f615df00cea248163d34111c5bce3f0ff7b79785921ff042ba5a673034bc43c481731585f9dbac4f3e2211454fb61dce1608015d6104a7b9dcd1612eaa5459753facb0c6286f144c8be97cb01f6a953a8abb380c849ed5a39cddf4f6aaa46fae9802c0102629464a46dac66ade8821c9cd69e066f850f5e747b7936e5cc3aaeb2cce5cea89d8c4668717318c93035f7f17c378e0befcca9bcfdb644e581977bdcf592fe759b5d55b0a6ef05ac17fac497d011b9faf1ecdfcb3fa6d974704017b19f62115f973e718ca9df4600858d75db8d3102f3d9343c2094401bda97ecf98424957315d78a504acdcb08b5949191e800e4a73cb50f7774a04d2e91e56c4744272c8c2e8db205e1056362a75a871c92701b7a805a4746342281da6c45a68f81ffff316a7f8007a3e12580a5afb6a3d95dba9a0afa6af92af3b7134536a714db9140109c5a475351b12f6750a1c92557a37457aeb56d5c65f79c911f1ac7da5ff9eed3e34c459a3fc81335ae6fa80ba762db8b8b630ae9df45f4f2c6bfe9664bd96c07936045f766d429fac80da9c9356629ff692e8b8a9df06ef6ac01cf06b38e5d38dcb7723c75b313f6bbb69e2462397848fdda2c485b186e2fd6390aa6404103be42095fa048ccb0dfebd3ca28f2cc0b51f85359d7006c77ff090a46aad4d907bb70b662dbd6bdad490a9327a2eb5cd7163fcd9d41e19e6c27a981c91bd30aa0454c5a1e49e43e0d6be98a7edba7972dd966f7476de3075820a04f120ef6069e9ad9ee21c66e440d0e7d6cf1966fdcc905b1b57184b7be78cb089203d14b57ce0367e73840cbfad41bc43b72d53c961b7afe2e1c8aac24aec2ed8132ecb66cc102a2c5079a9fc9d9ac11173539700f718b57bf2ecab9d33ef930dd626612105625ff13ea84bc8c23066e3e8e32044d8a6cc9c6bd2aaa8c48cbd7941f36c050454176b5d755de95d18a78b1752d1e32dd022871a16868a03dc974f738065d92b2cb7a9042863d14f54e9baaa189b15d05ec0ceb6558118193b023e15f790182cdb64a12657e3eebf114fd7fad3d1d32d4f79a5780e3ff728ad6f6b72c1c203d52a09dc3d2574025ad35c2585a81308f0a448e2f8d01b99b83149242834228b9c8df571d43b2b5c53950767a999590e2dfa13e7802bf1f238f97f2d45892d921207cb8be6e393f72689ba7f1235eab4ab0fb4460806da55d044cd572b864ac242af205bb164a4567c6682e3d56b64b59ff61598bde729e445d80a40192c225a8498ec63f13f4fd24f555135b004eed7137bf1700e89010bf37eafd4ec33855f94c74134bdf6a53d7a1f5656cc8936f62ae98f43d4674226a599ca48ac78e3d335028d2f10c11ec39a4b6b73938c3a81d7e48c55448b0dc9b4d1de540da5a0fede56f2de3d0f54be8bb55e9a4299556ee5451e667d2dfe64403a8450ae8ebb181d1fd6da91a694d4c2ce5b9264b720153184ce9f04dd9c0b0345a1850f7e336473b07589cefd2ca5ad7ce5cb9c45a740ebd5a4b8277ed23d19c01f88ba0c21a4182d480e8eefc7d27f23d2690b22ba5dbad286b54a91e2310020ec35e7e472453e0d9c7007e01d429d66dd58fdbf496b98c44fc9a8a7c3321be368f7a242c9f6644a378d0e0ffabdc5d0702af9e249351874723d96c70be6f13098394deb1586a75c0c53362e73cc447538597201a2d98c37a490e9a8b46aebd70ba21fd3704fbad082e5edd46f77315fe949d344fafb20ed1e12f71dd3485464e56665e992511ad483eeb20d4e1ee7494a539c89f5809cf265b65b021bf8ed9bb7972ab4906461f7d0cff1ea69fd039d97d3dffab47218bbf58e9b59f7c9c762a24953c1b28938a4aef6a9a68dee244555da7d35da9121399b2e97dea530ac205c64f0b5c163e5d84cc72e52faf3ab5d8a0dae5448ad42dc6e1939797803dd43c23deca774a957a28e51c82de020bfc354f1ca28ce29a019a71d48cd90ad3ee3e19caaebecdf5be3fd58fadbfab513edc1378770b15493d2c1fb4290df464ff5ca7c9bc0e74ea3b6f9c589b7270cdd1df6ea03e6a052f2d8f88c556daf84f6ddc08abc3b2b5ab18e9701975b04de38775c32c8a67f3c681d2d2a7a505ad0e020d69f1f28a2698cf6c0f4a60c7948d650824e1bf3ea3f2a987a0319a6ffb34fb82b58b6769e5c9e7440728abea055c39898af93e94efd19f5838f666b23c92bd1ad90ad30cbf0077acbe24c2404eda6f4da441bf15381251c0fd43a26815d9190d24a75a8202a6620a2197c7cb4afa00ecab7aed69958da99c8fdcc0cbc8e55e9623ff8db79bf9d12aaa6993fb0916ab6fb77789f02dc61d21dc34a1ea61b059fcae9d94e37d44553efb8f71c17aa51991a94647db13f243304bc218fcb65a9d7238ec7057f11fb5598a1294bbcbc3df48889d9b35f711f9f9d4ec2db1fb3b97460013707ee3c45786f453e7654c710c46c28df857087dab4437fdcc6a2be79833d0c93ebb7417843016bbd14b52415e12d10c77f4a0770b3d2d4f1ac9d10d6e4d02da99ee1a93d2ff6815ba02602724acf58088e45aec08b2032c2e453e0beb854d867c03ae06026df467af786585b49a4432f50e2ff6b9717ea6e9d8e0051b0e756cd0f90e5480c6f2284b6e911f18d3ca306bad9d86e67bfadba27c8291b8d2342dd3a4d644cb0f64f132213b9f1c380a55f932ba5a3f32e9382dbfdf044d8a1d8e04d6e6eab88aaac525780a8172ffd09093672b422024f7e9a9ffc22b55803addcc858d1b92789a4eb7aa7949e3532fcd5f946bae3b9ebf91eb0733853b0a0373b5ad28db07028b05356ab70a0749558b90cb1ef67942a1cc9a321a1291d38c3ca0b5a9708e27febc73cf22939a734e07b762c9497f8461edd2fca846b275b230453a51caf661ad6bdccd031fa6cf79448c6839663c3d1bbb8827d3d6be488e5321721e75b7c60b92d03e2fa919b91e117f32966d675e38f8be9e110c0703262d59e6adffc98df4ec50b3af739b62b6713eb184d983382cecc88b2268c2126b5e2779e23f73f2d720d06f8fa9cc5223e5438eff70eda7a6967e821f9c5fe6cf1ea70a844e2e45b738fb7284fe845c66ed0b8d1da0443f94d73650596a7c4148bae0eb738a9d38c317ea0ef5c3dfa6a2391f2e6a129d4aba3cbfed227488dad1d3d562e57555c763b99c00691ee5015e60b60b882db40f4f116029cb642faebcf65f9e1a8f7d5ee3feb30c10869636cbb0630491d7ddfe23ec7dcd9df15fd37b77bcadab7a23c34f82c27af6a51a604da53518137cfb195e3b635369fe60caa11d0886974ea3d9c91b18bf9e76f1ad39b3884de4ed0745a99a73abc6d571d05f2ae76c9f35b8f9024f9dc20601f5fa2e8b4b019fce9b4142300b174621c977b6ca1b7ee6d63ae5cdb8b750237bfad88d4f21d349e50fbcdfabe9a0d5ff307da83f8f09c7d0af82e0410fdedb8d922d40842341fd117380c5e72295d0466cda73465cbf0ce78cef4ffc5bd91f8405a5c9974d5112c2b5516745febfdd37c70ad6a2da08edf968f7d3f8ce2e62e5e07d877b84566dd613c8cf035d8b1c7c2fa50079ada7b48d2f83422301b7911c31af4b5e47d730c8d2bea32ef5747a77a9001ef8dc9ba478cf1803a6850ec35218f568e0a77e3529a5eb23fd94aaa5816305a73427e6bbb893152ee7676357ef60fa8e6063a23d203856e62a98bf176ab7add86f9e58b94ab31fcd20076c58b021de4f35f449e657a0728428d58094e4079f41ae1c9f807a9ce1dc7274fede34201b3435486181bec5ea63a8fde657e7b408b19cc50f18cf04c7589a4771e45d286ebb8ac615d4c94892e9d2c8faff71ab2ddfe10474b49e61ec198d4f44a6d2731798084fda00a60d2a8955f1b945a820d95aa7971627753b387f4b2cb406a0480cfa20d2dfb9436d30787a607c3f9d81ebe89c564cde7002d347f87ebafdb544b982796ad411b4b5a77a1009d4e2c44cd7d4057d0424d7560e04a55915a6d540838c334640b14c845be57a9fbdca6ccbaec4c53f9e4c9029533faeacdeeb6c4f5077f075fe18d5543a0d3234d1c3b0fddea03f8385ed3b8bf8ed26338c4544a87b29837c9327ea8fcb19be71f275052cb91e64c82b93aea7a3d3fc4137551facb3a99dd731b4daf513930d24bb78285cc28c9376ba1ad8822d37df58ee02f2001f4f08c06db4d8bd7e88e4f3647d29211e28a6f3574fba83da8826db449866512a077c1b79e14df73f184ce09641c460600190bf19f3fdd531abc9562b6b70e476897486e37b67b1b89c021365fb9151f847afe236aee88f875788d5f0abb80fbd1482681c3168660dcef80218bd85e944597dd87dee4212ac90dd85d50cfaf04f32549e3f411d956f0585325cf0b4d709e2266189a5541cb8a0e654e4db11ac0e6fb8f7361572b0eec8a77ab1018f9baa54f905fd40b333d7317b93dbce3fcc44ad21b7a944980f19d972ccd541eb6a27bb4225b4d4edb2c44d316191bdd6705af02e7d56e2516842c9eb517a3b02fd8e758a16be6b4539fdebd4d0a9cf98e3f049abdf24f46280d687abb35f8b1c50e5c6c2fc8848467e490f8529ebc8c05dff308d0ef3dcb28aff0eee0469d44eba8014ca9d59eb78ecbf782167aa9d4274ce49185c1d706b03887dac3d6f80d27cc83f031b71f33a8661d8ba810954b6312ac4b351dcb1ba47992cb58a2a6e52b7f4900cf53b8fa3ca0a67b14458815361b39ec2d47c1723e18e0c0042d35adb3807dc3d68da15ce814b1ea4536fdabd8500da1fa3f4686b9297e8c74e8f175f794c7a3abfde42186d729d95d43af37f5fa4398a73ac717b50a822525d49a81554856fb59f790f8ebc99d60dbe85ab6f27b3e58519fa16114b7c072d499267cf7cb57d30e81a3bf8c753ac93fca76fc512af3a2310da10c07503d85abc9e9dd32d0f83d25e4264798a26c814c7325867e3806996538c43d538d55b4386ad7ce2bb030ac4cf23b8876a99657666a47b1a689779d787a17540b2f476a319bd258d9ad3eae21517774949f8905e23405f2a9c158df75e569c652e0fa34723540eca6092ff58f9b16ebe3d748cb7d3b594cdf049ffb7c0a72913872286dcf7653530b0ee66ef91fba4e7b333abe83ff935d04e5e3eaf2fbe87df9ce7a475d6b7960d6f0f4e6882f984d8324999cefe55228ca3308d30aed98721d117ea0c015da550a30fe62e50e459ddbf9ce0ba32822ac199a6f97db3324e29de5d6dd02c7198c4d3a635ffbbb5c057c8c1e6ae2214724f934aa8e07a3d36f129993c8a9262ebeaf976432a876ed212d84705fd2e5dd3e70d890f33df01469f615e4fb413fa7c24367a9e48bd3e2341ea828c54bf52d53f6e304385a721c46e388db319a3d882ad1872663e8a56a15f9a871d8f07ce66da860c236e40c8173433dee7bf907d67e445938a0846c052c2e9e7bad418079150c7f680169e86684a3d1592487f7c2ee823ceb0a3fe0ff3467b18e2cc8c5233f084cdc87f192eaff947060dcc4b9d58a8683fba603e488886947d55d5240a6573554e97ee401693d31f924eeb123c71e43b21b829a7fd74d300cb0e2b4d76cc350ccbf14aa6aeba092f2fa07bde33085c80504b151476e2ce0c8df404a5c98028581ad5014dfe158184","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
