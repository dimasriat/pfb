<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3358ab8ea56304afdaa6bb6ba0796f9995822ab1488702d39c18f8b67a382e8f7ae778bcc8e4dce4d3913d94214644fec0e1fd477234ba4d58f4973188e4d44cc1480cb19b00cb516bc3910c581f750be68e01f2e314929cc48b1145cd4abce4f6def3e135966ace95e0f16c2c9745a0b7578315be5d5fa7139b0a46685acd850e50ced18a78de0f6a23b29125b5f77a50b2d44414c917c5ffb332339ff94b899c41570d7b7f69ff7b95419538d2229ddf6cf53d18c8061e99d7a4df71959af02e970815387dc96617ac5d30d65728c502abdec0aa10fd191f89bab6d275b4037003d6a64b92d1faf543cc29aef0d290772ca6cb68d9cd96d145d5d347d4e9e140fafbdf399638c304afb098b6b93fe9a3b4752fa4188fde7a063cbebfc94ede72ea335d3bbecd7e6f274f3368fc9ba2ca1d0fc35090cf72c2d1e1ba689ff5be5463fa9878ceb18fd1b3d4c44b3bd474db84820c3642e47bc9631b62b25c7f15712a4b7676155fff06dbc13c0207f39e5620d9a1a0abd08552aa48f673a2f809e0cf5f9a96d5d9679e30c046b96a149db143b70208a106da6502c0ea5f26997487f99d6c92a8962ab43c5a8d510053db6eddd7bbe0c1782c5fec67d71b2b985a86e3bf493e4d8357632abcdfb82a6ae97e08aa13fa68d321cc7e1b5784a749c6ac85fbc474e85aeda8b92cf9ba0e762ac4c3d1b29839b803eb82d07d3b6ce75c70493f289e7a38123611faa53a8574f73300f6b7387947b3e74ca39ca47d968257bffb96e3416bcd31380ab3250919cd36966b8ccb0bb65c4dd302bad19a9aad531fc6eb2a1f39d2f10e8f0405847438487df74850a105495b112f1d96b6a199e0fa8dd76baecc89395b080c955f39d39579b3d84e23acd490500ce9689db20604e3cd704bb5356c6fd19fc015d30053ae38b626162dd842a97aaf87ca95df3b300f3cdbd19d1aae3cc8e43f5c3c59b5279ce0b321b2a3b1266677ed1eaf73b3aa2e2fd11008b7c3053d9da43d6c068753af66b827c78118a763f5a622c326b7bee94f2c53ec70c27654e7da7085b6782ee7a43d19f68eeb7cf701ea7dd7125601a1a374b28c226ac22881a5cdf92ee9e72d456e1634c491c720d8874941fb93465c6e3a0aa8d24ce4827e0bedfd5be48f1969c56c7e9f1a8d2ef310888ec05edc1361b32bb2029a0aa3fa9bd594aaaf6a31da420f5dc6a14c67c29b71f5f79ebdfbf95b5a2da115160862c2e842aeba53158beb33a613cacfc9d87fc5822af5b3cff6cab1b651118ae2fca3dddfe9148be8c644d0cc72b2a82d4c92a6f9ff06c84302cdb88b57c13f31aa535a53856aa26dfb06d4680b3575d3b200ce082e2f9345776bf98a3c4fd1d17f915cd9e0f35c1ef15dc2abc958ef3f24af0f3125a1f7b6ea9ffc428aee71b7c7490adcdf386bd308dbc46d05f6abd05de1293393130154a33c4a52dc8acb2e1949d938476b44b02d9066aab5758440b0e1463d207b55c9e77ff5f26c196cbf7f7a3fb2f77eaf22f3ae9cf200c6866b1ce5df4af224e3acc9895c5e37188a0c994cff3ec1d0798332467f4e06527d3b0090449e65816d6952dd036bde9a0bbc9306134b4820eddba480fe9483f07447a7e5ea4266485dbe029a5a0964caf7b8e9ad18682861d4b05b7dd3940d1e07c6e62dfeb816f4d980c5a7cc0547883efb85ba7d0ddbf909fd5887df2cbe69ae31a6eda88289b58c8e88a355c04096f513aaa28b5468ff12b28501a5e2791d62ee4e7ffb19a0b5f34f9e78b8b2178283a80ccb525287879cae8096d7155906f3bdc415ba70a6468f00f2291d4e24faadbb7ff85bbc49a795b06c752e089d3b9a842daf0d970ca5354e6c34d7711d1a4247456e8324303caaf157121536beadaba4ec3a12d13f3fd25996a9a3b16a042ce34118e7d9b63f37c00f0e3faceb0264ad6cc9b07e80c6471ed1973afac9f661418dc37011ea8dc42ec8c38532f682513c8d682bbed895e82d51ccd359801f8b1153049db24c9e91c67a3330cf0d9cc8bf0994f1a941f05f0eeb447ff0491cdc76be6cfc84a9a224a69245b34d597317e2e5600a2130fe5b6cabb6433838d600a2ff1052c4e17fdc3a1da59dadafc8a16b916c6529fe6bf0fd308e284d25a2593498aa6550c775958f8a7a1f5ab35a6aa204e2c3e7756665f5584d3e423aa29770bb26e959b73092af13e2c34f80f77f75b2e1ead66242357ba2847da074fc5d005e23915982275fbd03a2830a0716712d9526c9694fe32d13a4018e234f2396e8ee56f3ba9fe4d40c13c638e66af00de963114ba8e2828e6b7b74f05cdd6b3f2fea4a43871307496bedd705460d6ece2180210f984a0568b2f05d8603c75ab39d55be9e3e9114c99fd393693d6bf52de7a89a286b356136adc251501ea558722bc1de7fc17dc26fdd37c0751c7151417a995a26c6a8815ed6f89808686ee4be2a91949dfd5430b78d2bb6357e28339a0925f8795dec2ab4ccdfbc5d4304f52eeff1fa69ad9f17c10426beaaa0945d6f2c77af1267afe89b5b38160552ea7b6eff92875d0bed33b13ce9724f59768eb008fc18cb8730c89a050e407c68368e4720d42f3ee62647088df068084a4072d101c381b4ba9f2ae6e1a7ff9e261a5db9dcf2f694b49f8ad40374265f47e21364f7449f14cc1e6eb93643dcf3c312b84ea81835abc09ef8a161b5ea62cd7f5efb39b3ea688b2d603d4f2adc311a403b8446a1826ff159c8497f0445da74bbdf821f2fb726d083bb12874f6217de6c37e6e68beb739b061a175ab32d644664d28d0c140c4d68d4f21a224f0c74531dc0407763246ed9ccc8f79fa230d747cd9b4518966704bdcc84204531613c364be0659d60e7ca4ec3a17982d6bb10cedb2c8d2453b1ccb1ea12f61de84e3e7271da6f96da1d37bfa1e4985c646200fe7c74e8e31c238d8e251f488b1695a287fc794c943431d5bd661da037183ae81f67145107b6ff32861ded7e8f17d5413665ef0579ae865f0858339f9840c1906feff86cb4efc4398d03d302397681d2e5ef0f7d3a5c0b311101d6eb3c9e7c30534f598aa2cfebe23e1075f6861f3c2699ec8e0aa7d491878aa96c4fb6fe5e7f0dc3192ca808c27fb572cf3b49a49b0f9dd717fd2ec5acf369365d4506797053af5e202c3abfd4365ad7042d987e19461877a1628b19290e1e24afe9d8e7afd6293bd84a8d1ecdbb35a8eb9c772146ef71df11cc5f35800743fae7065684c0b40795bcf6afd70d76736c3beb6f1417060a92402a945006eb13b094f031462ceead9fd441d98becfaf8d2b3b63ba892802208ee7df1683d072889868ffb4605e711310c561bdbdff552f29ba2cf3b8acd4059eaeb0c3c911d1b0a2dc2b41b08033b06d6c034277884ccfb78ec33aee2a60759b6d96ef172edafa7265f409fae715edf75ef34e0bb424645c3e4567c833975d0a6fa81ae1dd047b776623296a46d24e7c00844df37f188089c78729e0725ec10195d77081c31071d70b1aa8af318db556256bb522dcf680524632dac0350ce5c46fc78dce6b223d1c0ba6344bd6694587248953f5a43caa58c37527f9ead0e0a178ed7ceef032186b56a4b54cd52f563a45b58df6cf7c19e4502591bce7220e631cfa1ee3b807a9153835373ad4ea8f399ef9b3b30cdaf8cf76d126f0b57a5cea74d7465774ab35811c6fde3e768f0c605b0ccf6cfa585f55fe234121f3a2b43bd3f6eef393c002c1b0ff6bc4fc08e8b3ebf2022167d1039c29b8485b4a876e79e005782a3eb34c8b18930c512aadc6bef65368fcffe979d7b1f0f9d6c5a05ef7ae7212b66bdbdf24d917d4061a94d8d0c579143bb2d29633b8dd74640b54d8cffa3c4d6bb12bc7ab3f1b9ae9ce4e002d2e94f8dd5ff137ecf8b96f1a60bed4d73c5a75013d4f055ee451d5fcf7dac8b7e7a1cdeb1594ebe7235694ab96ec018a5fcd2a62b8246ec18c650a7d4dea575c948cac6297d1193b51222e6121f44a953627ecfca1c8bb1cce5aadb4ca49ee51f004a81d667614820c054658c08e15726c659a3bafcde725d10d108fbfa6699efac5394668bc6a263b6962b62f69fe7872a4c7c78a1e1cf97ad4c3af2b8dbb989772c9b536b5e0d6a013aac96c2a412d9575df8460fbf50ba95ebd88f65e9141f5698f56b10bc9cb29382946a6b4429c95d596947b2a17c1b35272899c7c9a7d8f819c0a9174c2f6496260a6072be748e6a14cbf377d4af994150d2b282499813b23a924ae37b261398acde69e297a03e6d2ba1f728bd77413985969a4cdfc4e0ce1670644de507a348e6db9379f28abf1de33166462678fed2009af7c5117d88b4797563b1111bdc0754ebe32f2f2bc86fc88910d0da06fafd4981379bdc02f1a6a46203d6110396da684e2e7bbce10e2813c6f04a539641c3ae7b0818c23ac7c72d60144d08c32147d4b9b964f97319331842c7686f64019aee95b27818d5b1d74c3fd1e8224d60d365dcf0ee76d7189022c0af5f5961d8a50f945834d6d25fbfd31abdcd25ff6bb88c718bc5448b390843fdfb8d54f0bd8b2888467e1ed1531c53441324955239daeecff1b172c3cd069faa11bd70bbf5887924d303d1ea77e9967dbfff1505fc8568e382f0b42c4ebbbf9c89b9cd227ad57a4fdff47dde3e4f649d1a9453f4906d12c0f82336b1f7b23e395505aa74b0a7bb4a50dc2842685d26a9594eaea7190d29de1875b98bf01c1d06381cb395ce86b67afe500b02b4d5ce94a68115f263cbad42be505786996a056008a2a25d28a5733218032ffc7746b5cab4d6b8db0a9fa8e408cbe0a7ebbb4d2284302643d24daa69be756d965b1f7cb167027d326702c71bd969a177793ee55a5542adece6f1b96471d2226dbea37c2a8b747e1100d8a7e3874575dc6885267d54be0ae736bd5f894dcc1d4ad437a87d20b91dd9a07c47673bb4f31cd9e5cac154908501835ad603aaa99fda521b5f9a55e1c043f295fd3233bece21d46d0103afa2b5d5c889668b989542bc3891b56c11616421c20e2e6628f09f951b291c961ecfdbb0e8438c35e2bcc8e066d1a88e3335081cc1fac7c00817610905a295f9301d0e91feb6073b5e063ad29c57785e437c238fefedc7d8f663a110aa90f426a86fe5db7b805ee6cc95f7d57a975f9f699ddf3e794022e01e81be0317235a008c78810d5a6c8b2fd71e863663c14fdd54609cfaae3ecab13780136305994380c743e0840720dcf64206899396050191f8fc97e7faf1e4efce4e55a30905c76bf01fa1e656d86d6d5c390d155529f0b59cb02d2156bfa507db7a1e1f52f6ef3f5c8db19561331df8945196de634b7076671ade91582a5e0c183178768961570777db0e2f2107300c6ef9e22f4957085d191120c4a0f7fcccde923565bf81f017fcc83d3032ee16658a58b2a7e58c211e0db67fecfee707672d6e4f75cf46fc04e70a143e2cddd91af525a9fde55e504ffddc55253bd2602d47f5278ba6fc6918f2d26cd69c429a36ec3407dff4742a46a30caa021c01f0b8a6c457439ee54eeef0967d77cadabdce7cc8d7c1329a0d84bff4b90cdbdbc770fbea3b6c33890e850a9ede3dff23cb454bc659701e360269943095d5f78bc9a02b0b16d2d5b6e26cbd499229c961632614f474b65d486b471c96290c3db2618e0f146bd549655d87fe963dd175ae016e7c9853cc85fa275b98b8bfb8249776fc8efe3be95acf13ded3e503e56f36147c63810f1baba71287fe922a81a43500da17f3ce9f5be95e9cd59374c363897ab024c74e31f93efdeee6f58b6754c5b9455809ff2fd4823592f32eca8c74c219391585ba763eb89c24686bbf36e0dc6394c2d93f0c990f02a108586bb5f5869022f2e2882a731dfd36ea003ee5f8d91370219470ebf29337e0392dead7c1abc7366e23b1d0669418a44441b3e8867163061248a9b84764026f5fdaec2547716dc73d0baedfa03d4e05a341ae5f4e21aedbdaff1f22f9b8ecd2599cfc357d571351a8f2118e71030014800ed751ca3aa949f24e912d407a6742ef1d5bbdbc1f26249a330c2fdacfa6325b504b41893b7d19575b3f0e24d77cadcc979e4b42ea07e00fd1511d3f3ed02eecd8f7af20cbb9e382d2ea907c4dcadaf6728fd31f88d8a5b7ab2ab721eda1ddbe43ac33f3688c3d20df0d5bec3d13421fb17657709a3a4bc3dbf7d6922b94d1f9a7de777f3cf9cd73f1f07f7b150a0f92bc9c158e8ea8fc493f8a7e4f6aaddf144577dd6c30cc46d8d10c8d69ca95a35016ecb6df907e2a0a692b98a504aa29f4b9aeb5ed9f7fc5ffec3688106b4161ec5ffaeaab50e50770869058a25cace9f705e409d89a635c085bda952c83c63d01470b41680609386d7b074600722cc18707092d933c7fcfef754370989fd445f8cb1add93233c5c823da193d08b7eec5e581d14235ab85479533cb0c501aa20aeb6fc1b03f583d8e65e40d21c6ac57b7ad7804d511a97917cc992dda7f43366198f4e7eeb2c08c8bb18e5e2cb8beb06c424237005147db4a461b0f25a3d4b2c18c8dd4a44c75cb2a82220faca456304243a903fa7e65530bfb262cc97fe21f4b7e13cd666bf5bda83b63d61be5cd18d9ed732754ff002cb4b1962f591f6533a5b91d4b597ebf30d5d6b1d0ecd525abe37676b0fdde85f1dec7b7a69fc3ee59d796160cb2d5a08be2483dc0e367b47e6e1d1f9c50a43462161992de386cdebe4763d98daa214724ec3b377bb91d685eb072a3fdd36b89b64d5a3af914724470d877eb2011ca687ef222dbc2936d4541be95f651d5513060805489e6decb1c3013fb81f0c0185769f278b60e7664f0194ceb78fcdb08b3dc4a5db5243f7698e0851fc68570c23f744b133647dcb95380f01bc88ff84d6ae7394ee598bdc2923ed7eb936534616da44814e2609848eecd56b235bbfffe386f2b32a90836e22342f94ee7f1d994e8ed6500e32eb64272fbb32bf94916353149ac79c8e7135b701eda52116686c4a2322278818eca3048d8af28d1712a89c5d6c9b1d9c54905eebb4c302c1864155b28f065441ede3e30912abeab2cf7d58cfa10b21548f3b9f6e9d347c9204b83855eaa4b2c9e21a6cb1dc82751cb99afad568fdbe3420f0f045628584ce38fecdf8d2f2a099081f32dc004a9a65a78a1bd49caa4d621ff9bdc1a51beebf380e59745b20a4bb6e2acc0297293dda2224dafbe705869fc0b6ef2adda9c31bc7162496841a6cd0e151a17952b36d773423c3bb273fc271a7ae40cd80de59acc97ddb22405e58ddf4d1d4932b45dbd8d33175343afbdaf02f263bb4e0ef9562f95486941bd8b374c7051828e15a2bef4c41ce75505f134bcd09d39fda57196adbed157d9b5bbf8ca9bc3dd34ee9090694694f06df067db5ead21f40f43650899984a22cf379ccd9830c404e670193ac4d01bcfc237b480ef6943690708b867ba61f4cedc75b7ae9481ef463696e3d4a0e2f057f302872a2d0bfe86f1461e839a74c1f94cd778c9affa2791f99ce74a722504051cbf60acdd64849ae939fc3ec14e5cc766409b3dcc9b87de412f18a19065db8754f2b0b9ec88a97795dd977ae7fe2f160d1ec171145f3e4456dc4c8fab5d68b5ab44fdb86db0ab5fa7e8ae99720a97fd1e7dff595c596ac09d1665c99d8286f7bab110316b9b5db0e98a39f48dfec9d2713fd78b69c2988e2a05986a333999e356b847f2fe014e4ec7aee08548cccee98d28f7be3c348ba422fcee89056088be211566195becf692672a8090ab04dcf7e00ba655635e45a72124400773eedeb230a3b5b3e4fe2157a8743dfa2fce598d96cc6fb4412b7c47ed91b1bda6610cc87f24b505c4b24b8e88a0aaf88b4a5de1f319924bb7ae569bc6c59cc2be80f760214a32b73baf03c4d412565a69bb9d509391c488ac03e2114376820bf30d173c8c66f0d20448286cb41b905737b5d21ca6e345e9420babc44ae31ff681d58ff1d972c0be133ba3d45e215d3a79c94803af73110eae7dd1c543e2eb5ac3c65516d3aecc15fd477b746ac7f420ebc11b6227de0f0385ef39b108b00e064786b0aae2725d0bfac4fda57a178c00e896958e5c5f2dfd15de5cbd79daff1fbe2b763623a5d0ff1679fdd0ac45f07f79f4ddad05c6f6be4a6ce7ed0941b2da927c695ef8659c5814fea507effcddec7af23cc7cd1ae42c07da80456a79bd1d0f987747f94ffa0f9297175d555d0e1224b2f73bbcb05fd836ac18db20c76fd77755b13b4d1884ab6af37d70f8a1c62eb0bb17f860f280935c0c5954539253808b73d0d3607c1a4b49fdd6c9e6bfbdedb193207bff9cee94763a362e88431c1bb9f66082b68e7b9642971a1c518770b502a491c68999a1b7af97c756b2a7ec34a6da6cb6d729f375e67a729115ad86775142cac8fdaf334a114975f5ab12418f6e4203121799abd02b5ff67041a6e5e033111b65f8e93bd27e90688aa192e9fc97f2a94a0dcab8d9e0a7c65efaa3ee269a5e1c154147d43517b6e91f748e96d3d10b5ba48691c3f29cfb6747cc6175c065cb9324aa9e054dd837afbb0403a81c8e23e6be5bf6779fbd42814a6eb61cce6f60080375a1f1b2db677c4fec0da1e545e59619926948803db39c0462e0e1c56c14295e765d5d687990de3c33a5436270b387ef6f1939dbcc6e467dbaf0a765301b478bbc4b9a14d9ca98d36afa2009a75206570111f7992df0622e38fdd004b5d7712010f84da78df0c8a3a73b89728fe82e201a3acdb424c9e519a62ce7acab5f0a48866d1c3b82c8542d73324e42d0ef6c9b5782c796245366fc329cd49763e69901ea73ebab4145ca09519e552d48f1eaee26ef4cd2feb753b13b099bfe338affdbe63f087a2a0fcdd76f47aee36240c8ac08c56ff6667491b8a460b30d267ac37c4ff30ddc691e36a7c86a12b7b998276e1b766001d85cdd74b9a9d022e1c6080e6521551a406c522b1a84945e916604ab434e0a7d8870f6b896d3734a59f25ac190b3b471dd307d80fa5a5b3e85d69d40e3cda3f33acc643e0ba1e06c4eeeaa481e162aaab35f897dd8175a3f85583b1c42cf78ad72b5444f005f68776575af3f0f9f6660fd2c26b077000357605beec8f8174824bc118951e391e227e52530e60466985b4bb9ec8df29dea1b89b2755f7f08ad8464fec98ea87f4f61eaaa818b36126d0a7af837594da08e214152b8ffc3d8230beefeda46675e30b6725536d512920960e42b74b89a9676223a46d3a09bdb86ece3e422b88439ccef8c39e9af983100250f50d6cc621807bc0cc896077f2fc74ae17b925536816b2de5b5165a098029cf7c1073ccc88152a99452350caa86048dff71cf77a034f361f4cf1f74ee87beef58c2f956c7121bf17efaf59bc9605bf4ef3430b43d89b3d2227de83b24d32f72904888af9c293fd25897c6be73d8b0da9911d75f0d68141ee2605e5017d5cbee0838b2e80fddbfeac8e832e888e7f51cd66a3973ee9d405d2317da9313757e28a86f3016c5af25d237ee25c7b382fc1988cdc5605f23202ab6796d45ccac211e61ae9e96fe74ab65dfc97b9a6110a6e09e15c5937250b026ded7ce9c215d3e553bf2a3aa1064abe3c8e0cea52e417f46e74415a94decd04857d0e36aa804f938e84218511b8ef94f8586fb062f75691d2796db4250c571767bdb663cf7b69b4ad1fd337a064afbc91067acaf00b5ea39cac05907b23bd70bb2758df36b3905952fafd62f8e8706f927ac7f7ccd307e29749ca8858e9852806d57edcdf3d46b899358a5393e031c0ef60a8503afc7e3acf1434f4ce5f07fc5bff5fd1f94b6e065db36aea56b689ac316720266023f6b4e6efbd2edf22ff08b12aa041f42501b74411ede768a78e00b60508bcab77d33c9acf520895e49c4f296276275b02291d2e61d461c90ceee2b5ec1c4adda30aa0bc02409d081c6cd4d4513f131fbfc37674c2e3b4dbd8784774649170776380782e38d4a72e85d632fe6a90afca4b7b9d953a418163e3bad822c8977529c7746367080414ad060007610f397d08ae5883c1130d51c007340771d60e1410f43240b823d9f8f293f340aaddb55165ba8c216897756480fa52c37e655446f2846113f53fa0d6d2c774f1b41ccd15026aa859ca89ae7210ba7e21b51e36564ddb9f9277eb97662a0fdef131b68ee1afce5d50ec8655049119f39e2233e2b677464d2775981ca8a36a44f38a981d6ff72f6dc648c1de0079b23a16750c6550f0370403abe21e83e2dd8acd04c6a22b6e5825a2087c263b44b93d472b95ba781d60592335e6889ccebf03760085de9b2ffe07c5b6f7ad84f57a853db618220a5092ce143791384142aa9226f30a9d6cdf23b8a56c2399dc59b28f5f070686ca18fbe6db9eb1b70c1207d3e115e3af8fcac1d4fc02bb056a1e2fb33a5a4acc4b39564926e631fc2f00cf03de6f67a9f30bf6f202d6ff2c2e2b868564e765dcb689ab6c87c09fafd877f2750716c6d16a666fd33e79865e377b4ad1fc4b9edf73ef053ce64a25214fb854263a768456860ee75daabc86dfdfcd2eb0962686c75080aa7dfa60316bc37864530ee71e6026495dab55b972e5bb92105bcf909ce917e42cd8199bd04a8d929479fa6c62b07c75a6de143305133703078dd7c05cd3f62a08ba3e0de79056461428e3e02b0c788a07617af548d9300416c1df7515c0cb2eed8bdccc1b11fcb4fc2e637ed64bf725335e62d66e5732540187d0d33976f226dc799d6ccace5226e8ccc95968822efaf2c7e43ebb30f7f0e0b0e5eca30ee71a5d0c289c00f4ef20145dcc9117871de79677566a2ce2d8efcdbd961dccbb0aee7b7462c1c8a7f2b41d25ec717e0706a6a9a6e8e08fa62884b1def656c230cd2bf966c34be1bc879eaf108c0bc044543f9f17a4da1868e12d8f0c0d6cb7a398aaeff0388ee4b47eeb596f9f4e54e7ba1f690713eb2ad4230eb343597225b5a437dc49d59d10f1c14719633be34b5cca9a1206f686cee683c13cf2a6bdc982e5771668b361363e9b66c48a3b61408f145c4836ada60d7d9c195099aeb0b2bf8198095e2b4ebef611733d24babbe33293958378c05a8007bd562a2ba45dcf79a00820b469a81f186ce6f9f30839e27043fab3ee639a5a37bbe83660157c78572b3fa3dd395bd5c769d9361201c71e0d5b0864f020d8ec74f0cb42b43703f51c93c128793219e47928301a0d3cc0221769c8e13961b82f2b319683c36eab7875d90f1de419fe9c88fbb75bc1b68f618584880234c48ba353cfd8123fb324162d7903dae4247cd81bcd13b30a1f9256bf2b6e40d2de7cca46b07307c24ba87519492eef35ade67c715d211ca62ecb8b18f9c58b21380b3a1c664f4158e4267195146de25f00fce93de7e23653f5ebfddb7df1b02c3f8e7978ef09c6f08dc6ad7af6d3ef25baaa5a2e6722122aef558cc1e693decae1acf06a0b8ff3b6f2b825b970a33f8568c2904140de4e9378984d1dfbc18e1c1fdd0262cee3ff736e84dbde72731aec52c0cb51e0163b92a66b78a8fc44f68b2108cc5f9e33916d5d7dd0a9fc0abe1050bdbcbfe8d97104e9f86e84cdad133272e75d447ffed0f9e338b8bce3293a1222897b5dca8340e36634c5e7a9881b37e7ba471a572fe42dc22238856b9b76e9d4441d77e3e59913ccac3b4301869e66027225c528f1f942052b9561bd54d1d87e4b813293542fd0ea076bc5482ad19cb530ba081c9738ced248d488fbe98fc9f2663297395dc0c036ac136061f25f3f0059860a93219cd3ce78cfae622603ff1778bb3476f0117811419a634c646197cc1825eea42088a85511ac9a3664d4819b11b29b293a869c1c4fd648e58945e768359c098b50ed054efa107aa8823171fc87f0dd1d65a0043cc3b6ea9853c1e6216b482868f62aac407388fbaa7f7d78c4eedeb8051dc4f2b4dc739f76412f020e7955c7bd1502752b34d84615e2e6f0c0fe772e187b0153496ae3f65d8f05dca1479a25f7932a8e6acfcfb1a4b4752dcddb49e1aa2bab81c28309b01bfda56d128c9a9ac7946dae22c19b39dc3479e0007dcbfa0ddb2196eac09bf8300ae4e93b9d20f93a4600955db2584932c4b725cae8cf429a1a98ea0bf34db339e2970b6bd9e690d2dd601a5bff874ff83e814889a56c1c1d7deb0898f5fece5692e8556b6b038fc0586b469ef979d4767f41866f58774f5ed5e326ded299ca4fa2491088462ede5fd9625cc42bd8cce8293d339ce8181694424f077e2b7ec35cdd173301cb701cc4c58b82b23dd1c7beb47566d31c5da72d1a4f14c58ba4cde8dc9cf758f4bedccb9625cb5e23fa274703fbbecef3efb5040b3b3e91ea16172e205c84cc1948c8f51c4d5d33912c3835984b410a9383de9e5bb3400a30a19ec391b590aca88cc6c1f065e6fb6dec3534273a1d801ec8789686d1931ccc7e7661a06f3f3e07211c181a5d5011aa0e482b09a3a8b67d6572f53e80d77e55282c54e5941704eaf458a82bcb15085e1af6c51771b9e6c11e0d7de0cb54cb1a7545291cfc71816fced5773157fd1347f8e4930b77deae335de464be10a6470a5a4c9d936b8be9577424fdb2f99f427aab1d29639a9b24a34e43ee7e790aa0412297a8d7da82870ac78e4cac76eafb56a84729d13b17b80689e2c41bc3e0ed7d07c6f8df6138c6d621a4b483a161d3a16a342bf74dc4878709b0f951f48a47ad8e4e35341794cfaf8acf1d1565513008400fa9c72e6ed16d2f04e836a562a766a3f5ca39ab86bcf1841965bd829d71becf3768851e3d11a118fa89865d8cd6bc08f209fffcc476436ea73511b82fccb43a20d1b042c08eea9a1e5e8daf741673be4d9e26e99745f96931cd2ba62031823d31373eb20032d2476283a72787e7906283531d5b0bb6c1e9ec9b203f1c5ccb86647dbf6734e51729887917edbfd119f93a8834abfbd3482c9ae9eb4886039737c48435a8870f0bb3b61ddda605c4cbe5f9197febd5f7f72659c7a311f670714d0ecfa361666486bdbaf7a958001c1f87add5a673cc5008ac843f7cef079435adccbbd1c8fce729c19de4a72a357d00f10a3c1c19b5c361b4b15775896e96c493bb3c81fef70b627efb6251610b9cc9d39c0e9f34601f2eeb48354c6b4f2a69d088ecde6cd3973b4253009ebfeb0abaefc324d2f7ccb795066e0435f0b28ee7b58c8d7bd7a6b079787dc1e0925f0622217217f190c7455525270f32f0a1846d9ac8fe9bda67dbf7f4a9da6d4b1ed02eb5da52707169dacebb15b16beb28ad1baf762cd7160382b5b379f4f961099139c7d44a89dd640c1fc0f7bad44901220fc0f0e4cf3a1699f75d233cc84d25a88070002155a44d73252c6f926c392d9ebd6d293eb65a6e2ae8cfeaae006a6ac112a6cdee3b692c70879a749f0be9d29d0bbee41a7d459fd9b92f83f5cd9546225c6f91d55a2f2b3c4f10e0952a708ebd73837b962688307d1ee89dc01071430dd53a76d1d1103c629c6e3152588097cd61c023e86b0937f3587eae1f106e45cfe6b380d8d994ea8f6538ae792cfe73efc13d9cd21b55cd819f365d3e1e2e507fa7ebdec3e289f36c8c40540f1d95885c65093b16bbea29f7d3386f22e1c884867aeb17fb470284d46047688e6d70a8564a995a8441feebde952a4fbe9f0cc2853a1cec4f9361b70547f756ce5ca024ecd74dfa5ee0706e80b892693d507d284c11243ea09a43d16dc32daed348ef6724ae1d5f06446c1f1571a53b8dbb4b1728c06b43aae2d299baa5461f495dae3919ec6b24a32914b76e2b3f4edc81ef85e8f2302141abf58a4abc766424894506abc3eedf992ff782d907287b808da9500c65fc32f8fd9c2577d568df2ada6bafe134735aa642e5faf0e3986f6d294800db9f16890a602a235bbc379f4c5247bd86c584db95a4ad3d2f1c5ec32f0c65176604786e77852b1b4ddeecdd9bb14a2e7cd0e380debaf7835550abd874777c87a9d9f50a1db26bfda4e804a1f95e64f36b1741db77f8dbfafa4fd510123770e1bd20c30a309d9d815b1303aea121741753581499f203bfe948aa89bb87b04654470708c5551ca58ee949abf4ed204d1174d66d037335ba647b0e0fd9252caf3f2e20182d175553ba6347c7ae048b6b13e5e33c08cb36a5d7637bf427fe85dd042cd4dba61347b09f18d9ceef5cb2aeeec4137d40494d65650f088b7f3f9af8362322b99ef648dd110b62e28542c8c789a41de00cf9c7694e4a63e1e6abf6af5b085ad05a932ded4bc67c6aee46a13f493d15355c4aa0a9f187fb64b303bcd0f1ef30adbf1512420b7a520cd4c3723de74b84d7d88ae15499a5abad4a4709ed9156c9f1f6072bb268bf4489600d3de6e4e0dd6920f9aa0e55ccd8b7a700fbfbdee3fb6700be707079a64965e16f97402ff0d502f8507aa8ff063f1f5248b3deac2bf1c157b857dc613083692936b62e236bb966645202a5114bcaf5de1c1c28700e3351dfdd9aa098525bcdb680c1a966b57c1747aaf2610a51fee1824657d64d87c3b895707d4ff0cc65af0ee440a6303022efc34a2314d18586429048227264f6719183ff489cfdd6c4f08b107c4c5964e043e04edfdd374f43ae2135442890deaa70d3e3cbd1d64dee6baf20104dd89e2a6b207af53bdfcc009a172ceb20d19ee0d91ef72794bca73a37852a87eade3cc9e9e639d61cc62727ee8397cad315b96564107f06300a6a05f3f188b709a457d821459e86e0741f58dab115e62f8f8cf3851420fdc39ef0004d513be3336d417e9f5638b710f9360661fff5b1d4bb1092e8204b49ba3e494ccbc5eebfa95f57fe97878e59aa7ef078d4be63e05f6df7ce2a5f08097fb22b40515bb59bac5f6f7ca5bda759f81c0354b3723dcdbd9fa235d92a22206c60db5069e1bbbac47ff56afcc9","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
