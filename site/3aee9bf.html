<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ec3ce7144c64cf376361de9099ec8d7cc0da369e3155c5dca907c7c27e3b69bc195a9b53a8322c554c0abec850f0c0db8ff34c98c112267039d5a1f61f070f806ff7c8cd05121f471d3640c4071a0e04fabf272fc85628775ddad1f0553cf14d3dbbb9fe2e95c2652f16e78ceee20e5d9ce9b9330ad14f36821d5029d4d14898f2a90ca4e3dac4cd87f7e16245c2d22fb4ec54895da554042041a0765b71c58e9b5bea45fc262e12ef3bb6015b38e273698dae91360a533a6e2ee17d17e94d09d95f0cfcc5ef9cd2cb5b4bf530954f4d4d7f86f4160e9977ff3ae868a567987826f8ef62eecdad367089d65073bb6d745b80f9951622386a6c5d55b58ea7fb2456b58257f906f18c2e12a483cf2959796ea2c8268fd9cc077f761c17e3ff3a0e9cc40937cbe7b72114a7676bfefe1d85017e41d758d7845e60864c9fad0ee16ef1006c27c8a64bdb1fd705926c0dba866562721dc7ade7090a1122514bf910270d9515b955965e5321bc4731006a695f4fc21a7d42fb5e21aa3a5c1a930aa273f3e3b5c2e4f7187895bbe07cedd947a39013943f775e908135f7e4adc137253ee563b75b58a428cbb4edc8ffae377f86f78dafec3a1258870a771749bda78f8c6d73e627e02a1cedb09f859de37f70347e268c4d41cc6abc97fb1e7053359d9ea7cea50e74ec8fe1e8cfb22835c6574180ea50d21f3f38812d5d9dc76d65d5fff7acb23e42179c07ddaff732f2693fe1fe430b8c3e58a4d5614baf7128c9be09a80006b84608e16289fb84d9bd1658cdd86a9c112ff7f0079dc9f7d74e812c12e7a10f374151030262b0c64c04badc28c166d2ca010392ad5b5c2c47f15c5f8a35ca0a6024fb23564adc474c737aa472a0fb190309b724d6edffe8d9e000f89fe368f679552b217c82db55e3f89b0e72d04d08bd60b63dd9d14c29d7ad06460f4fdced12c64ff1bfe8c4a051719a2d6f7bb8ba8ba87fde73648c586d743e32379828f614dc94ca56e7d756cff61c354a144ea2a3b539b0390cb25f06e827b46e16698a13c38e209ca96a04b070c7d213ffbcab23dca3ce82f54c16a62e48aea4cf72ae2143dc07f83d2ef4bc31513094606f11915f4d574f07b28482697927b69e8c8f385d2c3847ca7a4ddc1832afebe582edf0efcd38a20e21642496346aa20e83fbb7d01a5a788c926643cfbae0e6c4d085c928475de9c4a1dcf1b9473910e001dcbf163850311a9c4c57a509e053ea1866ec245f37e9267a8faeab856977e6544cfbd0ccb6c0eb635cff13fb98163197d8917dcd471adfe14306cba04f4c7fa16413682802c80a28e0a5cec7a88c381ed2f0de6db35a26e7c3993ed8fa402b1ed1af4e40ffbdc532da2c6a82d58b3b2c3462d197cac2d310bb8b091b106be94846ec956be42d788b37110ae18902dbea99851e4594d8e6062f01d9aa382fb12f7464650cabc7de7f16c7603306c638f3b8b52ade16c53296357b6728df4a47192567331fb00539c4d8f479daf3c6fc3909493d4e2812c30f1ca6a98a6e327ae60601da8641824b0dc5ed99281b8e02fdff2f7b38084c8e77e9fe7604c087f08f956bfb0bcd18ab759ac0ac50c9c1eda0d5b137e8e9a6f0060818e8cab0ff0fad92968d197b29c6cedc80dad156412a656b4fc09416d5d1aae9c9fffa7ca76c0f399ef0a681d68d1b9db7e32d2f74816a2825fb6f362ba5af14292398a90b1bc14275c6bcaa3c99a6e716da881bcb9c2a96b648954a211ec1cd6d53d1cff436a83ecd1702430a54bca0f926cad43e554fa22abc5312a1c2cb5ab28b19a0e11ac93418340bb5d67c087d8affc60e807291a9753be2a2685f7b32579a7d641c2c1c2bd9ea157f05b675781e0e1ce5f1967c2945804868f9dd47d9de99f285b7d09b3671b742409fedbaa389bd9a8fe2186bc2958e9e37160b2cbdd5e66652a5a26d58fc0a03626b9c870dfe888a4c9ea7384d47d294eb36add34daccd5a0db325e83b1199ad198a3d4fc54f32ad17fbf6e1866a71fe85d0b48c096976f9891d745712cb18ce585aee4c316a110bd4bd5e2bb3d5705e00356e8d96061274c0b6f7a2a89480787854e42b278664cd03616e2596b2e640d0188db1bcceb02925573f429d248441ead5b197adff5f86a8390778fabc77bb7e3e8a0e5eeb654c171d5aae3d9ed5c15deaba0f480f926a3641f2aacc0ff11aea980a8de2286d7d4f471d5604149c6c0bbe0435853d21a73af27f6126fc4de8d7d79e282efbd9e28b2342ede1dbd053789ffc68e6cd91eb5ebd0e90ec7220658d46de35e66bdb80c4c7ff29ab592be87fb651ec0384b1a91d8d59d0a994b58fe4c518dd7382b9ba377d5771991086737c317ad7dec7725037d09daaa1f334a4767d8ed3540f923e75786a1480725127163538828b8239444788a5521c9520dfcc42c5d9f3dbcf360bef1332ae1c6b1bef92130b6a2a1c9be2a21640e327752f5f3ab76029c6eb14d4e7654c9f7ed25e0e40a4805143e295b37bc7c8f05036f0fa96cdb81b8422e031e15634abcde2149bdae8e6253b0a42d5d4675521b6d6da24815bf2cf0c3d039e23c471694e7d06f62a2f18beed543178ff53aa6a0f54f268e9ac8badbf62b44482a49bbfe28634eae04e322cdf16fad2d9f137208cccbb1faf7f908176589bf23ef6d894f4602f08e17288d8251f2f286b2341cd80c7f146f2c1d20ab21e085fae6d8b067e0ade7e29e0b2e3c56eaa1fac5264e4a7539c27725b72f8257ed2ca52a7c1c093c5d057e84659cb5fc1c924ec5e392eff103a15e014d5347336b24961d762001491e89562e10a46c7eeaa2ac9829e8d4026a238590876fbc722066633978df41fbfb130f5c7e1bb1faa9fe8ab084ad2712057144711b34540e15b851225becc73e4725e1678574ebaae12163e744c93535a405824a15bf1cdf6f6dc3b3f59735b87bae63cb135c4277ea10c9876ed0138e03b17a48b84996c05d07b84d836710e27e6d8edcf8b29e1936e69fac32d7fbc1d84dd7dcc26bdbcf35d3323271d727d46571cf85abdc2a7461dcb72050230b7b968043b801df8b28f299305b6ae30b496d585461f267684201a5464803a4b64403d6fa1e48f22cfc6aaae8b8f24f949264d61e7ed900fb9f338be52700c999c7a41e3bdafc849aa7a9d9e03cc455ad064c589426c89a7aed8cb32d6be671c821f1b6a7c9d87a6c3c4e99f35e84d7adeb77e1a663703fd50aa2f3e48de7e57d01559a9376c778898167bda85d77779afb6d0822abdfa691d261f3c3bb48d20558249f5b1abf98f731e5040456d85065c92084a788b8595aa891af55996156dc9fa242b233b69d7edbee2ae7976cc1d43d9eb5bab8e2cedad1f2650691e63558af1edb390fc9d5194d96c5f338c11e039c5880f586522264c39efab30c98f8134c1ad03f1fcebfe5f5cda65fd5b99344fce55d22cb4e8e17eb5c6b52ea9c94925a9c02447b53f780f141d0a945a25a6ede5489067a574258009f97993a8cae16be707611f40fba8269cfaab86e6e2aeb2f5b793bca02e98eced920b31ad95136cf760d25bea41c3cd6b9bb3b5812a740adf3e2bd7bd99a3c0a51de871bbf9ef1e925c769e706819dbbe941f822e5752e92747e5928f7d9bce378170eff24579021167aae21e992b822d66294e46ca792124f2d8f44c52a8cc9ffeedc63434dd7aeeccb7a4d10de0698287e9483b9f6d5b7fd2977fc32c42ca4579697de1aee67ce6386702f71ed24d89bfcdb8c75f6aaaee8d4ca1b30abf53d095495cb1786ffe445b605edb576369aa06cdf625ba0aa6b1d67e53120c35e8f8d4bbecf69612b10891e15e15704189a86ffa8af2eaa1162cecd15dd68339270bad462666a7628e4600e2cb1a10649ab4f74aadab74b5d27e8006c97a3ec8156ed848d31462c7206b62eb3a8836af137cf64ab6274e8e32d8f272af884c367406350751ff9002b217a1a16d3eb37755566dfe8f36c3df5f8382ab0e638732bc908fbac1f182978538a9566c7659ee9aa3469224c3595a3f1431957b907ddfa94b9ebf056bba0a3d4e09fe71d4e91aad9f68707ba20c5f8d09e8e57b3a205929b945ddd19f04b36e281af9a233d2af9aad4718576c2cc2aa50794aee2a9c2052f0f84ac9a6c27a0c7336ef14f2d5a904806b7f5a28ef94f650acaa8ea573dae52c171f2d31b54aeaf50533baf2b8a811c99bc116c9f8fcd53fd5c52f76da51a9dbd0e9142cf4b8fa48c6d617541c5f764a8415530e65264fedaa45c17b2574fef19fdc341d01d25826e64ea30519e6c6e8ffdfce3e471ae06b81c23ed36c8d0b6347dd6be8982d20571fcf4d438538adcf4c61350db0870a24cd6ab6d6cbbe7102136443ea0f945471569b94133023a73567a579f90e131ef92c5f146848c0b33cf728f779a19bbc542d9d5932fa1dd9c88abd72186d57927290467af8d0357176f8734ca0c55f184c13334c2afa15c2c1316198ae4fd6e50074c7cc5a48828c89f132f2628311174684fa9e69f7741d44079affe43dffe4147c18d3da1894982c3a9ce12915be5e55b3def1d9ff9a0aa946e0e8a11f7b876f54b969916ca72f86c96d1efbd5fa9c5974643a332b2cae16bc6464bef287e527f08bc22d6cb5050c8718792a2789fdfbd3e7fd1f62d8bcac50f6b417755c9b1ea1743c86f5905d9abfd45729ff68a8f8bdf2929e2a749dc2ac782e1e664e4709ec247edeecb4c2ff2c5e9d101e2e4d346577887a5a4de5386d70dfa0795c89ffbd186d11199f5b5a162f74ce14d1fbedcbd58836ff1cb226632a9962881842ec43a6171e24769ccc445083a6eb785e23241ae867e78787e074ee440c4ff68f9761e68bf8feedc54feb82d80bc0aa68a7862aaf30b264239fe0eebbbbb815adc40407a7ed2f8ad49dc0f23ba535231e0b2394d521ef36f6cec9c58f9d98973c818f5da73e4f1c289af9afa7aa8bba2fbdbbc4c3f93864946c2204991c31ce143b12eb184930439253f5f7ac45aecefcf199f77702b8b4835150f927c622423684ce6045bde5934e03cae04bc529e8efce06e22bab83217af1b5c73e039aa27853aa9961d8b5908fe33370465f43d1c46203773aa323afaf952368977142e2e3cca4325d85d2b8e583ec56f2d88fb1929be6d6b023f45fa949efab7929bd73fa8f4a0f3d9e2e4cb7446a05c8e13e1df5e770bcc4dac2e4cfec3ed4f0300492ea428dafa91c6db9f06fb3f571f647a9c2d900f4723b2f2b14b118c51a225994278d9b1bfa0c4f4073e0722d140878f169d2304b8f7a7da5a391ed839d100fd6e03eb2c9e5263173b4601afd415e3511c9a16ac7eeae2f58660fce25411f407bf38d1d42d430ba9199f20d09eb9c07e97d47b121d93add15a79309cd71be3793b49e8064508c71483f464c1069320ba0d3df935d0920014f56e00f2ecb202a2b4a1ad5f77b3cfb0de01114c1164cdf47a076a29a97f3b47edd3a5ff994f52d5368c7284579f20aeb2a4947d533da7cfe9fba8f5b8364490ce2dc34a16cf50af6e12a345c5c26b2fd7fe3b00b1fe4aad4282c055eca6bb4a5a8ac29e9edd66f674f7015468d4fddbbe9a7646ae2c6e9ca5358cc82093c74588abfa2a04014c83326769e614ba031b57dda55f9f0f777ea5f0935e61cf0ba620699ba694906e9f62ae58e76338b220250b84dbeef14516ac72daee41a05e647a7c876da6f3371544d9495c671fa148f14dbf07d5f1f10abd447093efe337da050365b57be43bbedccd107227a305db44cf6824c6b268b8533a45531a8760be6b256ab757e35fb2843a6edb0419adcf00d0319a105ecc661107209910307e88022c7e03e93aa1891f65b1e5bed7cd0332ccd8c9637924ec68282abebfcdc7a48e0c2c9a01b595253f0ba14c750095ad07dc23b71b40f62ca977b5d5d56db1275f4a0b261c1b733399a5e7eea564ad813c11157941c7dfd16658bdbe1429ad2383de8658c5a8951a40cee12b935b54606fbca11bb1fdfe452ac0fd20f08c04f77c160b53289ea3b1398b8588f078898496907e37f19d2c0ba150157fa465ae03fc998c07f0ffb56c43ec6636f8415171d07b2507722709796d7714fa5230cc3890d794831b49ecc941def6022ede52b62c196457e76c96d8dd7445e633173feb68af69afc83634f0b90c62175d2f580c8a643fe2f56d53efa942fd11e9ddd409f6bc351aeb114825c8e22de36cbb5efd547aa78f58405670ec8756ad4a80ae1698500d96d32efa90291281f78ebbeed8f05babad050f41da4ce60670645074c95d7ebee481453832ba39173287ff2e4028c352e3298923f49f3091434e04cbfc7afa9849134be94608122c6edb3b3ec7e9a5c88fa290c9a0d78dafe6b3613e7df883b4af1d6b1bc4d061c359ca9e69a8c87a369acc4384881f7540ca52d3d4ab6bd3da12be893fdb54906fa670c66c91ee4cc4bb56ab265e1f1c8b78284433c2fb6a2d8ceae5960a66d3670163a7a6baf60bb3bd743366864472b4c9595c0a12ebb6bda65daf1b0001086e86009bc701c5ff429a39c3356d68e7ee4563a1474cc6aa1bf492bd90ad97f5a59ef2991a45bf44d2f3db270328194266b95a100f17f9887e20be92d9da309d2d1da491ac3135c99daed514a33b87e71c2c92b8761d4e77392c71c39da1c23000a06b75a1bacb64a9684a9aba6e5bdf0d52a5ee050a6453d443f16837031d1ab2f705b4e53486443d637e3b2b9a97d4cb91b9c1f2c5421e546a0b84571c62527635e5e3cec803a7c8416e2dec309dd7e8d063aa7605e15528fbcc5f4e23bf8cc6a94d3f0cf8aabf75d88ea017e15ae79d2b283002e64ff0db12533fd35995464283303ab431006d14301f8259ebd3cc53228bd460b25c759ca5744c5e1cdb9bcbce6c3e9ce0717b846f405b9858604ccbcfaf4fe29c7568f90325982fdb3569da04b019c4f0017204985c2f1dc01909655d8f5a55b3f351541c5f78a0d92795c30b55df28ffbb671cf32aed8152cf1f41ce044ddce3397dce57c29b483f6967513b37c806178ddaa68634052257e8ebc756929dd4141a6b9aa867a800db35540c6ec3d010f2fff88bea7e3e5bd8074383f360863415340e96fae7915e1d4d7afe6db100e87f7c41f927ddcb6d31803c3817890b7bfc2f08c33e3135a0afffc3ced41dd12ef59f8cd4ed398714a5cebde720f7f9974b8e0ddd6f0fb352a0b2a571f1b2b2c742572ad0cfc90572cddfdbc2bed1b64c8936e7256875b1c9bbbc5e1d758f73b2782c0deb8a795504db6e0ccf484730aebba83221617d63e003112db17f0f3e157bfccf38e8a637b76746c1bc12fa74f908e725bf8654f94726fa6e0728298410077fa7cfd6570582dcfa39d75243545278e6c3c317cace618c81c99bf10f51a50e8d0fa15d4abb00db4ef9b46722dfb773fabd10320ee972e9a52a299cbb4aa6daa78ad13812ae68df4830a92b4bbae010860f3c157ebdaec1a10d4894116701988b1f428059bd6533b78ee7829bb100adbad40278324af60cc7244d8c64e1f33964a431a30eb89f5e929abcbe108c25dce1612e0ce6e2c5c4c34fb0714cf592c0a3b3ee326580505486b9dc428fd05f9a237a6e0d956a14428785e59b0a4cb9b84cd9794bd72071b46030b5da2f082d8e1d4633062f5311c28e52f5d33f8f06d0048bb50f80d43b377e838084e69f9a9f12f34d960d428ee6cbc5dd2a65cc7e959e3bbe6158bc9441a1c367727b109b7ccc3bffdf5fd95ce09e6da49d15b54b89912dfdb365f5132bf5f8b9802f00765cdac16cbf7afe5621f824a5d40bb153db22be3cc06e429c255f3bccfe7b924b27888523ef26ddb6508b4d4dbb8649044b2b385f29085e9f24ef3f35422a50abcf63b6aeffb1a4ede5fc30523e109417234a59a17a1e15a5f239ecfa48a23d0615a39070f90b8511766d99dbb1449e92f630503cae04e4f683bb3d71557d74a2e45a75ff47584f0337b81c82b689e10abc960672d45cd055e5bac367412cd3eb46364f86c48bf7b1139b07f0ff692fb5e20b5195a4677630af71b3021a6f2d84eafc67cabeb558b811b98be697b6a943e5319b90f39b3a6d0d9841a64e143a4431d2b6d1c5a8ee5d4083209d51a5bd777b5901d96c412d8c06eb320ce429687b579039c9acabb2edf6b9a8ef888a6e3233059df3d0a70fa36f92136c0fd3e316b89a35dd773d8ff506b8e63ed9aa381712c4ecf990387325ac0c35cebe3886515ad9b802b121be677203fdf61ee9dc106f914528e31984003b27a8f0db1e74ebb5ac1ea9fa19003d17a7568803a69aa691d3250f96fbeacca40eba5920ec9fcfddfa42a47260f87148bc0e2dbf3f412e76d105936ccb93a67c043019935299fad0d6306110250d0fef9e59524c3649d288485605e9408337f2d74ee78619e195b2117f3413dc61fb3ae5563f92d8d285127bb57077902833b85d89c25419beeeef9caba5b904dc02a4b1aafded42d1ddd93f0844ea12d78e5626048d9b0e11962238d654b85044f20f7bc15e4fcba15ff95fab46da77b7ef0c754b889d83ececb0ee927a7196fd6807288890daa0b80977894aa86778f0b504145ea39652008b7800825eee0b019d8276de2cab77f1fd5f522e002b8b736ec1169d9083fac3ec2995fe375e39749b6da276309297e6f37da3b4982a89f9c4ff61fe674808529d13fb34a771a3f673d31a2d1c6d019aa363b3c8e4e57cd8ed17a47a457c011a5483046b44898f33584716ef758207b3f5f5cfa8082f6fad5d8d1cdd7f2ca8fe537ba789807c4cbcae31f92284d653724e84ad7d9450dc087a0a3fc4d39a87563950ee7e2299fe78d0e43ad9e9fbd965fada1c9eda4fd0943c885491a3c12b6c1c9f89077556bd0c93ce8497a1b97be6a208a0494eb378538035a6ef7561c74e89633d33a35fa36b1f3b4de5f6284893963955bcf8f3f79fbe9d722d96d8ff6d21e7c97dbd22faad7e4c3d08837067b178ffcab317a32f52ca7b67e24e28e6f970fac429079f680c1c81b80f9bacac636cb57031c92d90c3f17c5842494959c91b4199b9791f23860723a59efad515d28c867aa06cdc6c3db62981e9cddc042661476b4e36c41b32dd81821ad3847dd293fb7cd5634d8ff31e1d3295425708a81ce5d4792cd8186b52ba51f59bedb75f4c269ae481a5e8d04a7bd37085715c475fa7fb48be6f6fe31e4e3eb8bdc12a825f7fef0a5157cc0654b8b96cb4c6138f8678a2737e4847d2402417351a27c765a9bbda000309c8f1b8bb8c99d7fadf79f44843e106166864581e036eb63c27b867dc2198ea5cf26bb0cb42c4cf08ae805ba577372e1ba4a3f993753177b250efe6cc95633e7e415aea749f1c48e431e903849a1744db6c6c494ef811377fbbea99a42687b48b05e96f5bca990f8f0a96ccf7fa1cab1cfac9df7e07029f40c3b74fb696fa63a23b3ac0171f02ae80e4eec6d5fc50862c407ce27ab1b1fdb384802a3900162292474bb7995a5c9f9ac8e0c3d38150ffc79ae4b3351e8264ea615de6c50cddfbd2879dea25c5b46461edfc66f14cb8ad9ca631b315095fe7953c12d298bc6d5f08bcc14904d19a7639596245f092d2f1286eda476161fd866cf7369ed4a6f171526239cb89e6022b02b4b8703752cae8262334d4d3a77971639996d72d09f3bdfb9d93962d1598de717b09c5a818ed81016637c017c2ee9ab6dd24e67225bfa86b84667ab7c07a0ae264b5f2d30c9161d092d4f8b42527b792c63be5ed85fe90e60be4845dbefa914bda1d74f092f7fa73aa52764a3b12d84b76062f67c0d52ea6677659f8eebc9084b2f99570f183d8f44283fc0b7377b9a9b91c41aa6082a7a0ed3959fd1d59ca3ffd0b434e6c6d90d27d48a68848085e0dc3c991f0c06dab399690c2ad0213a1463a781113664d25f90ca418136d1b6bbb6334168cc32c45e69ccfd1da8069424a9187f6ec8439e8cde6f640c8f9106a7849fb42dcd8424ce7b6239d113a29701de9b8d045b5dda8ab9e836ad3407508007d30b610d655e7cdcbda09f262ebeade850099bf2d0dcc45fb003fd946fd4c8d3fd4fac72d9aa22f0bab3482e192b7164fc83bdaf6d91b990b238e45002a98d04c910b252218eef1466e494dd8ad0de52a2f9d4e52c7192ef4c66707ad998628fcf86e1187ac0a51931890a420d7a4b2c6d56d40aada4af03f61ca6cd599e574ee863e727ec87eb281ff2ad76716654140dcb97c2fe29a6cc0a4ac6f779b7c6e30c0c88cfa6c7188b4a99b7771137acec6e42a0d59aaa043556f68d35309f9fb6d94f91328591194acc4a8c83d1dd8d64683dcc2cb36051d01556eefb9fd1b73ef69c45fd79ccbeea01ed7a817094790b4a5e69c9aba3e58e6cc3157e6f220c8047deefb160f4eb9ec41a69e6868ab84a7d8140deba38b275b16a236607ccbed8b66772942c9a45c93ba342c089df4c5d52fa262a5202664a2066e2012eec7fab4b94f891db1118d0c59916270a1d43ee2c83b1b375c883c8f1576a69423e3d39676ee7136e8568f2247178bcb11c4d492298429e3eab7c71c01f3ef70e26268aedd625f0393a9f23ed5368a27d23bb4c6afbd43c2595048720c827ff8343a7d82f45b618d522b19fe1235054f78743bfb80173825da4408026293e8b89ee95986bbaf7bb3594291af435cfa51be821b4dc43a2bb58baefd79aead5eda2853518ce3f263e795a42c8d54581b31e3e0b75d546ce8362a35d79e6d73cdafa7286141d682f0998624f8a5ced6cfe2ca3a57210ed30adf04606661c96f25c72e65bd36f67bb04ea0f1e269d3e92fe25f3b6dc8f10782f3463129ba965854c4ddd152f5f5ca1d3010e5fe689581358892fd5c28bd78a35014f267dbf5c54c3d6f9b1066865837f32cfa414fd9d9f640e694a9ea976b7787c0830d357bbeb43b111e4ea5ef9d9eb97c616148be2d78e8e9bbbb5e047fed8fb788797666eb0ba24eb32f7e5fb80e924249417d8b45268b243a2ad6323d60fc98424e087413450ddd7521314cfe53d9542879ef9d9f1b0d697ca38b2e6ae7a2378ceca390065c519904dbe76c503347758124872fd19fe81508abf0d824e3d11f2abd625deb6312b90c276f7ffaad58bfa303f89416d5ca76bdf898746864e384f1d03de8fb2b0c767b22b54fd9790aabca710f00e4ba753f83044b98248aa017af7d91f000573c0a04f29650b19f0f787eb7deac19c6fee5e4cc463e62c9f3e641f44727ebcac876f3972b77dba75013c40d599ace22ad39e24bd7c97b570a9ad6657c50848a365d5084a9daabdd865e19e4949279a50e84d9dd4225dcdb151c076399e26a7ba0f3a383569fdd27c3553d1a4d57af5d5a139060068ef430e68e132c0e14a90f1baf9b2499f2afc0f77228bb5ea41fa913ad7f81ed0fa7de46b4d0667b69239c48de51f42e69f33fe4015b9c0720f63a12daa2599ba4b908f9611421486704411bbc175f541244f484e7f06c092437dffe825d9b41da1a054a00af5ab5d51f1d5d519e157bba188c077169bf70162d5f91d0ea4503e127c360511b5abfdc9cc93131ebf91ca4f3d23058c0416f476972bb39cc778040b694ab849f15bf76f8758b30785ad379a2f4255dabd77da6b7eb53caed4fd9b2761843df3154880978ed829d144be67bc61931d5cf30c3025c1a2af3c1d6e9e024991785b1b7dd5b0c074d8fa70958048e509c26dc018ed2f94e234588cd749c81a997c7e7d35c6b5a0b741f772bd89a21f0d3696ead7d3113b785bba9d42c8afe929d6be6f8ed18a94c45d4fb471881ded3aad81131bf001c6fa9f361675078b033ac7bef946e25406a213a5e8bd17e9b255e8420276c85936bef4c1dce6d61957801e8682a9535b183996b1a7cec4a8e4cf5a4d7e8d0fb5ac96197de0723baaeac4e37089acc8521da542946ba96f9d1a7de10894f4fb4fc97a6124ac4687adf65db46b6e9867438993b58ce6c17a6feca2d8a720519af4433be8229a8b4a8087a65797b594206e953ada755b0e0d2a6ef0a89b87a8f1ee5114e886492612922b528d08ab199eadc3dcdec8cb534912077127b09fb8cf7319d93111115f71184e2706a13621297bb29444586d7f296dd60964b611b5af7a5463cc1bc7b20f0734708fc4cd816b75ed1cebb4306e73ce77ad594bafaa327b38bdaab607f814edeb2b0d868f779ccd3d7b3269995679d848ec2a229c600cd907bd21ee51bc34841fba43eaf19f9b7c985444d62dd7a19e28938bd23384808bac39b3c127b5feee9bf3413846ccd09efd40974027d7ed7c21ac6c0e7151704858fe8ed3637b8d8b2787c4bc54371cda2c6a9de4c2551a33fee00ee4f07f9d5579a77712c883fda506c9c308df5ffff36ad82016040825aa9c40739a94f3ba8f2e389d8f250781531758474915f796d6b65bbba9c483dbfd62c94abbc41ac4ee0ceadf8c90203f1c0ca4988e54535b79f940c5da049f3cae3ca11e8844c5d1fda114935eeede8366cd2d3e9a4073c3ad75326c9dcdf35223b9d974ac314e3feb5189560aa0443806f7cfeebc48c3f4be4bdc1a229d8eb3369de63043ba36ae122ed276db7741283ccf60433d42f8c0f415e49acb615bfdcbd603662091a052162007572430d9fb1000ac3ab28085cec6e3d83d1086dbae1516181586831744d1a176cd3f0f5c7a36f04d1dcde20b4caf5532f03e70191330bd4759ddc94ff054bace6a6cbc295df1bee87d07729ee0a4496c64155c83b47773a3e9593103bd26e1ec3c1662ba86facd0b056d47e8186c34ab448d022d0bfe41bedba1c01481571ef17a05ef29d94357f9de6325ba2e04cafa8b6818c3e8357a07cfb6f907e6ea2d2443ffcce9f0e0d728b7ec5e949cedc5d3d13253870174c9d0a2943acec20d9b33fe995db2ac700427c67410cb461c98497b7e9a643ed7b13cfbe9a6dac1feaa4e04db02671fb9d75ef7fe504674327726272dbf0998489c5a0ff07bef3209292838da1a0d699bc1f6784c8b84db35a09df4fe87cad194f06e1126cfb78eb59d577adf3d39a8093934600fa5f4c9ced739026910e00232035334b70a759ea0fdf50b29743395d76074afc13cc83cae66a474d82c06a8c00bd10000ee7f8b1b99e8e981c3fa923b1e9aac859e16f76d68fcda4ae5ed9808de24b045fc63749505f46d624786f56b80bc9074b35930004004b2bcfee2580c3fc01b4fcbad2aae1eb7d6ea7d6ec7a58d921d0551be96be0383c6537d7df94ab755573823da0029b014cdd8abef23b0b365bf935a65498d4fc690a23293d8280622553e8d34a447c80cc0f0336c1276cb28229c1a3b4d95a66c0fcd7d92820330276aa68500b7fb2c26eb8cecbb99b99feba657a7363f038e4dc4e846aeaeb9592d98f27cfff7c4a746581b8f6e304b84061de04d40525c902725533dfda788cf183d4310e6691e7e5bbf1a5023fe0e78a50de96b59651075f2dbe800f07ee9d1f3d2b2b085febb5d474333bcb661093d44ccb510b3e7629fadad12cbb36bc9f148f10a9cc06fb25d654047371c0ea35f70a6d534989d1ffbd0f5d0b92717a0d88dfe5e4885eb534a746a7a13b96a6c6c6679ecef98fb44c008e4c77be3160429fd146eb7f86a7d264b80ca90880d4322d702192fa37e8866828d033ac8627ef941b6d39dc1a766fc3686c75ab1ef10beee1dc932aa5997b7e5eaa09badf4133c24412cd76f51e3e5b09735adb9415b911f10ebec1f29e046fd4ec01017ac21483d38f5a5c956825e2ac46e551e01e5ab54e186937a93a435c511231afb02cbffc17675d42dba1ef3320424cf28d7ec325a3bea2b9213312d574455ec424d8eef2d3f98cd39295eacbaa56de3d30e6c5c79c46f40716e403870727f9aa8c5fc7d1939aeee6a3d7df09270d559dd8a66a5618c1543e057ec37262eaaf66530ac94439a3a43200677b4109badd18e9dd2bdad24c48f26d4c105f5db46a78b742f4cf709e1147319b6dc4fb4cbc5f34ffc862a0607e293f1f3b0be24440e614014641c6866b642dd617c98829120854d4f6a67096343fa60800a7c22c05a6bffe30c5d4dfeb14a88cb55e80494fd8ac514fa57753140810bf33e30a8094109aab0e7fb9d81a56814811c16496ea691bee7476281f182483cd5d1785c1e0fc7554326bdcd3b0ee0f520eeb254510f1a9b82321f3089788cf6f5131a352aba2e72ca91c8982af7addaae197328c3e405e3de26aa44ed6a4b21b5ff84581237ae6fc0744ca2801405e4435981c44041e969acd5eb0b7c5cb105961f2a540e55b6f268eb43375fe54015576adf34142658113b0f99780dacf8e6a0e8a68fca3c6e739d30fdfe6f55ac5db721a9f685d91f1c91ffe8662cff5c032a929aab7e59dfe46ca07bf610c2a268e65f8042bc0d658cab173fb5f30140890b2477b6637e5deee47bd8358ed7a58cade8acdc5252658ca1c155ebe02045ab06766acc09ab0ef751bee1983f858129f8892166dae7a6660bd4997b7a131df49ee2cf47ecfc459e04fdbe1f373a85a87df8bce83dc7a802d030ce5421b1e9b18b0169ec0a8bb205f16a0b76fd1dc6d4c3d29c0cb6980316542f71f703c70fbf573e2b5937c29babb6b43e13229d9c688f7f6f12165737c12b059fc9637ba1c39a97746ed1b62e13f05b289770193b9d974ae28c5941101bc809a312ab2da83f8a7d3b946068b66e814587009a91a23f7284588763168e09a0f3152833af216882405f1e43c7d4f13ca55ba617b9a3fd9f20179d3c8bb14c114f44ed5c0cff39c2efe12a75a505269778f76ff1b84e8335ee9257468ebeabae00aac696b3e376f9b1b3a3e0f815fde6e4155556a1e9ceedbf94a93c815728cc518d112a18dc8e5a35d8b0de6c86f2d35b33c75c97496c1bd1085b44dee2545adf6b846bac237b458e33e66747ff560d430ed247a9c5d9570b6d4a5a1473c6c6dd64ab2450c84b0a6e8a150f3325c0940f8592fad775eaefd38c95ed10ba03c3c3d1e0e75602830f3b10d81e12930b2135f839af5aa11117dbf84b1c536e3533a43c4294091c2dd7db67acfab13c0b4e92fe5014647f3aa36b8b79c32c8e83ced8fb5cd9fa4206484252db1241a15956398549614e1f880c95fdfebe314cb1eb828baf41718ded3820415f63af706e51feddeebbbadb48c15c119c9dce0983307761720324117cc7fc2d285d820fbf6fa39d5683a4d01fe7281b3a0e7bd0967e7a9faaaca60a233cfc7e0bb6393d61dc4850e4bcbd34b082c010e65301fda0235645b75f3c1ff28f921942cd6bcc791b7a8037d65ae74590aa0d51b7ddb89465a0f1f8c0699fcf881139d576a6ccd2907cf8bc867c7bf668288b2cae2b75408da5e29a23b16781f712a36ce840ed3c5ffe7af76f5de9c1d619193fac099a459af544fc666d925e678475b7c93f0dda4b6605e2f9402cd22771fc6a1d116b7e6403f41f9f4b04b134b3b2989ca752a8d11ba5b710f4ee0eb3ec2ef01e8e09fa91d7e404ae972bc198c5b4feb44615136db6e65a4691c141e285b4d4f60163e9513169f0fb3cfbdbffb6c0b2db55ba014ca1d70885864e9b62518052cc7927e012757082f26942b19700f4ae200eb4ce70ff3d2611dea7d","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
