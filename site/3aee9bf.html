<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9452eda47a46abf671d67a44be36c4fc88d0decdd8d92c8e2104dafa0c28ce77b299885c0f90d4ee04311f59a55fc27a21fa822567edbfa3324b5879dbaab47c1c441b49d34bf7a681529a228ad8483156c843dd30d7a6e0379c7b2e53b8dfa8cd9f4a0206db26dead02594da9f50849385acf4c13ee81fc9ca8fdae4bc3fda4be09b7f1890c4da9fdee9280c7f05e4df772cbf88dea25a8b4b3cb6151f34d9470218d53e2555e993c3dbed283a707382ea78112d20d5b10fa177de6a92e7deaa7974410c05a0fca0ef9c0263c149d81a9973774198f8e106d58ebd7c72ec0f51cf294e167cdfc5f763e7f1a76aa4e39ed8a70181e25be3a87423df0d39298adf7c6960da1197a00789563206942085582da755279eb804eef61ec2361e51dc318b1f29e6f73062ccb604d69ce52bc12dd03120b7374c8e30829984c7c7c6e036f4719e7ef747223c5b6e13d795076fab4c59f12dc7b29ad47a64580fe67ed8befe05757b4e917aae61d527c9d124c5267d017b5b1f166f4b61c79da4bad06d3c1c949eb63ec8e19b46c577b685dc3aba38e9deb98bb8eebae0eeb320163deb1070178beb1c94b5df7cb3ca1c1755d2ee0729cf286066695a3b32dcccfb9aac1b64dbeda62f1cf650bae28f47de5286d26e51bc52a538d83acb7659ddee67995845fa6e443fa771749325eb471e40861cc2be519693b1cb732168b8b75504d75a5a479b6d3cdba49e9b2b057d7a0f47c3621f519e0f94c07429146c9eb30f4bad76e5a86f136ca58ff26d3c4a48fbc30c1606d57183df89b7d2f0edb24e03ed439266b05cdd89e287e2d038a1bb4d8e036e0ff808c0b562d5b9a452b4c3a909e72483b99a5098a83ddcc0465ddcf30cd0de7e5285b80193595868f10f534e107b3e5357276c74b825926218732e4a6cb0334ab679aacf2799422fab268d401f34147f5f5a6106b77fc612b353431146b0292167ac9d1788435d4e0c211c6d4c26afbbf66616c05bf6252a0b64e9b7027ba4eadc035a12d747c58d75790e9e07e185ccfa7001d4e296df0abba20463018dbdaf5efb3cee898733acc05d54fe2b7fcf718807f2ce6367068689f8db028f4632684efc5710efdd50c854b2d2a99f8337d4114b355fa0b35e31c8ed3bc0d61fb6a3755ec41e251c1ef9751c37331b1b362352e77478aede9f0f3c936931465a5ac8aa116192c6b90cefafcd18de63fcbbfaaf96caa0dc7089a79c4b91054814e77ed0356a121e7ee4bd9b3b3cc5796ae8f5f805cbf0dd8ef04873b20adecae6f581ade4e9c28a89f44d7007d708bb78cc13bc692cc62daa89ff1bcaa9f7401d3b70b36cc8d6bc950ce89b47c6cd3668997659a7cf3a23fe4183720a43219304245e099ef4b36e05782e50435a628a48c4a3de0839e021dd1bb84b1723fe712dcd3d38bc20e4be38baef24091ad667e49f8d1fe9794f03ecbba829e5a867ba80169dc5e7cbea03ca021f23cfad44713de7e889a17e0bc378d79d088758802038918d9b1eb14b60d4499672234fd529c97f0803ac30d8696a3c91d6eb3e9a62c0aca8e9035b9e77f0e2222085886591069381a76964e16e084cb6df3537384c9ea99662954dc94722e5ee65a260db17b4725d4a54289f18e2647fac95e60812430563447b102d416f89300a8ea7c42676e64c6bc0dab2742e37df306c1fb107f4a75b2806b5c6feec8afc1943fb522236abb8d6d02b48d5526a5ba155d11693a41e04a2dbca513fac8de5bcfb2353ea4c5d7985d2b4b52f433838589647a515f6d943381b138c309bfb1d84540f660735f9e716792617ece8c3737355b7eb845c26d05aee20e0fbe3da09685e943801206023efa7ddc2f446e03d984e33572a38aa4a07f47603b315d932c2f7e99cd68e24d60d684319d03292ab6fb0f9a88bb6dc7980570bfda5debdc3f0b2b9d7d43d266ac7ad23518125353684edd5a77902c5cdecb501c0b9d8fed179975eded9deed9c01e0404b43950157d7cc0743bae81d61898de2b963c900a9149af7f6402a2cd6ced9e3625e5d2099106720ba6511654352c68f18d8b83f562422a8df944c950f750951a34c6fac5574d8814fc9a484c5ab284650d9112155d165df09b9346838d72e9b7e7b090ce1ca9b2980613bb761b7af6856eba6537b0db8028107f85d0d878aa4d2dbfac8419367f6723729ac0858a4e2bb66251effa180d90475104656da515830b43f0b947f8efd307a56929c4779f228cad35689f8b7d9c85b15f42f1eb745fc3d4b55ebbb726e55450325ac3df9d85a05248c40fd76578affdea39d1da9b109eedde7dae3bf7f7a5a27a62479a865b79334cee9289c59bbe3c65b382a4d754dca315c0b6bd901763bd5eb59ba1e8a36a782b59250c2415f45fc9a10b9e138b243bf72ce97d187d923c21b49d792f51de20ff28e69ae786966081ca112c01c0557ba82fd3a6b31b5b09c95fe8b7665e3e7eb8eb994025591994e65ff21089d39d1fe61436676c59d1f47ba5c584e03d888a2849f49ba6adca039fe5f8b64dd68eb025589fd337f49187c5b19713b92ace0917c21a4d700eefda5b0f6a3e55abd07a1fab1bcf712dc53e981582f8e71716847716bf7a29d34d6a683abd13ebc589cd159650af1378fa241eb74b5fbf395144391498b6f92304e11b81763e227d3df72af9ddb50420111cdc437c70bfd96fa8a5467349032b3726ced716dbbbb1d97303eb9beec0ef73eab11ffa7192e3f2e24337ace1b314affceb14eb2b7f6bbfb5248a7d75e6e5495ee9b5910b53e423223f9a1690f142aa803fa9c3f71c8187b8c5d580a4f9317ebca12556015a13899be5564f71916928886ba85c5c853b656dcde422325be91e662dbd142354720defd22e3b0ae08702d22110fdf8abc850eb446aff650e6a6237c4ead4d740e4527b21b27b32d30856864193a6ac91a41e7f64b828f2167d39fa1f697033a5adc8b265bcc0c437bcd9605fe04a94c73f677310ddc4fb2d466da4eec7f6877574ea62e2c46e432cb1d8c1b4ccd486f681742ecf4b3ebbe74fa0010c79eacf0e49610451fb5eb0c60cc9abadbd782f06541ebff5fa075fb9a567c5c9458159ae96c00d71828c4e02d39b0322c03bf16bb45db9c224bbeb076d9f0251f4b8998cf1b877541a079f7507f22aafb3bf52dbb7d4bd5ce967e1b58c2ac902301a543f99b876127c84fafedbee5e094274d7092283caf938abed995225358d64989f6bb884be8927c99791d64a95f0dbd0a13ae5889d80b7364c6fada102282647f2d8370c743c9839ba422e9bc846ed812b417c09fe8c99f623d721a98f01ff3ed52e1c35c05fb90979b1db581373a4d8f6336e862559ef3ddc7d8918e0a1386aa98752138f4e504a448d421e5ed5e3b774b27d6db445d9d4ba9c1b77d092485e041b195404952dfdcc6c53764ed56e455725d38517983e0bfe2e79ed3c77bcc1e1b3642620464def255e7fc484d3fb260378c696b5bfe85bba3c3a0e23f51e9b27dcafcfbf03670f4145534f7b22c9f5f714f70b0267a82de08655a3b365027abffb0b5432b9e2e3a292f92c87908be14ff1719a66383060648856f0a7eaaa7ab8fc04fd7181a6e5f768843441e40f57ed9799ff164bcc4602e2b298cc0d97f4cb600debb6fc5478981116edf2dadec33f092ba1275f54eadc8ff1f8770fbde0be4c90dd60ca2491edce002a253d0e0464d417e5b5af281e98e76da0a116d931996348590bc7066954bff46a8bb863341a340de69f38a80545619d65c5ed7165de4015f26ea22216a42d421818c56469032ca1708b7f9f7e337a3c8300efbae2031d505604ec5e1ee039c2bdcbec992656b8e42ffbfad592962c3fa2cfd81b62df5e65da01c3388a6924199f6a6ca6d34954084d33297324cfe82c6543ee8e74aaf84ae55c2ff39c8a5a8c9f3ecbcbd1b99a3226d842ba383bf1c3546732cfe0a59e0020fd4a87c370cb05248801bec994d721c50f99464b2ef839b2b751fbf669c2dc4d259e0ff6acd1fce619ad8ce17ab895cc290255ab3506c0666aa6f5702bfa0cbb5976dbee3013f5792be0d6eea3798be2d8491d5a985ff3910d1bc6f7ef94463ad2df39e19f518d4415c1e5606d915efb2c0512b579a2cd53551e0cb8cb55d2f852e666f338b5c9f74874dbeccb148a6b3df581144e8cbb40d3b5e6a075fb2b442d921f63dd037094ee800f4f8b2d291ea0d20d501be71c73a0254b88f3b6aebe3abe3a49345ee0c9cd095ac08e1f2310b9dec607c5fbb91b603ead994c098ad420d45230fb7430361d24f4d4e0d5eb85ef6976d009436f7d2a511e9a436141f2eb68f3ca68e7e962cc6cca1374018eafe89e9b6afd542bbe7a1fd9ceab95ea79eb21bdb9196f615289743e3e5c4c1b50332989f16e862217670c7de45131637fcfcd76877d50226f89ffa72448a99263dd6143b28b8ef2d296f507a394b0a2865814dda416af47d33da24d765fdbf1120113fb6dd89f4cc9277e1f1d05baa59157000cb480025a9128c77e5ecc6d9d7b4a375ce3dd2e743d50b2371ebac332edacfaa8272e66dcab56d15f2df7c1ca3cbcba4738904534ee1487558f8ed5751149e94a6aa1f8be0a77412137c5df3459b92f86c66eb21861507ee14529e6eb7fda4af9a8b5e785f0fd55749cd5b0caeb1dacb479d884d67298b52809704785e3523c25c2e6df8c0225d4916aa64bcf36dfb8473c65dabd7191591271db4ef052afb662602310dbdf5c6a2830852103a84982c617da082003723711058eb9445467e547021e42473edd8393b45054e3e3dd63469f543cd3cf91f165eb718fe616c76c9be7c46503435650febde006f9c690fc5ac97d02f5970b1ab268b15e18d347741b503159fd276712771504fbf8fc164a211754ed2cfbdad8d2cdb4c47c8b1c65fb099f37c37401309c999a98c0bff7b4448532411adedcf723a428f825cc08055b021abf57302ce2457b90c8b04cfac0e24a6043575d5e7ee94764d990d1354e8bffe2bc9f6ca5596a48b99ee9127b55522190a13af2da5fe26bb61813ece1f16ece08364c991c8efc53ef57cbe3d568633f3d7444abbfa43ad705f1239d4bbd751b9f313e279ce7091ef4d4fff5c44760e9e9fb79269a67b570ffb4d6e67865b466876614550f8e260f7b93c6ffeed3f57d18626fa6e223366e986cf43f0b5ad235a70807dd313bd3e8c934f00a1218a1f87269e0fd6853ec52cb278493d42cb2ca831ef5e545e0c5ce58a95070004cc78607acff62f1d0c08111c2b53795b0c687c5641a0a922bb82eaee302785cbba5b8a2848758025bae481bda91135cc01aeda32ed2cbf3d8c661dc992a2488b59c25d951d29a1f47cfc5d6b66dfc9eaffc1e701410c6e604ab42aadc2b78c02c06dde524ddf7a25136e956c0d2b20a6d2856f8c415b39a3ca0e70b15c45312ffd958b6e523138d73661db5a35acf37d932c8fc3e3cbb2d7a5c252f8de65f0c53a791e48dc66900b2ee5fcf15dd8907c1370986d0516ef41138c32d072d1196f2f8584265c22b65d239b48e0b6e87f554fb21329a47cb20755c836acdd7a9a86c16077336d71aa52f409cf3ec76e823b3d9bfcd71bf4df7adfeccf59568cd9bbc3b76698d27d0bfd5475af1ece8d2f5c6903e48a32ac0fe3698033d733a7cf2cabaecefcf7771071bac3ddd505633b5d93af15fbe416e5bfdaf47a020d1db9ee35905e25c3fd1c225ae4cdefaef27258f042aed707517107f25a8649ad0de22c873a6f769b5981e16223f1540ce7f206f2172426c27ec207a3b877ebd49e624b137302e88bb4f6bf7ea323cc011caa8f364f3428b0b04b780e43bcf8fcd8d72616bdc6ad9db7a57d6958f59e8da68363a7c899b80608f8cc018490e6397b4be6a78a58ff6fb9ae30288862a2641401f642b4a32fcde9525e335b4db0c03c1bb4e08ac7256bc9286ece7dd38a127c770b6e21ff27b1879ca9645cb7f308d79b9e18bb1a59155c3c8572dbbcfc059d6189212da3e9501089f5250c2fcb497fed3751839e39b6c9ceaf6638a5f5bbb62e82a7846b1b4d54574faa131042596dfd4da36c61e871850bad4cf6cc57537da37486c08ea861671f61d55ea16b8b9134fc1c16d7121f7e309f353856a75f2b4b35323f888091c63b57dea15a8d4b0f29892dd5e41b13de388d8e6d83975064e990256571375606ea93785cec24cd45870b3cc2a213c62d350d3ce593986cb126345359ce6b9562f9c4d14dcee649876efb9d9aedaff2ee243b30dd6a59ba1c066391a67b8eed4d9ef7b86f9d7c0478f28083de1f4bca783317d0e74aac81460b4bd66ec4f0b7e86247249c3e78f706d135b827215946f2a17e25fe932bc1adbb2b533cc6f6ff00e2fa362e5cc58df06fcde719c99f9199ee5284a9140e56357bb4cafb31c18102f240dd23366140f7649d84e9b5c837a4e4df986875511a30385f1fa47dbc3969fddc45331bedab9bfa1176251c1e899a4375f291ee2aba06cda0b75524a9e89953257abc1b119f5f09e2ce921cfd03e753e336b5ca5ae0bcb132523b3f7f7535d0ccbfe1a3b2461919936af7f338f1cacd77d3c65bc5bb500049b2f97aa1245059e7e83b829fe860d1711982a62d45a248b98158d015e7739ee486e1bd0c6906bf371cdc9e778114660a4732a4264b2eef4efe789bcc03db94c0786bf6b50a7838cf6a726de9b3173b84bed6f500a0e559bf8c6d184e1ee9e464850d32aee9538d9aa8669b4bf3ca2e1cbdb74defc998c9ec9bc53cf7510e14bb759e0bc0f28d92b2d720ba63493ecd14ad3462d4e573233d3e24972fcf416267a323766cb9eabfc48d889f1f22b6b9d8aea0d35070ea78e86156bbd3a1f34234efb3dbbbeddbc68b5dd64bc03a44abf115c917d452f23d54e758889f912c3396c47c493774ae588f0db81f8bf962f1dd76341e9dd606e6fc0de4183ac0015b44155ed8f6b72014ca2f5fcf95ace535573325b057814f090353f27f46dd9f03fa591129b05ce7420d52db3ca88b555313a1597e9988829b5eadaffec6ebebab59dfcecbe8459eacbf46efd2121ba39eb3e23e377e1c1eab13926d3e6ec1d53049e6d106fe80c458eb0a5325bc424aef8b589df7b511cc70aa501a1027c4d0db464e878555930ef9652c0e363c1d5d2d9ea29d028c10c1a42c8a510e03908c72bc50ed7cdd1f2ef1737af3b824f1bf4fd1229204332b1f3f56fba375c5e0ccafa4c08e65dee0d12ccaa3019a436ce932ce757074367f630c0ecac485d625de86999b9022fdc6eb1dd8cdb44faf4303467e25e571a7f3fcee6c2905f0e9355f8e14c3c5da991365266e6141db5d7af60dbc282deacd88e0e59231e84bfa3538c44dd1d497d6c89bcdd2d3913d15d08d7f2ee4e77fa0048553e09316870cbb06541a6e863ccf0cf1dee4c4a236a2f36782ac7813eeb313bca5b532fbeb78dd878f81c0d6f140036b60d689577d78f6e26887aa52c08969d38dfa9ed9844dc998dc21b319a47aeea9a9a9bbbc8059de155019635e9f7ce28b72ebafe682062d843ef339d074fe01a00c357a0c76f2db7dfbdfbc1341a7d3cad25700a550c779730d7c600d677f9f83b533f557884a3a2924a98b70ab843528fe75143d906f75cf4fb7e81582ebe814e0ce4f4e01d72d3b7aa7db4346ded2c494e0948f966ba456588594ae4a47240e4b0b4899ccfedd2e52fc385d53fe0165dd82fe5224790a2e28f8fa0467ec4547df4d65d2d2cd94b5bc757fb0527e6a83810f37d9ac9dfb3eae7ce85334b86d4a8310a6d9becc399831bbf2de9c491dad3e548760da997941787a3d6be4035d778d06ae737b6f0cbcb5c4326a7063b0b56f604ff1dc0965d46ac9e015234309eb7ae5d445bec50a4eca648f2b304ffe1881a07505b81e913689f66a57c0bca8e0ddf819352f782c879605683392eabc70ed030b498ed236c9be32061ba93d6dba8144404e1e5fd9a24a1fddc16cf08e1375d06277f8ec8c1ce64246ca8b4c754fb93e7a46c719ca10401a3a429dfe98f70a913915bd135f4bd43192b2395fa303d3e460324243e64d3e47fcf13553a40a83b1cbe4f84c171caf1be7237af5d3846693f9baf8c7f3f23a419cce807498dca802d3470d8b3979a6e305ae0ddd4c8f36c6cfa82fbfe586acc02c043e8fa066062de1bd9f6fd00595af591b2c192b1976b8dae449a733775acf63efa751b7250551a1896eb0eeead916732c94e3507e5126791eb22594bbc123be2759ea49512d8cbf15e444b141de04b03f15af5372dc377819203e7236a1c7a5e95f36b38f24fae4e0e835e9f29e73c4fa96d49fce63b419ab48e528fa558e1c3d3bf32fbb70bd4f0f25528c284f802a549f027cc060e2814fb202ce47f05c7de2c50d0ec31701dd05ec22b19ea813778defdab5bb5a89c36b783d3ae270871c38529ab1e915126ef799282631709a80f4569b990fe515b02871ce094ebc926650eaddfa506fd747bccd5095267e7cbc77031f8bd16c8f7dc7b277ae722a71c57dee07dd94f065233198e2353571e14dfdee0202643972eeb947d48608716321bb8318f2048eaa465c1823a84c794d4059552d2277995acc5a17fda6a748914d6a8d2f689214853c24b36d8d7d3022c8d6db299a77d5cea4f156bcf383e4687b4906d63aef08e159527303e37e0e1dbbb7f4db552b530462a6981149d6911231d876a0bf19650dba9bbe2140c6746e869cc6ef31b44a844051ec5cf946c0e9a0dcfc04ebd00df3c1c7e61ac20e2b7cf9bc9d3288b03957080db1f02ff0cb10c33bfe0e60300726c07dce60c37b7e9274b8a58d088f9abea1bdda1032a6d0e4a6f489638a2eecf07dabe4521cf67af10da09081c76dd3b8eb43642e814dc007f18c5993f29539860013cf32634171e469c071a5c7eea56ec3317b5397d91fcad702d199ffb4cb5af651cec3a8b1e67d5dfc8e2c2abd411bf4a3544af63ca2dd923451e647c765a948bbe2d77ee739250ab6d29f5d7022552f18a0aa6ee737f2de3da737fcf1c7ecd8b5b6c9828b0a27091d963e1b9c1e763824f53679a8d9222b6202f17a80e6212b1974cca331e6b6d1fa14e70f7521f62683fbf0117d7c54f2e1b62719dec56c1ebdc341286f5f91c7c413ad6fe6565bf440319b9a96fcc2e465d25431982b6f2629ef86f988b63e6b4e0e85cd31684695ef887b1745d7b6861be99c4c4b19e5c5a8ec79c61a237492abe57f30c88df5bd7a5af2f25d796f37518c62e0c448754b585afc0ebd0a5c99a11138bf2a113c78a167d6d126b3c509a2c075c1e1231529a6c9b701529a07b554ca4d0b1ad0a7497bb857ac0c40a00675400bf6e13e050c31ab4fe5a45f5e983fb7039b5c7e0f6f4c3b09476e6c4e3fd1b1a936141148c967f0f4bc4cf8cf55a317e2f64dcfc56d9889c205313a139a227553c27efbeec87a3259ad74190b41ee51913ff352403b078a123210c0ebeeeb95b43eea41c1cffe280f7a143c4b297d60115ed6ea58a1abf0fcf0b0689ae1c614179bc79e436bb02b7d35b83471cf2a577317eddaa3a309be59300b22a834419da48740535e6b37f7375d0e1977ee3964da52a5c919b0f43f45c41367d4b0ffd1df8942c05df684423cc656dd1e9b9bdacb530235b8ad8fa7f5fdd7823b79cdfc84d5cb330f25bf6bab881f22a5294f9707a1c3c1a51e30a3781c26fa16b191d18583b79f0c255f03d40e01c22632a03229934de6267ceb1cce8e3ba27185f07bef947058aa09484612d69cbe219614a97cc4ff1b435c8a5791c6b8a6ac9483b9e3b520b0b31991adeb5e8892bd3549830acaa1c706456cfe6eecbb34fc196893c0635b711347887c7829f4cf630d674ebe05284e428a55a4ef7b391a18649aeea480369ff463a6d2d3b2a0683b97f38c3ce9d5933c93fded9b1cc4c937abbdd5a33c82e906c369c8ebf6843c96cbbc39c253dc9b863a4816288a4ffa6125fab5dbe8225a20acdf94d8c167ccd0f5fddd4450f6b4eb435a31e17b07efc946ff04e754470974060c1eb1bb14d16238f595211b7b5dc6ea9e7db7ad7eda520f3a5af47455778bc98c571b070927d674c87e970f05ae4f11b2b51c1e82fa2ab39c6f69ccb70c577ccc135e7f0beac0ab4233babf388caa9c2d3cf3c1021e3345dfafb93eb4b522cbb7923b62551fd0d2b30894a7e890cbd4cdbc29ffa2a90c2bd6fc1058f5d4cba93b54c4f83c3c40fbcd0e4de314890afebc15a7a14645235e9a039d9fafed3a745f4ea2c89dc84a6dcf69022cd6d857512a364a35072c33c45b2e3508afb62c3781a6cd990a96dfab381cdce28d158bd52e93a1a499b4326f1ed596f8545bebd22a7c6505f7b6bf567deeef829a28433696c3ddef7003f2c842d1e69cf24386652cd7e2f4dd56b3214228a127f18a7889ced84d43b8baa8ff4af507ebee4ce9bcf76f63e771447068f11dbfd250c9f6095cded4b67b53cbaecfbd035461c121b436c2a853f3523f4ccdec0b51a224d0b0920a488dd5e0ef6d915dcd0d92eb96539f79fac56e55a0feffde3073a15e7c3b456c9a69e749753f72e68ed873965f240d57f28848342bd2ad0bb7002021bf8f2e5e450bbf9b5cdb37d1f30c69f79d7139d3d8ec5c7fe7d9e833d1ede4cadde5783b496a729ff39d417a213c2b0ef5b260ec00bdded947316c47b0c14ee0a598fca0a9d0c874e122832c84f71953133656a5712928722c3d958e42cef6c98a017cdce0fa434f6d9c9c5b4766020ccd0cb1910f17c3e654c0b4e2b54910210aa3d84ecf96e3437669e52fbde19f31f7221a64abff5c6bda75c16d6e7438aa14b2b39c89b4f706431ed1e76ea6dfe593404b1d19f7a5ce223d01d3af27db5b443443ad35b1b982fd64f9fe18f62585c662003f844a32d0d2a81cdaa2c8ecdb5dabd916236e5c4b9d6000758b3676dcff17024eb29ab8119d93e7744601a991bef470e940903564227ef6233fb94d0bd147a732bf2976a34af4c3eac861108bdbf08b9114a04c21224b2ea9cabcc459307cff5c22e41f1c8c522f32e9e1f7e5c4bd8d9e9b347f6325dd6f6d326c284714c1162fd61d7430f3ae49d84e29b7b29c13cadcfab427cbea25a6735843ade76f44595561a54bdca74fa674a4d312c6960a1caea445685c9f1f6983e9f8d7b500b3751cd4df3ea2c8a264cd06027b1a6351d029a6cca8500022340007432d8a8faad6791b5f1575ab6010b2b4f38d86e0adae07b7cf1ce847280c892e086332900490eeb4a2a66c8d9b1acbb041c0c4f23efaea72da197da2e13e227702fd8cba7660ab2fa40a8e90a60649773696c3b5014829033776db6a21c8e2c2aefbe826030529dff7141d36ca558ff283063a9a531adb6a9ac5b8345b71ebbf7cad06e8cfafed878757c8bd931549c1d5c49fc2afec4e933143cb9767bd5e0e19cd9632d6aa9f64633b5de07264bd49b63cf0fc5f21c2beba0f3fffa20716d45db5f54938dbabca84e0341b83ffdf8caefaa7c513368d358c07786da9bf8a054eeff49514ab8ce2d773115823c0bfcd6921cd91311557d0f33eda5f4dd9c9cbba89b0bf5bd35ad6ccc9c835c5febcb4d6ed9077679259b513c0828b37efcb48785ff08667746af537a9f59ba5f75128c2fabf2c027f8a3ddb99249254f3a460007d28ba9ce584c92c7dd1b7b3b8339f9eea84c8e1a0bd5304de64e5c2dbe3bc3d77f551393f2057f45a7f15dfbda06298d0fe81028c6f187f3c4843063a4ee67ace62b918c14fec1d2bac12e89a27072ca87aa670cc7b35300faaa6f134f96b48e498b981e1ca30545ea82f9c0637dd1c9952959714d1481ab780ad0a2623d8dfa3bccafabeefe4246e7a32694269e45ac0a71a0abb2699cd5db695de59cda9581fa9d84bd94ed723656a6e7620a649ec82461d20934cc061ca0bc485da88223be361fce7f0e77808a32c8edd108370e8cd2b1fdd4f79870eccac95c27f93d8924654b3dee3ef12665ad6984c4acfc64e3fefc72af76c1c3fce640fb3b4bb9286e5f05e874afcd8a2f2b2094f51f3b0446931460132c951ee790e489995b460e1a318459c34a143924a172cc18091f2ae8469f858f75059fc9ed4069538bbf863cb2d1d45e93c2408cb59c47750a0c0607494a4c77ad2a3ad7fd8a373033f5ae76cc401cf23216f0a0474a34850165b6eda21951292d2608b250e221d7df5622992585a592143933aef4a4d00df70a766705b3197ac8d19bf868820550ca253b115e111dda763b2b467a476b33a57da31982685b1960f890cb9cc21416c54826aa8881b5791c1b9f0e3c5bcdf6f5154e92a11cd4524196a4f6317dbb20a677c93880bb705af7aab14673ed92ca340720e0b62116f7a2c1e85294928a33af3d7756aed09a6765b35edfb85ca70f6b6a1f8af12a8548ebd7a8fa5cd76d650847f7b103903546373edb04a498034b6462357a60bf5a267cfcf964ad1c586232538c66d4c730221f99e977b87e76ed62c6cd6bd17e1a4c255e142efccfc426449e71d2af50793e820cf92ccb18513c3c58b671e54c392c1f26a411d929ab55f4292d816561c1e3560b35abc02de0016d6847ccfa98a7c3af6800f08cfb8098c4d0339eb2c904dfd2832a3a0d66dead0a476e45522369604d98f1965adaf06d753cc39af8165cdf60b6ba74880635acde86ca0346db7563569864a1a1afe88725380a07e3b7a3a6fb23fcf3779897e842a960c4795a521ce2e8050f07d2825134ae8b4dc7a71b4fa5bf4255dfd511c1e2015d5732600e3039f17560f59b176631b9ccfab4481e0620cc59d719158bca79e023d55b4f7b09d0965c64fe8451aaad725b31aa367e33a98f46fe3715869b2c9e521694df860e140e9a04e656ad3479e48dd427b8b63ca9e983ff5ff97661a0a6bd039a72f22656b56df156ab584a03c242e9edd920477f3f4bb492b7803d92392b4074f545d6b0d27403842b69bb515a6acb4d3d469076e157f537c784c84f4dc061399926a45c5ed2b1eba52f769114c3543e29af4c786f918fd2b5d57c2b4d8761639c63a0649c78c9383bec5bdbf220d89be014014622212fbaec21ff333108db8490ed2be9ae38443dc470faaf75000fa12508ecbb05648063d0a18668445e73f569e0a0b49a4710d95642f41a53b434b66dd0784cddef825562e3f1c729826ae3d68861e0f15c62a2bf75640977d486ccb519686ca9c389bb3f02c7eff4243faee59b1606347f3a7ee081e5b83667502354594bdde316a6ed75f778acbf01c27001b5898b8372ab1eedd28176fc823372bd65a8a7f1eebad9bca630cf328b3c4d8ee03bc4dbf052897d63ddb8f5b5f3932e4863264eea3882f530e8aa82f903d6c1426a9ce8a234d70a410903df04ad44189731128ba9bbbb16fde815f850afac3d68607a2bfcb05243edddd8a7191b8b8b3dbd792f896cc3cf31c91a4a75ed270d4dba8b9d482300ed1cf134af81b45ea9d429e2f33d2b5341becf672ef2d663dc7bae8d09e004951a232d28bef5aa8fda6af637c4c9a77bc4a78d19aa75f441a1c6ef70654e4f93deeeba04c001649cc2469ae74d64c985adeb23597e2e78d88bb2be192f57949d5f90749205daf14e74cf815f7d9e25726ebbd8d0cc6bf3ae3ecdb60cacc3606c6c16d6d7d3a3786d0c4307f03d546a43be42bb7fe149c7a9eef4e345e8424a481e34bcec79788e259da415fb796aa34e82d7bdd9549b810835865a4c6cf9e2fa227b736c30fb334e601f75ea06ec7735139b0f2d4aaa1616ca3d58f0d523387383ec9709e8aac165b88063ed4a2b922914518582dbaf449a85597a3919b557d6e1d8b20998afed044b4ced73e2dd2af75e5eea0622c2fc8f6a3613891b88e2f084cbc03fda1cfe1728bf153d708434d5a02c79c14114303ed42d71572591e69b901a87e93f229db0391ae2df1420f4b078b472af514bfa9e0d4f1c5872f014f1eeafb5e87e20766e162e25fe7593a158f42bcf806f68bb09517c7c0276a263eed0493f45db05c537dc3c2e2db5b7bf482634ffc630d5bc7a29504352f8c9d2e0d6066041c9441f8a032be4fbe99a7d93f10ac88d5d0f15169f4cacd70e22574f99e316e4f9a36e3dd04f86719753b93ac958941c77f9805b3ab96f47680f75cbbeb5d5e3de742535dde106e93755dc4aa96d2609d047bca30456976976a6bcb1f10198ddabd4c937227bbfecb7977464595db371c3c67673c0e95f3c3520fb303f1eb9629f0361eb3929491991e5160ac2d2ee264c655e5b6e7d3a9cd0e4ba92dd5e1a349631b2963530aeeb6b97054bfeabd95915feb49f5fbc081195668059ea8177838793752be518cc0cd5512cf29eac72d209649336eeef9724069c6c25d81bef8d2dc9e45e83aa2081dd1c569b7cbaad5d022e7787caafd358fc455002bfbe11b7999e0fb2f5df68a08b60d6a3b1b4e7ea2f39643122322adc6b4fd0877035404690c1d4b557cbb6478e11b987c4632d85fc77f6016832d480ad0184fdaa9612bf6eb5fdb797c44b39cdd2bab5c2944ee48b187df13d24ae98220da54882b259cd65c92373cbc76ef046fcb45446372c0b2e00f03d5633d2712d547c769482dbb6106702f2eb","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
