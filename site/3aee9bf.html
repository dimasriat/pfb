<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26a907564f8b3556c1b572080c022e50b307e9ae1c4fdee70d11d410ec5050ddc9a766466b00e7b7b4cf4de4d249b34fdfa3db3cbf4092db8f532d1bff56e2f8a1dc97f082e71c2055a43ddcb265bbea528afa284be25701da04eb1863bf101025c21babfe0cf866700fe2d51f4813a65649ada2670b7d47debc5f687a3c0d7bb414bf35ed3a433a7fb5bb3b44686897ff5a8e2271420ecda007d97c5fce891cf78230eaa73136f80ff38576bbc7fea6c67cc654edaf26a01795bde46e8cd810bddff0e5213d2c3d584363cf9b7c3aa04140b32e1490cc148b394cd485e14e5ec9c4cb447d35e79eb3126221a96a6c7a9f3406a607d7f026c08794a4cfb428bda74e99c9e3da6572271b5e15d621818e3383c63ab31adad078318967d9a25f955b8fc784ba5c25000cc9f745ae964b9f8e543754fbd302314ec1f9d38f25b606945d774c75e4714045daef7a76588ab3da46f05fbc3282ac1dcba87f2ff9749e6fcdcdb0aadf9744017a2a270e6ee85b28deaabfff41264999ba7a0d65f91778084c1ff26893be42661b2ed3f0007e54f25eb37f842ee0ed932bcb8a4242d7611e3f7d0b7be6b558693852586140e388a31959e8b58971d33fe415605250dfb0de521fbd416e495d33bbe5123006b4680a448a3874a2819e2d2ecfc0d781fb918072ebafda495d638fccd359ceb24051ef39ebca3184d411484bd2f00b22fec1703b5d186fc8fcf7da8892d104228f1f500163feceb09ef1bc9e82a3f29a7cdfb073715d933816a4b17cc0c01547e73bfad6bc8e4d0fd5d230f1f62c9351f63e9b576c32e1bb8c6f828ca8069a75e82c5e6b59b25a9690bbbefb7eb51a9ff4100c20d792ddf44b8e50e93a96bc0d9b61e568ae4b1e9781db41a1ce8a2eaa6617c0aac74dcac4300dede61a9dd90e225b77bec16b0af99b7e5d85a2b0bdbac9bb7e1aad756278b30dec09835299c521e891edbbf529c3bca2e1f7a97d6ba8f30f768e63fcf8d3d4225978269c71eceb0b2676d4e8a3abeba2d49890e7fd8e010623445b2b7217d7aeffaae8a3f7d7e2600dc66a6b22f74b73555df56d0f21a751969ce43da1b4349452928abdc9faeadcb55f7153f376111657ea406e3ffa975147c29a54aadcb6c24f2d555d48a2eb680dc2826e623e685aeff5a37a7dbb1de7dab4fc368f1e12cdc8c5a70d9d0fda112999412e60d888dd4ab0dc2744dd28a2ef40410831a86c49ecc2ac4a94ca0928ed6618c2a9570f384adbf8a314a6155ed271e02764d0c512ae613c43c61eeb4e3515082badc759591a392e362732ed2fbf1802b782a0b347a335a1a56f883b596d179a73f357fd4882da4444a8c5b7c4379f609c2f7cb6f6ced49fbb8fb06a788c2e1bdfd6dc7c6b51397fac7961865fcf7601d7b508a7fc8618b25b524411cf2b7235a1438cabdde4be26629404cf151448f0c505e4fb63d8cfc94ee82f1fb66ba433713364da402cf42ab764653024825b825f616eab63c7a165fd9ff89660ec3cbe27d2a120b7cd95234fe6a28b61ef4edbfb94a4808124919185d461cfd90e2bed3937fe4eda23006fdbfb2d649428328cec5ad7e59c011317137cde02d6563448c8192c993c064c6ab97499f20724edbbdb4b4a58b461250e1173e453c9875fbc15f0ff5bdacee8d4547c5d6b26d4dc27c597e8bb55ef96fdc1eea28e82a152da9d6055738d1f648c88f582afd578d8f76fb5bac9c92612b2dec6c4934e2d07f32c80e2f359fc68b4e37910b979e6ce5c06fa2069a290b405e62fd698ca9e7c074dee7fee71d84f662f392b4d6dfce60448739cb7cb53dd1e80246bc4aa7b674976e364f20011ee87a664d73f401d309293a1d4376eb367cbf5091a10189476ab6dd1d00a165deddc041ce10a49e143c62c23fd1882ae7f40bfd2730be18054978757e1360e4924a6662429ed2d055c5582466ea8ab6113c0b8aead2f1b4ce86892ab5e87cab9c24dbcf23f4667f915e8d3bb7de8cf61ec66eeea30648253d68ea70b40ccdb2092047dac87e203381d8d826e08d77166e7455ba8a9af9a5d39dd3d1971dac99c021191628152b870838e4c292145c29d7d691d7c6dab8106c654a763d0d1559828cc0e3b1fc2e7c6bf3cb3a2f630cacf8ce2106242e45a23a97948bddae7600a00ace8e51b17e24bd93d588c61fa5d8fc6902448b3f7141f6525713a9c3ac75466dfc83fe376dfb349b36da572df7234fae3780e2326c299f6cf9031f63b7fa4ebd48de1ebe985279f37ec505458369cadb6a07b69b4ea767ffe3ff5c55ee45f0a0524c204f0c2bb7d88f09aff161341861b9df73e3674b9edc5b605115e850e3837637305aebc14d6a1fa110cddf0151bf7c934e65e78b97c5bfd0539a92b534e69edee5de477532b688ba815f2f2d18b1bb13aa8dfc1d853313c8c9c9c10cb1acd9d4e51b53c8ea9ebf52fe00007d21bcd31eb5496428e30da714bfe48e69627567d61cd173f19f53da908f797c9f03251a1c90c637319f9df0ad14ce32402a040593f578c98f560055f57b3e005c93eddc4dc377348755fd1ac1fce64facce7f5e9a24ec166da7d166955fd86817ab047b6db9eb1c2dc54fb54bb22ecd688aa4b5ec00feeeb4788ea0f47edf2c43b5f78e3c23bd10796cad04d3df5626344fb8a678de4fa19c3a0bdcfbc5cde448208ca8a40e71b76c36056292490b9d2dd55d0db19d424d7c8f8f37acb7da94f03021b66ac2d026c93e85d4b46494a1787ac734208b1ee7680997e7a4dc89b5b4fa0b7f77bc922ae9277bf15b5f5a390a77b6437876df8e452fb2268a5535339e6b75898700cdf26c587ff5bae345f027d588929e8593bab1948975e274437cfc700425c23a81cc283a632877041229785ee7b39f9eb90e666042dbb2587cbd4f014b038f96f53ca8c4d2645f32044ffe47631937e54521b5afbcc30a8225133a66c2abbb0b630ad3a3e3dd7854461ecd214c57f21ade201f2d21b2a04f0f13ec6f56e616cba47d39b76479c5ddc55c49a68b4379f949b16d4c0d353252fa1c6ac6b147e87923f56e2543007301b8e4c1e43969d0636c501b171f289d7ad38939ae569a920203befb229291fc0b5405f783d616ee7af03ae94e65209b2ca061c8a4bb3a8f15d6601b1913a349d1932ffd05a2162b62abf4d98918fcbda3166a48dc638032496b5af4210af7fc359d9b2f83a812cf72f3c2e91c69372777357dd8e61ac0534b35ec26c16174e5173c0f911c72b2cc4401c1685f1d02ed4858fe24cf21ad02a50dde2466d93dfebf4488242cb5613d774bdd0ab485a603d4a85ee459b355af315eea591210c16f847ee957a1f0fe973a393dc0e8481b0361bdec7469673555001219f7e424b7968c158e96a37928698d0da6e376fda284eea1e4dd56a37ed96fd03dd8f7f6c53e8222c3a0923f6ecbcc973e70cdb01222a9670f6d31993828ed4344955b581071fc5fa7c1e4265d1575a08b9380015016ff3804c651b7149380e432a0ee3554af43d67b9170c31330acaa1ebadd6ac110e31db58233ee2075f005acd94a8d76c8a614d3d7fe527396791bf2c77c41f22a5270c677c1f6140b379290fb9206079621d908d583785ab3612bbaf5ef9af58a2e0e60f3d5ec2e1a8c02f2dda8d90672780bbbc21696b37f060a6b4d18a382fca859be7bc139773b62817eb0439aa8fb523d004a355e7af591381a66110390f10ffc05179ea26c771bbf2aa9b7def827e98a3dd0e0d27e36c91bd55594f1c18b90922328914920e0355653401fb4d741e34dfa016320ab88a53e635837117453c6be684ab29d918f39ae8032c5827af2b0675db2e764bc11efa920b99a71ff2cbd00ed29c1df8fbff51d626eed48cef5b7405795a66a94d6b4bf177be60050e7455a02abdfba0345e56bcff7493aeef677194da098f913d245f65144760bdb026586085108f481696501e31f54d5e41cfd6ad4d5100f1123d6989dbb25a1185230129a4deef572902653396ba23075fd51448254d3de3faddad1a3425acd61c6d39e273e11c8a0a6464b99a851f463b2d7173abe6aac501b2a7f62101ca8e5c7e642c23fa5a22ccd3b73b01affb2fada10fa23c382819f0d40c8aaa4ba2c0174363129029b713eb40f794bae0c1e825407c5cdfc5cff28c9fa6fe3be0324cd297479826fd7393508964905a80c56a603f6a8d97671dd34f69243d08ae248655671de6eaf1043c90ffe2c2d9edc2295535e29a363fffd49378304ede0bddf0f330d1e7e345c222bc7baabb74644486d29f8b12e4f9a093c5503392d3281c76c6a610a6c669ccb95353f2188928b72138338d93582f5543cca0fdc038cefde94c09a9f4ee455acbb113c188906347869337a0e6c9fd2713be18d1af2f001eb0ef5c24048521be657cebe2a59ff86096227465bca7d78a796733e2d1fe41f99a15c982cd888e344c4385614efc02d280c5545c91ad80ff90fd3c911078b03b6bcab3de36f6a2eaf6171dcdf871c4fffb4468db9e7c1dca70e0aa334e51577b6206574c234db941d19041ded784ebadac89448ebcce2e694f5de78904e4c3370730c30c3d365fa1a2ad773a59cbe295fcb744d179a93324c5f3604e4dcd96b018cb42d647bd64831390a2179d0001fdfafab3b0df2a70cbc3767a6d4dd9b60831e8f4b26fef70119bda73246147d0623a12c8e8d5c5635ffd9292a74d8b64ba7f8f3e91b4ba1bbf502ed73f1f69e8b7d39fd5e10553e717791024dc209b888e9f0d258da7b975965a393db9b8a80b460a15a22ca6c59cc6a8a711368bce347fb7cabbfd5233027dcd5f8b8a6621210e1575d37b418b8d949d5f0b7050097e0d6c8cce09aa94ea4238ee50675b1fff15afd7d3fd44a393576c0c74006b1e248a729f73dc8d4f26f53857e0d87a87af36022c2caf5fabc6271ad6bebf11015943014930e2ffb7ec67258a88288b9b9e386b02cfa16363d90108057f02691a23d15b23019126e1c4a001ebe90e3fcfbbadd803384d6a4c073d2d43f7896929b6ffd360d2fab5170176d90a2dc239f9acf5905afc9d2e26cd3593efcde46bdffbeb25698548f082d9159bb3f9d352ae76d9cc603968bc04b65820f8175b42668670a0ba415339cebfa8ce83e7a0ccad607dd72bc2f18873c68033aa76d711c81643a21be677a42db21dda2e97baf529e6598478141873a176edeca5e16c2793c06b91853dfd7a91a179bc21ef4f194639c9d478d8ccc92b16723dd57332c347222eb4cf17f0d99e30468330580cc9bc7fc4a52e955019d4106e27427ec3fb9e19cbce4d42c4d2910f6748406829272c0afa186c2756d649018d4f41db8547453e6374bbf7f2fe7cdb775b9db32bbb1204dba95628852ccaa1f9462218861b7f484b4b7997026b935edbe589b12144a4fff6d9959705afa720c4f5d606acfe2206bf1dbd34cf1534223fc4b2b9934a998843b1c440125c9ab4d140f7e3f9e2128c97e8c1a5e807b712452833c61186185acb82c69e1a09aba42787a578285de29fe57f4d243177371663d2980b8ea3ac847f285ad65d03e8525c1784ed965dc7edb3e9f486d0acaea3b107a6650f7f0d83c2a6d9447cb10ebc9e264eecec99426a7971b13c64a14de0a3b85538691dee04d48caef7f9297fb8ba93d4a6e73c234308a5e0d293b000312b26d129a6e43adbd758ee00669645698668335e2c86854a5ae788798c735bad9757888a04564100b7d206788852995fa6db6836b0ca7d55452e108f78b9c40f93641862cd11d58bf1daefcfab2a9596bc9c05734eef1b82d2041e061c047877933cbcb05831bb3229da353a3f6225afcb8543d5a6896f3cf08f43b9732cd735ca47fc98e3741fd79ff3943f6babc5649c72ad8db67af386915b4fc72938c32d0dac23686c7d48d363c922fa42a91016195808ad38a983213211fb09d959bbc51ce5b0b98dbe0b4f33cf12abaec44f7905463a7d9128e40c591f46999a496e4341af39f1f85ee5838dccb6ee5f0b9c5f982d771dea474715c72bd2592ff321cc7c59b24aa091e03d961d4394082ccf1ee7d71376281d1523ae1262eb158a1761964d8674b0c42ab1ff3145895bb05ac53a301507917ae79d368c746bbb521101715afd2df402da4e07942a59a1fa5fd38591aa0764585a57916f2b6f70ac5c2f5e78c1b7805bd05d00cfe7d3873b383efe569bc0d61b075167937725f270b4e133813ed404b105d7bf412765100461290a546b7b700d5c0fafd7340954d3b040d6cde31e158482cf345c9791e1207c8a7fdcb940fa49494c4eed927b04da09fa1498e3acaf140ba137209b8cc2efde813c1fac766fed8da16762464c01d1956e26cbbfa51ccb3e9ca6e90c8f922b3b9145dc24dec4161138dda40ba658c52336036b654b24924e83773f5a207cae41774415e2d446c3260f4808197343882f68b089025afdb50f80faeacbc31ca80adbef202450912537120f872a8140d43d3101aeb231344c1369ccd77bb1c397cfc8eaad12c1f8448b44e91eb58ffff0d2e5c8b65937b23335ab13fa496e8c7badc741f5a1c1342b696bbabac92321c0f5ff6f3e7c6421b47e8814aa26df703ae88c7f33ddde29f22857a510f1268a28280296d73d23989149747a127cfd53f8fd8e5b616937d4e87713839cc53caf529ab830dea486b169ac82ef998fe96318f35be6b11b95e0f9c25aa83de80717275e5ca5fdb8aab62c28a4c0b894e953b9a32a8642750356af43a39bfd7a9c43dbac68b0f4ace4ecd21b03960f86770a9dd7d39ff84ef48f605b7ee61676356bbd50820b924e95aa68e44038045568cefb3f99b0975f050cba3823edc25446f0b9f668a222d87e60dcf80719d611f130fc512e86160576db3b270cddc740e2b4d338c0de9ba7727dbb49fea6bc8b0b2a57f6f49f2db2084938371e3caf3f1336b1bcb97b0f9aed3eca80e40ecd16c37ad489e11c25ab75d51da6d20675ec5cd12c9e87d6bbb12f4900cfbbb633373b713c920d2c9001ec64c778eb95f53a78d41c32f6c095332d47b549b5c5a2541c0091e322d5fa30f60786025591c3aa3a0589a79360715fbbb22fd4716ed1a7da2daf193289604c92814dd96184ba2130a2f8686539063658ed1f9cd0e63afe6d1aca86b5d96dc1c8a9f06807d71cdcc5cedefe16a4cbbab4578cfa62ef31aad751b8b95f102e9b10cc1613e59ddf49e2803703c87835a5c43b07693214375f2b6993db75ae1d272a45407410ea2ab6f3d90bc99c932604a1457dc6a3eb6a30c2ed395e5915a9687b04945120d838977ee80de21263c1e2e5f4b64063e8aca2f119aab67cdb9d3b37326589897c1206e541ffbfed5fcb3fb8957e6664329be210d6b935f10f6fa9b6c9254b03892d8d00a2286048b3e92ed70fa2f37fd3c34cb1dda656be8c9baa677ac7e6efe4e49eaf9249f2c65650e13ccfc5bae8187968afe839eb36663f08bb5c51f304b23176b254777ef8221eb6a1e9967f4b4aa87357227d8a7bf1b7e0f5fe7f9549e8d34639e4dd05106bf6cf294bbdb48795eac3eba6972f6c58345414cc1ad64c76250a76d7c21766cf81dc08e291f8c62232fbf7813e91553abd0bd6b99a831c7c15be3cfd68bf4d34c58254fabe14292a05957042fce5efbf1b9b1ae226c3ced5ea5ecad642d84ff9608ff5dd11b23c239950d18e35077558a6f2c97dd73c9bea5e19f9acbd7b7d2b86c920460ccacffe756975b48782baba277c2141b964b1bc31644d74e43e2952e5e6039876e63c6cc849fa13bbb4e8ab017ddf7cc254676388902ffaccecaf99a2818517b24e6db4471a875e10de476c2397e1afdb1871132c213a3b717d5bfdd10ba22b56e993233972458e6f2ebb9b26596f7a4d36281775b54bd7f3e84b250db8b655b05de7dabfd67591d1251f58453e142b42af2587f45d350c3c88fe154e5e98501f3dc47b53200dfbd63f9de919eb8b3309be19d53971688cf44ea270e1dc144326fd46ddfd5450e859e33b9bbff037fc308f305ce7bafc48c93eba25fcde601dbbd4b68e11f712786cfbcb1cd8660deee84eac52f199988f327e934d660ca5f9e12d6dd3cc58012ce0af1864b93813b33454d8dc38e4264efb476774694828ab2aa228c00313d84a7f203cb421662f3124eec9cd3a678fbe6b6d6ed2cd3677aa5b78e7c8f4e69aae5587c5e0b623035c45d6959f4e2c11fd8b6829080a9d7bdded63e56548535b50b36c080057eb576de84a4c9a5b3d87938afa79a96d0ff1af991f58b91054ed0b1d5770b4b05fdfca0d1011b9edc1ba2d932907c2bf0f4a377a5c80db2827e6f847bc217a73bde1c5dca08bf9fb72953b8581912b4086579a55983d5ee67f856dd8d88ac8d5cd4a4d6b8a102a4c1e53a42bb18f705d9d374b4586fccf72b32ca11c847fa6113e2f878d2634ca287d1351d8d69bd2b0942aadb25071f77d334d96ab864bf64117ec1774f4cf39d4f081307fd493e205d2e819bb33fe57c5654af53f783c62c2f8593b868cc8541ef8457c62507eaa2817846fdd4247fd12dba11afe5cfc059a7b56d77ce17359e5a0b7eb44cf57d732ec8667b8aa06cb11a103d01f2122e679116f3d6dff097279507206a46a46bacc0509579a2cc4e2632c238bb886c998ec31cf3fa0af1754910fa5ae445be4a5cdba9a74d5d761f3ef6a5ee1d37899fa63345ab880a8c35d77219e7debfc31b01dbb3c820cff1fb6b6a6354c3b4d08305a5ea88352ee3e3fb64760fb40235d7eca07d09eb549c29acb35d27de4cd892b78ca191dcb67f1270baa009b226f0c9e78fa4ee046fcd5a86299b5d229802876e643ceae1af1d543ebec37eb87128ee372308c1e1d92bd5c80d6dd6d628bbb7601b0664a6e732720fdd4d341fff9f347d5edd32ebd0f9c68cdfbe0fcb6cf17d05c42770235150d403301d571d29a5e0cc7c813a29304856911519d62cdeb8121e0ed3121d018e2d21fe10e83cb9050819d459e2916d6e440afd8c96be455250fc454e0ff3598c575c5fcd6d204923b5ff5cfe17a1108bea84d12b36c835db8a481a0bd5a6e472ff330e187f3d4875c2ae08ddce8399e450a6710fa7d874c92f7df00c199ec3340506e5d4b1df00b5ca62b4b398f2b94e714749efb47f33288d950ae3676025e0229dec301d22e0831b0f112f6436a9a791094ad5196dc4e5fa7511a959147741e35fb930d5958e7990619bdde685128e06fbb6210d0964da80ac5421371cc3c702e319c0bf21203c2cd891518f509c5d0e4eb8153d85527c0890c70bea13a3f55ab3c40c7e7d1075cf4b6b00534da54dc6a08bffe30fd16f54a500e5f6fa1c06bd7d9663fa648f12017c0eb9c3dd5540faae6ec259005c708f10755631fb8fad425ca61fe791adf5c22eedb1792076aee6b815f35bcb7c496f0078f0585f72a5aea969dcb108fd57d1a5540e06adcf72167cb5d9e049d0d51673a0d48e2e6997b8ec913ba629a991b12d06c758b96a8f72bdf296dafaf0800ad4cd6803e310f8f74d0351418ca7813cd0d54210d6a93800c2a637324f1fdb4c0b3e7a8ff98fecef325c3132e489ff0ebad076c32ef1d11ec9505b5ec7c44882f71253dda03378d7399ad87768b7ec1ae5780a35f879d68354cfefed0b7ec292001a95df99990825669c7ef276fe3b6e72ca1c08ba54c22c42084e2d0c1a8179f8e17c139f97f257d39cd4148d8c966e362898f660aaae0b3402a7663144d78320b21c36aba9b6527f08cea793c5becf4f79377dcea3ba28ca8dbe1b805bad41405d8c77aa659a44f119016e57868012a85cd0ed1b6e81a92bbf362ec2895e4482249667117c2c9b0b0b8e38ccd9d8c83e075e3f45963244d1d84101c5ec05afb31e94637171cafcdc56dec6d2706928c753dde92935e96081be61d90a8fc048257beeec49f944201ef53f0c0de65302ebac429d4897d51d736a66ca6eacddf1c33865adef0dd2751722140ce27791ed06a00dfe6132460cfdb3775cca5522c24cfff9b6bc107a6f7652c8f0881e2e5096f0b2fd730ad4149c82b0423be53acf7a7be0aa763a44fad1f429ec77292593a020bb654b9a47fe5cd886f8cbae22d26079f6e9c6e0ca1d35a010964b9ac08ef6192f2470b2ef01c354a436df2b041291f94cc81bb9280f06556e92ede95152caed2dd8293a5af6a7062635edd2b8d1aa4a288cbc26cef0e21646fa0bb26376cb41af89a7c85953151974cac1f7dde38736081ed713eb34e350c0a8b0547467072b7b88772a91fce853b92f37de38049acb0bfc97bf42baff42a068fe0d1bd6e3ad321e65df7a41a0dbaba9add6263f896088e21c310cec0e05b48e8f29128b567bef4f6b8d69f6c09c6bdfa755f92595e65cbe74f2054ddd359867e733ef5f41d1b9d30f2efdccf65b074e99c6254b5afe9dd9bc4ac9b27f62c3d023cccb943825efb372df0c65917d1ce504b4cd81b37eff497f9bdd8e360de41feb0c2f052b3b5972b4ff8855f9d07c926bcee85b77db0c9b6fb57d0ca764c286117a99d107ee5435f0dac0b7cf863a52029014548e6eda2c0e77786eebee1df078b667de65a19ebb8f36b4d01fc31a9c1789a5b92bf0c715fb7d4e608d660eecb5173336da4cbc1719b203a49e7955d0b88ce89a44da99e4dbc29909c10efe52e442d8439b8feea2d9a37d74c9cd0fcafa8267e5733f7ba1941338880dd706e488471ede7aa5099b58ec59a521e5cdc720a711819bdb2e099979b4ca8c8c6a13696b895b0fd47cc06a72d3c166c148bffae2c410572893cd7aa94f3c14e9365e5a08b900970439b3f56c89ba4cc82970afbd5437565b019616e44f6928591f92131a7ae1f87af08ecc79c44c868c9a31517a96c77e50629e982f022511be8b5b60c8446a13d298200cceaec66ed04142ae8ac9ef26db709542d65063327564679b2ce678035cf125a82da54f0f3d7585e215d1c3c7408c6c80013fd50efea89f4e2c530ae64c7821b68ce55dd93de20c9509d0e5df3186b2ce53817736d9e1aee2ec594360be5cf0d9a79bc412b89e2d4792b72cb45f366a05fc8a65828cf265842f2a722afcedd06819edb8093af3bc48fbc38e92a03de631b30e7ad2fe3d6e8ecd357ef09172ef50b123cdf7f4be529237bca4d5fe090fe032c8906f45944b46e09b8468b07853f4f44811f6d47c1dfc74a211e3adf4ef249e47f62eaf8ecc4fe9f2bd351282bca9ba1e8755ac52419a53e4dabddb08f0dfbcc21f95d8c479d893b202a792b19afd04c6dca0b4e3c48611de141fe0907fd718be8cd705bfbaa461e3147ba5af780b514139b18b6a0803433e84ba0a4ac9ec8fbe876109ff7dc3eaa1f2a50ca332e8263aba25c3a5cc19ec9a00e9fce9bc194f168aab6e90048e07bae7d429e2cb317e604b33bff718a4144f1ccd9c1ee28158747ea91ad37ebab26daba3bcabd8e7ba406921afb58987ba7552ca10203d3522ccecbc27c5a85485ccd1ea5bd961e100116eaeae51da8c7cebed2e7a83802e65ba5ecf648a07f99408c7b6b1a1ce5a524cacd4f5843fcdf61e8b5a575cda022ab057811c184eb457b55d5b1b87e37c2d363ed27d1824842c71f55dda4b8cf97fa6f83f08d51b3002f0bd654a68a0b950b564a436a33e75b8003178b7c97614fa1d61d73bd43020f119883fb75961eb08d2a05097ee9a8ee00c1a018dbcd5cd8541f20a01773cc95c2806cdd5281046d6e5713f7e01c1b1f4aa98e3ec516584ea7ff569448a4d103aec4cd4fe4e578c757352246718fc9f62f98bda9b8e2500b7b7ccf913b65d873644279cfa330a1f5f7170594c8d6e88b24952629bb503f4ff5c426ac637aedb56480a210bb66a12dd851082d7b20a41e727594737b444143b3853b9932d52c628458b9f96b903f2d95c2e2452568f891c1ff05059ec62d47460d4f5894d43e1e17c205641b1a7484d8bae0d637fbf9411a9126f45d20e6fd1e6b183f02b173d4f32e605fcfdadfa95c2ea414aa653ece9e2ec07910f0f515a4d19990377f4fff5fa2b3407124df450805820f4813263a5dcaae21b36c94061fb1eefc82f7dc91d4b2275e478c113ef45bb1066cd92cca1e1b9c7818561388c4290432d6c102ba16f52c53c8d1bd91a2a083a464b6227706075c9bccdf26f0c1d14fc2f43738ed59b355e9ed697d998a6164ae1e02a4288278e2c739e7a3f6e61c1edd19e541bce3ccfc2c2c240523b74812e4b64e02d084fa973ccc59df68236237137cc51d6f9f6610ec122a723e925daaa143daf1ea81aac8741b6fa02876740246fd1629d3dde574ee5930f060364c0e5251ceaedf2535211d35dda54927d2fb994d70387f50a80e1551110216a60674a89f8c131791dfafee96e54ab0902c69574321002d768ecc39bb9e7e98fbd2cdcf8a0fee7b82b343fe38648f6fc8dca8dc2c613c857b83aa3cfae4d63ceab64f3d8aaae9d7cff06a5b408299985cd60d6eb8ebcef1baa03bcb273e8d6c3ab893ffbccf33eb5555ecd8efbebce9dcd277ee753e7879b5aed3358143bfc0bca37af6e3baf9e973312da3618aa66e580dde59aae4faac447f64e55f94f08d5202a7411a32d7f284ad956034d8542e8551b39ca0207cc51fef9fd6830c223eac83d15921dd592e7b3e9f6be9b79516208ddafbb79c53b39fcc9ec049e5d97ace820826c42a8fc300b0f6e41514c2afff0672bd584325a82fa78784d1fe08ab0c13d5e34146e3ec0c8cba1cb32512b69473374af4d6ddcc43bd66583274788c273ec6f5cb724e4b956101ac53f5e08f5238661fa93be9aca5247730c37ad0c5f7624701ea1f7d99178518ae993cb7aba3ad7d833b50bba15ade53107a7cfbe7c9282c7df71f388c7d689e1560315bae1d9231b59eb1ee24db037e4dd59aa91c74650ec919f404eb1d9040499257938b03f7b0c11904c1c3728edb203fce76604d759109c357f2f9275d51db2b2a17a4ba3a3b1657ab8af8fb97a89581d77cb839749a904ca91f22f17818915e8a9efcfe7860b5985ada799000121b52e31c709863ea22a3b19da4065446c1eeeb0c811efdae1fecd2d10dfaf36f767181b98f3db4ee014939258c4c899b89440f916d66f77f874d5b6d0bc1628dd88ba3d073f11af4dda813b7a046d98a3c03e65242ac6b0efdf3b80956eac11da36697b668d25ec488c45966c4b8357a7b6a00223686c7cb20b59d0a69fc3dd3360734be7c0a1da720e6348fc834bb784abd0691ce078c1100488fa6fb835917ca1c42e777b7a1be7f0506c5bf93e6f76f33727a31f05643e0c2df491e0ca18554723e3f239a913890ca3ca4cd0273ce5edf8943a4f343caed1a71d6f1b2eca9ae496aa99c5597ad81e434299039cf1084581b4c852b7a96d4e13753aab55fe6af75994188da89368f520990223b52c8260194a691f5e57e2b09f81c486cf00e3bf905a6f1dbd721c674c0e3e480330b0b3ad26eb3eb7eb9f4f934fd8d7297fc33e8be5c3c9e77c091519fb47a2c048df732d206eb4f2179f8742dec2e253ca3a383dc24479be2d77fe2f2c2c4d4a3208036c5e73ae57482a3b0010720bc930f08a4c3fb6c2727025c4a8796a9c5541875fbee19fa850fce801c6c3bacbc1834d55ade2da21b90aa2a180b50394e09c2d5890d6c09883fec7dd08e312972ffc6c903236f2ccf057aa957d489455dc08fdb4f0ad396d427b4663944cfec1f11f1fff2c1f94bdc48aaecfda7af7b43c20a1f4a0916c6aaec20e38ea55520f952076f3e7d5da0fcada1154ee5f2b18d494d8422c68d1a2638d3830a40a7238510e3b4ff04e09489ccdcb8505b3dc73d6bb4f9424262fd30bade8bb679a4b0b5cf74192642d89877f84b68c6ad264d095c96aa6fbdd1c483e7c698b74b39c6b580e9f1e16cc9df1b4df4aedda26f23805130732f80af9bf2739e2d7243c847968f8e3736067317f4b62cd7bc3f0faf1eb080aa526c8538cfa779452cb1729e6d9914f3772fc54e8050fa3e10ece9739f111cbf1f3e616a1e4d3c6a11aebfa7dfcd37b0fdf7dacdf7054a1ffe37ca1a58aad4b3c48a2569e603e8dee316d174cbec19811c68b41e56cf94200e5c40bfc9b3abfc16a0eee2b58fbaef293c6e755a7c52ad61096acb1a5628107ec438928283fb4f1e7dab50e28c2b1c979ff69abfc69b400aeb85f575922cd76a69c4413cc7ee6bfa68bb56e148a23d6ad927c5fe1a23fa5b4b4bd53d5f1e8e80271e6bcbbad44b9be61a2dd9a0111e6930e97b3f5cd246a509d07a07bfff418b1dc8d4f371e336e01d258637b8a3c16c74f45097290f16212ca3d4028bf482642cf8dea4d2d667b7b640b571f97c8fa4be839bfdd90391cec71e3e7eedd14ce5821f99a9ff5fdf74593a9448af7bf688e473a8f79170aa7af478ec751cc53458a22caa9ffff98bbeb33915a086d2216ff9fb1f16061e807b493032df32a08123663cc4c31df4abb6f3411953468088bee265fa076d7bb2a6d90d9d66646b909620648d467187d4ac21604d82ffc9ad84b2eaa55eab1db78ead2ef8c1915440ba24e34bb7e02672e08deb89f667dc50c71040348fecac6b14d57528780ad2c6d4ed0784d1c71a9ebd453174482d941fd2dc2916d9bf5c7f0fb3fc4424","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
