<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a147aedb3533fd56fe1d7b48a3f06a1cc20d25698ab4bce872b915cc3e3c4a7fb5dbaf6757ccc9e9bc1d55a80f94a410d2a268f7dcf2f4bca791152cebcb342617931b4ba33c9f3e7626fcb6af9c2ed39957581dabafbc554d6ed9f0536bc1f9375f964e8c52406511e4ba109963049df46d5b855a58fbe3eb8a474ec520ca36f442e4c1f1d7cadf456e0b051a879fcaf32720588c495c72bf2a817f28f470bf5fba4502f6094a862ceadfba38292fa68d7a244c9086533699b254dc1089a64b9661d3e789c465fbacddf4570d5be3f60c6d6bb7b5bf8d61b43d010caa078e4d971a3ad32c73f7dd60da81f167344cb17a350cbed6fb5d6cb97664cd128f697427a5b39b0988498d4dd1870577a6ea0f107f2cb4b13fe31c10debfb05fee167d0ce5f9c441f86b074a5c936ef625d91525c7a374ab221e624e2c7619b8bb62a7ddc75e18aa07f9ecb32fa4bde97a04f5b75f73ca430fe23321d3c8fbb5bcaf02b2fcab159acd00a8e596ecf1fc30d20191dd2ee782833c4c7f129d1328f9f33852df855f207cf394e505f1ad4b1e7f57c11c345a1665e409949ab7e9444987231afd458ef12bbb70b5522f7b868e802bc5abb964dd3e93d65aba18d01119f69b787a8678c2c4cac55f4500de8414c4e0ff876818480f48126d966e567c892bde118c930c5518add5d4e320dae2e186dfce23c2bccd7937adbad9071c8596629466ca3a4615fc149c840bbe684bc7d9fc99cc231b20e9a22519dcdd9752c49722b0a35f68f2f6e29bfa4cf4806dd9ba90495dc292f9d1819fc29fa21f9dc7329f83aaf9ea510e321b88bf64ff05a5698ddb0c04ae68da2a9f9df5ce44a32efc9c45f999b1f75005f210ceba786abb30141a000a0f6b2489c7a0f7cc946b5e9cd48540fd810b20778d6d40946377ac346979a08072be317e0f2e84a49412cd95184b8f95a0a4f54667eaa444c3a44fd1421998413b2788c8defee5c2a07bd5f5dcaf6c0f1b42a7f98de1c8ee4efdf34020c98b4cd8a5a26b7cba5a2ba01e8cefa734eb12c1f5e20db4fa005c4e18a69643fb322c7d7dc1591dae5b4feb1d06bd94eceee84f1516d0a54a439f760abacce361a955fbfc8b4254e5c27df27bc9f482d75b01766e3f2027fdba4a228c868a49a1ef153a4ead704fa3b704b002965ad6eb9cc2edc315ba9682b749ee40e2961c23042be25f79fa2e918609fc3d1f881c61ee917c131f0d6792e9ad255fc34dd7dc15cef74f1d30c240d1b5dd5c672acb7cba8d879079820d7f143b68ed457bc3cd97a6d1d83f048ec1daf78d86e059af37c18f7a7511cdf0c78a60a9cfc71519350a2d31f568f76caddf24e3603ebd271bec8c7c2e7713507f9445ed56b2f1f8587d855b5e32d34ff0c6e39a1c7a1793e66c6b052f771fe4d8e0773d400f369a3ae4bfb4debb5d3105a41e93253be13f94372c24efe40397dd589b9816aaa515c833de1394cbad76807130869bbbe9fdd21ed8626e5369b730102ee01ebaf5e89ad822d0c090b8bb73ab09aa01071a08fa155fbbbee259d5924099a60c4587de6207c5f71881aa3f8e4c8ac8fb995dc55b41a43234b0c6890d133ec1139d58300e72323be3e25e706ae5492000f75f507558710cd3677dbab14e8f43f971de2f64982848719fb89fde2872997a75adbda13578b7c80c5c6f48792b6bbdd76c70cf777cac1fc67c1f03f499e327c16afc96fe5911ae6e775de55aac7eebaa6fba457755398668e5a8b2b98d6fda725dcf9f51a57462c028ccb1e3f5cd3ccd3ff5e1f4d94e87627f14702ee6777580e0dd883164f7efa157993f41c812d7c324a2fc7c1486a0ffaa421fd043da3c33ea2703e1f1413cbe45cb511c76eab9a932fb8b9352e8f478d637b6abaddbc319b5152f74409d649c116db16e5370464205d48314f43b00fce40316e32a97ee8cc24a99ce6cd39338ba31313d906845a0fbe9c6bbd5815129956e234f273f0d2dca9772156efc0e945a416d191619f98612855a939ffcd074beb57c08b680b6731f69dac6fdfebf25e3cb048840a7681f29fc995af6a331c18cfdc5d103f40f7c4431f4050514aac59ba146a1b5a6f4d8e61f4d8fa34a54f7f82aabd33f72047fff4ae8465fdde5d44253af8f1baf14176b959bdbda4fea9445599b281a00d19754230d860d7efa05d96c169df45a9556245f34dd2dce469b57043492c3eecea4687af8b3d74449128d969004a4267ab443d89fedc7ffcfe2242ff9ab3e0a3751b20bec889faf5b1412b7c7a0687a0def72d0317f9dbe73c0686bff3dfdc63753988c72512cb1473bd6afe8d08541e20600e6264bba49399b6e869c0ea013bd09476f51b5369d98c75116e189da829061c446f622164bd4b3a7adeb1e5b9f8334e5efe0716841066ac81bcc1a294d822ac9d94d70258dc3d9faff9b1dab4b2a776ba1c305cd0184d1dcefc8945c5d3207684ec7e1d07ae4af0f41de93bc117f702ed35e7bb5bbc58e342529ec33af00f0551449eb541fae364e6fcc3b2c53aa4c751d90317ea388f83ed7ee45059786decc31c2379025279f115cd70694627c0068b66cf77f792d2b4f7f0308f20ce2baefacb0e46fae4467bea5716de818fe1b7937912a2cf0e130b4d3acdd9f40ef5f9dd83e4f79d2a2217b6ae5f3b5103b85711c027c3b04bb1de7a2f93d5020909b2239daa9b06df2c5d426bf9bf9bf3dcf2e8d9cfccdebb58ccb180401c53140ccf655a53dc3daa86ebe740ebd46ce22e428ccceda05711bac443ba3b309c1302abc62eb294b54a9c8a783b95ccd78fdc496145957622d018ee5cd3d583f8b855293fc5b0bd8d38398806fd2f96a3b2d25ef11cde8f91cf6c72c08068e0bf85e7b308b2dae182c731d2b96d89cf4fa290c4a47d963f82613081dfc7b770d3e2b3725267749f8459bc5d5b02f8b8103a19431e627715e25b710af901bce86cdf4e45b0040ad4370b25cbda6c532357a6fdadce56dcaaff7134916e8a4d7bfe00a05c6db6a23ec82158fec649d3955a364cc912b8926769922c5443194470b64c9767b5101dddb99d4775570789b93a87714f5fd0e88e82c0441da758815d454fbde754e5148469edbc2f0dc9a9288ed6556932b27ffe2afd3ab63ea30127a4f9052e371e212ef5da8a2e2f4111b61db732e87244bafdedb5262998f6af2d8f066010dbd892bc751022b505337e53bbd43af0541793c2aa1ab6ac0476d7faae918af900fb81f1802742f5661043baa96a63d4b1f2716a9e4693b564a0958fcef36a7fca557ad5996f3604c80f6e9482d761b7b3373147c5c0767c63b0b10ef40947e0178fee84e00fb2863ba86646ed2f328ef33577ca0f21726efeb171ff035d723598f1ef521f06f048c8abf66786dce6c15bbb31521e1725de4095537541a0a4c410b7c43968380352d66ad79c8bc68222cbb34b86c4c9705182071cd5584438c46d3f5bbdb8c14fde37f6291f2ca006454fb5f3de4d46f9564e3469ba72563c8c5ea67a4b84154fcdb326b040366fc91213c76e75a247d698eb643a5cb035f65db2e9c3d5d09a14908832030b5950a4f6fc33de172729208e887d3504b5e2308c7593e88664ae787671f2cfec0e814b457f2a6f0112e8aefb003ef4ba80c4b532fc59967493b7be0ba4392222b6f4c1b6be40faad75cdfacb084d1a007039451de42996d9c558dfdc3b058b83f08d4366ca2c4bf28ece857fc026a463cfacb86781fa2e6c107e2902c2680488db0300cb96b432b9903516c144280aea3b4eaea38f663bde76328d015f5150095db808056e89944a74690efdec4bed9644b05171680c90d0749a1e1e506072737d3a52d967677d2089006e8ff3c5659019a73a1214ed510932fb1435ff96e29dd10abcb956fb6e605f6575ab765d86888c0be1a1561afaedfd6671e22cecd27d46ea126c51cfdd6fc125cc6d8fcb4aeaea1123e9c2e3251f60e653212695639941d6fcf87604d3d94cbc954186b11ee0ddf979939d95520da92595a2500f92ecb949260e6658301f7eba670b584b03c1730cb8aeffd4e528df368c0292e6f42a59ba421b88d7019d52c4560d6264338554998ed75348f2ca4af58afe2d7c7b36e7a8bf1859787e70569a1baec89a5c86b9b5f5aa80f08be6049d6da62b73b2c85bf12df266ae69094f024417aaa4f33b148dbac11e8d13f0be199e173af4bf50b85c4ab088266a6402ce2959a8e4ec43a51685d6b67c112d8b2cf38cd0c5a87767c1d08daacb6bf1bebaa780d5440e7a92e201fe5417fd58b516c545bfce6ea0a2b960544a890b103567b236fc1f622ecf6291dbc43022ac034ddf2bf173d099f501bc974c818d14c233cb04dbbaf3a0558cc9413e544840b7325bbacfe0f73fc5177b4082d938da7cf22bee88d275aa1692192e1a959db9885af96028e15a1988481d66c93a05fe5a7bf998ddfbd992125d369e7756b5a316a87a1e644eb11fdd27fa0b717cf266c57897fb37f9badad441b668d14feea5c77f1a9bb9eb881b3df575855033d0f90f1e12b166cd4cd9a182748830916f07c7498b357a0f71558058e8d9d9784f60869b7611627329f84adb6de32b6d7f7519f7974b673971fd1d63e04d143e6c4c40319c30e6fd260d822d97c328be75b75a4ae21b857b90496a73afc8f6a59cd295a259983d763ca7f26b9679cfe65abc0c97764b26d91215bea980eabaf94309651755ccfd5964041e9a4df551dfa3727bb1c04c279a36f72f79d63a87b3edc719a79dd1efc9d576d66970ff8e4170694d776b89367031a4fbbe2fe3cd962bec902daa92334372b14d51c933d5bb52172e5b7775fae449fd3a95a67e924afaaf1871d854b2201ec251c6d55c33e3bd7a193f77da29a0d5f747bbe071abf1468f11f9fc82ab7271feba2427e002aa1244e68110879ce214e59663cc9766c24c15c47d8e63f9561517e350a62daa65179b721a4e52079aae2073f9692dd05afb33ee0c02662c1e8b91492732fe91213b6acf9595e8875d6455e7fc5c19fcb88df6d319859bff618c0e63dd61c10d39cc2d839ad790f53bea0f4737f004822db6f8cfb869baf0b918f77111bb64bcc9d2b81d9f452221f9e6cef75eb73b2e11aed9200982bb1536791c3d43ef43f994336fd65fdcba7e730559d5708b0716c6975806ebeccdddac5d1a0b00560986f2cfe963969e52d76c25e7af5a7a1fd94ee8075004edf01d9584c33db74c86f292a5978e22d52bc563bc19ab8e5f2ad3f0eceb7e18370b305ced06d312fab50144c8a62f2be21bcf0143523f5826ba26e672864b422315e3bf332b56fef3d054250a943d6309f91233c1e8dae142c20dc07fcc9afa191970c6243883d7fc222941ffaa3028dba91ae64b11f7444a3bfa25eae0a07190999a50dccfe66d6de4c60749a678a9e8bd3e17ab4e10d6ff40eb5d9e27378b00677aeabe534d6100fc441c23ac56a0ca808002d680a20782a50390006e5dd720af304d3bd8e82f35d8d415dbc8f65ebc8e1ec8ea3b516107a9c74471f32e9518dc191a6772bb0dfc529e4acfc8983af1870637732ae69238a13385c8de8e282cac94d8e06cb0e521d13b67fd8a1f9bb8dc2a92b0e73ad662e049ce3a1d861c0fbd197b9ae32a71106eca9e9c80c06e891209ae62b3f3e517549da5be87a91686e3ae569af537e93e7dbab69f25e0498ff4e41ef88ee45a2935c93e7101699ba4073e75c33721b0cee891dfd214d49d9642acd1684b39bf8b809622a6c1bd3c0ad04796369ddc6d5714af9e506879c38328812a4a3db34f3bf58091a10306a57051e8e1ba93b8cbe319207fba164bca6cd2d280e734119d8c9b636b8ac14c0e5bc450a06b19e002b4d1cab54a0173de0f5222d3d297f7c6d9c8028440376065eee309d9b7b92fae2790548a1ba1cf998ef411e9e748599fb4310429339e68a9e488b42a4264c84897a98545726b0aaded26a7003990e9bea07cdd4884da0fc7984c4937da2774ac280e5e81dac051187b80fd1897219b9869b3d94a149bc493bb8feb6c66f86f7c8eba62b09f4d9216953edbfa6249e2c412b3f35e1800de6c049b5957613f7370f438fadc3636cb7e24cab1d489818e18efb11bc064b8b319414520dffcdacf1e5ae894bd456fc842a8020e6dff50ebb0f6f85269709acd7a41189df3bf7dcd6cc370f88c9b5986f82b129308420f066b44a73131ac7607b43fc449b4ff94f5cc561185766e9bcf6fc104b70cf3d9435a3dd45a0701b9583bf3720569a7bfecfb7f6e1aefa9071c330b6adb2d4c0d6d825cc426cbf2bcd22ebb706ad2e1401e81743c50ccca036bf5edca6f7d71171ec626494d8330ff8f799ae48f37e43f93e0b1189f0dbeb0a739a5179bd1e5815d9fa01cbab2980cabaa5f6a08ae35d0eeaaf5a5424df44475fc8d7ec633c143903b58a4f17d25fa2d7faadf19731d90dca2fb03ce31239e12647682b03126612028dcd0b0fc378f89e96194e656b8cd42ba22951140b5a11ee82e8bbb0e9e07347884ed15cea3baed4d9ba09220be6c6cae61b4441c4656665b9d40d270c312b313776e80519422928bb62dbaf564fbe94ef772b5c78d18cc5cd2ab1a2deac18c6238217f744586b4f69a258d5cf1887b703edced42c56ee68900340559dffeff7a4883d4b394c2e09f9055007024ef900ec732cc1ce689888bdc06e1543b1412860689d341ba4ee60e4fca0846a2b83255eefba7c73b16ce741663f3941c562cb5713b78003c9a834af8a30077ec3f310b2bbe2b44b405eaba9c11ec91139b9ed608ca642930891cf049a84a9e6a1bd6a43f1529b7aede83b1dc3b78d250763046beda80b4a0d4c838753e19286d315cbb5c0ad2639c8b154dc5b4382f22f11f0e1f2397ff49e8f7f6d5ea690bd0c3d5a828e72a21feff24f0e58a2948233b577338a2602b793355ce153ab274cc316fbd2c0c3121ec206f418aff873375bf4f7fb763ba438e218c87e25babfbd3fb700d436f602878091453f7927a1ed838dda0f8b1fa4526754c4a623a33f4317de4887839bba77a88899a1f0256097c635e1658ee29dd802428ff80c2836b32dc0a44891f322fa7d3732a37f6c5fb6e5c46f87ac8013de10a4b23fa984cb8c83c302a2a4f06fd7d315df88ee497e7a1b9f6ba59f2ffab1ac4fa6db8d09fbb18788e2926b1cc12ad155ec24c63038ed9a5d629c4babc569eca838aa21475d02b146b6582377dd41849155ef8a6c0147219f4956dfe2738065d3e147b7d0776b6733f37133f7f4bd81cd0e0ce93c3ae3d72f6a593f1fc78e5cd9ba088349ef49638dbce635a4ee8fc8db67334a5326363535c7e9a152d99773cc287d9af1e78f7166321fd2442b4cd19d1c5643bfbfeaaddccb3d2f3d4b3405054f178ecc6ab28a5be661381da61c3185989a99008fd0121dafd51128792f24106cad69b62dc701ddbeb828a8fd4c074ec6bd16a5a644eba86c0e73a548b1b501ccd64f1b1760deb98644fb28b4ab6b9a6172f5101283800a6e3cab54c48ccafe976416259d50e28e6455d206be8bc0b938d0ab6f6f14fed3f2a2230c08a1f2cce3a065560e6af3d5f4d5c523b8192f67b4f7251ca8add91a5036476cfafa787ddde8837020c26239b0adeb06803e7aab2481a4d966d26f1d27be92abcdfd36a2f190052255750a86b539e8d19e5dabb9a3bb49370c9ca344d9d1d288017ff7623b86106230451a59830e8b011d95a19624a259495d5af344951367bcbc3592b079579e664155424259c496d6464e5c9a5a65e4bad62ea25e2581b475a8bc2178e1501be5a85832aa0da8b227d03ff3ce4eca077477739e045f8cd216a8ce72f22b3ad1c7d185bd16abacb7cba3b8b255ba810b01e7f5e72cc4858c63b98a9dd82bb2d9ae32c51dbad8ec7e84ee981445460dad9249cf847d49df942983c72b9e2c895bf3dda6930108d8c43df08a494ebb5af2362127b1d23d6cdc96ec4e8b8df08208350b43f802eccefa5a6142cbccc5846e21d23da7b9cef464401829db0a9c5fd30aba9bed7600840de9c26fda69951919cd3e558cf2989512409106868bc395fc2be1b09b1ea7c3b8fe96eb3507381ab5ff30dbcdd48847cb0102e64784c4f751c3a7540508df98dd1937d751b3fccaf2af8b92a24cf376da59c0619090c3036113114306d52395767e08149e4278e843edaeb85974cb37ef3498bb57da50dba295fce364c2b1bd69458c4f181108cd7155214a851efb93648a2f0205bbc363cdb77f4e2c5b08847bb0cdd8a50d7dadc26b5764f18544b9091a0b226e6edc194666a297393e788fd52b91a6d93957194d90808f811d8a0dd7ad0e9994d5dc6eba1cf880c8933c4b2a3d51ce893fb1cda59c5b661a824be74253b8b906c53a0d7573796e350e257cb53f7512d1480f7fd388bcab2a084f5427473142f498f48acaba504800cbcbde40d86ef1a9bc6ba1129686838bbb1a59577b6f644686cee5acd7c4106fe1070e10c40644799d8c5919399d8f369f69cd5f7fcdf703f40058873bcfbb1f66c831c3eb159193b626df3690e2f9ab5ff64923511b094e68d984b2f50465088bc49606473dce97f9aa9fd9c770e8589fe4a6dc0aa5b7c03284ba88f37203291210e401117dd60c94a10e79b7cd6ef4d855ac24bb05930dc79994093abc161908677eb0282dffec243658ebf1c6b2aa40add6459a70b039684f3c19f4264f0e86aebdf4f227b9b24a942c6bfdb3d9130c8fde808d9c88701293980ebe661f0017ad3650ed5566fe65fe7ae23e3942d6ba3adb16762a10d6c95d20137ec0dcfa55f0242915303b7ba8b3a3e2ed0e07b02a6d656749cece1f012fc1e321d7d384f63e4221f84158adf374e9e14b1932af1c742c982eb21a7a1219e290e41de5f07ccb570c5f676fa689d9031c466d1c9587396e745d92a89d0fab4c0649cefdcfa2464a506fc2ee58fa76ba26793b21aab95db7bf1dd80aac0506e37eac54f6ef8431048099bed9e9a4fb6abec858e52b4b51cdc1a50cadf19bdb7e2c1855a234d8ccf3b010c318a382a9db72fcc4f66df32d5239d57aef89e78311202a311b32c1499b4a8862d3d87b587b65d8f13c187e64d2cf1b30ae3d758f4a4eeb747b4bf90ffe79367ded173ad1d17e8c57f422bc35c4df649c2e74c44e8cc0b01abb184d7e5da85f62105e651a464703ae3625335427aa03a8cbadb30a82910cb84256f23e84e3e363970a084594be36ea7f79754294448c008fefc094f3fccd9b0cf602febc9b060e1c5b16767d7a96b0b416ddc0082141260886ee4f67a956ab67a44aafa0acb975c7af4b7cf0129d0a5622713b6289f9d35d455b3462b714510aa7e0435b94a789770f9c38c604a2e0b1fbcc0816e004ffa60523bd4e7a4d1a00a42b8ae8076859cf7c762f3328c2b8c4217a6e77e08bd7f8b89759797feb311f5a243e8fa0ad23473e8d3cf1263e8402e15a52edcea599da66108d17c9302a57d109c9b66aa29d21e083711d0a94f83b9c5861717beba3f9e51880b592603005088f658c40e30e6f6056eeb910a095c777cdd124a2fd076e0efb3f1b963864f43004c82d624d4e72ba9da8f6462c0270889e1e9011f403bfeba042565c5e88257e720fd7644d6ffb9dfe63e8bd24b6868b7b3f694c58578cc85815bc93a8a34dcdb173ce8b38dcb1f39d635c2c33d82aa61459b0ad1abd312a533d99a4bdb29374e22547934963d7df13592704c020bf08d8484a12ae954f142249cdd6529c223dddeff395fca2d7e470ce965411ace39bf9f7fdc10c0e1104aeb92a1cad4cb18039a70aeda63a555198c01cd11f8ecdc0ffe77a1d95d7b76cefe3061d7911abe520ff96184e9dbd20d05cbddca4614125bf416690b3bdcdb4aea245a85e7dc2eebbb090f078edf76229b6f793affb9265fe49b951b92dcfc94f8d3a94d92b3f1c56d2f68af6e78434483ff6b837d710d0af3b48f0fbb54e92638fd10cb83631a84ef5da79a0e30f92a3a791d4ca2e00601222b51d2bb4b7bd612f25fd14a645b4158987683fd756808e914a6a2f37d2f01f6e514a8ca8d50c9fa14691858fa2731bc683d6bd9eb910ddbd1c32a53bf2427e095f8b8b7b47ea7163b5d91e58b7502146d91ccfcde123bb836cc5cff621f3ffa6a7378c4d212dc45d6017573c262494fe0003112fb0dd10291082f7afe31d92ef19823292f91deb392383cab27f290d275320e7938eab2047976208bbc86e97061dc953499dbb13af292f6c83a54e23d56f047a2f38a9bb24cf5e65d819df3d6bbf6ad9562311fc3c3127e29f5727ec04a509c828c12fdd2e0d517e28df2d3ac7d44867509170fd0940548bd7841b1d14efc7a8d0eda5aa80b1a33a50027c4d5fca75787f04c379554fc6aac8e2e73144fee95d90283005c054c0e2b1c4afdc63e4c9bc6b2335a2eaccf6590ee55f7d9233b09884b29e1398b7345dca3d7fea51d46ef3ce47ec972505960179fa0be8bbbba0f86bf56ca95ca8c2b8672f37515099112058e70a06f97fc4c413de22d4d47c1429e8621a648b5247983d018cd21366f9f0d93f79067b796d210d38978a42b6d9ba75ed767996a4aa56d07093303e7ae32dfcae14fde2bd847e0e9872af9562e611d9adeea24da9d19dae38789b63ceef20efa524bf748327dbd2f207e4f3c09c00f85fc9c3dd3ac248f6c2adbb312d7244736216ec34f58d06a0a9a07e8bd18157ba80c4434cca7955bddd408790c8e24bad3e277343b69582929c6038013fdb5b08a72095a2e198afacbf124347a5f5a0cca4920c7bf1cf7aa53d1ded9596be14a972e225b52d8a5af4132a447dcc5fc00993774991be0883e5cd5c99366b4e688cb2e590c39effc5b5dcddf75919d98625467385e04fe712be0fb85676ee75fd84491c48ee28368b2f838bcaff640d031a0262b898208210d91b2818140ac0024ad29b8df03810a6c1c0cfc07e46f4b61ab92083f3f26cdd0ea3c53e30b737982ac988f2f2a94083bfa25399bbabaaf4e452d5fe2fd16e68f3c77c72cac565948288f1ad13d5633e678ef7ca01b3e546122c0714bcd91e7b6f4a64696e2e71da9f24574c4dc81086512ad05749b70d1da226ef2e924c2aac42e366be1b717243bc5e5301d4b207cec9ebb2a9759f6c61bf8cd2b29a5be8788434568b9755a9128d51f12270f59d4790fa8dbb3ff1648a3650216c0d57a8e76728a2b073f9840e1614c6ca7c75d966ed910ff26410727e7a3ec5c8aab63b2eb0ca63509aac0c4c7c0f464b268f83627d13e65b89f80858351466e767374ddf9719174e3b9d10d6aec40897d531407e1930c80e686eff1a14fbab05e96c01151d0238a8606369e58ecef5be6cf9c85130af29909bbfd723acae0fc2bdbca86c2d85be0b4b1de5576a65b2d270c83ca096c6e4f3220ac60ff51f2e643c1e370b53aed9d13a7ecc6aa0b9fb022d3ec1bb409dc415e0ca65daea301c7e2f686aeba16f018f5caaffa98bf82cb862535e73e9cc50c6acbc72199fc610da7a0ce8d51ab615016eed6a5d65c91e752e9b75f0bae4617c828b3515a47371305e3c1e910749aaba17499b8f21ac7f1c2ff407bbad8b41548d22032a88599cd8e1cfa628e7e55d423ecbfbcd94de6548420fa0bd14f9a245ae55e082a649da7d32495e99c690b7075322d20bd7e74b8944ab7b62fa28528f2b57f4b40d3ae1303a55d208b916b5fbae328812a94a2102f4a03fc44d2a9f35004f63d8774ba8bc6a234b8d4526de396461715a22d39876554d37bd92fcefc826ede1609649576cd367cc2095d95b18099e02cc8ca31ffe9d86f227ad74ea84facde899cab4498be18be882655cfe646dfc5b53658276e17b982a9328c7f4173cecfed837bc51ba73953bec4878185c761ed0ce89cd6f7fb9f6400b33589fff4502c55ff813089aa5f5c363a107a3042622c679c737985727d196aab201da8838f38b2d55b76780cf928e12b95dc1a64a30b0bc12bc305210ba10e9cc0eb3519b58ded57f47d1fa013b894c2dcea912bf48d65ec8c1df1198ac40a65fc72ee23c0b0928621119f321ff45e0894d9b7363291cf92bc4e9b5379d911cf48a2e403b4e14a8b322dfc0bc7d209afdd3e2635f4274b053c33e19a46f05fb8e5f510641ba9db8c43f9511453002ad51582bab0824ffc5650a95edccc9da4995b6dde607a49eacd957dbc6031b4413b35b8640d9cd8fd68d1caad05b5d5dc821317aa47acd44b1df6caa96096e8413d349e62965c8d0435e36666e9a8273c836ab81e23ab3ef41871bb7176835fa4fbb79e39717b67947cef47b38b87a97dd44fc2af5a7c446d530124eb3ce2e00097be5d0c2dfd49bb8a1c8d6e8185075b32cd015707852f94b60b56b0dbc4643abd2204d8b0b6013fbe34bf90afe3067015861a5bf267a7a89cde4e5b4c5fa98237e801a4321ceac766807a62a9736eb38f6e22eecd2db2a33abeda50acd393e8569773091c29a7946eec39e2c52b55c49ed36fb10129fd42f7fbbf5575d38c339628bcc3484ba019e768c680370b8514fce19643dff2ce481e2b73b95dff5642126b073936ceb37d197dc12018e509815b9b0bc0f9c98827d46ff69570c062a6522f127f1e193de74ee096826a15d37934a3bb8faa8fc9a0943307f8b3c5668db0c43d77c3542b8eb8ba6b3bb85f01b177bc87cd00858b1a320bcf3a88ecdbcde6531756abf13790176fa1fd8d05e4d4dbf61e20d80064fae79df73e215bd87e5d9622aa988e75d5f455011b365f2ee41ef7e5e155dc5e94bbdf288a9033ad1c76adef3b7fff3e2c9587a42e506b601bf45b8cf92b80a52a537255121c8d25a0ab5abab43231ccf32066ada1e9fc7f19eb394d11e758726dee60cbbfb10bd8a6b48c66702ab5171032c3cc352497fd550d53a18dc86dc1f6098ae1ac9f97d0dcea11bca9120f00008c3e68e463800f6d4abae006f667f482c4771bfc743d8f5fb3800af98b788f999e5cb73301f9246e0c8e627b3ff6be86e480b849e047d4781bdd737a216827caeb0683a68d187496f797082f539438ee8241616c49ee2c611ee0856d3b617418306c1e4a44aa9c33d5faf77e52541480a9576e5fc1555da6d16a9a5407a9a67ac805e7eaf49a51910658abfa8a0efa7b423f498cf091c8ba47cf00da09d6a0e3b617b9c99af06bde4261b5f8f5707ad21b59342b293bb988a0c414b4c2252dca66c5074c50efa50d62db6e1570e07bfc5770d3838e46d26dfc1eff19f2c8e07d22a1cb5b0fab46b5f3fa02dab59cc89d79a529c49b02c6de74c10a786c91a3d56604bd07c97a683b46c50c0e919cc6c80ecddd43780772454fad4ec3bd80776f5fc26dade577edc406c6d6e71bfdd58adda672538ac5f0ea372eb0691351aa1cf465f35d0ea8464ecb458b645f333ac996848b03559acdfd9117084bd9e950ab3ad8f1403b4a1067059c02929aa518e852c05319d6a313ab0b0bfece70bd9853a403042335e62fe49e0eae1aaf360892f687abdbe6383be5a4ada756f27572ca9af2de77a443dce2b1edfb36ef8bc8271e4ddefe7a36d333e170bc0890cd92283d777313fd324550b5ea128a5c5b0dd53dca2070dfa2756ee2deb7f54946b4fa7154ad62df8270a34a22b395e1a9487ddd7779c7b0ca8ca53bafbb08c13b35118e3fc0d2a58b8f41e90241d0fb2dc80080b0f0514eaa40f277f3b383420409bd3eb4e7df6c154b8008804c02950d52dc52f09ad849e5b622ebc0b97429779427de2c7344c9eaf7dcf7320763c724c6b184c15d42d997771e3846690722714665ce785e0e7863924200b6ec8ff00f09773af8ec355bce4988096cc7bb90918f1f19a3dd989192fd8ea0d6977bc1e3862768e5ffca53c868f25c0f99df66c7cae5d1bb98e75b56f3b2c265a3726671ec61d0c8aa92b667515e36db764f93763aa4790fbc22f0883533893722fced3fe64594603aa3e9959cd2199e211b9415bfa1d8cd257bcfcdd3e090e6933354e58e541d2e473567356fa2d5d6750827b23e40af6e3f0f97facdb720766dcb25ab5e1bd9fab8f65abb97ae65bff561f06ae10a563a6b9089ab06c5410ee24d1fe70e3b2d1c31fb0f229fb24c9fddf06c01af7aebb9355a0e9b609a7130f7472a9e5958a26d81d648151a7d9f372b545bf7025a93600bbbcfdfd26ee597d4c120b75ad2fdfce8f992852d526aa566486ba934d49ee33ebd7963e896e2ed18aca3009a217fba943837fafe35d40098f0b4acdae4073775304abedf52736f0600c8891037140435d1f679a59b60fff7a6a748cfaa09c84dd4147845cd92598656f62ca788ce72ecbd3b6f3664dc0972524c76da8e9a6542d5805a28c5d8a83fa108b7d2cfb95e301598781792ca979d79bb465e2a66fb5c1531f2a85c2701573851cd71debda09e6ccce420f8b1e9cc41d0145d550cacdfad59e2c38d533a9fa1401023b604b4b511250630453038c03ccc78dfe587626447635298126dac999249a8413f11a5b065ed29da944ce37de650f8a45199304cb36552c0cad830701c3e8b660f563894e938f80cbe774a0c2d8504a6f12a4397f6e13538b7ef6316d70abe21948ec15a6c697d03af74044b91a6ec8db28a3","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
