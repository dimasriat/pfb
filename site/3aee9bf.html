<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91b79b17a4860254d4ca41abf42146946d2bf148740fc1c3d6b14c85a21ed2e441fe74c274c33298035d00489aa9567763003d2cf7bfab17d41d724261c98778db7fbdad1e31df50ca7dc953e1a8d29af81e49859679dc2dc9820132c04c9f118daa609b036bd0b250779af0cc53092b3aea7d7cd704a0914c6d1d99922e34bad384b992636183eb2fca30b514a95df48a0a52149bda20a731df7ba5b47f1d8eb43d63c6bf1807bc724cc793b0c8b2ec7895e90b7c5f11e2d02ba46bc756b610aa700916bbf6007db0c4e329f3ebecfd010be91bbe271473e87acdf41068709afbb010625fe05c17688ce8c5cbc16764c74dbf47cf0d8248138fc69b0ae2649825b25db901c7441fe91bcdd831ef0203baa340a21ed3ff78fdd7bc7feb361d04cb0e0f3e410284e6a6bc9a7c1e39e070fc7d1e7ae670c1f74d707e65062cbe1964c8a0ef122b6572a9427b1fc1c4681e96a828c3bc2fb92dbf62fb2e1a0347becda4fc752fbd8444458e67e5728e2481502f5b25025e4a3839a2801fa3e50ba7fe5f5ce9bac10055229c582687c928881ea3b6b72cd4eb2fe446dbc731a00b67fc268727b764218c047c488463abed2a9ce2e0f41e1f6d088587d1c9e29e4055b4f9788bce21243d7b7919c1d090ae589e6aa8bd11c7ba180aee4f90576139640c141bd2caef4036b865400453cfccd775464fb7d298b8dedb561ec38276ec9a5f5cec62c505606d70a1c0cb12afc0d782d7181c5135e278eb5b11bbc7579a883d9bca89531edf4f2597d86ef5b1881eba6ea33e8a26719b5618c1e09ad14c9f4cc7d9e8a4ad0f36cc621798046f1d65402a245e062fd96e715f0f04d5da591678fdf329f160f645fdba425e06a923a635490913071c21f6abb53fe3dddc9846d9fcdcd339e5e15b7a3483934a513a758a65e2e3f0aba4c95ef840f2966134c6f4b65587cdac42b3db34a1644018e3bb70e7ced5f69a10435f894c6907fe92a85818b26d597ba43cf703c5db242b1311aeed82653af20f3fd91f7aa042595c3af72eed1c80ab8ca636a5b800b30acff0e4472b14fdb77f3c336b9dd014cbc5361107f621ad4594a8267eccbffbc1b6f3174d94a2251dbf4687510350fe0175bec4f08c58e0761ae7ee08b08947a0c09fc855cb5386795a34c945dad30707387b50fbbacdd530289d508e24d3d742fe3bd69c0d613dfa7c5b3a70f06e439e5619f050e73783846aaa4d98475eff14733de8f795ed0bfb45d87d8c69a7fbf6a50d138f385c3c2505c88ba2a429675691a11dd318cf9843cc8c28b34c6d4e32a4b3290f5640c5716c3b8a2c15ccd2bdd3952f00a16eab21e1dc07a9459b179345c05389464bb5570370fbefa4b9a47c4d3956aabe063378dedf215f8f44abace26a4a439c19150df45a81519a66a0e27ef4f8c23d0c3b4192414646f6e5b2a06900ad4a80ce7173ed596b64966fbc4cd10c1161cb75a8352af3d5345a7e3a4ad64f43de200d102ab02b04d988c184b907c70fdb36e0bcd4f879c3dfd05271c419a6e90d87761ef3572c5dde498a4ff806392f55c554a005c51fb9e3f0865a5f2557c221859f2353e1fb0bea1ea2757c3a127098b08573ff1d3ca423d813ae4aa5f30eca0ee3225c1e1eadb64e976e58df73beb86c0f7df590b83931b7ea71c00744ae00de9c07b421d6f2e4877aaa62f8be6447bdfae469e3b31517d76a87d7f8883d080ed54ef507aaf82ae7ec5fc7f2422cd12741dc889099c5549108e46b9a5e8ceca4c6db99c4dd1ef61dc22d5ca7d57b79829a94b4e66410f1e962b2b5e169bdaf3fb97995076910d682c2b4f2fbda3dae87d6b6caa62e2b761ed2d210d9ca36b481307cef7330684df598472d2b6ba598de952e496809d8c69f64b634c4b9fa917c3b9ac3e75a793e3a21228e96bbb7799642136a1837cca07f54b11107622a8e623cbd135af45695ab3db14ffdeb6097f9cf8ba26b2b7120d81a587d0de03530ea494f18322ed4ec60db6331f754df39c067f1dc00ff5b9a26f6116489f461a411c056e766fbc028886832ce8a0442275066f190662f3ae15f13f380a93916d2c10e77c61cecfd3376a019f0c000f25b264a4ad73091e5c5821f5cf046dc0b3a9ef854f2f9e8fa0ea213b7473030abe470a96d0315e6ffaae0fb895f53d43b7b4abfe4f41ff13a40fc75c551861ac89db094f6ed877b44c2889a41fa636e242e3a096621a0184a81dfa75e46b41e15eac4ebdd95addd5384c2142771c02fc34a6869c3743b56fa50a4cda86125606074d61cef76fc1beb8eb9155f1a8f1c76b0c699893fd24d4342240791ccd0040257ee87b13760c829c5ced581562896c0f23d11804ed49d928c6e9cd4ceb1abcc4629c9fcd287b1978123e6a6231b57c642ec034f3d08f6590b0e7c5f6059c828ea573e5fb0a9180ce4e73a8dd59d6a9c84e6fcbba84dce6d8e267c3611c9df23d6e4545a755245ae2de75f606e89ed9d995517408f6947da4ae0bec6820675f2ad72d168d3a1c42b2ccd774da940eb93ef7bdb71e31adeac171083c4d2313345730f2f657c330bc46f1da20797ef802c8b504122597af520ab479824e7b5275be9ca242079af47b9d2989ced0d2adb2b62ce129140d8782ee8f631cb1e80edb432cd6fdbe3c5233f81934785de16069620f15f4126e06499c671b1989d009c3df71205ceae1f87ef8ba8bf93efbb38e0d5ef6da2e3713abb00def309c2f55fda6224a7d56ddfe6b9f6c15f3a7c701e89895f62288545499ea4f047b63cca77832b96a264e956206720b5cf5177765163d970a2c9d1330a826f9d9882bd8bb0c81d9ed7e34c24a8791ecf6d3ca094e4fc72a8d81f46f1f73b39914bc1f9b78c34912d4fe43114192b308c9fc9a8fac41247da2b15ea1e54427299e5ad228f76772f8b1fc87ed3e0cf427c81e65f46729244107fe56ab207546d6fdfaf20014dff1f481251a2da8f5622ca598b110818b3c40edb8435c3b6c19cacbe1de89687a5e2957d64aead96c3742e486e2354ce723090269da3c9a2c6c2fc2661aaf5c34337417c644c7b9df9da8a4b1fae7aba14b0ca3736b62527a9d678ef6116ea1cb5dcfe1d4d9eb67d73a23774086d2a096dfb06d6f76b8819d274b32cf2f8d62e0fc6f76fbae9b9743ed8c258f1da96d95f241d3b5aa1fe3945eec476fffb1e764f9dc366b32bbafb8ef72fa91396995a34fd2ea13373cd561f1f4ffea2df43cd666817fad8fb243089bd94d2ebad3a428f808440c2a42f85e8ecf4c94399eaf2cab495120bf31db0da5edb670ddb8d0c1f4c30bcaf273811da35191ad6dc0e2d86f22e959520b53f485277f6230a882cfa9de23f6f7fd7b5b1956d98ea672e49963893ce5a308a6290d5aabdd3b7d18a6f65ffdd86d4b02bfcf230ccd66d9fe4413dd19c3a87017c448bdaf9dc0f14175cb67f3f94a74f7a60fa0e4f98090b5a17392b9826283bd329b3d5289f233cb1815e110191b55bc601b4efbc5302a464eb4b9ed9b12ebe0530ccc0ecf167a15c8ec297e5b19a55a4a8f518c93f84f50927c8873b3c9d51b4163201d004e3389f174b07b0e329a657be7e948e9c4aeb2420afd71b34931fc4a5d3c827ff41fa218d3c0fd18db937a9b27ae45b992ca0a540daf44b84d5142084cba438e503b24eef8d76635f2c1d35c94e25c27999422bbae627235d72ea1e09233eae74e478666b322e12767c80a135d7162d71dc7f2d05043db969840b160c34b33c86231f19dd71a7fe3c85ab23a41a0cfaea316744268e0cef1d2eca7b81db022d26c50c5cba3f825c48abda8197077001e6f814d49889d167af2b8881ef1ad37b513b56761094240f2b6273e0c0b83cf67a189144148edcd36ca900c39022172939a5b91fed7462e70167372368dc7da76dd1aa00a17dc26a2de2d1679ca63df464f7baac7564d25c1565728426a9a0cf293a87713d38b0f47269facf9d367a068646a763efe5ca9f916d367bc56e3560579ae4cd3ea50ff354629b179f0d6d73d3d4a8788f9e336ee19709cf7b148da564a9a714782cdfe89c90109e1b8541a00c354e085dc4adab6c01b3c91b6866083b61d4f2052313cda9b1b5c20bc9b009426435eae38a6ad5681fe4e86180e0208af4fda3442baa133f451feb0b976a1a0c59ed79b62ce526f2907192ad0375a406d87997f2fa9746d8bd10b54dcaa2e28ef3140f980702b008f3df38c9757f0b4aae1debb7e18397dd0fd8f2ad8e9ccba743a6fa6ab231be05f8c90d2b9175a2e16f72b95f2712063bf2e544876fcd4c8a27f9880df72325e2b61625d31ba5135f1206147501228ad4a72fbdf9df4be585e6d134a154bb0177724078c8fcc45167176bfbe10abcdbd4715aca058064b6d5e75162c5d8d8d50a0d5330b1f0e53696fab50b627723c281016a0f3ed133ccbdf8a2e724edbf554811a5dfa3fa9dc41709f20c73780a4fedf80669d01f02c4643e660f557d52250a3f5955da34d7a45a9a7fad6112396aa219b1b01b94b20e13728857205c70e5f4f15926d30755fc2fa0975561ac420fcb0c0cebd556117eb3ba7ec8dbaafc5f889e520f6e3d7225aa2a828bb3ccb115152e8f24ba2af237f163c1fa2c00a7d96bccc351b5d8e87a519acedcc5fc229c262e0e9edd167d7d07ccfa226d2e119b7df572b415406a7a03cea651ee995723b6f786b128902c41f5d8aff173be90a7224763dd07b75b3dbc04a571decfec87be4f1b5b0cab21c3d13025780f10a84f3b212119841bb2fac07906446e37bca6cf57868b4079e141f77bbbe06229736249dd121b909d6af5c1c65470b82dab0fe51e3bd5e5cfb8361f28181301c88a5acc32591d7632e9deb48ca625c4706cbe5fc6df09392bf255964a471452e323169ee474736f6db405c5736c54720e187e65be88407654926fd45e38bd9eb497fc9532e546ac4d1ec6900a6e4bc37e04966f4944d83cda7a44170b05ad87920df91308ea5766aa28f276f10d0f8990ed861eed2649bbdba5d05bc622a9bc233b480c1897ca100c962fd0ea839d15be4ce57d4e413364bb452c3d1be0a908ee4b5121b5449e595485a7f86415390721c3bec79d69854f8ad4e4a40224e03df245ee5d4d928f3df7e3d242c20a841ee7322008daff7f8d7718de2a3dec365c08dfeb97ba3062cdec88297decb5bb419e3c662708fd80320e2aeea68e5749bbfe77d68eaecaf196e280fb8ab39a4be3015135be3b7ae7db518e1e97dd4f92bd2ee3f8c0ee4e30d622cadd0a1c25bd90ee9208797a6f0159f32eec2a537e251a884948b0e37463512cb63b934e1ee48ed6a3b52cf7d88f30aa1d579837b37ffd854a27397b971ebf8b72f0d2028118ca3876be27a041cbf647eb745a1ce2563a8ebdb6b98f97c813da699e712e56bace16a7111f9371e1baff6f2d0fbb1f089688c4cdf0bd11532e6e97c9317310e01f991e42ccc23ec61653febaff7451b7b3e02f0e1690dc5b135d6010489f3221989d41d6ee043b54193ecd797b130402193b21d0e77f6e8ba98bc38ab826336804e8f421403ac0a6aa4cd8f020b14748a9ff4abfcdd7c791f3dc64a7d0ea7b011bcb9ffe062fb191ede7b8f7e8525e7bd3d9df255371f9c8b57cb1b4d4b7c2253ee22b3d31d8076cb849eae39d37a43a7065524275f0ddd001cf7e8f6bcacbbd4bdb26ef2470952e8b131da5f2b2e07d88a807deac78bc40c4522167fe600278fb3c93fb12f37532149a2cbf3e6668e74c79c064dc131595fba6f505f009bfe5327f010cc23a7d5b5e95ee1bd927a1bb05b88b3e38c97937442140dd3a8aaa88123c54683d24f186557f8c5816d07d5f216eb2b47a4cac221f8396d7b29be117a86231a89bdfab773614b9460103465c1671c64513c06596dbaa6b635d43386cdd855c6775b702c297ac9805337fe49619a02ee9ab213555b15bb8620f1563cd75a38fd8b7c7449ed1082907f9b3836b894425cc730ce0c39a2b2b0de22750405ae3f2b8c5c1cf22b3469862d6140ffcd9fd6d9df4934ed608375ab23ba1635491439576c970187c3f60f1387180b3c7dcbbf1cf5d763a880750e379c52bd2b5697132e72430bd6d733a9cd5da8a256576ea1c2dd7a1661a51c707d4231762a1a29eda43bcd4723081418312c92e2e9fa23d0506953e1b86520664c644ec54594e9f3633cb62841dbc59f084eef24deb5ecef2e37196785d687e648efafce985fe225ac4075e2acf599be08535356c16d44ef011ae0f6096db83a569bcf647569c551780c2913092f8fa2dabcd66971da23adab7b11aaa13979924ab7b09f08a583c3af7bfa7192f2e704b8115e4a966137750f48d47131529555b2d8c3981df9029223ae8997097c7326742c46ba781c48bf3d480c10cf9c60a91d3db217e7955e846c4e2b68c74980a148fbe6b1aa976dda94ecc87611c68bfa0512f6583586f4bd2a28898da414c53a1d6e838c5bc50f7d8721c1d2691f63cb1462eb8b263173d88151cd938722f6f9e5bb24efd925a8a3f81850997c767826da78b0572b643feed97c4cefdfb4f9b7ec3a47a643b79aab00822cc71e25069a5e661d8e8f4442f210aaeb7da7f07b2e175b0bfcb5b10bdce70892e68761c2289afa2684fada2d82d22275fe5fdd53ad34994971cb5c1ce5a0210b0f027aff301a2b9c6ebea92b2deb251565b4323e27f6c0422a3df827f676b7259d040c4294914163a4c50129f8ca6a151ea7f799b87be9af91a60dca0f7062f560b7b176173b802d07e7b5351a115da47674d364da7f558b1842693bdc9c145be2c7e219b9e85af37ccebe0568901f3ccf013591fab59a3d72fcd4d8f3aa6ccb28b1ac7742cdb3a791e33e7d4f415052c13c6ed709e0757a72237bb0c1d9ebe39ece0c8f1a872b430a44c555e8e5e877897af648a8a849476dc9416c395259573fd759787bef516b82e9c976bdfa7cd0ad247db706814185ed1c55564fda07cfeb89681954d27798ba75d9a64bbf9b1b622eda26da9970f2de00bd11cada5fea35ab1045df9a0ad1115d6015017d5c67bf12014068009b2fc1007dc21d5111219df9004e6f64db7a3eb42d5e8c529a428d3452bf60873f5725aec53bc883df6f24087137260174b397ad23ae178b3e051a63cb62318f47d0b54e29099784d18a308345b33968eb35f1ea27370bc4c5a766ac3b99c4c477421ce59ef2498434cbf31668dfc07cd196a84fd520cfea6dbba774088e012ac52a284a8a70b262a95bf965a88e51426a41356283092f28373a1a1904d439f0ecd0fceb5ad243d4c9da4fc94adbdc5de523b6c081b41a1cbed1363ec96a119b100ab1d4ce3f07a1463cd339b6c8ae381d75e69b2de92c42df7a287ebecc90542bf80455d7576b150aaccc57dd540a2ce1d023f1c5d88e2740f4d4039eda4c224cbf157307a4904260e4bb42167226bce3e9c32976b0f18d74bf71d1e70bd772587040303f8affafc95b176a127f7581174ea832a44d584faf3a250f5b400b4c8e3938cdd633dbd72373e3693764c18269f7a6a1ca9d438d51c708725279b8caf4419adedb913632f6da27878ae1e2a2c3b2da6a76f6d06a5eb88308cebe7a8142f3fc51f3635a3ae469b8ff3ff3625478a5348122703a23735ed3a5dbdcb885420b6528ced8daeb7f340add5bdfe5869ad812b7694486dfaf3372567275f37f6b68dd105a8d5b89dc764d5c66a1f7698307fcabb2c692d2a21fe0bbfa619394f601077665f2748fdaae1e5ac1765e5a060edd83b9a1a31340f3c9e54558e6c0967c4e6e5598a5d8827c4820c995eba3d8c7b783a11aad85a1bd4112a334e4f6769d850f53166c0aa42f4d5ee069138e2f0f5cf68678e931cdb82133507de9ac796d97725526cb2490377c1adf381eb8834877da9f42e2e32e5efbf68b0fea42a0b5fed79538d8c3f4484e49e8b13367dc4b669baea37ddae91d58a7988a71d7db9056174f92f9b53e7e43e7772658e0a5f90550485e3b4228869663dbfe1b52aff9ce6544852972e4c66abe2447b1a3322ba266df73dd34edab4d64d2e33e99ccfc299c4112761a1b104e6ea496d1f3bb4b915907c5c60077a2c59e67b89e15699c523221ed1de7747e7cd09fea558dca32d1f08e930c9968e192b70af787f80fb452219b57776127062dc9eed6964c84f7b5fad454b20e636800cccd75c55739ba72bc99d60ab52ccfc52bf4c61846d53c660c7e6cfaa45447f742d4af85d0174618758a5d6aabc923f8c7027bcee5057c00f567e7e4a20c4c729724a9253902112c0e1dceab4065cead882644c964ab26d28886714f915905f0b3616b8ce7d18b4d8023064617d7c0f6c4ad40fac6a9a9fda66a1f541fb07bac0bbb2b7af119a0aad50953cb1848992ff722c3044b97b4250291016d3e3a82c1bf596c01cd927fd8a35e50be5971cdf03461ac67ec392cebfbf653876b6850cb540804c7cbca6f66538c57037fbff3810e22aa2ee9408dfbff1d458bdb45042629351841e6412d61bdfffac60ad24dbbb1799105b6b79eb0d5730f221c5d2f7c664e382c1122d00d222ce33eeb88fa6099a0690c190813aacc074c52a330bc2c5133f87507675bd54fae5cf1eab12bbb6c08da74b1b020a57c6a8181d9ccf585d9897d9e13b103d47678264bff3e86d170d9d4fc0c7226fdbde4cae34427734a9f81beb2ed77dab3e04ba707df67272d4e310e4ce20219ebaefb35e3fd9c21c445e3e3f6740d784333a40fd99225873200ba1466ac965f41c75ebdfb757ce003e48628ac85c594b8f69e6a4ad4937f5790631ea4c1c68a3dccc68cbaa3fc54d01612bde71b239c377bef16ee8096e621e4d3f9d64a478b954c8b77028eafd9b6c284e38a5985478fe9378a8cb951eff214e7d2dd31c0555727e7561ddf15774d53d316001a4d0a86196cc4850f9fe2157a06ae9ea8862e2acb27f04ba5e244e48d1e1e17ef8c0c0e0fad99b817a48336b78d542653f4e6a5ff25a9c65b69cb2ff176daf8157b9860fd833fa3c296a2f8ee8ee31eef19cabc7b4caa8dcfd36744acf90726890640a9028e17265937abe4a133b80e8e3d1954560a2174eb6834d12258218d7042451e9e3bf44cb97bd19652771e639b2c8ee38f81b256b5f07b53a5d33fce7fe4d765b7ae0aa2235d0738586d39941a93d3f5bf8928bb9cadded0370f4c19f5382bd7329611965e4c6c6efb60de0fde112b7e3abffca573ca7a86abccabfa1a0e0458153c6df403c49c64dcd98bf9ecbbb947934b7e90b1ff83363ee197e243b3942859a848b8885e24b4d0faf00dbd9655d67e9e71f320bf1fa53329b76e5692feba75ed77e30c52f8e84fa14ab4ac988523c08c05e53293a695429d305ada1b4dc7fd05b07f4fedc82b8345571e9ea1054e52c74b277dbfa60fbdf2ff13d932568d2e70e12c3a7ca96d66c6863933e22dc90b236aa7cad6b1c6ac4d12f237e57f11371cf40a59e75993f91a63c77a0be5b0ca2cec51397520b90a838f90eaf5c88226d01745e8e32a3968627858d2355e69c3ba0511ec9cf5d0a317236143eff7822d94c33fd95f2a72cb12424bb33bb983a22cf6e2fbd6f2ef0e9fe0e440e6b431d6411bea0274913be00985483df7b1b3157c35499698785b7cbdebdc63735015ca97d01a4842216afad84e005dc9c66e970b33f0228be9298ec8cc0879af68954bf7960ba7b70eeac4836b95a65b18504ec995d5ecbf2e95c0e60024b8e60c66217a2744ab50913032a2df54194c22a7b9fd5fdb45e4139d81ce3e6bb4540d4c6b8858fd87214f6b1c0fb51a67bb95aa25f22015bed53b5196ea563a45998aab5a1003c8c311ae7da81a1f43f596769db448a351c3ab9d4e618f67cb7d13950bbbc6915fa7299cdce4538228f7997a153e1cdd34be58b9e3e91fb43b9b25e6b8b1e5fc257c22dc903fc4167f7e1777e644a2dfc9a80c2fae055b5cdd0b10fb83290fbaa1494f46f462e6761168600d33a0e573d0b727045f087d2e460aa3dfe886073caeda761bafde95b9760eb78d17b150cb09820cdc4790b0f11a5eb2ef49bb0271f1d1e1a3ed6f966dd2f9a94cf1e19d7bfa6c8378e35f09e78ad9cd44fade4ea1601af6d5a3c157cc42f679b040d4335edb34bbebd59ec0fd66e0667efe9ba1fd415d2544d2b241c563944cae7acd1c89e9298a1e4ebf29deb7af9bef5e0b0d1e2a72beb0ebd6ab453f27bbcd0f50d77df39d464b5f9037a6f77844a1d5a047ffbba91413ec5aef604c5a3b8a9cc680e55a5d519d445609fcb29e0d3b426369007f5ebe2c644f50e7da4a8e17b8c7b1f21ccbf2bbcde6e37684d55cdb5286a770825736ac740c676c9e44b9ea4e171ae6819ba940ea35ffb9576774e06812d216d17737106c251c21a0d91014420f456fdfdcc97ae0cb43f673b9981864313528e91655bd1a6389595c02dea7a0802395b8e4ea28c46d298bfec22fc2310f964c006eca70e0900006358b3b3fa39871abb83e6ea635a91ea15607c3e594e59c66ab539e48309a1b236453a0ac33219167b25895bd9b31e4dbc94e0322be47f81725ab1f1058fab5bcd2a3a2e288e695613dc9ba151643fcf16042e6ef0897de36e602f8ae65d9c6097ec6a206d7a0659fd99cdd66af0ef7b3ddd78c3567df426ed3069437600d914888deb1e0a16bfdbb0d8ba6fd17fdb44a10172c622ca8d3251a492768d227f27dbbf47942c606bcdee03290a1ce234d10b7722ed889df12790d359f460d12307e0d9f33fa5dd5204d8e0121a7fe8e4fd4de5f222912249e2ad6d21026be92a68f24f72b5b35853b98f1fc852daa8a87043336089315805ee6cb377fc9b66009f1ae97210e552e270f636df332fe10a761fc02c849fb89d7c9feb011850d0cff526d76b76598745c88b092ca41fe6d3f99fc6d15c75966a58e65d07bb7afe14d8353522957070f533ad3551ece7d815afabfdfa227d6c60bfb105032359dd66f9dc8f73c2030749a97a002dd034b9e43627ffcf8afaf4722769b5a31d7490084efa63e21ff69d14c3b05b902df39b4a33d1e1e723d93fb071f6e5faadbafb30fd5bcaf9ba742feccc7b7ba1552c58fc2603ba62ab352b6bf18a6a33a9c0242c378e7067515fc1731687677ec986aa304e990bee7fcca65a6d6f42283968588c1676b45f633254a155327a81a605d3b16466d8a682b9febe3c2c47a3ca98eb6efc86175f815b51daf7a36356a4ecbda954f78ce26bf2b999182bd63ec22593d7401b443f9c5a19399c727120faf0a44d3091f9a7746201deeff633b50fe3eea6d72b680875bad778ade5564ec2caacf8f2cf798e93771ee12b4078d906463772e6e1a701e79b9eb58f357d2284fda59285f91366e056ca7ef58802f9550672afcad68c3984c6b97f6a77c76236cf69c9e58861d363a35036aeec3e33fdef900bd07cd00411e2be366517cec4933607ab46b6a364b670a148cce36e513ef14f0c88c6e7b5ee3889bf18a73da54fb44cda1a4f420464500c79b2efc6468002f2e066e10df1baea29f7052c2e396b56736b67a3777425f61dd8ff7895cedf1a6ece38ec83e3cf93b8332641e3e9bcc8262cdf7a09c194866ff859bf359750f70cdab18779836417ff439b7632d0d7bf475b6651423c0341931dc9a9913368d97bfc2ad9169db1456b076494b4c4843a840ca7bc647f70e687f4f945b002106bff3288b654dc4a36dfa4748a11deec8df148858b5192840b7c6d175862b31ed79074710533a8739194d39b7e1910029121c33957abe1c1bbbd7f4824f98a49843f4ad584f3f05897a06f375b79bc43da7f302206010d57a62639d2ecd7b645429ab1e6923e6a6572af46e67e4a18062105ae257398347668d77ce95aaa1fe6d96bbc0d6424759c40521b27eba4a4f10bc4e0a173cd98852e16161935b5d479c1bad66a3f67620cb38f7aa21940d742b814e32122a99ab179e8b847d882b38fe9957cf414de55acabc9e03b9e2c303f86a69746820f195e12fdac79aaf8170477e422bf026e920b4041f2de190df0482b3da96d4e91bbd29f72d5fc45bfe33b20501acd7dda4040c52748d1ff3ba2a0e51326afc84ae53afcefa4cf4c6ac21e8ed77ad2ee0f3423ee9cb94ff1fcdc936286e69ec447da6bb1200c1874d968351bf0653f42ecfd05ff12625917e08ee347459167cebded6dfa4cc7825d73250e81d37f6c785c4707356aeb8b45111c03d197f303edc2571531d08a5e40a608b7f6d75686fe5fa9cc3e230d344e783cfcec848164a5b0713595b4d755673aa32c74d9b20616fd949d7bdc94c9d3a2ee7bbe38a535846354c40b4896d1c5e64ff9a3e235c7c91cd04d985f23359d79d922dba7098cbd152f7c48478a52ab27c1cf1a532d59c2c68dd1f58ee53df651ad9a84dc799e6587c73d8058755329eaf41eac40dd58028b7b2b060ae07aa6a3afdd5b689eef493abe37f2f6f010a235b7adaa3c38dffb1d4855d694b0a88cef27503b63584b3cd537cfce9c480ed4f0d1e6aede33bba282d15ae23c070c53604ec55b34b25aa6ac98afb74f52ba887b2c23bbc7a05fd321d049834854abbdd0a58d61e4f9aa62c4530e754bcb617fa1c5a6dd1cbfacb13466ad41d973f7b89d186abcf0ae4d74d967a5949de756b415c3566d114877de3bdbf0b8705736b260f618a20450f38946e7d5197d792ae3b66175fa38c368642eaa0fd07e5485d74db130b5986386d26352039ba0b0ac2738479467dbce5370e048336fe19a9531e7baad2553f65508b3b7bece0afea6da52f5e3072f4864f65cd83c50ce133777f3f6bf932ae793fd89abcecf58d42f03f41918db96644f0a410cf43f9a9a8f3696252c3c0a9e7abba3030d1b3b9c255dd1602bc976d7aee94293c7c6c7306e41561d0d581843917ce082c45e4640ae6f48a5d789c8b10e81524ba98aac4baee565cb672d13dfbdc15bac9d2dc233fa8b93ddef256961a0f8efbff326e385cb06202b06e3070e21efbffe7f7b09726a315241425c49581ecad8f202ed9b934113f95d4840ed7f1485b9be62c1fc322b673a5f6a7c475029033f39fdffacf761fc303fe754bbb7b0f9cf5b09e175cf133b2cc475b0aa49466667e5fc73c6370e2f2d645bcb1ea07066adc1a1567606e54abb6a1fec3bb763bdd4af189aa7ed89fd8839d091a615ea0247a643389db360e86b4d5bd7733777b1c876bba7da22594f7342f4b49e4090a176e9968a4750dcff74283674437360f5e7425135fa82b7dfbb49ed10591066e1996b170e0c410ceb9e56c34d60c584008fca86a34949d908ef0cb3b9a2a805379731eccafded5030c9d23f63029dd012a08341edad2bed3d21a1a7b951e8a046195da7b1f7267d82fad30529a19287e3c8a54831e32b48758e794d24d93fe241b6e81b650b962295fb908b1e34120c3ac5c1cbe2a39e9a64b129eb54646aafdee90ef22627f27268c2f4eafa4b3e4b957d62687ee46e2563f2fea255408e601ae72e4d357ee636c8d8b915964f91e63266771015562b90efa5940c61adaa1456d32fe7293fe09bc64a13d313c4499cd4ef46558c1ef5d1274cf538683b394d3b334e5a039165582e396442581df44080ba241a611cf9d7dc265577860409a6db886c57cdd29bf1a36869226d37c414c8258d15d9786f20e65db3b4761063938a8fc5073a0fac928d451312142fa9d339710b63f11037cb9e6bc2fa1098f8ab35d19b5cf3ffb3937ea9068b97db0a4444b33f480dc542921527492e718c3d1d84afe1092ee5cc5d2c3487933c48904ef73b140f4fdb5b4533d3fa160d2010abf8459c9e0e4e42573899dc62a092c11467383fece8e1e440aaf2d277c26d986770f9afdde396f6d19627df2cfde9f652a78eb91c89c4d11d5382d5563ce62f3072a8f1cf50512d5e9e44a9199626bbb79c0a1ff5117cc25b5a6ed8425dbb430818957f02ff35b4b0931b2ae861272244e55fc7d7823e15010fdeae9f37169223c16ea3a903476eb6b408dc5add35feb1577ccf5013b3cafffacaab57ddbb8be80fa7237e9b13dc28672b25cf005a04dc9c0b3fa4c14072ca59f9fb1dd086c6b842b805a08662014bc435196432c0c19fb7a946ad788185097adc1717ead95d44cf4fb7ccdf7f3a8e6c41ef475a0e1a5a1187220254727132b62fabaa7408075e1943ae871b80d216a8556ecce624d08f424f2fd0560ff49f26523c28db956e0c298dbe9f480a22935e2658fe27a5078526966609f3c0c764b240a59b85ec0db215660dc0dd8dcd895b969fc620a892bf8602acd020c41897dd31ba005a139fbb3eb8b1ae522e9c6b5b4978d09ed4eb8872e3ff89323ec2a9a8df6b98fa50f69c710d00ca23df149fd330069fec99e35d03521e91367491d370d60cb10303c908d2961e1555f52b2f236ba9c15be94d1381d007ed39970615c3af6d3efbb585e3c4b4f8803505eec96166f356e58de9d0f705840435481a8c834d99d753a72ad523ff1b98bbf7b35bf3215e1a771f4b4ebbeb230b8256781a4eb6a48d16c6d4492acc289150ba9836735b8808fc7900c740f9bfc96172b0c089146cead148073bfe17f3029436ea5d33f926425b532aacd9008279e618ab74adbfc7640a619f6ed6ad3d44c1c9155a7cbfdcb8d30cc651e38e73a6937ac25bf69e426494fea956d1c81a8b3f7d5a367236fe7507fca5acf3f5e1aaa56f32d45bf3b1f5986dce96420c2889e5ce309327fefa1410595de4e24288b0027e1028e9f23de4afc0b93f141ef4228a9409e0ee2db34120cf02b79fd1f832ee51a8e81e802f4b74c5d9cfda1e1a964be2d3e23a5562bc2c4408fdb7b5173303b1767bdf55620251f58035d2e51a5e180754bfd542afbd8b364b321a21571f755da39d644ed90695bc68d9e940e4edb5062d","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
