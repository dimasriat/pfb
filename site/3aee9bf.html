<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99ce4139f8b67950b94a4044bcac5f5cb577b648e81f5f1e3e8676bb9becb6bc76d869b8b3fdefc9083ebe44dd94b5c6f7c29905ca48c7ba26f6b7027e66136b3213abe854725caf582590d5e49e2fafcf19fa3662fbe4169c71278c391fdd04d47a1673e28c6f30948e74ba867e4e6b4ee419cc460cc7c3ad88b2aadd14103a31bbd0ce9fcceeffb7aa87424a089c4a28b9a9420ff4489b5da5779e7b24a3cf5d230a35e105f92a993343b326eacbc40a94fcdc0e5decc3094796398aa1f5715e86ac56b9edbea21c67c5cf2b1fb16628b83954e3048497580443cbef71dae31042b784f4d876b31910a61f4d38ee133ce82b6609497f99209d1263e243209dd347fb0b106e468e742838ca348014f28c433ed8d993b42c42bea41e0c65126dad5fe8cc02b9f67dc24029f2d444304f2166e524dca6b9cfe296f158adc88f3cd95095ffd278f625a7acffae7cb9f4f64b2756bcf7a54fcf0cd5ff7770d4d4bf13b1a98d93dc6e3bf90fcadaeb8888c0a9217ff70d754bf3627e157349d39b4deaa1d17e5d526c65049d0b0264a761cb1fb80405e911e614a7cba76be639dec926a915eb0c446d62f7fd2eeb01779dfdc2c38797f0d76775c361a18893e7cfef844b661ad13db1b8e407988a6c482639564e8d0e56b14d191e5c91b24d618a5f04b31f86a95be3d7ffeeae493c77e65c8e7276e105bc2f3f2c55f419cca66a76d4c8d87341ac7626f61f5cacd3e8be44b1361ff7fbfc75a4fc5de05a81e535eb2ab5a7093679da4b4a7a2d3864320c075582344ddbf52373f1941894c0c6da8c1629fd4fee139f59ebb6b5866e0d407b83439c44b50cd3f6d7965ceeb0f773ff25cd2cba914f42bc9c0ff87b55129c7398213e9a1b0c004b72111d512544b1bc1e38694e4e29cb128231688216ebbaeb145a1590626b3da88ef21a01ced7135a26199e5f9022cc58428dc7c618e0803b8b592880a047738450eb642cb5dc5643dd45d9256412da479bbb513532adb4ff5b5693782f448b3ac3efa2c494aea9332301a239b70815291dc1113ce11e9bb4d034d10f42214a661f959df80113d6aef6f2e188c2e2a49c9b0e8e46d207ebd517e4088c7493405a63b578bdc66138a93ce12f9f68c1249ed58dcf87f91026c33650ef41f8b66df01390b70fab035eed824bd18e0422ac5b15abd73a27856cef3b6030f648dae13336473b65e37e8fb1875381ebf09d62dd4f90379e476e70bcdcafedb502789632517928f851ee05b9613457491e3d627e8e1680237dc2f640c481b0c83bebe7af1050632f7f11c99f51876643b7b022abe9a75618c98b88bb9f238b496e98e61b6f6412257393b7ed80d51968d5fd9661a8155ac52d529c8a439f6e387e8b839c560363bf71029ddcbaa228d1374e519a7af7726433fef54a25d2614e1f6c996bcd072c40dd2bed66c4004c3556bfe1356ac082c9aea8f1b61a6cb78fa54807e279836ad2c4ff4c0ac9710e2942d28a13e0972ffc856246feda14468a5acc2ca7e08dc86feb96d234aad8c15b2168af13240fb962e4ac55fc060f8040fde94c59f5c3f65cd1e8470ac4675c8941897bf665dc652dea5e7c25f6ead24e3a81da532e9ec1ef87272a23142580ad5177ce71e4a8d18109c3574790b98ca1be390d7c64ec16f5ef258599b6a9d9940ad2eb4d69f08ba9a820c5a69c4a7482d545b1713c0d2de577d159e8489c66a7bd3df43d71785df0df4fe82ffd9cb10cca992c042de0e76ae8b1c5054cd8079dd3f1fefeb04842ec13c1e03296b05c46db2a46c91334023ebeb6c8ad7db1ba2fef946ebba9d48f092e5a0fb5572424e39f1cb97fe5f1572ca1afe0fec5b772229c39601310ed6ff81ae42cec2a7ca529dceb8974a0a173a419c77781c0b13eab3527d9bccc42618884a60ce9ccae685bdaf7dc04e56960d9b13716fbceeb3717b08ba4508ada4328f57be616d36c5b838f7dc1ec41ad9ae88ba3439327b7ab942571d804509204adcdbc04fff4f0bb5322d736ec4a0b4aa2a9e8a63902553e5c81e17e80444e3b9c3610c4371e47420a3c5aa8e7abad56e5482047483f2faa3942d695fc92029457e8447951040dca853ba3f7f75bf8d39cc48f15fbb2a72aa5f6ad58dea6c15a1108f465a44f72002e38cb217bd0959e4455cbe61d50e6375167f77fa2efb2cd3ffd434f6877cbe67eba1df127cab1309c61d850f9f0b1befd80ff67d01a4c8073e48c21d2ce951a1ed726c7096f8aabbb62d50accf57d35a32a2616f9de2959536c75b23a49741186b65c9b44c1668bd0b0fe24d796f927514e6a289dead4d8daaa223539f138613eb5d028fe4ebf15ab8c976ed8dc8806a8575485970146b7f5a1057c6c958736cc25d8676f0da520c21092c9c3127e207dba91ca4c8afbdbb848d9591981c50f2557884a15a1ac33384dc240853499d7e751f4a7e9cb812232bb05513001062cb3c5f2f2a632fef90cf5c23be38a76d37adad30a500d25bcda629a0b21910bd0b9b488b5b4802b3b7354e2e62edc971c9b1619e7609b4a5ff59f118d4dc1ff232eebd0db1eef73471a5334eb8980f17bd52e83003404714307dbb407cdc5b0ba3ab99a908779ef9c221dc9b03f7bc62d5ffc61c637c9da83a57266a4557d690f56b86bf09abb6f0a9cbaa95754ffed71c3f9cd46e706483588779fc55564f8a2ec4ab36ef75152726058452025c626306d268eaae135848ae7fbd57c7738a4e81e4fcd96fa701e17d5e222180e2ec241810d4bef735edecaa5216f8d0643087d8d1ff7d017b915e3d2ac0a4f9cfa5a66ec081b7d4f34c34a1e92365b3cba74fe1d071dcd51af71456ce0e95d87546ac8dcdf974397ac1fc40464b866eec47ff799c3534a5d1b26c0f262df2f4337d2ba94260028a3bcd6e34d5b540b96789868283f05704668e51fa03f13c779c7fd484d34e45299541e0e5cc1f040863380af04aeccfabba8ca6515c92589b65490c5b2bf1895425f52650eccd0f58dc30a4590334a9f7595ac83ff2b73deaac4b8259aa08f217f95f537d01a8a46179eb5cc15c2fcdbdef75cfb45997969f026cc21070399be0ff78003400634fb6945ab2e90521b15b73182f6a8af1cf706f6e83527433070ff5401ca26d80ab308294b05c96ebf905114d528e994a2797a7d69b4caabb6a2754cccac6ce73b7a8605486c5161c54ccac1f55e4a0eac0f33082a2b63b1f0e09151657ea0c1d07a96eefbac8455f214f4d761f83c049d7e9a4cda3b9e91a74122b48cafe5889a1f6ffc5665539820725d8d1ab01f91d54f8010af593bc7572c74e37199b1990ae2e02103be3a84a42e3d11be27ce48219fba6c16d20b2b709fcda5de7e9cec471cfa622112e2e348e588c580009e4f195187454a3eb29a4dc3d391529b217d4a3d6c1156dd846df10dcedb4821b2e8effd4bde733a5b68235abd1812dbec27dd54bfe6b55f34d08a705915a3de3ee1e78f933767b57504cc41b991e7f1887ee20de3124671266b55f7a8f04715b1b9dd8bf0cdd80c9ea48859233c816b9c7bcb24334ae74b48b70667f1230a44fcd1bde18ad7785318b321d52154f7b0b4b5976e633c94c7a998ae39048506f29ab93083c9793d2043dcaafda0335183ceb2e3c14504c3bd76f4871332f5fb32461f06ead9a6cd5d7217faa96a757df9620f4afb0b25ca21a27288f0cf5161e78805b75ab07e8f1cb86d5deaa8267ab6c9e7842ce3f2cb6f870f34f7d317de58a36dc96951f1fd993574f71682bdd1dfc7a9e44a5b70ed26a28a5c53b511ab6a2fc2062820fefed0f131ea462d894bafc9598a150699eb65883a66dfab8f3ebd91b8ba2ac8372c4dea069ac8987a9a8dd7ff949c16ce9c7725bd2d5c53c813aaf0d14d10563dedf7c0c23c9d14c22550fa9a387bcef4aba206c28473740e905e88d8e961e82d0a470ab4be337948380e494cf3a24fc0aa48dccbd5ab18226e70223173a1ffc03c56d7eaafb6c6ce197cd70e2ebe7a981bda76795b5047f8542b04670ba96d34fb0e3b318b4db79447f58c58c8b71b29cb85cc7ba7d967ed8e89505d7c3f9a2636933fdf908c20f0d78b431fc7feee16a1ffc2dc851dd0d46cf16b2ccb7cd131d9f7522353b9f9d3c75b1014508bd9e4ee30a17014527595fe2cd35c05f666caad37662d88b3ac4b70026a02df5fc4a7186878287bb9a6992e37a783248b652c87a4ac194ac19ae966efcb44c8c35f3d45479f7720165314262fc16da39589054cce1f6d6e9f58dfb994ce9aa2c3204c35045a0c680507ff454b15141c159e480bf23e555b59db6b824505ce1d748d3eab024b232534b03faa0c3c09ad9735da93fa442e9ee723783ee88f4c208a1a70a9ae56b422805d1f6d1731d1227de609f4e33d73ec2093983982e404e3dc7b80302e191e8ce816adbd582bf4accf1178fe642de9bcf4b1f389ddba5842579fa979b30186dd2a53e3e3816fe31b794de3f454b7169b9f1f47506658ff944f4a5f6a93f803a85b4d125709ea772b8ed6edeb15da11e30e9ea257a799bfca64c02f4a55c9363e3d935ff5a43825ab2a038aae3d5d0c009058f627148b626fe04ad5056fc0f861ab7d8c320765e8d55784156f251922d0fa8eb25405305eb2f8eaad58af2a22bc2bf14a3bbc06bd8fbcd86ea4d109b82a7b6fb90e751575c37ec81ab9cbe52d813a853d076247bbe413b55192bdce79368a347cd64e0c1cbf1ebf4d27d2a307c4c15dcee5730c839701e9bdfa2ab198d9c5fd81bf7601d0f245942f63d9999da7371a02d60f4c7ffe67489fd9b7eeb1668dd3634eb004abed6f3ec382ba91f0edef47e29f4c98996ae1f2b0447ea0cb21c6a31f9dbaaed3beac295a4466bc1f551c0c089f0e52938d3d7c4950614bc824ec30dfa8a27a89be6b2cb744bade5d84e169057840d9345ffd97ccd8428cc94b2997eadca254b68b1fc393c0e64941c6defebd1cc7e13719357ff392e3c06035fdddb7f0ea5de6b10544a1f4305bd42688dff1848a08bf83526e0a8ba04f9f818b50656735e93e908535dcc9ed4c55dc8fcb6dd600ae4bfa47ff084e5bdc9e24ad0d829af648eba87736f03f5524313a12f16e02864533a6ecff4d9343e7d2c69c9d900957b3f02aaf4ecb26648a3f773d8ceb03fd0651b271d4c78cc0c37cc347f90bf6b3139461b4e0f05ad1afe102768a1958321b17a203a1c76f32b61f4441c0c2e2e225733a2f9c8d5ce553a59148b9954e5f35b99d547a7146e16f562c0c211db19514d9ec54425b76795168f3c98bcf63a42416fc1e3d5868d1a161b805702cf7c7e7aaeedc8efec07ea30496cedc1060baa33fd85606f1c8223e44200124e3ddfc840efd6f0ef131686fd9339e8c23c1d4d5cb68896cb3d92822b0271058b173a0963cf8604ec911876ad690f29eac2b5912bcca84c4ce9e019456d4b979edfb13a53a4c2ef5f3db3ea33f66823e50cec2f1eae45d372da71952bd7d32cca8ace41eb5fe52a3aa8f1a9b1f0b8d73286d389980710fa2d9b3b1c7166acaebd6a5499ac76ccebe5a417e69b8271cd6f3040680f4f54e04bafe75457e18f5a6531277b2807488b12230866901b62ada331bd23a99e0581e7c6d0b9adff3389ca925f810a02e41ccfffcdcc4feb7259d6610f49889ecefc343ef0dce987c134d6f88337260a9c306e2dfbe25dab3d5f9e3a5b5828b6bd3f2d37cc57491b4228cfa84eac37bdb0c346b523f72817bc36f50f9d8427903abf75f5598d629a79313467a799f687b95e44b2a19f5fe2c828c080c3b316e08352c917a5d81e21e1ca7ba66f9c4a459f6266a123de59e335ef4134a24dbce53a4af5f3bafec1ea2bb1de19773b599f6514bcf07f170f7133ea5b552cd8c1f1ef6d976cb4533d5e7bc7abb62bb1f5fe95e4b0f4c58afee6ff5bb32e7a53a9f1da07854ef9fed92c7baea7681126c0a6d5157e4810547c9395819cabb4c330517065c9b8e39a0352870052c3ec0024499b76d6a578095359ea8304b31e46f93b662c1e237779a07ace526349f21135012c3617141400926a6ab8a783845bc0e740ed7d9f9e9185d6ce488ee59948211c2479cb76af7c93bc39267f82562966ac8792bc46c00e981eab532f0f4163f533486436d361fe780efa3bce37071d75684ad953a19a80beccbddd854ef283be21bbb58b740f6766a10ec354534e763c89c211e45f25eceb043d7f64f8498ac93190a52b7bc977ad0bc783cf0ed2c5c99e480a7d6321cd0d89dbb0fd7a6f2c8c16469ea2c5a45f088e011a6f414fb5b0b9785b005c93e0fbdc75b42f8ebc5b0ec56e0ba33629f92d125ba0eb6ad596edb3ce7be9424ef5e9aaaf6b3bcea770234f66459c107d53c3af77d41541f43b7358007ae577e1e1464877ef31bd256e00035def4381515e9cc8c87a84f49ed80f9f43dda1047acf930570e693a0e2f3b0a57fd8853add6fea49c4cf9e8283056b077369d75d7f560795a2704dc1f0e1823bbbd095fe0befdbda9b04069b2ba1eff254660009fe314e811f7ca16f07ae6656b6c412fc1e82432ca5a64315b52adb4e91407c2f3049cbbea21bd263de7ef95a7eda2d9f5ebb2fb8d784d164af10dbff90d16a83018c49fa0702c58914f9e8d793f6ff71c54a52dff4c08732369948c4d89d5f7545af837c95132da7f2a4099702e2d5aaa0f6bbb1ebab2636133c3173fd6e5c94d88dc5ab49056f017b5d5c7eb96a3969fa45b783f43d13560029f278fb63be344fc6dde4f7897d1c019fdc9e9bfab1a77b22c775e820a064609a0fe30fb6f0f93ea7b3eb4c7c1ebe5c402a63c5f252baeb5fd728d23c4104ec29d445b69bda9c0e04b40c6271d331824d2cd4fcd27d611666172c459e55bf16f3d81be7140d96ba16253321128c6dc0f645e2b5e2187ac4314fd812016d5ffd75848cdacdb62124720e0409858ec01c93fcb9ed1d1d68572242b25fa646d70f84705a854d6bfe6781ca007df1291e4bdf8d261970e4022b8f67cb0e3f32121ecee03a978046526364c6f594198ae66b29c4d41bb84f7fc83f1671976242ebdcc81a52488e68e7ee2ae5c3ac32b53e4f0dc8e70f75fa8d614e27cbbdc558952e4d7db5504beb0904b108bbdbb6c3a21303e928bfa4fbeab43fb7bd47471c88715f8fe1593e767d0a52df6be8917a4d9955bf089e17f28503fa75d154594de796069824cbfa48c0772a468651f2eda3243e113459b5300c4aac5ff8876e512d47719ad725655a0564381e2b2a94300116fe37da5ca663e1aa0125e082b94e38633181c8937ad285449da738751eb49235dd2fbc910a3e7c01d7e0351090b6efdaa8e1374cf7fc044b442e7b4b33923b95ab4215fe66ad20695ec83d265a36afb554c17627d108b234bd1131822bef3f0f88854b8fc15398370e79529a1d9591a5ad84ec6ee9e99de526db3d743c22bc3812b84add34e83371e54090f62527a7d90da6670f72fd4c2a4d3c8bf57064db7efa46f7ad8f687d3272ed43b089efd4a067db37e37ea9f4b5561ea47c43da87752e0afc928364e496c60520ea697b3cd2751ccf5e94898b6556014c1b4012d551bb2b88e1c3cb8e0131dfe750c209d02470990f1cefee08c575efd272f19d0493d75d745690367ce2403499d1f6ead840cec9e04f8d59fd94a1a60a5c4ba54aa4d3ce2dadb13c13fe26fa151df87b928c1eaec6579ee8224b345d029763465a48d50073ae482e0ec14efa78541548b9545bdd43ea6e3e321ee7ec06c495057541b3f9c95eb7bd4a3bed70f48a84f144e900261c0768cdd2c40d4ee78ee0a21fae0a4ec14a014a6df54104a57bdfc6e386f1c1c4e16f581c92f3082a9079dc98b981266d2b23083fd1d14a5d96403557600b6bd5b64c8443488020f6fe672200c188eeced2900965d2a9945cd11254e8a049826cb7a544c676f3cd2e43d1df99dd647e4d99f60d4b96ef9e312b22c5bad1879d7d95e7f5cc02cc652b5293598f8aecf0867b157191870ae70f2d2d59c67e5f00c4a11beadd4576fc5be3c50ab0419c4765dabac76f4a018c096ed2451778e201a564391ba1ae7a3510b0e12a4cf8b24a5f520808aad2725bd0ce7dd6bf6971aac76e3fe452ffc9edf22563c9e23ed5f5eae048d81a685539e4178ed8743359990e0af500667d68a903382169a6df26445769c9d5695ad432c3ab988cf7ba1d275a46b618a19a56475283f683a040683cfb32d5824e9e773ad8e8ff368f6daaec8c5f2734be99e99f9f9312398a41d4db5e9cf8c633c3c4b67a1cef3428192d6494d261d748689d6c1074ae207a18327cc8781cc4a510c1aaf559581e116fc104a292288430f4482ee0ec65b7392f8e05b0c0ac62e09c58fac6f8c165097d3e07f4d40d2d0972fdf1a66ed8a8eebabb920ce34325a10f43c2cbc1424357e07a54997b5baefe2ecdafa1507435e92e01f74ba4df14519379f64fbf4df55bbf154ed68133fe953269c2475a7d6cab94e3f3e2870a09f9ac8273c4687c7fe23adba9a42bbd2a58ba57adfe113e650816e93d8c77dcdd5e9140c4dea6641dc52f031c2063f1f1a984d88269ab004cda9a2729db488fedb00430b4a2a7f186cf4a31d2ba70d79d0e0b0728a3c1fb83c84f439e3c2499d47b9c3e946efcccef2937035726177cb4fdd67735a991fd6934954358bc29fd3036525c7e0ab4c4271d90128686afefe7199075fb9382a4aefcae0bc07d2292c48fb4467dc233fa9ac74f61c15aa64bb1f129310e2e1205c42869433bed0126c67652864620d972d44ddfaf6dad36696e7d2abdd8fe040a32a3be984a4e3912b7212da4af612d169e07786a71e0b79883329928d704bd1d6fa4b92023dfcc97c00b8182168bfa0c3223e3968048668ef79bbe8d8893ac17595a4c617fef7dbae51473e5ffe001b30a0f02b7ad2c2bce1963ac86cb77ccbc7103a299cbd8a89f779f110ef1c71adeb2fa2da09763d9e4614eb2ccf1a6a8bbe57b81c43a683cd86a0c33080ca92fe457ac66942e5f3e762aeb632f24af8fe79bf9b49bd888dc4ebf7b17eab7b11048d67ab1325358b72345b7d500258d7633293e909463722c3ac26b78863a8f25e014e5a93f0dc481c28db6a90f88628593680192281a79f8fefc1a1ef21c127e0ed05fa42124fd0a9d034b44df9775050e1448598afd4e2fd2fb93e631375652f63350a570b0a2924a44a98e2bac07fea302ebca9a2cfb563b8e47ceeaeaa6c143c0e342e0310db3f5a3c48f4d6a0dabef2cad76d18f89182f916476b6d09f51d62c2beeacdd50586621b9d174abb5258c6845caf26c3ca40e31dd573dadac68c64462eee22038ded4dfb995643f28d9670387068d04068ab9743cc597c4657e62144aa09ce56257c4e43f32c62363ff95fb9f185511f3f8464b7e3431a554fafcec46be2fc1e941e249e25d1691eb2ac2da4ec07565cfdd880213319cc16ef95ce03943f67d2e5212b9ff22fd011fa143548db2b2d578beef678475c69a0f7c5a306f8866580e2003d3cb38632fd666a6ab4fa00809a1d7b943d144705f1a00dc6dbec69d40fa689a4678930f27cf21a4f03a2a4bd4ae5e6bd5ea019390a1ea27d7f702df8d6ca04e5ee0ad091b5adec17314b43bedb767f2f5d610b7793f33f09a9fd56ce083b860dce5d59d37c04cbbae51027bad50e75ae6b620ffd60fbde14218bb672b68e3a3f898e962a5f63a29060003d0ef6bc502f11e5946ddecb5bddd77f418a044b40f176882e4b35941c6b3e7b50a8b95d928ed0190982cb0eb50751e3f64d592a7b7c61f80b9f74b343480c28462fdd8ab4913b64677e13142eae714b37c2eaee6271e4eb94329e8f48824f564e8940dc59fb92c476e6fb848409ac8cfce02fba0e2ab762c2677dffa194a4f939619c24646dd041f07df6894bd7ba1cfbaee0c3fd3604e4c16b51c4eae355423dd3e81ae93d646bdc547ac3d104a90ce97a75cc1eb1c50c818e68116f488e29e0177e238a83a31b0eee46d4a402857ad18f5133c8672a8145584462e5e077855e1311d700efdac768cb75bca330f29d627cdf6247e389d6d4dcab0b0b4efe779f82424f7b03094a962e21314ac7936d0b9a2a10b4697e977d41e4df2650c84c4fdf0e59d6b76dd785e6eed84930f0d217be1ea59b7aaec3e40b5c013d6d15969048874260f8cc9f9b3084f0e08b256b0451ce5749bc2146249e02f3f88b3c3b8ecad10d555296df6898715e8b66093a96f1e88119d7164b881f4187aabbf627c0c2e411e0c7347bd533443ac86ebef72a327de634549a97ac433065afb2265c30e951df31f583c1683a0f2c1c485489f7d0ad5bc113906664216b2a68bf06a210e31a9258b7ec46eb5520f04656e136d3f2c22674836044a623cce8a8e36f860e8d65f481a367fbe52851f74de5fd8787790087de47310b225a09b246a2f81fbf3adb60b9f80fa54ffc93c2b99cdcb3d28f64ce76b847e964ed7cf3094d2a0a466fa1bbb4fb7d9b3d8d7a0735520b0ec7b7fefbfd5081b946056975fd747d5f7b9214205b95720bedb6b6061e8c18a721251cb82fce1674b34c137abe55024c660683ca6d80172ffd0a48cb8611d621e5149fa90211045e17dd58d4d4dfc9f9f3dfa24de1ce88be008c280bf8958f923d9c718ecb4819380882cb887e768f6854323f2c32a3aaa0e59a44e10a4c579308f62eb50557672adc2c98a04f4d900debb0945c9167fee9ddf05978ec786001e48a68bb52794c385e54dc05ac9ed53c092ff36aec9df6c1e8506475ee7b1d7e929819b83f9659b6824e22f304c97a1c622e62f92d2f52d3778b304ddaf23cfa319fc03a3ce7191df425985fea73fdcac661b2eb026d73697fe917c2c3190a0113e8bb9271b7cf900491a18a983688980f27316dbb5068449bb20ce5ad193beaa06167e82e6675c049546aa00c413d6e271f2a63461b185a6abd28a018d00759d43c8f2f3b951054a985cd1296cbf633635aeef3532aa49dd72163c344015d881ab4146ca7bf331d1ac02bc9427a9310c11451ad0d18ff858ead6ad3fbf85ba9256f00b9a2d0f1e301499b038bcd6081325ac6a11a0477acd42163baea5e32cb82d3a319f423676da095836fe091921e5eb2022f054a5b7402804e426df27c5f2d29baab6c51367dcd86bf5f6999761f6f7f7b1bf63194e1fa429bd2244599e8df0f2627e117ababfb0fc11764e3b3dc2e0e9c4164f6219bc95cace7a73555a3c4051199d39adc6c9506e301183c40c381f66127778e28320953f363d1bbf7723e4a81d180ace17847bd81dd0310af203608636ea3130b82bc3d4c00b039a37f87246224a6818a80c855968c2c619d80c92f65dfe17ae82fd27f3c8f18c95064f14a6836713660a0f75070b53489ae4f1a3d023ef3aa37348c3d352e82845c437aa953a56c8d440eef038dd7f36f2a7d323ba3db097c8664f39f7bb6dadfc648b80952fd5213b23aba136df13db9ae4e875c557bcae2c0d46aadac464f9aa2c2b2e71e3ef18d482624041a3991eb4c01e5277873d3026dfacd2212c3d7a8710bc71435ef06338136491f9d3588deaa45db7bf63c54ba2c7a35cb0fe06ff96abd07a7ec7f1135849f3a39c54c4f905309d075df3bfae556972d70ea7c0b41349507802ed1540e2edff9a9061e00c93494a0f72339a5ac57cfcfd16b79a82cc997807f6adc000775e9484b5195df4e3564fbdf0a45a261ce503e01a5b44a0063355dd30543ca9c4de1a13823c608c220cf199cbad17481f94ae3b6e06f689f31bc72444b632f9bbd1ce023aa9626f23afab8b189cf1389d2e0a6d32b991d52b7a5438c7d033c671941897249eb9247d5bfa0d8de91c5901b2d78b30d182f231487620603eed934b27bdeeff9c1cf01c573036c3669baaadebfb898a0e5d8f03bcb8235571d3705d262d14a3b155a1aef663b6e6ba907cbcfb35c668fe35b7688b3b66d5cec411a56cce2b3add3140050c761ad1ffff7113e16ab160f93d133655fdd95d688d103c98bf23a609e2367acadd8345a0434454dc582d53537e787cd1fab7cefd7fbcf300920d56dc56e34a8c90d0c26a5274d729211e67c745218a7e4c7668a16ca2f1a041de46fb74678147628d97c9346de9e2c0b06a9b1d630b09452db3a75c40f8eb0bfd3d15558fda67147be6d132757694112b9dd0ba98d4b673ddc0fb166ea3e727f7fda3382777557cfc2b8489cd2ec1e7a06ef49be90d70a5026eba969d11762059fec6371fb10c98c049be07bffe18e4370add3f2667eec01cf2659c7aaeb5fe321116cd94632077ddc598560a5f08b50836d2d465c4b4689cf3c2e5ceda7bb114d689a522a6a49fc8f4b1c9cde4e531cd9add9d4b91da8a04be66c53b7f4ca541c9bbb96b4cb856ece499f6da6d96286f8fef7192dea6641185c85587f6db5dab3af9dcd4a7268158e67b84c75539e0c23427e99b0bdcfd26ee2495be6c72611cf9e17ac1ef5fa7c1362327c4d26f51c63e46973e55123c2c2b3f8fe63a9291941bdce03f1dfbff714f0b6dc7b79d700d7107e7e595c4b1d2c2163112874c8c92c95ae0cb7ef1729968ec4f5c9f04952de1935e697918c54ae2f82d2fcdff78fb4d36d2995d3f4044afa538d41b1da1770c4b77c17fabc8125cd80391d837c0282d6bd2fc984aa24498865bff081000af30254c9df2e3f962a1d447a8ca1a5eb93de5c394d4db77e1695a5f9bd5163c213e75a53e1f12bedb92dff12945dedf7208e034e4e96f367bb0185de899eac10b1603690db60b8f2fd376e28b2160ab37a9b9980c4a42fe4e429b86023ca9f00da2160a20e7ec118e6f28771fb187408baac1a283fa985b1c0bc1aecd0457e9f54c078664500f906e3ef318eddd91a400a72a2123b4917e5f9c5cc06df9f1dae1c11df219dee9140b7b67f57875ebaa0e5ca085772a54fd965447adc84fd2bdf357a508a862549a52866c9c24820656717a0b22b20251f75a7736746b6740d5d6d325546f1a8fcf5d4b97f070fe8ef776b955a5389e3a15335800ce3f6cf8119ff2368cdab40194c988a5aa89792f8a7e639d9db950ab00f74a3b0e2e6aecf1fa1731f8eb2c29f75f546b07aa48e115913b89e8c9e6f28b0418583c88d9558a73b28d7b96e42858c21ed099eb74ab19d654f1286601598ab94fd152e12b139d26f696fcc03c1de6b07bfc9dd0fc3d683a4a23d8a5133fbd66ccee8ebbb91930dc6787a5f79734934540d5b39ddcd7fba2f343df8ce57b86d0786ca7876552148fcbe4e7ae8b46944c1daa1d97a046a6ed80f226df7c57f63d5d6cd4613d6d7d795cfd81bfd1a2c3381cce348c91034def306909e34af5b80db4217c7969013c832c67cf3b26ac45be77149eecbb4f721150646b1fab4ec1757217388b55f3daea757ea452a874b9d4a17f86c33760bacb075749a7e09d5460dab2762111219665ab820a010637f60863b0a6871eeec5ce0e433d1dbca18670da2c6a1cbe54f51e64705c6bbed7c2a42cdcb94fa16ff1e9e383baa8cf5a4a668f1e69570aa6bad188f7805acc164bbb7eb3519306f03a1672bd6e8d81dc416de1d07449b5f1f8c1917a2a655b333d1c3ed2fdd6bf8bbefdb1cea2ea7f74772a50b89fcf3ad5f8b53182385367433fe10e6d0a2607c2b6e07c79d4f750f32e38ca09459177aa38cc57037089f81898fd6c90e2254f6bffb466445be777799a85f0a5057dd109f37204ca92d41a17c600cd2ef0a2e52ecd60267d9c9abeeead3f5812304610c5d50fbcc2b6fa80a692468629af051bb575046f78d8591c7d5cd7d1e0154823762764da5b6559c4363a439e02ce6908fd728ea5f2808842ec4ad19904f0a8c7b9d6c50038c2c852f031b41e7ea0e85c17d037c21dc55fec893e890d2c39cbe5ccf84b746280f4b839cbbfa58038ccf80c9ae809ead252bbab444351245b660178c1378fc38d838b9b84c07683fe51e2b83c87b0b32b82fb257cadb74422381b43407fb2ecb24f892d89c873b153426ded81bee69487c480299dc060dc37e1e5fe2db30fbb2ca1a64350d58bf25e22e0e87b4766f9e3c77b55c888710a279707cb9f3b45b4d07dcc5170869e797f65af68cf8b7c2eb7e019805b996a29af83316e95f02eca684914199f4b4df28cfec641af4fa09283ddd4bb1fe4254e35f00e63776dc9f5507bb2dcd3abfc72bf725efc284e93bd1e8b3de9f5f0b076e92ba62884c6bd799abf602a298f56ca1920ef193c8a97d9b5fea2e51fd32dbecb91e00290a806ca8604c9ed0febe37ad482c0b8b1d21d025ec570875dedca89278ec4176b88dba297f52c2a4c9449347d926ee27267b630ea864314efbefb94ab32e4390a216fe24e723b8cb18e0cfc27362ff4eeff99479a57aea7a73a8da1069b9ff75467ca0812310d83fe5b44e795eed7cceeeb16b504018817fd3d033e5821c388fae80027095e5e72565e41a7c4c0281d08226c0846ae024fc94aacdb7d2554be3a4df25216cf2baaaeed78447b184891a0c93ca1349259728b667fa132b946a4b0049703511e4afb61fbf3de9f66fa5b13a91283063378c0aa83866c43e1086ebda0d771e357073eac3f0918dbde40e62da49ba7dcf04950fac02797b9efe2ab5f3028dcdbfc6975f218ac9873d70f169503f262206624250747538c14d69b9cccd02cd4ab402b37b909d63c6fb51f94061479eee9f7922fc8a30d1c8d2b4debe2c5f2f8f63553a39e9de9f52bd7691464893572fc969fba56c711c0776b15691f003353f4fd7a9dcf9a77c8560bcd779f5c162d56145eed893956a9fa0527417346c9a73856bfef00cb5c57c70c83b7aafc811058ddd4711a67d6a491f92d5cede113373df99d974fbf74a5a31b27794d05d0e4e421ca644be536429606792c6d3b925e5694ac5fcc73e7b87d161ae64317a48ba4e20c2ace93385331988c9266b2fe6632158da2256931e1aa0ba645fb1a1b2c29d68a70a4132d143874747f2ba5f24f13f10605d45d427cb3342e86840c321c24f4e810fcfc55d5a1be5b1d1349b2934e1af5c200277f4c40621374ca19eb612630b430bf6523f50ac7ead28171b3aa9d0cf1e853c3b12630a03d2481586b8f4669f512c2ad0691d6040609db73e56053862b3413b0e31cb15985b97f1105dffb71d1c245c19f696775cfcb828a3851b3cdd3a05f5aa59c54a4b501d3a2be0636d6d7102cdcbcd0b01c3b8ad06c5d2cd74f52001884bfa2864f3e83c052eca9ef5d6e2932ed1ec9fd362bc9567b171ac631f417204323e8c083f73499e236ea53561b6e5edc5de0a1921a326e1e0222843a4c7166e38c87bcfb6211e6e73f24fd3f037b2756781cfc9ff47df590aa3351b448a9f37bffd73056d7ed5edf207b7f8d3c3616b64298a370e6fd8395467746d3f422b31981c641670aacdaa40e52d646702ceeea52ffc1e1480087a0846412874532ba8b165ca670f72c676fca798d44e4000dcaa93b1d557ae3bba6202b4176330104bfb2a7e0cea2d302474bff99fa57247350bccb349c6938b29497659aa7b702d8b25cc29dbd2f274edfb12b4463311ddcf2f252e19cc24351775113050be3455541abbe8e549979bc07c42134bef11b0021bf93b11ef","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
