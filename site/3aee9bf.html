<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0c43f1fa588eedc9b9f004f77b579361f5b1cd4c31478b82725b98e3bfa836b6cb7b91b5e07488c77db83cb09611d6b8db627ac5b228cabe02f7c77a43c317887999ef4d797a58af6f82e0c311435ae7c06772f91929c6fbc2ceda9958e81ec7c3100d642aa4549b36d1bd7102b7cdf5b69ddf0962cead46ed64a683aadd147e1c55ed73b0cc5ead01265e2184d9941521f9bb02172f5fb5cfb07a078b7064e9fe6ab4928aec7117fe4935243f3b9178a59e9916b55b258254c3f5bb28f90906b82dbefcc6ad370d9cb58856b49c8c79fc883a246923b9001b1d344221ddb5543281e538009ffde885c9a4db2f0a738fb62c3ec4663004af327afcce4c6f2ba2c5e6ec2c759e6227dc4e3b65a9cef2f3ed97d9aeabee26db9bd829a42c43cfb7c9b2d28f743ee4d5a5a54f8dc27508d3353e8692949974fe39ec33ffb39a763bed963ea2b4fac67aa3ca07477bba5200eab8fc24d23155781d070be605594b320cd8030c83f07a1fd813325966eda6c0aef9c13070cf7cb7d7aa7c3fe036e0f8e08252be203fb1c14c29be2c3fc3c3c447823145c033c6aefd9d8a2d5e380963eed3bfb4dc7f1cea3002ab03b38b7d418fcb5e8f54457123b1dfb657edcbe383637f55de428a60e2bf6f10120352ffe367252a70c1b8aa268da617c0ea1ad283636ffaf456f12a68af12d0430faafdddd313e525df89ab5c193e77f41da7e9e4e5aca28d1f0c1c7736d84eff3b87ec84548bf9919c7f3ca3a14a0ec18840f888d45bf8d1b3e7608727bf31a4647e2c2514e8055ba0414eb91b8e2644709ab5645b3dfe3dca379355dbc7817bbf36127e7adc626115e103263bbed8008310ba96e7a8a19b926a6f3897b5cd869211902440a53fcffae0226f6e5f6ff90414ddeb352a1d1035287f57342d3f84f7471df2736926305744d20b365e9d29882d64a6415519f57dba256831ce79b894055c2f71b1c35d9d877804a8e5146de1847695b003733eba59529b8567f21fa5efe7dac287ca2d054d8c1d566ca3518d90900d4afdf6f763e28f08cf6efd50fd83cd2253f67fdf69dd6a3cd9772cf0d920bc285d040c442a7a579cf678408e299e59e87d0edc6f2fdf2275bb4a8ad778794944ce68ff89c59c762c7fe334ba7b05a779b8c22fc9a3b94bf2711c08236bd1b5a1f1a3bd7efc7b07608d09fc8ac917e64623f5b8f84bb34be3a7f755b677caa31b46364def118756de068d56b4e3c17c5b008f8c5a7714d8e5c6d2feffbe78caf80229fe69f24efa8197f52a714b595418355e34edb0997e29a9610a9127a4b4157b296a769598d86fee65d53e34926faa7e525eb9b2a8dc41da722c219b5e7728ba8b3cfb22b0296099658f298b726af50c37eb0c8f74f795118380f60e53570a9eef545afb48ff06a1cffba88305cb758c60598fad3272d27793330382db68b9ce6e602546ba94a185b9eb36728a4e3d7886efee96ebc7fcbcce0278a318d779803c373d21595d5ae77bbc95649b4d0ffe241ec5b7ade01223f6b9f0fedbd316d515246082e2f88cdb4f38fb82992c660183847de63ed654174a4097f801c5ffe458ba690c08fda460278a37d3e2d6cb768bdefd62722d4ac2e0238053461f8fde6d8042ffd54f2ab0293f4146c33c10437e0426988ef5b061ce4289035acf784e3cf71b0e28823ea81a171e131eee40ae6aeb8679ff63b6f57ae738196ff4fb176fd06c54bd8e39983beb59fcbc9f81aad1622b8a7f483138e0d465878714573e09dc4fbb6e48170be4f2ed21adc636f6a5fb0d24243f0777362493512cf4f5237b784fc6031d7eb410ffe182b23f72b49aa79e73139df7bd0044efbe05d985cf625c56f8ab3be03d05121d27d62f76b0e75e428cb63771f07bb713462fbccd707e2c72a1a64dd2f0ae8f6831ad9fe5a1d82791b1dffcb088ed57e8aa3f6fb62ed655078f0ba0bb214089f10a75a015e9d67e9694d87fb574bfd6f4dc8f2ca2e423e17da5b7ac004a3b3ad99df1515857bcaabb44f22684141e907d6763cb57d744c5fe9fcbaab2e9530f538b25b7379ed7fe7b57f48ec7452d31d5adbf587f686969c66728a16042d4b06e1a2d5b7b8355a6080ba2499805c4634c465ea25e3d78d371f2a65f675fc7d04b93d667eb63fd0a96ea8060adc1053537762559dc8c5cae37a16de40c57e74265d7b5baf81fe182024652dd431d6f456e744454226ac11ff1c814aa4e33534d77dea707aea845fbc92fb14f1175d405d43881209b4d36a0c9f1dcf2b4b15a8ea406a53526bb6da62dc507c13869bd9a32288e07c4f62cdb41613c8a9d5557a6945af46f48fb4681cee0317096adf404a138af12051390c0ae2467979e106cbc349e38a732fe3467c1cb81bab871493377d430976385c5b21858e5b9e69780e0aee19c51426f94148675f7067e4851bff0e5213c84fa93a48254b7d913be3b7076d7f48fc238c60e1b844993771ed18cac0ab277f62582bf0ff3513450e30bbbb694959a82d42b8ee596cfd6531de9246f80128036e7f1b53f7e9935244b6c67bec0640161520def73fdd048990d53b3f0f8d84c731a14dfd49aed0f178f74ef5d8e5a52bc1348c5da0883fb704eaaebb6004d15aa54e21a20b777987ae0d4d9ba03a9353b73fb9be3401329d073e8ab7952a852b73db9da8f9423a66875742e9312aaed99dc65a3297d996ca8ac69b9d0aa46040a9a9bcb13e2a589699608bc4b9cfc335013f284dd0b482dd6d7526b40b0a6c08685140269932e9162e50cb1cf1e8984da28139abe801b7181757ffbf748569eb5357278621394dd3b88d881d0fae68bade3b3642da2593424d4533046112dff07de2ac354ea159bc487985f2ea317448003b7eac264ac31ca767f80b3cc9ff5204da1a8dfee41d4b1964ae8e3a0b6023a37ded0f66fb2e195549881457842404abe71b2ce91d09e9ee1f4851b1fcdeba231d9a0ae8268866cf5e1470f7ed6099b565a8b7eb0ee938029f46ede14b1ce9fd075cd5aa9a73d1af5ea2eddae9d93c6179c0d4c073f56c9767f79e6b0a4e3b988a63eb16b2d7267514f926eb09a7fc1ae78a65cf5b0f23a5458f9668f4efb12e0d485561a0f388ad4a05100b4f1a90b94b8956ccf70e080df0de1f1fad927495c59bcc445fedcf95aba90cb4d87ef607471d276a63a71f1f5160226b5ecb1f7f9adcaa6bc91c035fe465a5f1a8bff86304abfba0deab1fbe165b13fcdcd253122e203d28322bf5b00d8dc8c77323f9ce2aa33afd95a45263c1bfbe5eb90c24cc1eaa4dad787fdff4917bcd8f356e1e6c2357a1ddef78e16e168a5ef4657963272d8330b92a4432cbb50a28707091a439d92091bb1c37eca1aee25500ba9db02006e3705a23b5bdbe5b25eff6e31eca84951716442e22ffded7497679ee0db50e374323892ba673a072d21ced07b50fda697be082ef765c09da3620b3ca18414309eefafe52e74ebcd03bf617f6422d45749cc85ce005b3a9655494e8a8a85feef8e909e9f277833006ecb1bfc338c9edd25f53cc01949afec2663d6e8e82a495f423d5d077cda04e7a26baec9303cb2eab64659075aad5ae16e05d8733d1cbe9e6e1ec00f292ac077fa61b03200a8f1d30d960858ef9212628e9bd83f1b4f0549800841c40c519303237ed86bba1a996aa0b261b799c139505e998b1eb3466fe5a5dc76db60d1eb04d3d5de1cb8a55f66608e8bec64d1b4139b7a3d5ecd18a92d14b62cf1750a27ce5633b1bbaa6a2cd1b8e40d8e71943ba57ef26e94446b7a9f31dac1d3f7e39eb197f44e35c7b21cc4d1aff1b91535b5ae68ce5003d1b733e1d26493fd292880fa1f278a127413e697747ef82a6264b6174073a582652ed26afbea2507f43909f7b033c3c4c359159f91c82b157b44fbfb8a49bbd19754b3a64e60740d4ffe2478424b0036891d3fd9cecdf866a332adf954a3ad8a52dd8220844fbdec094249ae15a1558bfc0c75f5e95cfab314826c6d47521cc464a504e9302e3f891b3abaa328275a547754a366e1f73ad2b4c85bdc3dfd864e014678726a536db023ce8d8c621e91798bceb71866d49a3cc9a270c78d8995512f7fb66aaa33a163d46771a084b17bfc107480d0be5e2fae391d63ee254a6b8db8a1ca40c9ee268636d4bb23d83bcfa441b20ab2cefeb7f0e34ea88e1c3112d8576d36948691cd4225252771b6111fcc78d79b8485b5fdfb405c7eb875b1346ed790419d4ed4a5c7f54a402090946acfd978d10bffd5ce430e3c2b5ac7f60960fbddfb98597a425c890cf1717880ff8ab83c53758bdedaab4f293e2db867cd332d1eb059e954f5f9cd1db20cff540a3a29012f85250be5ef634451d126690bce9cd2523b1e541f8e916755a6761c75ca55c0dcb9e4edbbe0afb87b38dd4808cf19bc9725d1e2fe5e0924e179cfbf8a65b1d6b162a0c70c6a7713053dbe0735e0a3ab7c26ae7ffbcf92097e9473d2906eacde206a6a8ed9e32a8b6221286d789bf40f18110c5605248b2709d5851e261da6fdad0da73d111e9204784b63490b85d4a685155d1885579c476a474fbb24c6d776687944d440b991118b7c324d0604f1f10899a5adf6b59101c29bb64b4998636cc0f240c52a5d54cd4e5574f86b989d39c720ee6ac96fe0d9c8d612b07912b84fe0fa811623a44e11f9d4a91a06872665b48311a21dd355587394ae14036e422dae890afaa126d0e3ab5b5ab382348363521b6e90de5bb8b04ecf0b57a766a06e7028eea6511bd14ca6dd45f150554758267bb836af4c1ad179fe070170f3d8751c1b2e3e1e9d6171a8b425042dcbdff51579749bf8ffe9a2b592f33f32bc3284df293f65277122f9bc578aca0727ea5f5428968ab303cd6a968483fcae7155fac25da9d5e20cb39d37e84010bc15b1405fc7ba8453df0f6d22cbb69d0ff7685b297b3ba29642e442e4f1410cc67413bad9efd1a406459cdbd434b4fc18e8b86b7ce270338b6b2ea0668a3f5e1464cc1662e43db5287d09c9d3af27f27b6f15cb37dc354a194058f55a3740eb9efcc2d4f539c71dfddbed8b47ee55a85d66bdf1bd62e26577c79df52cd548a7865a62e657b55296bb5122e5fb4346fa645664ddf39001ab1f132a7ee4363f7b9631e40b8fddb0d0f65325cfb375dd1c82c950eeec7e6ecb0413272090637f5fd44f0b2f5a06563bfc248b1261bdc74b7c3b73daadc8e929aa636ca1a6a9eb31a83e2ad7eb3de2c3701b488b8aa66d248720177bcecbe3346596ab9ee777f9a20fa2002513293c656c4dbee3e385ecdbf416a21d151c5cf42eaf159c7abb2a61a825218f170fe561ad195410ae29c7fda50d5709482a7883415fac79249a7d0d99adc6f93c1eaa4dbfc18c9495760a93467d15f932aec6130e17d7cd7fc708a0201f9a59466b1eb4a6455133c03bd3834f35339457795fc26614b30411510e7b45492a1024f8bea863d9983fe6234a0d0275734e5aa6205a384f3eb0c723b8dfbced3ff7d155f89a6397e8cf28c5e6d9f638141cb2a3dd2c1275d29ddac908f21d548167f22a4a8a8933934769f7f3079aebfc39c9675f614d1139977f152bfbb10ea99cfaa262bcf4082ba96ebd9575af2b578e4d544370565da3889659536346a3b592de05dec3b429b9f7d7139e77fccc00054cece06012e2aa8469970b2bdd5330262293a00d50f22879b4b9018d709501987de7d456aebc8d74b434cdcad4bfe17e60ded9281f243436b6a73f80f0df650f97cad6778a95bbb10118f0b1ee928d18708060e681f0f08d87afb1c2f8dcde2d7114a43679d1702f2854fc1a9f7a4ef5cc2df3ba34d3c8de20e30ee90e2e7251d2fb5f5499d968ed644faea163a3a52816b64abf83715bcc7669c7c8547d84bc8c433d9c3818585119c8db54e6b3c446d7775562877fb15e35f235e0592d7c6ee240d42406b77cdf1466920636ec77a6ca7b0e6f8f5595bceba11de89a7e5b11feb83ef98760b7282b97ee7158c28f7cd67aa15b6a6efd870a152dd894c834cc7bb7f8cb9dfdcd967d72b2b55e5f52d4158fb2bbc83a0f0e778033375b369de48d31e2ffc0491329ceae621c1df549d01a82b12c3fb69334cfecb9077d7babc866786496e414a53949cbbe94d0e9e2e3ac6542828149dacf9ee7158b118dd4804d790e1f432ee22d598012122de28018d9ae8879c9d82457ea9688aa2d7d7f69056af02401b13eff79208034993aa229b0caacaf10668415fbb62aab87a9840f6247f7a8f65b6644a4a6c87ccd0d9d848d3c3e28f7c4cd920f8b1faeb6f58a201c1a471b6bdf66b1c4506931165d985def8c2c91cb9e6ab8e98c7a2159b39f93ed62d37c742d966dcda0df76edd174f4f0917dc5c1ec3fe5f17c79abaa83a1294140fed7c57ec0fb4e1a7a7af31cda474247dc0dd9fdce4ca711cd67b5ace8fb7c289fa771f2236940cf5add08a95528ad88f4184eee6f91af62daf7d53ac91d415a45f39edad733673a854ff9aef7357535e7929669238a44a9bf5c9ea1fcbed8ca92aa0f797049cc5b17f23df6bb640737fcfc2e8955d2f6f74143ec4a64bd8aff055929a0b4377f70c0b30a80b2f80d51b9303a257432534a5ec51d08566cff6a3e706e74fd2592ba02c810b58efbee508df000701dea4ec0dedbd396142b7ea18d1e32bc294b4cb2b46e90608a71ed20af3df1c9aa1544e02f8d2df0f361fe0d64d3aecae3b35d1f931380a3b23726979bb92c4f79f492b0a5edf731e94665a629a2e7a04048920522f85c3a92ab69c2bb0fb6474afac1eab44e9f5b63fb61aac2b53e0cfb5b02d5b42d6ba4128b5e0435a1ad5fc20cacccb8039cf87c4b8cd53bfc0fccaac8960952bf81cbf3cceb27377115cba666582d55a61774ea31262d0368cd99487320fea2f52caaf420444fd6eaece8559084a0d45f50084e5529a092795e4655a95cd64d28ded38bfb8f1d5fdfbe01ee6627aeb327d44b5af53572965065593dddc984f56b5dcbca533947c05395917540a2f23b60908f40cfe1fd62ae2519d9f41bfe682ffc108b7ed71c7ced4ccaf25a17550abf2e05886a040d90027752c63e92ee10b4296150bbcbf0fca5b128078585fe6973403580ca5bf7869c7fbc7c6966519670d7cb59216edca513dff6d0f9063860da4186dc0ff58b2d2aedd17930f68060a17c5d3cd6c5916655861899e5e0311ba3c70a656ce31485878d4ec5d47a5097cf6706ced0b7c40cb2520b794d79dd21a0e0fe873a067a0571fa890db197b3dd904d7858639cd83d06a6d82b5c91871b21ea553ffd10cdd6ffe51293424804f29dd707682cb18e8fb5347ba385906f95152bd28119eed23a010830e202565129cd78bbacfec20a5aca49a7e07a24167f3d8c58489af5b942f319f862ced1d18b22020b7e97a7077b0b5f754d815a4897a10972c5acb704d0203d1c3d27f100525cf4d839a1b69de141ab6f4e80618256c42342236eae8090d973895db67a6a42ca536ee4b576c84ae1109970880d9d4815ab8d6ef3e46bc59677f0cee65ead86f6b1f456c4270a7b1daf8bdb4e8387ae21b4a32ac571bf8fad9fdc47f491c28355d1f3eaa155024d183a03d753d26f7e7fa683be826ff1151054a75e14943cd34d153cba3898419f089a77fff8aabf2effa67b17c82af64c60f932e4249d8d0c6f7e3fe52097a1385d88be307a53897fe4cfb8814e8aba1876d22735fdf5ff5908f077acdecedf5384d645174147fb6c1ceeb1e5febc93a58703006be414a03a9948196cbc1618fe1b9f80ad6bcd3ddfa5893ea22951349dcc681139319dbdaf4b0f29f2d16c3983b297a2800c389e4f6c0f25a51ed4c0d4555812500de2013728b48b7517831044ddd1aabb45bc8cdde26883909426cd9ca9fd8dad2095da00daa887e04e4bea4ec15ad3f11e5f40881495b21b5c094a4ffd7cca0875c86a1b7cee796fe0e1a6b53db85abc0732acd927d4260ef4be3b63f4bc81b7320cf62f0225f65c51f94c09d0dc5432d2890d33c14bd67006e527a187d98c740c7e8e2e1cced35717ff3877bb8f600f7a24c489654c3c8bdf6920653781380254aa0004eace6ad5db108cfb50f5393572f29a43f8e9b1f2c83a59ddadb8bb6217ba24281cf290f4d877fc1bd595e13b9461b981f7ada85c14b66ab5f39f373497a210553a3fa9d857eabd7bb97ddc8f3ed6562c5d586dfae7b9994a3ac84a586ab3698974ceac9ad698581136ac6b02b4aa545ec63ea3e149744a394719aea9fb0b4ff68c29cbec396065479d6a061f22b0fd79954ab3bf29fc0fb76594d3643def23e7ac1ca9543e50e54882e4db90bac84f006ced39595e1583533651b12bef2919643e9d01a4580c7d92458e3c209e6fe5572c543ab3685a38833d9c185f43ef6861c3a4422b206f05e6fa78bad11c686c9e041aa865c7d26abe38752f56549d6521e14cc475b5af42f6a49e718195f241e4e9f9f2074080665674173d08a31f3bc3e604807756f7ae8ae4c6c4937538139a8af3d3cc9b7ab2ea8481e3cf8cd0be046dac7d046b867b53413e3f238fbdf48299a91fd1c122b03c30bb946bea7054c66c66d09c217ae907ee790cdbb2d0feca7f40d51f11d3e3c3b5900feec1c6393f0e7c8cffeb4b8c9a1cfc619e6937c39e4e3b4b15b1d0232002c9ddac161a73aec49da0a4a5921e3e241f7367b9b82e9a8c7056c0ce425abd2d93fd86cc28b8b134f2b76e45a18af95015f92bdf750389a39ad304fc82efb4fedc83b460d94945c6da32701c6398003a18a6111c1e4e5921208fe685d4797a63d6b602801645b596d08687d86cce2a09f1dc7f5d5deb1af6aeefae54331ac603277bbd454c08c92981573a6dd0ee9da0c22c0995129e81aa0fb7a87131ea3c5da6ea3132ad43348b8c32dd37dc2b0cca031007ec192e09cbfa86b053109d4ab2f5b026f210a7119a2f895a09383b58dd9cf3630a25eee69606a70e510a8a444ea2b581d9f7388288c040834856ef3d854c4ce273e7c16c63953769b180b3373eb6ed724e31e73ebfb27a766ef473b8e5a5f79ff0f030f0c7cae3968afa66399ee405073e46385353e48f459de56b33466dd97a6961d895cb5e4a0b3bd1fba130dc720e82a076f73bd02b80f628ffb3367463ab305a81260ed9d13209d43a256f8132dd1d02666f388710b21f9755b02cf36165b7a148f4f311c1b519631bd461e2f4ade46ccf6b27b949a20814e19d1cc28598141a7c31b703ee5b5da90603f526228726444b3cc7af0f616a5a2b51cb1bb47537ffd5f0c664e1be44b2bf7419ea26a59b294a6959627a7d497244cdd957a6874814e124ae936b68df67ab3a674f2abb68c4a9e8d1c091b35afd4aa5dcfa72f3276ffeed69474900cddb9b7acf83a16af185ce9593ef689889eda6333a81b19f78cae294161ae1e6db7aa35a1d537d497c7fd7fc9c6057c540b6948cf3bc2a6a06a157f912fd449b30b2550e0b98c280263382de415c0f2335016348ce06a2b40ca524a71ec31bc29891c3c0df6b7f783c370ea879d4c9338d6335b395c68696c3e10324bbc98eb4dd79fef289a102f0a4bb513e6fe40eca68d72179bd4b2f9c06cd5ca3ba317781a11461e187c2706ba788ef971f67767ae7801a2aaf9ace30ff5f519e8303f9999fb3d19dad6cce471bed16003db4dc3b24266b69082094925ae9e0293c3ba6fd6c96790e51b51467a01171a9e3a8a341cb29a0adfcfffc1f8479b049e4102fef5db492b8cb056c5762aba51e8c8d88f0318d0449d8ec332f966e952e83741fbf2c6620987edfeef0780ec24e8902a442b98ca29c5012e600565ac0869c58a129eca415e1f103821e3fa33ba156e865868702489070a986225df9a7386262c2624a274b0501faec9bb4bae85f5e962139ea8f7c6760e6d24bc57219a25151ff4c1a45ed3781b9fe94b997967cbd1f129a805382d187eec80f3f310c3853d0747b2ea2367a05ae83438fd36261dc91a6c65652e3139634835325fc99362656b6ad6b6ac48427aa8c29f57cbd1044dea781cb146760932763e558ca35faf766b880442234b23a9e16b52cbbeac8a039b486018e6f536c0276cd5d0920bf0f027a39715f640c83ffc13171eee986740412360fbe57d4162c30f888cecd768e2dc50f958ae7d6723950061800bd3fbf759aa63f49fd42538bb24b28a2fe2c9958a9dd2521db82cff4cbe3ba42f75f06f21884d20b5cfe0c6af984596c20507eeff0050ae63a7c8cc3ca0e1ff9dd0ff3843f4594bb81ef1963c3c798d62a064b55b7f84ce60aed87b8c780967b5c63680a526a30ec6915eef741450dba86301d10196b265e03321a562e4a09f072db93113d056b7eec0bee78b1eb806fab77adac12f7da5b49bb1c3b8dde42cfda81b213a00563ec289c5768224336935ee486320641410daf00f6886932b6a9d98d43d42a51086548dfa8ab2316af68994d0d56d23e00cba492505f2825a55bd933d33c89dc9a596371bd7a21de2ff33d8b0a6253e81b09bc7ab5ac1c62015622296decb0bd82255dbf80ed799f7e852373492842b2628b194203f801d3bb3ac162581eb7607d4a52aa03fb37e5136b95a2f6f9dbc44e8d411ba8d1a306ba3d474d1a6c7bd67d5627eb1697a43acb4ba17b70e7e29ca6f0aa893097f6d67f9656699e6c6fe8ec902f4fba89726f4d128ee4c0acfddc927fdd19e750cd1daa1130274a97eb7b02511cd5b88d5e9be06bcd1cdcbbe2bff8f591325d741730873b5abcf99a7100164f8ac2b7f5c4cc1bc5a6a9f9d240e481f432fcbbab79763dafb3497e3b3b7eab668a7c232b72d3799f1b0232c24b46df0cb0e891a40177193de98fb0c27cd485f703b737d8150dda5ab0e3930298cb88dc8df5028bc717d9c0df57e5e5a45cee1f2ffb19e47955dfe074b95bcc082e1b6d4a36de26aecec53750a0179b3fb65cef574ae8326b148d17698d40532f42d0d8521239f7c491fb53e8f6db085c23d551f545451b3af0159ac3492d8b5aef4b3c969086c3041f98a93dee1928472d0ab72c74490f1cf92436fd469b1d66eb025d5a9a711bcfacf89ae5959eb483a2ad02dc84828ffedb3e674695cdc4642009e63eab1936f9f6f21ccc01ff7b73a2665d219896fa8fbc2c5e9a4519bb2cbabefada6f005fa4a20e3c9563ea039d051f8caac9107190a27e981f7dba24d5c57b7acc451d2dfc26498067605dafab766dd4ca4e9c3bc389e105bdccbcf7ba458759381686bc83b0dfce60c9f0d6af3d2071cd89fe22df2163d359df2fb0e60e2aa6f03d5e2a0f0bc84cc778e6981e41a4a85dba71e35f5ce5c2f3382485ceb7baa5affcb50d17d4a0bdf8305ca1f1bfe968504439cc3522878a0f073ab9336873b5b4afc4623eede9947f7404541f52334a480521d484e59fe03a5401803248a4b09f9a22bce70556a3bcbb2a63b42619dd8288fd8b6b555ecee0a5566bfd1153104cd2d500f73e8c99200ed8bc6b9c21278204e20cb6e317a3d3d4cb1891361cb09cf63f44930d885e5e7a9dee82c94c92c60f5640ce477399dad2968ac2915e0233008419064526d70660c5b8d4317794e39f66e7c2ed45c0351df05c0ac678da93c98468989eae72b653ab4bcb55e014b1c9822909514ef987b6a7d11321419b7d8610544fb0187cb3ee4d8ecb724246bc79ad0ff51baa427ff7f992c1823cb5beb75f2e7c357bbf1f70317b218bce1690c36873fa75a1052da719de80c1e70fb3fe67e891a1531d7134456029c464352a261e43f9d2d1b563a550a6aba89d6eaab13690068726eec595c3bdc5f1aeab51d5092d6e4a45688e1b63b66f640d8232c6e3d6ae3951e7075cf421d6b20d336908ff4c7ec4cc5cbfef164e119b4e680dc74ec392486c6ec998572a1b676dadfba32ef1f440ccad900d9fd9f39adaae378635aeaf4a11a2a8bf1a59f6e7cd4cf99719eb680e19587a149bdcbc2ddb8aa746f25cd662ff1d23e8fd1336adfc2f6c70875efe069eb689549e63a2daef5077ca1f964bebb80a2e5b8cb0ecea2b4e5f4f5176ecb660bccff7912d71be366c968f5f3a4dbf244f24603653a2c1eaab91b0c8aa748f1ff4531fea49426831690c8a4a6895162cbfb94882f6557f5ed1982794c011165347da12ab1c91ee7b1eeac1a8f0de3b05bdb38b787d4916ac846eeb3081e89b578c541ff67b17a20f7b7f26a76a03b59e4a80ca3d95180f50575a20a382b76e05c213703caf5690c0ac04dbb7fc7aee794375a422dc15a16558fcac47e294bc553242e8ad0040a7bb67aeb205e7a7430c951257386af72e7bae971f184b16694d8230be9115883b603d7fc543bd1175e0526551f6d6a9f4ca1f863c5e54dc05974f8d280391e5088f06f82f0fd4dc3c645488698c0dc2905c0d405bed2defa67649d4ad1f245824729f8796d3e571021f9a482edb576cf82f6416b85c2377e7582cb2d3b6ea431255193c55e9d696913ff46009d749fb1e17544510187b9773eb35f6f33e11382bfc7e322e9c8ebeb2fad59f267b09b848c24e357dc218793f68d5ea343de1b4f5b29659932e3eaef5e221f1856af797d86e9e0a014e2cce2641afaba7a13a314bcf423e597cba2977a640d61fb989f8387141a246a796501d3a5ff36845cea664e110ba838889496ab3825d92d7480c224b7e6c940f2ac372a6a8dfcec9807af27980f3265929b58fd2e43bf59d4ef8e451e6dac5228080156885018f43e5b51756e32f1e994cb6a18364e022a32cc6df8d6e994bdb96e3ebd9476651b3e5554ed8d6755db8eaa1a811066b68d68760e619f9465ef3324eb64eccfa4e26cbb2cf447117b3c02b9ef37f6da3123782cc13765e7f5fb6f87d03482efd4c645f2e1f40dd4192dfa559f4bea1b6a04f01032f063786d33d2faad684892b8703284f6de0b37a91734d0145f8b05fe04b93e167337327eafcc128f9cda6e69f873cdb16ac99b90d576e63c646cae9bec6b620d35488c8e904cedd36acc481199ab7cb5d9ff921543be89aa843322caca726dfc1903109a2fa47e3eea9affd7e7c03296288b926002fd08eac139880b4b6fad9c3ad830f9e63046293817cbaacd026aaf81cbed2cbb7d095dc561cd603f7fd8418097b787508d353fc94ca90684b8b6f16d6265344ba3ed557a45a82c047e84b4e79112b6258821ded1c1dd47edde0a50fa2c284321f712661ab9254b5c8ecfbad08fd94115c2b64345dd08b65928176b94d474ab86399409d1c1e81ed0f97be190ebe2aacc5b296e04356f5686386703716fdb3ccb0e9f14c2267630f522eb21689ba08be394469476b5aabab6e711b060e74b2a68dfc42b6352b484e73d5c5a97cf1a3c656f0932d90450169545a91a5e018e43203ba351f5b278511f82b329811304fcdfa52bb71f2c91a26ee9c5dcf71dae619baa08886c15b88e720bb29b7fb646d4b1167f3b0b31f426d8ef0c89ccdc9735d1477a1e8690801d1bb8d00380401bb559bb80f0e519c881d4a81846eff2fcdd940a0f813fdd5734a0d467a39425eaf94ea97a3c5df945fa97a0864ac2778167b89d5db6dc45de4059e9ae6b4de8b16d091d843a3cbf1084c910cfe3e4db1a3ff8cc3b27323bfe61f74f71fec9946cceb532e2604e7ffc23aa90100b0718b5258ca81f61063d1b327fca97ccc889be6d1e82b8ba5bc61aa8ecfbd20fc4750236eff093410fa73b0bea2c4cb062d610d71acba892cd2b3ca0095069598125e6b04bd6661849a20aff6237aa40a8b42229483540fa9918376dd5543bdb82307e1f8c085f4e317067becc08118a1d3ee9338c7f10a01d16b4198c1d3b4aee3b35f7d48f5ba104653a2258d00f606b5a4e0c7c98689a4722a1cf3db2f93aae5db085c656024d996ac344cc7510d2e0629f5f5ff7c95e3be58ade04782e06dc937c66dcd9a286555de8d2ace4c24a312eb67fd653705387c3a7232f96cf1b6a870e5635c1859e270de833bb20d42d328a50027fe956702396c5fa20cbd2153c11218a8e367a729a87989c51e414c24768aa3210ace3af0b4ec82d829cd0a7c3a2ca9ae385375b457859c7f135f4590e9729e155ae8c7cc05c3a58027f3fd3ca7bd1fb57bcdf4a68770b5eaab4335368867e5e4d86fbbc57b10e1ac982b13d08940d31e3800a33afba653af54cc36e56f01ba4009ccc46e35e78045ab0d8205d8dfbd4f2fe193c0041304dda1f0aeb7acb41040d410fdbb2842aa3ce8c9a89c648d1c59598e638aa19f2c9b09218045c4d4449c1015d8d793e9c16a19eb27e26ad88973438843d39af415b7596f8df8e4ef318812c1a7ad6a06f555f68ae2654f9fcac626e31100b22c36950ce0298313b32b50965ca5e5244a204cee3db13b9f3d90a8bd3c930241fc3b317038f7191b0675400e823b315c8d9c2670ba7be00bd41e7f1760e991f92f42a4c2b6058818310ddc7cf5522863f4c797bf865539d6eed044210bf42df35e90f3337341ce4c82dd6dc1eb598666ecbd48c071b1bd155d79c35fbe1a1564e8856ff2db2c31b39349b08b8ce14ab4e0a31b3eeaa60b81ae07bfd5f5d79667b535f2b15911e4ff9195eb6a22d442445b377fa75a0aa45eece97520fbace48eeb6822fc6c44e94a63bfacf177c01db897509132f5ac87788e65a07184174779d885caab259b8859c0ba66810aa051dc286a8ed210ba0ad3706fd08b76429eaa14e748df13f247fffb4ae1530fcb2b0fa2a520b783bfeb3b200afdc8b9e6dfc29cf261d007b5f3a661825263d8f29b5de3d9b5dff1a228dac83d14bd651a3b7072df2354b4eeaa8d69b55e3a69441ab2e4bbbb63f236f51ad34b399a4b342304037cdf7f8fa1c2da9310589b4fe4a68d9e626aa311263662811dcc75278e6e1972a7950f0769220cd3a6a208703445ed3d3998a77901ed555","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
