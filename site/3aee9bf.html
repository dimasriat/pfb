<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5bd6b6f07e5a368f751c47bf2875b2fe94ef196ce4a1814118a3fffcc3d9c49f572b0d2e20e5414ee33027337ce02bb11e27e8cc4e2621e4030f078068e1b2d82d20ca02ea7498c24a5a0f78edb028c56f92152ad25bc5b29fd55b8d6ed7fcc8395b89595f2d332b2f9a44a5ade64856983877b62ab32dd03fe3bac2b48b240679f365a877fca3d87cd69610ab1fad796a25cc9e73605fd915038f87e974bcec4d07f11cbf5a0888aeed2819b01478d6ec2ed21eae4bf5c922a8e321af1c44038cbab13c4aa31476176f62441fad15ce3e33927eacb44d07121b7506d74e9684d710c0292629872181963477efc26e2a9959c3da0c9225dfcbac0a1bcbd302324d77d4b0493af4b9ef179f5cf91b46813e1f0179f297b461de6ff76d2245e6b3d165f09d123745b5973c193bd39d7a30bb4eb6bcc9ab4ba5d2d99e0504c5577b9bfc52ec68eda44cc4005c7ac74c35ad9664788b1a14d2f7b6a866203b23060503fe3dff62954b82bb2866d1bbc9f19ceffeab6b58c4ee47afbd4ff11938e324a7060d0e3523baa750ae5fc28de222b3b898daeda0ae52186590fa20f00d03605bfc8c6cd2affcbcd5818e8bf2774248b3bf549691588673f828abdaf298b252af5e8a95073a5866ee5ac3cac73ab9fb981dc323ef496b15841d942f96da16fc3f1353d0c3fddd7db67e4008d5f21bd692ec36e7c77b26f4a3e729c120bd355e748494e327ccd8f4d1126c781d238cbcd44ea5bb0404dabf5b4af14f18aadeb9208a997826bdb92205f3be1d8b98362096f649226b2f478cea57ad869856e06b6284ec49c73b12e5cd6353755c7655867090ca55724650d51ad40a2838844864c80bd80a3431df5653c51091a1a1c3b4a3268cddf0906481c65716edf3a094df36c6c2a240f2884c5f685bd4eb00ab35c6c737c0180b8a0932f84a5f38d8b8362287afe34efe39ddf09250d8a93495e45472cd4faccd7827970501f8a4a78f9b243e7c14f0efe4f958da493fbe07f020ef7261d3c8c8e7dda281c4e8a1aa68ac3db7b2a5b10ae51ee14ec6d257d03e7b4014a314b201049010e711d05b2566aa3ac51c3145c5aa6f502231928e9df54e08a3390abbf1976440075875122776b53c6940c26f6503cb7fa3ac69f91f237a8f0ed07ae943799f8fc954de6466a0a08845be4329751b7ec88f4f8041235027d035f8a23002dfd7e76db40f762db44d1fde5dbedd95444c68f235edea8e6b801e9897cc5650388a542bc3bd1d21f7a3300395d642388cb901aa66aff208a6d5525f69fa49d23d00c87c974ed054fcb1c57d6f1f37ea5c153f06d8fe8d4940ddd167b1cceebd9c489ac64a7af36686c95e5460460288acbf16f819f26fd3f21a75584755137e3ee6c55582fd0495f471f5b80b04c1c71f369688b2e241ceb4295c4d1c52b1b1754ff9a637f9eafbd6393633ee7d1c574737d96a020b0fe61933182e9e431309bbfba05eb530ea96944974075fb2580c277f28ff3b00270ba2a37e4fd5a0be04971d7444ee1a7ffca0a99ed3e2e33bce9c9f11c34c9bb1d915e006eabb1f9a7c8cb229b97eb20232f59a8fc4340d84fc76993c9436cae6b4e3e1f5aeaa6162ba4fbe81a32760d1fdde03e88cab5d4752fece4b705bf46061acbbc3d397fc32ab21045373e038fc0e3f02822d1db8c71267421f1e29fccd1ad8ff9dda3bbc00018dde74d44df29437e2cd6958cefa0dd393fac5870f02dbc2e4a8ea82c1c0359434f84d570bafba8027bf1c794519f73a114469f9fa2e77a3bee9e1fbb916870c6bdab2053562e8cbe5716d3228c24221d09ba066d1b9eb3b77e839af6030790e1dd81a7fdfd97463c47c971224a07c6399bcce1eba96e8f957cb6ad9ac24ecf9d763f7d427b8eecd53769e4bfb99fd68e07c92e6f446c804dba8806c6929193663912098a1712e81b13c153527720c58107cae9e0b21ad45edb8f57980c59db7ec339572c1e109dd7e9cb224fcc24564477c1e0488d78b752134a89e925602519a58557cd206ec829786a0401a4358f4416f76a516a07ce9146f7709c658df73a75c2be6df826c78211d2f17ad1edd19a6a0c8300131551f3d96679607e88a4575bd9551d4e01faf5058c601f984607a5f9001f26880ca535f5eb837529041cf803a30366d18dc92c2f2d0ffd5d023c178545a111af674d444952ddcd1acb5ed95c7ab13b4ecc6234c41e5a067da825be923e43cf1818525cfad44012cab86bb8d301bab4941c40aaba4cd63fe3788a12d53227e8f4ae41a5449b142cc4babbb83433823db72bc30fbabde5a09e6661aea64d9221a7eee44b00d99abfd557052d764047ea9aca07554a7211ef8a13d1a6c900545eebde2d23f8b2aae4afef12d94cabecbab35a05dd837009df4c5c0bb6f9459e5c88e7cc1400e107a120a589fc844bccd6609567e6780ce636499b1ff18df7cdfac1e8ca0e75970fb189714b0db6de72662717930f374e105d11a29b5a11705cee410637413ab8bab412787819bc8a53761ff5d99cdaa2d0e6c043f8a8ea9ce2767adf51f622c092f56e105004fb04c58dc16c2de644c736eb04b0ab286912e26d012d88126d4cc4fc1afc08e01dedaeadbb7e462cfb7c960f000f725ee76b8b97a592ccff00fb131b4512f338539f888c15a83ee7f7b5d751eb7c7f0b68d1bbc39de0ff6eece6f51e50584e996d6e7905e6014a6292c8b2a7b2cf6d15ba3036c346ec91a92ff3b196e203d9316e41a0653c236a43bcd905776af3f8601748066e69ea005c31059f2e007638c9890a94af124dd7a0338811fc75f435be22f03f78f21a868bade8fe703b54b10ab592d47cf1d720da5a6e5850baf7d5e299cb071e4b15641bf3499aba72dd4f8a3b1557249817affc78b8b253634ea154f3fdc4898a6e601798686bd98cf413895206ec54da3c9cd5ee4718b7a5260450810fdcedfd08cb01a2166e40a770af181d710b4b546334deb04d3a4a2e3814e4bfeb5b2149733bcf7a81e0fb072be9612d0eecd29a1ede630e441dcc3e10cab62b30eaf9f45901c40fe6cdb69a5b4cd00bda23a07b7de38f98ba06c46070b3c921ef19a86b4259a8f3e8cbe0e7952f3a188bca71b3757a7b2c3082f5b06fd56bc4a52d183f6cfc74cb69cc80860615add933622429b46867b01a5b3c67e88d87324a0975b726974b41a947d76b02b17f1d9c2f8026d060219d535f639083df6e41510a70f88dcada1bbf51045961d700c1bbf8837904433d4a03251f33d564deb70c07cc131d11454515c797eb3e2ee3cd96cfef871147b820690ba813d2cffc848c00ab4174ca50e7f5ef3e762632ac6e23a00695c85f216d36bfd847d256b526e7522ece02a5c49e345f8d8c51f6af250894da7067705047f497715c1e79400c35580efe73914bad3d6c82080a282d70e04e5c4aba717bdb02b726c0158fb8cde41abcb50e8e4702be88270bb987d8f3e7dccb40be532117e7041b8da120d3a82f4440cf6ad14eb0570467437480b3fb455f296adcb2a5d0a8d7c2e3098883ec336ea262246cc0fb279e0850db1846c9de557776dcf05f38902de6e0e68efb0d0e7e67af4926155564ff2d0172ab1160cb1dd9382a26dcce80c478a5f8ac3df70ff7302d6a98e03960a97a6760ec3161afdb2c1e8940afa2af27d315767e30dd249da2dd773461c93e4b65fc349d3286c3cf51e59c1a6b23b5f6218c937b5012d6146870030dfb7c2f9db6e11d7f25931acf7dc6981d50f8f4a99343139a64c43de52fbb3b1b0635e0ece844444ac756a2504d3fd2708a7f2a69726240240e114ac5bc8cc9b8a234d67d21476cf7bff6c9d75a0cab9090295f4967d02f69336e669fde38dd7eda1adbef9f3a5cda31bc8cc9fe1786d7c1ea720e2dd7c4c4ef38559c1cf41bae29e2c32daf8e38a4f2ef726814b7aaf168155d8c47cbf5643cc1756b2b027c6b47b5fdc70e773a87ceaeaf87ea32d302e3b55bf4a82b20613f9a11eade7403eb1f40c23041b96969a62a134693a9609617d459fa184a4ddea595069fa86da255aa322763701bd08418699a8f78b20d501529278c9b24e27c0224bc359613ee5352c0d4f436f661abaa05df076c5af72646cb5af56bf3b39249a14759a148518d8823403004e036dca47b4ab8533e70ba42fd54e6fc1c44fdcdf8696ac9c9e51f84b5ef4107b5c9f5abcf3b644f8fc6f6a9d23ea8cb8d758586b48957da7e48191be18cf11ff038cf95282a7e9d931a537e64a54a6dd20f48498b33260e7c395f8c3f0c95de1f043ab969a8d03ac1366a0a4caac0a190420b4f7402647f7418735902fe5aafc338cb3a7bf6235d6868588309a42773f5a893fdc73f4d32f17d6e91706c206cf4c363b49cee81138ea2454e9fb7359383e60a8a0a58d297fa5d870ff36a0596da35251b434f39cdaf61752022dc2a4a0b6938b7f1a918389271c4541f7c66972952cc1f837dd9c0566c0b900abcf41f8e4be85664737e9e24bf9c1aa1f3f3020b35118be6a2185452f3dd6115ba2e2cc8d8be2c68891017bb3706acfc56282916486941fe7985382e94306482a725abae8011d41a7fc9c800c65ba97fa1861c7ae976952c41109b79713705ac0da58d0ab12a92652b3f837b4ce29317aaa0c3380c498114077437fd2b1fa27d44253632050a1d9c1515959ca720e743d6e8c3abd0e212e0e96ad458ad1b1d3fd5f0207fc3e25dfe286986eb177b1ebdc596bf97f673e58a4074e1cff359bd7a64401a0bd96018e97995df8863160eda57b724bcea55e50ff412704eea740829b452ca9501683e20baf74de46c812901271c46ecf93d013a6202644e566dd9867644411baee4e7f5a0fc0fad30291434bc7bd1883598c4f4153eb83d326803f1beede21d45d9a51030cae239c3a84a62b8ffdd777dd87fa3896699aef460456ad6572dce8fb73b97425101a912c2d5d5359cf6bbf0616fe74666c1a0ee8ba5da3fa9eaffacd27c4ee5c3f4b7e902bc0c7d7aa3071315563ccdc2f736306dae11a5f1335bcabf818557c02fd1f20b40edc55892c4b6c5a37d212b28ed9eb39c960022405ca0a433db5584bd952e9f339fc030babdb6b15ef1c735bbf4bb6f52cc2517d549ec89f93d36c01bd25ba0a1403d3df271e4f99dc505a704e6ca1c87254365e5c514f1130f15b3fd2f6d1c0d3408ca4807d813b76640bfc4cc50dc21a5b758bada3fa7cbc1430507e84ba6a5b4d5b4efefbd616b822a8818404d218a9f6462f525aabd99b47ac0eefbd19b702b8c94e9e8160443204050c86356d3f2785a6ed242a5946b6b96abdd28ac3ae4ddb8b1d3c7d81dc73c9463b95f8c80f775e6f614e55e9edbae58031e274b0b3dbacd485ca6fa6b51017af05720a93647154b6970e1d875a49569728f92d5185d497a9d65ac8cbf079c06a1835a832346c86b6f8e3d4317ac00b8d8aefa5263ecf0cb0f0f2ff8837063a01edc1d5ba0e8a86ae80163404618de25fc98d1fb8e9c7f19a9f23d8e5351e08cfabd1c9634850af6b7a256e1554bc7bdebcdba0905dd3dcdc2729e8274fbc3ec8eff89a02fb04539fa74c6e086746b1d5224840011dde738e44f0cd919c4f59babe3030facb8a45a457788b474c76b2bf0b15db6ed3b81533eb62bc201f8c811a6b2ac6ce180be768b64239ae27e6d07b3588205bceefb177af151fa00c1942da4fe4c168895f7f71bf537add501981eb5321495d507a21a3d98efcff14d86affc5acf4a5cbbe8a52e24f3aee307b36240587d86a9539b83ab2abc9b30f1c1219e657bd53ce6b660cd51cc00471efbd15ffab858909c219d1cbfc645de02955cf0fe2fa3942dcbd5f7f4259640b244466b7044deab0a73727d085bb8f574d9fd1018d4bce4e30daee5d57cd90d87312203c462f7e90bcd8fde0f67046f9e04583ce73f1e73c7de6236093f44ed42629dc5333ebd4c958a3ff4d3ad5d70ec8de4b5868928d8217e9d05f7badff6d6bfd1418eead5c7570592cf83eeae5b6dc418aba4449f0bd4926f07b253f2159cfec655d8855e86b67a290aa014ea865a81ddd8cea79f88898e5258af43f4277e592b98dddc986a653438930a80f31adc1aa02ada7062e6243445451c2ba9f72803fda62962f9bc894ddbea1247c38c0759afab29e4ed3461a640d8704d03af0b895567eb88765642a3da2db06782aaeb91061f14b1c6e9a8bd376afe67ba3bf0f7cb7aea63db4edc4814a0a045c809170e9a84cd6d6dda70dc8d9b232b1b0824ca4227b285efdb78ebb61b179ecbb77882a766efaa8f59374e798c76a4752d733d732e7dd8041e801f7a553ef293e0871a3d29d1f037899779a1755880d84695aa16290003238db52f1e8247a118083db2fda89a0a6d8ea72fac2cbd65430b9ab0986e55a9608f32ab838c6cd8063678354d9a559b745147ba3cb1ab00094a65d694d013a521553b478a6274826187da627d2bce445018e1a88d931ac373e2914125bdf9be61d5b600fe57a2cf74feb35d1029032f2f1fcfb4481e6185736a2101bf99680d8586fd360806267dfe671a8c147db210a1ca39550f20f369b7325e564ea6b3e2bc08fdd4d1f247d7884d18d5275f088ad36d9845fe0d521381878c1a4450678bb3f6e93763a1ba94ca67291ba0d9b9ecea81c91708af9bb30f92ec6f5720bcc7d20ca9257ea04fc601a306f3e821acfd435cd16738598de09803b9daf769c6b80928cab427656fb0a1df8332969e5b9802f6493ed61a6f098bc710147691b41788a8f8c4976637a78325afaea109857cd9edfc16c9fb13e7a05ca258b2f6a0c02fa1770f24604e15d66c314dad8290cca0fe5a9bef9f6f1cd7ece26b15a9d35df0030294cafbdd8c6b8247257b4630125c4bfe984b5e9b29f48a2538171fb59c3f29200722d1d23f75efb631b13c1957250e44086ce7affe6255e8b5f21569264d3e8269a7c214beebf815d5f42229ea8a9023e54e912bcef626e7fa7d5a3c0e088ff5438319b8972a33f5e5021a9af7ada54f6e180f3121feab0009d040ecb1b406b7cf148f32915ed471aa580869fab988ce0ed4fd5edfc24c5e1bd222e9b578754a5987f8094f2374ff55a28f2799efcc4f9df2e953d5f78e9eaa7b6fd7f094923862cb8334849bd01a17cb926c68d966e11e7f64ba2ebaa9c9217c53490a634d7955d567c25f985ef4ce986bc3ec86af630946faae9909b56c14b1f6eeb34d9c554955fe5db8a324911a03771f667815f365edc5a82d43bdda3fc0b5ea97dcf83daf7926139d3adc98267dbead6f51836e19e0ec659a30157dc9e483ee76a15e93263338825f56b65eaff84a60f0f891de2f8c78f945f8de4dac06a29da4236dfee7f0e84521c6880ba86ab45c4a7616f8353be72ad7c72923f86d6b433791a8bdaaf39d1888f1d2e51e365766ffafe212a3fdffc073e1e9fb87a64234069f679328faf6ab017f3e70017cd044c92f5f48ef2b9b0b963795ef6eaee99df8d8418d1a38864e497a37d294ac38d75c31c773199b72982d48b45636189ff69177875c46e16118e1fa3c0a6ff845d6bca65ee3d6ea461923329fed6b7148d7d6d054211db49013a7ed912362ff070da7fbbd17e1c653e57607bc6177c30185f03b6ff6064f5f22709a26fb40a90a73e84db968dd7bf8466235f3d255fb77900b1bce6478a1b734bdb40eafbbdfb843d48b2dde830076f7bb2efed72b4ea29e06aebe442269d45dd1c63628677f3ddc70aa4809b2afb2fd37bd898c268f055dae61870998c53aa34001d426b0902312a902e7ba6e5da216b645bcfa93e1f32c0f52eb8376c1ec066638d2bae10d2d14fcb8e303d9d1940e80972d90891e547ddf1d5a1a500ff146f4044ba57589911f84daad0f197e6b72e3fd1d1a47414c48c048c63461004dc8c0a3c717dd308ef887e2ac7c6749798e6b2cb554c5cf81def4e7ca5992894e6ed707b0b71c50e05e7456da278cc41995273498a058010594d62380dfa792e798ff8a48d38458037108553bc52ab188d40cd8cf8f8caf5fdf468be2b6164f9ad641ec2a9227fc7faa72a559c22da3154d034b7af262f93489b30f4c73f957efc03115a61e94230da4f4a86f33881e06a09fb1d4b464e278786b100e09120904a29abb08591c372f15e36ddc40d73c64d54cc2a3ac3e4b8e9581ecaa32efe9dcf8b0a608f244dd100268add73ceee6968a1a8e7eaf4a3023d3f8d0b6ab0880b65868d84c9f31a1d7f1e2dabb45bb7f9db18d77f464ddb5021ab075ed044945780722ee399077c7c4b8a64664dd7698a7fc96c305c575ca4362391d8a8e453b6fae52be22b9e140ace622cc7e5e613d18e4a74ef30769e57b1bbfa11daf4cbf8510e3e9ec2c56d70b49aa5432c18c1d75e2c9cd403e2e73172ae4af855e971e7a9e0fc7c9219fae3a6ad91debe5e5ea2385034c04efc8d75c91cd7d59ba0c1b58d93b4b472bbdabb7d23dc6e81b8628726d3683718c5424c2bf5b7e1c3976eeb486c0d0c096f12c8761a90f45fe04f867d728c153668295a22bff823a866acefc9ce198b88ae992265d21aabd6d2d4bde53c72c7c1a7c20adf26612c4474d0148d3f811bdd540f0731ff7894eb53534f88936287a7e6e680c24c1643f25edb9bd7d1f4c4d023548a698c13feb05ef3068937df683cbe9c6a9584d4781be8aec0e638b756f53335b1e5a0ffc5ebc700ad750a08512fa033c1475ddbf46c5943558829cebdadafa878ad7c6ac0d8fa58c204ff50810fab9be18893f8ccba81b289edc1360deb5e321af22867500e13b3c23388161f3d04592a7ae10207724e08c6660914a63272f578be5f6157dff20abaff8a47f914eeca227d0e664dca1d6423a84d9a23357222bc57a3fbc8bd014cdd08ec2c1dc054fdb8171edbef2b5682f4abcc97bc5b2594c743c9ec19a87a7038d15cfcb5b20ba542eee61c10daf2c0b64a11fbd20d9d899f90f6043764aba15d9f31a651824d6f8fdef1d9dea52aaf270a8e4daa6c0bd4159c68fa81cc478b2b9db8e33dea3625f50bd3d7fde37d1a3783c47f570c9ec4791d1be22c854e909015f8f41eaaac4c823c0b925502385477976f81ee8db9c4b81994ba8f32b0cd6ad6687433adcd760f3bb7e069ca9ddfdcad4420c3f6b9204073e4c78cff70c8baa6f15602c5d11da0b0dfce92c483602f7310344bf3e03bbddaf9f0849ae6f611ea9d0002ec2e1ece199efd6c94f1ebc510549fa9436e7ab96f8df0714d732896595e45e7de5234edff3551969a66a2092f44743598a478c43c9315ddb02e7b4740fe1b8248fced3f43276a3f9212106918160b733a9164a61c45871285b9badaf73121788ffa081763a40059b27a8afcd10743883079adf6ca48b1231659577fc60e78294efd47bb70f2cb2b13b8710ee3c26b3eaadbea32a6914a7b08a3afe2453f055ed8a939bd297c87831b90757b094bd6ad014447422bbcf1827d831c33f826f75b489ce3b89cefc42e00313b30945bdd2934f363f9b4aa93fc674e34814f52a12cf7c0846bd8e121f22c79817db91ebf836d61da01fc42b59ccfac84529b12c05f5257b099a95d9680aeb6f3ddefee3e925f2bcf803452cc618b49f4f20eb5a5217cc32a5d8ddedcc27a50a970e4f2f30d5c036b722908596397f8f032350195fb9061f8f2ebfd31dbc32d73ce6e3f58873907ccafff5e7bf76a3229298d9bb1834dbad1a0f1d20f86cd408289bb01b1943e1a0132c797b6e282f5fef0d7a595a3b3c58d4e8815963ef367e26bc4e8d7be34730b36a9277efef91a10fd140ef7a5041c34def3660da9c7eef60b8dd4e04c3e05275b1fe08d2c11b3c51bdd064a59cd5f829e396a0e559d37e7691ed73420cea22114951bd562eb9722ac075b9176433f3c361f58b2eb37910bd3de3b384633d7960de3380dceb04483dcecc27d1f65bd236fbb9fdff80bfb9d2b2469abf9531581050ca2686bdcb64ef9ba4dbb31de45c996be8270f6d09a0e6dbf3e55c4c69df47556a8a8a9e0002a2232aee5d8e1188582f4e8fe86dd4575094ce27885cab4da2a1b2ff29d7b502e2d8a257da86de8b88a327a1eae22f3621343f71825d424c8683cac88370dc9f09040f842ae3841bf6074b18da21085f633fd84dba0d1b243bfc93867894a475942dee719eb640a5a0b127d58135eba0f9dc84a00012b33d569586ec08227d5ce9934685d9ea53868527dbbc0df096e83a4700e69bd2a85b9b6ce74b2043e030120dae66e1d7f1b75b0061a305e6325b5bb5c59ebee1d0d9bf0adb6a3b3d3d750925158c913e33748f7158e2ec797fd83d96666e4809685b716da7220d41446dd0b264ed5382bff92d38e5a37f3a42472a6e1e5697c7419a2108b892bd1f31e95edc19248253bcc619cd5ca4896f894186b3f7b23896c4b692a883039270ec6e999bad17d0b7ebe13e93fbccbe081d0f99bf4fd8c68c8dec3c753a66d53ff4a53a6a36ac78cdfe600dffce15aa206ae57b1441b533383655ef7ad264e8eda594ae17d772d6ddc4a10b55818dc75624ff2ca8956fd6c4779620725ebf8c73f74acc989a9f3bb453e017c99f1dd0067e6ec52b2642091c6e227e32a4cf9b9ea6cb7fb8d61322b57fd9e291f7c6ad9dd36cccd163f8cca4d7070c42d10893580e4f35c29688a1db909609532e1df7c535629d2f77912cfe465bae3b0a3f445ba2fd77ce7e5c7e0d01bea65f8749117c687bc2e233f1ec847ee985339cfb994d283cbd33e123365091d78b5d2aec1b0ffe0dbb68c4932a95914d8e624a1c9babc298801c06c7ebe261797e6a9892260afcc4553fd42baa3a55fe2545e25977eac746a4b05be93b4a7098336828e23bd54705e50457639c592c760bcca4f0366848daf00de22fe57552e355821ce9203f4ee8615a4abddafd95baf1bd3f7666ffa23564baeb273b9c043d54df6ca6d7e207c88c9ee88aa573053c19b32c40450f5adc80a5d7f23b0428344aba7eb815c0184bdf3efa96711ad878de19c0ab4c4256e8c2b4765cdb9781fb2cb054f188fde66caad79b51e7d1e7fab79e38749d38e0803cf04028bb3929d38a7bd675581680ebbd714bc26a9b07e63c70a4f2cecc51e741bfd6c83eb26b8a4bdf0aebaa16ecc58964908663ebd46c4e7e161f176c58f8af98b33ec39f42a08519d1456509d49ec51005945fe974172208cb8ff57c7ca9675f77a7135e4a29e15df56dfd1e153d645dc55009dd43f9d520aeac72b0ba884a1a1a81dde7f5025bc0c2c3da4e85565528eb1ac98c222c81bfddf0bdacadecde0387e5383bf7b164c85815ec7fb761547f683937a549e77642d9188ddb3e5ac766faae3386349006cf7486a8b47a03a472da76a02ca5d4a3a5277e8b7304c267653ba074b289f66175746acc563164dd8568df3fbabf12097b0b9b50ec9ede16ff75da7ff0697fc96cfec44382754694756b3db60918c52c170b1e8db3a964fc477246967a408bee6e47aa52526346ae06fcc49dbf165f9227d0faa844a32e9bbec991b9706f1eb55760b45fb165575410a8a68e85a0185ef640e00232899e97c4b08e12e546612292efd1113b6347ee35b3c52bc43068f1aa1a2156e1351ed979ecc1100e86fe137ebbd4c114287d2f21faeafa4c0fecc1f2a45e361f97271d70d3f2f185548e3b40efe492708a16ccac829a4b0b59852856804b0b60841d52679578a1d9eb7883143c8ad993cba2baa4b7773ce0424953cdddadd9a6bfe7e7336a469ea544db4232afcb6c8a7cf7245081fb21bb7fdb6219bdbac7eca56ec1f0635dac5c5e8f7e91e94024b588d0fb5585962f571b87537c4cadac0bcc8be18776f724ce42a6973f5cb8c171a82a98638037886135f9b3f396200d575d9b90ed27a37a2169ef9bd7336ed35ff93017afe9ac4b5135dac59df9a42cca2f97771469f93dc4bcc71394234763a030f178ca8a6d2e07824b6b12edc08d7a6831e4bb65fdde6cda165aef983339dce08a01f716cb87adc3620afa842a7e461925a67a870361958f00f93a2677345f72dcbe4fcd84bb3c839d0d387c0908277fd1d95e10d1d5f1433d11868bb3fdce143463b53d2f1c7c42210c0fc8a8791696dcb1a6847ec5711a5846e434f31140b98d6592647543ad545605323f28ebc3aa9c4d861452cf47987bae31263d21556bc65103ecebcff34128ba6d2c4112ef498510387b7b05094137eb7357c339b9ac1be154036802519887118f74ed75a72265a8a036ee1b857373eb5579857105817a772d49f622b2edd7c09ca77dde627cb22e6e8f88deefbfdc020640fc332c67ead0b6a219058c805225f7de0288b58f9beb4ebd604b21bf191999d563c569455076adf7fd1085c06897c2985c0ec00b32ab0b633ec5005cca5e6b913ae8011d42085fb8c37ac256cc45485a4768bce47e66135dc8a77ed736643d136092f9af85529a0cb6daf9b6aad06bd2c0e5fa4a7505cda74e85c96a9021aa0d262ea594a30f7951d7bbc5c983111cc64fe4a5457e0648c4c15d4fdf223f382fbe3488a166c589eae6b65a9ca26d10c4aba7858867e178b343c5e246a92252ce916f7e8962728001e422e1a7e8b4e6ed376789259b204a1d5954afa481f7ca93e33cb571806fa24f897509eee181bc041f55c2099ca2d7b87812814d8ca2c8621624da760fea4b58cc9962dd701d683920e532e739703107d64f349b18bd33efa7ac462b01e22eb012c508cb2a840eee63779658222b9e3bf6834feb0acdf93c84a96d8558bbbfc45a20af3e064eddc2488e9063b4dbe27f067a7d65ea6b195ad599d4813acb94e25f6560cb373256e9451931926c14b59f724159c2a1202ed5ac86d7bfc04e1ba30b8a714e64b30c5a102fbc5303a5308e9726dc45ecf514d607bc0c40d2d1a3d37a03177b01217229c6bc8e555d0f3710f9e778765edc95549f8cce209023688cfc0f60632247e0885c03b7104560ae0e333b358136bff6ddb303a30414f3a664df5eb44eaff0157e6f825585300b2fbd335784c76ed8865f0106bcd5b9f16ca1e675127025b9f7903989d64d2416c598c2d95e2c79f7e42ed52788008bed5600c0b6e08bcd657b4f9965716f862b45c163d55e8e02c4a2a512cf12383f5c438eaf6b254da9928a2c6146dee7aedb87f077c94136c0f0f549360c7663e055c1fda1ec37b5f25c28c1e48c651548d58b24b853d7c69b4066f6aaa29c7160b15e122f1e1c3af186cf677e6e2522f74ea5f068046c3201d69d6c216ff5851d2139f9edda41835f62f0f41a70e960c3ff5b9787ff2f6550db4d2c8a0ab3f59f1df5dd98a2099bb2411d41fb9a76ef456204ac87ed1c62f174ea1629f68f66bde4b35242b0ede8762e469ab92e814d05906669b914e80424b53697dc1acbae56266b8d226e5c95d134dfd5d796e646d02e6f5c341eb4600935fc100f2bf7a8d8cfcc1b11f3ecbac18f60d5e0212d8a333094cd1710cbe015c5b82885b297a024529dc5f3ffc2f00f6f01e4620e48623c55c1addfefdb3b18cc2131cd37f22827bfbe69c24587e3231557a784965daf8c43e5b0595454ab248235eacd3e079f4b4c451656b92af44b67663a4b80c550347271d8b14e1f05d7976bf42970f343525768f01d860d11b02210801b8ee28f768d4cd565e773496b1567f3cdc89a2d653aef0d678b6475cba45a7e1c2a07c11afa4cc6364c63f8de1f5f99ea2485e4aeb25ece4aebda19172b725d232ca1fe92eae07f46b623442b2ab2b1d3d1ae8123b918f099690152bdafd0aa8d29ad14df8c87c00f88b9cca70b2ce7813e17f6e05283ab6579af41af7a07039961c9c137b48a1f01b8bd1a4e7451c27941b93eb88df9a4e5ba28f9621856c63c0fe37defd3d572b4986564c36adbb012e2757dd9a8d37c9ff1400cbd91f76eb95c14912aa99aaf642fdc5ed317bbed28ce41041b5a1a341ad5b5a4054dc8da817c71f37e8c09eb3aca3daf66804a23b8d97993b8ae42117eacfda036fa4ae3cc7b3310e750ac7e7b9642fa4d24383f360f4fd8374bab662d444f444967a6f4a5ec3f34c61b3e077bddd8cf23586920a45754691ed1956d4082874eb5df50ad284422453ce0df3cc1c4bc6a80384d9c521cd298ff75d4e17064f9f24ac31043fef5174b2c337c5538ce0956d9abae4b356851ba6f55aa57bb29b3ad20c1a5e00f299d6206bd89cc87efb2f8f349eeb90ba35e99393584d2948d39f17f1281452ac4cf241943323447aa78b8cf9704d99199bd723ae5739f185376c90b6a5be8535d7259097fad7ac283bbe54f5e0fb0e03775ca447aa83eb4a6f03636ee7fa2aa695ae0fabe680c9ad47c55f924758840c306594a04be81a8471c656e6448e016753a4f7fb6f6cfa298352bc854b74141bd4460662fffabff7500b19f93504998888960f62fd9c2776aae8b9dd59ad8318b7d4e48e00bb698251c752d73fef3ff4111b0516ccdeca7aa9bb401beadfeef074c94315c9af552fbcb8f92f7590759c830684af4fce3dbd2bb345501bb4d2eef3f1e669a94c7781f9d6ef64f0a418282b672d3b5b03730e2a64e5ecb68739b5fba12705fc98ab742af3b0b51e5c8d7c2a668568e5672837540aa2346b28357ef98fec0","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
