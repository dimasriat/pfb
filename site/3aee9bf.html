<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74489509a3a79a7ba8521a9bea9dc1e2ed83ad95d7c69f10d2abf660240645e5412f8b0da2863575deef024fc1d23edc24efac504cf87e6acded3118083d7ba8d23ae5185f2a8810c78048a853a393ec7d176276602c8c56de32bfecfe146baae6e05ca792241fd198e896ddf9c986cd86df765d09172cbf0bac33e3f730eb79fe0862faf93ae421e2a1f979670f018a52e34244ebce5cb68ee04d6e33f44f6604bebc074079d724892278345bec1a914fd965e54e786285ca63b242e385c1fe928777673d133355974d990cf788fe31a6d6faf00231bfcef845384f7666a741866d4b9a776c9d7a0c077578886c22d3eb975bff02899796394eac7b0b471b35be1c95aa9beac60c1ce8cf9d9cfaa42a0e3fdf863a3447c40b0ebcf15907e8233d7262aef7f48cf1cad6c63cebcb38f1d03d94e5b0455bca15a662ff40e197e200d69e8ee41bd9dcd22bdd6b6f6015c869c17abcb13d2ad03d30b8e9fd18ba1527da99590037cb21426d2b7b14415fcfb9b00b546c13b614a0c47b8a9ea8de16ab2c5402274bce046b03781b686f6c3aeaa4b1603987ff2f05e3ff3e73aa5750090b7b5c790f155b416e2603efa3ab8dd4cfa61d74db1127f8df85329bdd3f488d2bda696df9bf1e6c652bfaeb35e5dc50e8ddc9d1e8dd71a1c9d3fe26acc06fc31df9cbd9c9f01cb57c281c566481e83bcd08be0f33d4728c3b62632f3147cf11e708fa06bb037752683fe4d36fc53c243a0b2904b2997313601c1d615cd9a2e8509f0600eaa243dcd760637889c780bc1436988b237f91b95d73130841416c0beaac825161c334f747c9d44abdb9fcd7f1660a650ca75152623ea464388ba9b9233743c67aec876b69059900dd2a176bb380307a7a9ceb58457933689aea371ebc9391bcc4d65f1d62cdb9ec881d824fa989569cfcdb8f4b2f88f117b2ff6fef7bb965642e6c4f475f92c20501c0b14351da5eb7057c8bc6288c839b41c304066580bac2af2f37e85b4c7d21fb6a950b3a8fb8540ed131906638a03e56bd53199675c3e453d2f30d23bda1a5ec26aec4414459ae0049294ae54a1d503a09abdf6c53cf8e9552d4eb5ba2543d997b4a5d03dbc3fe8851a7d402be3b041e1eec21a7490f60787b22f056885d574988c7609d190b27dcb0280f32632e457cd32bbea57f98f69bd33c6fc7bf47beeff9785add9876d3c3b24ecace1b2a5c709567612d19f9a922e8fc5b1df6ffee429d5250719eeaac8b2271b17ad8279f162b21d552b5148371e25e8ef471cbbe9db6f13bfa752b8875ffc60f134e56dd0f93f40195793dceda41fca7053e7088ae558f90f904aafe5467ad974a3e2906ca667d7b1f9b1e5d0675aa1934196d21c6e7010fbf847d0e02228cecf30b6081301b4ea1a847ac9e07b42de84ae6792ccd5fca9c06b7b59084325aba5f6d5be7df60642728eb5612ff7ae489e0ce1296c21d5d1a098f52b42be105adc69b3f25d1e0fc7a3a9f634e9dd5fe56d3bfebb7606c2c1a623e4e0955528c699f026519fb8c569d6277afa882f3a1c708e65c5121c1789298eefe1fb14037f7f038102b21a857b6d952f4f201fafb463309828b7ab6005951dbfcd045b01c5f116ec8275e7be44d4528c0751698d5662d80b5cbd63e88502335e3dd5057c3526b1a19614ab0ff7a8bab7ece4acdffadb1d5cb98f6187e1e3f197b084b4aac4ed1ab20f2ced2586f92e2b6c83eaddf12b5ec4a38cd957d037345d4fb3a8b60fe810a79a84633eaca9af14fb6edea3ddd38f0831be3690b40e4ca0d0a9a1172fdfafc8f734bcf555edfa864615385d25b6e18858186328b6b805c62d687289387fa09115b902ad075a6da4bf70b599f227c7333baa99982dfd77fc42c0d5682dd02a0d29216f760300e23f63d81c0d9526e91a0c1ac186dd48ddd9af384a7b8a8e6cdc7772e1fc1f218e089e286c11678ed120b732e3b27bc54b1f00249b1918e2a6a72286a455c3fdb4273442260dbc9761fc18f72c48a228a037a79f11376af8df70b4c4f6b4fafdf3e5108b80a7002ca27192c1c75dcba03fb70be522bab4fa9d12947f365e9c50e012580ae4980067d47b674edaf59de89444c5a28075a927615ec03e3bc34e2bbf97a703d54a498786283a1df71826ca84c6abaaa231989c6abb6f1b167e99551603d3e71fe093ae8a4f44d10bcb8a2b8bc518b7e0b729b3aae1fd9998cfc5ef586f170dcd3e7339b4a2b39de6bf76ade8320574905214147155473d925fa9e6460f79bee576e4738c8be42fc4a946d8e45a8bcd4eeaaf3f351d59ff7d6da5f72b55718b79f0192cf5b5f692fe2f48ce1c440638b712ce4158dfded3c4763adcc7c98905e992cc763acc063e820c9d3b23cefce4e0c592d65cb9250e2ad9e28a80e945d2c7c9254e6683b1f47153d44142b8d5eb041cd3e3ce92be8f1151ff9ef0564996335e666c2db9e355d9af90d4932491f670164f999b4f42d786830e82ecc53be16bd52b5d91371ca2c2f043f8fb3b071b11cae392ea85227bf5f10ac6a1b0225dfa44d3ae28d26cc1ab3a0c3c128dd98bbaba8e3ee3bbe260bbcf7a0bb8af118593e106f46a3bb5526404cf1b8f760e2076b55d3261ffa826abe64c15a40ab26a10814627c89452988454754babce9e500acea3879a801de72301ad7c007a13078f59076e789f84b55f486432c0f96a934705c1f9bc71e78f867f5344d79e50a5eed25739fb809a12feceb95e9f07f8e028aca0765745a10b24b148119a910b6f364ddeb97c1b7bc60cb7186134d3a584c927beefae54253a94dc125d40a83fe9c9678cb3be76cff4c37b90bb68a279fa6e5be4e61f8080f6de8f5cb1b30efa2e4658cec9a97802969db79fefdba7bcc69ef50ab668ec37b1b6ae817f4c9d921ea5847e15887bbaa1a680e705a4efc25383059cc15c1c915e77e64ebfb4bacb96d3163b2a1af383959f6c8002df59a51fdd375d91d1a4fff059894bcdcd827068bcae7dd261a8bb712ff756e3b24c44cc1c6db63508fdf868084a5ecee87fa667a2aab84d9b3a373e971128d363cffc6236c4ff23879c9521b808de7e268f78b71254b6504d96a895abf3e43231a437590aa4c502ff5ccd902b44ecfe47831a8d00ed676cae0d5712f00587a6270e48d0f9857e31adc10a7a520326aace9879bee5f24f78d116b83aa5ed8545f78c5bbdd84bb6490572527c61e3334a738f94b90923b46e571447174616e30c57256dc27f69a30c9c6297c793320d053ef476f7ef5d7d1291f1c606ec65ea86232c925b2ad7dfaa0327c534c4332aded46bfff4d4f3abbcc8ce7101af6d5831030a85a734c5bdfd4aa700ed3c1d1a0d3ed3db81d94fbbacd1eca7266d9635eb45e2c3d36c06849fdf0d7ef5750eb2c18d678f509b677e3bf3a7f62d6d22d6a999510345a6d678e46076f87344d1e5728600bf81bec3d3de2ac24168bde4c649369145e4591becdb0b0eacf0d91af70f4c5965c4e7efec3b72525da760062957a5ad135f7ad33ce1429e09d0b9cb1ea2f441c60a7019d685a85fc5578863a96b8ded948911f1d99a1ab8e8c0d228f91f6b0b5f2f25697f9f4ada5c8e4495664925f21a498ad461d752853f5a44763d8e36b7ac1fba2a66774c5671b81c20f0143198da378ecc683ad7667f2cae1bacfe278c2b822b64df7a7156a46be18c1a06f6455b9ee726b7cb825faa8021a2cca0225b326ada4b1dbfc972df9f430b9998a69c3f9ed43b8e3c21c2d8bffebadb0f26514b435fdaf829130afdd00581e3cf377fb5b1f66550af23ba61fa364a2dbbc8e4017b4dcef6aac40c2352746717e39b24429c8218ae9053d55dd3c7484de2311d43695740ccbe159b5f2d3bc4fe9225d141db19b3350de83c337d0f15736051120593f36f67991f9e6788881090387725467c8947ea7e7aece1522d44f5d64c715203a3b2d94ff55460bf13a485049bf5d05609ff9ba5fdf9ec5ef331daaf5f1599c12438af2f6035a96ff6ce59dcdb24267b79fda07908fab284910ce86d4f201288f1b94e0a410c26cedab22905b6b97e1d08cfeb71c94a6555d225b19ce64e1306549dcfcb375b565011c341903817a00a80bcc7174b580644f6a74fbe60f39495ba0b526ff42190a08bdbe62373ad423fd04cb827cee89c1d9f4ecbe1f07dd0cacbb74fd62b108b554873657ce3722bd5e91c053a84d6b97179418cf752c9f30343d5fc546fd2526b276c9cde42a4ad3baaad02f03a68c2ded2bd6a8abd1785b60ef3ce449409cc744d75a6c4a448926df00bbedf586ece5bc4cd746d26c1f9eb370bdfd7958892cf2c596a4504ed6d90c6d43e5903c9cc2967d52e1b10ae7468d81ae1b2d28f3816ab88402ac7c0c4128999cfdda05f7b8838dd63486a874dbfb4425bc65a619262de5fdd53749d8099a3d2f5669e8a7e763d0e4f08b661233628548782b47d6042ed72526deb811fe9a24322ffc01e0dc2ca9d48ef31f95384e2d8e9746a703f6b255729ee03718dc020008cfec8fdf72fed11f4989d1b4e129119b2df3c4fea9407a0cfaf235e8ff90a6dd1e8ca327ad21eaae3a2fb9853a667902eb9327662c238ddac73e5960ed22bd0c5fc75f2f2d69eaaf0de4436a946da26a0e766a5cdec3374f39151e3ba486b0871a5c87f9114b8e5242d85eb9d7fbc0cfc187dab329973cc8481e7807142e61a05b2150f9bb79a21bef10b3238932c7f1d2bb434fed8ca867e84851ac1b9dd1c4b0f39e708bfcc6d03beb410cd8e70d750ace24c87192ba1563d39fc74b8fbf84fa8e37fbffcbd9c676e562009cc0cbb601812296cb02515f153a897ea0d5a705e04716dd09c24c5831537982dec0ae1bd7f83236eb450aa682426784cc3202be7fc2f86524d989aaf00ee3abe501dd0c39a14f680d2d35ae3599e274f71afeda76d13da159b55f931c9d08232ce7345ba3cb12f874c1a378ccf51e738334dbfe67a9fbc15d56f2b3fcc78d6a665c40624e41054cdc1a135793103920ff14d949b6e85a16ab60c4c03494de2f35f4b980d56884aa83e2ea20763072347d77e30b5e760216f5c2941dad0d5f6067ef238c5ea536a9700bdb2aeb554dc8583a632804b2e87def3f3dad43c76711777d8fd8a7181da0f5b86d48b72f7c1fc813552d38194021f54151ebb88f7c4c9db2bf6e4d7d7d54d9729200a3c51cb7607d3f3a449bf64e898b14443123e0273b5f7f043174062f02f00ace1f3dfefd8ff69cc76ff422f3397d8383b4e7203d70c21d814985a0cb48895f136d7e5288e5bf3db18820d4ed3d355b151aeb3753a699131e9b14b2796d8a027783041f7a715ea741e4b6ce0190f1a01db813ea86f2d4fcbc3434237e6325618b56768004b295d458fe294a8b62db7df6f91611dae3b2a996656608beee7d194d47a537366cc153e1b4a0829efbb27105b420d6856256cd1bd52ce4d7a09a15105fa4d615c071031fc5c514803abe650d8db50b23e499974bedd620573aedf79fd09d3c2f29b57d9f69592eb2d40f60e3a572a42996e0efb2ebc8d086e1090d7ba221cf3cd6abca2ddfa5fcd844d4f1612342ec4b59f27d578433ebea4493f9b59669caa9139801b6d13c845e0674e4e8161a528a5be9dadf9c6090be609ffdb34ead503797c320efa8d404604a19857a44400b6942cb3f77e3c8221a16b0ca0bc23a2881f507dc317eae14a8d329074ef9ab8cd45f9b02642b2f538a88b8dec1e1de99a78a32d129104d1f00a880c5c48bdbb24026975c785a883ea46f6382dd79fab8e20287a39462d2ce2a4e02cd7b1b3f4e1cfa66e6dd4a321f772a55716e7ea88fdd56eb6d749f5b02cd6d4b96648721c9f6c20e98d0e7fc08ee7b2468e890dd44fea4f55a4b5a40595d791ee4be6790641f223da679823717158336ff4e069a8ee7fd793f6adb9a3b080d1b9d6fb9c9bf5a020880c36f5fa2d6bf395028c24ca0377b1ca7d28a4d8065d5c85f4b0d571aca8e97c6e5ef9a81e5f89265617ec27a27cbefc421d8d1755f1ad712131d4b58b06a3471a50c6944bfd93a7c4d1cdc2254f2da7dd00c7a15f6f5989c4f1147c0cf185e8ab662302668d3fa179d0397138ee153a7c3095599e7d9992e5991851ee2b0da9474930780c3e5704b6ea6b2ecc6ad9d1f0d7e53a31dae43034916cbf326b7dc3e3bd132fe2cacc8a3ea30903a2f23ccc6105a19e054db5a8c53368d5733488fd011c0244ec92770c2788207083605cd74b158ca657ff49cc8d088799f927e14d1bd2551d0ec6e32aad2d00c195a0f7f71c25beb16fdd54767d1c10c7a5d513ef02870328f2e68477636bf5cade3d3f1f4cba4aeab54e46e69be9c8bc72449fe221b459c3a623f0b433a452f242c9654cc58297c42ee5d113f69f08baedcf34b6f05f270ffbd888e9c8a639473f8ae27115a45b68572afaa959ab79b492958cace3cbf620f31ef0d4db4295aa1ef3a2862f27e318ac5195eba89ee8c55b600a1ed4bb7151a04258e4645a6d8f0e627b9171631dcbf6482bd078e30abd2a5fe39f1fdf25f8ac20a74a7342da8745c1603c2d69183e6130fa14efe652c2a0ab837fa3728d9ddd764252b083d3e74780290e7ba81555cafb9dc1052b4f685115b8e58900a0c44369d5d12ece600f8edc3c559e0fe0ae08af041737562b75c43bf7de3e175216f9795d7c11bfa647c1fcbb18f77d9f173aa283b3d9bf4f5b688f1cf8f213edba4c4511f892c1a8ca50fc16b4c9de5b5e2b9773ad5f0f871983d1bfac5a3242ef033e9666503494c09820ef52980c092b1c7abefb1d7d350a3a671598fd69968d535717e721b64709e6f7bab2ee01a9661c91a61bdce8802993574b190979a1a2f1c9b4e16a33c66811f2f5329b1a13aa9b18169785f9bbd454c81fe90470ff4aadcff057e5f8070c78387034988d1706693892dff29bb0a4c53a04751e5c787f360f32451365ca33291ff0e795b71d3a789ad58c2b34a223ccbb0c3251da5660b8198d309c9d1695fd8e44b04e01fd79c0e5f73f002b5ed7c6a258f22af34df3ae90137ad4800d124b7eed02f935215ebc1145fdd65b2cf8bf881c78c1e952b131517834886936df340f85df9e6e4895625546c31abc7a4fb3e9e123850fb7e44ea223292bd70a6ab66367578259e84080bf31c68857d2298d02a10633a5cba8a86f2247eb902d69aacd0df4ce6ff2ea52e4311557729d969b48320d51198c96cfce915a229a5b4d7782ae2a330e792ac3a5228b3899addaca33c0db4a14927b0312df9eb538bf2dd5a621ba471ea41b6b8341d9f89937ff811012ff1f62ffbd2c4ea85b3eff5dc9d05e507a3cba02cf39dfb72818c522a0604c308dd62237745187aa916a28bdaf5ca3860b10b5834414323b1e610a9e4cf9852429bab59986981d7fc9177feed21df17b439292c8db8029b5f7694e2d1686a8dfa2d16a28513e6ec5b2c3c95e6b844a969b9a4b578ec9b37821f3381d4c2fbeb38b10308672f41afd57725098c6a62a8c89003da8bbda1b29c4636077371f95e706b97c32e05d3042b5d05cb44f125de84d7e70635736f74d570bf4a08f436eaf00935e5e931e3d8aaf73c0b5a321513e4f7f5b27c09a0396ec781760e674fc8b04453d32cba920cf347eba016cabbdd839fea5453bbe3c1d770b733269613788f71633b7a349611301edbd7cea1cfb99fbd8d5ac1e925fcd3274dd05a768a1b951608a60cd30e3630815c1e31cd7dd3842c856bd76b0014d9e2535f958cdd3e6e5ff536cab2740c6f9494442b03bb77fd667abc9a038249ec01e668f89e466b4e48c28c0536c4b583db3fe0cd4ee99ed4563321f45b049220a43ef72d425ef575cac74d71c1e38a6fe863e9cdfe01fd5218d2b7c134e2558e9ce605ddedf4660b9d6c406d200dad6f4009bf264822ab3fd10077bc5c60e36da7acc1484ca948564171b5629e82f06aec5a17221b977e8ae7043a7f9595060d8121c333b19d078f9e1a36840456c9151c09f365a6c021278870cf2fbb9b245770106cbdd238493b037c36d9480d5470e439fba15d63b2e5c2031997267d4ed2ebe5c4d58b86419759767e672648abf7f03120d86d74a3890d7dfa6444a4bcfb11834041e55353da3df8d22f788522c2d67aa17c3de7692d71522cf6e3a356228b4a7f30f6290ebff0d7df8aa9031540386dd7a4c377a8d8f8be12295691df2042a06e0cb7c7c95387d577aeca967d8f1993ec3be848df2c766932c245213037926b3b4bf59e0b38d8de816348c6eac3aef0daf89ca8ae9b23f26671da4b30df4f159f13d8ba36eb6bc6e8ce7c2619e8a4ad2aa303d7b3c969c3387e50c90ad7d7a208d86e0fab1c70f35d9980c11d9d434e05613196c5c34f6a46713af3fbdca772aa931dcc73f6778490a861993d1537b7b171ff5500da929365a20ad9854ba7eb9f4ba8b1bec3a8bf2473999bd0c41e69b739243f4f8f23da550a9ac35869fe20c34c5544e30fd245e4542bb3bc6f9e7143385645f055e036bf9b87877023c88339843e6295f8d3da5f66b57d840da20a31b538d2298929e409e0014046b3d83947e4ad0ed4967cba9b5b289a84bfca2b068a60935a5467a35b89b85a91a51e220f1af8bfc321cca7220f2676c3e303d847f1af1a376c09f5b1af7fd3921c71cbdef2d8fd00fe2ff29aba07db5105b5d1fcf33c88e73af01107498fc94ef7e449702ec303e77c31a17ad3e0540116013e83a53fe135b3651747009ccbbdd49befb36b56e94e6be3a7fb53f0207aefc8cfa7700b7b46bd086f1cc3ffecadc61ba31a07ea14750cacded94b9de1d98b77c5145505974fbdc19bd3dc8a6d0a7fb0c83add8a960a4b5998e1e05bd521b28a60cc109eb9863e1b4418d70f707ab70bb1edf350885bf1beca44a45afd639264ccdaa06c6f8d49cbabe7b9c63cc5272f7aba81acd2be408042222735c3406d8e2465fb725bdd3ed68faf21bd65f3d35d65da217703265716950a7d055be25988e24f1f4932a880c47035298a60189867c85e8f0141c6402f5e629a2303345a417c09e7b49c81e1bfa28ac7b0648a1b9a3c3e35202007dd18642f7e98243169464176f7934c939c184d0a4c63cef6482d879c3567958efe49d29b622b880b26edca5da2c1ae581e8a09cc67a9f287378ee0e9b060ebf69330ecaf9e23d88fcd697f3938c5d2ddfa1b658ad83eddcb31955cb3a38c53529540cab254f014a736202e2852ba383c8fdbd65cc05d51f32eda310b2d24c24a18c098079d765d04ef4f82ed3d14397a53879d2d0891e7f877760586d11a75d508f507ffc25ef511fabd2cf4353d740a750af98d8d01bbc39ee5b846851cc5b84bb877fc338b8e8f123e2c651ff2a5064fe602f4f2585e6681f5a097c9abbb3450b103008e904b3c726d2d1fff837c175e7b10e2eca616a9ba07bfd951fc121d853ecdf71b893feb6da8b3e8ab6057f15673c773a25470971ed12c1b069fef0d94249ba6c617e04240d792640f19ac02aeffa4a7929a3502682adb954ae05c21abb8a3e1a0a002a6f58b96fb8bc373443ea8fa60f57d31c7e8762637aef3997e472829a0a26fd16991229a36616d9108e741fd4b3c4e8ad0ec6246b311e4d7d334164c026d7231c48eb71cadf6f216927b50a2479b5197bcf2fbcecba4e2d2db81e9a7e3894bfffc46eb6a7b9626ea65a106277bf17d910e397eee720e7ffbaff1f8f378ab02addb59a8512aa45f04784088bd106bdedfe652cb0f1fae10e812deabd57f2bce5cb3e55c57d9d917f5bce7a513d769417737d91d1ea1106b5ddf7f7e7083169d2fcc7725c9ab43c6018aacbf0cc6933262266930a3567e05fd549e992f9de0214f4778a6a9f807f24897d444eeb1f5266d6d5a5cb7cde216821e25e19eefaabba3ec49104b81b8037e0fdfd1dc066726909cdaaae568293e27e97b6431e4cc0493fdded7ddd1531aa13d08417fdf38d7a9c6d91b5d4872f0dade07db49171d21f8285e68e64cc9086a86dbe37a1b0e4441d87828d6b5b01b074135a2625b4151db2c7cc63bcdd4ac28e4bcad1f6d62cc551bdb34c42bf214745b4422fee98770a4d0c9f0cb87dc53f831ac4421ab7f1aaaadb83ba57a2f23382678ba6da47eb1f2a1436f5d338348be08c63906df73388cc9ebb4af01598de90d0420a8bf7065eccd5ef7c953338b1e336e86fb2c28cff1ab6de50ad983b0bfb8143434c6329e15400b6d76ce56c76278b06d8ef719a83f257a3aa79f1b4781470c4d3c293761482b6d3135acb5abf78c9fab6a1b9fc91623c711145d21c1ede327785d7a02c248737ba39fad298fe0bb6f5edea952c40e9d8bacb95fe78571e4399e6d7821a294bde024add44b7832156a3854ecf329e6efa0be1741a3fccd82d2dc83b54652d2bb77c764e14a7b1d63f6ddcd9c0a3894726e5eed9f7b18b1863d20f8980dd72885bed86e938446e315594e9661713eb6d3f7013779d0f9e376d3c774d447c28f20036b3d0474b366d075f25ef8ea8be996e0e1b5682bccd2028c86a4c28b43d75abb3d3d1f8d8995d025f67713bc87fea29cf81600cb7ea7287bec01ddab48b57d58e64192ffec2a112333a68dbe189e8d017b88a8b4022aa64a92ad74965fc9c4118c11f838c065e4f467adf47e2ee6afb227969a7702f0aa38ba374d9577083888a3ea3655de5d015438830df5f8ce97c3bd575e3ac80fd3bc310180c25e92e87050642678585ff73f0d01f50e3cafc7af9d676fd6cf67187ef402de484240c197f6c9ea4899fa9240961234e208b0f62042955d09cf789c2cfbc325645d7ae473061d6717908aea260cc45d0c42a48f4629ece3da6d0fb011ee6c0ce4b71a2b2c5a07defdbdb92845fe5d225ed8988c478969409144b1f2b966cc006ab1caac69eeaa31bd9e67b33e03ba0a6fc27f95cd8041d977db2c03667864d7e1aca14b0548829b2010b50c7c0b9f2102fa5dfe5d47d3f0af03d3b8b46886f59c816e2b9eb722e3f679081859fccc574b57d647bd16e3c3d9d850e4c4a2fcf43f06f2da2458f9a9377a06741d5ab1ad2952c742463a5697b9ea394d51473159dfbab4a77984b42f9d050c53a4a19bb797d389a559ca463d03990a7c0b4bc774cf03fbf3cf75a892fbf655b6505575a9973480ff0541b89e028008e1931b8df6bd26e18e327a93ee82502e392e0f6b1aa4828ae837c5fb74adf2be2384853b0d2d1c92dacfe5720a4577d7050a21a459950c955e147d8985214186cef73e50ead6584c2dc14bb637a72af66855478270451215ec19f292ad25775527f3a1cacec8f1470a7abb8adfe59445bca3a047236e5592631740503e4b1fba17d8a1e1815d416fd4b02c6e65e4105c5168e2463d926d3812ae84b5e36fde1c762dbbf577ded3d7066c72fd9c0f16340a18f779fda1a720b6a1f7ae0e4cc0d917b95b70cedce94dd0ecdcf080f03e4278d676b66db7fd531dc18de02172e4d24b2b512d368b9ee2970f3dbeec13b14427b3d479e764b4964060b459c4c20790a26b4e7bf2c0512774976d7191adcba4788f27bdfe55e4b27d64c5e04d3ea36f2420a3085a2dc7aa5ddd10111907926d1ccf9d1b1733596559b8b1f4e9e0f897a8a3519bc4665305b1b44974f33377ea6d42504082a045c63733bd10d2c8b98da8c1fc6606b1952c640b6fb2e88a5f3288b7b58e576bb873d5f2f9ad9be9ff4dc057e6644187f09b8fc434f125d5bef554928f7d89bac82c3cf3b73bddb86ef602d86e587bb4b5ad301cdba3863e7413d4efbbb651c9a614e7ac80c83288dd7056f2dbddd0e5eb85d7201668215ecee328df0184efab758d6728df963655ce0ed2b60b8e8f3d4f871f4799bee9817b53685374ee9646a70717d96c45d0205a9ed2d45591814094c1bbda56751d571c44107178e882840364afb5813955d5e00805b702d9cbcbb0700989f434cd495ae5f7208fc3cd966586b70b924b15c85eef2dc41eb8240742a0290304f995c024653aa87d1b11072af7e4d6636e33cf0877ff3480526814180a044f4bd33f96968cac22c11646a752aef7b0584c2283013b44973fdfad471c77b4d220094177b9e5db0d590701b6b74c96390125e2747cc9888429acb054ddc0d29c54952ac2c2bbf6ecbc593685c6108950175a58b8e8adcd02205fc30771ca62488a662f4441ab29baa0c2598d72d204c301267ff8820dbb9d59ee5776e6efaba5c41fb2d471a8207afc66db5ef004320395da1d19e8015d09df84fd77ec2bb57f626b2e80d41b644c655a87cd0d8319dff5b3ab25078b76a14cf24c2b6264e23ddc87fcdaaa51a036d4a69d1c8b318b5724152ec86776985ab284d4377b3e419b2071437b12e92776b6eaddea0cdd3c11d0411a361e02239654c3dbd3874bb5a6be8e14a5d996e4c93368993ce3608f952cb1248027dcfe29ed9a3f1295ef2e19b2b06b1f92c8790bbc04c700f76422e9b022a2f196b1bccd5474607e446074bbb7a236b2721a52a1a7bb85a6afadcab0d2a9c9d4485c7281dea464db3f05d7baf2841aefeb868c35421bbd189b1dec7fbaf3737d92b4dd5fdaf407079f8b208b5c4a09ca7ce43b887ea0d014963258b255ef261a2996bfeb25b7e2d873b952035a5c1ea303f21ad4fe4508539d37e3c88c38a4d9477ce1e1dae7573dce08b83d91ec53973cf673b3b938bbc58b5c11d62a0bc90fcbb41848793337ee3859857e7df2687598c323d0e3d1ca8c0f03b70b3a96423eab50eb1bbba1071d92a1b942ca94a6cb1a59b842f7aa8b9381dc67740170b56302d73db14a9919f992108252cd6024fa7bc420c8aefc2468faa16cb1cfeb3f5ebf164f60772999f5bd09c0440e22e1e78d53da0b64326852c70cf7fb41289af93633f56960f4f0a8a985d005c5669b1162941af9ac36a301378d9f4c2d479dd93d31e2b86be1c15da8d972a055663666a87dead00e0d936247b2711ffd39b3c91399af27d9ab5b24f807737a7f56bde0a5cbd4069cd9bb3a9afa84c60d4ebd258033f59382e439871953240154190863dc6dc739a9604f73e267638bb72c61dc16b99f256945ced68b1720595a381711f6338ec9e5b43cba9f4ee8625567b93fafc32e81d85136f3e8e82faa7bd60ec1dbc2b41257d9c0fb1da2fed7508ca644865b489cdd163662ea4f6c37b09b0f9ee3294addd0b7d0330d76bafa046dc6fd21189730192e8953d2e97ca32c370ffbebc99f7127726f1aebe038ea949a7b2b2d3df388e881b0164b22fcc4d91d34ce1c063ba606a073e4e052246b752974629640c8036a5df56f0237fc6936c6f8e457c481effc9b048d41f0ea924e970ed4f77610bf6b18f17540b996195568092345767887c8414e113158aa3634115ca3905edd3d1a0079d4362c2ee77acaab34423656fe29e6ba021678db3c89d5c6a8565e9410679bca1a82aff39fbd2a7baeadf42ded849a649ea2fe60f984fd134bc40fc6b6724963d248349d67df0e61973a5d5adad725ad062dc2d570ee81b78ce352033b5fa87ac4614c4c89aa14d7b75b36e75272d296178970ee318d567c4fe7f35ad32fd167511a34ae75a9002b39a80a6fd3d6c0fc36d5d4bc0bfbfcd7f7c4e54155ece5b865c7560026a65a3baf2f9feccc7e9e79c7de0fb40acdd2b80af237398fc410f795e4267b3ab6ff168afa75b4f398bb36ee4794cf51fd9b3331a8bf9950ead8cf51823ccbde356e4bc73472b787b44d0d777152157be50604d74b507ff4d331df0a84d38397f2960dc6dd1f76152e6b8ec8fa44f83a7cf6b7c9a1bc929e484757c7bb6375b73622d3ae67244e58f0ac3160e4b03f12e058db77ba258bf01d152caa5c2cb804dcfe303d1ae1e9a335166f241b1cff54f6ef330c5c50a88066474e1192a4a0f2bdaccb6d28c1bdf6ecceee8e825a4f1573fdde1cd5de981fb0588dbc94a90309e15146069f5e506ab4abab38b0b1503e8dcf114ad2dbc49a45ec338b729cd852c0b466babeda71917562fa3b051c724f8e85","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
