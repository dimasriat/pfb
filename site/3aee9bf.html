<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3210d7b3927d32d6a00edef636f680e3c1427a6970f32668dfbd8c2ebd09bb7a5fc550648636543535a8d2a0e204bb0bcff2ff6b4367c7ca23cae04f9828cf5c3c770958395209301639a767a1d8d0116607e01c239bc2e373105a5348c8130f147195cdeb8b3b9b837f57a525d91ac944300f46d4191bcc468bf03da81f8dac9a8e8118e08c1972fdc15f54e6f5d83723c6a9e1ee72a6f3c254ff895bc2c9c0e868735b8c6e7b7204b062944316bfa6db3c37b9d97d30407ad4766fd34408b56f442255cf3b2c51a31547d2f24d0e1a1b4d78ebcca75e575b6d0fbdbfe80f159b3d69b0baeb06a5c6b686e4a583d0f46d74aa32c2044f8dab120b1afe2ade08b09753a779f24e59b45f1140c484b0f97c6ca561da56c42005ecf74f014e00886213e8385fa49967f6e70753b7741bcf7a43955228b9de57f8db2d2f3acf8fe74d8688fb3b963161fcdbd2582b6ec7147e3cbdb5eae5a3e88899ce90960fd70baa3cfbb6e2ee386b2aa862ba7548f2b69e098071591c97f6cc01e24575182edcf22d8fbaba1019d5567b12b69dd3d6c1907f9916be363cd662854f78ae01d6cbc3617731371b59d754bf1a01d685da5ff04ef875e1070f55335960d199e1fa036d7874fce709ea3e23a7f19d2fd5d19ee9724e4e958d08a7634c20c1f19107248d4840bef55ee3109ac2cc8aef6af492cbd9216de41c89e0319d243b8d9371c65fd9c1e470df3acd50c2079f80a0db14b3d7c47c5b17d5f445b19336ea21f3f96640944de4594946de511fefe17f231beee2e6f3c54147c4c0346de886e326049eb52e1e10633a500216af10da39fb675ff9ccd3d4ebaa746e87d571e03ea2c08299a6c1227c3fec970d5b7cda5a667405ca5f2099282eb2fcf5f5a3571e995932cffc9d1c6446afcc33ef1e8caec1187a78c8f2c63fa04db8956ac703960ae064998cef3fb87b68f649743a2a85d64fb68cfd6da1c3d89f8215a882aede50344be46b4643ac8c3d1212d68db8d702687c33996eb26519a6426ded326158ab8dc1956b7cabaf07261775c4c470c0e35c07e653974b3c0e71225a75983878a42d20026bd372bdad3b1f16c9775e2fceab39f1a2b6789f8a7acdef74cfd47c211db51811ad94a174bf8b90c8a8cd83d3a0113d9bebd1925c0e5115c7ae1b9900ebce4ac3919afaf1b8c7a7ec51a96d994edbe3a52e9d5cbee8edd6e7fe38fece5fca803fbbd548680794afd608637e41f7f5d907fc2f6c6f2155563e18aa5989e580c914d48a101a628507e35654a07f2039e463fea05938f05a24dd2546371f8b1afd2821daf3493b13c15739838986c62173bedba74d7c75ac5b8bc75918f61cf85487e83ae901726f3d513c089cb7eff4bb3fc392b3aa7d458893c1c7101379ec83b6b6441086c0cc6f885d9990334ee844846eb741487de4d936d5f69bedfbae86cec41bcec8d298b4095a1021bbcd453973942f642a95d960eb45c1e5bc3c91b60a1333aacc1ac87ea08ac3683282b4c6ccd152c699b0f9e810cc89146dc44490cdaee4cfa5e4963805eaefc86032922fc43e3aac5ad8dc4cf051500c68285f83005ee16c13b0b9c48966e09c083b4b9af8246e66f30f2de84e325c6e8bdc71ed42532b4b4d1863202fa946e48ea83c1bb9aa5c05940bb6d0eb099715932dd97d6897d6252013464b973064d94acb8f0af9c4fceaa8e05a1418e8251d31fbc199dcd126fd6a4d406d6a3c486e8b6aa10bc5ce0022e4bc0a7d95c993a57694f548a1c292157d0e23eae4ac87dec89f489b2264c561cd77ee56279e40d233bbababca24de5590946df4df844216c05be90a971e0a7f9f9be239bd63c5a7e6b2e8274f38192a2a6dbb0e549529b885e7c92bc28b711ef7aee6b3b7cac15bd1a4e5cbc6c89cb1b1858651747658e52f13cd7d756781160acdd83706257b1f9c4ad0bae3ff9ad62a1bd204b546b15bf3369d093da53a7c0c196b4851597dfdd58b8fa6b137376448103d49eaddb89c61cdddbddd822e9c83cf24a41ff400c37a5d2c92752bc422b5c3739c670bf888b1f3a47ea41ffde80096a7d92255953310569be7ec66ffc773c32e66c5ab45998f6d694f3f3c4b45672361a10f07595200a5afe118857c386d9bbde5a27cf067f42dc98f2691a12fb6aa38ab32109bb853946bcd8dea988b02854ee07335293be5823916df58b4de6e7b89ae0b641e0aaec36e88b328966d41c959414d0511cc630d06c9646541072908165534cbd4d18567128518a1c90a73177ebf993db4143eb8aa32e6480387e225f286ed204b74063b5b8307a3875610bf7f5a24ef961d2ac78f8935d46c8c3c4583f404f92282ff5435a677ade92276bf7beeea73ed02b7f5002f13df6fa0df4c0d8635254b027d2091bb70c8e48193a11752949e4a9b61be15b0907ee552ed1548739b19beef8d3b636ae88dba9d3f1f4001107ff0eac650ff1b40baa070a46423abbae4b690a4545d507d956cc1899d55c710d5ab9b88e171aa24b48c39ab727ace634d2b9b4ec903a06025e72686fad24a3691991d459d8ef0319fdd3d3f4f38eac3340f5e452203b01e8228f466c9e602ad94cbc678dac7e1033f215b95bddf27803258cd82b7ef947bce68b4009267ade6fbce35fb303cf1778d536e49f72bcdb49ea57af6048158c4d860a300d5c3021b89159e1e2d635093ad200a6427346ce586bd91cdd43073c0ea4845ffd50ed85967b93e5192bae70663f5b5d89398cc856adc6b74fc695cc85f00aedda4438c4673d84f6bbe55257186e814e614d7ae795ad64f990bbcb82bbb6ba475a94db8ee930098c79cf885a381297dc9b20f971ec89934077fc1fe62118ce8165cb13b70ff609ce06da9807fb20ccb7beb441b52cc7e65220a782c94ac740b0598ca7cb1ffab1dd0c98c21cc96e9b9702a68681e35f45505922a619eec3db56f97c0a8c68bd838e72f710f1debe425f245c0ef66657228df5f65b3436997a366ca5633c7eb8e28df35574f28a39a0c534c6796d39b0c43849ea25cce019f2a959619f6946d6b092a265a7e01e9ca33e12eb8be58eb245b93c38c0a85a744b6bd6b383f94db194f42d6d415311a2610e218e1ce0befe2fbad29b71f111e06a87ad4564552e99dabddc38f685e7355579d185f1dd2be2e2c8fee705d6a374034f0b72812e14c6a9235869a51e6ab2375c4d435a21e4c2f9d521663b0e17b9b82a1ef979709ca7899672fb8171fc9782adb07b2e4da5c68146bce046c0c65a826d947980836bf04b2a308927acb34cca3ce1649164f9e5eaf863110ffdddb7e014a10efed03e53d9ece43e437cda89c66004fc2ab13225e06cf841798efeac78fd5c349e5294353e482b2ca6b3888b53b8f9277e749e7f3dfb0346027933ff04b7c0adc77e2f7fb4c1ad52ef5086de8319f111beb6c1e405130e52b1ba3771717b1f4beecbd9a000bacc485c8725d1454313ae0469bd1fc765123bd4f1af5e2ba364d62d8b654c0139a0374b26494278baa46eb567a65328a9427960fca0fb14bbf5174ae5722728e5ce40f0d597c8c3d0bcf4eaa1d50fc9cdba90204cada967cda8089a4f4f488a9cb159927efd13fccd14b0d77befc9f8cb2275456bc4b529623d29774c0ada2a1b848607b15d03a94214b78dcb2022d32be09391ecc80a78eab6e9d01a7218e8060bf83417927b1c77a89576e32bfe727d26c2f68ae72011515eca397189b173aa982c70a7d9158aa8cb9c96ca6346eb5dd5281dd37fd5095e232362fb2306fb9a57f803853308a214ea933e03de9dabddbd9e35b1b0f2a928b0c7ed6d0ae98f6a91a5c43c8db4fc86e1305953258fe686906e4b3b9eb9911d73f2e52b7d600f6c8fc1eb23c0adf7857653b15caa9643e65c10200423a4f86eb8988a52c0ccaa583fd7446aa0abd6d1fe339ce6e9f87c3934f8f54add0d838f21458f277ff73a7fd6c574dc7790bc6267fda20ff97a6027333b2bf017060ecf5e0f5db5f0ff60e06039e99ec95096d844c5d575181b5a4c27c646a9359b72cf3c67ebc85664c748f3a3212ff22fc2114a39834d9e592431b2f5405cdbaf7dde5bbee76ac3b27f2b82613c37b9bb0bf204303da9eacdf0994c4ba9ea4db4f7933074c180fc64a55075fabaea9377c09b8dee03002013bf6aa0402660d7046654fdc7cb8e46b5f0026015abfb6891912c6d48837ba20a545f881ed1f6ed302a9a838e176be2493ac574a21afdf9f6a4d6092578f7c5fce81129bfa412ee4692ce421b430b2e5baf9adc276041ce7a85e3ce756b8149a36ea9b52604b44128f45dfe99aab26a7ecc3900ed743b30752677cd9ddb6137307c8f59c12663245e3ad93b17bb3b0cd96b12f4a83977011f7cbe4baacf3015ea577c1578e5ea708ea3976af9f044df8752d31c6aabd1ceff93356990c684933975abb632022bfe815b11ced0e859e6ffb21b52c5cd8d1a3cc0b18ac97611663dee2e1c787602f8e6a364033382b35b15723d6d4c26b927d799dcc02016418c764434748b4ba0618ea4f767b72cc8da9b6f5f45646e465485213b40568309aa62e1cbb0fb8ea92dc4f8d858118f544288d64b8650bcaa918afedf0c491b133412b7026c633b347ee86d528a603becfd9fca2dd0ebae18f65ee2d34116516c55e596d134c18b8b0b5bc20903255806d59724c958dec378786440cd5d1b0ba5df4439c658c2bd9a2c28ebb0344da04d6731e5362fd5630d7ee7a086d2a48f9506d090383204d0e00cef858c48432fe1eb1da7a15c231b2cc07b3d9d93dffd6dd4bf759a72e3e3bbd3f84af97baa8901b684537aa56b40d59a3ea84aa4b13917a39f724b8e86a4f5f42ca7cc86246446545d5845dde65b620daecd5c0e4a6f3f4f42ad7c902fc1b68ea0c76032d0c45ab3aa5296aaf35b6e905a6e4eacbd4ea1ba6b5c05b09532197620142ebf1ac764739f7e96a0bbb20dc710e2bdb74ce91efbae444199a61eb57b46212440adf05e7e618f18c778328062d2bb5050569e92892de9529322d686aa53bee7d02e7114b16848f053ffa9181683bda4fdb7060de84519165d3c790348f4780274dae3e06cb4c55178cdfb9bf66e125c8a17ab46ce46dbe19d7124c37174c53038dcccb4831487863b19d0fff87eae35509e55af2b14802f53a8b850a8da4ace24c594bfbe67ffd9b7147f8b731960ef2fecdf0196be6f5e27fdb6d6c0c6758402b5c2e1f8c836b9868a1cdacda4f8bf0ef1adb1dd5313c8b5db2dff878454cc463c17a85c0c200677243c0d85099226e2726b05c581959defcbd81ffd60f61d1b0f36d242823f4bc71ee02368090fd19b69b1deb797900da34d504d1856ec4e9f6ce970ac0141238b9aa098ba502cfd1960888c26efc57aab932d0980a6656756b3a9363f58cd63864b76992811924f1c092b73c68ba722876765750d5e1930e22f35788d6425f55fcb4ef639c6247f44a7101cb304d4384e95ade082114c00f7ffa636f5ce4a883ee5600dd3b1b337ed7b9723e4c6782a8ecf7f2912a9fb462b502aa28aaa28b2ec9623328327b05f7651d09b6541c1af6ea85f427f2d0a5da537668342632d034a63603834328decf0533a66d98663bfd200143dfa67df0c381c7452a120dc78c98533cb231cad188c4801d60f02b2777916af7f5c51407ae27d8b61fdf15d802891d28a5d0b9fd56ace77aed965900cd6dbce4f7909365199f4d4dc50cabb6f5a6b7842b095abb99c80fc4089d4d03e4c7e9c12255e1aac5c1c148d3903749d1311bee815677a1be538089dacfcf9522df2a9db61a8b761d65be3854d43326145869d2db8772e404753c08505e97b9f1b3cf7db79b60d0ed9f44258fc10ffc1d22e811b8f214bcc13ec1fe0613938140d5e36103388cd16a25e69a6266222d21e87fa60d1a87301ffdcbcb44f9b4f9f4e906f25c35da7b4bffe6076c4c18e8f57202201286dde150633b1e09246d581bfe4934a9e6ae41ed4b9bb93b026855bbb3d0ff91e13f20fd8728a92dd6113420dd2a9d5c77c943f493b11568a14009ed95f1e10a2c6d242fb14922745d8c6d653bad966ce7f5873410ac246a46cca63c817b4c1c38c5fb2d97a3d6d1c8f0cac92f158d3d906cc3a47f6123affbc496ecb97231c9d2fcd62400d9fadf6bc480fea3fc9a6905ab96f7e76051e956666e59f0dea03001d0ca43b8213c811e0a3ec8844679f3820a72efd7d448fa3adb6c6e084efa96c101bda2110a71d1c899a7ecfbe74c27c70b4bc92617d7be0878790789dc7ef9d19e999da7de01d234ef171d1be247060fb15c4d27f927e5ae0a97a85fa79c12230842413c00575e7fd5ff2eafb5c2a909b3df96ff71b8bbb35f4834c25681cb94ea5c1057e7f0fc7ba693c11b826d3c1168379608c11bce950a00ac77e82c71b4f5147c655571d40dd74c86956a8f833725abe2217446ffb6cf1ff47706905f001714da55f63ac6a687da4c085f24d0e36186cee5718874ff74ec56a187e29a8dcfd91c89aa0451aa26510764deabf904c987cebb11a5acec13074dab07bc62740a02eae1ded59dbe9e981364f5db17c694b71d5cb366ed47682e147d4a887cf6c5839714a42e4b26e78bed82966e57d63725c47b9bb21d5b38027863a44702930034090a56cf141fd4a3c7d5e33f03b6cdd86679827f3c8d853ef523a5ac4549d498f997d3ec823d0d6f9fa700674a1664394589a5903772bf9bb2832aa9e5689825a292366c7b4e1b306bffb807d98caf41cabdd62ed14a0e2d4c449ea7a107306602bc83efb460f15636b5ad18fed6c58b39f750f6be5e2962060ef5b30be3acd9d13f22ca4b504647ed4d894e398ca6b6c130bac02dd7f22ecae23af921843511b31fa34d3878831fb51c54f1fded6754bd0e9cf934fd2e4ccda68080bfa9913733acc032fc86eb80cad9157ef9d808df3d437abc403aac04edfd2a97c7758ec212e180902c48e78b792cc0884a99a5adc363a0623e1140c33c5e9e2bb6c9352d2662d4d6c6a230563f7a7b477c716b20323f7d88308f54dc33c7cf66e77181fac9a9d7fb52f93dd27eb1c6d644d9864799a7adbe593b482463164f87fad5b0a974e9e79d47eb8555da917c19a96c5b0d597fc02a35968b8df58f251c446c9ae7034681aaca0496cc2a2c9257914276e55f46fd54986209065410da6cf5b4da2846ecf422c98a9c0054f0b4a9bd8e8db142e82dacf4894f666a31e34d38f760c54d2a6fb86f67efcc521f5f2b162626605194452e3fa1d7db631521ea430546479d212d79605f34ab2d5782c2ef938037d1ad40a5ec525767846deaa95de5eda67b62fa431e388b441fe155222bd215dde29e367fb38aa8c26ad952eda7f1512f05c1615016efd6816a1edf33f68b7d3bc8617975279e6bee23965bfb7110e031ae82831ca121fd1fc315c3a0e8631cff820e15cbea49e7a123f31e7161e202b6fb5fc9e9ba8ef4a894257d5563d06249a9153828366ccf62a54f0225dbbe72d7cf11bfebee95870c2d5472e094c0cd9f66d6701defcf8c52b499e7f0bfcb188e4f6cfd20d955798a9a4a6bbe97fdab8f63eddb5106c98b0f8e576158d707925284d838fa91eebb6625ef9afa1e053be0cd5efdc19aef85861fd69ea99b3e40aec81985fc2d68c2a77bff9845d2bd855650c4eaa57a1f3bd4ddb790b9d586afe215db85bcd2bed961c88242166d0d4ecb59a1708fc300737602d2cb00a592dcd3abb84f10a7226d8714ad816d0e59a54b1757a4fa8ebf3e3f18cda03a18a630c438f1e3969bc6cb10076f46bf6bab92a660dc59bff280f4469938da817ef26e5971f9ebed25dbc002aa95455640f103d1574f810b3b4c3647c3a6b0e4d8711dcb87b2556cd92c05278a13c120517781694f784d918a91b5b2d8ca1991cdc108aa124155c412a2a5c1a752db51cd1abcb1c1e85b4e2c690d08f036daafe92685b926a36619e24772b8d29b3b7d1540b02abd94e31cbdb6a4c2d507e262580ca85b2bd9039c785459f2404478eb11d23c011fdc55dd66e62a5c2ce914839dd17102d8c84c2383b63aedc828a7c4a2883142f91ee0f81c73e566361374a6dbe010f0fd6b10cf06cf87d82a593bbbc5aa7e8b3ecbf23886f5bd28423c4efb5855050dd778e79d41621eaec61422944d752dd4c9e920797bd264fb7eeac15a7794a16baf69c6457cb7dc4b378f1aa4065cb26c4f058ba7811041023707b6b98b63e60bb2532e7f9d54daa9c350dfb0dcd95e75324877e6342eb1c5fd0160d128108d4f27b873f5677d73750cad1bb1c278bfa21148ea55ec0942fb4a8527ae76914f1cf777866138206a55913732a7ac6b0e3ba4ed4022316ed411dd726c316a8e6ed6d8e6859a6fa6baf3e18765b4c1dc389af16efc53fe4028bfc4c7410b01c26d067b356e285addb519742934414cba7287a3b2de0cae9b2c0e93120019e0cef33d6927fc37b77b83d14c4181eb028373f018d2676ba8a88e1b79847eb5e58748d8dae630ec79558daa4273e858f58463ab1969139c5977c6bde23e09cf4a21cbffa10fb18fb13cc8b1b46f1d13f0db84a2f7db269555e1186b6fad4d881708b2f326e0fcaa44fcd1950007a9ee36f82286d4b40accaf310f0ee7614773b0ed17d0804c0b6189e786fc3201d7de09038f6db38c1a90496d2cc963a5e0de338757adb7a24be5395ea1a186ecec609dac6e33583aa0939a6981924229c41d89cdc6f5a08f82b2b63d745d9c442a5d53272c48fbb4e7ef8e70de970be086d34ae23a1db961977a0f48440db3374e68258516adbec175558c2488098753e64c46979aa73a274f001f12c393dfe8e631c5f85f0b3eb80e324466ce126fd3a637b61793ae2c514fee01a2b982f1802605193dddac25d17951aa9d39521c712f0d89c50b1b0f031b5d881ff0fc864731ba72885486be2d3cb93d9b45ad7cf786d9264f50e1fdbd17ab29f499f2da95acbb5a9506a22ec665fe8fc85f040e2719a9ce35fd8f2fdc2a04cde2a441ba49f86bea323072a23e4810a6a66950409a5b331eb2c7fe62c9fff8f16778113df337e67364f0b1ec708804ec4120ca46142e4aafd51a378719e344c4c8d92e1c40e649a0811f9f53e8f0ab1d9e15ad7c14b8e4a0b4ed4367cc56516a5c90d02575f6f4addf86f5e5185ba3cbb87561872829934e92a6490e32de9c5bf5eac952014129c0ed86a2acebfa7b214da649ac6b21413827640c28ac4791b7cb3ff06d815ea9162242dc0cbeb524e97d6d3acd59a637a81a7ac9c0693b8a6f569642fc7119f7eb9b068ab7ff540419b9ce407bbdb205d92b1a72b02ea15b2091d3fbfe7271cbc6a4ff5049e69a53e65a8a4c88c4267a852f570137fa332f32a1c0e59266680d580fb956c574b6ba01a7cedd9a2ecf625e8517451ae7cf9f82b1ee3b12af7d43aca36df0660abfe8774c531b2bae8bfd2bac98b0e4d1cc97a0332a6bbed89cecffa5c93d9cb6ce902983397bb05a34b7c2519cf58c03487e430ddfa89d053d0ab4b64fffaacbc8c9ede1c63b81b8d008ef77be8aba6bc7dc4ab2286a9f90aa9fb52d495cf22619c638384a2abe38b5d510a8c3bece4474b78a7f69cb0aad4c4db6ef212026c967f94f548df39016c1e35aaf5d43bc03129f18a9177211bd805c2845d483df290e1c8024ccdb004456b685b522587b8c7cf7122a258925308b619b7354ced0e68351cb6263f1ed87a2f0e21af34be203f4b25041bdf6cf55fc199276192a9e198a8e43acc253a26bba19216cb26b4e27b3d7e2e7484ab30e08a2158aea1799e8fa9f7a6edab9c4e7ee1a9d12f2040e6686e6374aba9b83c35832af2d57c4f56e84e68761c601c5611306ebc2f74f15b7c824345a67fbc65e56a615b220fff0c0352355d5bf427346f33bd40080b1586581a603ff12d3a8651672fb272147fd9690f6adf656231bf0d0ea1a4581f1f5bb4b54c6080eb113d307226f45b65ca5cca9e18cef6c2a2edbd3366bd4f272218725f884e524df92a52204573f6dad9ab3dd3fdb2455245f4bc7fd73f195ca99a612267c1a96b1bec430b57b3d6de04d30eeacf0b1ae2044e1b5759545e1b9d43a6353e2d21edbdcc53e1a950bd392a6a2e3d682c68741b1e94e10b7a79c3486e267ad074eb59a8e81116b533fb9688fe83d8e317941bf12df593eb98b3418fc58b9875ca76c52b2e486d0e90732936ce45d0af27d4d8180c78bcd4f8925b8408257045c8952429e6f57e742fb8f5034b4b1a9af872461eb98b8283febc04350af4b984847296da1549f96c8f70871ef4a4d6809b2bbdf2cb1b9d1db0b46d6d0ca5b015f8940c4b7b7050593481825158e006c0c41c94286d847def4486e51514138fcb75965277532374396a098d6c06538d5d2d9f13ee87d0e3370d83bad4ae9ad34a46a5ab8f4e2f65e9f339ec71382c07e699cc29797f099210cfe536038b14d2e0b729f937dd4e12554992667ecd977476299d2164d859aa6b4ca659d24f8a01ccefcb5d272f90d7d7b85e4d315a7aa3ac6661de93935554c33cd251a854b8984d4cf7e823d05217a625806468f5ae62ccad33757e49519b5526f618e5f0c93d45d41090bea2cf5fe8afc8abbd5b4a02b689620eeed2a56011943e217c9a657ce09f596f592e5060286d31e3f6239429b3ac147898413ffac4646009a96041815553e05cf33ef7841fb25587be5e42e12c159ce2b278d32a9e31c7ea1f9b1afd920101a83d7d19499aa40463a46b6c327184b5c8d921f41d6c0c559e90288cb86cd1bf8356c63568985cf8d399b654a649dcfba71c2ddc27b54038300d3921a287f07f52e40e79eb8720c8567bc7c2a1f23c4687c8e3f29aeb9bec15f15cb5acea0a8658316f2104fd20f8a3e50db4628df52e7e03e573bc9bf35b54300c54a1e7027851c460d1e3f4d923a056479c0dde3bd48e37d3c1c5a149bd92e1afa941ebf8f431387077188d2505d1e108e83cb2480a3b93e26c24efcfbf00b2a0e943abca3c8d3e9eff184ba1d61c691a7ea74394d9162e4862e1a0e26ddd79cc1ab73ee9d0cd8ea7747ad89a80b13dc46a304db7a93104bd0a379d92e41697520ea8019b0a9d9739a061434a3df18d6862e8f069b2c962df57bb4e1bc0efffa6c25ce063d30d6ccc4ce51bb30448df2ec526d43a7995eaa9937040dc02c332ea47537f8984ecae011f0cd4db9ea27d4fd8b1f9e4328ca63028a8e3889abe540e7849b68a38b797665e44698c585d3aac1c37ba57aed0e542ed1fd5e26cdde085fd47c5c791332ea77f38557d07e07e09ef38f9606d0ab0eec3cb3c4629c97d70dfe4caa7a0edd31b5d7d701ca8cdb4426f77a8e8f1500c469f86118798263300aa8cbf5b861153c00e4bb4d6f2b7bde1cffe1da2aad64454926794c740d7a2c8ddc17d0842ea295548c337cde807c52a9d8a640fc5cdd3ada38181b977ac43a45d91427f0a4dba5477b47c55d38faaa1d2ed7c3c3c5f2d4da7ba6c003da87e9c2d5c4486046c966ee59c9c1c21aab48db95c8ca5ffdb91c073ddde084d1e4be3a9c5c595fff369a97f5ffe4b95acd573c1becc5e037d4bafd33d04be752674c06932fb580f7a4fcdccd937f7d1fb934084a1ac18014e98abddfda3b62f75f946be94de8ce61b57a77de9082d238caa69234d2a6a30e6489b5d2ec14028c43384a03326af306662228dac157f06dde8fce78971990f2fe7b813d18d5e995565c65d71612b70186a340a19b51a51f4c60048011b11a6c6e738501740e07e19885e1674b171577917753947dbadb6360553ab34a6ef982cb0bb55ea1665f042607f15e431221aa356bf8dc012a01f94e84d88c0df2feb9c933ea76b55b2ab15be426efdeaaf5693ab119d3aca7b9aeccc58eed1677dfee1145fa619a8663db17c6a38c509b2e6a3f60cb5392ef61852be6d8c2199f35bd6a15a2bbcbfecf5c5bef01f9bb84fb933d496c5d17261e12b35faf8ea8047239b5abb8021b1840086c0eed244604310d157d99068f5159a701d884865096223734bc993470ec86d6996b6ab6bfbf3df4eb222e52c2335765906ba9e39efde448d9e0be25a84efb8ab86d9f32c4bc78db5d06c2f6804ac084d81589c98e454b46ad22bd14d760881516caa7c62911c6f9c2ec8c064dac115b0a6a6d5f78a6321e07505e73eabe8379bc755d2d3afc5f89a147bd1dbe727e7c1f66494420446ac7206ec313046c2f3e15c10faec88519bbdb82f5ebdba122eeba28a68cab3074b456dfa72d6aef360b3013e4e3ae31471b29ad59c630596037da29e451129de633976b5773b8ba2989132e4d1bc0b3667dc734adabfb0e75222c27b5337ada19a5ed198d466f31bab4094dede8544de506f8846630666762bb07b166fa269c2a425f2604f9300627943ae3134d056d88a29daad1bf20a09209a2015f5f1e28d8657112bf2a969ca15cab843eb7281a7fc0199a32903f41a942847e765269efdffa8f07bc660f0b73ac00c32ebaeba0df6e1c28ac39dd4d465223ef8f6e7f32bbb9a24482d8fd44511e5ba97ecb114a22aaf8caf7010ab35c43926f0b5c88ebd71bafda8af2ddedcd844fad4b656954508586eebf128d1ebba0ee3d68d9b6cff51ce57a92a406f4aef1e9d846f9a0bdd03927f8b17baf5bbddd351129de9d2aa1fa64dafa86f32f4b51951822f3f6a05835b7b3b614d61eb3b2802e732839c8a44419340acdbc3d81b425f6c442cac238be807b15405781a6df7a53fef32c61e600ecf125e7c7f6396011be4d9e03b94e5c834aae31c7332d981ad2d4df9ed8a44cda2285257c94063b6aa59b48703e0b344e88c2af3b5f70e446726d382866884a8ef646e4619f07e5dda9a9579f87993afe0de71f61d71d7462143eda5f0d6a93dfc14a3fc14477cdb5162aa5cdd19006b847d23e6c4eff9b236b1f60c438629f76d109f51a78aa13b1e834d5afb377835d515055f98227896f4d6886319a6e32ad56414b8e594c5bc7335a899706fbea35fcd7c99492d49c8cda50177cb76e1d619e9cd4cbb782a566c194dc5fb07d07c91ba99446f42297ec1b420cba4c67483d1010960a0c56930859d090cf16ca22b80529792987594b6d38f329cf7d344ea328afa21f20bfa063b0d735d4528e4a7e2a25560c049c855a90003595cb57f8c3166990646030f59bf6ce5f024848c5e8b5052b85cc498be6249d334c6324b95c9a38916631aa0d6a4c6af6b3820e6a0bec3691df9b54223e986a181909ad2620f59bc87ebdb2228f31bca300b33b96c3541948e72a95d7fb55b372f9ebaab6197555555ace35d5857d9899e48568fedc34f1e040db77994ff48f867494c9c204f8a13a9f35500ef3867b1ca3261c673bcef4d5825aa86257a35357e6239c0ac8886a1ddc2d7578921908e664214b1f7e9ed16a115da7a0492663a595fcfe346787fe98cdfe908be98d5c2c16aa561113e0f7815f789b0ab7549084d506c69feacd9a160895b6f5b119d769c6c012ffe32d4d86288c86785aa9f46a640e86fe63bb90c3d49fe606ba3006010a3e4c56709465dc289c48ddba1035bd73447c9af4dfdda269c4cb34eb951e4cefb2113b1335ec7701176407a355ade3354d463594ce307a46332a72aaa1fc9d8ef8bc08cc8bdf1a0d0217047edf9649db86b2a78bbd66ff1a3fee9d744d4c38009956cfddf756fcb10089d4656f2065dbf29ad2a59040080508a9caa7b53cd8897061b1f783dd73b85fdd765758f55a64078726e6b3e9c056bbd4add3adedce86f20e4b1e34bb038666d647d830b2dd851e75e09939ca3e2e3c688c635e92f87224f317fd45310a57e8ac68b7553ecfc71297f209705774f28b6c0689a3a772968f9af5910a77b1c867aad2948dc85965d8acee1b5bea2d3ed4bf5c44b23071aa59a0174b3351fe9df1d5e27f3af2f4e3b3cfc53fc762b1abc1be03abc2ee9b516f084aeb858302f4d231dc9a26801707f01c32224386263b36191bedd0a5e55c7a0be747b4c302877bcec84564622e19d59fde4ec4f18132dbe1bea52a9acf0cba7e3aa8cc3b003e79b12c4146e4aa73eb1173a016936a4879b8895b1166f65b35756d5f069669a8b5bf369e4af7415ef1718cc35796fa666937cacd6789ef46f80ac62378af291cc0ea406f843d673972b1984b231b0747faa21fdfc74434836991c8c3de3c5c1e36c01e7a20189e52458b1f79f94b876848ec05447f05490cf0a0ac04e75119e579407afbc77f639931d09475f6a280ef11948121e691305f9916d46728e24d823b8a7eaea790ccef9a72e78043389931bfa8cd869b9317cbbb01dcfd29c0189619cf04f604099c3aebd143c24853561ed637c86a748d064c8e8c9b78bab61e2c02a3e9f584004a15416dab0601eae75ae4d78ee76e2c3f27ec05c0e2b32fc469b0c4d0fcf97807cd00cbc263b1a4f5a81bcba4374f2a304ffc64895d62c972647f0bec7b582a2d26f5fb92a5856b4c196ba2444c0bc3476378ebb13512d03ed2381570a1e7ff482464580bb556702e179d53c095c7153493de7cfe3ff43dfad603b79261c3161c42ef9e71c49b188e756b6f0f4dd30e833105b523730982dcd7507943e94165e55eaf8d0166ecd7b1bc43c1ead4aaef703b2bfb7fc6b29dc91baaaf725ea558421e920ca4c251cbd8d9bf913074e16475f5fe929b7a579ab17371e2c3f0435f029e11133e24ed309156c4d37ec6d5ff6ae1f3bfa5c63fefd7bdba8ed97f15956450d465c252ee150b53116ca6948bb1bd205728540515c9c794d80ea248bf59b8155eefe8ca1c3adbf6ba8a628946a209d9c103fecb294db8e34650932aada06706834a61205419ea5237530e8c0f1ddab17bc91f62d331cdaabb56983a491ba11d295a30a8c2a1766e75260a4767d04e1e1510b7a18de2","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
