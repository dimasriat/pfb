<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df85359bf6f65e5cd812ae42bfbbe3aa2fd94e4abbf2ab1f3de2d33e5f5d8803e902a8e004d651a0e0f6ef658dc301e7324150648120c90a25db4d899de0fa6c05187a38cbbb9c4ecac10b1b3c198581a71bd441c0ae0a1333f3340c12ad68d9cdb2ccef379123ecf3e7e3361d4d5194e9345f4d455e8c090cca487d5f0c25da66f74bf64f861acbe09ba2e44c47a12b2775a1c90c046d2cd5abd6df3f97995715f50db92e25af46481e6f61f0b61091e618a08c3a34743dfcf1a311c127740423c25f8d80fb39327112c39dd6e7bd488d5d7b2516ed8966a002ccecdff0b1d4bcae59c9d4f601f2f766b4e881c9e59c516f9f4662f1bb2ece1e13548a7bd476ea766548779995f05f24917d9320e6ca35e8bf9424c478dc00159ec4c26a1b82f76628f7483f461429bf613b2209d0b1ba76fe70d3c1675a8b563142d76222d0b09ab707295ee75bbae8c3adf6a73102f0099cb8b2d52a7b35db45ab09bc4c7a9dd8ebf73666b63933244e36949310b72b57bc0ce2ef108cfafdf767e5047102249eeafe7d31685f8fa047d369f8ae0110142410c4e9b417c48cad74e1bf71337cedc46dbe672b2fe546c1f92ea936bdfe81fb6e47d317a338a84d852abe3952cd54e91b1cf0e32fa48de53bef6dcf351365e77a63418fcd4640e55a3b1658e6d36f1870f99636cbb83542ea989d6c23bd1750df1e4feed82a5b306bb0640e244e577444856f8201702565bf61ec6797282f82807e8b97e2ab3767604f329ab3c19117406196ed063f66bc3539c2b474677d2c160829da336b13ae6ff4de69fefaabf1fd71acbd036e30eafad7ba29bc279dab80a7e4008dbab520bc31e56ceed1b2245b594882ec6da3bafadffdccfa97d59813a536c1a546e5da3c901a1fbc99cee5008cd040118db2697a3b20dcfd92580562612e13fca61346b31658e2e9fe0b6728f516958677411eb43d3e6afbb5c5401c5e51adc855557483650341ec25771d3b4c35c8cf2284be4a13fa24615516f43f2a402aaeb3e83b91a23199adb39955b00aecfac46df8f35fb506d6f01f97ee7fcbdf20681585b99d36ef738e732582ca83e89e8b8a636dbe649029d5b4c6a48d828c25d683f5652cc77a893d4b08e38649cd9e3055050f231fb29ee3810ff75f581078539270a423a22c2c412ccba7320d5e3336d65d9aff5cc736b50485ec278f7e256f0a6bbf99565a01247436b65feb7d6ebdd47f21f02371a71acfe88f96b9b0f3b1d09263ea112b6ecb5b561f72bf22091233bf1a43c0a224671c321bde8c566098ca30213c0174cfea5fb5e48c503c3b3da43bc9288f3b0586d3c7ca478db7df8b3286ef36e94feddb92a20c49f31adfa4f6904cd22f869ce47844924b717f4d239dccc4a06d5b08b20fef88b402cc597c9368d58366e68b896004d7f17044a546a30088a9e90edcfe7a652957cb1891fab658bbc33e2d6f794238a5bc1f9041f9d24f79a5c758a0f79f263301ed2c52a6efe7e5ae07ed60409810a9a19d7cf96259c197e6fb02ebf88f54ae3017d8de35cab82231b9c76abbf94ecc1c1b80eee21cbb589c90474b37b6eb4465441ccc3bb569c83efabe380da1696349b8e658a322b583f1fc3775d58040ff181af90fd5c035b08ac6c163916fffb8b5e6dabf4693e82d17a1e8dd2c4a788a3238c36120fa31ea8bc1801ebe6ef97912c520385f8b3cc5ffb076c0e9309b4be4a9e314045269453519babbb5a6a32ade89165cafcade9de7f402674d691a183abe8a9b43a024c4510ba643e0fd2d8b30e49ff3c74cbb3aaa1434820742dd74b4a2aebb0cf7a5ce204d5aec22d090d2429fbf88356980d624d94851e6046cd3e1dac8db045680ffc93a8aeeec345b497e0658d22ec8edb2d9cc7b6296f4ee5dd069d139aa9a3b2904ee06765789523ec3f27610bec00e91d7efb64bd451e25c4aaa735da60c1da673adc566533c9cf567c80a9ce358f7c91b4474b32d7b1e30086e01773d5fca216cd3008f72f78a8a7fa839ff3b7aec05ae0cd673faeafdeca420da8a782db6fad405ad34efe1aa95b8e7ef877a5cf413f4b632a9f43d2f62934816fce96c2627c56f28eadc788b4f146518187d4bdb53746bd36b2fea2233421f10ca525dd669a8414d6d4958a34aa42274b56c56685cff8d37f208e63de9dc7e1b22b83f4806ccd22ddd0f4a830161cc4a50f6f6dc52b1e140925dd53822f9f65e25326ee014ff1876304aa9889a250eeb1d946d928a10efc2beeb4f4747de95f4a47bf37f2c3e4fcac349e91a5e5ebb1bc0efba28e37330517a6ab706896d0294deba36d6b529bd95466b1eb28c6734ef6f59e7a393a7888f5ec5821e807fc28a6cc743c457c1e5c8db9ea4459f11d17a1431b5871ad938d23a13d062c10a52ceff51fce9baf7b7d2965225b4ffaa2b32066d5c97586b53d74105c7c1823a024f65060ce2de88e0947d6c1c5c4429dab50d4f95f31f76cf8342e6875d4b622a4532d0da112bcfc251c6f35edab71f7265def28ccc704762f85a4f45f05fc98ce13a1d631d17ff2cccbea1a7ccbd38433eff8dc7dafc2e880218fc4154c63e6062170e0c5b9153abaaae9b9d8c2bcd7a8cd56c6a060efcd88e6e8b2b2ba6b8a3c578058d2e7985214d27c4bf577122f1586fad57c411bc92cd3e09580c9a3183d8e7461e771eda221809e476fe9b2b660eb4f5cca0c7bfd96144c8e5e208466b4ee7c74451a23e8f59b9fe209c62ebfd62bfd0a6b309ad410a8eff0c80dfa9eef63faea47626788a10aae2d2b0611ca1d5336311c42b52383e7016f35f445ba56b1028f5998c725c98f07ba5bcd50b279478125418b33ecc122371968fb4cc80c1b954afdd6fc72fa200b53dac5ff47212017ed864361cafda57e7c436d22891e3f6e089a4027bdb9d3edaee095a6b1c5f6ed5d9cbb43e63f0a88078b1c2e4ddb868b717344084f7c60523a6e6ab77f79d5bd706c18b96bd739be97775e5dbbb32e2de69d8cf89e43a2cb78fc48e2868945651603583bc5f0c02d5eb7f7982091c16baf68379838b2b811cfad2b844f2f4c7280f1caa2d87a46e86bdf16c1da9b3b00cae6f7dd8d84e481c90a6f4f84b67bba146750cfe263a1c89bd3986fc4e84089d0ec6d8a41228f01dd1549526a4d5df1d2285b9a752e2dacf78c6f0985f3949e0ef6e4d632f5718d9c4b6cf148b4ac0e0484c00d2c4d5bd1b4f4b3743e05b5ee1e8d5a1e9d7e01d91995d3acf58dc90f2cd5e88916a12f8b59f5dc82d75d9f9136b78b2538fd03e9195423109f5d1c6010d2939d2dcdfdc02f38acc066fb74a40d71fcb8cff4eceeee89f326f57b31cfa692e6b02d4aa5ac9e3701e744f8956304336f3f0c13d41add7bebba95afe6851908589115c4a8eb6bc1fe573ec96ae1efe19d966ef365379695145b70d887edefad872b3f9c8d373ac5260c6fad537d25b3b244b36167ecba2d50a2cdcaa7d7eb7014282851cd5a7a598b6eb36d4649b3f3f31209a516d12e4a918290858fed2776b850137ac79001e1e70b23683a73babe06722bf24c1854a3a355253ce53bf7e30b4a8da8f4da5b52b265e204696232fe00d23170da4834ef6452cd41860b8f16331f7dfce01e1bee57dc9bd91626fd339a56fdb08b01546d38f9b0fc070d63d2954b73689b61470b417e55cfd12defca68e9b49b2bf4ed1d9a6c7f69af05cb96b5be8a68d777b34ea5b2008362601e4eb4c7f2b262f8c58cbeba1454046c295e77fd96362ecd431cf66ca2a8e62078e3bba8c5a05339da71a27b62b2c52d6dbe2749c12cc185cc41e995cdda2f02d5e81c9ad2e4a2400617ce42632655ce107b0b324cfa9e3cf38d7c131ced8e4b92e20c81b28454cf980fbcf82fbf29738dca76f89258519f4e5ac1cd0e87f4e2c3d953011f362cecde309f1884cf51b021889997282ba4874db71dbbee6a4b3e3ec3c90366bf3b6126e4c15b2ff32ec27620a9fa5bf9cf71e7abe2d9f0f181a484bf6b08093be54997b20fc5b3eb8c0fdfd09f709cab681d520e59e85e1cd862b293cdd2ea546640d7d334851f83e93c187cb8f9268eae5f4ff3a3f0d9167cab065a3c216e4059a65b627d7ce04a1f5a6bc539a99b4088325841b928126918a2eda1954248ad304cbf293bb52c9236189421f5afac757f943eaf054821f3a6d909e4b58af37668d2eb66ebdb38095cf26cdcce5ada40d9136366789c5ca19f00308c55c12986fdd188880ea9fe09f90faf6c3120779ab6590f4e757b8ff499141fde7d4a955742d4c3f58d65fe6595a789752aa1b65f84a12242f95de71fc08ea05926832306202247f4029781f446f90f89c0ed4fc91de84733f92ebd4283f262e879ef89b8bc65ab480c901b79bd7a0639ae2c19e0ee9dd0b5a7404e27aa6ad4699622a265bdb75a647b4b3ce89eabad5425d7c242b661c94e5f182dc05b720ab2b651df9eeeda3124df6c6f943ecda4ecb31da1b284945ee0c055df13855f9b66668c4889b2656060569629686e7a9e72be466fb5a8afd9a078676f551deb90fe94ece1a95a96f0848ca3a4a788f342d0609294bce24469310e710108d078ff7948b8a6b895caf6d03644e38fb67d0e346afd4f10f803ffd16eea7216a00ffdfcc085b296f0ba75fd188fb53cae912c333518cc81959ec7121457699b734aa77f08f935f1aafe605ba5dc741c4569e07ca6f81f52738f909d9d4f9d06941db190aeee057110715f8d84937d06cbf2e1d7d34ce175fa26c427bc780029422392ef32313e8de66e194eebda04159390f246c934493a5d85723c3212ea2364351682a1ab1cf0d8a1d5f8d47918f59dc9fdb3dca88b76fe5f21d84a92b3337568deee8b6c0a18bab5e2107e7c10da7e1af132dfdf63fae5812af80511513e0d8c380267957bb59f8022da2354c154da015b9fc0bee6ac49c81fbf598e7c5d6cd6b842b532f29d0fe187c62c8052cf58337a66059f3d6d52c371dd7f35f636d938f8bd6c08606a42473da1579d45d438784cbbda0c69729e71e9b037a2467676f47f759490213842607efbc56e92988a29d75641041659769fb410f7fb13c95b0c202512ec94c731b7a512b7486bba6a58037c6df3333651348f20a235f8d745d08a172e122b5f55f7c33fd1066d45b0d8d9fd8a742470fbec9e7fe8b52b4e577c6695a03d989b0a93f561c843dc44e9701d4ff61b20dfba35c302ca282ff87d0ad80b5896570599d52ed027e87ee6590e53e470b589a0028f96bba3fa7ebdf2b47e6927b7b8e154c6ad1cc41929a53a8972826f4c5d6f41cb88d3dc22a881936321c7c338d33f91d5663890283ba2e8d532abe2c6a2d42109146b09198ca72492c16f0ce22601219c9cb1c08191d865782be9e202b72e0611239320bc5e7572854b67e538d34d833cfb0ea0e57bf056a790862c50705e6ab148f53e5a26c42cfcf7fa4bcc3626237571ff541f5ae5a8fc9263e8e18f0971744915c1388b3f4a4ddb539d2dfa732adc2028db7e3574ac9d70db5bac04887a4b3e431002af109fc683506e778962743d972853ef00e6515b2b58ec68936530684913a0a705960b7c2d1c03404380a492ad7c18a942c3afb25f3c4193fb41bd5c5b6dcd5966eec6d9229da11ec831c3b810639c744a18aafdb958cd9c73b24c8adcf9a974dff9cc4a681123c416b2697b22c6e2c02bb3e06534357ceba8e19961f43205d1b82132a9a3b4dcdc2748c76347e365ad01c900dd5ac698c7e3cc5ca09cb65c9c6b457b460881dc6bcbfc4b0aa27a5cc7b705c9d44bf55a8f0496374e4c383bade5cadd890fe35d045f3b3bd1e0d5016c1b0dd89736a849d2c7ae2962125b4ed50c99ea22728f665e46419889222f7ba805a9c93729854fd7ecd6a721ba3884d0fe24593b81ae1f4c6158eea79df78a06866976c4f76e393e26681bb6ca7d5707f80f5b4bc61366f408b57bc168e4b86d84e57f79dde490390d38097b6dcf2d42c65ac39096af0e4a6cf5f6ba8a6d4e0649f6f94e78018a637a8fe1b7754b3fab9f0e446137500efef8e3ac67b39b756d328b916392bce314163a2026253fe29de3ab8cdd8c30c23d722e463e0d62d547b1ae8a8c3d16261adc8d7d8be7a9020619f643d45cc6a76897dc9616b50e28f6ee051bb29b8142c3b4c639d7b772c1cd97c178c41ad01b151a0209dd86341138e726cf3a0ae07ac89daa5aa941e28c3c9c884fdf6a36edd2d268773611c54663ccb90672d89a1d6b83b65e2aae3d247fce8ea0f5d683d89c42ab62b8204aa571e6371099d27d9f6634d451bed7950c0df81ab7c6d294f474b138b6ff98ba74ce9f2ce9a3d7483794381d68436c8cddf05cc456b24c21476826c55deb3f8cc26c145503a282a2407b3c4cbf93379174866adc82e35ecc6fc8c4602438b68135a7f9045b5baea4ffc133da79d82658e3c03a82ccf8033e5a00311ee7d414e07dd6960d3196db52c54011a03ab78c37918e536c24bd999d832db9b31b8d667252da44ad6d29805840bd6b069061a142f0abbe81dac50d80454b82d46316b93b5736174de107876a37f63a1c1bc61f4abd60ad1b94e0ec015b93fc7c7cb75eed5c945444cb5e497c074575a091881d3a61a63296f18f0a1161480dffbcee8c7d1175644472de575fdde8862ca8a4d17122853fd7b3fb0d50cbecedbc2145d40ed36714dd27708e6bc71f2e0a7b555d45164b3f4d52acb70a2d4cfe1c1b9ce45e5c1dc81788279fa342fb2179b225ffa05a3a284c125c01ccbf7b5df81233e35e5cafb038f3850e651340b9a6c248b3e50542e2efbbd2d065a1802395aeab16ddd8006753dea4f82867d7028d97ac04af72f16ff2e80ebbd9ea341eeafd2d90c9bf065676a03f841dbfe9a2dd3c77d732f8728776c275d1b069b88039088516a0ab99ffad43d931d1ac70b42307a21e59b6d31a291ee21df0c03b08107b38cd138073417744a8b125a6ff23a47d8df1ae29a3d2a7c0f5de66fc7b1ea8b253767fa1eba52041904509a9df43aa978c0cd2114f82e229f6b7019bc558d89d25ffbf4ee499424507e7220f6c72c76466967071b1ce25ed06995d35af1e5a7d6d995eaabb77b75dbc682515a077438a4ef3c5228bf306fd6665d07e65b892b8112926489ac1ebcff627a27a9119dc8fc7b44a3eb03b31b3f9d9265c6fefc10e944c1d4966781723fb408ec88cf2f23d4712649c9bbcaf1f1dd49fa7cc977c0d4388c0e2ab5577e98d26a0f4b6f8a58d6be72f942aa09565d5011f26c56e56e8979280d140cf5b1336cef5090d3106ddf9fe11bc50ae9c360b52ad8446a06a80c7d00f5e1adf602a055c1a4695379e1d5240ddd7830e1f74bbad3e5bc4c9d8bd5d472de2faec65dd6b90e15bdca9a8e761ee55f69f2c62ea8c2f5dd709f355ebef7eceea8da1e06d74d73d3010c179dbe351a0d1ec637af2251d13827023260427e27c3833afec4a2d2d7b9095865352983ead86d6c05373a858c5cc58a6cd10477ed419d213607527e84220232aed6d382fe6a8ca552367496cb8650b01226111defe12c4ec5d2e039b97e5c436190ac6e7ac61139a7e33fe15f20533a723010d1646d577e063f3b05ab70613a20d014f397977f54a99634a95fffb521614b1ed9eff87540b09d85a6ac9777a6ecf0c789909fc90dee2a23bd049850b77d5dfdd08d782a2058c91e2431e9e047f3fdf3de7abd5b3fb37fa2d924aab526fc0645c294cdb7235871f136498236fb486e8d3696c8d2f6ee3d01dae2f31a9a9def65391821e22992fdf26a0621013668dcee5872ca7e255c38c3bebb4836031ecdeb11d52197bc129b5024e5f7bbbf458835b74f8d61b2fd076c6173fd50fd953323d87e5a49fbdf3869b83fc874f2a335867f0e2437acedb624865b6a5d5d1cd433907449d9670c4a63899b4c13b2a6e8e2accdc9d89921209c598c640caf1c2927c37a7363bd9acbfdd5b0026e7c21109fe87ade148954b7bb61896a2adc7997f60ace65b2cd828a8bd75f01142d844aa49f54dbbeef1a14b5d47bf7d3212fc02b8057ff694f28bc7d2ff6971b9558f711ca9d1626af189e965cf03c55ca90df8a2347c2d03c0ff57a2490c07f6f1cac426203300f0ef05e69b1c08094b4838b982711d56aa261862eea06b072d1672fd130b29f72c9d5d77378334c8f8f659536e4c0836ae31045fe90c3ae5f259d4cc5f43e0921509a1d92a8e8be2cab04690eaae10fa343daff0ec4109d95a578b5f041b4b7bbdc60327d132a882db9c7e840ca86a96ff880bbb4029c49c6bafbcba61c803c673f45168f2936837dc3d8722cb54043fc5949e8a4c39cf6349aa6b4f4c90096fdb27c7c9a7c3659256908db968ea5b5e002526008158cca70fc3c1abe08a53e23a53ef60ce4a26af89c41e7c83f1264b1ab0b095d053829b12dd193c2e7ca2053786407ff2cba5780e7ddc9e49b222bb94b257c89225cdf4ec1a1f1e8ab6fe5a1eb041c54c2708884f6c95fbf21d5ac0684c2d4a43108ca1faa1f60a8fe0f8965e3be3a7ba0f5528a1daf3bf5323cc38c7cc90a0c6a9f5f19bd54d06fa3db0572171c78a4c47b4fae1bd2c31a56a4adb20bdc10a14a3e25d3207212d160a6f5e1a23e9d1185d2d756fdcd22f65234004067e87ebea30fedd903a44fc3a63f474e991d15959ee1f2cb4b266b73bb2205c8b6b15fe5126c94589a7ddb07734a0fa8d0afed98da4ff75b764b2ea16b4a6589748de1ea67589b6aa0e46eeb3c664649e932c6a8fe62ea76747c6b292dba35f6699b31d6279c54fbf6de5c96f51bd86fb73eda833098f9888206d1e29105498fe59b69942f8ad305cdf22aa820d8f6d4b102515db1e72aaa829cd3d9260ad8020464c0a722437b571a21b12710863692ad006180ec1f4a80952d3dba63210e50ed644d1f0b6260381754eec15c408dc38d8f31fdc217a7e5e524ada39725d7c1c0c71d1b80ab4564120d47c7da1ff3b742ef7882c556cdf577ed7648aa262c34f5eb5c0570ee0518751a1d36c184a5fa4b021f17b983c8de3395ddce00a76a90c2f8db4bcd3ed5b40547d43bb03fdedd0a8865fe3bab8ab0f9a2b1d1f77fb64e06d981508ede1bb6dac33de30619535ffaaf68f5a66bea7528510bc485ae31d37d434a1d73af556bb6eff3a0da9a537ca08f659d9a4be7d69e81ea78fa3b95fa359e0cd2be5e87a679a468c38aa63456f071dd3abc33120234704f9a1376090ee31b51f275d847223a89ca6432ece21d9d44f52715e48d8ef030e96e306677c7c6245a5b2d769cf4e792ff7438d17c5e7f4a6c03161b1d7c584ddc012da4fd36d1e850637d5a7cad076d8ae4db49c34ce3f9384b9d8a9575db0adae37e90c165ab5c9d72c64b60064086d94b3e071b298143d94bb7ab4943fcfa09bf6ede9920ecd2aaf14de2834d2f0b2794f6a6332cb7da253cfb3a581ae374245ad15ab2814c83b7d9cf3a2734414e82a79e547c076198824afc8ffc5ccaa17ac59c317c30e86960c4e3b4ee2e5017bd2b7739ca56c36210521ee1a273b67b4f2ce53c3363cf0120d6236c95bd8cfe67ccf2c5290cae6334dcef13549d28662d4db3975dde082b5046eccc4a01812d0102fd9c05b827fbb835f7f95eb57015300ff3f312ffdf5250a1529fa892e955d9697c935b3b275413f6c3e8ab46a266b40af22a5ed077e002c27947e95c8b57a8517d38ecb61c8c32d6083e60df9603147244ef986e21620909ee210e3759d5cbf9e3ec931f10aa35d2c823150a5561d899673e5da1888651063c51d61eff45c3ea4aad09719c90d5fa548e16a72c767a77601f50f90c4dc43d98d1c9d332793521e11f41e181d67dbacb94e92a981ff3ca46328ae36cc7965f38aaa727c82be078981da8a8436df21b5b6967fdaf7d2ebdad2874e9b7ae80282f822ea04770359005fe25e84779e95007af1c87a9ebe6f3de541d8a2a63610a9ce03fb03d9a73d6b093ebbc301fe65b838597abe3699d7f39930708dc0fc9590f41f0fc876b2848c00f4a085d48a1e85614c949318e8d7337170d56dd3307ab9525680d3c6cc55d3965102480328694dfa055d06e86c3453d2e9d3aa52d37b6b84be463435986b5a436922deb9d683187de0dfc81bea3a8e12fcee692f361acd839857047fbadcf489452a87b4db8fae61605dab094fc5b4ddf35fa025c86b278c92112859650abdfec93c9ad5e8339e91619b9d427fbb5c4f024f67d32b498aa422305966e9bdf0605a82f1fadda627e8d54713cb45e3823d461a943cfbeaa3147b75722d0155bcfa45c965e46e8081636db40e7eace4b03f5842a9d0a83ca5fcbdeca5f253120843ff3620fdf2d03716a669ff50ae1b3f585d44f1279a206f02de6a39852b38b9cd29e9d6a616c5e5ef0378d3ce59c54b437a91fd1f4e90a9f5cfaadb165fdf227d1a1e0573ad36a2174eaa22cb17bfc1529d0fd15002511184278eb41f9960496d01aa25b545045af4d8356ca67ac587d626a9a0bed9e812a84bb28ba3409524719a33c3e8a2655db443dfd4e1870f8189a7cf7f7635eaec8b8693fd9726f1f9146ff53089eb7d91d19db1af61e0ef89419877d2c13e882305b1cb28a49d8e91475ee300326091a15dea3bd4b25c66274a344de12c39c04af0db440d8ee14ca555b42a8d2b81b352b8242b08877e3302f78ff406577d0d549ca8a2fb65868334c2ea3853a4a521b7b950b417c0c5f874958105e757483fd7b6c18587153cc38066211d9002ff382da2ec66fab99522c051c81f7b9df7ff9d6d4038051bf49a06e602eb5ebd963ba6f4052216b046025fa161cd34c1a56f74c8caecb616a3ba6974ed35faa95d4cac5b0ed96abf346fb5b8479846994be34aa597f86c53edb66f605bea10a1e6836b7d2dcdae99d53ea74178c6b8b12b3b8e26af105b16f63a8238163ca7bf59d627d78767915e55888c241fbf886ad6d6688ca10934b2cbff1457f7f36fe1291415bca562f81052c35b8ca717cb3823a6f73f6f6ce94d70be21ff0596663812f0cf9525d4399d0aff65a3a7a2eb7048d88a7cf19e46c42affeb9e5a6ced064b64870439a29e2cfcb81fe86503fa87379f5c0e224532004118e4cf5ec8267fa74142d02efcbc827779e3c4e92224b404ce5bf79a8588513f0b1389fcb00ef3eb243f6ebfeef9550bdf3afc9194f4c97be603b210694d770f45f14e1e4d885e6a8e53d7bf77cb253c48f7e1d394fa85f5686de922ea637ea6ba0e33ac3875efc53348453f866ba6dd5d7a9f61eb1a6dcd079010cd63036a717dec3580ba5e4df1bb7d0bd323aebd564efbd415eed5ec1b85d516318c749db30335146d80f5948adc29adbe2a6ccc95780867ddc7fad36c77bddf8d77794a69a46a2ac62ea177a5d7830c9abd142e58edd42dfe75af40d389717636e2dbba4a6ddc8875badc68c14d42381eb574fb4ef53351934e79078b4d42961695a5dfefdc73c9530cbe72f55c022682da9c02694494fc03a571322b1d71546c9a6ac1a6b781d3c66bb9a9c46021d9eb38dbb0def48667246ba9d3cb559774bf8988e6270682d01b28f32aaa4e8c814fe95525dda46dd87e4c15808b0a407e2574302a7bb0a532b3e46a51e21e24f14c85f1b11549d088235dfdb35b43321bb33d9481e16a54fc9937ef632b684a298455230b730e475d3a19fba5f369144090cc145ad9ec3611f32d72f39e852c143a1cb690d19c02bce4220e136a90145ea48b698dded88cb3f92d901674d9301e4d1f54b0e24d824b32df580348d24a5c65181ac85ca81f215885d47bdc71242dfbb0dbd7c12a099775a4db1acbfb4b43ed0552080d8c0f0717fe84e100323b1aae6879881eddf383179c58535e2083db1b8a16f22e72f11ea43ef01d31eee0116f05747111b7649b8cba264f1be8cea76e4dba07e5baa1cad8b3f7edc3dc0e24da0facbfb9a73a43d695313d4880132729b66eb5302d8034db03844c14670a676eefd4cc9ab5e05a8737acd30829ade39e72b70c501072dcc66479221782972ff6c1d39860fd925fde53df09571e8d8b362adc1d041273a6c00d0968ed94593836686850fbb8d2faab8628cc4913076cb0f2ae9ad8c9e5d02bfed0dc872831d568ba4da92b734e42a5cc3329a7e553be48b1dc842d96e90e160ac0d0605c1848c2db747c3abd5aa05cc47ef40bc7086b22691d07080670266b2e910096dad6ce944bc81f7dcd7ff969661f262296c724c365a5810247bd8911fc50deb7c005b9b97f148956677bb0bae78202360b8486372542fca3bd899add09dd45a0a3889c9f354ddb99911c30d15fc34948e5d3192dcd6177fb60b901a6916cc7c0f4f20362535c7db0ce0cbc045d08d8857e226577b2c45a3286fa87f13e6cd1a12e36e8ccf98e8b36cc1b9621c5ed1b4efe7e142bac6e7e8849fa6f4295dd9d054b200b9ac093a1bcc000a624f0ccd1219aeed3ed5f8b6f1c5e05873fd520ea3f130463aaaac8e517dcd48f7c9b06baeda4e84947ada4361cacc73b9708ab69c559fb44398098ee5bada07092831f4cd14980c9e3fc886796060cb3b32281115ff4cd46f31e6a4bfea86699e7be0d3eede0cccdda3079a4be7ab992b6a9e7b8887297b2d39197d0360eed7813f9e9ab11f0763b6d928ad1f8a6a31bfcb64bd9f350785b881c61ba6a2a2e8a35f9cb08cd13a661b210029d1e82600f1a2932e80bf18e52a3096fb32c83b4bd3bc06549e788fcaae207b31c20f3fe4318fdeb8374103ef117c8ea1b063e8c916390e4bb0c09aee19c7f74fcae6fef0da1458f60878fde3d48886fe81eaaa5d6bad9f33b2b679e004e26dfe4f965f41c5c1547ca3da34d87f100fb0958729ab43ce708443feae3f8964feff3273e03fb491bca1d97482d5499a07e6187774cf2c3475a903b91ffc79d6e28603c904e7410b02fd6021bc7f77781f340e75073c0350e20c91a5534890cc73740d6fd5497b4a57c7573e2dea894676a238b59b8650b24a47964be981361eca469ebda0a0dad54bc59665ce6b0b518e97a18e6085fdc3a5e76621e75afabb64cf3be02cd9c980a3cc5d53ea30e083c5276700d7daf94e89d1aa6b798f66fed949efa172d17a1ad06f1dea69d5088f2a7a4b042aaaee873e6ec5b281114b536a31cc569b5f47f6a6dcef9d8d9783d9cc64332ba1965c0eac45430534ab51118ad219d3c878b31a1143973e27197e02fc33fb6a9ddfe6ec5c934e068c2a133ad9e325359c0a4be96a368593b141ac77949f2cc0c29433156304a3f95140f10c44783ba6f678d8ac232a453a1b8d40eec5b42527633c1c0eef56946e312c7692842320e25ec396dc712619396a995cb5e27626f64eb8921956e252e3e4c2a6609bd7a8859c2e46a02806fd8d44e0623658625bfd39dc1f7cf1bbea9cea5ba01cf5e439eab1ebe1f263b335990920139c8cdedd1efd3784e007f7833a62356cec05866c99da3abccf8b12c8e4e15311d104806be6411842214e211f98363d69af114e3e0dda4bf78120c19b743470d595b3540deabcf0ec6e541f3d6e71476f86db5b0f0a89468cf9f751ed8575d8daa86f45fcc7fcd52ed755ff6dbacb4dcef104412ebfcd2e20425d5acc4e0865250d89d063a63284e8a0a5d092193cd531f5e7659220cafd82a93afc80f519538115fac1b606f8cdbe72184daa92810bae76c5c17a026ce3d7a367361f87962031962da785477b2fff3473d6b043a9e017113b7cf7f5f28105a08af17baa932cad939029371d25f6aa2d53347243d9bd3c8b1fd570bd7a234af5f1e833f8519b880a64823768046a53e6d88ba02f67ff8788287b71be2879d14ca6afd8b90c95b6086de8ac3d1f1cd2f42ececc73c65086b8f84c9652cfe34e9aff77090d881eeec13ada716808bc2ffa35c2f8ba3f788040768f74044467d0e52ff405f121e7a11a6f0d49bda7570e39e3df03b42386e40875768a6aa4c54593c0f4e526a9a7b980ba094996d23dccd88356c8592c535bd8021e2ee85c4ff9e9cb72420c05361e2c834e56005152cb0e68a569d1314add290711c9794ac3ee9528514a925d3727a9029a79bce669b6b948d5c889aaff9176a397415ab8173dc7e0ee933ceed6e63b46704af5d71d3cff31b5afe9bafa933dbc39db6504883c2eddc39e74aac7ae331661854e89285dacce4658746831d0fe60bc2aa72a6767b51511d3cb1570f31b1b1f2d59c689aecb575cc4eccd6212cfef1c25781818d3a50782fea8a76441df77ebbee2d04792065b1e4454dd48c5cb7be93c9518582144ad96b81792c8b7f74db2f668b47b539cf55732025be0483afad8962303ca0b6a39355071609e25d7f0978545a72869018e706d1d000f1a7809f769321a4dc3e87287664f5e9ec09a54ebebb0ad09ec9579323364e21590cc3da37b217384718297133009ad2f3f90c33330fdec19ef0d727cb59c204ad7d7ae391e0dd89ace4495b85645bba8ff77430caa33b357025f5977fcb0925551398fae46435cc46062b0365a5b87bbd6cf3b22042b24fb251040c37df37c2e9171170bdcf7daa4fc0db2c2b43b4af244e052c2bc51a747929c1699e487a02fe3248f8c02f1a4fddcb38bb542c2792cab7cf86c802a3fe9c1e4a4acea99b27fdbf5b2c041fa3a05bd872e3dc9e37f9750af2520cb89af89a3fdbc68e8adab068aa2b33b3f601fe09c6a9539168028783de94cb40d01ea23a3cb513c93bf18c2306adea1f81c3f356b32d8460c5254373c72319d799a9218d39c8103a96bc89c3f4e0effc2a05608b2b8bc44597cb7a563183f78ac3704c145df7898e5ac912160edd13554645fe39b2e53ec494c0ccaa7ed19e13123d3cfe40652798ba5ee8529ec6e662ed56b94a1a334b57e8b4df701e7855542c3932e22783918ec9f1a14ad26c6795dd94d8e6020b0f325b012ea93b3972c6c7d9a6468da64d8e58e898378fc5bec335a916beeb67e05fcca69a1e8c3e6bda84a0e7e470c624d33c13f9e0b39f1442885db19354da56b170a8f66d521bee0e89da1c1004e475e59f792569bb1b0aafe28832a2f44d995e4ccfa229b809b1d5618d741df106e6d262d0b1e3d4d181656da6a4a65170d0c5ccb82c6d8941cefeeb0d4a32eeec6dde8165e5396f7df5d4fd15af4985cd99485a0c1cd56e55fd8713e27dbae697382fccb623a7b21e5439be3c0bab7d500293cf7efa71a1d2237e400976d6e61649ed819b818d3362a24243a8961d51fb4c7e67d194623ee898f96194316","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
