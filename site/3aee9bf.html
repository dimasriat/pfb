<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"676db4f9bc75a519d6f7e51453d63d93ee0f4c932c90c14898b730ef405759634632a81972232a810b62c0140ca718f749c67275366ed2cc08fae745a2f6e29eefd81dabade3c1db1b14f02013fc567fef489b8a799f67b3d216f703188b3bd278d6d6deba41762b188e07fc32cf499907bf701f7f83af6713401ff759de5e2a68dbe4573970a689c7e2d09b202b433b4ef87c87efa2712d3ea3c4791248fdc491e961b933997ad5f4cf7e9f6ad1d96eb3fa4b3ffd7e1b40750ea6c2c466aa65ffcc3dff0cbd5f232f437c3c59fe0a0cd8657fc236f25106a6b10ca2f1cc8640e20e7c3957f24ce7b8e105e5547e92879a31f5ece0cec00a548c60e833eee2aed6e41a00f130907a76208babeb15162aa9adc74fd457742e05fbc21c3f98fbb9db2a918cdbb39016bc78a216f857a60622822d5b1dffd5f85e7bb63da2ce48ea09dc572978ff20eae261bf66c558eff7e959673d800931b87eac5c9ff447d6011f3e63c79ac2bc247966b12fd58accd55ceda0ff777054bc18cc13d00ec94092d4b5df09ed218ea0ffcddd41a9f9a2931e71da8348de0078501f1891d6dec75bfe4e8402167adafe158a22dcb515095705049945238eaf2f37c5cfbd22bdb92445ee93169d5beeb8e5f88731fece1957ac98f975906e79cd42680c108f00aa2613a9c147ee77486899b3ebd60ae5918a0f2f8baacd6e6dd24770c73349a9685fb2a7125b7569d4afad6093fd35b23aeadbcb8a3192971a281b50663db4b4b4f2c5831eed268a21b679fd8fc17d425c32e2d8922522aec23f1dbbb444074d220425e3c3894d8525dc27d421ba7a1e4b237866285fdb55f9125cbb65b1c519b20cb28c5289f8bddd950b0befa7365680af1a8fa68c00ba3fb0484b667356bb9c514fde43d416ae92730fb34591331594d0ba86bbf9122df8d1681217e8b4fb013a27830dce1b046a4665ac3e6094c9a33c1d03d90905027f06325184de677ad5a4c497409edf828e2fe7fbc3ce052e406d976d048177b58ffececcee6d41b261b035983f022de96cf4ff0067eda603e9c013a605b9f59990191dd73ba5eeebfc0671a05078e158d618d1d00fad5d8691e921697fb7ff71b62e64335ffbb7ba7d416318659aeaeb26f7253ca5838684d5d2ff7ceff791a70f05c1eaa43d7c628213df507451667f558454ac154570ced355a4863036df0590f3660e8f7b522eca32e94cc96f9cf256f4a2e98fe90ba92e3686a840ab152d6e9979e1b48115a19edf33a703f78470259f6e7fd3fcae746d43b35a9f84f57bb499b3b7a606c3c2ace5b90e6d2bfaf1bc5bc3625a89453df22fb1fef33d3f710529784eefe5de2a082b1101361158e13ea06f980bf30d88bce03a61bebf59ff2d6ad0a00903c14cd32df08246f64bfb0f8c9a6d6c6e47ae28ac00d70441c95f8e84a357bed6aff2c8bfa5d2eedbe65c74e7b50b1d25067a90e3f0ae06e9a24a933ec0e1d246d413fc479bf22a463b44344e64e06424de06fbd7cfd7343483a982a0ebd665bfead1728fd3f42f3cf4251fc7ea142bbd476c4552f39c180347f35c8fcdd9763d088bd4dd857e14b00a72f23b99a73713657464d529b168ef61603046924c90f590f74e8c3f8d1742e842387fc26b489a2f09664af7398772db1936ec0b4684248d389b0622a05c76d83049d636cab73606d065e9e464cfb2051d3a22c2d38631380cedc1433f5ea1857f360ecbdfec90b030690e2290a76555849b9655e73d8aec9f65dad3a814f7f3d9b9c062899bcd58470b3b999edbddd664342a1217d67f3fad9758d1d4abb5558d60d903fd8efc27beecd0963c7b3916e049b62a09cd7bac2e6a0a04713ad767e2b3ef5d71a54400e98c18b670a51f7aa2e87bb4b4bdf6877a4f20c610cb414694a4e5f182ea1a29ba2718a87ea0732a185df42c5b58dc2b1f9fd9a438a521ecd5056b46b0a98a6c0473a5b708625f82be904404b312c9584270452b9cf2bdb991e8c3ef79ca221040b785cf63567f1910ad9fb8e2c685e937394c71d1ec6e1459d31be66fea632763cf08e0a834beaabe904390c798d64cf4b929b75cb8d7a64f6cef426f98d4f2ca066379eaf553a2912d03d839593d0e4f0c5351a21c6c6c1fe07e0eb9969b90f767652faa5a08b96557486dd5dfce5d570eb78f41d4d5c98b2569b06cebd798293d15ddbc14a57af8850f3b0c93c9ea48cab8efbf71c99dffe8dc83f5d79280cb48b6c20353a2be2da4a38ce5cd84a789612bbf7d7546a303f6df8e325902bbedc1c9b4313f35125b6521f5146112aa0825ae97578b0546df6837d3b11f0c33c679bd7c2d3c4177ad98ac5e47a14d41ca2f0228a0140afa4a0e92f9e53e3d3e2282d613b98b94e2dcba4826b5b1bab14ea396975943f173019aec8e281816084265a7c708ae28dd568479f503d039f8887bd7ea8411a85e119ceac233c7e1bfaf5e57c131f6ea9d3a58f0cff6a5d794f77a17b7906c1cad657eeb629585e3ebb2f25395cce676502f7ae0edf03e95daec4856115cd005675e2c848b6cd91631e53a47119f084782a9dd9b45124bfda927b6d86faa5e9425211a34b6a3cb7defd2db465d6cea0f373ac34565b1428795a0bb3f206a22ed49f8be469ac728aa28bf7f1309e1d15c4a0bfbbfd12122a83b957a82e86c381b472bb788481d15b05f93fd38dd269cf9bae6a4d20dafd24ccef78d1088a14a6063f328058185b5bdf2403b5dc8fef57955332cd81c303cdd2981e1523cb9dd1db5b145d6deb088d8a7384ec6442f9794f319a217b7eb53c226711729d527e711ac07254107f1f6b8d06403dfad4fb8740134ef58a2a495fffef342676df56f2e0ca1919d8eafb7010113b32bd128721a3f81702a5a4a90cd63a9e02dbaa13f14eac60c48dcf8688ba63f159684ebffac12cd47abeb0a1bb03e73a5cad35aec7ed44d8626be7024ee70aaf94ff2e398295602e7d8a1c246dd098d5b4d0b552fdf5c559ca06bb9bbb98dfe9dc18c857dfc560922dd83f55d4e752c5d362ebb557650e71700d36701b1b834a9e43b7dfe4058cd957d9640f501d090155a56eb3420ac33c407947dfe169eee0be6bb4d870563cc07da0f23325bcd3f35ff7741f1be108827a8ba3512d9aac26c982c064e94f54e2b26b5f504b48682d391eca78d91177daa91b60df83d7137a6f696e077524633c0cd7ccfbf1502ac309b943570bc8a222b461a1dc3d4e59c626713d98575330ee26f1d5af9c4ee8acbb0eaee53b27a8a5d6561b7a50fe9be5f90adb42d14a1a750ca001c5c8b355057db7bb081f09c93eb4bf439b8bf59b1463175a3921252600810c998911cd986ce2584efaa941850e3a717070a3ea707236f6a77df506c0a945eefd25c50389e64e2e4c3e78c440437ddd4ff3a3a5322d5b4eaf8862300f4f7be989603ee4df0b0951ca0f84d120adcc6ca2a48c1d37a00782468cf008c4fbd8932c0113c476a395970f5729d354a35c7eb1220ddb0458dd5fc84dcdca2e4506cd4946f561ad55d82a7bb6dd0603d7c8b739dbd32f3c806252a48af03e76bde480a0b53867475b48d5ceaaceed434c7548c2208c57c1e8087789e61ee51180735163256328f30424a2e384ea7cc41e4117d56ae9f8b75a582046f9df7a525ab199e46c8a5c8c29c5e6df7f46542520cbc50943e2277a549185b582ba057ebb96cb52c184e1a5c325d104ec3de3225d68f8370b150dc47b748df988daff0982efc6583cbd847b0387c5e95cf97ecdac63b1ff5e1f1ceec95189fe7adf8e90715a91354a0a1c2434ddd106d4b57c3909d803544d3fcefbbabb432ad5f05ad232fa94213d589a043955c9224441135afa42b754f06739d0462eff7a83d5fde9c72a1cf50f27a7efe704f5ecc943f720102c2326ccb9a9473dd8ce85bbc12d3408a229861c8b5b814b6e619ab25dbadfb22b08c069df22e7d3e0a2bb4a257a0c25b83087ef062729eb766cdc841f561257f225fd77e5cc6fe8ec199512f3cc962c8afb8ef4e79da134d3fe02dff8d11e1de45f5f832cd6babac94318b3bbab932a685ae30d0592863992e3115713084afaf1af82acb642f3326b9f9bce7c0c33672bf3587528488271dd2c5cb4832a04a13a903f88d263f12681462791b385291a21b1e14c3d45375422bb7e5a222f90fe9e158d891ca14e97db863a8972e2b9585dc840c20599e7d417be9049b52914b5086ec7ae8aa79c8c4e87ebc525d4d5321eb601023406e4853c772799df7494dfbb808ecac7b2eff9ddbfbd73c2371e26900871cd2593ebb616b9aa4965bdf8cafbdcffe04bc2ef7aa1e287f359a65fe93cb29aa91ed9d2dfa0c8e997a9436c743ff0998604f9f88b36e59df48bf1e488bc9de786ddea99dd154bc66d489db6f9cc76b50748cc9b2c5a9b4ef250e4c77237438dd15c6fa7408205361df2bd95f821f382e31099f6847a835e163fc0906196fa9f9641abd56087db4f47fee2b2b35736fe471eb1235bf97b510b5a2f6275a142a80ffce6b206b14568ac667d2498f73e3b897cfe9ca5ebf0d3c8cdfffcebdf43e22acf33242d6b15affaf9222e03a8e3d8cf633b9ac2562a4164a8083c2eff177ef2a9d29b8b5bf5f235e58893f4f1be6575eef80a9a151a1977abe1cb87590bbceb2510e25f48bd38d762716dd31d3004bea0bf7b41c3386ab1f309b3ac067c8e57855968497088e262311603b272d8af38a0916124e9610d25c6f063a37e088bc3a715b4c28269f50444c7c73df5945c061bb2c23ac9f9cca75f5bdda226020c226fe042df487e878c24a730817a2de51efaedcab113f3e2c196b87005ef1cd737bb9b96cc8718cf974292ac4e2e712162b168209b12b0a81769e64a599c5718d86041dd12fcc78816d88bc97b4d1e42ed08f12f462bd3a8c83366d2852b91e33129ac1a8ea3a215c6f65c513aa7b13c5e1a00aff51a2eb5a85cc9f46d2d971f555fc054d4bc4e1da5c4ff883bf9e2dc847282b93ebf1b08678f962155ea79aec24599ae051f04beed09bf587a1e825f2c1e2f3dca071d43b1bdccfa0eaf9bbb5cb52313b79ef7d2927af0ccdf7067b45e64a7ce96345fcf829feda638982e1a88445818e3f3f278b75ca7fa3f8cd8eae78d985f567c19b5227cbce1b014f26e55cc0c84c7fb2102d05243590cdac2a5836fccc48232d3e30c1632d47fef9363a19610d3a90ee6944ad6e680dbdd9bd28e7f11ae3f9089fbdd046ec1e11346f0d295b62a33ab55bbbde1f9a98cd3729d79e85c40c6b7ceb257875eeb33556290bd4f6655c27484960eef28d213acc17aeb262341e5d7a9f0c1f6dd43d3a1e476947b0f907531125ad73b67a61f9147b49b97986de8fe5806df8af2065afacd8e1ba5e395c920cbbf507a61f7be2c8b667f5a851ff4951ce9b1eb4a88b7755f8cccc67a5054cf552be7da518ec8a2f232cba0115f57eca1de5383eb36591cf6fee8735d163c5c4ae149480442bd1c842bbc8f5af719589bac892a68e8812aca2128604f6cfdaa5ab4051124a6b086bc1098e2c8c5595af95bf095a6324e1e35f14fcd6d527a6bd415a378059db27b76c0e2f3252b4112e5187227c52e6be1e7914be5140359feff2d7b3ade46b58724aab30396a69dded9340ec00db5c36cfc0291136dda57f054b2a187ddef584749b2443e197cc94c3d1548e6e767501bd2ea2054bf52e88e6c9a693bc4f5b006bce08fabf47998b747b9c20e7de03e30d7dc139cd1db56b0835ab9347a7fc8d5f1114b354a419216701ab5e73f004a8714aafbd552d8d1af1dc89142ff78d3871b36c964c934f1a02be6255ee8c5b4c9c8dc038f6322e381dc0d4a0b9efb26826bd37f8cb324887c59989d3c4651699bb8ce5f4c0449ab23cafcce36e6724cacef120bd618e93f3c960f63f07a05bcaf2cf076cfd0d866b62d9eaf0ac0a548aca63a172f24617a1fb1abab75929fdefc5fb93b1733eae250c55617be343fdc22ebb4025ca751250bde666c0112e214ac059bdafff3eb29b62b8f3afc8fe6eff279d869e83b8b1f15a9528b23ecb82a46b548f4bbc76b2de78acb397c07a826ad1a3139158c272d3efb233520ebf8f20f5b77c27dfe91383434eaaaad2923fc7ad020f42ae4ad601fa2a1c17c954248488603ea73779e5a92f97efc28bfa824db8bed5ee3c4785c9d970f943eea704dbcbe6bb6832b171a732d1e9a265cb4b7d52096ebea947fbb09998fb67b0e18b2472a7bac725c77709da6d958a3ef1a83a3ee020ab5d42c4d329a1e39301143dc1627a7d82ad71889a3ccc9168f58fe383edaad927a5d74215f1e3fa69ac3fa1ea795d4456e325ad2fa76ae1a58df19bdaaa377431ec7fbb626c6ea96a864d8a671a782e514efc929f502e871cd7b3e66123cf91258f47f58fda7128f585c1c1e672b590c2ffca133fc24933fb2c85edd01c70f0f49132536b9a6cc00cc47072aebb896cbd073b4d8bfd2b9aa5e25e60c7d92d96dba026f3604b479d741b9a58ad690971c215d37b44e8a1a1da2e1a012ac82a0e421bc28ce65a8900fe9a4abefdd79f20a0bb3d1add65a6267949aa479ee065a4d341e59c0f454b7aeebf9296681a6513cb643783633b06d5a16293eb30b497e5772f1556c158c1e10421989e115ef3e50723a2e1f432fd5d610d093680d480d0a8a83ba18b6903ccdee73e4c47d40670cd02752bd461852e389cdcbebe716f51fd1e51fc981946169f8727f712f0242a7facb69871669035a35807a3b7e54981c9fdd7d064f98a102205b40a42c442366ef805d11da06ce0b955fcc3cfc6eaf2e8679b6c364d16c53dd9200822765c2366a805bd119b8391b1f28753b0c68552f10a0ed2c7a4e83297bbdf278931e4c9091416241844735721ebb52d6937414540bcd4e6609b75c3c46c5187b6eb99cd74882c8a6418f8e2774f0c1bbb2823592ad52c371763bea4949bff086e06b649884886f47a24fb1fb2aff8abccf2413ae7a3129820ecf87d51f96f0d1ae6d57fac04e540e4fd0b5e9703b1a1aa70b1f7ea611ec267abf273ba9c79d2cb015019f503f9fc334586cf8fe634018f7227db46e06de668c108897511bba64bf48ebe7d22661740a8874288851ba83500c09e1ae8705cb032f7254ba351aaa9c5ede7270dfc4ddfe9448af68db5aaf566bd978d2e67b955b4948caa72fbcac8bad0c8f403f8c8bdd6484377f7cbce99b2de10bdaf724ddaae250abae4415ae72ddb70a57ef91cc60bb46e6ccbd70ddb5e5c990da65668340595f5d5433701d77ff6e938340abd64ed3a85c439d7214c192572c6aaddfdfff05fa8c4248d38ecf76c17d0301e5240ae4478a90e314cee946e46ba8e0a32902799ead83893017125df3b792048f283872b13a0bd37bf93878d9b9f691cc0e8968f2ad8dda290ead2d093d6aef990e18c35d8378ca205b0477e9910c8387034006495c4119d516ae028ca3b5733e029a1386826f417a87df6d23d60a6317cea5ad5dde579e5c0516086727fec268d240422e3ce85e05b8f2ea7baae8bb7f4c15e02dda5e6eaea0f8b4b045240c9746a6a8a508f69ce19d6f389e7a0da659b359227f29a64c359b5e34533a00f708feb1c5a7abb19125187d5e4752bab6ef4fb8eaee64057fcba791315c7c54f2cbba3bda04b0d99ceb65ccb914f6ed14ac9f6ba90d67ac48f9c1736b1bfa2217212c8a1803813db71cc0003b45f4230ae2d9c35ee8bceac2abc7569a73290f9c858b6b2f477a1163895c7d095b6055ce433784998e1bd7d390307f4f7afd483d3da7650bb4eaa6869e69ee7cda88e0c7f3e16f483700cdf140f221c26ac565bfc583a55265b90534dfb2297863b80c0febfdc8fe2735de82de405c865d7f0120d8cb9230625f80f932395003a5b784fb9a6df294fba9b1b41ff0d1820ee8d0caa24affe476ba1bc21d91cdd6dcd4a7668f4b9228913c71055257787b3263ae7e0c54a7002790b586845f02c577ea07c684e3646e4d35fa70620c4099554db595a73d5c7e9acaca3d06f1035ba2cfc4d5a47969aace3e5daa9b9659c72a4f4618f7f0931e73b6e5b19882c6dc3c0330ad4568e7c3c9a20b6f62ba4d9e45b60537667430dd6a3199ebe025f5d2445e52b90bc184b147f4ad2bbbff9874ccfb787c25c87a4bd6a1910772e406f7c703d64118c6901d8befd63be92f2f2ee4c06cb1ac2a058eb172d78d6ca980778ea16ce7c0d90bbdf8bd894715b2f6df1c6cd08cc4071f61ff1aa9200cb9be6188899d986c97c13928cc0c6a9738b2155070bed81ad830c037cd58bc167931ef724fab3f21aeaa050c1886fc2d758522cb83fd4558f081ff6ad5040531d69fd41ae0232e9e6a4055ef9e3beccdb4155fdcfcbed916257672cf45eecd9a90c9d611cc5c110341bb8b40296707816551064c46616f53f8a53b910baad5646d7279173c3825703973498811a2575b71185c7913bd71c97eb44c9c529ee9bd036cc937c035042a2840297f3d1e57fb0800f581cf40b7f33f562ca4b6f725629554870a389d633332894f926e53e4ae658fe91c39709adc766d26d4ef5878dc0e1a65f29ea6aa527fe55c8ad4fbcb9f1852a1c37c096919812327ac0f610ac4adff99bb8682a0895c4d9df1f25c0a81b0f8327a26a8378868978c7b12447033143dc18ac7c2bb40f64426c34ea87139f9a4efaf4fd3bbf1652613ac4ee6129fd67f608027951a13d28323d45dce174ff8121ebc6e37466e0e9440954c9787f1723b2698ce7525f8cdc2e876f72a38ac43a84fb23cb208847e2742191b965d2fe13388bf6a619dd3f83130b5b9b3353dd40998aa5c405c35de164b9a7b8421c4e4c02b94ed4426ef50ddb8b344775b373495149c9a4bbc44ea3e09269cfa56918135e04d20426238075bdfc6e971a19c8faff2963b8f53d55aa8cf5174e4a41705f41fa9bed5aad05fb907bd70d5dd86b2e513c566573f25bce197f365dfbc3f39c2481441e466a55305dcfe3b812daaa206c7f6d32bccc4c89c6c45e493144d4194a5aa99127494cfaec46546c85df661ce5cbc78ac8d56f7b6acf5f490c06e09166686b18e6087b03ee69bad78e2175386729031e23319addff61fbb0d6cdbee304db6383ca1b2408ad2a0a3cb11e2d1b34f0d98acc9d751579f613e4d111f7685a89550c84f3d3f296c828792e9635c4493f38c52242c6349cb14bd9650e1db13021a758a759b98da9fcb99ad04a8302ddcb6e50600e47fc9591b5936020b8605f958e934043ad56612324142dae7518610ee9f2422be0fcb390036645bbb8afaa3daf34527347932a7bab707feb652319eb6bfeed43fe556efd900c3d0e5c782365f8927a6cab7a94cb513d5987e50f5539eba61f0d7dea8be9771715a649933e8de6703414be51812e908438deb5ff7eb1a4476b35819b197ac0220b81e2d490d6ffcc127786af7f847e2d09d06df206ebd633894daf1d6ade29c57b7fa0d82964f8ba2c2aff73ea1edbc36ed34e5caa2c74f165c35919810c88278c4b9fcdc24f1ef2bd503082c28cb0da5fa6b042bb6e58159e25e01e9fc93bedf0692eca38ed94850c7361161694a7b5127ad1e5b9c1479f6635a88fdb1702f30d5ead55b94b5259ebf327c0eef8f65a994359f31ff85f8c6bacf1c464e2c98378711472581cb8dd69a7a437203b358aa3e40cfe86c864201d40ab5f705208c5975ec4aaa1d7d4658be01223c744b9fa526b8d2bf71613ccb35af472f13a1feefbe3dfd51385c7f825eb1f221b39fa78dcc391949bd1ea26f215c92a0bf59bc6a2c7395d2d01a6532e3414c33dd6ce8e32d6e1881706e87cd9a70302ab45d44d2d8b5acda42151737bc52542cca3d0ba5c5acf2a62d393a7ad81c884280a0cdde27e4143aa31bbaaf2e72a0198b0cf6326ff7ca0a1098e3ec13e7ca218561fc3495c2b10bd1bbeba04a2fc77765d81d5628f289dc6bd2b95c03a7b1d1c1e053b22909005902e2ccb48bc5a8a0632138592f8344d39b6cc507499f129e64d18fb83c2a8aa6616a20715a99688a2114e7c75bbc64ba00e3eb4571552b6b1a42df9590859ecd2475a7d689333d055965c2d79cb153a43dfe9c328a61d8a74eb6e7439e54c2edfeb24853f7d002e9048a21c3128a743ec3f962524cc755a3cd81c0c9dcc0bc6964184a19ef86b992ce526710fc050831364b76dd3495671f1be96d22301e1e42b88862d0962be794d1b31b0bf08921fb7f344e273183813d5fa342f274777719f42f6d784eb770bc58cd25d8a0687f2341141bdfbe2fbae4ca9304cf2827ea81ec77244b75390bb11158e5f187aa95e339c4bdbd521449935f13c0914a2beac552894e3601299f7953ca3098bc9d87116de1455e4f3cddd5cca3f15f822f1281d2fe473e4cfc0c508f93bda686f8d6f602e9c9558050d95ed15c796ee0cac264be8fd9c73bda0665024639f516aa0afc7ffad714cda2d216a6f78b61d17d9939f2e5d5bfafcedecc80bacd7842b1116b03fa87f9afeda019ca84a7e9d68e372eed42e9224f09b1463013611c20dbd6f01ef975f9be3c4b25eb374f6c6ba496b97b8b06f31a0c0b51d5cd709e57a9bdf6023993f70255151936220b121b60d016841e6abbdb239b56db891a00cd7df48c64fd9e724f5438dbcd746981d07a5a9d33b81e47fb49e1b02555f804a2de16f2f3839ef768a35145be5fa1f2e396e12cafd7d06cd7420b1c8913a1e16ff8fba078d4dde06943a2dbe52cd6b6156bf39b110f62baae8c7791721625710e70dd5d8e6fb6c2aca9c881d2ef34c175f9bd7a4a3134d4978c2992defd33a90184c21731173da57b9195d5d34162545eba3a0bb721b7e4f0397613db256e9435babe563e053ad693157492c730f5b71ccee904316f655e61c36d40111a09768f1d72ea0fb2ff1cf2ca72675ab5d70c58b108add143af3997b9b2c83dcfa2cb322729b14335ae3357132a480d479f2eb1608efaffcb23aae49e2e025fab78c1ecce8136360ce95de9e6f5c3bb6186edfec616b472eed4c87fe71c9e3fc046b3b8df62235ae46e03782bfe71247958dc7d47ea702bd1a5aa8d95de46be423fd13edd2246ffaf157b1f37ed3ef09a827e70578b1964c289008c1b9a04fad8ad307a168e1857d4c608386c426f53cc24a0d160a1624c3c47083053572117d3eb7eb9a3008cdedb35934f926bacf6b312ed4edb4bdb63155650a8af67bb309ae43ff6d36632137c7d17dd1301951bff74e4c48237c3ea0514d0bc83c374f1c91ef99d18ba90cded2a654f96af8731158307663f21a1c2778c31a15dc89c948c5204c2cd63e3f6b6b6c87a27fd5c4fadca877851f1cae4cb5a0ab8ea34737ac0aa943a97a053051b1c2a9664f6ff16275371273fc7402867b02796a3e6f0d440cfaf536897edbee9d54c09179d3ce5cb083ad0e8e05590fdd5f2348fd9b92f473a7050e5bd434d4deaa9993e41fe0557f29272fffb0a7dd940e9f96a880f4e18a39882fc84338165c1291b4624359bedee2eb457049bd21b1ef72cda9a425418b2cf03fa6b4487a0259b22e0f105d85da18fb0ad3d4a632a0aafe9eff75ab62ceef2727bdc9985a08cbe921879a7f3c12d01526139829599ad040ccfcbbded75a0f1dbbdea40a9436fdd73ac0bede994c0916c1462f6b33765d511f0fa972c3afea43192efdce42f66cf8360722a5e9281812c19d5362df8e55090eee8e128aac8f95863e1a214e12ea83d134f613a3cc8e387e6d45a03ed4678297dd82a120865dd93f5592020a77fb7357c3b08b8fbd9dde2e36245bfc4ec195c15c7d20157537e51a0e1d5ac5a238a9fa91fee8ce0f1051ec5e79c5cc99fdf78006dff74c16470b2fefdc7019cdf60fb8b9b0dee2f3bdc36f724069ffedc59d33a091025647bdcf471c62e6b6582b4b9499bcaee65fa5f22122a6c371af70f8c62ce62255cfbdcaf429acb11460a1872601a24720502844e975fdd6fb07b806b1c0ce76c92839616e9c040da486af51acbe288ca3a579d6ebeb985ebc5fabad5b22a8cc105fb359b77cca783664f8c502000bce769467786e3744740dd0da50c222ab71c08afda997e47c8d35e14d428a13f37b96dceae14b752464177ab25989a6eef919b3b3580326740c405fc566f3ce529991dc8bd950315e6686bfb82233b8465b91fc6a1b0bd1d06d69735b3730da7218931209c5d8b8fe971f1eed29be6e9738dbd510f02a812103455c45a4125f5aa73fdabf53ecc2220778306a7c7a069a33f2c192f581431ddfbbf6442a53db5357ab9a9100890231919bbe7823f4fef25f6a1f2a62dc896001497640a79833710ba030ce30adf829c266174a088e9fc96cabf1d44b8db20f945f16e42d3c0be810930fd750f026dd330acf577228a3a877aa8d75ec523f7fb34686eed6f0e912e47f737869b23ba90fa5c200290c4eac9081a950533d4a2433a445ea9a0f75e4180c6a0998f87318f9deaa7fbc8194302d7072d0cfd87e49084d300bfde6bccf750929e6c01c9bf431a890671210c272feff75170d79e07c1eeddc721c3614db92624d3f6f25ab306d43f169cfaa4d661aa3dbf7524cb3dc8691efdef8b89f74899f3cb8ff352ea63ec703fc2cdf05aaf6b5f703866ae22622f7e169828ab4bc32014013659410a0d8c0ca320ce570a2701a68649064412b67edf22475e834c92a1ce9407c4e8a890e402d6668eceaf97bcb0c887538fc9d8840956f1be9f5ee836e3f7f4e7c45e8a69f4e5c6f70508c00e3d4bba65e1e22d5fcd1b465a13212b4fef24b5e6945b7f5e40af6735fa3ed0ea40f7d29b3daab5a1669cefb3f2a437e5fbc2d736c09b7c4fc0209d07448b4a20a8fa9f5936bfab680ec5ff4cd826de97cd07971ee0443ed92f42c0bc83853971d819466d4848a404d802100fed8ff0dd29153440ed1fb6f924b811be48bddd5f9dd3eb8c1bd6ce1b4f7998395a62e020fa9808f5b1c92175100448364b0c499d90adca53f528fa3ceb3740a1aa73eb76939b26ff355024e088a9fdd77e4aca16ff4c75aeacef3f8014f22c82760d998aff26380b85d5ccbe7377b045c54be72ebdeccb7284f3148e86351f456a550bc829b9eaa18b78e6b6fdad8a7e780e9ae58f6a74ad7117cc67b31a2c084a67d379619d5abd494702fc29d1199ad617cd6dd98e92b49aaeedfaed9acdde7265f7c2e6af0c41028820639f4a0bad22d2e99d05672d8f85d602456b71821376607a1b0fa49f40e78a0707da49578ce095c132038c1e39e92a2ad5e3271cfda30495f306b463bad29ca0e3b6e6442abd3c1a467aa9776e6a559f2d3cd8ce67605b75e208f1a1c3adb2dc89c47b097491624d7954a97094a220375303f990db5623928dece38a7c6fa75564ddccf5af5e5f867e6d9b225139207dd99ff3c303bb87010ea738ac1a0c037389ea9003f636ea906d6372213e92d950640783ec03065dbdd0da6ec91b0603ea17b5544124731e88e03203dae72132ffa02badd6caf5c3745d9ad7d0682231fe627f3f354a03ad65d8e23b8ff4fdcfe6d31512801f015262323bad0b1dbd76853f9714f5737f5176607ab8a4aa1ff04fa73c039d6ec465b1997a545b3aebd54b5331fa041503a19d561fb3779f6dac0e750c01fb0256c9428805e42e1a0749ea70da95f1500aff6cf216488f10ba652dc04290cc8b5c5c363752c9221e01275152d9ed4297581aaa3db56ac73bd5c714fd4af92e4a3d637a19796c7b12c6250706e4f8b71d3be0470400f7a689ebad10beee6e0499a5b9940f0d3168060462401a28bafe01f798bfd7a415a329194d56a095cf32fad86a401bcd631b9ab66f07531676030a183b2b9e1e201c71eb5e5a027347561c775216985b7a841d19b208ac360c5b20b74fd7104da4e6f80a34ecbca40f44747265797ad7e379c0b2691580313b026ba932f58a4cadcab4ae1182504f515a58969c6384b69ad2ad45446e27e6797111e297336361354bc5e0642975129a7174d96c9ad70f566c13097c1a6826f1aed725cc1339b55cb9bb36c19e4878f84ed865f6644d26c17a30671ca694ba37db56207b519b6a506fbd76f2c10599d828a18f8c06daa6a8f43d4d9da75126ca27fc05041a28e109a15e0ff47d7be53f33ed9b342d492106b51ac5b8e525a6c352d9c965733edb7a832024a8d5313954934a25585840e652c2bbde6c30a998929699eaf34eed7f2a1eb0451c96ed32cc7773bdb05d243697761db93ab1028ce39cb5ed32d0dc83c52d183cadb5b4428c5316a2de411fb8fd575b0fcbf91cb329741f511af1f12a83c7dd286b0e4ff874e364c8af1918b8bc0a3f00c35acf9390380f770498af781f08f08fcc9d681eeeb9d28839ba4697555438f07cf93d0c28deaa846f3ddb9668ea337ed7af4b85eee358d4bba9641b8d72cbfd4e494fe6692b7483a122a4c690a66cd14eb4c87d551580aac79b9abb64683f4456205012e113fd61171c01653abdd0bcbfc71a9e73dd2cdfa1ac0b262342e084f7c2e74864a085c5afb415830aba312074cd99bc9bca966c146bf0d3b94b8e409b65fe9b0fde11e5e1d02aab939bf52d2d8654ce5cde2e0a291fbc7c9c0967f36b5702b844a548103a652","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
