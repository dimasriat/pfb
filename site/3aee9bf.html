<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fd77ac1b803499b69f66516ee0dcc62470268a85a87e460a7b57f6818122b54fc54b5125175f25b1585685d18840100fb02a50afeb9955335f316493334d735ac360ffe8da5a769876b9b843cb124957b59c286bb7e706fbf1b746692f6b4fa26b5b486bbfd0ce2a61f4b3eba00c8b12889ac77b6f0f81b91a7729d72cd713e74fbff6fbbba54372bd47ef2da485e8058fa0909d305f96db5218bfaafa848ac9dc8d820d7dc1240c3233131545b25fa19b5d23e21d7d420dfdd51f7117a77606923be138e0db1d9f837ff19a5364709cf477fa86d7584561cb8642ab3b07aa97b93067d1acd8ebd8a48a7c6659b365856bf3ae5ec63234320907ab32eda07457032227eeee588b533b2ac9339365e3d423b3e98dd31749110f4a15ce4c678614c2d115abc9d17ae66ebaea465d4f9a58e202515e1057369494b6cf5d7e3de4a41263333e045ad54629e603cd4399fa2b257919af35dffbe71f9a4739b5a1d7829a2be1393ff80fbeb9b9e9efcc021402079853b8d9413d46d5eefb78285e518b0e234ee8856c448570f6649e3e18d2292998cf926d93e682a077a4bface6de515ef993675a246063fa2eba154a60caeb979f8a6c8d6132b30320ceb5356a5f333469b35293eebe0920bc5ecdf8ed9b34494937c1c901ac3d7e2fa3adc9160cd8fbaa4188c16481fbb26cd8ce6cb1030b35f29ca26fe67051195592bc3373680ec2bc4980e6d6c9c43696dccae3a8b6286d709f68649293ef378fdaff718ad6ecd21503a2aa6537f42a6beb6549e069e2118e96b07fab7f0b82834d5ad8459d9e640f6476c8629258daa87d4970ae6d65641753cf0d6784eb7246691277ef9c1759361b90dedca23aa87427eb2cf7e24f8b3848a180f2bbf978aba15336f0c1256fe2c17768a6e85b8379c31c4c9fedd22323aade0786d0b5fc029f76c95394e357704a014a703b09c650808d7ed1d58ff4ffbe2622cd2a3578d39b47030ffccc3d045d402b633e6c7b5817e8f790c263c7d3a9da00600f9fff597d7bbce22990f62e2261a67693f237125f72509c1b3fa3058a506676278f209e42e63b2a8763779aac14d88e040dd613f1e336390d789d443943d29c0d6640cecab6ceae71482d42e067679c7a4b3298c39beb0ad36b9107f31ad7c7c40e3a004c9938b507bad037dfe2d9ade0110a2ab567abdcb1bc7416c4bd3ce57b1bdebae699124c38e9c2755b26ce9329e269ea595845697926bec27aee92660e15c5aeb1fc71873066957d999efd22cb8d2656232bbaf97402bdf86d3b7f20a7e7c7b60ddf08ce42d370caf1c2867ed1ff8cdd9baed789a772ff2324e6053630e272c67756fe6eab3f4e9eca6c8c079a167fcf2d0c49fd15d8a89a6a2e531c5767796cd7441106184a3a1a1ffaf4404c366b775c558fdf2d979bcd84c20334402ebf8e3ff7e3fd66c589a094f9b7c0a0130d330fe380f8d5b946bc52b3775adb714d8fedbecfd18e2c6ee15693db3a8af70ef7c8af7d282e4bbfd7748128743f5050a6c995e97b091c205d87020b93c7ac3960917f2aeeeb7ec2eb413076ea9322c70c3d14e85f318d12aab40f36ef40ab7f33228b977f025caae45ee11a5f8295181e1d401628b5c3d971060d2cdae7977384d5a0acad69ca7eaa60dd26695419d9aae463204c5293585acb499b701a6230d9001f9c6c7d02afd74ca945753948a8336a1300f511895d77f020b483e96c7edc4e30de6d2211cc3ffe692a4717d0e85473648873dcf69288c144781532c6178ce59dc6656e15a87ea08fc4a3cea093a43db9bd4f72da16427b4dcd71e7c33678f7e5eee07be6340fb5e1a986557039bf97080b920c03fa6261c037bdfa335d3f4b3a193873b4d450b42bbc7f089343ae45c6748ace406122e7fec1baea9e9659863844f8285c22abf672e0c4ede29a72648f0de5dbf8051513aa44feed5fb5c7f1bb040abbb28e2897923e662e52585e8882bc4813111fe64a996e0502afe6215f825a421fde5f66245392188393024c978f22595ddbf8344e7f9937bea508749ac12617ffc20b71fbf385b72699fd1a6c14dd0bc6e8193081cc4552eda55be01b1e751aebd120d774947bba0565339bc72eae6899046aed8625669cdebd5405edf149ed97d99e9cfe8c76ea8e640f3e175ac98c6fe38fb89adb3e4371ed639f8e3539bd1e8b5bd5d4aef1cd3e41471542494df852bff5f420d0bf48af0daa5778972a2eeb5ecc6a008a3ecd12de893c0d4ee650381bb90fbb7019c5172b441bf7063b8a91ad7c17d0b6a135cdb3ca5f4cb921622787751067249156698ee8dfb7ff97eeec04ec2bef4a1ab518696038c3845005682a017932571f715e06974d6b783fa3f6f1c75f95cc5a22188a51a5264a4f5294fab4a21759c50d85c959e7778f8d9d9681b67d310bc9722ad88797a8461a0c63c6f670e97ce386e23b0d54c21a937eb8139e25c1809dfffedc5e7278f5fd3ed50040fb8908c87abfe7b314dbe1fae380b8743ac3b19467dc50999796b809ada0e0dba084c6ac16c2eeb802b2e62820b69b6140ba5403052c332af230ac6dd740fdc88d1ed7aad9d2ac450ed7fd1be36692126c1e179441b842700033132ba6d7d9f4ee31333f2cf14015822d59983a5e1d642e83057370f1df8654488e0f463c6219951392c413cbd89c643cf5180ae71335cb18bdbbe106776cc0dd43ddf3784b3e509b270971a0c9ca346bfc0ecb148a396dfa073e2ce98dca04103433c71056479f3135d90326395382e606032f5a0fd10a9a2132f969087e0fa119cb1da99b479f48c45774284442c2426cc3132f3c23b4259248ed72b6a4f2072cbcf25c99de76152b05e82e0f65ea1e89b60cf11bd2f552d140e56c8799845e69ed8db846a518c8cebc6ed961dc8bb9843112e5bfa6bd589c43552ca9a44a5ea6c4d8fabb21c9bb1cf2951a873e65fbfc65b783abff748f04ae11f6bf68279caf8aa3b64a268685ab5fb361cdd1ac018822e3e7a482cc1976e4b1b90fabe7203a0729463a3116a6ef8f3b895e9b4ff45b81befe88a472fb18ff69f90326e2bab54b73930e0dff802216989fbfbb9c52ad615e65d40de09fc7c1fbdeab7bd4fab5994ab04ca01faa68688c91026279ae755749831793093e6ac29215b3e9ada344050e459338cc602b0462f16a57522ee6cd28a02ab429375eed268ff7fee8dc92b2fcf166dc5e5cb4f79527e0f497cf109c3a15e6b76b2693f1917c58cad3877d510da409acdeaa3e86e360e3958659b728d77def5c55b888a045796846c6d8c7785a82a0aee7de9778fc59d518e1e3f1a95964653fd7420becc810db5a7f9a6ffada28649955122fc0fa1f21188c611e1cb027bdb8a0884e8eb05a360e1e77ac9b5c39aeef09da33f61d744ef1e0a67a6bef5e17ed8ccf89e9976f5eac46220cbeecafda4dcf3daa68c52f00a494b8c27d81276ca5e5d19d8953111959d5168d5ecd79e767444fa49e89f33f91c9b313af3919561475a5c1065293fafafa4d05f6149ec231b2c9bfa68ab4ebe3bbc3ee505b6bdbf09c99aa4a83a68e8a44e8616fe8c517b2e8e17abbb91a401dbf063d378c3e6cc4dc5eea5c3d13773cdbae18fb7d29e67e250c35fa358cb35e3e8305cf508da1be51d1424b104f8fddf439137a689f3ee56bb649b3e3c563d4abad9b4a338a525d990498ab42836ee721283e0ea7bda9f3b6e382c4aa768e1018d1a2a57ab488b2b5325b5bac487dab0f357ee68cf4adcc4e2762f03234bd407d59199252c35020098e6b3d5c7a3b29c24b344e2b825b5296fb48416313d7ba79bcce19fc4452bd5e54e73c704d849688bbf8a8eb7c203ac61c039c89a9b9bc3c0271bc011777609dd6056cba63cb5a93be32609dbdbcaeff57bc144c4453cbc9c3f8fbf9771ddb845da1531c5bf56a60cedd20c958d299437d5d901eab7fd0c3725b0e1e50190fae7829bd654946e6a52f2afed59178e8bc0697b5f237e4885d8c6aca69805cea8ae8e4962063b71d9732a926390bc3edc2727b47600faf0c71746c06d11450cd2651e8902c93414c52aefe5cbfc4cba359f51ddee29e03d751e57a65754eefe6b253ed8ad25edf4a7acafe275b9df9d76c9e57cddee6a1a38b6fcf4346baec7cfa90088d86c6d243bf9037c740476f9c0f55d75c69ac1572e73b110a2ae98d931ef321386872df327d7f98e884b3421681edca62d3d20161216f2a4526ffafcada6715742a480da6453ebb1519b8d07d292f633937753b64bd25aa50e167803edb6200e350bc369f0f17af3ad8850fa7067d79537ede82898b9038f3184ff9d62e2e4633643da600585668448a47dbd87db906792ea2dd245fca3585285574cf5bd17619d54664825cd39ce25458da19e76dfd10764b3a96cc76d704a70bd0b1bbebebf59f593b7e56e9a1e31ddb777e6756e60b37919f0f7594d2e8032a3c6b8b43608f09dfa4aee594a054a0543b956a6061e78372691e9307eaaec4bfcf76880fe96bcc76ec0795aff6b8ba9c356fd9f222aaa3c2730d3de199575b86b3b410ad922eb2f0867f8e31df07bdd23e3889f9a23f62aafdf07b2bdb18ffb0d613e88c8901d45491308a9d04bb9984e52ebfe9d817b28e385d3e98da20ce083ce999c0debe1cccfe194e66d1787c4e036d01dd602a7d04e94c4fdf346099ac6e10b2b9a633993b9b0ad1f2e33e7c4acf8fa9d1687944e74c2cf5571c588a874e1fa849ff171ea233e0c073c5e13d3a13ae139495ecefb2ab4ec9484f5b392ec29dd8500b63db6f8311d656b1accd2360936b1960ef1bf2cf1a6e76dcf36f7bfff8349bec49b306715798046f47438109ec43014b118f73cf23df7b827954a3dc51d9e983ad2ee95b09e689f53e19c2d937dd0b7d52d8567542d39f5ea3510a5cfcb0c8a9eb02683efe92b26a0043a9bac8e8391ab3c55ceb82130b4730ffd1dee9bc3a8b1c1a87c397cc2200c85953b286b67c23dab19087c1637632bf7dd245c752c24cf73b71ffba56777fdc113b1c86bc428144befb3a6bef5c9fd9cbdd232b269b02ffd8a23f588a033b1806287a9a812f6b05d9e3ded694fc46c0e2919f185519694522e15d6aa11b79f7745b17ce1815320b17b84669cff5c1399eac9fe53fba2013e8fd980235000885ec13df7bb65386318bc14ea828fc101d7dddd342a6221100ae36c2ac2b1723da43c3d4847922ff09a214e053d5395e7e331c66f886881ae7b95b3e1f835d5bd60724893febe6547c32b77b47a4bd12b03c1855f8269c02c35dea6b6daeacc56d19bfbdb536b438ccf120a679a7ea2fcf1a2665681a41d5b5ac7b261e0c9f43d149207ef6a5f11b1ab7e8495f6948404d6519ef30f86f7da746d438f51c097da767bb06a6f7116978ac2ad0b6c73b2696bdd55677b4be5c20459219b3d551d960aabbdf9ee170538e08455aaa6df43394a94e3cbd2ebbe93b3859cbc041ffe81aec5cb45cd2c537cad600a64fc9150f6928b0f1ea4a5219570c0d1aeca449d388e6249ab49daeb8e12d5be43a849e88cfdcae4086f5809310249f995f0c8e83c4782787610300c70bdae6600f88194607e126492960b4b3e559b68e21eee3f6f5d282bc4cbd055d0813624df114fa5b51f0e5acd2a2049bb411bf15547c52e97465fed2f1bb932a4c7a584a33f613bba28ecce638d529d58f1261d763ce3272c7d15b8519b7da7714d3aa6748cd03ffecb7bb1e0f21f39520de77f7fea2e06122b0977f3275548e47d713ba977cfbef8385299ae02f7feb5d331b8a78407b649e594bc56266f59b3c582d0beccac68f2dd480ec1a0533e5903eeeb6ff4628c7db3d351e273af8a5f2edc538851f21892de2fec5ecc70ffb392f5cc5f0bb9f0effe0e2441327af4e94ee6fd37afe6cde1c3e32920d1ea5ed2676f1f8427fea05d6a9e81cb92a746057b68b08c038e9cd3c2b1cfb1ee564f656d1ec9c124f404b41c89019102d0fdeb93b45aabfff05feca94a1a38d2d6189f4b85c2c61bf150fb11ff1dee69c9b4b4a107cda953481b8cb3be5d395568858e232342e6000669d3061b0a08b8170de1988459f941f32f0495d77710e3c5bd6f574248a65193231f75708957154236d09a1e0c5546e4b86834ef994d4c1c28f0789ff251edb2fd64717ec7c9142b82c7483354bb7a0ede6e1348c7dcf4423cc3485207dfd1be3535fa1b701f105c0eb7e92b667d0193f9b07ef74c8da3a2b1e0531fc5f30a2b26b916ec4a6fdc2886cd48b01c81c463adf38df05380fd1f79e6ae75684bf52f22f4bea4e9bde34da2163c9ad436471dec0a484cc85cc4b99626645976796eae6c71b8049a76b4e3384d8580dae483e874443a52bd6b40037a551387b95c98f92820841ab37a0f3cf6df592e84ebc1269c503a44ddb91e547d34a68b64b04b527b53df620ea9a203d7e7167eb168d898617beb3f1846737b748ea8495298d03d54beb82c40e89c24514a6e30699b8f342d3acf2f4f202f3146509052424c269c6ecf1514b2a5dd90d553d004d579f644d1f1fc13f6ace50c0f8f926009a7c2a509367e8f2e90fd23c1e90dd4979c210528413cd95639078e1eaa3191165e6447c8671e1fde683949db0d34420eee528f871d0eaadff20622610524aa94d42c987d30df6a9c15b8d108392c2a65204fcdc83ed9519420ba9a755594ff273078a5b5824dfb17dbb2ec246f85e9813695b9775b7dde1b90cc84692050db379b4dc4fc91710bfc4a0945e780dfac1b0c573d8a1f53e6d7cace53dac6f49691ee84de56cbf1a7547d160128d546326e3c0c56fe4ac3769db5cc71681cda5cdb1d367489515d72358e2a93ca2ee3c0af8c586321c282fc2282dba7b6f5eddfe19eb624b87fa8b535aefbcec2e66f8b81c1012918500631ed69c84425573f9dead0b16f25b48b084bc4e03ce7b715401d3dcb5cdbb35d7abbc1d66e1dc8d4f76b7c40286019f694eae5c94f798c52784991f049c5119c3785280da4fd6fc31fd0d97634871df5ef8f34bb8fab8656ad68fde87400ee7254da1ded0ec371e96fe46c8d83ffa8cea11903111f8583457e4215408d5ff1f5e5012271cf14d557e626f0d87d0b4933e36cf86b705f1f89369781fc08b8c376eaf2cbaa73002efd1da8df3e713efe7ad74e640359e84a17fd93d976e36837aded7cc6090c579d4fca229049db8c4726001749284369ba86cc28e6856954508b5f105a3afcc3785fb5157d02123cef1d3047c980fd29e9cd72fc2d525e229b9c95deca2503b82fe027f5cbf1f6a22e97ca10cd6882f86062f9a8faf8fb19b2b6bc208f7e4984e27ed43c0616bda10f1defdfcf7526b69b5b7dfdc4f1e20c9ec1d441f113818aa95471cbeafab5f5d9b651e6f2ec1b2fa6c53d9d5dfcd2e4ea83b8d99fb81c94ec59567d00de8df46dc4ad6674a6b4e2f5a6568dd85da4729a12b03d640919eff5d82e2aedcea7c6a96bc8e566af2c578d3fd43e236f1327020d473c8eced3eb6312c7e5464516c53f21f2be42b440f1a35e31fd0e0f70e37640fd340b1804cf782e013213037a25cd7fe548e760bc8211465e2eef1315d747e94e3e24cb8151b91f66ba502b0f229d5ac3a577230a5fec24e7a3933300dd1d3a5483d525f2bf359d45be5fb91b27f7534970eedbe11a1ff62c3d06369ad210ea634df1f9cdb0adc7e126a33eee644b2409a9b8fb30648f1d1d356edc44007b619a3d1afb1ba71001dfdce0cfe328c7dcd15bb6e6ea3343f7ae8ff73e20048bcb278734c79d48852edf032b6d804777d9f11e56a6f47ac939918e05afd5f28116819b1610aa1bf216c515de20e577ccf7c4c21cdf9aacf922310e111bba70a0f895c728d654d6b96fd8aded2587c96f8debcf607d1d53c270b3a66840aa94b3921513a54b52aa05fe3732897be8c1d6f4c9e5c4b187bdeea85d2feaf23cc457dac1eb341815517d6c59aa3cb266c0868f4cad6d8aa0f408434c5cefc9adb9e2e8c0a0997ff6257709c50c2df3fd03e40588c717d4a68a17404789cfac76a67a826e763d31c8303d82710b4b9ac318fe1d724d447ffcfb66fc149011861ad74c079e0c24a8418ed0ae1668617373901398e4bb0cf0004c482626cd3bcbb71ef603c6abf440c1923ae38976fef3fd1bca02f8ace97eb9d5ce4025b25575fc1e945578d7c2f041aeaadd4ad66243f209738d78e32dc91bf6e47bf1d9bebd58d9b628a6773d2c7f8ff5a119783c2fdcd5f37f9000e576859ec00beee1b17bc9c6de06130c547583570d572dcd69ae65e716082666db0470107348981fb468c41e0e5918c23999dc1a8187ff28d4f159537f9fcd22552b512610553f12072d1565dba31a09724a1542b63faf827f276390ea40fc52c8a6482a4ec003dd3110a2f7ea1ebc1485dbbf92255383d3dd79b9f5d736397ade35ce71445a65b0400e5cc9bf7843abae90fead7eb9d19d17bb48ae1268871257c5cec31437e610e8747ccbb8e1327e68061409dfcd4bb0f67f24c2ab0c97c6d39841e7a156b9f48700832ec3cd62dc0049ace3788ed53bbf8520ee87f3f848b7762b21e3f6766340fc1a1dac7350561d3d1f6c73625a8017632ef86ce2eaadb32fb1ac487c8d11b6fc172942d163cb75055afcb0530527dbe97f7c85043ac99b0955d9c965dec650ee7370382b18a297be80f5dcf727e71a3b8a34dd3aaad3512fb640bf6fd4ca5a4bc2e7bd7b8ea2455283a52b4aeda0139bf1adfe90d0ee7e43204ea05c553d248a6ced0815ef944b47ba82366466fdf69a02a4789121b439a7b19de54f61c8be41d925b6855d8b6ac7e47e044a7664707410e990569dbed30a7bae51b6eb026421fd2d1ae82bc19a8932ad901a934c1449365c97cf25dd4136f81de6c9b5285221783931954c2da96aac1703b5b4b4b4c890a0667dd44f89ed16e10ee4a835b39db01ffa8244137cc444858642707b4d6d0feed079ef488ee19b2a19e27f756090ca95264c61601eb2753ffdd435ebb95601591ebd1f5f14284a7faaac7527afba0b01da0a711f06e61d89080a890ed1d3ad79d23f0b90754952efebe3fa3d4dbb603e16c1d6ec1e92726022b03ce9ef80c8e90e2a1515c89a8d1f815ba3cf4c6df4bb82b84519aaae5b9a857d485658381f4ce3a0d1c8fa47cddc2ecf18c376fcdc21338af2ba629692ded830a56584b301e29d6148fc52064bc66ce5938274ac8199b7f2bdab0d3e0672f15856fe051f88454b1bf03a603931b6ce0644f359f0286e32c735051764d9a380b216fa176946fcd1b1813b6bee210e25d560d20ae9c7e9b0c9cebe42622b63d4ed04a22d55f6d3c76188b3e3aeff2eb555797851edc89c15eab8ae15de98d5bc7fdbde0e256547f86ab4b7f2344e45d9045df634d3577fc3c338d130066815aae39271f31ee0d7024cc3d30469d358b392a7ceccf7f52102ebb9751133a5be7df41e2dbfa2ce217de0857db8172cee72848f8443a0b6ea25d0fa7296ff04e28fd1a9949afe0b40800966b14c1faf952dfb8b991a4cc4e2a36b0fe10570edabd79c6bc8a0667a7cd09ce8bd83ff1846d4010e9258d77d998123832b7ec7857bc3a89c04107884ab4c8c17f0cf86b612d0405887c1534bf7c944c98be1c15f53f876e5454d052cbfa30ac64796abcde6e11ac75dbe13539cd9892e4ce0596db53d7a5585ca909015f99c59948b4d5ad0d8c70529967af662bd562c6b25a4a98f599de79311f8cb9ac6a3716952f185b9448bfee40588a3bdf93041be7c256e936d28acdf7c0ffe3afb2e1c78c4f91de0c78be639d8055bcd28b9fc23954fdc9466d4ef31b9935d4b15ee8912a9f73dc93abd76989d5462559780d2d58aa32f58231fd35bd3674469d581d63cb760b020923437dac9788a31d8886e5e25e07ef3b513e0951731cef994f37c378e0b52189f6050517dce804f35b0c506c6e74ec90828453ee1db58628549df0a896123f05d20b4cd7c4dece8d36d7695ac71cba012b230833a9c52ea704db2ce7c513d8b76894d94236c397d3ecd3abcbc358c7604f862d817db85e5665c7a408e2e6c704d230dd5cfdc13f71f95a0f200bcfb3eec6b622be80d2a081443b5e937c64a761c2380666302268c93fbb5ebf561ecef98fb48a0cc328827615a2171afe30e806f8d313c107117d8bf37293bad01e9d705a566762de80327d3f439638ae7fcd4f734c46d54e39b69fbb5922588852f73838aa148580de9b76757798901a73f15501a7b13389e2e6e5b3b94938828649ec5cd4146760b89b5cb8a1d86abe7d3bfe5dda3dec63f1a35a0230958f55ef7ed5fe25cca94aa084ef3770333af2965f50cb6ff478c637aeb85745ef97e28b13f2d2a2336f34aeb24d320335135df66d31d825ac4bc2de0e519ddc864896c60a6cf94123d1338dee5f2e211c1e6322a20366e473df441c96e008578373cf1c38293225368095139c38e67f8d68ce56a0e01fae8ef075b70db15de838c6111194aa450dce02a081aea7b9d25e0c48cfde72f6cceba6e4fd2a583d3f8fd04527fd3b3bd3cb322887fc1352bf94fdbc7562c59eb40a001e1ba7147106dac71e968d38e6ffeaa01255c92807f7b112ceb6087a1915c82ca1e552c0b6522e8f3ec37aa63a618039b2ff095322f37ed862ff543fa6f8cb250b2ae35135a272edabbfd8f0b6c1c37cab975e95300e6020a900ba3292a29a59abb095e0baa778b9d0babc1da9ece144c4bd76da9f55de36b0996c46b41a50b5ced7b1d8f4762b56dcecd20626763ebff21c5345d117c99a0a0dd499b63d6ad34d8084f406371c6cb639e9598c46d208b257eed3b3026b781c58dcb79fd5f5e640ba182694ebfa2cebd6bdbd513f8ad02b1df3b349fee38124314ed384fd8b09723ed1282f4f8dfee1af2c1c1b3b1369a2f32c567e408c8e5700eb520c60116c228e29e4e02e08e9278e8c40de44d22ef040ce0cd5a189994c5f9400966edacc7e46a5bb8416a487bada4dc09a6d0e2f4be83bd12ba0a38cd65067f7ce2aa2e0055a803b550d387195aeb99dca4207327464426b797d4bc0193a72e9fc771524a6fd265c5e4d955512e06361f3fb49a741e00833f396434b281b11d742808976d72c8ea40ee0e2842429ff89d540c8d45c7e83895ac17a487f8abfa0c60052ac4716a142b3dcd49382e31d0b0582099b4975cbfd104858ec52ef44ae6865e08b2210ce3b3a382de75c41ff92f006f4eecc9ec4ddb77b1ada4bdfa6978b19e44ff7cc72d982358aa6c4a41b7aff8d2d68bacb1a6de6311cc7bf812253bc3a96337cf5cceaad014942ec8a40c23c661e867062cf749dc8e0b4b49827f4b9a56fa5d78d624aaa0c3d3adf5a7e0830c0a0d9fd0040e4f2405c1940115a64a56c5e0855db28a22c37663b0d1d9d86df4a43cbcbb5274b0239f015d21a420f720f85d91e11fce264ce72b9a8c84a2b99ea431b937aaf998d7c7f3bdb45d1ee42b306b656c4d51cfab3ea04cd0479cc32addbaee7d62edb6c6762b1a4bae3b8f91550921843cbd9c269d53c6c17fd5cea0985bb501075fdc5e353e127b044807a2b3ac3d44f2eb92c2f3e2a0b1badf31d65d49b2acc2af7945d2c90104125c19710764439b2cb2f497ead4c258a52ce80cc9dcd7645df723803a41fb5a4aeacbb773b9dabc1400ecb18763623426d9b19280fb7244897487d623ae9ed20bb5059905cbc27906d38f161852d611677c151ff7b7e66dabab8cdab2e90286f2cf66139ec870b4335a6b2cbebc3d4b843391b2e467b7ea647f974ce8ab8401cdce634de8d6e04f1abb4aeab8503ecc7bab52addb842cf4faa1cabc02279523d6b4691c72af782ebfb2eb05b0e39662309b78ac05d4c5d90d47b9af278f19037dbc048e7451d0020b0078789f7ad1677d4871e7d4914b63ac3ba0d68c13a3f5b2ac7e5e3213ceb2f9a8d945143840430a3e6e093988dcca1aa039aac1c8d593618bc097a4342515a11dc95368d77df1fd6c6576ddf6d88a6ef8bfa810c3f8db220b13481000075123a6e3c174516e8ec4c0b664aace0369ee96b4ea52f04616588f8f72291c3f25c9f5b971e0ffac1a508c8c06527fbe1e37bb3ce2fb1f1e4b3b6b1556c926edf919fb0a14daddf523e3a6d6de1ca8e49a52f0ac59b50c559fdeed076b8c2a218c8f52709686134b78c916bb99fd1c6c6e6709ca0586282372fbe2d2ff726b667fc66b2680f432bcc88338c87af3c58fcd4447ad6e6f56367d22d3c77fc744c17d720a82e81384d171342d91d2831ed49852f2e6247f9a4697678095eedddce90ed4785145e463b9eab62901c78fb68c911d37f2db5fc3d835ecbe6aed0bcfa9ae65d9c6450fd14c9fa8ab5b94a86094f60e8670434a1d1d0eec7a9d7fa6c741237fe3d1ca29d6bdc9d43c05068d7b46e6791d26b6a7379bd273ab7300ba7dac8f4c6cc02929f4b0e7975d17391f053a663cd2e2bd60cbd3df135354dae5e36f1b89076800578065ce1dfd4af06f66537e967eac6f7588ce771d75eceea5cc69050eff370170c01ff01eb021d1cee335aae718a4b086d3278fcee57eced37f3733b1470c8ba0b2415cbc4e6ac95d8d7a05df64aef12a909310ebbd5dbf64a3b47ed2ddf8e68cd57e2f2623f0843f8797a970b23c423fb4dd9b62142e7d2cc6793fe7babc9ce99997b9bc9524e921de39c99c0b7cc99f45d9b395173d3b8b2722472600f7a2a1269b924fca13875b26b7821ec50e7f7b0311b89d6aa6b3918500deed9252e637153ac55b247bf85625e50ef5d27d2e782dc916126d9542ae1aa16e1e8d17a2f69054e204c2540d5b54bb1aec60da4af8e4f91e22469de47943cbfeeeaf16e600df809aed0dc8f1aa220b9c91bf19426f9fdd1da573e20cb556ca2cdd5a48bdf94c4851d6c72527730abd1edbfa6f5e9bf9a918ad538fac5789b67387d67c70b39980df5b913b3f64500528e818a2ff8bc7d1836b67000e2271ca71ecc7da97af7968f913efc3c3191e9d6ee29bea92b2ef705dfd573b2b06ee65d0c9a51a8e78fb07b831ca082ff5be0d239d2283dd92aef61c7f7b78c0c3bc4b6fa8265e55059614f5fe72ef67c3a049af1ff92d7b8498f0b11f64de0ef507072aa21c70fd92190448f7bd736b085c48b5858be28050d99241d4623afaff61dd6487aef802a244cb4a39bbddf79a16318c0a032632c31e9b343e47eb0755a8cd8d099707473c53747cc2c146de99db47df86123b74ec9a534b7f94c30ce73a78ffe8202fdfc412fdeed45fe5db18892b35d4df6a72d3be85837014187aef2e8b5a9b69572dd083fb443d84115dc1b74b685091e2471f628a2a4fc78b666e4e46547e69322ba1b8c95268d8a3d2732dfe8032ef446f4f28cce7402c8ab49e556ea850b2779bb34f6090772c86523e2345c78c3a9553b88e6eed8648ee3d30b6f9310669e470e58f42fc02d7429a0b0c9dd598b4f8c9e63d5ad7eade4fecb3e1eabfd75f91941bb8e21679038a96104f05c04d9ee996dd7dc2efdcbe84b567a0042379bfd383ba6afbad5dd09d2f8fcaf6c85faf046c1ad4a826e9ca3f9756632832352769dbf49ff78c5d918887d8caa09f507e8b69c5932cfbb9f846354469715b32dd8d9d46b2e8975e5ff86288a2084d0b001be8d172f4363c1794ebda05da46682dd4fcdbf12914f29f5092e061eff2bc73bac8a686c93834b2aa6ad1a2d891008f44d95fa285600bfe873db3d98a78fa6df4f23d78bfaa2527012bbc3fd2cc7fb2ce583363a7b05718e532040ed019c8eea8bbcecce6964af716c45e2fa23abe59521dd164ddef9596a550a18b523eb396cdf061b8b597e1b337104e2070b8e4890981d7e858258f3833f52ef76f56111c2a867e46b7257bf7893ab8aad2ca6b3e2ca133aeb696971f9fe3e987aa7c5fc2758de7f8d37877a53a9642d2382f823a73a69299a2c1025b0fefa5473350d53047a2d506b92fe85ffc24dc8696cadaae2025c5298e2aca48c52da89310e25bd0e34ab33a075ea03fd6558fe3b9fa3b6aa241052c7916a1b467f42460f89ff50a2aed6d254a0f8a32363f7ad9ca15c638da2ae166bc445fd45257a820183d040c497f5530c3a775b3b20e859051ef222d83c14e1498f8a03b02760832eabcfd4c86d421c26f89f3a3fd1c373a08776af67341698a9ca8c3062e160ca041a17abc6ebb03ad3497df9297f4804b955fe2080a08f5efbf3059e9a9eb94d228b6d2890a4f96894b1d875d6f46ef505d623190e3c92e5f78fe6c9adcef7bd7d6f306ee03b5972bf6201359f9ac8fe74ff2be918c4e8ffc4c156c6f388b4e33c845bf243ad14204e7ed415034b2eed220527a08f68a07acc9e10c8a2c7c2058a4f3f4eba97706c872dc98c4e18f054e7e0ffdb23fa9166f9707ed0cb616df04dd1f6d8e4fbc5abd685b69a33691d66403c5c67c29045b02f0e44167a0a661bd6a7127d2ed1a845e730e274e21499b1845c5abd9baf0babed232f0e4e8163e67cec9b0729e6d992c6aa7f9a84b125a2cc4ca859c405823fef3188eb533ecbf5cabe8c959aed2ee056a5963b6f71a5866cbb8743a9c0a0c15a1dd4c5bf68c175311ba401986b57069cadab1b4f8c699b0a1f966b64ff2c4fee097ac05b7ae0b95e954512bbacf9e0a1576b60804c052bbf3d7221c953db4cadcebe4756dace616684a1e6a95a4bcded35509ef2820a404c50fd2ea8fda31d893f5c7fd81404165eb47e0e2723d2d531c8e445501f69878f518890a037f0fe092961f677b66b2e3c1d06e4e48f967e9fba5c86f4978c1a8e4460ce685a58dee13db45e1e8b3b92da4c8466c8b6e783f055cdd12394e77e36b9ba972cc3a1e934d2cd604c7d36e352ee3554665db893ac8c50d6a26492aaf50ba226f3c5a986ac5837212ab47668a058d3628026560dc3ce07f4c2ad9432faff19c964c3f91db77c5d8474935396d5458bd8277f4418cea7f76f2b7c56067d1ec80b5db32d80bcd42fda1c7d3057754bc00ac10eece7c63e268e4703ef93ebfe36e24aeab217780bb6dc1701d314dd0d0391e99057f4e9297bc5cc4605487be9aed5bafc2c80ec4cfe5f73b041dbd6a0292394125cd56734339e34a1c9ddd6fd19b8710f4a49910d3906ed15e019b49d2bbfd3244af71d7e48500e21eb2d0fabb2c0771d5513e89fbfae0cf381628193175639056d3c342339f5949e9502281a43128035c49d580f8515e440cfc304c442d6ae9c25b8465a2911e47569ecdc52f19de0b668c48e928f0b9fcfd7274914c66ee2e2e136c0b4faac9889acd4ba04250b4659bb037f8c07f7dea1a401344bf4b078e9542cd924903a88d70e965411e4570ed0664381a1e307f94dc05485fab5651a7438b7c477b4c402fe41e437d58a52d21cba8a58849783008aaa2c4320606747730fce1f4a9f6fa624cb0e3b9b9cd62c67864dcf37df0f7c8f5139f76930ad57a753fa5a4808fb96fd8eb3d9ad4f41ee9b21d37ebbdf4332febb4c5f80fb38d08cc5ae401f53c169c7e54c870e0fe596b6ff68e1f4b7d78b2d852935cb335a5b0b151a84ef16e3b93558b0eb4ead669de24bf1e281ce84a840cd4b287c74ecd8d48c9aea6fe3ea5a70a6f1ae0003025f984d209","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
