<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c4de74175c654cd91540dc5406a84553ffb705eb7cfae622f49f466caf5e7ad3a50687606e47cf0d6237e61c0c1a193ecab879d057b8239755c4d225db00fc18922f36721cb60bfc89c2d4348a60374df11c41eac7a5e00cbba48a01225cf4adb9077df49af11b7c9e78d35d1a7056b61a343b7f15856bcc79f0a176b4d3b2d6d11c5c4f166dc5b62ea0483edb7841f6bde6502dd7fe63d3cb7c44ce2b9cb154cfffb3064eec4df3a91ce4dd9272c995684179700de6b7ece38a630faa4617b05b606dc0009a18b7140be1f34d7c88112eaef75e6361c8e42a57cfa8e48b318dfd7d78b4a96f464fc09ac60fe3b6d0f19f4fa3256b29999ec33ecb63b54ec58b07837e72a530d47dab30a2e45bda75bd8a3238aa36d9ee35ce525e5f779990a108233f7d57f4100dabf91c4b49555cba55d74fa29099d6875a4e3181b53b0e9aa22bbc0dbdda62f6ed48fc19d351e477793c0496c9fc7738c5ae404383925636fba89685677a38d605de69e7f72dc54b370ffc5801a2be2d336cf0a8e16db71ebce9ecb928f5300d0aa3bed641e2ab60c16b430e1e1dcd4dd703ecd54f41881e797cc1cc33358a337da67dbcb659d57fa474555df47837562e59fc38e7a8295d7911f7f01d4d8d529aa523c49d9530fb6d4ed9f680d722d090d6ff969ee654a2477334b9e0190373d67485e84d7878b5f82b560d87d92b6b3e6d0cbf03cc646a2b7dc51ce2d8324561d6febcfd91f5d1b528389399504add73bfef37b40817d82219f0b382a4fe5daa0b64199b5f3828133393673b6fb46e215a9a04a9f0fa9d92c2b8234ca003d71fd5e15eb049fed4f0192802a4559216a6325ddb8e77271ed9c780724655821430f26866d919149b64215314b399b562f8a365e3fd68ac5ca2b5d9745b469d124de09b935932b6eda276c9f67433d615817a4426aa537286554e6ef2a4db0dfcc9ccd74e2d6ef76571902dac746e5e4617f8d10cb3b7a9f2dd71051494fe7bd81e84f2c3ff5d34ef9adc398533010b8d0e52cd5f5e2da5d2f0bdca60a4b73298e85a55649d0941a216cf90213552f89b780c072e198e8119d6de0a3a7246c32537f9944587fe30de4e5acba5b6721a22ada4444b83127f707c6adff760f947abc9add0a2bc566620fa0b3b54b5dfb256d481866c35785ec8b479fcf10dfb4177fe1f910a00c0a3018fcee90a1ff8c333ed69917b79d1394374446fc7df253b115161824712db3e7dadf6427db8cb8c056b745bcbacb7e42dfd2e339cb169bd9d61c1bdb8e2fe100c4cf5732750cdcbdc02230d63aed48301e27b7946a41962cb439750ac2688a57d329058adfc1a927f3ea4fef292215c6415576f2325ffbb0b4f6753e91407a9cd2bcd8d30a7d1fdc9a26a046b259db01e32e7d7481e129b4f7f161401ce261104e38ef5553254b4f985bd28a71ee9d9de22444e6bbb832f5eba34df66855670ece9cd0f711953698a4bf3366eebae14ffab1ae57439ecee8ee17120a72302afdc234b706fc285ff82b8ffac7ae1ac7133f672326625a3991ebf1b6d0f30c8d69a1e4a22eae5ef1c0b257c7b18adffdf6ceb3536ffca50d7bc66f1c0693e3270e30fb696f0c34e663cad99f2240e5fd3389f0a574535e6799577bbd3da3fe9b3fd0f22fb436caeb1556b1e9f0c1d89edd697d0edc6f520e145ce7b8f936b51bb3c4ed404a594eebbd82edb6b9f92c1e89d2571ae49442bbc5c0d31f8c490db33fc81b94aab91578041df160724f02568553021bd3a7d9f164a7668260d887c1da8f3c0f44a7cd3f123c2f62ffd1d4ce6876d997c87513b7abf22365584033e237673fbe088ea92bd018bf90cbc89cefd1bf75a2271096b4a53eca8c19a321d2586ec7d61e26e149c6fcd0b03d5b6c1628f4e06c7097fd66cf8b76902790f877284447b9bd874944afb69e4397d44de817faa85492c80b398fb8e25eb46e2bab0242e073d3cf65ca7a0bedfcf697c3c0e970772f5dbbc5db258d00e56eb60f0ab03c4a197bb03bb1b0cc1155cf5eb6df6ac196bb50ce1b79b1f5e84485c4b1e9df74403f54f8b72f4c138d8a2181e33390d65af2a6d992b49a96037566be1cd75d8f7bddcca930c76d25ad191911808de05f5b80cafc6ec48a0980898e2e96c92bb982d16bfeb0d32b0beac2bda6c7b89d8a5e842997ba91cf9839283b4e1bee57aba6de405047fe7526bc04d083a3f10708572fd6d2e9b60fe2f2c16324b13b5d5ae76484b6183f7191334dc17ae1f4f7b14aa983f0dbc139fb2ec24a39664046e3e65c721a5983b0cb6b4c96248c9218917eda0cecb5251bc2034652688c40cbdff86a693bbd8ae6d9e20dcece0e8fe9736c57800375f64431019f55c33ee670651aa38a6257812e0d4c27b61a118283040696f79cccdeaa304e495edeec03e8b32f940f7511754db541e4248ea36442ff62f10a93b770596306f5995ae54a8892e885031618a27a0448fd6bf39424a458c12e0b06ca5019ea901e68284b9f28387a0382ed607c2e7b59561d9b338d0cdd5b22bc265b861edadf8778e34e29562e5121e3317b0759c13f2b5fcef04dabd48da67b2a9c585e0c1c3b687f16197d6364c6e1ad3dc0643b04e0f3a9de8fdb67c4791f348ebc16fe72914a0552aca0bc4dcbf2f48393484b7ce656997c46160ce3a9d5670680bff73f79aadad6034c8903fa61e4051d9c98b0b6d0898710f7cdb1fcbc2a1a640d807f598abc327495a6ebf3eb83f9aa251adc13d75eea76767ce3b20b117276be290e1420219f50e23066f6eec1ad1cbc1d89f1bbcde307cae331460ab39e0e335520c4d0236e9c8a916db8d8ab5fb435a03743f6f321984f9f066b12c49305a9256f1172cea1f497b83dcc99a4dc20793e720d0bad3907ad2eb34a1b35f6f75e32ee92ce19998ab8edafbb04ebfb0c2afe7a7564306513f63bd8155efbbefdae29f1aa7368e65fd0957982a122ddef76fa7a677e18f0476c40614ad043353ea98d2b3f9341fe5af244168dc3ce67ab9279d3a34c1a4d1cfdefbc805fa52cb1a2e9d7915ad8ef024a5e19ab9d1563c272815485054647636f625b32ce1921e7c2ad351fd4fa50f287118453bda294fb09b3e4e5abb87b19ef17c7150573c04facf1206e83704470d10097217f3b21cf50946b6401c8c6b96d9dcfca00a8f91200a0437d6ad136f6e119e1628465fbd89000b807efd5778db93f03328e9fd693a8980aed701712ce8796cf6ca932288c393342b0e0fa173b36a0ed59cec1922387a0e826ecd1fc22c3f5f87aafb049057d1a6d0e219e183a63c268ff90396c1ae923c1567ff7032c87098a2874bdd38a27100ea271b725916c2617e1671a05021d4beb8274fb93b1fe2c598f560aa902b65f1b664b14cd20f9747b7dad7d57d0ce153532d9267d50db177465bfb6076725432df301b1373a96b23f0a8bec5e73cfa5b54578c7db747b3a287ae752af58cecb242128552845a07835e2d7e2e2eeadf232dd7c547c7efb847a288ef9b247f67a0849768aa55332c2c8bcfe4d0846cb0defafa1363f33a56007cb637933db6e24778a56e2ae8688a98b13367f0e0afca830abf595e28e76d6a5f0bda595b39230d1409a05512892b3186015c1042b69075a484e072b4726a8e5f15921351e8718decf3b50fa54b94d634c84dba3662cd4ea409849444a7b2cfb8bf3bd6fefa8fe5ef37850096dae6e497a158eceacf9cd3400622af3b6b1e5df0a88b94b5c053dd4eaa7cc4372ee824c0f1cd57d63c2e6f366f247cea918e75c74bbeb5e46f14d058f7f995dee851a35cb798c0487de7ae20f04bc552a983d0b67b17a264b19b0278bc54d8f22556b0d7305e98d9ad599d799029c9a350e43d851f869c4b20428460046298b7b6ffdd75e90eda929ad1e8b8b3f4afbafd5c57b6bec0126ac7ba171616783d7503adee458a9ccdaa3948878fe74eb9921f43729d861744d6e1ea34cf92bd4ce9a3ff337d27fa81e00b9f92cf7bed760cfdeadd3be08c0ca39b9554d7e5858b1873ca782e9a458418590b2942aeb9a0e170df18629e46f5f226bd7c9d75f0c859863956edb931805291254311678ae992bf4fb7d6c7dfbf33db13049a616c823333ec025157681db7e5f40d47a0f51e1788b5619d0a0badad59dc4a6a5f2e1c47aca21bb4cfeda85581513cb96a149dc4737550ec941d892c155c5d8edf3518790294d9fdf75a317b329c8ebb1c6a91f921dc3f7dad4c3cca660499bf0d47a8d11b205fa5f65a7fa9111db9627d8126a6a7851b34bb024c9407d7f862674d2d0c693aabac94860b00a80f47b0e5cedf19050d5cd26dac43ffa5bea3a8ab01ae86863ee2dbea961471709e8c37271d7a8d72d158166565ee5cf0983754f041bdfc7b6cedb6d710b7b7b16c3656190fbc8f377fd4574403dd927ed8f141f8195b3b11c096904224278988004bfe7944bbbfc749b47eb295ea38b035d5afc990fbcc4506b233d3e0b5e038f7cc2713c7240f82d66dbd52fec868e2c9bdb15b71dd3e958319e119523048eb2bb71eb1a67183e519271c2dc5916b37b52322c9e80f74d6da4d4613d1acfd76f4dbc2a97199bfa4a5dc4d6896578a9f28c80de37fa787bf69217e08b521504680793377807d0c48e778559326992fed784d98228f6a65239ceaf53767264645b7bd2d14aa119d88e5502fbfb9c402e3f0b16f85fba71c14027c06d153e5ee3d8ac1a086b9981b0a3f94b5b82023f38abcb90ec6c1832d7169f4df7350addf2f1c83d6cfc6b4d20ceb2c115a7ac6dc3f8a3a44bccda76a3880795cc5e205c55e75679c2be77fcdb5ad7f0918df8c21dd65225562e74344b272b38717af41a14b2e1c6528fe61061eec3eb3b03b1cedb73682174cef1b7dcc7e880cde9ddf9e0059bf93e120c15f5b64f99760165c9ca828a29596e336aa79e00446c7efdb613057c7a69e0b053a5755a3b17ca5d0d6813c71bd751da377850c837c94d80c4aab13954a7f043a93ac42b5ab1339fffc34977b784107c35f0c1a475dfecce065fd6c0252b87d2bf524af81a6680e7dc8e5747c1afd23eaabf08f9762966defba2ddabff996dea6982351dcb51fe6e61dcc68caf25e0658caa1950037c7a95df325b932fef5b7504f64e8932a2af1767c0b5b53d38fe0c830b441bb9b183edc64acfe0c64faa8f78d9a99f7d00cf71f50ef43761c848b0fdf0fa2352e686a3454ac280d83e34eb4a6d11f4282c997e469a2a68a465c9a89c1183cdc1d30dd7c876ea733788ed9df8cef11c21944105b92e2cf531d1b3ead6d14f7df7344ee171653d39b7710bdb71c0ca0559ab6ae04d7fe4137968a9d2186eed3aca52ffcefd4710d033a2cf317d70bc3702176afcd5bfe286c4158e842c2f7eab81ea1013f7a5a380005f5fbc2ff62854a8274527c4f7923011919773622e2f16f165cbdcd4cfe7ec4490b89b23a49aa28ef09c2158b5a154b1439b0c6601c9e0c6f4966bdba68fe3b48e62e002264e8d7702c692e58788f0f46c605074d546e0cae7b8ab630f61d10f07309fd89504138c6421e33e84d92fcb1af6ba84528c4b083db832e4b7e1013e82f5653488c8c5f74f3b6a015d2bbe68075f46b674d9b0019174df808bc1df2bf91d1bb4751f773f8710de93603a8f92e96489c700af013e064584a621a5f71fa57ce9d81ff5a0d7d822be533be856920de97e3e57e881c3d01cf66998402baf45c2cc0fa8cd4fcd69d64167f26110b0423f944d36bc654cd512d72331f1d8c16e2b7c4eb5d00fe36e794f00e19856ca300054aae403153d3d8941e4ce589155278b6c4ffb0e7a430f8b81ce002facd084c77bd51afa81e835fbcf1ad5adbc58ffe893984118a419b3a28e0aeacff515eaa709dc9fc58d306f3dcbd72fc792eef52145e02f9d47a9fbe1c6c56088fdca260eeca7e93f30e7691b8803a38e4d642938a6621070f9787e6db958fcdbbb02ec9bbfdad182819fa97709f7d98c9d22ff18123981fc0b2b3212a217cfaccb6b947b8af7c3bf5a8a34bbf9ecc8c8a2f11f34e8bf80964923cb220a33328ce2ed22d9dd6be90039e63ad95accf7985cb13f59a166ce6d017cccec267af87d98e5b69fac218a83fe5ef6a2d5146232d34401dc10a3c5a853ad4b1d2172ff61b92a6c1c4c3415c6a87b744d9d7e52f35b4d9026479e78d981beffc2f01644dc5dd5162e423bbdec4f5fdc72d05e50855c8aa2d983d9081f844bbe4e8b4768c206653aea0e543eadc122e4517568727d27731ea2ab322120e053dc12bf370ff35d02b8019ba00ce2f7f93d01a8e285a75323f734dc01f8da6c94f33de2d3cb7988af0b9f598a88034dc372e13d2f5673c054c2be4ff4f71419e8ad6e13134b22eb6b43745e5d62b078162af1615bdb97d7691b40740dc3b30a4ec968384afa5d1efc74da8bc10eb8ba49017783c5f566961a1faffef61f31d02c9399fe17226e2c94f931555be2abd22e4d4453cfa035cb543fae9b3f49b0f839667e36169e90771a3e6ded7d025297737e1f6d630c9439cf849aae220182fae63f717574a6acfb6f4505146cbd6ab181225e0d20905250d6cdec81bc286bb232f609234c67c487a5546f3d3bac435c22e267398c87c5eaa3e94ea4e55972155a7deb9b7713b0a74f20ae3de784b89abffac4e293933081abce17583154bc5840c8470475d5d6beff38c290fcff902befb58b896d04bd332be936e3b864c4c2740322dacd3b32fdcfbf75a327c612d49b9212836cde5690d994fea4a9489d6f3a1c5ff8be785e24bc0862b3ce2be2733834fb8e64bb3c93cec8f9138afa0288c21ce6f1cbe1cba196f27df5653f0230232921e21565ad64570aa91545f47283e6d305946a15572573c2e075c5cfffb9b99e18eea8ce81b3415ffc88e13015579f3e45336861b043f24c7771f1d3b67b71d6217a2eb53a2b7710f100b353784956b8903622bca91a38f6dd81624a6599a89629e9ec3f70b125cb499f03777b17ce9006203cb59699752e394a51a4c2038a46ea2f6c97caf9defc1c5530a76eb782e34a7cbcc3500d6593d3d9dd54568cc7520d8532462eb81926f69ec39bd2102c334821a1b08bb2089d73195d3cd14c4039310ed2f5bb5406c8accf15685657c460cc393da997bdfa005dea7878b9fa593e6cf01089af3289836945ac0b56a8b25b5a89cdefb64e47e5ec4eb239fbf121bcb27f2e5e85def047f9a1210e5cc6497fef5d2e8a9d40353f851546900b29e27e453476ffa6c8a2b80824983dfb078947c47b33e9b443a77cc1f9c3d6765721cf42f267c9097089f98effdafac1fb58c485bf9859bcc4fb5a433f7417c9b08d33e821db5b5b040e5cf6662e0abf75bbfb74af97c5889def10e022f74f22e861df7b09fadd9df50bd34a6fd0294d7cca9f55ea980cd14d946439edc435fbcba8e959fbe01f148b474bc32bf3e2594bba70269d905b5a52153ad4835f6421ebb34bf8a57e26b8f2c84347b93b6fb3c56d0d6460df529bdb4c2937fe5fd9469e4455622ce370ac2842a7a9cd0d233aad9875c0caabe5e6db578ec6f0435a27259c08aefbe645b8725f25d8384ab915109eb228e018f0a9b5ee9b63bac378ffba157eed3a37d39b5bbd7c8165bfaa974c3cad96be99ddae33885f351eafbf85289e8930aa0055fbaf8759e175fa260e55d9f6d1ada902b3fef82aaf877e024f2132faee1b165911077e0953b9282346cf77955858226068081a3739fbcd406798a4efb0a1d5e67c904f25efc96cf0cfc1f9d6b053d1c3e0e04c1eae3e7ea0c7493aa6cdd5b1e3b4cf259eca742af64cda2eeeef25ce8d9507c5f05a385803f1ca4a9ccdc634a9076fd5b87906c8b5a38f38acd097c878f206641639221652b0aacfaa6dd4b93fd5ab770666a6986bb7701ff723654c2d3e89dbf56365dfce5b7ee00330bf7e9cc18524c65a9d685dac5a63426feb19c165abd4b53d417fcb6e561f06e4c4464759ffa63e2ee07392b929fe2c2e4e721a7a18c408b7933a70a674094e078b14c582e630d68612d06708bdf8438a8120329926f19b3558fae8606b75d7e235e73bbec880982d4c2f5bd388aedd32bd38988b664044df968edafa6728139fb435e0ae558a17265766a27ed63498bd8ec3754480191486aed4758c28903df9fa0b01e352c809444259003fedeb01e5adacdf10d00143c24b654299a0258cab9975f231d3db366f95a1868bf3554d853c0406f77849dd6eff3b7baf855c7eb398fba73ac40320c39f7a7818d9a80204f341229548f225946f23b03170c8b00959c33a6ffe9f58e3aac346b175f24ed583d1316b11163c46ec11e634239166df17a37036df6e03fc7be7f498637ef193cfb01e27aac3dffc514ea6b82fb72bb018af6f0f091b506f7a18cafd859fb1aefdb19d7c13ae950f32430b5595ce61b29b03c7101fadb444f814e40f9b8b405c9e604088d34faf95a112192897f8d51ab765fe84c458f8778a588fb2626bc85c5b026e4bb1259a9c095c04d35c307bbb20f58d9d34685a77acf752d242cf664caddf24f41907df781e84750ca1f648717fb2ce7b60299525f0b4a94de7307dab5f75eae40902c6b1d7d5be6a1c6d286a1f8129cb03329641ae329dc49dafdc8df8af3b666b43647240e214ab7a4d541b538f3122673cbc09ba9cc190c06252c96fef2ba80783947aab593c90187fcfd9b308f546dfcaffd203318b6176841968ac6f5e06f6f4572dfebf710908b7eb4d950509a1ea4c63320dd0101380564b522f87471817110ae646f29b7f48835bb8d400a36eefcb144113781d60387be8d7ccab82b47051e243bc8c2f4c2931d5e16c1d3745c7b85fc3b3b7ccd63f4eab7a94133e5cccac8aab24e9130d517ff126dfa5fbc2b03ef5f0e6f5784d91a9e3bad4f3d8e4202dbd5aeb1ca5d9e6363b92063c4f98db7fbd4dc297bcd0e8de9fe7132e5fa6e81b8595d34cff6b9d9818bc71f342924d782a4e7c8a7490eaf1bd10026a4833cbb6fd63a4cc5709fff55ef2a4f78941e2ad2199eb075b6c824c7f9e55a946dbda1bf2a56b9045a6e404ed637b2e976d9d1c5fc25c24b4ecb76e446c38ef3adc917e5b387e7aff902ed7be2d01c323e7bb944310fc60ebd74a5c02c975e3d21c40f1463a9d2ef67b7cabdb83058e61ce4e47faaf07add97804232a8af2042aa645e1de55c495a95d4136f7c18ea2bc9418b88176b7a8a63a514c49c8cdeaa964bd24834e6e797147546c4ad3d8b35575966de19441d3b5e850e49bc66f1b21e0bdcdc4b4707d9120af81aea1cb595d5f64aca7232ba5f1976321466d160cb34e11e4b7adf3af7d9ba1161f5bc5aff17cb31660274b21f5b11c19b8f37011280d0e9b7b374a8e1d7ba3002490c272cbd7cd6d56b7722e0412d61e2bcc01b3275b039873bcd1e6a5325cc602dd329f544175c5bf8480cb746ee68ad5f49f1687b409088a41e1fe62f0344e0c61001672e612e0493c90de0be0189ed937472efd3fd49b0f8c5f82f05998516358f2d2c07ba25ae76723978705cb82589c4682e498b3f1d8333f6ff9f9629062072f7c90bb48db36560930584b4f71e2c3118d4ced5ac7dfe2ce3240377a600d2cbe071632551dfce50a9653c543f86ad2c8d78a1f9c703f51c742802d016fde025a429c5c3d263459e5264d58d5b4bf740a1d8d8186fbc1385813bccf36bed81b706a9b4cfd86a8a29e72af5aeafd5181891f767fbca510ca04795f987891fb84d2af48df14c44f56cab71cfa617ff71159610a6d1cd3277bf51ab6033ffe62962e25405356cf11f2fffa576dfafe5207c4ec0cceded8a4da9d24f1419166fc4e77d4208d535c063781bc4f9899679c28601961e749759809e9fed497b189819a34b4172719ce64351bd7dd2d9509f0fcaf87dedda2183bac863e8ef2b2906d4340c63c44532fc30443dee2a344e33bd03a0ff5968b4d1057b34e7c6147df5de929d3503593bce5d4e8b97e5db770ccfceab961a6a2031057c5d82f693360206b34930cbc12ab46a1d19992c630df6215f12e922748fde0258109ff8872d4d372676abbd43d5e4b6c7c011d9f8aa9f0e875f24fbde6ccadd8a25ffb43d833bd1e8a1ee44c668eec6f22ab189f1a1ea7540c0c56e5b87d9f5121e6f754bfca4da51bf2d687e2334e8e93e57d572cce57dff2d007175fed2e6e57bed9bdc884197a3177388ab8d30e70831136a56fd625838156befc2d92d78a6c5c0553c5d4b22c3fdf95ee598854793eacafd202ae0750ae1142c2d60f65f642e61bf3a099d9c8dcf8fb56592c89201a212695b004af2007884f1417f1fbfc3f757d8c1ce594667c86510d15b0de7d20916ce1a909abc2c131fd6cdf5363c8562eb09b8c02a656b736ce2e6a41cdc57fc616325fd8d7c5acfc891da6233de1ed04870eb6abdd8267649ffec0b0072673fcced3d07c09c93dd4434232b912cb970dc3727cf4261762a9f26ba289ad848fd72b19639ae4e6bc0c668d53d384ef5cf5e91b738e7f1c8436a8552ce103e7002227fa9a72252d568876a66d2186b110a6175be85059dabb48199cb414014bf881b00d71f5bcb8adc77930eb973a4f7dd30124eda239e2849159cf135f3e25271714732d18f3047782a15f2aa2fd5e2138f2dc6a0909131a89f3ac919f40dbf6d4c846638a539cdb670238e55ecea00c267ac34dbda85aaf3f97f8905a2a7b0ea566c39db5396c7896ad4263d5a68801e84bcdd84fdc17ac5f4d2a52204ac8e7acfca3cdc3f69585ee527c50114be2b261a2eafefb79cf252d86845dd78c4df0c9cf20534fc91ce69131bda2e8466588b22f17ed154eb0083ef1af08dce63e0e2072dd58a89126d68af489998bff213930aadf0caf8ef448481b46b014cc8167bafd26257c8232d242d51fa745a040932346cadba88aad9a05c636f9b59c277cd25d272ddacc61261d245fbc058195a6485141db086acdf016e87e1a51c9d455015334e703e7751e4a9981c895bf2a047cf5176a13df56fddaf507d09b7bfb04c0dead303bfd53db2c5b45cb93b1328894904c8da80784e9ff8406b311b4527e1cca63f89b08db4acd0c290a879d753802db21f7cb7a84963a94cb6c0b801b1790a777d527556e29cc37885c411df8e27f2a55b4bc061f22333852db4bdbaeae0498a2128ef159e8a58e44384661fa0efe1a86f63846fc36177b2f81d133e840907818d2d303b971f5e79c6f62575a18ed5dfb07fd3b017aab4544f534d694076562a7796d5d0c01aa29fa9bbf023952bb5dd5ca54defb252998cd4332c41cd52e3cc8f0e219d1d1405394291a005af3fd87a2aadf7d3436c42c2a1f8b2f71f8deaee0bdd9442af923ba0804e81dbb2bbd97a7884fe959f1f32040d7a57d6f6a909072f9df0bcdc4b0938df05417b7e0e5ad40f03bdfadd3400159ee42f1d5e389c1fba113f6e321c1f14552328e6bb6d3c895a6d20eae209c08dc575c13c1b6c414484f7ccfd73f9ea9ab831ecf8508a639c7201b4cfd6add18d2d5ba7e4077e46e07ab3c127864613231a225f63ee3a0cd1f695b0434df475aeb698fc0ce5154733264d22bacc2e72527ad559df4783133fcc28151c5b05b32784bcef090a4be4744996246d94b4694e8fdfbc4bf0ef23762d22e1decfa071b878a4745f0dc1d53c84f02a5a48aadd6909ee587671a5250bb8653bb68d6c54762c3eaaac24a2b5a5f3d216a8521c0257e0f426d3b41ed33a5fa629dc0568fe40b7fa138e9b40a7078cf8c5e20022a605a74b28adb46b69055b22ba1b9a43cd37db5a5ad3144107ba246416ea7f3a02b0c5cefa32a5b7a2cbc663525061abd27aa1671cc7079e4807b9094310a2ec157d574859782b3cd0a2d7a0100efc633ffb5d52df321a8ec026672f5fc8edb97cbbdefbab51b4de8513a203e79c656c4be2e0566109c6158b30e3ec86b53b90c4134d98bef2bb897eb10043053c2a9fd10347a2036752fe9c45628cf84592faa8536cece5eabec3a2697fcd25fd7f453cfbc0a5e4ddeee4aac24d0da028ac0dcee7862b11dc0b02675bd154ee94a1ca799ba308502dd71665cc9abbfe78d5fd8ab8a24cee77978fe5fd6c6d34f6d763609e34276e06b5f337a68d1634f8b99c9f53e24c1ed10d358e1405208515397375f9f40a06e2265abca6a668ec6f07bdc401b49ea5b5b82e42eba9e2b595d525cb8026f6a79f4408dbaab760ae44b0bd5774d9b1b5907abcffed54717e44344b0afbb09f11e7e6874e777b295609d178e91e77b9991dc5b9a260d1ef0c331aaf29b9b1e2190bf91d5a4d10b1f23a7619b60026b29f503fd4695c758ab19d6679431e2849786c05bea5641f67082954156f745747c714c3b6205854e12cf4e850b4d480d931f24c801d636e51d9481a6a0fe98251b8e5cbadd35d9d0061313e6ef3267773dab1bc7d6ca3f25d608f6ca452294dba9f00b5f203191990c70924ec84b0dc5699cf88037c0227ee9f69920d9d75bf53fd5512683e050d6f38687e54f87b686edbdf56cd3e353a31f3b5f85c9347cc21a78c28b3dc458905cd38a93607f0f7654fc2307a4ad667fd97646fe59b5caf8da245f2a5d37e030ac513a6d8efa9760c716ce26f53601cfcd45611879497b651d5cca1a283532ca3f9fed841757ded0607b82703ccea991fc460d44f941311adfbacef8e0b148ba9db43ad69d3ac513c470f0d285f49c75916c578ab2fd34d17dbab58e7c13c15b49f9a3dcabd6a3324ec72e1b238ffc4fede148553ea2424890d3af88ae150772740a790e946d665446a9d4b24de5c53777888a74bff483257a602c368cbc7b0a4201d7d9342d7936bdc0b29fe9972186a47f5cc27c312970f14859c8c1b72c102be48e642a27f369da6bfaa0da774f757deeaaae6d37fb6c7b3aeab8cb9a26e62bf25814390c6c5ffbeb1faeb7727458ca1c88b0273ebecebee6a899659febca73d33fed4a9920ab9334b4a6c0d5d9eb777d34dfe84a73c0be6369fdc7e31b8b964183051ee1652c66d7152272e9f913716b53aa828044d649b3a8c96a265b913fc00f368c388b73ab8f41e133cd6f17c90ea61e9c7bd9563edb4b636232c24fd3f83d4d7a8b593e80df61a8837fba1114bfaf83b931d3617d92a7c4bd46e9c1a413bc74607ed52273b8d0cf0e8cbedf3f47117b7960c4c1dbd1e0c1d0e44098fcf73178ef4d8e01e322abc0fa8e217ebc4e6df2edb96b105e51b3e52cc79ff48760f04482e20cb5ed5ecba7f0d58c42cea14ea6ceecaf3feea49037d1b4ec34ab53f8ad63070ea8c6a957df9a033ee32f0ffd39ed90a8f9daf79147ad2b4765f7eca118d33876db54cf233bfafd5b0c27e5a79332bce713a619af408b3dab2c020c8b15c05b64de91da57313d786892fd687e56f294eab1a44c550f9a02358b9d0ff7e6612ef5fed3ae6c321737971f96ebeb8b0625dcdaf2228d8c9a5f658b2b420551853ee74bbbbc26429f05e447ac01be07948c47167afdf9c50a6257a95bf17b998750ee5e0279035111a17c248dc452509d8b8b2ee02bbc6908f7456d35a60cffb08ffd0f0437ca315c0991ca308f437e28e120f69a66fee6462619ae01dd96ef413b0ba6512bf47829fcdc8e2141c921159011ea12e616b8a4b05b8d96eae7b2834870a5bb29258acf3f0d64a297796933d61131fcbb4e1b52ef59b731bca0f2821a9a864eec0780d64b11ce079856cd0d189bacd194975ab2a30088f5017a1a924ca55bd4446f3939fc3015d21458a8e4b59241006998b01f58eca9c716b6a4160937ab4e5be8544acad294a7a29facb4d7e2525b74705360b151017ee64a88e757406fc0194348079a5d6791eb3ae7cd3661cef1e5626ac21d93b7b0add1613d0783faa0e43ab9b4de7a387f2557cbbcf557a9ef3d724bf1d60bf98eeaacecff5cea58fc214d39ea89035d52dc4291557061576fc0341b4dd8ccce861adeffd0cc6facba43090fae735feebd33bfceaf4781dd97e5bd6e24fe1cdc3db24e97ceb6ea8563e62091c874187f191142dd76ff915a8a35276465d632519ad81d65334216ecdb4abbcba9b66d3ae6530ff8688c16761a92322060dbb95e5276e15155b032f24d6940d6a83bce5050e4c92d04049352cb7bc10ca62baeab709230b29d5c4c8a54d884b6dae964a78779959a41eba138e7737186b68dc6fe4fcbc537b3ca6300713298fffd0d1a4e4ef994959dd041ea11fa7df61c10e9c43a5b5cfdfb17fba04ff4e77dccd7cff885c31e1cbbc8cab1c1ff0a055904d2e07aeb43f25484da659032956f353fbe951b141cf0489b105ee1aa9fe18d56aac0d2c39dfe7a1470721a4a40d47bdf599fe590686e6f153ce700964cc8e722dd43596f0a2f3ec9112a398b67489d42bd3af72a3e055d603775acab03813bd86476553c5bf3dc0e159a00172ad64bee9c55f1db7b2e8bfd8c54ab85494a2c2022f6454f13c849887431aab348182fcb6e679a1a6193f19578ec9432008229e514aa4f06ae40c40a944013eea856c791516d7a43eaa9ecd61ad3608b3cb6a39bfc3badd3ffbd9136067925ac61dd5b2b11b35b1d2d7be2f42e975bcdc58533a33062859bd1974f1b155eabdefa6fe8c8b568a00e7de812c0ac494c78f8d01faa42b3e9b2e22d9b72d3578fbfa0c93a40be123bade2b7a1bb56a9fed5d46c8832eb47219744464911a7c1e2391a85511bc43a97c776de72a46c2e8b1e7ca2951440be48aa71b5fca3819bb50e86d26d33b1b164d11c957a19fc543346b2ebb3d56bfa9bb14d405ad5064d48e43caa42a2560062bcecd28b879984f33a83391405b8bc95884dce1dc165d9130679b94514eb2ce3830a82af727df846e207e742ab3e29a9defddaadd93e9bb497f21e17e57426a5db249b66ef73f2320ddd300e33e67ad0c520523c9374c9f55fc968ec55e6c03a8a1469ef4dc2d3eb2d80d0318b7b69e309392511dd0f552f0d3e2432efc8a66ed38e2c2e3b4fa002a513195dc548c507169fc1ad7450b759f8cf56d5f7e5162d1e6f2aea06cd509274c4f56dc095","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
