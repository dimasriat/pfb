<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f25c1f9f7baa32582be59bb75df7e06504264cf8981706d143b68739ff543b6709c4f6ef247e32dde4777ecacedbca184a4fc8d563dd00bc8491544ec79256c95d483e9068f601d08ac8f4571bb887fb42a67aa568e6e72f1b30c27abfd94bd89eec6549b30fa9577f339ebb00948cf8938bd72ca79407e19f4bb0bd1b54ba4e632d1c3724bed91d6727aa4986bc94b93f88ec860b31a9d41276aac8eb232ac82fdfb4a7bf096f53b5ba77f66f4db56ed480b4a9b6f54507fb22ec828a3b12808f177906946f037965c510b2d2cffede2ac08933e8c84b0e366b4f6eeeb1fe3edd69378c200f4d2f2d77b9cd3d63607ecc597bbe69219a8ada6de9bb9284da2b36c55ec71928cd0a743ace4cc5853b4674d86345d78d230e118ed671aa357f64ccce14477757994c7c1aa0442492fdd1b71d4cf6aa443a769faa3c103307a8d21d3091f01f50e1785b30a66b97551cc3ccac70aabf9ac58f46cbf042786a989dcbe41fc8b5c441daf84fc2c4c9c86d3c03695ee9ff74d76e78e8353fde04ae4bde494ef419ecd2145eb4a13cb90894f735a30676cc5b33cd5d19d1bfae769a214ccb29a8547ec34f0f4e4513709507c19061b3b575de011b5f003c88a858e7e24e67f09e6c20971c8c7074234bb37c30cadcbc9371504331f3ad96d76cbe4ee85ceb685869a2cf39cd7749f136d65ec80ad44f0d335d2758f76a78eabcf745e2d0a2ea313cae71a873ba70e35abe064536986e86551d5dab784e2c57fb0efdd3bce1a4a29fbdebb5df978af2aa51b67b2189598226774902dc3d81105be8eec28c6ad07d3fd20861362ba67691fe391c59bdc6f039284090f3a4fb41f6e144da829638e1eca765010a744015f43d7f2f764626caf02d276960628aac234bdeb95c004b0350c8ff35ec942822aff60e604abaa00c1e289c6a4134d358bc288e53638df1b1d0478e4a83b16c5a7b1d1e4e3e332016769865ff4b29fcc7e7cbb2a666905111b439711efaec3b4d9af1c24c6f27af09407ff2851770d2dbffe57abcecfeb86d280b02b4a5b195bfeeea64e3213a033541ab770a475a6fea4f884b32bcc5a7f1272ddf7c1b4d0974804500509f9b48cea5891ff8dccf44cb53b11afbc58d5d20d67c4758e0f008c19414bc88dd0933ab9e1435f671aa69638328700ef04eb3c193981a4bc7c53f47c017fa053f2dedc14e6038e2df288091b192b35bc77ba71ba40ed7e64b6cdcb50f1af6ad9cc57028079aad2e07697503be3b860f8180c29bfd90536c9beeb7b7ea0a60231f4dd51d198a406fdfc0e0cf5a22bb8c75f787c583cd97992946afc8dc94fe767c1cd58227de26c7a06db60b2627176e7e667044986114e476d940d9e7b9b9e10d01c7a32a2a8b30b8401ae86c5dcaadf398d37d079afc6966ac7afbfe26bc9d991086cf2aba9471fbb1b64de9fc53b1828b37fcbc9f053c45f01210f433346563c620d66cbf55aaa73e48e9ea20bcf7fcd5d3633ffd0071a61a0aeb64201010c0010aa6ef39f00175b632826e7245617175c8f68a0ef2d9cbff01c2d045e0c9001bda2e348c8c23184bc4a4f14c222fdbf09a807424168c0c252459c929dbd44c746c4cb0f68652bc9d3b0318b45bc3b0298974b0c8e9d43335db14db51d1492b13d844c96e8b27ef485035f4ea93bcbbb5b9c45c378f380ac0054c33fd02f3b19b064b303b213d49aa9dbce4fcc935a0b09a411ee12adb3c3054c2973a2f358d100b0c5eff8f274cb97240d857fc0dc5076fc682221f504a1a7fbddf377b5705488263a7e2ea399f08d57dd3dbc48af8116dd706abea9683951d245cefc70a1a9af283ad838d9465cff5d72fcf4b0212472a57dab4ebc3a2ba82167b45d4632b2eb9287142a6c5c60ddaaa87ec5e070692d29ef5f44edd42119269327222483d06d148e8c35606c0af2b884f1ed2318eb33020432803a31a06852e45aebe187c9c3207476a560c8538a4ea42487e889062029097e95807607cd270492e5d169801cafdafabdf138e54b943e1e86f3e82ec82a75014a1f1a077e8ddab89c04bee6cb140b52bf830bb0530374809793e17cbf617314ab0d0fd9aa3bcdbbad0c157e24fcb60a2bd714e1b380e029b3d177b11db06a720c9ecf70527678d001139a9d942aea0de3203c1807bfc20f4e72647bb6af46659e02a548646703999b1c094ba85551683b2d568dd1d13708acd280417abccca8e07e40fbd833bbbe3427e6804970705ec062df245082e0b75a3caebe033400c1077bb845499e59c82f7509e01a36f29669121aa7d8b10ae59ad92d878a197a1587b43d36986a741597bc8d0ce1bde8517d83b954ff6ca233d6a74b170ffe0a6ce937001cb9c0e756cae01f2b81ec44f98ccd09dbda3736067e1c78b949b68d64bf27401fd673c5f6f25904f5433e5d84be064410093376b6edfdc810e38e6bcf1ddd4af0a72ce5d42edeeb3e480481fd29c52061cd224d54f8e82c801e52e94bb821121021317dd7e564ed03dd68c197121f2501a4f95e5510db18b57ef54f690a06ad77ff16e5995518be43691325f9f62cd7abe219fb5ce4cf89a0fede901aeecdb13b3bff408bd71a74b56ce2a3f8124f434c5f4b46e30e0eceecf2537b968cfb4478b19de77080f0384e564ae52ea6e34b34edd896f0b0702605323665fa7875c68a9238fed5fdc9e9b6d7f67b3da820c7f5e459f66e4c3a966d8d9058672c3e26639827cfa2585eb95bb5192a73ad67588708189603f19a07d472f406e2b6095e13b25ab0b87066e1d1ab5838eed3148419abcff692e6853e1ca5c1263d4ed6bfbcdbc148260c4f630145022ab267d20773980c8af94c37afa2da6ec8813c97775b1805b2919f1d23c9511ca1e9cb6534e60270dc6acc8985b2ff7ac7b027ba6591963bffd60facd59cf3989733fa6d6d91a2b956e84f5c7de18886b2b7de3778245df431a101913f6b5adcd6a20e0114040444a89b4e2c37c63fcb0004f9377503affa5ded32aa504a39de424acf852210ac71a7e7e1d4742f602453a784820f25eed1b610a4c42f4747c00c6d7f108e7038ce82e0db734eda9c895d46cb1d69cab782d0c18c6ba074446330cc343fe64e7a3b8ae6294c08c5c2955cb7840e9657e5471b3de37d6b03049613f0038893d9677d11fa0aa82e529c7e0e37f68b8e5428b4eb2eac05c50076624813f9298787a8cb0d9a658a2d3c72268cbebdba96a3b082d050fe4f10913624a68a39c16ec3c176d97fa2735f4480ca73152d81b9de92c7418e741e45dcee5f02737a78a7b76f1f9689f407e485d66bc46e2f456f8d5cd85a9592cf74050776179c75db128969b8afedf72ba912a36a7e84987c630782dac97fa11c4988c6f85c2fff302a44b444f701c6b32ab57ea6b30113f683c5055f6d1023966ed6ac7c98f3f3d343024b211718440f9da997095a1e7e892eda750add3dd866451d501716da18ab16a7a00fe7cc5df0252afa70f8b5afadbfa12e8af5b674539737b11cdcb744262ffe2d5cf20dae6f08d44e99a64c6a458982456eca4b2828fbc7b69113bd3a940771984a87574291782f649c5b81cd55949cc2d460a193228d6a9761f698f6957abf3107c4cfee2f167e42f2b1f5cdd996f2ac869ed467bdc66fb52e71cb3250d6500b42de42f2484321eb2a9c86d3bfb47b205bb8c681340aca8c1296fa1e626a1e0a04018085516f54e8e2c586efe852b33ee0a53e6bc112775fe73ffb91289d0a5fd2da59ac3b2b4e8f03999d32bfb99829ef7802cf0b3ea152106aa94b9e04639666e51ca1301453071acb81a1c8160ab7fd0338c457e58a9875029f4a4acf1d4fe168a51fa6c7ef16f85c4382d9e753f3eda5b54a6ba645b8c7da44d063c039db7314e4071622d54b8eac4a37ed1f005e40f9e201d07e9a813b85180633662f8e77ac09e48e364e889c9d52f1c3b56b58f243812811c92073c700d33118053ef87391c11ecec260e049db80c03810cd68b760a27c63d6c610eaa0126c8858648bf50d043c6aa4dcb08d30b9acb4767608ee6ba7ad53ba44fa15c5a6c30aba87deca4229af5168579370d9b3092a9d53a8c2e6abf15953c986dd95ea43d42796f036c5cd7c36ccb0896b7524204644f6c6318319b2fdc60487e98fa324f5f862bb98a51fd17a979727f42ec9ff3e7e88d7ad50c6d6bae98fc189dd0676b435047ff4980cb3e02d0dfaf94f9138c65a2ae69ff409116756553cabe96eabc5985d4b18ec4e98dc0cd2e66aab21c2c7e5f8472c86ea3a0be85ba9b6bd16edec8774cc55259da6798069d091b35a328d9f5e0c5ec9dd8901b9bec651513c42d2a76f5e0e2cdee4fb3a8fff9e513783c1f0451244d9324fa8f353689c3637e555fe7dfc098b40189faa3e7ec48853ee78022fc2298d5c8696005fbf7952942cc02b3c30d69c3c3ea19cf2ccbc0628cdc15cc855bf5b3ef17da5ec0d2e436813b37212fbd5db2972aff575ad07fce8ab64332e1059f1db0f1ffa6aaf9cd5dbdbde34a41442d822fe8028183d9a90924ee191f329cf407fdae1e4b5664f033f7129aa2ec225e6197028304b531bda121de294aa9e8329702706c4753e0d3f31bb2a0949a0a823b1809c4c4dbe2c9d18a8af5ca8085b962d3dff59d531af39d4cabf5b4ac6c2fa6549a13cd80f63e1f55e42800e37775d1cd9ab905038f4c1a336f248504ad10bff9e38de9687e48f18c9606a966ca2e42682467d3e00115be0c8b1b3456685073775162e5830b595dbd06a388478b6f5592e35a161f424ebadcc437810ee2d00ba9facbab83286d7d4e49088454072303b83fc0845068eded5d17af98a833966bcefeaf9f7a2ab7a2da0b54ed66aa01f6711f711c6bb996841bda5369dcb68328825486ed328673c1cd201c3c6e18909a94ad59451fc6086fe7e3d7a7016b68c35842c7e1380992f9c377d62800b84d852c0f5650529ba680112de62f84295e093e0d572d7daa9d543070420e8c24b8df4461511959797d54265b14bf4b0952ac0214a69a04d76b314a20ab180934e2532e0d80628f2f48c51aab09ff03fc66dffadcb5b2a3be9522eab43556eee664d76ac82d4f975a1842b54afcffd5c8693a8e15303c175a68dc9308c6e4793b7950703e4abd817c882c9889ba5e473a60e90292890aadeb03955a786cdba9ee3b0d93c573abf202abdcd40be8188c9c82564f0ff6bd6f8547e948ecff522a759465b17020e10b21aa240a8cc0f68197c11ed799011a24f634225a45efb6da5959500fbb400c90866a2808be0e137f9a9b6f02ebebb5d522faa3f0cd1787efc378e03f78cbe64a79f1eae62567f3329ad1c6e721be528429cb5e4f1d0e99a983dceafb31a260e18146e4e77d5928c9a0839e0c519708815971afe45618ec0fdeeb9a4b682665b47e90d20e25217fb8a351a8aa8b5d620dd9dba59822e46959a77a5bda94c0af8864ef96718591e912ff4dd70d484eeca4e44095ea151de5b45322d532501ff6b2ea5f492bbc25e9d4083c51f1b5e141a3a08a30ff3b2e67f9ea2e437391da1f2856dc00d7191df72079b4a8cb1f1cb487a3e4168fb18aac8464e91a897d93e60dcc99129c22f7400c9538acac1b732e895447e1ca1ff9ae8681cb913b8a55704df47eec9c4e7e2b29363635ce0f179db1d8b24e4ebb71daf07cb88e0094c2b631880f6eea437e81d870f400f1c390fd1f1290b3bcc01a296044b2f8721bfa93903e1ef294ea6c596f7f736bd678a6ed50f2e7df7b3dc87a04a359e3424899a45eb9ff23e3db39e8dc410c9678560743a0321b1c1da791961be19807fa1a834a64222536212727ccde4fc29b2f020b6a8b5192094b4607378f539755431a77d39e9759f95189bcb17089eee682276498fd9c6aa4ed3719df793dd9a4533bfbbd6160f1c655a7bf60930ee6adafbc584be7f7b5747739ed60701fcf4b22fcc3b081173eceb16373f1f294a65e67c7ecd6ff513733b9aaf0b0d11caf2f08f28bd99bf7fa647200de42f41df7957f3f0c25b58132d6fa3036cb6bf0ba87c4ec2c4c36a1744e6cf6d7fe1d96dbb3c48c6991ace8758ed8032b8c362784a6fc2e409915ae89ea7b9017dc062d6358c39906848d6f1932a9cea45362f4a9691250af1199a7e0c1220d918162f5bc863a25ac6b85f0305bf40694667aa556c6e5ada334fcc1963c7c96660643ee06fb13de954f341d4ad936a4a12f461b37cc51042d743625219c7fc83cd8aa54742a1263c0848436f305d5f32677f9570ce6218428e26314e28038f1cb4a9b567a27a774d0a596419713449e0bb67e0f51f5f86174f61f2675d825ca7a2864e704a718d8051a03d5313a62e604c4a193698991917c3817fb38dba1931d9ffd68a7763de533e466e747231aeb0171c25b0d4d89d7a077005a6f27134c115bae793e83fa09d34406347db9349f11e9a74dba42d0c5f7da5b90d100117bc4bd9a0a839bc39cefe4187d9c743ccd4c1d4046d2223374ec04c8487c35868a2b72e9b2750a9f68468a0454e06b81689c50ad9fccfc2118acb53a9c2874dbb49845107a00a423c684789e5c9608560597f4497934aa20758ba2f59302cb40e7b3994ffed48c4bd309e96912133c7501ecce9884133613be01161a6032b4a80a9ff0023a2260775fcbfdbed026c83130e7a7cd05334709cf47d0fb74b9c0cbef1fcd7b0e3bb52d8da44daa0d94ed9d2fc193f8c84d50a2d79e4b583302e8d0519796c35b4ed019d17bb7948076bb2dca9e60040c4d55e45d4837ee500e49b1fbf0c62567848437c7720a8fbdb0488c1481cd80695ce80f158626cc282702e495f4d76b473c3542f985deaa981453a240b0c714748b448719fc678d4be8184c76d13fa955f526d55781e1de086425c724c0c6c91c86eed75bf3bc051e1907de081b2d3102673ca4838964a58bf0f812dcfa7aed4907f7ecf1ac7338d7fe1151269ac319639bc6e4248188a99f6b2c6e08e6e1ce18f5591cc89517639001ec4e4a408ccc256dc103da2f4c46dddb55f14f9464d74a1e093daacd429dff1eff5cf5c169d9adffb80e6e5b92c799079477fd0155ad379cc28c1e21da000b720447e799ee154555db92484e15f7cfa79bcc7dd4dd438db5c23a594d515b068d8d7cde8c730f255444893bb223897c6fe12e68be8ef96add97ba2626442f407e1e159e166d45679b336a164739880b07519c450bb9b2cbf197ff14da1e778acf2d6a8f5876909f417ed1d3b214c065383676c83888aa90190ffcb421b8cc7da7b052cc5ce32d8937301d67dc89040cf9d4e26bf6e1ac0702fb076ffc279d9839cb6890112bc6616af722a7baed54e40a4142399e3045af2cd8fecc9fbad0f938fd173591db639e12a63cfc02509f0ddf6a16b708d6c389e167d3489bd10fa871089067dd31c2eed302f406579d00dc529c798cc5d61a94f6bb94889e60d66e04d1996ac555bd4e548b0e370c14eea1e91ec192455c9ce359fcd6eac4d64254965f283bfc4d24e1d0cb94f57262b32efafa01c281278bb6e1cb73414d3eab610b439f478611728be9bf1859d4dbbbce1c1a30312c4ad06420008c3a763698ccdecac138d5f09645361475306c02c34a9d00f0fee419e18e4cf3a5aae9d953cbf062c019ba0181d58623c504a4f6340ed34888ff73232a976317456bf3d07064c9ada0631a1668ebb27a83548fc35b69685a82030f760e84cd299017738f2b4f4f1488aa3231be30069553bac249b5c835508d6e4aa8432c655a2961aa910da7d9362b7a7e42f2277aa493b9a3afbe052aab991191772ad51c77191a7efd5c6433958ffbdf30360806d49b37678d1e2d47dd615f93e5c9a735a5240ee086780705eaaa19fb7e193df86d84c262dab4be34a0a891457d2c391fd83a11df45b1f269e7c4f1210391c8691fc29762f3398725193736e2dc2ab85188a5d64c9e5fd087e2bc51bb63662ea1b1266fa6716f3eea22363fea6c7ea2700803ec0225fc2d1d1b6a38782594e9c40d09a41f16920cba3c1b324004abccc146f08c8aa286a2d6859ddd3d1e08df227ad4dda95a5a9b7b9ab9b0f482599ec6e19431647dfd78022e17564eecce39557bcfa3e4885a592f985a44b8648cb85255095d1ab69b6c4817a50a1deb4c4f609b7f63ff87c10675b99029b7bc9326d7a55a83a35d5cf6dc26b00e522d2b3d66283020cc06b3351ec0d0725cd982cb52788975ad7625375fd31d6e0a2a3aa59c029b179e282466bd22fc18600c3124bd860e66c624b21ee7169bc755e227132cdc8281b00bb7331ec4cd1c8dfc085c8655115d29739cca884e9fae998bfa4c9df8b0baa7515fb26cfe094bc9f1bc176747d1731b66ad18d6d990aeac5a20ca2ffb7ff30815ef54f2165b019b6807d9e817df75a1df3e556415a7d5f05b75df9dfb1a9a2e5157721f78eb55b8ef270409a77ef9d4599501029836c8a2282f3a608c61c01b286ade024af272d798986262fa61d656de6e678dc50d7e09c58308022f5dde79409f1b87a6d97ab52117a3fd6c8448e3801b76720bd2e58955fa58a469731efce936d2407cc3801d3a8cb587f16e0fa7fa97cbb6314c8f4646cb9e908ac5a83102e25e497b2707761120743bd7a8e3a5177ec0b9ef99b8f90c39ef750d99a9660fa76ccf25b2c95c15601072547e0f3d449630bf2d36babe3dfea87ec089fed5b27747f4bbc49b01522b9152743a1b08e722c92671ebe9d0ae99c966de6c86444966921c735bdedbabc2e76ad4fd18d7a692a41428a83427c62d4cadd791db4c0b299c85e43f32a788d59f9a1802c01cc920834b1583e5f065e5957117e92c93e3ee59dcca9128ffb718a0cc5cb4d5dc5d9d22d67e3c1004fb3dd7a170b24e34121eaa664567b91ceb45eb1972e1a72eacecb5e77a74931545969ce4252a8a5cd0007ea932f34ba0d9ad7fd27dd6ac8419acc4e0374227c70b0a69ba5ad63a2124eacde6f1e337b25b45093d3990405f81e52207fc220d1701038eb51f2daeab6c28248a337aeaef847022431fbe2a9e57513303a3f952138b4b80b9182e1e10196dc0dddc3bb69a0fae241374a858c9d1a4e649688c54188b666071064670291fa9447015f3d30461a5275ceb0cb824e62a829e4fbc63221a470b93aa11472e1147943a576bfec37929ab00e5b630294bc6e64d99c02fc9016fc7597f65644437cca8ad853a66d71ac8754eebb71022d98d1c2d01e7f28d09575fe2b943ce370ec22e41b82c15e94a78bee346731498e711d34324bd705c16c9e92d66558e07bc08213a34f0b3b3c4715ce35df672ead6c3424f13b630e9895d192e57deec710081af98fbebd4ee1ad62978d7459a68af175135b21d8c438300db331375477a5349f729b4a90e45d46ff40e678c6198d80d33b2410ae497eced4fe5a324dd45b9b61077fefcd4df161fd5e819db06f676a6455a4b5c3300c5ab78644d25258ffecabb483f1cc409014b82e2719e90d0a5fff695a1f9d067c8fecffe4e43267d417b30bd58f7a0acbfd8c91049ea32fc003db57a0447e2f89acd5fd7bccbcedc74bba8e4e89aa423763dee16fc84301b909360db84aa32439d96b5d67ad72c016e4a7ef1a1d11581e2f91e2a8f2d9365818d51d1b2fce76bcbb676b365a0f2d9d34fe1a47f9a1a33e1fcb57df5f7e7dd67f111186d5d85147961a1651ed1e68d13e6596199d660b6433c04e977899583ff6c5973004b7dbdb36dd40e44be223af2a8e6913a4d72924f0998096f16e5f04d86ddec52617058408dadee108a6de194da02a8e66f60498fcec84177d9bea36b7034c36ae7dbafeebbf65dad22f65000bc66e90aca16e2d82cdcb175b7dcca8102e806f57798ea2fbed242574e36028d282ba3970aa3c00ce11a9d77e4d2c182513ebe3c56bf7e18bff3d3049d9898b062432db175dab0d025a5df6a8bc8c8fe7125ac219a95334188a661dbd09bc023469d92119ad4e5526d572c6bc192a526d90ac32eb88a0f44fb6ea794f29cd62c402d95b31c22bc6a87f3b0ca176969d201d4bab4b10bd0939e307a2f4c6092e1808f5f26efe91b57b37f606ef1676ead2ed566f1473f60442715a8cf7faa14d1a100c43826e8d3a610842c2b4b186b8a3e530afe91ebc0e7e333b4dfef1d0b8ff504e94dac0a687063a61ed24b767980082f6079ae0b11e49bae935ad9abe80dfdc3a997c971d301a2a4c470315a3699b6461186160ec98a25f50569b53834acf69feec15875bba9e929622aeb561281ef770fd212cfbf721a980094803c3efc21d6d4eecbf7b3b3703044209dcfda3bf11879f9a214871109f488f6c7cc17e330f23b72e4bd598209632c651c6432f6d0597eb8dcf2a0ae88118f41d0c362d99bbbd3bf751e6be0dab4e6efc0474678c5f264d05e9746c6d958633957638efca13955d9c7ce2be7edd9bafda20aa0c5db0d817fdb8fe913d9c950cf173862fdf09c9145da460b600f21afef5c76b01f9b50ac13b3e2dd172e45db4964ada87b11ad9c43e22fcc08f362ebdce0a95346b0e67fc5b4651c4757d57c4de6ced26e8b2812573f9b5423a6fd96fe49ccc1ad41e8ba8543cb7e5911e72edcde0c153c92a81113c641491ff3043ffa6caf01f8664a69c7f5c91b319d57480e4df6a08851bf8bcdb077c1e524d00a6f4c11cae310cab8fa799a7c1647daddaff84dec7f5435e61cc979912b51d78600e7641764a14f08f39f530454823ea74e2fb2df391e1fa8d0b193f8531b93b4c2f653c4410dd17ce93c80cb523c2d869cdac4f94beb5b99f8a7842fd0619b27fae3afe9be3ab2bae8460728d1d763360f5c4a9d28b435b557b0407241d9304943d6c6c60f4f32436544f52d93e0131d400ca1f658390417e4b57bb035c1587f74b74f15e9a1ffcafd68b18d8885a1473c450cf0cc96d731b259a1ab681365fc1be1efb41546073140cace43f547ac731c3e037675aafef7ae90d848120d0aaadcb47d41f4d77b9b53efa2852526721c278d288c5b4b502509fcd3ba1e4b8081c87fabe92f5761cb175a934127c808fba7c0ce05dd36c90bc290bd40c5f437266827b31c58ad5191d86ec406477c9d0c2dc261ec0bf3ca76e3c664ef37b47443ea41bd8d9abb250a677bac896c6a3fdabb7893f16bf11ad5ccdc038cd719ea0eb068ae7a7b8bf1f57d3e1e58567b873fc5fec2deb6cf01dfe68d36633b7eae1b9785634ab5f3ac6482773de181d5e2520d8a7479807d76e3137ef264975f7ec9627b8ff600a62fd809e85bf15e55a04e765186d8c0e60593fcb8d7646b030b57c5f1bc63785126e23fa35eae46f1faef4d7f09bc615c3f30f92f551559ab94cec71dc7d70ee435ac2376dc0ad488ca3c4f09ae3c578b44ced5e6aa1036695fd4f3da3bfd330ac70bbe760031ab056b0bcf1a20f21c078fe8ff6bd48e30e172bc5a20efa5eac50c587840d56b2fc4660f711bd1f85b8927423df8c900062b2e484fc7e08cddf833a45a8bedef857086f9841bbc93db355e4e945634fd9a1ae0e4892fdaee8009f7b389d2700a314a2b19c6f0e1901055e1646c540cf6bbf6c4cdbbf1328b84a010addebabb4d24c71178ba091e9ce8a0d4230e6953f1a08b339153ec92277df217a4e805388c6254a38ce8c2a4ca19f3f35b7a71bd94a74f8c2faf6ef2ee211e310751a040e0c6ad30e863a1c2a8aed464f1ae278f8c06f3df1a9e2d66a7ad5185d9d2ad943d1fc3d634e99277467dfde47440c57fd5dd683fc03be131b0492a484d88368b4a5012673b59eaf698e0d9ef724f80e879ab9838083ef510ea8c81e07d0a826e078fec826430caa93b05a48dfffd6b546827ed9eed56cef41408e14c4d5238817fac4fb3eeb7eccbb3a972f5eb46798d7c0ed73526527d3089b8786c3d5f3072fd81b5a13186375b3264491aa07231c535e958a78ad53447a0084efc451c340180ac761c4f6e6bceb1b8e80cd6578abd82c6d48598f182e43efc411cf5ccfdadd2914701ffc56ec2d91ef96cbc5eaeb6c0492d72804e4c0dd2062fb8bd3a2d766e8291b4e7ff869f892584c25bd05944685f3fc1d56723f7e09f35879edb4e777294025682a7dac5b4d17b7ee919745bc92e5eaf51f5badd941ca84def486690e133874c80fb7954d33e1a86951cbb93a1b1a210aca85ad34f31a34ec4a45362231136b52e800b7ffd3510f0508ad04e560c3f8791a4483fec945cc90cc1cc463933d0757ce2e50dd2af51f5e60726fd6cde6e9eb8fe1213fd496fe2222715bc272c941d349eb8491719b42f4a56e8a6a00b7ca47fe2727479dcc253f053a6cd35b8b510d7d18b4371c80f37f091b55923696d1e0695091fb5c44c9d5495fb741688a1be7d81d7f5ec85bfd34662c04f351b0ec17951ede624f1ff420237d6319620e02b48a0a9e5f4df6b00e6e7d5228442d953f9c7124345a9c08b8c2fdccf8d2ae5b410e1f8f1fe2516c1e11aa73eee1a9e217678524f8db37eea9dd43e89598bc95f8614760baad6d6a8bd4b42212341d639914896f28512009c80dd0a85f0345e44d1cae7b585d0080ea35faa11f70fcf871cd1c38491814338e452d5c9c410e52c1dda98cf4c05bee1c3d758d7b773280e51ebeb76e556d17aaa4e6bf6bb7ad6aa515341f6942514742a0564d0e6eecf6bfbc08932dbe3d55e4512d8d3cdf84b8f8522d073caed8ed8fff257739ae25be2eb4ecbf76241302f1a795e0a5659f0d7ea4cf43cb608616b59185440aa54b16dc06ad835f820985a21f44b08784b808c98bacad35f408cbd0b24d7019946741486a237f2684eea730e24c2b064292a2d946b1712a7d8c428d5dd9b28876d6e7f6c4e490e5f4358d005d2ad0a7e60387d8c012dc0546b78fd643f3f1e866730b5009cfcc6a2e019b6e0b11315907f691a3474c805929ce12ee490d1a1a99b4ab0c2be91fca4d0efa015ab15ac7e310ee5b382e9c16e8b99c9e5c6f2b58a69014dde0d674c7672a5e2c7c1aa85af529b5415f5d2b2a01862cc433ecd550216ff5a3b574eabc2f7bba9a65d36ceccd45eb66c6b4da0c7e7bc8b2fc71c89160e10aa6c0fa54f6897d558ba6f5dde6f8b10c9a86a8acc26240fdfb1ffcc5029912e3df0c3148d09ffbf278f0cb655963ce2a30a138487c644ffd49c5f0b9cc1f4fa2623679597184b0701da563c3ba8e0d847b3c923c5184fb45497d7cca165207ac9505d222a2d06f8495c3702418cefa165dd1751bb020c524a7ac6c35a2ced8ce9b7d528c1e8c32c73ee45f1aa1bf6a115ab10d548b55fc8712bd72285911c75f962c6adf632ed0e5d3ef2a3dff1b4ed111189b168f3111b44377f754cbef19b38d4e604c71e3c9c9e50dcb885694d296a45797ca61850a3976b6367fde09a3ff49b38527197b156f2415981d3bb40b1ebba8b1f4ee34095e4490542784ce263353d95c02c46d014525bf8303416e937bab62b5967833a50b358b65cb8a7620e85fd424daa2960b39f49b04af2039abf8da4fb70f04c60c3271052edceadd56023f8a9ff70a53e5cb1ecb88f0515762b584e631d2dba4d7503fbea4bb445ccd0b0de0f7b1204ed077aac2f670909ebfe9a35fc1357a010bc44e08be97431c9afce6068a4c2620e178d6894586799cbec8276ad422b9f3bc7c60147a9e76817cc1bfe727fc2a269c4a219a3518faf6b592874941effd4b08d9ed2f06fb8949b4a04ea56c219bc21c066c9ee3b10d27f3b9b255f5627a8332edf717c6ed0dc556252d01929f601b30303a468dc467285b81ffbbbeee4820481d0a1f247444cf2a03297e4ef110fa0d5bf334bfa33a004e5ce96e60180c5e066b399a77b4dfa4a93e371692de9b791b70ea82eb30a3c52a3dc191de10d37203a8d5380210343bdcf0a6666bd8c901d21bbb8ba5fbac17a62c3915e563cb225113a1782369b1a48910cf8b28df2d1530b037a3805a187c79c3b956c87b1118b858596e3da33f620ab76fcc839f34d573a7416a7ffba0a33b77ccdcce07d5f8343d9920baffd9df18613ef310e392ff3f9c3c161c5dc5c6c31fa3fac3ebd8d68e5777d26e3ebc4816acb88dd8980cadc5bf510fcb13926ec89fff6e3f4f073d32fa279a52e14f774ff7cb7bb0c7ccc2dab2605765856cbb1cd9275def801fc7d3b3a6d29a19c51a3a03c83e307b8187861094ab8b850c0c513576c088d1dd5ec0b0692bd6a6cae2e8f3f45cf5f3a0f7d6b604fe56ba7dafdb038e8b90fab39f91e3b84e31742daf42556b9bd75018c00890ce4df043ae9ca413ee7a677e7c45f3f84df9472044ecef1e2cf1cd84cb4dff9adb679518ac1562ffd88e65288e797e3effb7fb302adcf4648e37fffd685d1183366f2c2e0957283ccb6f26ca2d75a6681dbdd0ff3d42015fe17ea51e5c623e7e630dde9367c3e5dbdc911095c1f7c33e72c21bd979928de950574961115546035c264c6d4cbd1a22078ec44b37e4451250f2ed3d4c497b8ebdae337a01a2aa0eaaca3d27f385644dfd660a663275dc72774f0b6019a1f474afaa90be67b3dee026ce6f82c0df6403c092f3d3f65b39e2149d83d127a29321a50e77d732a54a0e57fda0f4b6f264887328e9b7e1a18e635927bf458dc8a77215e4d3f91f2370040128204b1ef3afab35ad7327d89c5ffdbb55df0b829c8d3fc0fae2cbcb4018c412cc346de1958c4b011139560c963f7d6b3ca78e578874fbb590c2755aa1ae01c095755c822dc32cb27e656cd91e10dd24cd4ebda0c8a1c05cb074b37f78cc991e9f0d533167ac0a54b1dedda58bc83c5a3ff1634b1f6be7fc7c5a444de56a91f618b4bb46e9be00af66ff4f8417549a7ce1293018d4b2a3ca56db793f6dbc917ed3c1f8190b9a67176f23c2af97e01fd648fbdf9e735ad730b5f50aa24cb45535639c9bd945645bf2fbf2c3282f0a79c971cd7d882e930a74f06726d67ae77f6719042de77c0ff7b23cee92702c08e28a5a08df6db2917488a79b72f44a350009bad716d3eabb991d865c1d14291c62d0e181e920ba7339b973f0eb30fe4d6dfb24e826898c92910dc11d9d81a","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
