<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c348a5dcf0b58b57ea01cc9fd895881a84c5980229280f4ad05006330ea20435322627851cfe4dc429f3aafd9f57650e70611efbd1870c3c4edba528bc3cff4f6df477a0ee5db0f2c2fd6fdd76c24f5cd701cd5a3eca5fb70067caf69b3d20df864a9a4ecd8bf9d51cdc4cfb3a82bbc025b3a9d5706f42be660adaf3483d121e9c46abcbc21831d09082068848cacbe08151b6985485593569d605e40519495dee4a0e2588b758cce24edbec82d24f42640dedc11f47ca3b107b75853643257076a61f87cc0db16e1bf69faf34b27968da26128590b07ea2ade8dcd9fe7ad44f2347f790890f3163968d825c681fb3146dbef8211658cb674a470ac35d9811638cbb9c2effc4b3573536b30a47c0de5d17c69cafff167c2db78bc730002d00d0131ebbaedbcd12f9cdb2f7a4ef05574f4a645f13d54667f6b5d919b797ccca048f3e7dfc9d3d05bb477980b3a39f6c82ccf94c57a442884b22eeaa41defddaa449bf070d0442cd74776d06c6363e370d47c12b0fd780cb79780f8387953338705e2fb1af2a34552ec52bf5c8288af90cbef25b9861e91ba63970e275ee362558d556fe72582bbf5ae8e87d6c562c6794ac627742d2a03b2381ddd22e15dfcbee8154c6b464c3dca5ed2c4e736c2cedeaafbcd17eee782bf5b6555e836aade79bccf1716c353f542725a0e74959aafd598f2ce01cf386ce7b27a515749c736f6047ce81e73d4938a5cc9950c7b3d1bb50413ceedb9385267b3afffeac7e28a87efe9655aeb67bb9dc45abd8d5656f0ba2a6149ce111324da1402b0c99289285b1cfa51b4ee558f160df0cf85ee1047b5bbc164a4c1fa28817cd497ad0ca3f46b0944238f8f8a9a4b47875da6b793761a54f013793b9cb38ab01cef65d115a8525b445838ec7b3a00897fddd30f8ee3506ce2624500b29b4bba5c9628362904762955aa55d914e89c502ec2790db040fe259dfacf5f435e7a6acc1ac60cb1e573bf70d525d40f4762325f77d4abc7242089f998540660910aa4d6fc8bb4f947f2f6e2ecc037abdcdfc7be947efae1cc624e00f1f6c6634407bce3561ef08773e5068c0ae2c17ceac82227b7d99fb8148fc5005885689988a5945f4f309642c9619b8a7f84a73de8e56ac713e5153d41c1f54abaa6646670797e36b67d659f7860e8ce79cad316d385984d675579bb9961bbee3a58b585e0c20a82935a000779198519a9c76fd6a56923f0288dbaa39e567cd1455af519e6af5de34606b02ba7627a38a7539231d8d489b8bcedfb57f57ae671266c465eaf3ae7c1c67fe215caa140eb5e04106107f72915b5c1ff36d543e85ab81f5b13230e53f44330a77ea9b6e76e9dce425ecd7ef499b9aa5255025a5f194247938812ba8acd2a16a4e9efa4aa8fc109ceec02d1f93b6ff4e080b8e00a47bd0f3b2d609f639870ed059b74039fd62c2c7bc6d94a7214935187cbabb00e38cc1f0f78f34f8ba427a84e7b7e164582c5d3c02df963200fd6a494e56c10b924e32e39c4d68f5dc207e0d956c8397f2323a5a6222ceba39df2abad61019b36983ba6ceacf05f693e57a2e1b6b165de47ec5a5fe59df87a67bbff6639b200f90d829b600c57418d0ff505aa9f186c3b877ab435f8fbc19b1872a0f4a7ebecd6dd840e9876be0647f479a60b6983adb8a57bdefca89d2675252b4925e3a0f14f3d453daa4ff887c91c6ad0c776b45dcaf519e14c00d851fc46f29a40612912f3bf008ffc3ebc0c14bf9e128dd6ecc057505c46a39f2691db94628ebc3d81388cacbe5b9f990a019a0aacbbc0b7c199cb6b24f9aacf6d0e7e85e74ad944c80a480eb15bca9ed86621f8d19c6cdacd25712e7501344dda67fe8c790bfd70a646a81f56858d6d482a5e2f51d04dab9d05d54d06df49c8de17576e2aae07b1088482b699ba777d283b9f79bafba3d2df1cc0237216a357fd1daa84aa284532642ea510c3d11ce3fab945db3b7090479d31f21b88dcd3d1bba1c1977b4d2f4f4dca3c5ee3872f6c82cccaaf4babdb4559b2a69380f9412a32c93cc76d243909a0c4b7d43df1585ac15e2e01ecc631cf554877af129afeba9dc61c0b290b173990a46a8aeab9e611e444126741f17734daa0d0411faaffb1029601bcd33e279e923bf0c02fc2fea8dfa5d4ee385950fbe78e2d1030e26e78f11e93692b55e509d4b5c80a75036d36bdd4887d2618244deba9e32c8dc862a60b12b14ca2f5722e6325e9f39a968e6fb2e7bfba1ded2f62caa4f81658c0bcfc4863065c7b3ba27ade168e226ed878be5fb299c5b4ffd739fd6afc1411cf38b6d49aa25e54d578cf83c746a664ba9f49eb5a8ed220c787c5bfe41bd5c7b66b1acbbc01a5e52fe748e2dff8e49a3724c05038d8d2319a77ca2c96768316bca39d8c709c2ddd8de1190ad9d9efcba8343c46178b053f12c2495d24307f84e58aaf60466b868a0555d9cf9afbe2ff5cf189f86994b07e9559c7fe7ac04359725fefda2df8800946535827052f085534d58387ff33c8d1238a26df088e6ad81a8b83cffd891a5c6016b9b13fc488791483baa6db426ef353ed4a161100d5c4cc7d60cbfa043fabda8e1338dd62f660bb3e3e56cedc5f722c32e998dcbcc0eea7e16b313c79f5e5f47f228e8e59a289e997b02da8f25babcf6f4e6d964650d6a0c13284f968f5d2d23433c8cf81a24bc29280cfce34b019bfd5b86badd6d6c5845eef585126a1fdc3349be9b450c075738e3ff4218c4a9b4f7c5645d285b15108f90ef14498acb5eeea37353c6fe613201313c7e6ea94e7a16143d558f4fa6fb5ba6305d3645c012227d376b7ed9bf025ecb4e9f49a32e4ac1696c77b2efbbe3efdfd5cbe27a99c910254fac6a87969956586368663992046c4dc88874cdfa9c7669c98cad0c41f17b27e14959cc65824097d6da831643bc2e893109382b9ee8990873fde0225aa8c8114f42e369c4f3ceaae097a4b13ec1499071c94ce2bb718bfb821aba354d0c075fbbfb26607b4531fd80a36f701baca1093ba0cd8b0ae19c8c8d9ad578b2d902c21eeffce7cf31cfeb32c469ccb36161e6866f9efc50e17199953e8896bf980297a9e73e554d561d245f1d2ac8fc956187a69257f0582e216f3c97c29e21485897a3b2876f700d7e5593deb7d518e9b1565f15e7545373df1152980718ed22d936507725aed03baae339b34bde4f529fcad49f9bf1010bda982acaf0911c09620f91f3c603bfcbde1c13919b2c0d1ecf3585a0565b641ac19f01d9529d419b419176b759c2b951ae775330ed898b8b3c8bf2dedf6557f03e74c3e0e8f8e5dfd1639d9dd154cf702a6eccfd89739e8c67192f8b7e5d7537bca6779291f7aa31205fafc745d25e151350f361f7135b65cc0d72ce169717a11c0de7eccc17bca7dbfd2da9dc052e225fb63ac78968eff8554b3a60533d75436293df3c09bca8b1bd53e84f69a54fedb68ef7d110b6d5e647fd13b0c60883894cf601fc5abf2f4a424628a8043b0b1af98ee96437c762946e698070d09c468c7ed262f6670ca7b8bcd345bea9f2a6af0111b625be6e52a88d114d208cde6cd9c33ebca6316eef0a33889dcdfcc25a19b638df59cf9283a4fd8f89dc9df5d0f1667a246731988403a523e21fa40098e86a454d69f25d19e1efe7905f624ce6e5c20949d12df42a1ac930b462fdbd5a95bc287c89e898f8949e0d92da2ce4bbc841b0215ecef0246aed74d64092d6228233f0b46c35df3ea931505b079576b12f1327d4e2ea77a6bc0487b5570152503642364319cc9ce748319f67acbfa2cf445dbefde4bee6ecf5a0976c4bd3aa787e7b6d6edd1894428b9cf95c9107f27872bac99b766f7c9b50b29d419ffa6179d3236f3e990727113073775f6d18d43a6b9248969cad5b1854a395b63329210d54d887454cba7b879a5fc4ad4c3821aa08c2176464db9c11c0a1f1bc263e301a088b6639012c3edd28d4fa30c92a65767256d9519c6945bd88c66bf332cf809478f2994cfa8f55b6c3e71f11f999cd5d36016ca12f6c94116573be3342645bfa25a1f9e0c3f00e209a28733b2305b090f77e75568ed100ef8de7439963e0336ad80f4627311b275cb3ad81c645273eb4612cf6ec7bdb83b3603d8cbcc33f23d95db9cb27f18e9501adcbf1e15ac16d4d0e7b616b0cf1876ea2ec7a9162fbc507226f8d94d408bdead0ac8aef04c9ecf2f80f665b16691b2c30e9ad67a93e293e00a959b99f40d032422e0f76b0fc4467ba7a700a7aa262e51e715b7c89ff1761178b31140b05ac8040f2bfd9c1b9b37c0bb6d7cf13d92c28d2f70aaa6022165a0a3bbce4b3389261aa998cddeae93b2034e6b20b3cd9bbad597fe3ae8204704dcc3399666b52851acf5d12dba6362e7e998795ac70ddcb73de7ce9e00bff353ccc5d0de89a7386a40e07127bf1c743808ad67b014087c4cc236b3122ee23364ed2182b69b518bc11786281fed181d87d9bf1e3fc264c27ab4be3b966913a5795755e9165e08101c86b8afbda0368e6ddce856e7862957a210a10c4ed0bb992fc9f1d80ddc1251edbfae31cead7c02e5b838d97171a22ac98936c4f1ab7abc40f1562a6baceac1ee26470d308804c5893177cd284691d6686879dda40daa52764937632e08ffd595e7165d97763b3e617626bdde2224f0c8a37d35cf5ef95a18cb7d3c966266c2012c65e42ed0fbeb17509e976bf113f8d931d7110a5ebe66d9b08a0f7519df9f01977beda8b0470e7406d8bae6f420d34cb75ea25b5acae57153741f7cd25fd596c8549f7cc8210690fb1affdd8ac046c741725403c295ea9fd333868192426eba4d4fa81969e4e0f5816d647b60a46e55d50aba251879fc107adbaaa7dc94d50432281120d4a28bdd18191efaf0088d6a32637622e6a4c08589d2a6edca4af15ff67b75b667378ff7d3a1ab271fe39cd3f058fab6851e679b85dbcc63bd182173187e185f8bb0e3c1621c592b5cfd36092a704c72f3859e2e4e4c1bbaaa81fc2b86a77c1968fe6fe08cfb89929ae61762b783ef0717a072e469e2efe070e92259895d411b8fc94036f650ddcb8138da6ede19a980740502a28f8af3a5951a85469318840cbe336f7a08d4640f957d50767146341d1eb40436de78a1000770f12af20f4ad782fecf6ad199cc2ee94df2c20876708b76b5c66a22c5fe8e325b950baf010c5385c48626e1853c76e075e8f3e90171c72caa7bbd1268704630217ef6b48c2dc7efda76b9c70f0f1acb4d23026ec7e01a7be1f20b39e1fb19b5f75fe83c47c4bfcadf6337f56fe31dfbaa56fbc8176818d05991cccebd344796f5ee6d0683df5622f133596ae612bae8e66c254e41858a97b017df7fad3e4b697a5e2c22e764abe6812002fe42b27c43e0bc4d72fd5911dde3b9c57479db792a83a029b14d5378834786907c3a483e17c80f277a1234894fb98c8b0529159b80d86c5d0eaf1c8a2c8eb8f4c8f25eb20225ec2a6478000c4986d5236687e3837d8ffe26570088c63577bd038618eed042c5cb76d5f0508032d02125aa9b39a7b7986dd9cdb883a34d429bb6a62cbdb622fbef677b6d79cd7bdc0e530ed968bcee59334759afe7a57782449639037fa2706281ac6cd9649da91c0c65a5a771453c688c4adbbf6e803966bdbb9224fab694d382e1f3a3dca9157105f8ef37ae17bd0e2b4a06c5e9e891366788d4b201beb67a4df37f7e46155428b00a427b34bdaf6530918206e4aa14208b0926b3ed954eaa7a7a997d49dde2ee96f014aadc8bce2239ce671082669e88700d56a134de38a571def287c2c38d84c376e0907928bf0187bde50c7d14d1115533f913311febd7ed4dd751889374545874527a344e13c6f10e980ba73c259a2b2826ca1ae2d3fd84ea1de67f0f8737f872e572704c03bc712392ef43cfa9b6ba14bff08fca7ad4f883777e11cf3369dff79f053162ad23f1c7ba8f191e034db1e71a60b53c43af8f85e90625b340f03d4b1b522c43c8e0e643d9bc8d49db853adfa282c725527a49b796dba7ad9caf9664096925aaa80d0abb1657b74ee63fbae1efdc628fdec5c7d9d5f77c550a01650638bc8997a7d33656594aefe2eabb30897c7a9bf788c303b0a28a9cdaa40629c94dc6c4bec0a822e451482e094416b9d2e025b5eae86a0ffffd3b27e0ecd9ac3da80b7403a89e0d53eaf03b5960a5ac83f8e4e670118b3f58810a38dfcde5c4fa3729f01d8f63edb8ff416cac985088a30dd6e711b1d60d09197d88151760717e3ccf3a292026c4150fc9c17922f37d4ae859e6b92dcf0f88af8e86ead48c6788de91b353189870cd05b70027563b869bfcde26f40fe193486ebdc091a10563950df567af52c6b03c2d32954e1ee1ed9afd15684c2152239fca55985b512b5d16c2b13576192965a38ada4b3633efb03b4ad95cb74c409a6a893d0eb1a31cc7077bdf167da5cd187787b3d0929db83c31671418b11ac1635ff0bf9619b2475358241bc17782345f052b3a477ef5bb14dbea415304bb866519ad8d0baa7250105e09fe77339b9a3b6e2721b16e67128f775468fcb00752118937ef6ccf96a5315c19ebff0b0cb2f4c404159b2297fa414815eaa47ae665f14b83efcadd5d448cb511978851489be7502c2f57732ea546804696e0f7528d04a69911fd9a9db4aad1f0947065d81ec4d98eaf527bd493831185b00dbba2856e6f408ea9b711a7e86c342c74e38331b42624c80c99dc94253e9b3ab13bcdd49006b9b7774d7bf45e6437c4b5361328fed1c479302e7b94da914e63a81213b03ecaa5ecbaec13538b7cf2486aa6048caedd67892f1b62a095c4c5972284e64ff2fd5145e177e0c8addf8158d1da2c17577e71cc4ef5f643c63cabbb39080a5f9be4101c3904cac1eedaf1a94cd03ef21303f53b840a6d1cc5e4019e6eb4ebc8ae485dd51aa137ef86d96ec7785367e327cbc503a469f224f7703a6e07692ecdb909b3549be50405848f2887d79c2c4de9f91f5917c1ea35b805be8d588f4612e9537f3ed1dde34669271ac3be05bad8dc61212607f04f116f9332de8b627da37be1b0166262c0a066bea8a90c668a5236d5192b6b55528c9e035d884bb304d82398409909905081f5f67c59968809b24a253f04b7dc520015ebe00e0134c886cc459d5a2537dfabbaec9be73c3bf8ba1b2691f0c3ef3d49adae392e19e641b50bf5415bedbbb021e00f8f63451267f39f49b928dba26236169e28361a2cf45d220252909f89e53e14cfaaeaf42ea203322c6d86415d633b456946aa75f3d891f59a7515396656be0095b8d7d2bc723aaf59e2cf95ed553728e8d4be7d16ff6c031892d5e398f471098cf360600a6face671ac516485de262a45a1147f9962f134b474728bbc7030a885589dc4d60f31264db8b4155f2dea829f783080c9cc3a8550ff0bfefb6a067adc96c3e393aeee62f0bbc59c458885dd76036521d3f5c6e2fcca62d03c02d11a855f98f4fb35b1f7766aea14af8117e29514283749c77ae157aa4c36e7a125a3d016e13acbcd8768f31be721c93f86223dd583b96b1c7505e1243667afddd8e7a72ae87fa4e5c67e7cca056d8d1d3364765dfaa9e8ca7ba91d1c093e06f19932b6359c1f1c92a8efe17850b6d7a9968020486a0269521901f593579b800d5a132e1cc4b274de23ef53ea03bd47cfc0964a2c158e9d2052dc726483d957b3a4f19a992b3c8722587ceb159c1ea8216215bcf4a7aaaea0cc1f0c399ad2aee0e76abae9f43c3d0ecc905f2815460e9b3ce71f95ad6c054e0c12f7abf0cd263788c91fc192e9a78f0337965c2dfca70cf59d2b6013a11c9361ebd887782e1c4f138021cf4445ddc75192079b3a32a158811e87afab2c0db9076c1ab084708d4ab07f70efc030f71158acf980eae0e64ed68d152a66b4d4dc36a86712fd1a0965d6a4692c000257e5714c225aa721839239813cd33dcc0734dc1a275e699c7efc0f0cd865fedac85864a5be32cde22d5c507db91993540f5598af398649e055d964e45b5bf0ee1044aaa79ee6420c0c8472ca0787bca39de4a9ad3edfe1ba202914b7dc946cb0d969eb6f04fe2d0e7475b73777016001fb92229deefcd3450c98c1e60525277b7b5513e0ea2aa87c21d1a7ea4796294c89195b94304e7219b6e9ddae9c0c08ff3e5466bd45c8ffadc931102e7c0df50d4cdf7b11b1a9e88ba2a4f872238b5e80d2304d05d62e31374152fcce91c8a2c46abbac88a2c0f6e8eaea98114ce39f6b9236334accb58d5a34f5bbecbc24354899ebdb0ab1fe87d73eeb73d638745b29f5d41de1c67be67f0a0ba1abac81171acfc91c87dfa36870ed57c56d68c15526f185236fa48e176b5e00c5e693c1fbb0576a9c3b9e276dcf2d067a5318c43bccb65b832781a260a799a5e160dcb8b4e637c3a7260efd0c82943757d632757863caa47db04fb0242a0b5ad8e3355387e455c67fb3a0c1fd9210e49f7109c39a4afecb89711de058f2eee2e62db5f63405129e518aeb2a5e7088f6f091159769d11fcc9158a5b1faa654b4dd03abe2c0fba20085c410c03de78c5816a44046550ac1786c74df483b39b9314c176ab0f33c03fc913f33f5fec0576fa753503ddd9afae213fc35d490521ab2a62cfbf9cafd79de1b28dbe9cb106ea30503448926a38092769ca2c8e60e23aa64bdb80734475e961b9a97bd1bbd0271d7e01abf719c331a55d81032737331ef5fac1c194c3457077da412bcc1d38c50a5ed689e7e654bac623c4b8e58dec62de1c471c9c9925c914ce877dfa8a817ade8347422a1eae7e0e0113d513e0ad174e64d9d2fa9c6fa47ed893f50ae887edda0533b3e146375fcada55879f4191c03180df9ce35ac3df4fe405ea75afdd75678d3b77de22ef4bca705c03b234e35842e6113a6c3b5d27080f28ff80706d28163bac0a0c3237fd3b83aa627100a2712dc16efa6ab14a849fba047dbbb28dd92d4a9a39da0571f59c2592b452dfdc84558ed3b3ecd5f243fd21cd1e0199db42adf726059477a7ef50ff3daada9aafb28d6bad0dbf71e4b07303ab70144ad4581909e283ae0c9c3021e6b724088b54abc5eae860d93bca6e3ba864ae29652a0dd5691caff3c62f246dfe26dc085813772fd62bcd5e8065b454aaa5b1e1364053a8f2cf538a0d941cc6a9e8a6a748d97bdebc","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
