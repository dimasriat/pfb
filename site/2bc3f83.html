<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b54e3a55ab54c768aed252f12f03df687ffb10ce93ba955fb0c5312ff1bac2b00965fe00e5b3c3d6e9ddf07060e8485b2c70e1800283b39fd0e6836f648e656d7b796457fb39db725926493c77defcc9e714f57bfa291fee8589558f1d380b612fcef0382f26e06330947db3ca9f031e3327dc64c65adafd5e28f1d84bf2e1d8ce0fe338d5e0113aedbcbece4c7434255485150ec82c3ed2e4b35940a094272a70f053fd1b3bed70e1b8b09edd76c4431c64f1290cc9cc0ebf82e0f9cad0a4e48b3d53529ae31e920dce5c92a80b9491742a8e344f25eae93e59258c79907f3e1b9adebe5d319eb184867a3eb60b43670cc5274ac92272a5ff324b725e13c1f859d5e8522a3ed89807470647510340967d7f5e810cecd0609e277ff246f71ec4ff6505f8615df953e575b5cd112aebd7c1b62a1e6f37588b22eedbf1454c8c84f9cb50949f256fa897eaa05008516969870dc900066f5a3c3c344e2cab8f392663db6afd575f37a300b6bed3a72a9b873d2500312bf5e189c503254ef778cfe9cb90e7617619a1fc3f1442afcc39a0390ac402f7d618b8ce8925d426bf332c7e45c327b76251c5f1bc7aa50ddcbc1cd18e7d6d59f013bdd3221a9042d312bb5e661e5cfa8ecfe5bbb71bdf17487aae683dd553b5e15415ec58cbe39a65221833ce35607a927d5c9d0b1196e1b91d326451ff2d586467f12c91b9430d7f27534281b2eefef9de0d77bee43d45e5759ae2ab7afa770fee4b465a237a81140fde615cb4aae72151941cd4af4e5e9fa8bfe419bce120ba56b153b99d0e686803fa41ef4e0c076e6ba1a9b3e2463f87c5257b111873ab633592844bd3715231b0c164953a5cb12364604691c243ac50379e740938ba3a75a2cab9154d3b7a3f3d6ffd830d8fa12cc07cc92ba36105b21b932237b5e2b31267fb3172f06e868b7023ece91c2b2f9c7d685618a95beca3bb5f727436c1774b313cec013eb397fc3796d18272e7b7af55216afc7890fabba9ee287a90bf37dd65fa3405bc112e8e0a33b1a8504dffa270c240a95eb12c1570b7238da4d4b592e6b79e5b067589a5f1d3b0e70cb58729daf992fa2f50e4309e3b906c364eede80970195ee0847f0cb4126365f7e5342befa606bc530d26ff481c91a0a440783d144cd6eb68ff1ffc16851092c0e2c27fda185a7405bfe25834ceae0c0fc72149bb9ec8088924b1fde397df96f012b919dc749b9d1cba9863667c2a2e97878f708315d72243933dd377956e6feee9089e50ce593c6e7775197e2db6bb216368ee76ec3d5467632864a6b4fe4473f2029667ce51799b7d8a7e43960f26b7fa46bf5f6b77660d58286e7b052ca94e5d0fd60f0162897c262dadf5462f17ac823c357207c6f1c0952d660a73eddb429168e32c75c07ee1b5e36950acf9f966c075fcabfe6b896d60374ab301ca90e1cd74f4a09e9d954228261102a28973a63a7bf446d047187eb2064e303d0982a8dbb5aeccdf7db03ef35208ab0ac4e8a7a87d8c8892622f8d3997d0eacf9851f6ae3e047b99aa72b127c81b03119c13b43aacc162f70ed3d285a1d6e624d104dad2c2a28b78b75ba52e1bad60f133466c4e353b24024f836a952e9a988f410b001bd86eb1d43dcc2ca82754f898fa22f70eea858556c20876f55f711e2fd035fcc6b94c15d4a5360ddc2b3c91e3c51e326231e3a734d92f59741279f63f0b8ea887e432afdd89f77f6da3143a6d6a941ee5dc77852bcf9875af40e1d634197dd9963ea088a98d3d9f8b07a0bd5ec3b6a01058dd7b421d4cf8bfd5d99cc4dc64747503a1a18fca75339a76c328b617152420cafe9394b20f73703587491fa33d683a371c57ce571d1d8f3562f2909fb4b3711f1505a2fd6cbd9e6450757b56965471ea0f97bdaa62e20e7e9628c2229ae1bc748dab3fdd67ad8d99c3af87749cb6ca1b02d9f7a9a6415f8faf9aaf6878335721280fe84a58411cbc482fa4d8b5cb62e7dfa9b088c365f124e5baede852da60ff363ccfea350c590a5254a7d98b56d9c0b0eb1a05a0b9f9989c888d28862cdb707670954add4e9043aa71365e6d44e02f7767f2ff1ebe32abaf18f9109746c36f8a68c407da3f2268d4b5d7e4bdc446e9f1d6fb9a3580d96c087af3ddc440ff581bfddfa43576f97db21ab6b808af182372233a5c11cb215c38733aa699a61e6da0d3e5ccc0e3b49e0c8217b26722f343a7ab433994a16bd8a22a28f6cd36ee8a13aac94b83a2a42c834baad2606b14072b9c8718c5c254089228b0a3dbb991b426d222618492d089e98173205837293db102616cf36875fc123465a0f4feb9335a0118764bc2a6ea90441e42e96c82850e70f1fd76d081849adbac3b3f53c33cd8fd1e365db6345c86b9f865d6b341f401826261ab428be46594d2ff9d3f064e7892a2062444e22fd563dbd718ca07fc391a7c6d7e524d9cf9d55b51ce05d2d56805be9ff047e7f46d3b4b299c962c56f3f1fc56878d09cfda1940baa77f9b37e831810f5e67138b76140ff6c971614ee1b12cd5abdca8e0f8125c0edfc70bc779fe5ebdbe889b70df964cf1b4bad9b839ffc2610294b2ffc57f707a0d99f604eb04fb8101bdc0d9472aafad5a4fca8cd7e17e64cabaa4ad4b69da31af1a1a12b0b06ab01a377a9eef84ec817f848c7c183dc7099aec81d97838b1c0d2e4e2aa47c06642d90d7ff843939ab2b028f1977a154dea278ddd9d204e5e64589951f145fd96f3d15f668869f8d24d43a355070ed30c0a2d1df8aa18d900a37046d52f420d9079e66eada3aaf100a2fce8a7869987dfbae2ee347c7f9f8cfa1c368805b075052710a67505cce4dcb04632840718d227d9f1b38be13bc614ee41c0fecfa6013a9293e56ca19cbccb71921d214feeade39050e2074ae4bb280a996979ba846b2c81a7d6c19b627ccfea9a85241da88d8db991056c46f485c72eb770bc5f491227423fdef955329799860c958f0d1a2a07156e48550519ba01722bb61c98b7d4c1fc1c0405191995cdac4c40ead05c565e256eb304392dbd3ec170ae02d9ece85c9b10e50ea28811589af4267b8160654da2b40bb2c7782619a4849ea795cea05888db5957d833c3e45d29d47e5510f568b64496fdf8e109486bc98cb12f79edc29d75e23a4866ad085fef40c073890887672b57c554db29df28ed2cbc2c1780ae377f98555a14fc6b09f7c97eb87fa65cdda28d24b7fcc709fdc7515e6db03b4338931d002a2be25967d2018659e4a9ad67692cc9c23bb003ea380f851a91ed9359311100f786423820cb29a54a126685404f41b759f751b5c20e3260156a8d3f57f5e270cb11770ae3d77d2110620a4ac802b0f5c663db55d275b74ce4b5a35ec5d48a9e6679b37baf68540f3f108872b93f673dcd326d06b48ffa1d408ea0ec83e137c68b3a7cff4b645dd2f4e50a3136b7258bd812b018fb041f9d2a4e491240351e3c35a8cfa6eca8e644aac2004700fe64ebe94ed0ff345fda97970ec29f61d2d8ab7dd85d98c0a62b41b9a6440f687ae7bfd98e419371258b7a6b54160283a861b72ca424ffc73c79020338e11da835199b3778d34d99ea2bdd8e197a710f37211f57b4cc8dba8b65ba55f5131af617456fcfe4a2832764fe6ea15cf26f2fd4c91e9bc0377583da230e96e5b4c159ebe4e1f589ea0f5f1570cce74544e48e41137c71c6ed0b3ec9b1103e4104eb8671e628e70c11208c349b7591e1d576ca4d47ef7e6762984b69c7716f96f63a8e72b381ac3af13f2f96c178d49cf996a563827e18b00efcd744683234ae4908846adc9eb6255e9f64fa846b2ff348dbfbee7ed9026d176534d14a8ae4e221b5b83b3153a6fe3d9d85a3532cd6308d094a707aa59ee276122affed48805519637a9054dcd9fd932d159f5a7ba7fdff39acba196adb736f7a6008bf4e8f7df1571966fb0391bc815186f437808180b9f64002f76c674fdfc0bb951f9f5bca90c3054c8f5f8f30f2aa9797e88b08d601c83408bfe187121c18ec2ef59116e58cf28ef766b2473b40775e09cab2366fec41ed6e8acd8eb80c893a61f354b15a6397c91e436a04578fbe08d652da85a18a35f5f9a10e934c5bbe6c7c46bb86fed7f6fe39e3865efd574aac53fe5ce913540cd7281a760f5e5c65374f5440c603805a616668773faa0d5991c3d4a6cd518244be024a067850aa63facd3fd1f22b6f206c57dcc4c704cc4f65a35ff4b9294cfbf98fa4707fc561aa538c44d2c066c4a813d22720f40b71a823cabf6f938b96e11242b95bbf7345415d4550ac27403fc9ee421a61ffe5e4a9f347f7daf19ba53d3e08b0f1bbc35fec8669d010a2a510f2f06208da38873975f26c3d5e69663d11bb127622d8ac99a3a55308d6e8794670385fd80bed443cd774cc4d9fff622e8d514c8506c20fd2cf324c0e21a034e460b34681f80b1fa601b4b54d5a32c939addfbcafd6a4851a1b0311d2c72da9c445d8b40941524b3df530489242cc39586979c0b468cc43fd78638ef4acc49cf30ac34de34546a3571f47fbd02773b21454646f91043448ab6ad0cc52b3bacea72d2dee2a4b513442f8fff550e909f5213146cd5b6e3716faefc8274acd65bd130e20a94561115463bb3d8e4ea358c15a3a2db589da21a36225499f3dea0dcc8910c4c3c0d60ec99f079a34b2beb9761d085efe4844cfa3ffb06c4c8965c96470b6c1c0f4c6e8a9a5bc85eeae0a60d48e64a554fcdbe55dce41bcdd6aceadb7135196a660843ece58c5d71ed439c78184ee79a42cca3a5b3fd3b2b9dadfb9141ed601c1647a3ff25cd269ae758e09bd8b012a22c4da115685b7df5aeb23161dd1aad57391a5c6436e115319370608dff1532a27f01e910db3e1476eea17215e974f96b3d38fa07995f3c1eaea0f8ecd81ad6e8b0a7bb48f1a05b57d08f53d59fe99c3f98be130f5be35bbc6bcae76b50da9cf61ed0ba7192f449dcdc59838c37428c50db346a722106dbff1470aaa476268d0b2efd94bdec54a761f7bb141dbb93de8ea3901a8130c51400d40e544067375f4b5f33fafca8456cdfdf07df657b9686247f4a2b3f8a3495e7d629a14759ca94a1cebd3f1b1b2c99313211f00c856908f03074f344ae6d3b98e4996931fb0293efdff0a3f5ae8c010e9f6b7f508cc80c404f4a09b626bb85e182f5d8070cfd047f0b9b282e85694632056f682cc6cf250d0b789b3ad67b5fcd341a74bc980a094ec76aa6ff28e17312d64d1560a260a10df500482db0b6063931085279162461f2a73e08100b29da1b4a9f57f9d799702f1d585ec30983b4401ea56525dd7681da87200006b4a05e574279e1dd77401d09bda8433b86fd9e40edccaa98e0263f58780225b081f0f5158e0afe6c20b5859e1d719d666fbb6cfb7b5af143795e530b4160a17d38bd72e193ecb98340ef3a389b0f1ada498d9e53b56ade4e4a58d3876224a17844986c46c338c747cc20d31a94dcd257e5ce7f9454cb802a98568771ff60a90c325d93c857374bc77d47e7abfbd8daf5517058e6327d6eaf5054e7b7c1b54bb4c741c1288bcec1dea22410966cbac39e18ec1a1d32cc2b0e0837ed5e84ebe2fa486a1f4447fed8136c1908b36e3f8c94c0b103733077f01238b4df1d6b5ffdd9113c37c31b8651c86b0db35fdacba2b804ca552f32ab3df8093922b1ea6715b6f3d5d33b152fb5f6bf8c1f69e2c2f8d569b662df9b4a04cb40edf6587a99e148c914d546f1e6367eb2c7cc60f4948502ca2bd079f3244be2489a1291574a871f8e57e5e9f3d648e2ba0c162aa6fdacc5bb8804d68d96bb59ec9ce67550cf1d73bd29a02c1f7e964d456243133595ffb9cb2252b76eea5c7657f46cb20a82cb5e80f2236a9d1f7e7c30769df32f67dfb7dca8052a9a16ca459f798a778cc7e5627225d395f10562924ac89998b86d7dd666f976e76011472cd7a9f3cb2b3be23c1851d2da9180ff963ca510d7b75e8aaab54bff7369fe89f171a0cd916969be44a230e0eae0113bd8ffb98756eb4cbbf17fe9182f31f4e7aa5c1299b3ee32b70c11f63f8b51330b1f4393583e1ce80bc9b60b41f268fa98cf66b3afd7d0df2b777fa941cadb749723d8581a99f8daa321a993ac455b4d9c509c684fbe0230b53072999a0ff70508c01f17db9b39605a770baeca27608baab2bccf8afb5e849d2ec86bd6904699a6386e170962a908da0443b099ec1a4d39f8f13a7fbb6233fd027a37fb97b3688953f19a38eb3e92099a7d44091d82892d83e98ae31251bfed62a94215a1480df8fa55c58961e919daaa743553cfe0bce3fda08ca5d1c5ea7ee00c6abea3d6f7d1cd8b23ed18fe73b38d23a58c579d3c8c0a31e67bdd274eacebb81e051337d0e89f5643d98504fd3876ab53d46aa7dcac5a4337e75e71332d6cd7c2b9fd8785480a4ba34afb9027d0eb094e5fc9074b616eb8c414a221e664c60b671536934e18e85a7db71648da24ceefbed021c777bffc4b65430ad948d68e3f30059f8c8f8fe13dd44de26856cd8aaba74a2581736f447d0edba3ebdda364c1ff0e07ec660b8f976f14ebb4296af71c84cafe2f26eca0abb6ea28bea376a682038c852b454788a9927c1698a8670ca0cdb84c9396b0eb3743e50aafb68de2ebdd3bcdbcd19afe8b030e67f20061d1ec3e83c389745c00ac5822f3997633f2b3d7ffc9b470dfd2a628cf07d65f3e02354cd7a5196aa1712f0ec2cd69a313660bb2db1f2f2f614c95512316a35c736748896aefb07da25508124925b8fde51f9241023f36a639006ea1fa79f7e71beb9e9594243d0229f3b731b0e9dcc5eb40054cde00b71d5722fa1c6e2e74b6f89aa4df08f495ac559420aec2181535b3427a6c7a512c5362f09eeadcd94a1984d3db79758f20522c6be52905a6c2aaa61af46067524215d67807f1b0873bf02010f6269e5bfc99186f310b71d53c8222742f7d60a6a9a42fb0deaa968d6a5932689e51ea4fc07a0422b4ab6ef07173e81af9bf7ddceb843bad2bfd0650ab1699e62c1ba7552c0ccbcc8a295cb36a6817b8b24f20db024f0d6ab7d1e868812a9811d4aea8dd6045714d3c8524697308776fe4e4528bae4936aa9ba28ac833085831025f331ee898276164aeeb5cfd664621187395e192d128c978b1129587902fb819bb8b0574b4165f254c3227ddacd6d848958c1be80cd9e41bf7f0bbcca01aca854d4dcde1506c6171f8059ffebd0b2f2ab934c93f9f0c3c8477e299d5e3e7330a709b6b4c018d0728d7392561a354520d082b8135e496df7dbd85023fcf82392130b626af541f2cf2ea6bbb360045daa6cd3a0a2312fa142bfbe4fe52ab99abd0be77388e5d043b359554e966201d79bdbe8006df6ee71eb7c983d4d5c1509afcaed4b4f598e91634013464fc5530009e1c69768161cfdb647a54bb6293cd29634b1e9b01a5d34c879f23473c1e5e873567bfa446f09b15496f70fe1098a24908ff33d4ccf3657eb46617acd432d3994accd9de77308c4398ce04f29ec4199d7a44ebfd1dd3642694063a7c59685eb7badc1328dc6610150722742f0fbc9a734154a88cfbaf6b7b3fd0d67e21bb246bd745423a4ea519784149b77d508a39824bfcd5a4036ef06abff85e9331469a8a64288b72e84e46863ec8a1f5b7a324b4c8c6d1c3fe7ea778fe0750873dee2abb401f45aeb9084678f6e5e1510e77e8231fed69a5d23519520f5f3ead2ffcb2854f36f0ccd5f1dd4b4c0233225c52d98c31434685dca9ee05096eba46c36a8442f8c73f034907d308b6812e649bd6d56aa6d5ecaa470bb9068c62fe48371969914a14ed2f9e316bc732f8076087bfd74fc5cf07226fc39eb564ed19713ff3c53ecc96062a0a6df3cec4aa78046ccc7a79524d1a7071b2cb75fe746ac25eb1c92a3f3807e67c8fe03d811de6d00fb5ff4b92227605c404a480d405bbff2048787b62ca5b6fb0611e73e1c7c0fc68757d65a3d4441b699006f5d14b4e8123e06600c2e9207211507f7f40bc7c9f3aa393472569121a10446809ddc48135d00d88d59cd750031f443504b5e42f75faad28cf69fc421105216a36914bf89485fd6d1a9aef2f01969790e4f64468e3e6e93ef4dbac2fa1419183e67db7bd344f157defed245d5ac0ebb126db7cff8d332d42f0c817daf9f748a8adcb9fc8e9340c21875f6a0f5697492c1af7736ee82e44660a483e390598c3198b5f912cf1c4f964c2f41968f569b8caf422032e08bdc4356cf2961284bd1a423eac98b352c24488ff33806b7e229a5f51d3f8ac75bf09120181c141c11ed26cbeac9a6a153c68d5b33a8582e5cdd4461857c2bf753aa670ad3a8ffa8ee7b886e08c85d8919b3df3dd32c7997c77ed8b8b855e50e759bd7dd570ebe66cf77fe5a38eccad2a6fe83d6b6f952ef9c8df73d973ddc9246485717c5924698fe4912ec54280692ea96e3475c83609fe711c1222a8fb78119e065640814a360f37ad93003aa40b537aec6572c9db1ea6df804f36f38318ca827cc2e99388a54a615e0d68c0a304b6a199d8c1fbec2d26ed88e525968621b71b4a3c63cc67b1018c8248088011a7a3d3431e9eefb2a721ab0f168f0fbcd24b7f712964796a19c9a412ffe90b256cdefc25c9496f1635f7b34c425ba465901901f010626696f2f3c64c893f8187ed99c9f5de21a30f54e9850285c0934c0cb06f012cc78d35f4669c7dd24c9e2b7c6c2de6166300782fb2c49502627cf3cf79cbb79dc550ec7c331a467eac7aabc2fde45274721cbebbf6680c3995c6d14d36a34390e48ec38ce3c134f86d3f0fa49d67f1547ce04a3df44d56d4f21a97e44317a650a95f9f95a468e8749f2e5567f14222534bcf47d25e1dbe9464e9b5d7cbafdb495415ada0f19367f5c2d33507c425807547e8f8187241f4a61e5992921e5f8e8f6df7b727840224fb5334cb40402211b0dcd0051537ccebd5ee5bc7d552a8c510d91fc0ddf05ca6d12d9f82bf3f7ae696173c8dde5b98ed26b7f03f62ef49d172ce1966ac41931aa85943caa7e18a4a74c92465aee18c67282eceb0a37e6cae0f18a41f51cce3275ed2fb48c1bfd7aff1857be6d2de3a970b993b684f071eb1747f40507323f8da0818a3787bb09ce0c07c3a59fd5ea6abd567c868a2b5a7a625b0ad3dd8b7610bf731240e8ce3c91bec4323946c4","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
