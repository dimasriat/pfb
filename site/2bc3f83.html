<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f44109ee771e71d7881aa50ada63bd333fdb93db2c67f4ac56e9ff5fa7734ad1ba00146396eed5ca3a6de74c068af3b911c1b2191b765ebe45a586f1a6d1c468b06dbd29fcc552ffa4c0b37fe740c92ecaad5243bc2f4157d934ce706494fc8dbb9d18974fa410c2e1a718fb0da08de3b8c95b122618b8300c4604e7be445674f7e77f9aeeac321c9cfb1bc16458e061c98b27d74cc4ae978cd2d24dac4bf280ac4d1efb207d9869dedc95e72a473ea5cfcadd34d3ecf9643ec111224afff03ed9641ff913db10ea8e0af9afba1cdbb86fe4b791d00fadd4a65d887d04bc4184fcc95d2fd9a2dff7c46e7a2e3449e0ca0f7f7aaa7f713415f3d5237e58fb29138d144bc3ccd196ba8953c59d15b6a7be2124ddb072608eb63b4c42adb3464e013b45b0f720d6524c8e19ac0e1e364baccee078e2cb1ede2c6c46a3e40f006238780857026096049e69566dfe7034230d776b1b750fc889a20d2cab0bfaafb0623a2cc1223f0971baca0b7bc5b7b6325702dc218612087b19ef361d5900cada581043a5fac1526a85f1d4244a322fe66fe3a4e0c7ee6ea25013becb8d2c2d427b8fedf1f5d000a3b82c9dd5d28d3b233ad93c7d37c108cbf1b50875bfadc3430918feff419e4660c039989d3cc929a31f823379a9ab84e92d27a82fe6e661803894fa50ea1b59920860e6c04a401cdc60bd7d0a7be835ad0bd7b44645eb978ef10098e6255de448b5caf5fe7a123adfec16d2a35861f91979cea66bf3afbfda46ac7ad598224e0e87d5e5a084fba81401fb6156be94533dac45ed60e9cdee80fed2a01a30de9168005c6409f19c377fc3a0cc48a6d48e8cea568f483e8411091061689a42678534b6aceeabcc6f4996d9c7f912669d95bbcb8573b8ebe784ee4c2a93ee46814934469d5cd72f4f5ba6bc733697b106de29f21ad7a94676a152b22daffc38721ad9ff148b666f22232d058589496c8f442aa4106e485954aac16562c461cd2aba33db47f59a6deb0c3bf8b728a502b37175c8065b7e31acbbeb5215b66ad1013469cfe9aef5c74b6b2412e11b968580048a696c6c7c2e8715dc989f825d1b3062bb1e68f9aed75793002f628184286bf3a409e87ca5531162f5489ebb8ac0455b318e74ee8ca2ce36169dbcc2dfb6b23b812842975ea3b2f7ff230d2d3bebdd5c6f915624fd07b83520d2c221cfe1b1a63e015e0f501bd52921d80229ae9b7f93d77df4d5a57197661a7e3b45354f3c59ab6a28618e8450c5e99e048a639d5d50473954e8570aab2c9061e73ea672e423d3e1f06a95914a87787403d8ad7974ae6e9dbb2f8407e5ad207683df6ebc9d07faaa1d36dd7e7451d40cda56c37ed8fa91c3448446d90f7c4e81d8f3d3c841736abdb8b4b3e5757594bcc61b4de3404a60441376303ba397637ca0ef918352b7f260580fd6cbacf2e6d660b03b38e3a13ef3c5e98517b18994295ed3e87c940017131466a315dfe4e73b4b7f879b26da5600544abcb9b8ac11bb16531bc9882da25acf8f14b0654b74493f7eaecafec77cc73bcae3533ca04f5ba0817f7f9ac3f36b816e31511dd0f9ec9ab168b14fbd7e945246363d4245dd11c7023247cd0e6382b7a69e59101761d73c1ce5645af82a9a1feb2a7d794007b580e1ea7fed107cbf48d8b5d6bbc06c1b6678240a333856615e76087377eb44a8d6a6cb8d7710fbb8489c257b2d52447fdaef64f3ca862c0c3fb60f63c417698a1de03219c800b87f88f1788105aec0711684c3fbbf04d16ecb392b268b2b11b7096e3e29d1f125d7ec57904a26eab41b8812b808bfa05b719c57771616a88d9576c192d03f58984c8ea2f9e5deb6b7052ef1b2d9c007e8669860f5049ebcbd6d8276dbac08fcd60375929231ccedc6f7270d7204dc627d162839a76515eda470f8ce2518e761b575f78ecfa6e80000451d1a94c45dadb0c7bc81e001f1b53a04d367bf647599e339769c1a5fe0767eb101eaa1eb2d77f46fb662744b7f3cee19d8266def509a82d7ac19e5cb84f710828a3b9a89408531c61e509e94105821988ad9b691b283b7f8720cacad7ab545075fe9e5be47e8c2edee63dac92f1a6cbc81c948f17a3086a9c555c8520d6d667c7ac372eda12b4017bc5b3b596e56c6e2dc07de04864a362c365ee16ed80b8c2a504dd0f89147de6687ee6eda1562f0290c506e6453a00fe018feb91cce90eab379bb76e643ccfc3db76ba0dbc02435bb0f6d0154a6a51945ec704418892b633d9a964cda8646bf15f2128b4286897577a729c81807267773b440e0d7547ad718d8fbef82d2c6ecb9bfe03999b54db44465b7b297c3230d2e0f1b9021bef25e3cb8fdc0dc989f0bd106f5c2bd432eb23eb0e94f704ff00bfe2f21cb74587f6433df200be219c8bacfc47dabe951009bf50a0858aae0463ae3a38728c6e387d97eee921559be40dc8ed2854ad83554f681f32689fc45cd68325fac89f69067a541d2c68f1b391c733ce9ee6ec58b95c2f13e51d9db8dd2ab1b272574865e257bcd9306d1e38f1fad0ca4f0e7b8da80d3271cab3f6b4932026d49b8587eec8aff1a18dcddc834ce57a89a7e8a2d32ddbc4935c7bf28baac12e453c93785fe695fa1b05c2ef936f0e5a58776944551a08ed91c2c270a2004bb4c3499e1d3efa2fbbdcd0676b2067675773fe346840d8c5315643171b0e751454001e86f0ba754cafb27c7a054ed15b61dda2199912a389d5c68417995da358f9f7cf8861f5b5ceca49e18e04b7fe0f6bef82bfcd83eb6b06b9c333baf45bbed76efa3801fe235b076661e76f6eecb60df7370f00873db44bafc5cd8b2940263b1123f6dbde18777726ad48b306b303d5c00a3d867ca8d02c09fdc9343fdea7c5a82516cfd9d4f47f613f7322d16eb0c38883e72d331e8cd2fb3fd16d6a938b22578c8622940677abfadddd5bc9b17f99f041e14e9047ed3227939fd02998970fcd315318d708530fcf20558469503fb54b21caae6e8cceb5a2e6db14d041588de9ffaf645db8626ecffae2337e91b1fea44bb63823d9789f537399c2646a5e474ec38edf7557ea0a07d914cf9a5e9a1e1aee0544b29ae79406ed4c8cc51ac5b31f3548cfd65b387881899fea12b88cd12e000adccf62ec66c001c5c22e7a377317a73fcb206059997d7f3dc4cf60ccbb2e0c688a3dbde67a0286641282704c25badc9eacf5c32997f8d35c6362baab36dcbc612534128cd2bbef78d64a2de6220e0f006137f65795ad5d6386057a89e0156879fd51795eea4bb791e58546317ad3ebd3053fe03ef48e4011567c0edb571387e01150a1fc5d036d3282e2b0e35d2d5f46db6af62c5c04f297e6d28166bbc64f1fa088fe229615e225993b9e7ad0e55a7b5a5b9df4831711fff78732d0ec814747ca876e535c927a6bc643eb4fd38cfdd40f7cd1e30c281b1815f9f8a9108904272bf81d72d69063ba7235f65199b420f05d16f502cba7028bfa4c726b8be1390fee9eef165dbc84cd070765c551b3388975def7eefcd62861ee9d403848b374e69daffd99c3292437784cb73baacf1b5d2a804a8cdf71772e22bee5fe5addfdcead7f2f555745bde95b043db36a8919f5a15b3e9f2a25393d213827a30f2a3aca3dbe0a26ffedb701507848e0cfcc6a2f905ba11a3e8bb646568d105e0dcc856b1c6b823d42f384ec21b881f2cd849af832655437fc3054418c4b3e5e9309a644542cfd37c512d19019cefa4f3d1dabffbdfc4184a4f2206e8cb1782bf6afe550a4eeaccd799b868e681cf880aadb989c17a02e3aa90625f02f79981454670c9e4e290751c721d3a1686fbb90b6e224ee48addb23fd3c4e972c36f8245bc3ea1026556bc035fa7183ac92a731e2daed1e3a41bd465ccf9325d3059a9a318ece34cfe94ae268b204fbcfd7cbd544558dffa6b074d88fb59de3b2a4b4e061547de64f90fe3a3d7887215149abcc35bfea2e48ef6a036d08e2729d2fc610e1f4ea58f1a6d1bfc1d5734807db10e8dce75e46308c31f122cd803aabbc872884ca97db7db9f2864b8ed3e082d04e377cc164e3c7c1e6d001a5d0f221fb21763cf52fae20e98f692b8995f0daad1c93ffa1e908fac5f17544802658b69a93a418233f2c35e890931dce3a3bf7d88ab15c1ed7038e9dd4c5ca0463392d23de8f578d71c670a7b5148c1869914858fbebf499fea70518e477d6442e2c9c5bc7f8de4dd24ec5ee1549ea63a6de4e9803b108dd7452cb3f4b6b5c3521328e5252b5a0b7042a56d23dbd82a2e99536a5a3411f75262f4c55dc49be76c222fcd2273999e7f7baffe98847730a057f2f66dfcfdc61c7dac7244f14f0725998a25d9dc3d06e61190f536053fea52f8713bb28be8bee01b18cf6462a9db7815bed8ba23ebcdd3e0ddce680e3d92f6d2d4cb7e2ac1dc10ff04eb35a99b9e3b967d51e205549838705f7c969de17fecdcae178fdafde3968b6a2fc3cb8b3b360458570fc72de33c5434035cc41d7b90a762d75619f40bb135b31b89d17bca304866596fbf42b18e44f1335adacb88e89bb1f8384456b3aa88d45337b8a4c43779c594988e743f503edcb479299dc893374ddd3d69b3ae9f3130171d4ec203be98a1419e22b6a2fa1b1769b23a05111691e4e0cf8ce8d4acd67f9e7f2b80df6a6e5bb57b319b90b881c6313c533f4016b4b0e166b8df0d93a205839f29af4b671ec3cf6024f2f7df37d86f245b0f9a5bdfa018ab4cd655cb28be699101775473e7c8020997098e41db436199509dc9ca4bb7adf1da53a6e6287c29d68a5bd909cd804369d17d5f5a25835ae7bb9952ba7d3c8dbe719ad9b9758a743307cb5528b60c74e64acefa92178eccf4734f9dc4c31c19e7924f20f50b28f3024e66c4ac73e39f9ac92e95665b86efdf22cfc9220375a866381eba3cf51255a0bbee7d8595e54a8fd94d8b49ded9cf9523d03d7a2d81cf948c1d216008fad22e397e7ebd901b90de6930807919a82c46f61a7b4620dd5542ad95fda606a8c5d0b20868433c244b756e7def4da0e9ff9dfee1f0ac0d5bed7e8b0cff78a01086dea15a0bf64f50c7714180f2c610648fc6a68f0e5ed27b0420237dda89f4922dd49158fe4134dfdfa04f93422b17afba9338700d5d561bde9351acf74a847ef7ede80d32e4268afbe91df21287fea033adcee2dd1d8533352b691110354fdcea34d6ba69e287dfb4d35db6bcfcc72c9df1846dba45a4bb62ca8de5f9875aae95c980f98657654afd91adb8b1a5372d3b522cab301eaa0007853a703778aecae64ec59e444cf49d99ece1d9a0d41002ac6b0b076c26c8097f6481e0fb1e8e21430287927d7c960b4fab0e72b5468779d34f0c8e7ff47a50a054ca2b151e0e9ec268567fc926d28495ed7d6bd6e2d514b0d7b93c1d3e44534f135b918bce8cbf9470a05ee2e8120a4ec0d77dca579aa443fba494d58633c7bb0e97640c93435e9e6866d4d3d33e3a66297c2d27740f40fec2e486a899da947119fccb690f5102d40f4276562ac31a852091f9df7a2954e8064fd14c45767b455d3342b01eda350a0c6b820e44971437f042cf4c0c9967494f04e47217070253d75a89d77684c3352cafcdd303987a710830a8694a2c25a7aebd1bbae71da3d147d6b77c41392b2722827072ab485992f91e537521fea1af331cf6ba4dc3a4cc47e8ada8e52ee1dc4c6b3e11921b0ca1ff5b561fe91ed1b514998873be8bc8faaaf4b109f5f613798b53e38d05cd4f04af76fe48039ae7669fd39b7f25a625f097f26d244094b21a19e29324a900a1c5b76448f5c01d179a3ffad151015ce90648195215384688f3e5b9f2647fa755f638c93381de7e1774a54938c3e33a53cef6833e01eb574c6563f615acd42d5733221712e70f9b68e3fa0e8f16721c583978e83de58290ad45c12ff43b05823eca734d2ec842516d162b9c6017f16020e4a317de1d9418de227922bd591f04d6212b30f5d0609002c8958c873988ed282271545c6a9ead4e98d5d0a4a46f6602ede5cdab031a6697c805e654ee11ee7a72535ff6a4bf60936df3cfd915e12fedf8f92b9486c5b6d21e3dae21ff12cf5a74d849f766085340123f892dcf8b485a94724e04458f956c94ef5da4faa795b2506a3bfcc81f0cc003af73a3908c76ae5daeab41a7f0d998cc05870f49bcd16e9fc7aca2fc8a341bd7d3caefd816f9cd490cd6ae3150a8ec61f2ab04e375460b73edd6519965569ea5f537d061c66e1f4e153de689da915dcdb5753e20f0aa97447dee1e5c5ea6adea2e97e776c771f4e6210252a0b7ae963e24c9704528958aee41365369daee1360aa212d6bce45a20e8ed1b70efb8f39cc509b20d210874efb02c07513fdc6b954d8991332f7167f0f8685bf28a1b267d466f4d3356c69a8a26ee32624959f233ee6b77a79cf92812766cc8e8349db26064d5534f780389f7e9bc3d7a372b303274b42e3979cf85fb3603366dc8472f792814d514e5b958d55e141802601ed6aa1c23e9f8aebe9c3a2061aa6ccdc90bc78f764c7519294dc34f0bb131673f47629d02b7145395219946c4994c8cc291fcc70dffeb9887e82861efe214bbbfa98126c226fa90ba3a0d44253e6595005288f0ce4b7e6e8f1de502498beebd5480dca97b7f2f6a20c0cc7dc98be8be597629894c5513a818f29c57631678df11671503daeb146a67d621336439c5d015d70bea4abe589f6d5ec3c3f23929eddf40b97d5520de9444ac322a48e94a2448660e450811ada2ddbb9f6867411b9fb03c22df0a1d10c69cf94d0a158234ef79aa647a16264c945c3a08d8672e86f4b0dc7e585f3ab3cb13feac925ee96e4c0266adf6c37bc6a0459f9f927ce2a17560954ab7e6ce0f6654e73ae65005542e7ae72e2a86643c26c9c9a2c5446e77efaf50ed137b650f863f698e60e98a46e0cef2ee52935ea8274176391dbaf4e9882cb5e5c5baca031fdd1a1dbde0129a9d1734a704ed25d27f292a46ed7aaae0fbdc96ccf0bd173654975c12573bb95085ba50e36d3fb1536e69d9d95101d204fc4d89eeb3d33e7b5e40bc423e1817506ab5e9a0f58f2f10990d26411dde87b03121616ba3548cdcba4baf603af0f591c4f8f9f3ecaf229326f409582e14e749b27037d9e5978842c3feffac535c81aa802866b49f7408563cf9a56896eee35ca696a74ba5aaad4ca956042ee7a1351454f95f2862883edc2d6413a1a5388363b33007fb3d0f0f47afdfdf798ca8f0293862e1d71cc7a86ccd3fac23567dd097f7afb9ef805f7c68ef89009b5a4d6484330ae3c90355e0e4c933a03ecf5a0592aa1d075856279b1d11763aacdbbc7ea7aaad4f3445181259c32688d709665931ff8549682f897dad3d7565c0efdacd9c19c157a43c2d77f4a798f9d273d852050b5a564815d80180882238c5069184c77783f60d98124d8885b175b39853a892c743d43a7ae2e1b7bac9b0f96ee97c7ab1dc1d349b3d0af8331327380c18b753dccc728eeb7d90f8687e3e974a7918d573892428a21a2a283c5e15e75b68790a2f9498557c1ef72c72cf169847fc015390ad1403dea3c6f4bf8b6c683442b489b044f80ec126393c7e38cda7fe4992d9afdba5a0b52fadaeb7767b3892f2df40ab1fe7181a71bd0d8b8bfb546fc1e51de300ee7463bb84e7b96c11e15d55b2ed9063ce2f972025a6fdc59374a063a67c1901f859d446fde60b4d5bd06ac074246fc6bf43bc708b6188ae256b85fb0f771245877159ecd38914fa6f25a279d05aa83581fae8d4cfb6035a13d4e46f1781457a9b32e72aab957b7692064919dcf127b195b2d9dfa246ff7522a9c8135569677a9312886d036ff4cbcfce18e49fd6f3c24e0532d175d848b29023d10f17731e070802569dbc878cf41df9eeabab92d0aee635be89abbdc7d87ef74caa2edc548c36df683b25b30b543fb7752aeb052d2b2c0274317deb1c4c5ab66e56415df9442515236c9ba86b3ebdc61ff4daa1cbda61bd5c36448858c7fb84b47179564735ab06a122c75fa071b938d0bb8c845ce3970444fe4ff365969f257c591b8cddb34ac8365819943962ee0ae6c3746ac9dbf6c05cd66b346b8852b0f227e679eea00e2e52900e622870a6b3929dbf48aff08967f4e1a70fe9a627fa489870e4007aa70e82cc7b1cc6a00647d418b9cc43c53117ad134df2672d8638e34873df79efb4f9929d28d79c51d7a42d53ca5965ba8e0a9185c8cc8ece33498b671acfd5dbc658474299e19b3621097fd0946653c2ac81232d3fe29fffe6a0c4d168545bbb4caef6844563dc8e219c8bff728220770ed82ec588ee4ca0ca168445719abf97bc6a364849935b8211bd7c8fa5c0906d6f7ae58e23d1bf2120545ab485d8cda4723067df096194f729f295eb2c3a04f72a3ca0e48d7a3e715c28d5b508188069dda23ae93ce03bc58d2d9902dc207ae11de8920042a53027623180bffb7c5007eb02d399c523e5260fdfe378269e60030575e5a82f77172875b13edfbc44970fdb877e654f80c5330bad504e9fbfdf4144013e1f8d2d5edef62ec050cdd4173348ac8d150a1a17fe0d4adc512de4b7c961e2f37d8fe200c3d23da8b483fce73d65b0fead10e7bfe2091b7bffeb4d8864d2ad5a8bb1a8b1cad0070cf0a0d162ad079f9409bdd098534f11d85cc42fe9c0d5209b41d32ed33fbc21c7d47d6d09e57140a8035b624ba6966553e03184b00e48d8d010d9ab02729728a13160f19f011d05c65919f205da7de54690cc754916c5dad7a1b9349b672404172213b7ba5fa29d0f8742dc260db9ff2572714e42c161478f6efddf33f7c639025f3c649ff577f29905bafc437d8168798f1a98afe4357ec7f7b30fd1e9b80c17da0ab2400ba32dd201fb8adf189d03a82ed49549c9b245755eae71b647229e3bb8499ae06e64ec8ff96aa3f4038d75e8965df4581bbe2bb1f99bd9bd04c00776e0720a1a13d5a11a00b373a9c0d7b54da1ff12a132f24b570493fa43a21ba1ce207f6d7ff6e99ff4ba459ec051e75cd5bda0aa432cac15e236cc13b5ff53637b41e77620b60546ef4d9027a94a0a8f4b5abc43f1a590a25e8e5c50e6f0ad6d653a3d099d29f095b544c9b5b225b400fed579f0e4e43b5ab0c3e8802716a4a154d4501185317f4466ca3346c88c1eb093aab2e762e34739ce74627c0","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
