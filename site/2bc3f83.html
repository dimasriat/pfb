<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa43da4f9659fc87ed65c37018c24691b817e445728d9cc62e2ac7adca21896281b53f6f5358214bf2753a926020939804d2cccd8e316e07079ca8583fdc88d26b759eeeb095a84b1b592a488c54d8edc8f0fd3c7aea0381e8fe4820d527ae31928aea47ea63239c81889c54bae010ecfde23c21a83a363cb02ed72c767bc07ab85f702cb9bb7dbe2a809481fa21e93af60ccc086a8cd74b5458bccbd027f8492b09d26e704b35b55ee7aeb8b76633738ecd5d5b69bea7ca7bd304ffb60e531e8727e9a5bb597f37233fdbc6297a4807a1bfdfab5e0d795d744ee2d555a22a2f398787954670ede34242aad74b2d6227ef13fc12c87311ca32f23a30b824c0f1682cd7836b0ca780368c9ecaa165896e07793fdf8cf46c3ed274a4e19cb6b8b8497e833b4de26ea502f3272176e6cf0a50d3755a2aa89c1d251c9c8d617597541f6935fb68cce66cd3a504a09031af5f92167dd8165239a3b12841016c287f951db02f37f37dbd481abaf38bcba2e6f0c6a3f07a2246bdb5bef45ef0b6bb5204ced66d8d21db22675430c1f6f48ed77851d0c3c52161b0bbbe16fac07077285d4c833193fd0ba42148858cc55141fc142cb9d6bfb38a969cab076fd4adf4c65eff37cb49f7059f30b3a95bb93662dc6680be41a9dba16d777c38b908e9c46233b169a9f7b1d00b36e030c34b1ee480da7ac4480b5488ca9b3614526e7779a87c7fbdf15b430948c44e3fc55e39bd2f16129a4021f5d60b82bad206955dc65b6b27510af75213977eb549f18d890f52f6f2614ed2fc859128a57dd61f10fb5c53082d7383f7033d96727839cfd03d1c8abb60e58f7bc4afd828ce7901c4fabe4ea14d46deacf8ba6c2ef2e8700e0450173012a5967f2d3ab6a89c8b67cf16e9d1d1fac208f0cb963b70bd5372b375a9dec2d232426c95196c504c55221e9d695b60b9c1c8beeb06f6394523a24941a73f71319068db130629b14321ea334e40706e92369dc5cbfd91201a53dea35d2f17c48b8bbbe32c3c24ba9e7145b5ac4706fd0f94cdf750f9e07cd8484d0ebdbb9245acb9700d39019042091012f4c9866fea95c6fc87f1ad2ed315ba0b45a84a98c36a9dcf25632d45c11a946295941aa0bfd3ed3b2494f0154b4e32e9c051a49d577b883b06caf1e826a13255ef4016e6b0e66122149f7cf3a5528fc0e6997cef4b6b754fd88815627156fd638c3cde2e6b537279c854459542e55ae2fcb92ab7f8a3bb77d7c3f9beb6ff62ed01e39159c27bf00855fa8462c3d67dafe7823e0ce39b51d6a2adb53d938db1881583760377393dec15dcfdd52d39262d895ec9975ca1985580e953c6cd900602213bdfdbd4d96c2f12619d49ab1a020210560a168b5ae17f597d5cbc461ef6ef9e157ce7f92fe973cdd820c00d2323448c0fd3d83f54f8a5d8598771f503f81d73fd4b34b8f1b6b7c61c78a901a2cea9687b204f042966fd6dec41e1564186f7e706badafc43f4fae6c99dac49f175633e2cb49224ec62bbae1f47b321a0cdfff812d57148977accf4d7ac26fa21ebcb76f0c1a463c7b5c6a6d394b986eed789169f2aaab54755a5f90b1125455924dd7a8927631961b9032173c546c2131b1fb80aed203a2943d41bbc4ce57797426a335357d87a63e19b41bf752a5e768eaa97ff19b09341ae1008f5a3ce1efe1d690b2b95df9af6ce53b39bc2d2d8b280a19c8e8d6636aa2a92313ebb4f05ac221fd19d5028407c94a9ee55963c6a9bdec92b37cc3d621ef84b33c2209f29ee8ff0a40581f2795957a5fe881c3783ff0684cd1ceeb73b2f0a1435a83f492349628b69bae87c4834647ba443c092d8c85381005da10071f728a2e49304dd55ce4c205b10dcaeddd6677fed35b7ebb7a4cf0de8d1bd3b697cd321007f09f5bbfe731ed2043161c404afa25afd769a298b1ca889a11424eaa6fd6d309a9da4aaf94bee702292e8f75e02c652297a70daf5a82af8995619b7be718cc2bfdb9d0833b6b8d81163a6a66ce8984d28b6be2f58f0acb96721584703675364586320a9e0c5f8c187b6759686d0b8d27bcc5b720ce8c6a8ee3a61ff494d0ceaa1cb42b0d38e1e66330ff00c09806c80fb1ed3634eba38d8e374e31f03202e4b422ffe48a33c225d16948a71b1371ed70f70055fd5a8bb85e5ad6df57aff4129866487418ab9f60a8d69ab928778cedfd55c44fbca77f569c688f334c7137473b9ea1537bf0063babc9490ad6d11177f546cf11e3406d2c3dc92816010fabf48aeb14eadeb70abcbba2361d5111aee037a2e021dbc2a2462a3ca617545dd9de0b4ae1f411a82c63fb3715d723dd3b5ec15caa5efe3ca3a3468ce0282071ca72c92fcbcb38dfcfdfeb4b9e48b4fb4d17cf56fdb7b3bc9ca2f9ecb1507b5c191cef0ed36c96428c8f7cdcf763a21ced4734807ae80a987f2f58920070b9a498d8f65e76d72013fc10bd6f6620fe8cb0ecb10ca35bbc7b59f30e249d3847e51b166384d87abca035efd0ae95d0f586c124429217f48d180f8f75b67986f51157aacfc7479fca5c9c7995b5b6b9f2e331638269ceec76c02dcd4822551624f95a9e570cc27bdafc03c20a22b402bcad0b1b69370804e16fc92c3f782e2646c8eba99c18f8b34073940f190b878db9b9140c7a4a564f341d9e7933f8997cd6d53a9b93dad1cde966bbe7304558912cb59d9361e5366de3dd1a8b6a6c9e18cfaf50776959576533999c2e727745b405f2d40b45398ea7d1cf8f0acaf581d03481d094a0f9efc49429d976f70387405322eb129fd77f8a410feb461c71bcaeb75da79a725fd92f5d9d6ffdd98c36fb1e58bea45216ad120c3fdba793c0b8bbc85594601cdeaef25b3eb8e19d95fcb7b0d5cc9d264ccd2b399aaae0da11a6d515cf9b17cfdb0609e64c32c1c2cabb6d2e96587a1071d77c8395592f2aebf28417fe0e234cf1c689e0db288a8773d8bef4813e16ac33435418a252d35de8b54a8f9f7a006ac905d96cb764a8207d12d299bbaa8a21c4787846f5a7b2b99e34d8befa652728f0d03cdff344142ec2a8c8625f8ddce8738fda28bbd5d5f77e75be25495a16a8966d0802f2d2a891461898776aa01531ad8fbb3785d6e392b9386e3dfc12b650d868720337f09823b1f04945b9d1dae7d488668bfe9eed508ee70b2bbef0940cc53d462f490e2d757176d90221f30af0b0b2bfc95dd2b0dc5416e930a2c656aeaf1d26f1c078e328a3c1309c1b36cfee63670c5207ba5aeab1ab46c898da2ea0c9bd1dc54feb8198edbc326a17341d6b6a31dd4220d26f86d334e3087f70bf29a66d798b98045b383e63108dd81eeb6796056f8db54369fe8b42347150feafb8d0ea884fe1f1a10f3c9668b35acc10664aa2e907687b02b6e90fb3224f3ffaca0b4fd279866af2a4ce63517d8c2fb3af3898d742c22e3e0edbf16f3cdcac523d145f3be23d82a2d7bc443b0f01132401e961478ea84de19879f3db6e83bb2c5856fb3157fa003cdcc2e0428e80ed730f2c074f3d12c3e07b4ef53cd0efed1db59f4cb677bd5d58667e7eb2f34e3006170cfad841653d9e81873032d8218520ff6a0ecf56604c516541570bfc706059dc69bf92026a2682b9d32cfaffeb2b2b00915476dfebdfd4d7e297468ce5295ede87a84c4d6eff146fad926bc4d2456332f9f90474af109904b8ab893a7970f2ebaa0693a78d9ca2f1923d6a777291bf97158a8cab9db6b6d1db97998efd1c02f03386e886333e3706be70f20199a22dfe0b80f0d4e44a0f1f7484419d68af87bf11aba18181d132b598775924a34e2c44c4c5d2525118c1b79e9c06be51786214999ec4200d45842956b847ab468b51b063946e09e6e17b321623b4f353254a7ab1cbf3da7cb7fd665568a0943cc5acc29f4ced6c476e3c616c9e7090c4e246687dba24168b0a86c6ed3bc0c250d673ce4f9424b705804003e4ced5d7e480af5a972d92ebab6c582e8a7ddc2dcbc0c1652efa6f2840d63d8d5f8877aa66d7146e2447e654620d12216d945b1435f7fd281d2063e3427cba771cdec88842f0459aea3de112503aeb5d31ee0648cc4133bcd1eea45fba68ff164aea3b3e5ca78c37a1d029665712466e0aa2ba281c18f1e0b7a79ef2d43e668ed4017fa657bff64907e154359b389f1b0063643899924f04110723f4101a256c13218bc0c2811e7aa33723ac69d59887d6bad9d9d4808bfe1a54a2bd18dbbbd78f2640d71c1e4c81bc0b014b7956d65035ca848e09bdde561cda172ccfab47414903cfcc5305adb40d82124a0ac3052d93786be5384a9939c5e58f569a8a1c80e961d6c355579a006058fcebced0a10dc9cc1cd383fa2cba189a30d7191bb22695a0228520bcfda030c2e870aa98bd4ca4e61e9a3763b54aa37b4f69685649eeed057a2e6a24d7a39ec2f0ec2f2a9818bfcf9072ce964a0d7135514beeb86b1c71447bf4873c5e182f817dc3e8d3d2fec255ef37264827fdec294f0e34483b628eeb07efbd3bf116830321c2f78fa3e41d336a92e5ffa3edd862944e0e5a331604c70900cb8b89d2f6e751fb14add94b6186afa8f0be789552fed0dd7b2aab2a97cd986998b6eb5c52ef210a8cbaa202d74553ba479da0ffc7d5460ebfe784493e1bc9c8b87791891766676137909941e5b55df6a990410b06cbd1f91f58e3bc5c5eccb057c931e6a2c84515b0e9f04852d6db178e6ac22fda34fc0fd94b4463d7f66bf479dba388cc98b71354ac9fa31a552561d30e229da6a3ca19ad439c9055fc04719add051fee0bfd5761a26c27aedd1478387d66f8cdde8044ff9bee22fe50da3cb159eb6c5f41bba06ad205e5e2efc76e8c51bc516d206dcd86bb8a025cacf64cc3b2a64efe96aff93c43132319e7b4ac3e1b3adf6f5ed72e12adf2bef6f5e34c52b1cb6308a0037e6a454ae8bfe35d7af78d21010e53cad11336a073670c3470e74b3cddff34629a6b0c8b474ac74006b6d34548a3a370d452e321edd4fd0604e53596ca9ece85c7fad8fca284c6f77bb2de83029343f3aef1ed62c02dadca1a1dace68aba0d29db390265dbe499e4092b750111c0705559050ad4e68828388fb028f425e11f90b7de07187b44ec3f037fecf83023243a21dc6acc0c996d8666aa310aeebbc3410bd03c0c26fc186cd603c2e5f468460fabb3e1cfd2de0b67dfb23250b95615fd1fb3394e85c4ba5145e94918feb8d0f4929344de2e1651b5d66f2dd4995eb384245562b389cd5ebaff9241c714a679e2c94bd0a057e887d7ef10736c076adedf797e1f2341799f637c75b522fef1d3b37261784cc219792d457b7eda352860da6a4342e11be83ea9d4ac25ea7c0f78d66ef73fec2422d49b5168e89d94d09bd0fd25090c855f89e5d1ab9a4ca8f387603965289e1e965e771e8d0425f7bb3cbc15948991b88db4cbdbff986de37b9367ccf37b1365a0aa7f4947c52c61b48b4d2bed7195a3b55b66020e76982d4af02b84f1b03aeddd8d566092f24e4b76262d936ed734488ea65ddefe14a048aaa016ce5391de72794307c124d142dd6044f309a6d8d5231a0ce1c6e308e7a3c0a53494fdf13b66f8e22694e143418fca2cdc22a3ad4b41b111c5cb7c6d015ec451a1cbc5375bb3f1062d788e43a32526dd7951bd1ac8e8d6ab1c156aba9942a345a474b6ce892cd65ef71b18f29bedca47dfcbbb9d8d38b7d1d723e11878189a077e54e523c3d04fcc95daa18f3fa741db6827deb40fa1f4b3f098aece524424cfdd5fc81a9ece8320e076da863ac5fe1bdfc613a12dd3a2d2045c6ebc1e026fdcdee4dd4e8bd5a1b87008eaaf912204576da17b38a37d90f9fd203a2005fc6f7913937368e0a9150c6f2152a0dca631f887953a365f12821605f0ba1bead3dbbc5070c9d8c4976d1469e5b15ec88b02eb5155fd2e2d63dbd37fac187e95fe10243a09d7035f566aaf7312d761bffc53a2f89eb20a942dd094288ad22db958169ef1dc05e168b0ecc8022b52927f5b483e32456446c55e4f4ead7e15696f31e17ba2319c24ce0f820e54bd5704c727b769f8d5973adf6c836e2143700e89849f76fabe15c72ed63c689ff719650c34705e39c2af3aa90c0ea7bf4aab8ffb31f7460ed48e31613aa867839d5720c1961294a21864f35c651e8d3b00a0e3352797c520f1ffb0d06155cbba51a5900714288084c0da0d9b7209c21814cf70e4a8658a10e2c3320c7a195f8ab4b0234d59d5c302b6aa5133200700123f00097aca26566ea9324f55a9c644cb578eb5e17f24ef2d972fe3ed06b653f50c4b3e7c515fd952965f49cfa63a2d98a3d406c3010a99e8f0f083a03896bba8163c99538ea22874911bf6f1a713773c185509a4cc808bcacfd26838d89b50517783d960e14adc80e8c030748a4854a3349126d3ddbafe12a55f582c2134730c575603838bd76d3ea870fc0bb7f3173de41bb2a72244f2cc00c2f7ffa8bf635b7314f410be3ec115f1a9e6c317746dfc44655ba56d0330e2a2ab9ef393d634e51be2ed7b86266acaee4bebf49b0a12273ca44674e2f8ace3d413abb20fbc5cbb9707fbd1b98d82a6896bcc0669f7bad8d6d5f32c014e7a723349de90f7bfe234f325e99fa74e8c2c85b242926698b7073eb79f923c00edd05b204f3cc6ea018844ffbed7056a8c3ae97a8fac548b5b31099adf0c2999d8e9ddfae7be857553c73080e22023c3a0e89d88074a4adfb78cc1e00d342cb58c572de6cb72517cb216f2f573cfa64d946e0e423976c1b5f01a9513347a92f652da122af7f5b9e96e6d3161292b539c767f14e362df8d27e813f957a45de5218f6115677e065d66d888f04902b319c9d2430e44940e8e3e204f5aa8e6c4af8b98e86fd4c0c0ba38cb0d7d342815329f79468993edab3a7482289de6ecb39346a792909d5de6735bc0d60888e36f0032e700c140c137862e8b016eccd170636b3d4bf3847d8036608bf4895f6836a52e363739d9890c8c015260872294a2d20b164c6076cb088cafa6cbb7e6487304ccb82769eda3bcf7ed188877a6332fca2425dd48c54b640317b2e444a933ca646901f0c4967512ab00b8bbc46a832ee8bf526a332d1d546527582c4bc483ab88a6d5727da14521e2ac1520645c478d3fa5063272e923248e37f4457d8ccdedcfebf7060ae0f7b3d65a47396a0ab8a8fcbad5010e1e9e7edaa58b2eb0c8ccd4c874d1cef95593ed454954ebed5e7643adee335765e6438a515c5d651e7fdbf7dfa2837515faeeaebd2fd6ec646aeee207e9f9d2b0a75e8ca4b1600935678c74c9e1ed42a6706bbe9133639edc1a89ae68d221938512a42a7c36810bef2f0a9890f321cd8eefa15389596418129635d860b53ac74faabd057cabd0160d62785462cc8b1bf881d30b0fdf442760e49f2740ebf339807a6c36373ff4208d4190c01ce376d670ad2349bb66fc1640e4d6fc685622ad2664f48641a12bdf7bfa702b0e0739952f78a427b5db452036e38f35113b6637d0e7b7f91fbeea5830abfbf711b71d938a370795ff913da4feb5733fe7d46f597ef2818b11f21afe2f0e291b6aade1337c489be36eec7e2c23afeb4e4ec6a35a8390d2a4dea930adbf4a5a475841831161f0ce2deea17080df7b426715c69d47430a793f8ce338f56ea19e40ca09b43b34209b088636435f8c27365b1c8df8c989470d79f990a35e59c79a6126edffe5d39015ca40ef3df630be69ba2bd613e873ddb43683bb8b55e8371c60bc106df1a6a2d7a459d7ff6b8e7ec93ce3595bfc1757419ff091bc25b0ef789a862ffe9fbf5d15c76620511e386da0396f24f06740f16f682d647314746bd7899944aa4b6f66fd8c81337a125d501b673b373699acd6200444e97dd951dc7418ca30d4d80c2bd403a0d80f0207ef350122edf4b179f9ed281318de1bb0098f2f039d5d020c02dc3f00ff7d135ef4828aa8c1910ec74d9a2635bece7ac9c892f677876e75a85076462bf87424b8df95ba098bcb977e63f8e15a1309a7a507567b2aeb27e1116cdbe8514600548c4e90303fa1a595348fbb4cea4c7b687bec7a521431755c6b2367a6de43547c5b4cb5c23fd43302d2ac8a11d2e90f2a60fc598ddb477abe0ab589d95a4e5933e3172b6b4691ab6ba30dec5a7b6f78ee5b44f1b8c2751d010d4132cff24d87c8ca42a268490cb9c8c4f4cf2dc5451bf16d489598b3b3fe0e5b2c31b62d4ccb37cf2f471334c5f5c530634a50c4415701cad4a428c2cbaf674a7c04267e613709c9ddc28e6c7ab4ff47a2fbb9a374ed298750604e639259d32a8cc6b2fd991ff8484d333469a29db6c76ffde26e05e355b5d559a10f35bdf6cf2292565cee3b91b3674a04752c40cfb8c062de023d0943b0a23cdfc9e86f83326363fc2404de57417f38508f07831c697ca5affab8eed448ffcf752822f0644f95cedc9371fd7013e2056ff9eb579396aa986c06264fecfb5f254fa786565d1957c344a6d4717f0c6fa715fa31358fe41b96c8cf606d97a79016c5df66c0cdd81fd547e7760e4aacd87ea89a1b9ed4d510be71e6722607dd29ca9ad5076a22994b9e1aa9128ada335e5eba6b6a9d64d71860d443736c5fcef0d9a348278ab0bf963621f42a7af0074cba04fd8ba9d3b718903b5b8cdffc6e1b507fb2654033a7b459438687aae1a0702541f6cf182888054f31c53535d433919664a7e0a9d63b688c727ba7a3e2693c0065a97ccd9681890ab5dbbafe79d7b3346c369178a01401f4f7d0f9f7e9c89bfa991643ea105acba3c8bcb7ceb1afc3dcd316fb96763ae1967f05d268bf57234d2e8fb4e963ce3e6b834fda45af8a309d43c8c8bf4739114ec20b4b9feb8b87c7892da09c6e7c5e832d192f04fbcb362ad7501bb0c9a15df006b0a0878394ca88e5ea86553ae2d44c6364b7ba732762b94edbf789951b411be8fa4c3ccacb00668ca578ac4a3691e516486fd5ef779e4178f17847ddc1e160b974d8cb824e264a06abefb867a40c69df9d17291e83fd0260c8c00a3a914b70ec4bf05c805ff21d3e2856d37e37c8378625db9ca7733523c14f9ee97deecbdf5c833365ed3cde90839ef788279f4522a9587d4979d29f8321ecdcc4dc6a3407c612bb301b98837a0b4783bf99f892a5e86ed277b48c96b20a19927e7d616471fb0eec1010f540a2d1bd4a2373931b3bd1337e1cc","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
