<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b6b6d51163f9f08ac516c18e6efd850d81d03270030d37f2f11ea70933b5eb6fa1c900e305212e3a9efe1201f72744a6abd1036d6c4ef2034c9f3793e1b53ddd813079e9610122808e483cce1f9dbf5541ebc8648b41ae59c9cbe860c0ff85b3e02412a66afafcda74f062bda0f85b82ca3c0efc861bf9999eab7ff424c40f76c2df21337f3738791753408ca3a9d8e3c81fa40fc8e5c38c70cd9f9d538d6d99ca3f95054131f7cf28450fd3ceadf7705d5e3fdecb8066a78c60f0811f93a1ecd351830eee6a0c8dfaded2b67d3b618432b0334f9e21b9b400fbb24b874f23cad936a61d91e68aaef44f341bb155f7dca23deb9798b3b4eaabe78884843bc8239830c5ecd38624a3ac50105ac8baec0f18d6baca03a1844042593450eeb509071df2274a5b174058b9152a842f64afe8bb46853791f709bbd9c0d6fbdd4f394558d5b5e27a419ce801fb61f8842ec1b10a36abad5546477c21f5d5d4b2757b96dea4d392f00214f1245cb08f1c572d419753adf3a060c2ff0181019095f3c2f0328fac38b5ba4798fa7a00092aedeeab688da373352d0912d307be52f93603486b7f40a4e9dae56da3eeccfb69558d1e3c41f15f879e3093c06ed16f55a3fe6ac3f5e098a28bc99c3412b4010c7031f14dba43e75bd0d5a1ca66cc2a1c46bf30459226896ba6ac67eebc0438da6aa984dbe4ca92ef2b32258828d8694579bb58b005ea2e7f9cac00e012d48cf3242e649ac07f6dc78805c12ee9b49b8b1ca9facd1a466734280d2fe7feb5bc7cf21ae3d326727d3c49c5b37cd0d47026ef71993c01e60c742cdff5f1d9ddd6a7464aaa04180d3bfbe40b43fd5e2cee52cba3c310f19bba30cd1c9aef40b6b67408953bbde34f3f756dd32eb8a55d492927fab9c0ac94b25fc3d036b80fb41026c98085f07de8144f4aebc8f8a2c4e7f4f69f0cdb884b893cbdd9ca60c854dda8483268c55e091b4cdd956cfbbcadf37a802eaee9c86d22f6b350df2a9c54a50f6d57bbb9710cacc4878b2dc64ce1d603ef55e16ecb1f1b7e8bced92018e4c9882aaf9698edc1f002dfec0d8fa9067c5449ee45b21cff35e88da78c90b17ccafe9c36c49e90e1920b57e317a9692a3221470a8917c7d292b305a63ddb238ae09f971dc66665c1cf8b45ad159e04442091c5f98fa0e72d6402408279e99902f7f090cef51624e399afb1f1171df43450c12b585bf2f7154b1a38bfa106fe9fe40c2a23a6fac1d2a9ae7ab68846b569116cf0247c4e88c3d7b52a313d4b9b8c6f1cd062d1988932b59abdda322731cba47080dd33088d0a46f506a4941d0d0d2ca727229f7a4848747307bacdd953894da62ea39e874ccac9d8ef35cc8583c73fdda37b790774ad6b434d268eb25bc50f601b491fa10754d1f393675788185331aa39dd440e849db4878a7dc5fb2a8bb9efdc8b3407e8ea7ccc883ea42a80c0e858873d0c22ecd677ba9572f2563045f142c996f82869ca66b19d97ab8edf9cfcbb26c9418fe9b0f8ffe3bbebe4ab713663ed8efbef45d6cec3e4becaf3e93c5747545fdc02cac043f64b39c515a36ee6bd619a57127430b587d05924777467b28bf7fc9de310852436295abbfb47259ac4d573f4a1147cda3e15a113b99511950a4d5dd84085d6975a76d8f516e19252b4bc3d8f5b0109855418b17407ae8425c0b26f8a4098b9d23b3c44dd148dfecd388abecfcef9352804e79f5f35bf427de1f171e98e973cbcbedc4fcfeb722cc9965da75b0c3bf21c34995ea819e1cb0dcc165c8fd95ae96cb657dc2aa990746410cf781410bbc59d2c1af67238d3b3edee75972af73a97a95eca177d6ef09e7ed23ae6412035d0a0df31eb68a245831f333b43072e07014f89d7763c19dfe08df781e53f76ae031b21e8562cf24ed503e08172666684fd7fe74a4e4a99c3094178b9a2d7037a4267b9478ba94b62de368f6c41632a547e4016e2e41f8aad5a80dc654b962fbccb242eb62977ce2e43688a95a38da0e5ecf157f36a064ce50730568f375b0f9c2b71e4b86ec056192c0ede47340da6c8a49d9b1202b4579e37af9c011adac6c5862fdf79079fc3549b510cb27f5e94ef05d09723cc95c87e119007532892e578d0461d50001a55f2c4b31fb29303e03bd7c158fda798232fc26dc94f67df3c638f03df42b09059909acd0933cb57a66dcf92d22f66e7819557faa59643b267804736fedc54a78298302f1db83371e7cc7ece4de79214448d0d9f28922aae87fb74c38b37505d0c8e85be86e34e69d169294dc413adfb173d5ea9f7ec91d07261df788786e77b781fa7c71a3036fb15556e8523c3b8c7a114d345f4068bf988bc2a3617f4992bda9919319055a4d4419e846a666fd2c90a35410b064763563fa16531d63b19af2a5c5410efa03a8f882d9253a81e6dd622a3838f37dbfb41372a31fe18218317f6dce808646a2155942f90333f8aea0a9c85ef373205a66827aca86bbaa4abcb873fe189abe45262a8f66d1b1aca816a5be914f59c1b07b26ad0c297490c32be9e17f2b37e41c823618284f62e154b66477074bb77d119060f36d36c49ca7d494d57ac7079d64300bbf16d03da083a29d6e4060ea94909ab580962af35f8c9a157d6c65abf42adae485e2715fcaaddc935b631c67a509b855db68f28358ef47a3fd20f9302818e67c4202328b61da41571d31f33ca602ff86ec67512ace26514ee6d6a6fa6cdc313e5a830ad42b47f29a6909c7bdffc5f316169b2e2682bb356b48cb4b129d020602e72a8d9a6aa36f49adeb57175fcd4079466932fc0348a96ccae441e453e3dae04a216d4314d3ccd13b4a0ba01e5e30849bf0f3c1f26b7b024f78554804b2a58681831aac6c8069985bf3135515b5504471d2418eff2ec734043fc06a609662bd480a6830d63655db601959264272f7c1f51612a068b3487113cb304a78f99e04a5142303a27c1e2d1384b3bb1449b3ad66045fbd189054440ea437c64149d89a51e3e9f518781fb9766945e6110629e08bddfe31eadbb9a9eac9486a2fe76a255f0a5c3fd695df36a37983df94724ca14eb532df106213f20fc97668ccf7f9fa79b267d6843a1f9a72f59bfa13ae0ced6954fecc31ece77a8e5280f671130e04d6db308c6b27e0a84e2ee4adeb0c4c240fecc9d3d5a5fcd03a9f089bd405ae880b49361e1ff7b25e964a489d47fe971a03e30e388e9cb86f5ba2a42e4511020369780a6c840d4fc2e7920c1099af3ee36bcc4a988d21469a97add8a1a4b6936a74dbad22d0923b63e316d441a0ceca3445dbc22e9322f01a4e56b5f68a4fdb934297a982f154945e1892957be2920f21c54f0832ea52ae0bd09dc1b4851e51a1060900fbfd5ec96c72cd0025bb7c1be634d65f2589355e3933b6eee740ff71529b9f4e7c1fe86e22844d52935afd56bef8de7c8e69cb609b3b315f92d2d4e2865b7a469d3b957ccea1f06a2a64ce818502520c912e47460a204a517c8028d61cf53a231ab4662db21dd4defd9c07644d527857162f4a3e98e480e900dcf26c5f242dd540ed84b3ec4690487d3a84eeaf0b7869ca7016b75375293d850a022e17e44406eb86d20019b3427fe836421e35907e5fdbbabf014a7349897bb4441912c25033c841fc34671526072df8f9b956484101c4621df2f4742a9c7f502ad78aa5b3acc6bf500e8c8960ebc9d0b3f43ad4d707122dbaa02854dffcd0987f7532987e2b092440b03faa8e3d730717afad46dca99eb330cb98ba6aa59bd1e27b42f4f4068271f696cd6c74bcf46d1a64fdba079cc1bdf2e61098efeb0efa3a0e4961c16f39d5fbab0518d52864d3ab91a7ffffb02ac010251a5d446a6c19749a8c30c4071a2a4036b3a2aad8a5f361a20ef223a83ac30d6922af996c29e9500c4cf19749b32289a6a0a59c0dc438923db091cb5dc1fb7767e49e9e0fbd99c1d6e1b2845f84f00d8511b5760198e5fd83c7acc2b0ceb6253de9e6c63cb1a35df60ea65458bcd9ae7a5da2af92d9b05222c3b0c69c082f82307ddc48da37e184369041c219f80e00ec7f91f45c8c938f303dd47cdb10cb4034cbb289051d8e903ab89b420de35671456dc5e99ec28e51f24649930e5aa06dce2e31717749abb2694d5aa9066596dbe650e8bfcb1dfaeaf4b537f00a7e4661870745aab7f8f3bec63c93b666d977b24ff132632c28e4f438b0a8c4da58015f5fc1a4abc1e8d3e95097c49d85ec1da4dedc0b54c04f20b8a19eb91b3d59f594ff76e7147d2bf66c3f26ae48cb1fa78b4ad58bf103a7277858bbeae9e23590aa7a47bced8a9f8db85deba84b483c395b254196d71fb3e39dbce3a30cf50e0868271decebefc8781942cdcff7cf640cd8650a6064a962fd03d50982e8ece17aa1981ca31a1fb73d7a470b4436d1645ac812f65c8be4b8e0d0b1270958755022318bb532783562ce75ec14ad5513d4d5dd932d3e9fff4e236e7c98adf37565d5c5140bcff84c4aa27d4ca2e3855728784a4a1ef0864678b3c678182f3cb04b72ebc13e25be047216ef76979e33a7b44b11279a47c94bc366f74e39bc1bb82046a696f4d695d1cf2ad2be3ab80df1890da6ba3fcf7b16f39071780f1e3b154f9a6c16844c81e90a95600af5c69855a40cbfe52f6f7077aab1738bae2b519e8350c36f8ad216122f8b9043083c53029af25ddb5ce7780d3f3952b5537dda73a432928358fd3dd5b16d616bf15de80fb137cb2d475e53a0bed4b21e758df98981a712fd77e1b627bfb7eddfef1565f2a4008c2708d407b77cf987e93c7577267b83e4e494b345197f46bf5d9fec2070b2f337580a9a225425e027f483b5da49e82f8cbf43f09ad24c1a46bc7f3cf2e6bf0c6eb110f5518e3431f071ee4f1d91c0897b8854e85ffd6979b8374b6222b09fc579eacd2cee26039db2cfd80d22514c052ccbdfa344cdbdfd02f817f7a1e73f8dae5e2135061214e2b8114f0e4e2adae3890b0ce6e84a0bf72fd69f4d9ac42dc0716b9049c04861d1442e58145c007d491ae7e03152bc6f10e73a940ac7a9dc8dc9a0eddcda7627f5bac836cb5dddd9cdb56cdd3086a88268e01f948344657edaaa440c6d190f3ac622049c3cbed65f4e32f287e81232ae5ddd07f6133c41663fd0398f106a4f9d491ff23dc28f2cd4a5ac74812b631c4bd41d954b0c9117191b07b728f80b60ca759456a5697ba00db5b6650b8d14342153df9845aed9805de34357e288d79f074b258ebcd4159e46b337cd29bd4842ec54d5446a6fd0166c49c4713b7f5842a63c42d4faad910cda8d8c2fcf6bc9b9ba5356c2180e31a1e95c0b53e8726df8af33424bf5703af19afedfb69f04a5c8a5a0ddf1fb5359f099f53aa1a0468a50490f7984071d3f723abcf9f6ca42efb7a93a0ebf9bc3d30f2533e822657f928a9d9302ad1f7594902b156f6c171b21a03139ad6ee37a568b55302b39bb69a6456409b94243e9d29d489c2214b5fd996d25316c1aacefa5d8bfedad78ae067418ebc8f4613132b03a70fb8c69fa815a9a9a470abafbe0a852d9502896f6dee09a04e9fc163e44b0ad06c1e450f19d216d721623385822e4cc53006f687ebb6f439e56212ea7935570105698e8f3b8b8de009a5d818f9a75c6d068a275a20438d8fd4e1f408e9632a1f58e862c07eb7d8fe02f57f532532eeea60f528b9045183a1911ab150eddec1819c495041385e9775d6ef0c9dc4089a8078787c2ca49ea472d72e897e541c10e8a3e8c43e12bdf4ec49318cb3f1e9171038bc0e6b62bed5b1b446a754b2c0e59239a7681df326091c2f27e8173e1f57ef9a345bc69d3ed7f31cdfc4cb54be0692fd5e8832d4dad630720852fa34b9121b927e98c71b90e29e1776172f6042e66024c4501f3472cd86019d1290e77442569747e95b3cb7cdcb8de49dcdb154774dc9473c4a9b05178efb4cf586f626fd2d03cc1b25fc179f25de83c811df1860d252e17948fa0f4c45d7e247c88d9003ce3b5e5b9e2dd93c3376b69fb4306bafe6d80f6d41e2ba6a0c6c8b9f02d5e6293862fa7ae75d5acf7206955e9ad585fafcb91191ffc31387b64b218fd1042eeed33d56900af68ecbeb44e27194ed1cd160b9e9ae4ee4ee81674e73a0608682153494ea6cfabaacc8ec567d894d0a179baef9be1b88db30a871d31d0f0091f6e6f55061bbdc174e3d5db2e9448f5e99347b88cf8d8eb89b5a46ee40509d997a08a1d283d3b85ae3d59239655557490cc9568f73d98fc975b06f010cb0b4773fd7fef8445ea93d67bfe1b97bf11d69d648d924ba6d0556e75b590e4f91852bcd157c173e740419bb7b7c717af3c0b95f78977708c268a84141660bd3743599e50904274ab41525ed440121bcb87fe10fb0c4100f896b898d93b369a93281103ffc3cc376066953448176b8d9ab1811b5af102a77830bc99bdf3c4ac2dd344600181f65abc9c88bcf7181ae58ddf9147c051556feddc6f99e7061f9f06282461c0b6b301794c5ef779b6ae39f3964003b23f143518f2b8ad508d8ed3750d93b392f87b7347c14f8933909cc3952eb6c9f488eed3981ec87e94c258cde4e3319649edfa84c91b675ebfe3545dea68b6a84877f8f637fced14f7f59667b3f938306f16938280ec1f76e85d854bdb2e0906b7f96311e5bfc1743e8832e0cf25f35170b6d0846f98e2a89bb8b428e66a6fdc5aa56764ae5a9fb7ec0fac227ed9aa51cc1bb66216707cf507b2f9276df1eb420aa1bdf6143e8c33c5345491b8fb22aaed0731fe0cd543dfc0efe50083a83e83b57a6e0ab2bdae77aaf2f0d2e2f3af4bae94f884da6ac8f4907b2a8b1c3ff479acc6e044161578b03b3a38423a86902230906ce173ac6d96fe0461a77cd55707b11e4d0a2c0c58b9c152c28d1c96a6f6a842775a263f8d01c918913ff1a1d5d02416f6fcf1a36d371f04802852b8ffe41a42527d25559f92c794a064a32124444594c2a26440d30a5ed771b3066bfa4584c44064d51ed9ff8bae11566e5bc18049b34b493d2366f7869974603043846183cececc0c70eb0a3b935d1245fbf266b5c92645a91ac100339e772cca63951e172888480951cfc74b14f4aa1b2682095c1c8eff8a6873f81800b1d6762a4edb05060da855510e969604d1618effeb5d8247225a7ef8a61f7b377c7494b377faeec9ec51078c1bcbcdeb7e496a206ce980f0d0dcee286f128ccbef69f9562222a20c0297e855365b391b7c13aca1949824d70a2047bc96595ff7b2241e448e9638f6f182820d281efc859c2922b54d6c9d667226c8c11d358fe6903849f733ffdc83db164f4fe463e0ad98a379fc4fb11ea24140997fe19bf61ca3cb1956334b68f05ed054eadcc21268a6893cc3141407dc9b0e6d293c0804f74c9931cb3d950e9ee944ff6debf66414fdb21f52f215d69c6c4a2e772c133c51b2b2edb6bca87a95a4f5d5025952559ac805d24b17d8196ca1ef17159721c40f36a77051c62a7531c493ae83ae9fb2affc885d8afb07d5eead85b0679a997fbdfca36378e7ea22bbe441cde4226fc6eefd77505c02308b400e6aa4f97d06a9f8592ff40062dd4af557f9c1036745ce9e22f4cc2960712a08aeb1f93d0fd5763d481e37d98a57b90843138ac1148ef5a44a75178f9552619faad7b4db8d017d2e302acfadc96469d00086a6ae8cb429375f865be3f40b7b987066efc78914ca68a11a72bcd4ad9fece0382807e789210780eb5cd5b8024b8f1341d91be5bb2ab4bfb26e115e8a7cfe1aef4a67952a8399bb0d9d8b9750d6c6953e782479f3dda97a64ddfc56ed446cb7236ae79841b6c7a55b7c2da954975451ad564ab6cd272e28fec4fffef2f218b98d4148ed152b860e7187439154e92c6911bb1710218d47b2cbb0b28563a07aba0d460e774c26379ecec73d1a2285714ecb0b5a210764bb110849fe28929ec489aa9360b3a6a46e327f4142fcd22d61164ed15f26ad80fdcd6f47df938f5c52f5cc58edb538639096e3c16527ca753f800403181e74d39f4d430b0f070904c19487730e2d7d37778a5ac2e650f4e898ac00de1acdec54162de12e6eef242ac293b9532508f08308d876fa5bd4d5daddc15865e362cbfcc75e7fdecf055255b31805c5082f3ec5a3f32be218663e8d43fe8933e7a145e88591c7e72f44fc32a5184e0ac5748b3d33b7fcb28ba7696b1cda9bd4b71e59783abf20010ddc010946b24439114dff7328ae9dcdfa2882894a0fafaab5e6b5af5b5ff486ae7a19814f592cc0efcbd5e16161321867465b0e46379be7ee624b13e042d2e92f3fa4febf91e8f07098a83fcf730d1e7aef5559ca97815581e3aa84dfccb6bcb093354c857709d3f06c409736e9fcf834191b72b0d7e8c4a3f5decc1718d7e227c1988ef3de326f4beb6ec4590f0fe66c0d8fdd00448ac2610c94f8553c8aebb698a5a97b8550cb760f1c5c050415a7e03a1300904cdd293aa9f067e84066eacd068ef5ba8ef558f6d2c6c14a0d178324f066e55d50aa99c8eb443946dfb770335257622cc0d799d75ef0a3316b48424c4e3ff74b1b3006ca48381d2b0a75113f35b746d4878303385fd6baa1f1a0cd3906ae8d481f4d6c1cb8f94b779ff51d329809ef0f1261235f79918468bbbd064484deee898c80c7f8bdbb047a549f7cab21f32ff38724cca9ab23d675e1e493614d082e40ac82ea59e5443f9ceca21b0f36af4e396eb7d253ca1a6b2581fd7e180cd6c9f8ccd9e50535dcf1fee96131aa1b0993411586ef70733a78ffbb4842616583130380c49ab7d3fb575b569e33535523e4f6a15d3dfba3856aa661664d07b10838c1442d4af647c14c7008bb2d9409a8338fb2bdf2aa47076e18271e37aaa488cad8d16b16f661d5d2ac0f2bb8f85d20388c911a17354fe7b91e02f3d2c694da5698702a71e6bb18a8ce62d89fe8504174c10d663915343d3a9848ca5a1c14dbf57027b97177396f8dc5aa5735b9c3dc2c2ddf05c9111f758e15f167456d30261bda41c0ef1aca16e7ecd3e43d7a641cd59064f932d9cd1fa0941c2722ff72efb4cd137da2b0b4f7b78a110c0460b455c05c354dd4e14d096e73112bdf21be7cfcaee51745c04109bf5525ad8822f2ae8c68d6f66f4456a0402e208208350ac73a9ebc6a84207b0838aa70192eb8c61686263ed1186e963c3e3462b3b510","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
