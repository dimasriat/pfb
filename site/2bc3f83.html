<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c14bcc91ca9840c46820579c22e34135c0e4b8a79a954260801a07dfe5ea9d515da110fdb3cdec58a108ceff6b86749c82748af9bad4f0e8711c131cab4a7e2b6cb46495c38c3aa65941f60b4bf01900a3d9610599f396e9fe3292ab00ecada5299d4d2b85d0d57c9d392bb3018246d2065d94af10a02c10c5d64622591f99d84167a17fdb0c634710eb4c696c58201b439afa82a8e8d9dbcd2e8938985cc350dc6d0d928784f1774c153d15f63342a01445a3e146024d427ec33172ab6c19b63d0e29b3827a1aca1f53f3276af4fc1137aba5f46e7d2d6dd4b240cc3e622008430a758d33fcf1f0b6a4f436a29e0f92cc70b88f169416b2344b451d83f9fc273c41afef323f6ce6badac69cb66476986da91d7563fde1b0bc6ccb0fd5aab83c47c91b4c8ce26513a0cefb6cdbb291fb682d1cb8749e33bb0db3c14996cc5785585e86b82893d5868ab03648686e6f919e45b33193f7959d2a82970f99b13de6ac462eafaeb636c6f013f7380c30af394a108e7fe9f4a118a501f11f05c2ef40733c384e3b795b7147f21b3872a89e3bcc7227b62f6a7864cc262c2489d302ca31d4b6f12e0099c6c3116558bf86625597dfc7db48ec0652655d462b54388ccc7b6590b19304c99d64583d74c151e93f79c7d06df9e17953e03720683ad92f4f2264fa5335fd3a326deef9abaa41e86b731c07c5debdb84de22039e111ccfc1ca8a39605d27134e76430541fb1ac004f2362b4e652e52ddd5e55984563f4361e1da7ea9d9dce7066c3d402dff469b128ba176fb206110d2a18f377642a32199f3152ad417c834750efa4597057b41e550b2b51a63a5612cf327037f7de2f8f14dd5150f5f680205f0f3d1fe6da5e885eff75d0dcfb02fdb0d765f9164b55a17dc6a862170e6fad1380c35debe9464dae2be962f11e10624b38c67da2de4bdd21facf1aac94b546e4d4bbd20fa38a61d768c6d8497c03d8c0f3332982aca92376289a62a11f58e27aa065581cc38c201652ba55211b5edf7716f043be093111b643eb6ce7b3cba1e8c34674b149c9b95fbf53fddf62614169c5c58aab6fffe23be7a027cdd903883b8f36c3b8a8b719edb6fdb0b8f952ef2116d8b388e44964ac125b860719a3464cc495338cbe21acb45b1860503c3e4fd65903db7ede8743c4dd4d08f493ba160a366d4934fe343635ab11e246541faea7ef7efb848c9c3f8d616f26c6819ad9113f03933e3618ce92e8651e242022770db8de7d52723fea129b77f64de7270e6893b883521623c0a6a15cb9d384a3897f85f990eff700fdd4c34c2db48972556d3a614a746b3ddaee102255a23c480934ae6d557e069c303df62e4bd043fd22a7f0cb329a5217c0da625b4881d80516005c36a90a3913046aa6c1daebea10789da8363a5bbc1d68a146002586dee47d6be3ce3fca79ee7ca64c610a1a50084d812384003e8ef6ab105c003c58beb8d8a9a311dfbae908bc6875017416d815e24b55c8c008abcefee183de9dd6382ed5f00425be7503b29e5cd5b2e12e59329ff2b0bc26a9106745175bc35fd185b98f623f418095fea7111b43caa85d78bdb80ede82940bb3a2083babec7ba2b9531792bf10de33f6e3b19024cdade57ecb0431f181c2a1ceb0376c4b48166f73b94685fd6f0b6aa2e02d6397bca3b29c4684fda303a907298451365c2106e05594395f4f7b13f3f50ab50dd28100915159807d9cee949ba4fb417140925aafc80f61693b2e2a17d6c07eb5063cee99ff12aea4936cf3d579fdd19119fe2c8eff23434a92ffa428e9f6e759ccdb2bd58e042fc2997e4d26738bdb040728646cb487eea6c0f3b544fde402464328ecc2a2b414f368573112892db4513532d7cdf0476a488df74948365fa2bbf41a6407f3983e11a0a67f3fe8d5a4fdbcf10b44e706938799c5a4355592ba5029731a6ec6dceaceea3580d171b414a72664ae8e12a5b22ba2ee6451f07cd967e50cb2473fdecd30af06bbbb9b0c7629c3f8caec2cf3e73924c1f5a8c7b526dbd5e7ecd782bbe44181534eeb3ade62b90e368a1ed56adaf4c0e8b9107a07d2206bc6ddf45bb9ab19c3b9785346e22853687d580d0a37c09b31fbf7654f33d0a99e5d0fadf63857127a5d763446169ceceeca6c735705d899d10ac8654f5a71063a134e1a19d407117543c9758e0f953a18559776b0e268f1d58f671e63056ac6f9ae4207ab046a57bbf3e921ef382888731f163ae5f169aeb09b0aa8af64278c354d37caf9ab8664d47b16e7dd211d8c32f7c8bffc7568a4e9b751f7eb734ee85286e74e9675a51de0cb76e9d9c99a09a3092f00ae38a0aa4f8aeb0aeaf8508331a467d423cf96680a5149c62ea854ed2c7a535d33e719acf5770b2eb65ba7f2e8e86722ca9939e902e2388616b7c2ce61374b235deaaee251e0f663c3acf9905891defadf4836d8a1970bbfb2aa72d4f13b69c9bc2abfa9810e19776e4b87f0ab9bb900118f2b02e6777089bca70b4c172ddc24ff2b4e82b425baa37fe968875181f1ccacfe4faa09edf88f9c001e384fe415592ce722a6e779f5559f04eaf93bd0fe98ba0d0e11e646a83bfeabffd75b47951d7172800abe7db1cb870c20edad299f82bbb8c31b83d85429da214de7c2f5cb279af691b008e0614bba30519eaed26213caea4e86d69d712fa37721b629a4d3da45cb94b4c574eaad99ef1eddd3e499d022fe6d2c50a1ffa774098b8c4a67c7cd5c583cbbc478daeb192110455f208a0a049f6c51f0712d7a9908de42e375190c017510aebcfbd11dcc9d08c1a91c581a2b6fbc92b85da14699111835d8533125861e1e5b6066d493fd261673a3d82499d8c0d749142e429231ff0dafea4d4985f51438e9c83bc2be3f5105345e5a6158a31ac828e871236308ac553670449f054b9473454f2ad05712a20e20e4ce400e44578bf775671374e7d1f5ef3e6ad977590036099e82f62ebb3357a1c427ea9c6fd172c78c4db8b62c01c8a8b1a88fd46e1334b1d26fc3d39be42e3b050e51f1ba2a0a98111380c18d861adb12c52ed128846c55aa25faca3a4e9bf0316dc7f85735a3c4de7bc946a3ff2d231e26f3aaa3d4e9b5e5150bcb12786ee3d2ea5d1b294e6addfab061aa0e8fb9617545ef4cbc223343b3d667844a34463b947b8ab0aaba0f7a5a0b829e213fe65a475d00d14589ac35059a37763aff8aad3cd13d09c2754aef243bfd91041d5371ba6ec98d9fba6df9044cc774fba1791132dc67065e8a036a19279605df969b6c3dd06c303a185ef9b7005e895321088bb02019d965dace57027bc95a293798ff01e996d2001310a90f6bca141a42ee31e8d213c730a19dac116208c138552c9e6d3150d92dd6495b651b0a060235cb315a0e9d682ae67b7b1d476478b9d05127360758b717b74511eaed6e76d655e193b823962c043ac17e053d948474559cc01948ac4a8a1cbef0e3e0096dfb8e92c8e602e62bbc7fbb225cbe1ed8a053a17988c095b6512e1d1c6a0b3dca7b1f3e180e641fe18c461ce5e6574c251578f0beb28f67813c633e9b7ee8faf2af598a9a16342c86fa8aa7c53c98753f6ab4b7bc44df47cbb75563e517bf8b35fe5b17265ec10af83cfe886b677edf2f3b2c1d373c7cd11b5748a8d90f2291a57716e8e54cd2298174e39cb55605617b51d8832b1ea6c9ed177f945292f32de887683d71d91edebdf834cfe58e3d4a746f75ca5821c81aaf1202ecfcf572225a9c3ff7d45e8357b729e48881005898f1b751c72a13f14df64f5a3255a441d0dff338447f3713aed841e3b1d5fa19c592edcadae29f4b19fd4fe2afd2fd56fa88dff9e483128c5aa7adfae143cec0f1c835ce6a6a66ce48e403247eef142790c0d7be33b7b5f0917036bf18a77292a8128acfa4e0739638befe7fff0973668f048b34ba6fa926388aa614f6234784414a19c767d5695ab0258102b9c88965c458e099b7dcbbacd718220fab77c63d280e54fe9f771d903ce2d5f0befceccd60440011d9706ad967ff162476c5ca3d0c6b3229a5736d94d09916b817b62e59eabe02d08b1fa48132850258af2b2925e13e183feb950ceae97178d5bef84dd3f4b07c9be4c7805ed06ea699caaea7f4fd4504835d5163b9bb71d06bbb5f7e6ac07d0179e8150d3b8ed8fb3d3f24caf2f87efd0c0346865ef1da4b72d51d01debf0fc7bdbd82a49550fba2da233ba808d2321bc9e895db7d8c93a217840c85cb48f01cdb7dda66d87fce865c3f0b6495fa04605dc41a72a2afbebdba3026af778efdf38b6e8fea1e3dc46a3010476e96582a48d9e2cc31a9873837d176832dad308487fb9e898cb2f3816296d928d6cceb4ac5c411d85f7d6dd1104e65e2e463fbcefa4bb5cf706c8ad234fe39e0d98a5a73fd1dc0a44942accb5cfe59992831b47ee0d0eb446c8a978616121e9c108a13661b9c848e6b540ed65c634d527e80a65769b93b56c1832aa124abe58f46f4afa49c5fde319388087d954afb1db476b4b65defc389c790a3c369c8c49c11311c417364f7f5d07c6c5d4d9809fcc0dd386887aa37b5093196d5a4b98f4df40849f00e27def88395f599087cfbaa6b52e46f57027ac6c7dc4a14c732f9e97493fabae985fa25bff96cae4e3427f57b3e7ca341042cc291b6805b9ab9c9075262da4cd5759ea58e6d96282a2e10c07b3055d996012cc762a4c4716ce65c73bea414ea2f84a8c1d7fa7c2003170b92f3603284179660dd66e00384b4c9cf066620404989b28cc4d02625fc48ba9eafb31730412a37b4f110d8abaeaf6cc88d8b451bad439e20829cba638fcd7865182ffea1d7b9fc7f5a481d54681404ccce14ca526503999a39f63c1b196b1ff7b273a475e9bff3b1229a3892ce8d9e0139d854ce034d4e6f91766949cb7438728fd75294851c10c1bb33dc0cb843d622fab6a67809a2bba41a11b688bb9582a2acc6654f342cc1670a15f4480dfa99f0854b66c0489831d17eb23c3dffe59bbd0a7240ec5557efff1162ad9dd30d3381798ad3eb2bb141bdb8adfd3d323ee2aea2decf80d981607d577a4490250954681e08f7fabfa1af65a693c98da6e50040ead08b1468a285fe169b639ae77800cb7b0828c5d410501b88e434f9461883f4fdc47e7ec09fc7930cb6517f6e1ecda6a789b6b50d45ef4fa277ccdb07a4dd3b7e2bc556c903e9a3d560824dbf8ab478d5ab6bfdaa9b7910cf3d15f152e570c46a7649595550b41f09dde0aacfb831e704f8826e7ad25d44fdd396f67f6393a7ab96af7cbcce16fa5b3bf3f25c317019444a65c3b3a83292cd35fa3b83677c3d68a07553f1f9256fcbe1f2376bc65ff0ba686fc13e222bc178a637733fe6f8663c9995cd05c15f73c15ef1dd55e54cab0d79754c50316e59b6038aabfa3f01f15435b2fd8d1bbb0cf8a9c5433405c0c86f5bf8896660dbeb4d62958f4e7deffba44a572f200714f12ec320ae57fadfddb6a72f810a85214b28d7f92bad5a52127fe42693e65cf57a279d6947814eff184dbfe39af6702c2402fa71a8ee8bccfea1b0dfdeed7d46c2ce3c1ee155a9dc9a2049500e07004aef8580ddf29611a7ae61524b0da98bfa38b0c5438ae250adc5b6b5405f9f3f1200911f38afdbf6cba324da6044e9ec3090c214906ad2c3a90d1e19a194e758b8bdb631c21ffd0530c70d46405fb0a4d52703d818fa7384d044bee0f95b7ada5d688dfffdfc7d797f6e01ba16d257b029e952cb41b65ab9e4cd29f1cd2b3942adaf76d52e6ccee90059e25d81cd3016a0ed79e64146c13ea1f77021e4d58fd78c04685438bd88a054a326e0614c8ecf39a552731e594f3d9007c633b8ad9a31df4eb9ed05b314352a1e0daa2db7bfde2c12fd36ca4a3ceeb61ea15f45358f8054b2a875e1bc09bcdfd9736624c26b836b82d306a0c7a940905ed96725c38b8058780c9f0c88c56945300abb6aa9e9b802841a7bb78dbae124bff23bb8e73f4e270b3ca3e37a1934a8e8bd356472e07fb6d82e1f4f1d4fcaabd674e68fdb74172a249f973aca7d695491b2d5096c975c5d9690db320e8113f159e7b2a7cce1e6512ca4b26b2605abaf6eaf563d07a94ba6b172e8bbdf36b3a7787d720929cff01aac7d16cea36122c8a287cf88cc03ec3401ab5d122f04e47ae1a3125cbe171223e97658f6311d6daf4032ad12c158d9eecd074a6eab21e0b287e38909c177a6de1b1387e9417b16373841fcd435f89bd0a523b9201060c7bfba5692f34f421b729d24ca182550934e92f8b3711513c38b517959c8aea922cf30e5b02853ea7bc7fdaa3130167626626da5a0c2896f9dc9dbb2f1a88f959d6adb6a83c599b19c323e786a329579c164b294f7593e967058e3f12dbf99814db3c2d0742adbf3d47f0cfb3cc784701cb354f3ae36d4370820cf1746422bb291a4da09930944a029cbe7091cd84873f423b523cb63f4b0bb801904d22516b3a118812a8873cde48386017dd75d110ea21f51e0b99c3a35c2646bc46bd55edec1527655bd934568db531e9246b2d2718d2c27c09f594d5fc53c849b847ef95e55ae5a3aea253e4720f0f90bde3842244a32352165bf348df578572ce11e9ff55701f184d45a2835369a00859d6fc823d1aa10ae3796fc1e76e3faf9ee893926a9f1a480a09ae5c140ee300306dade276536c606e6799364acce57d2ab6af51b2def02f37f9d586169d761301b6f24f0f474fa65f05481a7e53564ee4c14a0317c22a775182b4aa494d79a2f0e4ecaaff715699f9cbd45c1382128c335126c71e955cb327f2bac4a96e0c2f5e37c7670a4305c90de7ced5064e5f723604212f7b537f6105fb46f3b84d019eb167a11c4e2e10eee353587997615175a107ff27aff248542c1242e8a5dacd3c9826096857c2ef95ca52c7c3222b0554785777e48f30edd7b14fe8f4571eef1570decd2076932ce5b1994b16e584cac35c67a3b162f5685fa9d295400ef7a0a1353fb2b8acd54df4a4cd23605e273a8a92ed38c3b7f8ff55ac38b256a00750214d106524688fa1b271183b2de98a2a0e9f65ef9be791921037d36a2b8fd2746b018a3dd77dc4982eb7ef0e0eee2cd33fc13512c1a9b6089035a69c5e135111250a0cbece1343df748002d4b7983bd30e257030076b85ef23de8fa344d5b72efbd44717842142544793f5d88277d30892e69359659d1c499a028a38c3c9d1c962b32fd1b03ff1c6e307b90c5cf3b4c9f5eabb2559649399c1bf6b1fd8ba3375ee47f1d07b8c760c2f648fe27b14726beb9621a3fdd5f2c85565e962a4402269724ee9be5c165f66f3c2932173e2907e08506bb50483985012884710bfc2305ce1791bcb6f27672d311f813df8ba339786525a6e8299cd41f72cf1d61d9b5717408c53c4e47c739eaab14b294b7ef370b2453a1fadb7ba9ebefc4baea1ccd141620bcc82f7d3067cc328d357130c8fec53039d42f960ee135038cb71b33edac84e7a96adbd5b8f7113acb03441269774b2cebf1cfc8d573c68302ecb9c629d90edc3bc93f70fbfb45852a174fd672d3f6b6ea499b1342129f1341841987aa360c67f2168529865034a9587455dfb9cd2b1ee3f7efee0aff83ea2ad7b3684f3995ee944fe6ce61cbdfe8c4530b08ddc889ddedb0ae975d38165f21fe0b4d9d544f4011013e44fe5732c33eff9cec6961ef55365c98cd6305b4a4ddb5228598d7869a21130a8b69f7aeb186b7c224d5c25c54e999d6b0537e6679ead2cae4d0c5524e045e843aa7384f116b8a548ad8d8e79f2dc86b3d2fefb5d265e8a9364b9175cf92743217514a97e8c0ce2e2d5cd9b14b7d10daf8ed068620faebcb665a6d94a27c98a574da2d9bd97af3a5740d9260b9cb73d4247d49239c2ace9ebc939e890cafa3cc9fb34b97aba2f3fab1391d2c29056c5977a84eb303ff085077638481d37b378ebdb529766f1c5b339329781bbc51ad15f40538fb9c289b5689a46c9816c0a9223b56a80fdf6106c34c537c70568da0f13fdb08ea3dc69be8035888728da7fa83bffc59248a88e24f4bdaf8ddc5e1e96abbc4668e651ec550bf66bf6b94e53beb5b78c29fae0e6ca4ca1e9da815f67abcf8d083fc3b15e9967c11e642e711a24e9d0cb4680bb082992b554f44edb46c32fb6a009a9a35105ea4bdafdf926986943bd14e1c56beced046a22953f159c11d40f4aae51b19ab130debaf76c7f9e32b678a8288e8fbbcd5da936cf65e1e7cd85eac0cee89224bd4a1e6e2fa8975b63146ca6c54802894477b3ff87b7c0083211d63291428999d259391ce6f6552f3fd0a2f5a3b25ebad4a512f7879645c9fd098df023c9483b53d420df9d362860ae7b7f82d92a240714e4b94b8b34b3c62c04af1a5a8d491a92cac3be362a643726da33fd168d5bd45b968654e9dbf13f8712028a20c5fcbb17d85114cddd528c351829db8513182173c75e91a9ffcacdc7f956bb59e412d75bf396c93a74e26b0fd58cd0983c78ab72c917630f04060e886d8e13ee6e1dc7cab20941bf227544a2175c2ed924aa3152ccbe66f4f40910058873451c03ea7c7a6d176cbd7337987a408ec684db6a42dc6f1e5359587034e641245028baeac19c4dc6de13ed8b402f83bedd9e27ac84638a25194a92154b541a4e53ac2bb50527342fd4b0f94123b77c0ff5959c195d29a6c67e770d5ac4031758903f5b4e8d1e2c64176379ab44455fde5377dd5f1fdbf4946fd023df8d7d2273fbb7c2f9640e8978b18b4a0dc5d10608348f2aee0bd4c5652a9f0e3aaac4a730ddff0249af3f7a060f4ba381cf0c1bce241e61e1fd33ef54e92d30b67e2db99ce508e2a064ad5621c8a43b3586c576394252973653f43f87e84a4155e3815ab080a8d983d2e1249fc4c45329c71d34f0127b349c98b5ad8d6965a7ea6e883aca97ca4e7cc0af68dbbb457afbdd24fa73f864963e56733dcd2669ddc46729b7f0f62a10d99e7943e322701fca8bc4b76873fe27741e6d427a728032da5a91ee7c2e269b81fdb4c5a730f2469dabfff366fea4840b4344c0448b1e54fe9f97fc337921ecefd6d2755e964699faa4f5023753ed0bdceb674b0d6df58259de1cc368e661998afb4612fb010a32d788b949affc8fa83a529d5c1f35d65bd1616c9b13d0b780939b94beb8b468286217a53b54d50679608cb0d1ffd87239","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
