<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5355bf4307f51afb87c532a674ca4695c5cdb1b230904071001e56ea4c98fb6c26e6ad0af9953e8dfd8899dd221cb1f6995ea44e14112af79c8fc669162de3993704f6d69f2881a65a235127a7c4ab00d88d52fe2a6f4cf29f0f9cf3e2de3398eab80f87683cefccd868082413e1cf4cb8f6bfa678bbc418c07c9a1cc5f33ae47ce069f7d6ed145fbd178483bf91c56da1a24daf5409511f29d2fb72ec0b8bd4630f7953c3b9066f3d6ba0dcade1395b813ed33c146c964a54debd1d99022ee6ca779179b4a35886c560ff917d3c2cd17098ace5cc22d0aa898aff37df483cb322c9b34dfcba5ab3ee0ad4d0673d30ae571aadc778c24aa7c5fd89c55e2990d464b06363779f1b2bf738a1ccb423b4d3c5c605c383fd97d0bd0bd68a0335872446e47c9f69061a974f43af10cc1db4106a3da11a54753bc80ed35e354155400230a04d5e53a4d2e7f7bfd92e29fd93dd1a1f38ccd64494e3f5d887b3dc3d6782bdcb1c483e8fc37fefe0239b6db2ebb2751a615c1e7067585903c4855e3fae734411dab3449188ad31d0870e2d98d70645e549455b96f427f964b5dbdc86fa4f5066a0b68dc5061f22860640672949f52405fd7f81810b1179ecb1e5970a34d6022fb396d7f0c36acfb4abb8e93a8a70048926e310421b5f2deb105b2aa78fa591824d6e28051b89a80fd4b6d1eaa0ed0baca8286dfcb9b906d94059b954bdf42a96c48eeed44c509fd130ce62c34fb49e9a6146f061d3d45bfa754ccb0900a1cb9995f792ad25bb186e48a5ab1e852c604ced2de823658e9908c196e7700493fd0a56bc79b6fc9f1ca6328d7e82f6c943faee207296a0d875bcb33b1d870cc5b666d7c5bd376c2b10c079c0c0112cfc2c0137fff7d12752eb365ce12badd10b8d349adc0e5ae7f685d7298ff4d9e31aaf21dd0ee11499262fd6f170397abfddcc136fa186d012787f6223244f468067348905eb1cb97392a51205c36fb4dfa39da50c5235cf16016ea5c05e9f6ff1fd8aee7b832db0a51a8a6c8efce36960d3adbfc1dd7fd3b0f32cb90699b3a76d6470fd537a547e1aff182ed19f1e4da6e79539ead5ee03b8b4be01696e5c45317f2a4bd02b2c9bd3cce0e73e639e7ace5d6eed39de0bad4eccf427e6f2cc74617a63b7c3e5e70a006ab47647e15818f0aad386b21b301985ea466c12517e384d727243aa8661b087a846f00a6c8d0f20cf9f70643e72902b5315c71a2a4ae1f0176445ca90bfc89ea9831da648a4214a493a17759d076a860b94ea2d3527bb55c12eeb5ae1d940e417f33cdaaeb64dbe12792599b7a63654338f773ef2aa601238089963f2e7ce1761330d8d8fcae9193d07ded208b783bfe41f743773663dc165e7dbc28e8eaa653975fc210785bb40e1b419e3b427aca5badce6aec17608468910dac00f20255cfb757341034803abba87d08df1d76925a3546c4e14669314227c57f423b16f75f418329e0d5cc20def38b0e33bd8f8bf0c07c5bfd3da556698998bb00e5ea64c9cbed7d4f2dac00a9c37abf1208b2093e952f8462116fab78553717a62f3572f9e0d65cb1d1d934905888f2806b14bbea102e5ee685ff27d13b835d5be562d56595f7db8292a2ee215c7bbff9937e418c7e771a0dda9afb73cc79b45ea5ff371dc7dd9e9aadd9dbfbf68496c991fe1b9622f32a8f8c2d0a5600b5a6c82ddb55542c3dc0bbe538e138a302db7cceef352b871e98758b5bcdf18476a4e79a1e4a8a44cbb22298a50f520f16d03e5617e06194d24894496227a2239c7ad2f43bffb340f55ea44c86fd5579184fa849038d8b8ab60a918aca8d47da03b6eaa0a9754b7a5554d7ec609dfd9dcd4d696cc79b0151323876563c9add6a6cda690bfed50ef853a07f37da08779bd6a60cbea3e570f57e76ab5ed6006ca53164141538ebd88d773a091716d7547ad64f65f3099e60b6512632a4f7ef3624b330d772f8a25f7dbeaf58ae8b984f2ec9a9db22ee3827c8310fc1935fe95856e977b3a12fba54f02996f46ed2e868db91a5328cfbb2f7f69ae1288a3d9cb4c8476da7315d44279c77c11591969bf304d49af86f468a94b166b263084eadab3b5fb0c092344c2fa137d89054155990c74aaafbea38b49a0aa34b34cd78c9ebe526f94ad8cef7891eb28ada190967a5c1efffbd2859512e9178b64de6e7acc17a909de337157713f4c114d159f61eed26e99f541d6eb73cff7d46bab2c26e292acaad940fb3eccaa63051568e33bf008b6f2dd5b12edba40ddb3aee1fb0c9531f66451d8c421799ddc97927b85e7a4bb62c429a295551120b34a041d83f9543f8f8e5fe91bd66ae24db13d661f9608bd05de765dd6357183ebb822ad994247c75595c495ecc5d2e41cdd47d71a975851acb913b7b6a99c49dc12651e799e6a30ef877c0d864e9d9d13f63fd68ad9001fcad6c506a30a733f36e4a0dcbc0d4d615e1831a1cb8e681c8f2cfdb9fbe3ad59e6c13a4f989f7095f863eec9e21613fafde8fca45b6b64de2ad095ed6c86ded68cdf2dba840c796094c15c4cf1c5f047a85ce2e8b8bc3acda4a6a03f326af1a7cb85a9d03623e6ade845d380ef18d3d8687a2e53c5f1b504ebef47b45614ff7359b07c4d62ec1a8b5da9886a291b46e90368ca93d7b11fb6e2cd8550d3a9662256cfbb6fc8aee6eb73b498e503fe86c1f7af30225b97a2abbeba7eb922b6e09aef857a454c6c177b9ab9b8168cf2bc7f56823c0a8cfa6d5ffbf153a78a337ea1645387629eaa801e5194daa9481556bac04d0b2723e1e004be217aca3dcbe6061f1f67f96811f06b48ed96af8c5af71196db58f84c8d3132e8dde4993b65d5ff8820979041bde222555d6d5ce0064a9bee89b96fb8583ea80be0942ee09ff5c3c93ebab2d0d2e33cc296350df6227b6101103e865f6e874cc9e91bfc83e8bc45382b169198319af9a7d6ee420624c09e0022b415632abad95d622f14e54d4d7fcdf85fbdfda66f1a81a8a8442d0f73d92a294658692ae60f6d1f13990cd1daccf91c1a870853d398025fe7bc0019c3c2299df32bbfe87a5427c27eaf4ea4475b8987b22dee2f0472ac9c35adf3f85e371291c5ae399d616b7dac443713adf06bd68b0bb1a43da38ccaef4a13fe8585530ad8185f055ce6ef600139265f2530e1db5cc2e0199bb6e398079050e6bfd776c313e227293a100fc7280ecb7f80eb24c0de51ff5998f67d217d84ee3772644acbda8164f25d42758c75e25927a5ef5682a9fc429648b95f0139b452a28dbbfabe803c31dea5f8eea3c04d55f7516866077aef8f3481f55e88a479e19c03abf914f92f6a4e119bb883811e39a8d85a38ebaa5080a78c4a65da62e55d71e1f585215fbe28b0b234843860078d09b6184eb29e9a8425c1ee85be26fe298299d3e513d8ae9f1969f8bb74a77860d0594f90e549aa532acf0b74c8464dad72657bf817eb8d803883653555fa73454ada20471d714b075ca10a97d6592f87da02d03bbc072f243797ee28665a3a15f527986305d46506a2f32de04309cb35cc5849bd65519a2ba99fd201e7ff6afe8a207276837f11e49b899aed12f5c761ef646132d49ae497dd312c4e455f70e934c4cbb52b44c63ea7ad299fea2e2645ee62ebb7a16d388bd3732ba4e74fe42f7b131c52ac9492bf96c58df80e6565c481ab3f38f341786529596c31556ea3897f36c2defcb43f49d8313ec1ffa5af448d993b11f1e0ecb13be57168a99747d9d32615aa07777d367a1d10702b9d18a9d1a0118641cb45577c4c77ee51278e5f29934bf0ee45c827327536b73d55506780273dc11323135394d864a51c25075305e1de023dcde3a46cd51cc986fde9044a0d7280e18c525b44e88ecc4a438af427febebc757eecbdd78a828d97d233bc29d24b6f03821a61dfcd61949611f52cc02c6cf9327cf623371c6e761f4c1abd2bdb24d7aca9a8451f97b3cc8cdbef9ee3665d510031dfb31b015185c2a25184775d384ac2a34f2d695f69a39b1e3e8db206bbcf513cc1398e3d994a4ef3e5c81fe262378851fbf84185f134ed1dff21461cf54375c95332e7186d970e67a6783dc7a29040af8cc36a053f11f9ce4fb37ba65fb9078e4e03812c52749f272230f2464f6b84357c6ca1d52e229f897f758b11119a2be284ff5406600db289c8699b6e58f5e670a701642b51415ef09147a5db65c6b648825f41b6d1ffde3888fafd51277f28e7b2c99ac4dc39a6119cd54bc43699f2ec7c2da626611973006cc93e2b7a73a0da533a9bf09d6b6a301347193a3fd5576c11912f5e510a7899791c1560e665fed9d0a02106ba88755a71c55969a3fc62bf7dd3faf5332da8906aa54e67d2707100e39045c03317eb63f6db08dc2756f872e51e9ab29de677863471b119c9525f109ea53508253b61e81ce230c7e1127b7cba15763bc81e0fc08bd059f530718d637e2c18f0fb7f581254011bda039867a94eef6b4eb7d97103267eba0d3595725589332dd160c013d986e33da12a2177218306b913cd2094becc8a11d76804d65fa5efdaf7643fa3be497e8c189ee624170503de2ad246f054443f6d0b2f59cbf8e4ecfbc5694aee4aae58731cbfbadb974bc7993f15db85e3b3b68f80059731721e65f45edd370a4a2db7b4d2be596a0434e73e0eae01d151eec8c7d2bb1236ca9f98bb0f522b3aa67e1cd606e4230796b978662de4ebc6eaca610b852deb98fff341f8668cc7d119d105713e6145af6a426c89017997e99310f021c85a5759d8a96ce023bae4c1e6b82c685581a13d9aefe31448f5b30cf07d2dc18cff035b7bd95a02f874d0b7a4bce64d348ae3e9e6a2e0949a16d2f62567d56b6613f12e0eb8b9ae0f6cef9d67029f29de0882ba8c51314f911a2a042d0f72f4b3511fcc2be931ffac64370ef0c2f7c330fbae38e6476230cac4f69d69955ac42f748e5b77d7ab08a91d6ed631a7b2bfef48bae2e181dbf888f383a9cc70e58def6de0d1a8a1bc2912d73cce9eee6ea5d4e084139494b7d73deb85577398d9fc78514ca521e3b7a8f9c4342f3a74daeab40e5779a42937ff81635cbd4adcc68e77e0af25500161b13183fde5cf9302904c27189d999085555a4252ad77498b8cd2105891e1ced708b63183160013e1e0ee572d21b2bbf1586fa83bc33afb52e63cfe361eb9592c53f884b99be51f6f26a1303dae99ad90dc576cb72cd7b8907041203aee0232d77694c8fc173d21d176935b3eba72e8debb514ba33ddc9e8e9b96927986522eaa3862c2c95f97d226e9c64136f777d5accadb1542a329a5c48ca3f52f88c1d2d476396ac878929a38e9b50b1e7c06f5ad5f5dd8ee6d84c1789e8ee304b472123ea7536271175858c0f3abb3e118d54be5b06c248a52289fac638fe4eaeb125837c11334521ae151127381fcded6565cd1542ba176e17e2a57dd4b0a46c0544f0633d6a9948a7cff54f7ae712192655cfcfa2bac5fdde62315e518de79712d78f024f85c2d42edf85c5f408f23df572379eb0df327213251c445dceac19962343ec95b843765d103155ffa06ef9a7463b4e8872ff4322990418846a9ee609d1a6e3aa8fe1d5110615e430e56cf919238b1bca8e5f89205fcec64c188bfd10438c5e2de2d36451b25a41d11a0aecbd8a3d74f989fc0cdb56b6032821e320679e4de0eaba44345c67c32abbde8e1aa4a345e7aafd8801b906940fdbc65abb8a56dd55b6c20b865f119a9c46a11c28164930ab0d94acd78d4b8d6f95ed2d730524d52d626f2e341e77b6a62cab58bee840ffb8cda109a2da14ccd9c507a50b018028fd52ce29dab552245350964fb24fcfa5623f39a8af43c06fe7367bc7a2a156e2f70f04a7dd5ecb5c759f70941fef9df3a02853cb7a00de112ff7f471fd1d466cde2a68b12b9b92deb823bac696bcad2127b90ff75b1459d5a715080e3275a3410e1799eb020a3624d699476bdaafc59ea34b843b521afc9e767b16c84c3a82e85912de816f05a2ed84e83ccea39776ef4aa68576730ec8a6c34035bce408a1eb15226679f4d5671753d5fffbcd8bc8e831764d1737f2e0b4eb786187f3bc315fcb0d49f2c4b00a9a0f4eaffa34138b44cfe8f64f8260bb7318efd2a6566e8483a47deae3b23793edd3ce580dcd34114c5da66b5cb2f57c516cb8fe096d559759495b18c276a6e13c30391a42b704d89962f6fedab55011abfa929caf5ccf00c01cbc8f62561817bb97f69cb998812597e5cd1b60b5b7ba58595f4f34886215cee4629454c92217c11cefc39d8443bce5cba69bf202b95970a5769d2fb8cfd6ae8824e690552ba3a2f60d5ac644d51b34213431d78a4d0ee14013f0bbd5fa8c089d5e809a3520aaadc9898aed24086109f28b5b5fee85c6436323c668dec5830c0a0e93791afacdb5c31271f39adce1e5fd6e05b1a6b18d056cd45247b9e680a66da0b8b2857049de5ffd4989c7d70824aa3021f78081b12d8d9e76f2201db9349001c9f826f183cd2ecad372651fa2b4960218e7acf276f43f31e550816c658dd0860bf20b3db2a7e33e4c59e2c43c27bc450ca2e838a7b8bc803168c8cbef413744c95804d7d1b6457ecfadfd13fffbdde9be3e6c9a0fa6dd40b1c0c814362a318b6a05d87f80b12e8d05be54b952170f30a00c0aa0fe901389a2b8f3eb59b6184cf6648de6c13f1eb9286080dad661e56a0e25d0d4f286fccf1c8b4e1a4e0bdd1e5f5a54d47ccd72b79fa0370aa5031c2552da65ad5f6eb8c0c15396a6477016cd40ebf814b373b65567a993c383a28f762c01c6f1ae7d51b8b10eb112ef31de33b413298b747258e1cdd64dbc00acac3925a255efa21a06a0f1b0d0f7603c94dc7ead7492e67a6a0a0cf98a6e958e57b12fa5e95a4146741ef0e89781e7d2d159a47e1852f384cc1abe91bb6aa0026ce73d9b30ed3b766885da22d06a1edea3b8c9f8e3ed12288054727426b2c65816f9a07e9b96aa178bc855a5fbbc8b3fcd5506d65bc59e68b2bc9ba2941cd50794a787c665c31b450aa6724e7160953510513fe8350dd3f38a4f2037fb9c4da0d6665c2357bc4f73a466ad7bec3a2169587540ed6c3847bf4258048fe0f69f8731f193cb7765198c927d5789c60d6f6fc3128ab97f743245f9abc950319c6de2ef92e6ca6616d67ecab4876079f96c133d0407e0e813d5a46a0ea9d9c54db910a45c5911b27ed3e9e906ce94dbe7087b6ad957d4d976bb2540c97afa013cfc2bb1eb9c0b7f07fca1e0a145350e4892ae04689749d6d066a4ecb7308c4298c0212fe32400c44011700068bac5b192920a4f84c3bce8d16d4e36dad2b379ef329d40e64efc08ddfbd67c9c66fc0bdc294c9016f1c733a20454aa8c3f957598a3409f4f178eb005d9d59580720f197416f6c7ae06158edda042dca4d7212a10b3e150da282f069ec7cf688f9b6e725b848587c481e4d23cecd1acd32743d6440a3adf914b9c673d84878d9bf2829e99e8762a1dcd23baf18668b5eeeb3d4bbe5d765adb8e449df1adf87f86c226bcb5a7105dee031c576d0747d0d6641154ebfa6a4029069e876f29337464c1e0fbdf570a24d78c30a51f5305457ce8dfdf93cddc1e4cd5574370986088bb758d4891d963a90458067bb28cf605485294328338a11fd6dee1c13cf240cc455167ae492822ee130091ac13fbc6890c59187fc23097bb27df520f06696289a60ff0583c969d67aa9ebc69128fa57fa8ae9baba9d35fb536b37b77e692d0af083f82ec10e5b5a6f17ca3f0c69204259e3fa45e78258a62b6d0582e2a82fd30b211810673258c8f1cf839bd831979c2d03a44a07264f6ba3e690fa8bebb8162da1029fee099f997677db9643b2a85659e25f3a4c2e8b9ff316dcafeacf17dcce1789751f7b0f6e93dbe9b29a5134e7c15f1b8c3b998a747c55cf2da95555a6de483191106f983173d8c027c67c8c9b6657413e86f8ecc45ba7f2524fe788fb8d1c80e22e941523d95e3b1e97e2ace6eddcddba5db0121f5c0554f6ecf98323689fbb03121e09362a3d8207e7706d6c5f33ccbc88de17b79c216e10c813f02b9aa90a045fd32f05f2df5d4f6598e9872bcb4d867427462e68b523ad46998349a52a6ecb0d30b76b9a9d3157f69e5a54f8804753082fcb78943749af98717fae9253fbe22f68db40189420d50cbe172f5d34129d325afcedbf4c61a89ef96782db5d6fa8779ffc559093a8926086adf84e4cf29d7628da2d1749dd5b78a8808d235ae75afb22edf5a2b9b8bd9b426625878992a5fc760499967aa60fb7a892c1756319feae6d556ac93609fd24dc45fbff26c14cef046338d88ffcc99d36c4e2462a1ba05b3af567efbfe342651464388a4c3fb2ce55149e3464524badfcf88267acb2bebfa7ae369f77badf55ac7b398eef1be52f2678aaa9e06d49e11bebe00e8b8d4a57984a34ea39648a454a8bcae1fb23ef053ccf8f2a3da0626bf6c17b9f03257aa6235e22d218eff960ea7bfe46d38b1e104696c1b4bcfdddbde21788a789c9e1b41587b2906ce0d470d3334dc50d5ea53394de6195a279f772838ce9d3caa9ebc1080088f00fdc5a9e42ff734dd35c6339f7f54075509bcbe6453a3a2763b5b15a4c0e1293810f5bc56143a23652cf979d4c520fda7e6c7c7d2147c2e09f4f40cd25d0f85dcc493f124654fb629c7fc59e831767d872de84da5d454c77d3735d0e4f04854f96c5c1e49399e5933015fd0db793816e453833b4287f448a412e985c01fe1eae8e77029f0855ae73c870ba39a4be8eebd00be0b47e235ecc5f1cba709638dabbf296311b8a1e8dfa4de840aa49ef80e6aea520f2665ad863724b84cfbac09ef90c6c1d2a2c674b5e925bf5983abb2532b585227bb4a5686311e916d33ddf614c7633813186e814185c82d5fc1cc6c3affb75be9f6f2f3d8b977d961322b2d182d1e86824dc6e5fccb22d39e56dd4570d48ef97956b6fbd2203c42f46d60e16b2d0b2e6b0ac964ef4768c4214974f7fc554057d1244512b63c64b48e4b0a9e413c75cfa42e37bcfab02aa0847113feb0b2f7a6be6fe8b66f7ba0a8ed78465471e7d3b17e0a2ab7e7d226329e351c9b09bfe78e222069762af850672b900bd969be3df845cd0eacd99913d5dd020e44d2a442e654bee7ecb96261eebff25ac122f24b2b2065cf87ab1cd1c91","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
