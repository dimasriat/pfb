<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6f225c8990c259cbde34ba96791657f4949e285307008d6b6b6381124f09ae00a80124d511a347cb167eb279676a9046c9ab55ce008df2c2441e57c8b3a337f257dc0e98e7385a123beb0cd27219bcecd24e705ac5e00e913eab737e5f8b10b0bf0469d1a93ac4199712201c87af35585e90d8eaf2012e334ac5be666535f7224ba8a1a44852c6bc79ca904334b84725f25ced13cbae8e6860ede36540437b7d084ba7b7467e4c58a046104da62d7253d56b8ab779b2a129f5397d437b76cff448c3f18e29488a4a3033c7eb6f1d24599d1333879ba0a0426581b33c9e72f89b2f560f0da5b76a923894a31595900b12caf663e23966d46755e978423b410f6751d589f66b86cb7c4f83da6899d4a81c8b9b8626c1f31cc7eef8c36426b8bdadf135fca088558bc5757e0ceb8cb939b5292e04c930d62aa6be0cf4119de1a614f67f70c3d1794cc91aaf888a0acc43f6b9ae4eb6298c6ba1a28f43ab0ddad532b06bb71ddf978ee040665cf125852c37823df06c5348d3bf28094983921a3c64230f782e19da4eb5a5d0b56f75df8233809621ca339f50ae2ce77b293332167541cf14268cabb58a462e257006ab084eefc92143ed35c56de15c22d3795b7871603538cbceea727406ddd20355de79f511b16ac6ba83da1c87608055b179ece2ac1afd55db0a511068fb11846248e57c5cbec34ea4f4b5b81beb5c402d40967a603ef93a444cf8af804f51c383af574259ecce60672db9f477964589c1ed1d189fca62b75949a068c15cd68cd0148621dd0722cd20c292bf87c5d8f5810c44261348215ee327d02fd54f2bda88d08b6a8f36295a4f3895e78d1883f80b2c330ca6d735e00234ccd855a61c9fba9ed984fcc57a4419df16b117b84bfaf79c0660a2e2be5c78d7658d1992aca50e25b1bb82a7ebadc33a93efa335ee3b83ad5fe03ce3c2341eea8847da8bb229245db4bf1a21fd2ae829417c3c72e87b0ec09d377e78ecfccb9a2edfe24924d93b6ac757cd715ae6b0c1d061b94f753cbec9542b238b16208b09cf5ec1af289c5facb3855418c77655659a1e9b223f5ec4756eac5a8a4531a20bd2c9b0721cdf60889b4e920d21682988d7df10d4ff6a3979b624d3fc795d264ac9a78d32322e377abf1aef4a9b2fb09b55e7f21ed63cb1c4a5ae31c99d6d480f2ba713d7fbe81a1785267ef0158adb9a528eec0dcf49f8d489d213badeb3f1a0249a23da1d68ba38ae8c07a081fbdfb93d0a6f4ec385b85197e69e8aa2835f47cb43103153e268bbac0d13bcf247cadf01c653dd7cdbeaaad79944841b7ca07c2f9514803a02ed72a129a2edd465a8227c14dd1e0ef6b9cfde5fd4efc494d8131e88bfd8629d49cdd9d1722781d20aa296dd263359200a66fe627993acd37c55911e30f4e72378f5b0f14d2bf85fae29b12418fde90b6b6e71f2e5e093ee63d7e9ac0fefe59aa1f659df0f7ecc4c979645bed58b0c1800434722a056ce0996c86f7a25538a8f3a675f79085b4ef210f34bb32e9dce84014b0b880220ce1db73d19088872083219c702ae1ea846c7379cf566fa040bebe91065d2bb11b5b366864f131b47cbdafbbed012c3986c9e4a75e8a39acef54d8939272f63ed0bd5755a806daafc9879fd46c5eb55eca62b3ce12220ead87674c20e7df9f972c373ee5f78a7e27797ff288ae885419fe239b13a286e89292a01b8121846207e063f6e1d034aa2eb860115fee49ad0849fec5cf17a5478c4cc14287e7905e740a12b271dbb623e2e4b5a7930c42ae7fa0ec0b9cf500c2ab3d56a1d24143c3fe7abf382ae981aa5bd0e3f41f8ff0a0afaea4ed10bc2e3e9bbbb601649057807f4422f7a6127e71401d24c58210f15368934e7bc9af995bd794315bf6d5cfeae6d9ec07c255869391cb50ab846f75257400561f4c7b03cde99a048030b0d1d344ec7d69352527b4d5842788d654d79979304b0c548a2fed36b41e8b8519992249bd04af36fc5e7c33240dcf4a11a519e0e7930175cb94b761d218f68173330e4d331712c03e0dd5ae745b555c448687875ec8c4f273a333fd0a466f3ab1204fe4ab2deb87c0f9862b9943f9951933900bfc36f26dd039b4f7930dca5c84302761d9e3bcfa65b7761de88c74961a9b075c1ab1b7454fa7ccc1968270d1a8e6c7578f223b9979d7fc7e874b0ea9e4f80a31ad6d74a5e5dcd9c810123e4f5951750a0f075a325d688407d67c95b689a454659282bfa4cbdd38b460f8902af46837fb5c1d705431384273afb2ace47c954ef5b94d8557e07ad6531032310e2f288d7f526ca24c289714090fa10a84c936a016cff70e1323075c8a227aca2be4f77b30ed0a9d84cd5ca1f5e738b76df58bed80b0f986cbcd791c5a1619fdcbd6a233fa63d4a30351cdc455db625b21ca2e030510815279b01c4fba50150e26225817304301226a85b3d4fbcac6db0064c06db93a468a2e2e464f4c2be2483fd5245d85ecc33a33bafc5d96b00b39006867bcba31fce58feda4aa50c9e409bd99a7639090fdcfe502bd66b0b909e42baefb8158afcfd29598ee58ed4d5766b1b1121f1a35267d0165440025a2e684f8219598386b7a0b49a564cdbfc749e33a114a0b955a5cbbd51ad6cd0eb117906984d3471bda9e70005a4c9b039d5e1cf000cc7e221ad4725772705863dc8516acbee63b44783904ccee68e20b40f228d5e4c20e7e8a67e146d957d36649e2373df1657b309b4f7a41c9abdfbe9c38e5f6880c88af8ed24cbdcf08338cd1aff642b837da7ffbf1c5d3d774cadfe8083ddee6e2cbea6d96d3e5cbd16f19587ddb71a7b4d7b446ca0730914a2ac5af04da26c73e7b61388ab2b72763cb7573a3341a7412b29787ae0ae21df8408cec1f4d94dabb97f9aed503bfdec29ec2a95c0f25b4c05bd58b12556b92863870124db997dc562180d159dc9971d7a6439347911aaa13561b9bab8b20cc193b9e147710e936cb97ac467f619e0146570473d7e32f067bff7889da5cae01a54f6b5e961e38ffc95d23d2fdc8d8262b870ba18fe284008f0964bc0b308591f463a145602bb1197263b9deb7e6eccbe28822d8887454c2d935fdabb595443b65084d10613350b5029903cd8f572cb5043a9311d9c1cbb697490f42e2ab066fbdfa713ca9aa5163b99bb5f0d7a8cbd935cfeb7194f1777d5b4685b03d83d5f73306de4a1603d4e521af2ca25591f1568fd9c6b56911510d8ee6789016f22d3dd70bcd631190d8c2793dda392123f167dc599c62cd009cc51e2346eaeb84e5026ff3c0b64010cb176efc9acdf33df887549b129ecb4c09d62970f42b5049b8b7bc28d3f6fdba9b5bd94c7a3f49346e8822968623068ba752e4c2dac6dd93889cbee1ba17d85df7ff3b43971bae910533042102c1d9c1ef1777bdbbfcb291ca31189fcaebd6e71243d20a0c2d73f26870e79324e844222417543e1252883066ea9f3bbe67892fac72fddba2558aa406dbbe74eba75b404cdac9b45d21b2e7b345df0c096654f2d439ee2621396d3bdfafe6bc55891dac4eb6e07f1b35c275292b7086109efb900234932474b760fb9c782c4ae846b20e9ab5e140454d8ff59246d704b44fe65fcee51910b290bb90963616709c3446487215208f8d56d71331fbdc167474a33232591a15205cdfcd3d52fb01661aeb8d42c4e7be5f0323c789fee1a55a70de0339f0c81942ad230a66ef8ef6d695f1952f7cbd0064173edb67b397aaa991e4d1e874346c9eb003d7dd5eb697060374fc9154211e258e40ad429d842561d9be0246d7e24e0d68a20d5bd53d17ea5105f375568725bce15fd56baca1b730dcd555e99d2528aa51658a30807e9005a821ed424908b74e92a87f9a42cdcc00d0fcf29b64e7f5245dc377b48ff404966cff28b80ea6754605f0788d091320a847e517d853a148f488d2f828b534e935728aae72e01c5bdb5119d80a6757e8a3b69a94110c70c3625c499f0bccdcde9c9793f701d28f07ee7333eef0564a419fc2ff4b0ebec5fde5f4f53a1519cc02dc666801f75290e9db2a381aa6d7e1f11da455717d8458284159b6e96bf28513b3573c5344df6dd2f07ca44ae99100712f7e8491805a8300630470fda74212848b6ce4b3b581acd58e0a8f200bca54db298c8206fd6e76f884b032bd139979756114a26e63156aaf50875c5fef1e6fc2a48c01ceb75349647cbac93b723d440ffb78b329dd4fc2b64802fc24277db67b662702311e4429aca8dcdd6b479d86a1b728371161677ea2d166af1e3bc93f7cf21cf11d9df7404878d19473cee17eb4a6ac07fd52f242db3b3e34f61614a01397ff8d7275124ae9732784956e3bc4dd20b7834e8e4236de6962e92cfd6a9efffcbb8086abc5f60f61a0893d39cc8b346904deaea59c9624cef77a6e47b49ca9f2adc674b708fb99c0ad7ca46ffad9c811324b23493e6c5e920065ef8877ec06d0f24d036600eaee3418a0fe5b1e22efd775ae926ae2990a33adcc0bc821ba7a88eb6c63de0e57c4f1e0e258c77ca45ab67ce20eb4a30da3b6fef2bfbe60035ee7c92eb58077968d72c8d77cf3d96620074775e04a6290c1a089797b2f2b0d78490b93abe9b607924223c5d37a5b93ca9702b2fdccd6618a929994e7c4559ec46e9fa0e9de2e241bcf9ccf570c9118a380b17ab1d5aef99b72daa0a180a507d590ee2b7d74652ab5e51c715e9cb793abe93a63713bd393026eaa34be9510f79ecb91d98a9bbbe92314aa5861023823b45c0a37f4f044d786cc811ae55fead4f747d85419c38d1d5ecebeafac9b2f813be020a4b5a4fc3cf9a97fe9ec061af34eca5803e41eb16f4283f4543761109e021d4b5b68ae9d3f21f8c6be81059ba928664b401147213d171f288550ee16f49d6e513c04d82caffd484bde40ee9e3bef85a2bbf00aa980832a2c7e1af955f31610f5b97308f98041d04b20217509fe21d15a68f98f7e799ed34a61032c1053fd0a4cfac72478d1c108a6ef2c3aace1a1e307fc5f6a14d4a1718b4b8ffcdaf955626d1690e4b65a9bd97da92c835adfde64fc3b339a97a314ac3623beba04649558b9d7745b921557cc6adea40c06265376c5a336711831fd2dea882b1a60172b3ecb04e565fb161f2fadc7a964a0cbc586495cf1956b6e197ba13c54f6d1587945ba487b64f803df236c0f5631ca66b61874047f24b5d084737d523f542e7c8fbd06b206b7aa074216ce4e0ab6e6d00cc812c6a9cb8d3d70696166fcc20a3d9afa51f8c81d810db6aea03d490a2b6391dab980ced0fd78a8426c50f13fc0301e0c70d9c473085f142634fe05a2b244de07545c34e492cedd1851db0819497c96e61cbb708545a7291f3bcca1a0bd584587e26a105796570e46f65cf4f9ed5def7c699d0e0789fce6b9e83c0ada35ef90629c4c431200179f001b242e3c80dfc4a8bb98cbc4d38d2a55309b770b0211d633d0cadbcf32b9281eb13da59e3120d44ed90f3bc8b9c2792c31831a83a315db65d4575127a8fe3a384538f4cd83a3ddbfa79e84c4e9a7c0a83636254738b0d1cefdd7cf3a28a89563544b4b3d967b95768550547073d308eb5a60227eb99347d02d2f5fad63885d89c474a5969ab59f78a60fcd9f361cb1c3f6654e90df4bb6627a191802ea1af14b5dd8187ca000c539cd3b9abc73f00a986a2325838a785e3e9935fc946e78de3b3d298e5905c2c8586a5cd2eb40aaff6f6c8f33f40ee21e3c334c21385a76397c906aa6b9b25d40701513f670bc4fcf247a300a7808fe2be5db63c7623db7cbc13decc2c341016dbe4cf01bd15760079257dcc2cdcd8f2685645b314a0d6e3afdd9b67fff8aa9ea5bdbc938d9130d8b7ff7d0f47f7876aeb958804e1204f48b0c566a33583ff6f919cfbf831eee121aa22511c40508d5673de0da1474e17a54317972755dfa16d5524ab019714a8ea6011aaec779986c0dabf0b53d037d3e9b30f13c44fe577cc28bcdda47abde3437f09c1db6d6c10b18c5cf28af6c81979f0366e552d9ec8357721d7aabc7bbf55cfd00991897885262683e2ca37079d098e613f9b464d710b665432e9b9193f9ebbed05315badfc04334e6814fda4ae2959c8ce4ef452118c899463dfb7197df1f7248826a972f8c94a9b6137360ff3a886c9b7048a81bf5e4856fc96044f7a80d9b0c867d0cfa1022e46b01eb3d1507e34f9f1cf6bd94b7b5fabbb91293e6f7cb3b591273247cbbc6e68ea73ea42301cfcdbad1085718790a8af2706d42251f196fbfdf43bf6bf815657edbfed9e565c41003fcd8a59a997c25840422fcfa5d6309874edcf54267fd21bc6f6ca8722568322d84a5546a003f6d7f04538d40ef23aa8ec57fa81e653f2083bc6c98306805a8997a54e8cb52a649533d0c964382ec0e7017abdb5832b7644135f236ac6d92527726d763b2bc6a9b6ca9dd5ed2408b0a341c3a99b09f98dae0ef36cf3c146d865de217e43664a419ac44d5de501d78ebca4803a77b8d986b56574ab4756d1f016f3da085dc4550a046d83c0d11d7298cdb8655eaeac70078ddd84cb798c71a2e7e2d25b8697470c273d5c7f17b1f0059f0f4547c5b2e9df266537a5eca4f64b956929db1ff3a9d6d604f81cbd4967a53d2bbb3e9c0c3fed7a2bfbf76be79bb3dde0c19c0a9175e09a275898eec79e82f6a24d9453ed4908457b2b2b3e605414035ca2d686ef4199786517a9e22f8e60ee27128f215d8842ddf7d8557a7b9bd83fcbeb0d1d44ceb20003d39219a3a3ba16605a73ab90573f01ebfcbcc17c372cd25474cef6e428625a59c3f0ffec2bf25b7c2d8330cfe2f50690419d8871a146260fb6eb92418ca2f061864d422692a03ab46015662c7520c6bd47725662493851e149bf6deabddac8fb282acadb9d5d63cd847bd6fe4554634d5874335152184b4b435a6988c40c02bd54a466cd36c3063b01326f6fe723a9cec56192c32a623aeda2a0671b44453e5d0609c4090c82cec2350cda176e4a53346624e833219db1e2449d96ea3ad9da39c3bc48aa8fda5f42a9a86d9b1a1ce677a5a588c7b5d8587ab1aebe21221dc49bae19b742728c4fb8a622f9aec54217d40c7a339af3406c8684e0905fbb8e26fc2ff587fd630af538e4eeddc52168c9e33898a41aa4a49b34c2d52494080f1368b11e8865edbe92e23e127e3f2f97718b09c06cf56b45e5a52a204bcb2fa00d5c6b9848f9f7e298a503a73ee1242235e1997273795fd514d2b0ae8974d215a59e9e70a4e3d16ba0c19f657e4a2864605ca595de522db3ae9020869c90383bd1386d816ae8b98f36ca401401b900b1a432df05679887cd6c65aac569d077fb26c21ee9bb3db68320af41225cae27791b5a585e8f6a83421c9d0d4297e19438d705fca0939bf14a120d7c048c1a7325550d0969274a4242a2f71c8523531b96487a4804152a7cf54265c2addeaea2aa92392198ce6ba10fead5255ad614b76ad086a9b00511acd99bc8c9fa6485a3ffe2f2c8d38835aa4b7a3eccbad0990931db63ca5ce6b1b74674bfa84f79088a71e00c8598296cf6d553ec875ccbade5a94e3bdeb6a885d0007b9726d56dfb13f63f7b8a97680d5c8becb1661aef15f1e3c4269d013c31d4f5300abef27d8b27c4f9b4ede5ee1f4334d9ffd09fca51ad7ec63f5b2a45b358cc966b6ec13471c2a3831482ee0b28a91e865a98d8cd40f4f162e1e7dd6361ffdb6a67ecb7baeb745e292319b7c4c44de9c14cb59f629cc4ab0c5e06c99f6dc329e130ebb6f240f73d4c53a246fef0da511759afe06da90d2fe47caec56964897b5850e4dfe83ce59f1be1b628507fcbd4243981315fbbbeb3d1d5d21780fef8f1493d14678fbe20a535f289ef6eea86621e22fdcd8641124bb81db416b7b8ecaba58621a3ae355634df6aebd3040534e4600606c542c679085913cd281ecbece294bcf069182e34569f61ca5204eac339d03bfc4be8dacf1dab6fdadbb183980dfcdd7d6ccd838adae95ae774c845d0ff9eacdbf8693b8c0bb61399b3b79f1e948924b01c732b2aa4f55e797973e1a886fcee76481e0c3383fae186efa773f1aa33e5d6d0004a0c004f7525da4d781418b29a46d9a0f28c9eb16c46c7a456e8da9ed4b2e9c7bfb84addc93c88bc094e35c4fa3860af1131baf5d696b16601b59b666fe29c2246f262dcb75e80c6e60df1f73afac1270e761f4253215978b5d45e54af5da1988f1c1577e022e767e9802c0efb703e826018e0b0c8c4215121998b7c9e787d74a571681e7f226579ed601eeae8c1512ee3e90349988e886c23919453211ae4034f8bd5a94283dd96f153fa7ccd7f3fef7e579dd278513901d4f9b53c8126163ec4e77161e6275c1c86d3501c153539843ecab5bfbc97a419ac0df18b0c277e44a6a904ef402231e997fd541de6d170c5e52979e2c992a8f5fb25a613c7b94b86c32ac75af33992b5bf5622b3e6f7e1c5fbe312cd9e2c8ea5aa65c89e7240421d2bc749a730b4a89d3734618540fe115b16cd1bc7eeb3f80e17f59fb77cb504cb8cd2bf99d6979e535ed832816e3bf0096a2db0b0837d35996332e333c2b881f1e38654643bc0941768f204b8f35e436f2713e6c9b5b9db149edd795394280ad68cc116727b3c9973ce49464abfa46045efefbdf930efab03ab76fd45bd9c55704b30caf6153b1cb63dcb91226698000ffb02ad3580686f17624c017cc427a91050fa16b165e049a99b5fce544fcd8db67b48c663a9a1e6624baec455ca84c262acec94a14b945e5b381f5525bd71f7b9f9be420882ab6da48a018c35c73e7a0480dd77ed7c0760a87ebe647cfc0dbe302092f648ae688266612a64dc571cbe7759aa5e1ca3c18a118a5cb0a1c2078fce91ed9fc90e3c13654bd06dced9283c7d120289da64207e58bd6e458605cd22baa03cbbfccde98d4ff7bdbf1c038dd5bec09395a2d7994465f36fce9768beff9d16f6dd11ae40c5d68795b7d4099c437d63d16df2bef19dd6de964918f229a0b01287ea96057bdb062d534b213557e8bca01bb2e8e0a0385e193178fc93dc5997730fb429907b4de95f8592615b6895fd2edcd1d531fd9c4f5ffcc1c44f5534fc80687a482559c13c94335bb878cfcd17e1b1e08f7fe072c3eab09dfd7a693ac45be2dfb28ac6732b7457aa8aae3ba25255a95c8048156f3937a","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
