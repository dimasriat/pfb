<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1efa4046a49b11f99c1b323a4913f5a123f0f36426af9030cbe586f313f5c7d15e8e766cda827f2312d31839555231c5b147bff940d1966c0e3c43073e2f8e455fcac013dbaf6e0a69ad0bf059209c162d67b594e3a3ca44085c1327c9f77fa0a0246624e6ff0b29ef9776077b47364ee2b30056114bd90bf8aa6f96d3d18aa134e7acb75d4f06e666d7329bb8086b4baa170917650a6743c5fea4120330892be4bc7ebf0ce12bcc610bbf73e1db5c15cd275ed6cbd112676450f21f9cc5edaf8c4cc34ddd0643d978e9539cb1acacf385b72fc3c8c718af84aef083332028be6597737fc1abc98feeb1f8ab6bdefb2a492bb467915cf5b433ad81369359af7cd484c6972e39a83710bfb5bcbb503fde262b6f02bd35d362c483836e5b9299aeacf3a5a0a59a0dd2246cdf2fab9d5292364f446a952ec108fbc86d6fbdbbfb47b800af128ec8ff6c8d1da7a264c4c412f1c5e942cf2021d66640b63afc0dd6b2ff6b1b3f0920deef06e02ab8a38ff7e7eb7bb3adec7cc628b7c347654eda58158eb8241177e623d45c681270fb581b606b65f6891e4589bbb2af6215097cc73664d810d6124422832c0c54717446b45cbfbaf89a7eea4e42eeeef01547492e91964b6930a0b978072dd7b2e2da95d5f714f25c6dbf62bb000882ae3de2cfc0338fcb4b83bb0d7002a5137ee92f8d94fc850af7dea63e1837fbfd033084cb110616b38f20e6ca15babae2d2a244bc6898dd132a30251834f7643f8eb45b39bc98b67961af03784bb34bcc7f1c5537bf1227b1b3013598a14515891b611196e9a8e2ea26b39b58b700c11dcb414bd21dfaae6b31cdb59c08cde0aa2686480e9ececdcadd3aeeb474f11bb7b179a09b150ab67d5b8b79f453ed29605f2c654195a4962929f74d616006fa2a0475a83da2d3c6b64d763121975932d08984ab005a7a01e4e337a8747d60ed4bfea3f7aa35d5c439156cde56ddd2372b33c18c55ab4db97efb0dc52f4cf2d5e1a35dc1777dc84a0552ec574f5f9a412d97f653cc23c281941c5e792a4527838c322c7031846bd9addab82d6121f3821606ed1694f16d098a593432f990d98be44e6cf7d0b059209f898e9c4a5a68899244026f732851e19d2180aff3f4da5f4bb04397f56678b1450d9d4d07075a9a6ad18c7a778df0ff179880625a74165e2fa9066a423b6b5a9a9319151b98a3675a41e94f993fe319593bc6d1a123883a8cf5f26fee0e8fb02133defae7dbd0f0f918261ca17cf9cebf0e6aa55802537f6b27557d794bf249072773c239b1e2492d41731eaae6c34128929588e7df845ecdbe001628b5356806a7d52a69f4a0e1f10357c23227fa3fc79d66307e875c1aa0fb13706513d8bfe6f3d748ab3dd40f782797652f8c44b4b3c51be3e64c7b7a0c4002c02643696b176ba3508cc0888cce3f7e9d63cf3f4369c0f86fd02611b1f8d3210b4b1f8abd31b0792fc9266169926c8e8791610453211bb51ed4ebe6c6d4955386b9b298c84dbb55806b84dfd6c06c6c4123d6aed789971bb4959bd697e510740d1520fe0a354594a0dc88b406c4515e0e2d347155ec09c71e7131f5006f739406dde589ba6ee1ae7c55c0f51f23ac5a3eb2820a078f0c78fa85930b8a7cf40b2abba8a2294b8b6ff9710cb0fbef5ec8c5ef8418081fbcec0d1c6f8443f05646224128e6bc14d4e46c6144014f58551ec9b2114723c368746e28c4ddbadab2a376f59f2bc9edea2e48e2470a5bdd2805f94d24482679dc564ebca2340c0ad9b49a4075148fe1bbb6e2869d0dcb2fa69dcf3c728676d21f01acd3a8a6221e145c15c92e20f6dfdefa01633ccd0bfb6d10a6bbffacba5f84e20e62de6453460dfb340712677ac033aa1bf4fc010f19d3316e9a8cf64ec103727c7442a83ee36101214939eed3546b136c08a4736f9e4e38d4fb820751f3f70d145faa0229c5f2ea7a6a13e12dcc54c6d0ef0a250217d74d66d84f5169ed6762f8d55a49ba4b2a66aad57464911e104501b328f3178bd0fd3636985bb580182bd02a851783f39e0db2e4543320427578d03535e58d069c83fa4cdbd0ed76fa7360b5d626864f1ee30719e2db68a019aacb6684d35e624bd5fdb6e0df6140b5be066ffb2880ce679444e70d8e95e1dc4d555be9e0e368e8b184cc385b4774dd063ee2cf39911f6a1ebda7f4ac0f2fab1a9ac5f1b31c21529ed8d9987a74639a755c2e42fac51bb06386a62945261f61fb132b727bfc04a9024e654c97afb5976781f95e9d3cce37a9cd8c9a38e0434fa070897fe0f5b276cdd97f88c7f2a110b1505303a0f4269354fcdf6e347655a42c810566b049594f710b3a96f88750ef308f5c4e0f11069dc56e47ba0e84f02be40494e6f8a918a0910c84651eef260980ffb980bb6746b36c3353df58066955899f80f08fbcf54cefafb34a3da6549c43c42085487dcde378145c908c7bc8706f204f214b2366bea5f14bdc70a54c6fc90b7bd432a7769968cf9e497432b9d41cd12cbbe36685b6366647cb28d786389e3f53896f80afa111bce51e8543e7906dcbf8afebbc7122cdd658a948cff2b7ab394402879aec8acf270f202931e17dfe6e398e51ad951bb9f311d6026d223b3db9f5dbb6344189dbc57baff3311db84a2374cff9a5501fa88c7960cd525b11cba1c93d2e5c839154d2cb1698663435c8e29d8682c7891d902f1a85e024b5a20bb66b32b04db176ad77a2f05c6abd2dea40048593bf5d7dc34786b4e34c60b6e023502b284e8ccc378adb68e0402f31c5b51997c5002eacc0c6f21a185be30d99d671d58e33e671e2d99e448b0c6ab51a373787b742e27a0fe73216bb6dcfe2802656225a8ce7c74999d7cf9bbeb00d1f2087d5449dd931798c2c17f188b8ccfef9671166ef81c36fb3b72b626c3f89c7508a9109cf9855b2cafc4713cc61aa031d05f3ab9633aaf568f8ade42be4f5a0256c31a9cccd9f93615ac818d087e60f87bdea06866ac56a731f62d2568abd6025075d50bd9266f538f7323dc26c646325bc4b4285e779daad82f7af8682a91813125334c41f7b33a5383c2c950d7f4af76ee0a9ca090b2cea59cdf2d941ecee81032fa1630489ca45fc7a7e5f86ea1bb0f07092154e7605cde808dc97f69c53f344660b83274e0a9654e84add1df6810bb0a6247a3cdf5a0f04c10fc493987635d79ad212007d7a23b27726f0208726df35ff9df6d92de9bba50e716c013f299ea0fa7c7cca84a52389722caf960a5a8c17bc539fc4edde84e68af0942116fd73aa498f6e021862405565d7581d6a8e5d97f4aad0c0f9f7402ac5d109c285f73e621bb8360f5f9dfb43312de4c656fa7ba17074086ec83a5c8e133ab17f1061f3a3c9d229fa71e8e4d20e49b716750fe33617de45a4cce7660a5e4fd457e5bc990d6fa9fc4c500bd21d5285586b91eb83acb828ea5cb4231828a960e909303a84fc9f49bf6f1d06a4aa93a71a82789434c6e276b0772303f844dd2770e290423f9b1321aea8e23b1bb0d5593006e66a63cb9df2c10394b2fefe750603384b7f4842554a5f80a66759ca53c8197a2fe67ec4d042fa9279b4779bb0bf68640ab04ea25b2902ffd42e20d2cd6349d217f7a614be9212a77bfa6d38c5335e4694ea944d35b5de8f1909d406339e1b70f424ecde233fb0ea1737ce150a891951defc7ae5a5512e4c710bf4e9e2a124ddef3472531182b19f6cfbed22c509c81b56f5bb9d84e9074002f329c67b16abf53cf98cbadcbdd4038af46551d8ee5acb253a0d88d556e19e8c1d256693554420bce636d42fca70ac4babe94b68ed004d5923edc0fc5870598d9fb9d9698afe0919a8767b9c70ba464f19f098a6d9176125cd42bad5cd2e47060804e1b7f5f57bc7bdc23c0f5f86409736f2e6ebb84b9905eab1c095897144e2fde441a052d2f4ab51df23b3f43618be462c88f3d27241ea697346280a3c7dacf9680dc4cb03b49ef27473c59c3c0dee8d3cbb96f5ce96ceb4ff99358723cece19cb29eaf7818f7c8097cb7c24bdd869ed7dfc47e0144e0e6ee636619391e4915f3e37e621a9b3a277b42e591c083afe37f5292b8a757f691ad983e6b240dc7e3721b5cc3da653897eef5c1bb111ce14412028608f119a2d03cad35b478d64eff6e6fabaca399071035809dbc93f9176e1b9c83914e17823b0f26ffbbca5758ff00250b98d1ef1dc5f7ca5c1037dfee8bda9439cb25c07934dc6e022bc8f3db8ad0d75a0770be3acc88f4e215bbd7778db682ffa5fcce5c5ec01aec01e875442e94b10a3c749c5c58f6e9b2a31a99ab07da8d1030610b908d8fd397ad57146ecebd2dc0480b82ba57b3a1b66fbcb670f1bfdaad9bf262150a13207a6ca16ff0d57609f305eb2ef13b156a1e42c6c425af87e3f6250e7a25874a5dfc9de3379fe35ac2b6796d62c8253c8c6a9fbb1bf0e3749011e71d79e52c030c41b30471aae2d0886e827f279da1e2e1cde8dad9a194dffb038e8b9f5ff92e498f68176e1e4814b96e33e1d0dd0add32573735e99a5b97b9b4e0a3595565d5b8af59187d319a0b549e31e0f4d6ace0b89eb158d5a532c9727a58df170cf7c743bde333f89924b2299da56db8781a2a5b5f8691fee3d34484448b7e3a31b31e77be1d233e761a6c2186489dedf52b1d259a6e0880800ca8a440b3f7a022cfbb3a24e524b7a8a613259181e087f1b800f3fb7b8f83cf7ca89323f9826844c68c06c65b05d11cd6f1940049ddc11f2a6b9219139c9d7dc9e440168df0447ca7548e3185a7247c1c9561fcce1a7e6cf1ea5e4b78ad4bf0e1e8d09fc4685636d21bcfbc7aedae210bfe54892f83a3532954910b12d797c05361d7250c29307641f75b6fa7aa17087a2b7bd15255cd0e3dd525c0e12847d8ab0a6d165bce21deb55b017a4e1c2669424f697910fa9267648859d4515b7dd0574072b21c395589f8f0bc37126ecc193b2342fbc6abe7a6c25e527bae012f5f8f695315c3dfcc491895ad9156fabf0b327d2a047efe7fdc39f6e5aa69457eb51226ca9ace69cacd33f6717877ba110555e50b37d7e156c17130d25c76957748f3d3671a68e2b6ce6082bd09b321af9373449a4eb3fd45bcf0abe249bb5330850db02a4a6e60b2838653f885c302e957821fc1c967eca7bd5840528527eb7bba4f4915e312c46e8bb4a18614a2cdec545054af23a6867d6e6ebf291a14f2139a3565e5c63afef9a686c71d093a91e25e9d86b36f5abf9858d7d215411d9f60486c1f52bbe070dd23ac642f4f8a6a11df952967cf0ca2f9452d794c9dc8c9d61e674d03df2630619c0679667fe8e087336e8fe9b8b4698638bd6424f0123d6bfcaaf7bf604845b0e0ef9d57d8160b6eaec120935b35663e11ba557d729c2b3cfaae123f03401ebaca10060f3bb018f447506efb393885ff601ce3524f1c423f825d18dde8c1fa19ac39db45b77994d1da26f3a879d48d7631a158d3c15c7debab8541bf4f2be3d5ddad50b18d21431a12617ddc632fe28e0a190a03b7953cfe6d3b9480a0e1ddda20f3f3f345ae3a885e8bf73a64779a022e46c07526f3cb9297f97eea1591940af3e01dfaef26600dfacc218b074f6e5cb9a916977913ce816077ed3b6f73b83e45f007cea189ce168cb84de0df65fb3b986f400688b4ebbc9c30f187c2666934c6014122abfcf388acc3d146d76bd32a8cf01501ccb036b9f0f4d817e646f79567627f06df9a61a1990041be271c71da999de5a1bea483c5881192577f4e4866497ed8ee0fca5c34e904935cdf791a8e53c9b16b9cb44dfbe20f0c24516f1aeb25e94468526cde6d6c2d6685e66a945a4cae6601790ca5883ead5bfef124f4e1d87da2acbc6f7e7cceb72a23537cdabb15b630cd5fb20789a96abffdb2828265f8228c136709fea8dd4e6458ef83ad729bd35064bf1c73d71ab895881bc05058107efe461fc2cdd766bb654922fcb5d031f99d5c442693b934ce7a83146fcbcbbcfee8fb8122965bb50d6b4fd716f8065bdaa707b9a8c7bd00b01ae9e2be3a63a384ba82cd14f377c31ee2375c4aeb1126879330610bd17a51ba65dbce1191aa4610eb1594e39696fe88e769c2c41555cc55f7006d4f3f44b5524303f8baf2733893c79c1ca197c071dacce43a785c27060958ad8f81ea10bf69a3bcd9bb73a46960c0d81d2a95e496692fc3691c3883a10bfc2af6970b73c88aab8c0eb792a9b39a503548820831dfc57f486c42beb0d4bb86b26810effff96703039bfa285c8d82f575351ce9422bb3702eaf628821ee023438de13802be82addf5d2a04261541ab9f55b1719e51690780f2370b3b096186d5818be2551a34e72838a2626970e57fe0446e2622a0c05cbd9b19fa5777f61ef01d7cffcfdceee6afe785c2d65f3652284f7162c17881bff6f561899aac4fa67ca55875278660436dfa8cc4e30e7c3fb90d1f3ef89988916ba792d460480bc9211f93c765ba6a3a409a8147534b7b72c83b72126d051332ea697a1de69818964b81c816ed290fa49114621e3aef7d2eeede88eaa73ff22e4ecc4c2d761019c5d6b3caa1102f4a08afd662a948b6219d502143bfc8354b8fc3aa35a54c340ae0158c23650bcc03ba15b7b66721ee08bfc7a4e2f1974479b7b1512179213d405bf9f56f3e4ed61d8a69a6354c0138cc5e0f403737b0bd854e46641ec8626a0e44b329552e8ec8b47889c0b167ee7a5b2dd8a3fc770bfcb983c46d58b33f75e9fbdc297470cc10cf2d6ea59c4986c187c28fc831c1208df4d758b75245e95473aa06cd09f5b19a573ede6c007c0c13526a80c9202a3b00cb82a80df88f934e0de5c6cbc78f0f8d3970bd67b47536f2e0189ecee14f3efb3065e406302220e2af2ffb96e557805a28a4b396a7fb48f7cc124d76cbcb350421630e970d3d7d7f5c5ffbae73c637ec589bba8b6f752d5d8e4849497ebfa055bb74705972f7a267894a1914a5a61155516d44e9290486dee7c2b957f93c0dfd29da7e45daa091f0bae775eeb2229479ab1d6318ad714535456859fe3324bd946ae31d4d6ddbf797355761acfa9c7fa0d18268a6f66a6cbda29bf934fa5f48d4e4254a86f8fcb36fc7a6ffc48c771be9e98fea3ab09c5b6b93f17aee7c334a928061770aa3a632d17fe7a9bc0f2a079aa4e3eaafd97308d08ec6da4b5eea891d627373c222d67cae099ff8d1b0d8ce24a041a9d927734ce784beede35d59dc3fa9e3e2bd4e87d0b1e3d606a1936397c56d10b228dc7bdbe81f88b3a454cea862dc03d8cde7d09b4de1149eaf39b21ccba634dd8a014a9d196a6f6405b81629a905a5c00e9d2f19060cfe92e6e038cebf07fe0ab671ab25ee969e4b5028abdc84451026fb022a5d95538665abd22ad0a7e6379e70f2b70b06b011a5da747728c47836fed861fd245f13017c2b33b338571c9d10cd5361b3ebeb73b4b5d97ddaf749358b0364db155743c3405eb0359d1a718612fecb986d7fc5b7fba6633d7c4850822a8c6bf06875516f0324adc8b2c5bf224f9b7577e7d1b110ef20920c0db02b94c163d0724b254e4b1d60861a8557ac27aba124b0e542cfb4c1d2c5fafc2af897f1a42b7f18a47ef6956a6bc31024268128a4472999f404daed44c34cc750536c0462b890b05767485101391d53f36bbef3c3ffc6d61bbc19662544ad28a5519442845274d4f5aebdd166b287b13a70296ba4cbfd47245854dfd9e96b6a44d5c14cb127165cf136749189e7903d878ec5b4e1b5bd75c76be5372f42edd617ff02e9b230fc90ae375be41b405e0d7ecdbd3479dc21fa33a30a6c96f0a4ffea3d9caa5fbdeb2c83514865c88f4c04c0c47bb41d459efa79b7f9b06beec26e2cd601a71c8fc251a8ff738b53343ee542acbe40ea061c58f16cb379e38f407eb2449321c692cc880ac93e8cb07590ae1ac97098389f975a99aa30a8a2880314c9c699d193107266e9c453f21e5350906da3e06fe8dc017e872a529a2c485f778ef65cb74256a62056ee3f45ac429cd8169c91e93bd6cc8a134e4be80ad5916bf3c2ae35a844b47cde6a40b6a656172f33fab40b934257ad037d77cff9df866459022434a7b7c1435c1acc2a74fab7ee11b86431fc7c8118a1d7bbbbe08049078ca87daf335b1a9c1ed363300ab47fa069d20ad23dbbc6b9a2ef2df575d44dc9d2734adeba13121a26fc20331163d9db024f42b17e699fb5aa316da8be7f28622c1ca0073113e2f071f328655e72e7940d1ac4641a19d6cc0487e437f451c251b3208c1ce2292d074fc4818a5359da11c127b22cf758fd40a0b4f987df506163d9a726b57514c9b8a5823d69f2dcaa283228ca58d277e86d8fc4e6c521f216705876a78f41d027ab5f357faa5c0138f9663820cfb009ca993af5185b443a28345b9db985a37cbaba3ac4f61bd4c95efdf0082d1b34146da920737d73598da3d7f07d230e990097430c256b3f9bc8b6a84f0c490e2ef58ac35cda3227bc4e1bbd4b8bd5e9c0e5d39fd57dfb2398d219f9114707421bda58c326212c19cd49c6cac4eb6125736005bebf6b7eb1ec3c16bc520ab036efbf24b1f6198bcec74c8d79316ff680c03d2644cc9599ef9b78d3ee6ddf5c28864e7cb65888d0533593e8f79b145e74f5331d0fa21b203797cd694641b62c99fe0d928c651d4b04364c56442d676f4903f2a758ea0bda0c48c513d1d4728e7b72e279921ac824f61de5501b7969b14b20a35bf962ecf34ec087a6e415c5f8c060496113997d774d0193a775a95a7db04a5c4248a8e0a1ab44f0cdf435a1fda670ae67991707fcf4ecfe35a0f1c355daff3dfcb7ec248d4d9977935e62bcafb369bb1962cef820ba5d2fe2d4a43855f479f07d31869b2fbef3cfc774866f204643c5ed37465aced6d2b645e9f307d2d2884de47fc0947123d7d67fe6baf4c46af9ebf15c9c9ab3eaee2948f7acd73bb1c6d4634627671e1052a7c12c01af49a0b8fce865b5064767b05061d1f3e17e3eca34f780e5d4ef3bdbc82de04e128fd06ae2039c34469797dcf948ca8e6b39575987036af750732c19042d9d13c346401f03a1e9f393c371d7efd82b048467e90df1385920f5d0965adf1a8f4288d0394c0724415722eb0d29b0bf3fc6a62115c56430acb707cb7e2a7cdb124893e9e7a559dc7bb06139dbab9419326ecdadde20cbc","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
