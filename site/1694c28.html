<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d51b116f3e6b4a082c242282d9cba152bae3ac8cc5ab127a409a9f33597be9681729a8888757850e5d8be57726527288d33d98494eff69e3909d30c2f6cc1d665e574b5ce878f8b80f3aa605fc3d198f9ec00a92b431239d9177d62d681f1b1e448aa5c608da58f4eeea82ac4cdd229d6482aed523a959545fe087ade50cdf439ec3d78d6213947d00732ad64d2c9feb55e0102518e9690eb715aa33777ffa0507d16ab55e1e07b4ea397d8c3c3500100f4300ad88cc84fff385a0ebf3b714c347f8ac4d9613b74ea7316896164cca0f92b3497e8f3cd76363e1f6354e96b519ec3e97d25003e3dabc80428b1c1849e64ed0c86010af54c70492c5a2bfff54a7f0cd2db42d8d69a45c5d5aaa944d0b7b9a37e9796716dbc10f7160978f767866cc1f73781c6c268f0458134dc352418314610d292cb0ee781798cc5902d9b647b252ecf69b48dae0a2ec83dd97be9b5f0b3e692f82a76c8a40053c384f0ed0543cb6c0b77ca53a5df71ff78771a18daca4e31f0eedcffae0e6c9264d2d5eca9a82a4ed363af1dc17c74793fd4a015350e8fe27785048cda47dc3d967ec1caba114973a4204bc1e9552324668ffac462245771d3c2bed06efee28680204fa8ff7032494f3ad8679d6814fe89f82fe6c1268ee524364aa25927daedbe61f278962d3038c4d38422f102daeaa8de0cd18d40d5361790c31be27d1e6f2e81ccb0d8c134c60014ab613ac8ff39f84f60d8ade47cff4e889d3c2afeea2ebb36ab863efc73f02c2d480fe0874fa51d98337e880b0f6e1d326765f4c08063741577f4942747f2aa50c2f49238728167c4e09fd1e9d1ae864c06a19cdc9b4c12a2becbdd982c7c77cdca56e17c3deb855cfe9fbdf6b22f1c66945200ebd8908aa995713158aa3bf983d70987ee02f2ab496e62cd58360dc1459040ca8e336eb5539e94e80a022e770f96165d8e32247cf3a7c06f9657fdc256c33e0587bbae567113deebe011763043ee26d4d258779db9f979a7ab737951fb800dbd6d13b9db87455c9b0232931069b470f5b184dd14f5a4d0f47f31eb52cb9a5ec6810923fe5b7fb5b835b945d946d33e2e0de7f6bd7514a1d3908d5b1de4889aa7f17a41441509fe64fc431c40e71eaeb147e52acb8d701a4f9096e2c07fc69d8df8c26dc1b4595cf139ab148766af60da84cbca9f0982e9f016c81368d0f9429be0007b69b131d384f0b81494b4b09df5d6c63af0005a535a355ce0389b03f93a09ba38009c07633685da3115340668fb1dad68a5f32114650839aaa73f0c53210c745a64a541bd0fdd3b8d646b123848010fa0c37a95fe32177e4a4fe20cd776456e3c6c30f4dd351afaa90175050cca6590ac4fc23db5b5088fe2178f46f93ab4319c04bffc8910c14631b411ad7377286216be2677d6e0bc7fe6f4fa4efde9fb28ed0d1adcf5c1dab7762e0ad4eb6f3f1dee9d9261e7ad9e7c9effc4d3f04c2c9ec082d1deffe8bb568675030a0aec1b42a3bfa3625eb79b71dc1e0a6f7ec2ae1301c65984df79195d8b1eff91a6dde835cc426c002214144b7d91ba8f42cace8f20e6a7f765de65f01143cc0195521a9e5b5197808c007ec714ca0ba26fff0e883855b88d60947ea51e76d06ce6e8e957663385929ae017ec61a7f3a3258b1f285319f6b0f452e13aaf791ff5723bd584ee08cd132d234f07ad22d9628452594febe626ebd4b2660b9838d54b7147525f6f8ec5dcca4c61c30b6f2a6db9937795ecdc2949736325ca430f3969dbb8d979c1c3284d3ec56ad40d8d8389214acb0ddf49eae9b9c8585385df0d5b11ada37a23d71f751e6c8268a4c292afac3fc28f171a8d0bc932d9fb5cc4fa909bc30435fe433c42849ce9ce6fb41a43a1a8dbfaa7c7733ddfe2bdff9a479b00f66f979fddbf6dd1c6b76b30c8fceed4737e36ae2ae484c24cdc9f44c832ae40708598d91ccb092eaa245303e6db6056f3573f466414955c1ab1bb4f74a052c1b501dc753058ccef349c507c2c95d59a2a24f94d98257ecbafbb42dbd5b30c5899c0d80f4142bee8cd6f43124e0a145b91c4dae12285b7c220ca6817c0c8be0dac7a5f53ab0a14af07fda7eb88e23484b312e8baf69a375c835c295684cd6a4bff075a66f64e3342d00d5e76fcd767e63696527b334ff3c6cc6b8a4ae8d250acfe6fbb49116a0ae37689a88a281722d585e31b95bb79d14239e941ecd959b488822299e2f0e5aa57a165eff027f2ad10ec65af06eb5eb9783d3d90d087a54a98680ec08a443310378eca7e33328dd0815c11c2741fc75dc55bc5aaa0666a8ba45e8e07afab58b28f46b6c6c44db8020936b5313a9f2501087d2006fb9ce920db0a7557f9ef0f428028672aa16145d3d7ecdd039cd4431a643401c85c5b118c02b4345df598472ce9d3b2b8a74be2044de0abed63f8a2de149a0b50916a6d4aeecbfbba23b6a3dd57c70f3ee2d4513ac3343d398f4cf64d98c9471faab04994c4ff9fff9fb48175c70db25cd4c904d1a650c33b952130129f61b6c65d5b2ff4fcf81338c8efc5a9802166a1863db688200f7bbeba9d0bbfd8cd3eb5ebe551e4637d38c73b942822c463622059aa5970dc7c97cfada82c0eb2d63f3e99f4cd4e36df24bc5ea36b89a46f6acc129454878995d93a5711ddf165dab92609ebc5133c3aa3a342d67ed069f47ecaed479fe3e03da140804fc62df585fa80d7d0404868b29f35ab557233d40fea27746e757867b9a95a21574b59dc8352b876bad203fb68dfc80dabd160a847d44a80d58af4b032cc5ae619e1cd93ce0cc0ea3639975e52526f9fd6e6fad00ffc3f3bd865984fc01c19d4ed8cb196fd83ba567f17663ee96de3ed3fe773e9058f9841cc8dc3ca94498ccebba5ee7d7108291fe1620f749ddad20b0aa04541756f2de4dd6478016aa6845e19beb74087249bcff58c91fba05ce7f7ba7c4e9feab9481e126a1d03522b9f209f6e8557c67d5afe74e8cb7dec738d8dffc2bdca0f6b2e9f8447847bb1bc76a32f824ec22462a3ef07d1a5caaa5e14c38498298ffa83450c8e4c002f70d062c7df617fe923141d9fe40a736e097142049b38be930c353bfd41fd3ac2aa7440502d2d89699e350e170e1dbf621dedf1ab2bfe6bb123ee86220920de4b83e2004c329b2073786ad2b179c7993169dad993c6598cee187a6765ba374b573b6731da1b918a6882c527ad661d7019db63115947b4fae389e545dee4e2135dbaba536533685869ffd51352dc7e6c401081b609996b66046b50be88000a0f7b6d9c920035b84ed9d980a0da0663fdee6203684d6682067df3957570b699132b4d6f42dfdfb780550dce2b01bf57fb554dd3de0f238ea07f4b6982f999a617067fb62e6c13787fe1ee4630a7594e611205e08df47448db628404a68f28b175d0bfa6ba05a8360d69103758fa0b9e995b89c30c8b0262ed258fd01b2a65442aab97f64624a6f471d1cbde3416d5575dc5ba42e63bf9bbc9e4832621a3664138d36f824a2787eb39995fac0f6c7d1c8e1706b5bedb9cb6b97960e28e95d1760da76dffb67731633960d3e1ec4f475937bac4a7231d52a3bd7bae8d7f8d4d1791dea5e3efc9707ab2be86b344f53b0986fa311909985132bf90dece710abffec32e77a264f3c56725e464f55540c978c03d63c543d6e52f35d061853e39b2493efd0da0d6954dbeab31e75c7e1706bc8324593cf26c16b5f806dcf9b9383dbe0cfa2d686d0f4e521519645c509abc5a93fa3ea604f822877e52bb703479ebaeca43e3f02cc69ecf0b26c2b1ae37f622f75acddc4c3f2005d105d2adb183340cdc16c90d023eac53d70f5362ce9efd549dba533aaa6aff9e94165704a9512dabe097c1427ecb1d1788965e058881fab02fd89dd7b85d5f957c585488a1de8b15e14ebb550ea71fa9c5f715dc76dc9896dd5bddf6947778e29a5e6c5592100f98d4605b8e5934d65ba0de497172123420981af393286a4a6d0c7b3625aa6e11c196b3a09f207497f5901217bf8f3f4c04d287949d58ce0ea76fd8fd7f3659f299fbe0df314040c76b5c75bf9c0131bd60a322ab553a3e57a8c6ce01bcc79ada50266e30834afe792e10683e03095e4c508e9b07b43a4402acf89246f1def84c1c4ef56b03eb6b81507194e487e307d3a541b57460409103c2a1f134f463055a1b284f0df25f572f843b75654d83be9b46465a63754f51415bb136ce2bc2fbdc67c69233f8bc82ed920f2469ff0229becda0ef5970e1d2ed6e57415b9a745647f2d57f3455580468d40a9a6e0eafc06193e08802026cf11ce79ae664b9277df697b1e3c0fd24031ee2a1c55f1083e95aa9802dc1f38cb04d15886879d99b0c8cd278cc4833d7f625d073171eb70fb464b204fca9f6768d6b3936f19acd3ec1d30b497aff11ace4ab87bdb778aac209850dacd0b32119cfe1a6298dd4c53963a1308fcc80027e97a3bc9a67160f7aa9eadf4c1615cb9c38b506d954fa54d9b516dc2c473ff8042597b356cff16ed3f04cbd8b233526226363aaf0e8539d6d6555877feb5c6919c1ce6eebb9e1ee14c49cc510833b657166850f963cc42de130192f31a6d4e045c68706918a90666615607ae396598b2e2b613af0bf39db41dba5abc3c7aa6fe0c99d9492459af7bf2a557e0e306dc552a82c0934e90c42d64a11937a45e41628ab82237ae1c7c5e3f63ebe4659f5b89c302a01bd99e9a6cefce5d80b629f296d322d781c42e406284687895259b830a98221df3d14c89f518d0da45c556a82f5370c7538c814937b311381c0a0ecee84cfab1de85781e5197a266a596e47bee1f2537e0766bd9bad84339e61b7221a38747ea44d43c7b77f35f9bb15c91bdd756797b87ff49e6fc3db56e7062b53f604764a0dc59a0bef397d7e721fb9c1aa3e3cd94ec6167c2adbe2e53c5edd6e97df1d7760c725eb97c5a2057db0b31f17738d06a22cd61f817d211b2c828f20cb0d8d6e7d69593487a31bfd1733972bf188c475e453f8cda337cd4331d69a20c98b2ed222b53bac70a0be1ba77c24dc71b2a8e2666a1805e7b2d34577d3d485c7e61c42df234f03bc4ffd20cd023b14ef5d3d712787735f54bc7efb44c9f0719e300d858c83f70b54c8eedd0e1c9a960d785d8178791fd9ed0664e1e9de9aed6fa3c39082befab15ab4575f964aeb1593c79856460c8ff17b5b9e44dd076cda726a02496bca64ec7d8bebcb9969d35e7f459ddd7685fc2a8b54b0d2d39b41408650abdbaa64e8ad3f02e3c2ae05f80777ebc977c4f54068af07f94f28e7f34212b359550b9c53070d48afc877adbc446678ca405a48c32a6fc0c2971763424767f66a60051688f217d223ca68b15f0e2632b6fd69a8b5a917badc396a76002873c1463378c6c8815aafbc84f834358b0216bb38213a23d3f117605d5dac9fc1c7081f542bdfc8999c2b6b7342eb637f7e0852025c535da6cbd1a7e2cd9cc7376b71b3fb756b289a42792295cf10234e48bb3990a1a375edfaed22522ab5a9926fb4a543c6d5a1657be3855dae88d8b22a7d61183873bf82f67f692ef6a293eff3f2a96dc2ec064135aa9004013376c31ad1780b60fa0e7dae439781cf197081617a448a5a78403cd6f65e732b16db615fde0cbf39e362968d0aca936a17bc2338ac310b4f6b2678c59d66d619d8c8abda91b1a42d5a42c61ae1edd87ef8e8ad5d33bf0f7bb732d19f85b2a0713c5e5ed1806f2b4195ccf70006cfeea1cce571805537ea411f4827cc97f15c2c5d1dff6e44d4df605688e093f609def46a2af675627ee632867343ba5f860a21255c94017651692ed87323bb70b6a1eec1fece13637cffbf65df21ff55ab8b517c40cc5233736d194feed02bd5b19d5c29e15f93e3ef0d12d43691c774f7bd3e492699cf766f2f0401331826beb7823f406e371f8ec3198779292d9671ec8a1fd6f7cedba5ead124c6e740b8f6a1d18e2d8ca369e0b3c2bb499052888034e060d0a88cb214a7e521075bcce9eabfed6a2d0d8b11aaf2ee38078975f3d0cdbd35983ab6815f86265ae50241d1fc2b7346d1bfd93c7bdd945e962d7838c41d4facb94612da29aa112d4f88313db9da6bfc3d16c51aa07702d70cb3bbfb8b012d47d5d7b22da71ae938ebdc94ec8e1c4af52a401513a14d47a2867b0cea18200af2ee106adb30e5d40dac12913418642af194a1374836cea0510cacd9a3e3c93897992af9bdfb8793bf08cb6bc909a44217983296463cf88d785129a5f7683f41e573a74cf446f32f9cc1a706908c423a59120c43c50294cab2efdbdcf97b9ca641d902c47b98ff820c926f1d6b148df64c2c540f92bf84dd7907db295a239621243b6c2333b89d0eacd39fee26f24a583f1c14c0f6f95f8e813ebe4a5f35fbc6952c8c05d12ddaf8a6fffca5cbfe8690332597bfe48c9e1dfd0a259e8296ad2b0bf0a2a2533ecbe6a57b3e36ae2f96fb5025523829a95c03f5433df81bc11861fbcd3e88ab00d8a81a6f6839456359a111f726f00e3680d53aacef2c574a38923df9ffa67e5be5c22b80d701956c1241c3f5565da640c6f3fb1dd1701b0bd613a399d5d50eb7cf6add7b9544083aa639354ff3228a6477094383d6bd3907199ffa70a7a8a004aa899221707f19dc186ea009e0569c6e58b3822c9eae55ba4d1d61771f26a9cc68e71f73cc44d171c7543c09bf60f78a36bfffe3d21deb3f53b6822c12ddafff5087ea636dc35bd76c535e9bf6762bf92ca34911db956eaaef3b8ca981637a45f0bae8a924c0a6a9dc2ae27eab944952c781970b79b537043abde63bab1bf3c5829f1b61f9e4fa998fefd756a1a80e86ff3d55ca642e75a365b909afa456a3612f2b41868bfb32eca59405959f4ed799c68191ccfc1ad734951d64d4dd8b7ab79a7a970a4bab76ef0ef688de7f39ba2bbd5c66c1d26bd6e56be6232c08550b77b6345a291845f86480e8681eabadc31a84b6ed06c62ced3ac2ae206bd6c3b5082effa01e22e0cc7de984a5b76713648bad3e55d3787dedb5ffa78a619fb5b2aff986f179678dd584ac56757ade780a4281b5877dd6b23f85b50c305829ad62b42890e41d0a36de3fd762eff880bea11d542961c703bb1a037dbd247335a4c7cac6adcd41029707aad250926b2495a43999555657dcb8e6bd44a75680c7240cd2813fc782c3d06098c08c0fb8c1eeb45577e7aa36ae7fcb2b91fb3706e07c57d969436b7bb3dd4c3068128c9d908879fdd4f3bbc49362a47bb7633844ea6423101825245dc71862f56c91c4468f7c4411b6ef768cf00a6c8acf4b6a4ff6d5e664c4c018f7d5acee09b8db311c6807f808a280b516c3d23af514b77470da9a3ab0e2712f4d0668c14e1644fd3462a7afbfaf81d6e08508efff348f9b63efb2039ddbc98153e91793ff49502c6284a0e2ad6e4c5d3567f609f4aa517d19209595b2f71b2382e4efae353b59cdac5dcf22f5e5fec551ce6fc0578e43c3e95f6e4d6fc1cdbd3407615c79aefae6e4310c108ea04dfdce2ad0d1a1e52da8a63a28b15cd3c703dbd6d14e479cb4d50d887072db80ba1c4b7fcefbe86f4cee2a118f92bc98a3b2a5d482f6e1490fd27c62531bd1fbff1408040474ef40f764002e96a45ffd4ebbdedba92a33c5f90352e84c7c91493b7ec4243bf359d56a132fff62db149164d2df223494838e83ad6637b9d7904551cbca82219aeb82ac9fb3c59c239e3378268b107f0509dfa9407e5dc4ab2f34d39cfaf00f0cf74b5946573b57a1c9c0f124a2a7734b150fd17b34784d2e32787f599e7b6c2e161cbe2786df6219efb7ee836294d83e8085b1aadc28a11c818cc86fcf11994e5bff992ebecd5ba6c805934f28e6a5b3f10c0ddf5b1b26aa1e23d9b60960c55d8890e085e987be17c704e44e6a12dd325e134bb7534000ee52a030c66d083389c3046aa9b71f04eaccb08221d8fb3ac1a0f5ccc53622e14d62014d115210640fd1a943e86ee79ddc35f94f8b4e1812c3f4204db9939bdfd160344ad2d9fd3bc112f8cbc510dc6ff0da2fddef684a1764043db1d71df39f77ad13e15c69446c3cc6e84d3cd24d59f6fad35285afe437efa8721c1907a8a9cf051a038ae2ff8f390fd87e5b8d35ec753c7b7805c455b8904487f5a3bc30d9080e3adbfb671cf1f6fb07ebec830e50cefbb69f68598acc4109ba6467995fe5a15a3bba73163efdeead8fe2b388c0145c67badcd4bb36acbf7abbe008fbc1a85380cfbf59514202f48b67b0d630fd127864b87a36ef4090003c936ce6026afc8f93601ded1ffd20a48f1630adb0fa1bdc9dcdc134b0215b14edc5e58f5fbee257a0d3acf84d0d4f6093fc9228b4042f3d2b4b03a087b1ece35164a4bed63149d3b1c1fe00fab83c3848b08c9d1d3a2588e300071ac5ee4c096d6b979679c9f907c49015d286b0d7aeb42daf7840338689faa976d51e9a790501938974dc82b548b63d6e7e43a9de3e912f10a691f523328770ce8f77ca0718eb6e43012916d280d8a3033a449f1665b214dca15a618636b7974b2af0f7c582dc35f6a466c3511598a0e3d32ec5062e4977425dfc742b741f52f360bc1ae29b65313cab2f5d8680c5090e0e2236a055a29cf9ea38cdfcd1839591057c8f1884b2ab8008720ad90a5eb948a35871150710017b82ac281df94bbb47c1f8be6d669a9e9bae41bae60eee3545163c3c4bbfc9684cd18d75f23fec1169814965da2b9cf6f656afa39b2dc4a9e9b7c3ccce2eba8d8254cf93706fbe488b45522b22053606afcf4bc85dc1ebb9f3fdf47425efad26ee4591977df170d43169a8b15c85894c5705ccc2cf50d363f0424d9c8756825e37c3c212f092623edf9570d382926c4d80ca109713951d53539ad25e42b5edb6b450313fbdf08a84dc461ea4c0cf0a9be3954ba96aec9dc12a003f7873f97fd810fac580f28048577fd308ea57db4a8e2dc1e5685a59670fd841f29e9be28b593c88c6f80ca8798c19ac7091332d58b4dc2f92e5e5fe0c2f2a6de78e029a72978384057e667d22dc7a4559249705e66fa47ba518f9c9ec7d8bce0bf1ecb9bbb6d8ef2334722376ecfdb15bf4ba0d7b89672d99d1b9ddd2b564466e4024450d64101fd543291ed9f0a8bd54cecb30471c9639d57bb3238dfb3ddd84beb8033463e58fce0523bbc49696d51788c636dcd68989c2397b9687e100976c91c40cb415d0510b3b203a766e740916f6b4775fb61be647c54ce84a3e0a69869c61b27dd5bde18931a70c0ee29849fc2ba98fcc3235e7a40f2e712a0e0f775f750cc8ba28980a4bcb643d66f9a56393a32adb5d0acd514c725615d18d52bbe8d927b28ea3cadf80727ac4f2e4a12cafd0ce058a57596c976a94ef5beceea7d308b53a0eaf8d8181d32e38ce94e0a5da7ecd860cc958600ff5639a0659ef72bc41acf44af88c6a63121d1caa38ccd73d07875783b6a1bdf9babd1c58f056edb7472394ba95c00848cd30beb47fb0296c477b35af0239a6609ca286aa755232a7f091887b6b249a9362f412563e0cd847e0b1ab9b5ec63b806555ac61027d7a6bf532be3bfe9190932652b66555fef9fad3325aaf179338d8112fea2dcd291d882ea0ab720f7cce9806e64c782c58ac4b0bbfb80a02e252dea09fe46287c4f9a62dc911068ce54da2bc1144f71e57bf9a91b140c598b9ad9a873fb6a543d0a40f6b4ba7d1035c98d766286b04f741dc8186918ac5999fc7dd75e5962c2e09542c1159b9078eb0d7da02d99bb6460ce85191d23855489b44177630a635d25999edfef6259567db0721c8b59d82117a4a6745c54bfe34cf92e0865c97e31e255e8e2b6c6f67827d68027f1d49b333e814fdd0d1f425314d9b9782f72071ecd3c07190c149499e58e5cdf81889de228ad8fefe13b8cadebd2919de3e30edd6c2230a43a934bcfda160928fc6ec4ad3c4bfa176065b28b0230e96b3bf3a53082b69f46bed039ed7a2cfc08fb09f76eb97bea92d5f2889e082bb7d06cc7d30c4f88bb04f48ad4c7d0588dd0fa1781bc119106096cf6a062620be06e697624160a7638049bed320a9e68eb1462dc256a674aa8399bd099ee727fafd3456d884031d02bc866ee2dd65ced1ba195a9651ad6063201d9a2a74913d8f493d105ac8bd180228cd142269423102110c5b1b3d7dc6b24570dbcb3d98ab46242b3a2a40e3c2741f2998c42a88d361e1db71cea47856af308873c340d24440dcd2154c4b7deef44c58b0f3556f2531b20530c88e2e2f4a7381aa898108bee1face40a263a848cfe9a6c2c5985771d6f3eb5498ded04217c997943125e5408bcd9626e52e9df036485f49b7ad84726081be5404c11c0389b53b77dc4bb87facad81e078789c780f01791a7ef183ec0ab2b0ddf64892a8d56e21e60572d4167ef75e0b894c60691b1c09f7cb9c5f56a24fe0dc9362fe529bf06aee4079ac9b37e0af352473903a6f733552338dfc0966589b1f449d469fab93fe2b03d99280d01a4efc17298a0c4d4fab6680a2be3083cd03ab6443c6e1f878b0a6b7addff35076afcfb12ec6ca21b5ba2eda51ec1a1d6ad8e763903847719db3ea51524757a9c9b8d19ec7a15e8129e32c8710d7d24e3f4f3f6d0986be81b53c8ebe0f00c17eff74ef8683ce76ebfb32e8c8e5c7a8a31dec5228903d38d7c501ce5a3b3d6ad069a754cf2526df2fe195e71a2baa6f20f15beace7e1a8c8b5a8309aed09ac429c90464989405a59c8a4ce1b328ebccb8826e16d37fa971f7b6f04d2a5dca4f30eaf4b4f006023e9d68175bbdb370e80da8b6f86d7b4744e89a88679cedab7686112f695260b2f738557d97cc59e4b44dd794ddc394c4ef3da77c51d6187e30a50fe5651b67e170451a58adf09c61929f20cfcf62cd379fe7add2f9800ac6947d51b8d44b53a5b694f008c2d9a4b6884e5303b51c193276733b07669577504e6d89b10af79219d6467ee8b38ae27dcd0e496e18ad700be1e41b6953ff60fbf9ae7093d2c4e99bf89ae38ffffed49f2e7205060196c5c4c9ca695663690068798b2a1f5135efe2654e1c8a3b9f6a219c0fc0d61fe354f4c3037101e02391715899bbd0fd90ebda47c4cad85b803cd52ae3e4d890439444194f063aec417bb9b3b90b7536c23ffaa84130e2021840a63e852ebcca5546e7c8dc074c0c8324d6a6640c5428ad2740b5534a6ae596fa2d8cfdcb7c70cba652971afd880bc70dd4166c2dfe2dc79b928c2c8a64aaec272a19f9dd4b687015b264b28be02d1d7bdc9ee9e9efaec206f613c3764b7b6d30e1ed668c48093ff21c446558fa61a8274395c9954f3931875051835cad1155a7a83e3e40a910cfcb37e97e10842fdabbad873bbebe777a7486eba79ad6d4823a354a4293adf318b9aabcf1ed6132bf20b280226b2ae92b674fa64f528a7d3a8f438463954019076a0fcc08b322b06ae7032b622a698c01236c1a8006a1b254aecf74c6a90c707f30057ac9f17ec801c465ab766f9869ce1d08f4152bc27ceb9de2f74b4d111194a21b2b9fe6aff790c3a6e721d4d4596ba8c10946d336524052317c8f9313abaa7883c9b926b50c404c89a71bef89c48840180e2aefe59dcdf59f0421ffad844cae4d4b947940f544357ab236fdd47e13f8de455779795a6512f7335af7b8c2f4a37281f6bd3cda71405d8d544d6c8b20bec1f5ca47f596352fdae2d82794fc7a02b42c7e75e7ba30811bf2044a4b4beb0d3678c6bd4759332e691c58a168803f763ad3f6e9eddcf60e125a8c0876a2c48ab662ade8c4cbbca03bfaa804fc3b880d5b884b3283b646727875ba24fded6947fa26f9f580919b7931082a4f2d8669b64903da83adf20b1532b588bee836cc9824e40c764aedb7403da1eb1ae7b78c898cf97efb4bf6c6442c968a889415cf5291574dae26d7e916ead2a4033a27a741aa4c46a3952ff5fdb008a727b2de454dc0af206e4b6ad0e35949160ebaab91347b94e287f541faa062c559c170d497295572c3776e72f91cd5ec62556c3c2d621775366b6c3ee878920223befef7ee1141b818d0e78d1ef8cedd02001667054d0642b659ad45fdbcdf3576fb46a34d42e36ff330404c99583e7e5399dd492d26ca8ffda7d052b8f657e0abbda570f207e5143d66c18429d7380f06a3057868071ed92899409ae6c0fb291e86dbab1732c36302c62699853b425d03034946dc304d49a18ff7a3210f4339a5ec98aea2b4b46aceb742cde58599eadb97be3548408dd717ce8b8797818a78ff120c704632bc51d7ebaf041d94df38c3dcb3634b3935dc07b9165a8c8a9ec0249a1d34b3954ce622678a7ad8cfd1ad0796f669eb9397095f7c3b13da6eb516c73fd116e645b994e44b1b8ac8427b549b6af71326e5a0230a4cf3fc4a21562a2205483ba92cf7196e56af8db8bf5c9fad1f929965d1db3fe16e7440ac7e6408c7c3bf35fbddcc6cefe22865f2030b03558c4a5840784d0a50a4b1955d1b08fb277f4ffbeb1a601c451cbabfe746115ca3b223fdfbea6798124bf2fe9480da4941a0fdb77df1af6fde9fb8c2ca6c5d9b459f36e8b8d79ca2ef54aff0cad6f2c47a76dd8796a10db081db3f66bedc69a2e8fc8026547db440dd56523de66118d637f28b925942b12d9cfc4a2b67d46a8fe4bbe8c8307fb1c32ee3ab9ce2a1bcdc4950355e197c5575e445852294289697fb95dffc2c02052a59b6b7796000199edabf63bc234aa440b2753490e73bc7d5addb92d90f6fd9a7cc5738b526e98faf49831016db0df33beba1407e4ac5184c750a0faa8dd7e90a62fbf46c62f5f87f8bb1ed7814335076e2e686533ea5590ee75caa3c28d00167fc856c1dcfc33b3d1a55f720f2d1eb4e1209e5320c0b1259ff0f2ca985d30ca6b9ff81b53f96ec8386c1a08f31979516831d48f7a834e8836a618e35abf2b6d8e459a24b0c8595541121409469cc078551f1ddb470edcf52c257c5ba401ae73a0e6993e754c79d5e83b34ad666ce5f7ce97546e6de3e80fea3a00e80cdd8130e37b60ec60024f99720192e6a7e855a44c6a00d449d430770cce2946861f2f46c221a70ba1f94d9ec3e586e4892d41bb9994471fef1e47ab9c29e25acad9202040095670becf504a3856ff488ee3437d636108d2654be657ecff0bfefab7b754d9f7995cb9e645b1ba79b2144e1e65cd9722e3ba62fea93c7ef6a0c87496571e0d88bf20911fe1a65a8be5874a6cdb642b5b1a11e272c98d51489d0a5b0d478a7d3fc4798f65beca98b91fc3fcbb2a44c8fb7a18ec0505a3b686be1d388971b3b29aca30d7ba87ea9aa7ab1da9755d78babcd4423591c3c3afb48c4d1f73b6796c09ae9d2e83e5c7503b0de04ba799b6c67337f23cd206d54a357dd63e6fb703d82bfa25dfc5124e9a1a4f75505cba90aa9f68c01b0621a0eb4bf43953ae1bb31a34de81fa39ac735620ef5e5449a8a66836a5767d418236c69f6e7488069cd4aa326d24ca2b3cd053385b23938142d88b93c8c10ee1f29118e05094614b8856ff621c0edbfb47ee0655dc0cb3dce956ea2c8bb0be5ee698e9e7e90154cb3e7d4bbb0412c446830970b257f96ddb7c8150a7d8aa1b6b109b450c86d22357f06177117b200bd9e7d774082d3dad2627b00a1caa5d03618045189867548e67824584e0e8e8e17791979dac7f25319fe7a86b0d51ce85366cb762ca2185c058d314ba8c4e4ed34361b7cb91bceb633ae5194618f44a8a40cda1e1dd4b0ddc5a807fc4413d2e424a2d853edd84f390ea92422daa85f0c8ffd8225e940eb54386f1035e8c490d79499028ffeb54bc3a6af1564d10e3d59ceb92247109e0cb2c832aa64f2ec3c4fb9e789f05aecb7d30ab737111825f515a18eeef4f935ae1f3bc83d1e5ff5c9e9cc6716efbcd94a9084a7a4d4709450073cf09163872505285daeecbd70e836f6eb5d47cbb8de1cb665f48440fe03a8d15cacea99d08acc9f7f8ac63030158d5f5e20bd3fac7defa4a5f277c3b57c9bd1d5997c9dd1d5f2924edf1e6a0970cd3ea4e5ea14ed3f34598760707d8bce93cd6307ad8e1d3320999765568b48d4f2d9392aea7b387c45d48e3881d37af791783cc6ce37f937e02e1ce50238458b428f091c769da14e4caaa63fc1f5ecf90a25af72c723d8d0036e8aa31aea8ec4f558c2477859d5ca4e9a6e93a6793db53b2c2065fd565e55b03fdd925edd120e6b6672069ac552035941d33b364c375790f5369ab33398b68cd82c60633393d49d4ac8705bfc0ae1bbd31dc7c51b7e8cc1995ef7cf1b8b95e3734f0d9340217a91183001bb707ade29e73647eb9bcdf314e6ef56a92e4635a88460da77fbabee8f6c6871ee6edd66ac899a75904c6b74e3c6134e62fd92dc45580a3dd22d97840f4eb6088db875c14f59b09e7ea3804f804c9f057e2d359a78af430587501d85be1de3dc0b0b18a1254f4063396039327bad96ca28bef83240c0b672f6badf65934e65ad9ba61e8c3ce579498bb35785c411176b3205695787a798a50deb664aaa143dd232dc7b0f3fd383d70f12b387457f2aff0cd981d3e24b38b88cb979debd751baa3750e2e443dd948b96dd8e20348b26a739808658925ea673e87b0f481dcb7e0e3c0a0bbea7a540d1e12bac61492e4bccf01668425435360317932636d630f9d5245d52ec2d6d2acf9190b8a3ab19e19c94cf8d2abe446ef7225ba7e62237c518704f92edd30aa9cec383efc2f9bb42c2e4c25665493df71a671798b9ab5333dcecac6435762227ba3e616ca05a17d05c3af6c0d5ee1fbfa9372b8ccabe6c108bce64ea1edb347cc5a1859460a0b17c869fbe9c4f3050e7998dcff73449df4d3483016b29d93f5a2d52dacb88d61fcccff05fbf052528824c6952c8d01c4a57459c936b36f8ba4ad40bcf99e9b96364395340ab0188e94d28d3c9629e44b03b10c2b9fe23fa8ebcc4b30ab1601af697b5a4af36a2fa5b2a31995b7d3c480efc9097b08b42e15dbabc42e24f54c6d7c63d08b30a9a8c253c1031bd3991f60894371ae1fc16cc9a82c4215479fa0d7db3320e186bb132ce22e9e089d921097ee8a091514cc5b03b46f6de63ecc99bd6bc39b1f2ed22cfc1544c8dc16dee80ea2794c58994e786d66c6ed33bc909fcf9b699c95eae0b81fb5357036d7e80f39f8ce64d81ba605e05aa9063de3864beff92fae7015f7aaa15bbbfd601142a3ad2edd43dc0daa48e2d1f6413c4e5553c656952a99dd97b39e47a79f4389b3e432084fbb7953127721fe12fb6200f56eef789b3751880249d7d88a722c78e113f4a85f3f08a1933d7b9bc22b0b57be2b0690ace22515ae3fac3a45594a4980066592ba9579f9c79f152b938b4e914c3e8751a325ffb6697f441ddd6eec61850fad285bab7f42dcedf2270bb20f015ebc04038d96d4c6f7492bb9091e0295266045fc31ec6533ffe5357cdea87dac09ff045683e24d96aa4f324df863286958b094b2e08102d4d6ffb5edebbdff49cc4b223ef45dabd5b01b2cda9a02d90dcaa6a16ebd2e5ea7660a2142a77fa4b76e79fbf7b2ed8b1e55939cfc49c019888eef16c4ca5e12acaebefa0a812ccf18014ce71d88e6fd05ce6960925189f0d1409ce24a30d223d23f0d29e7160439eb28cb10a7ac62dc4ecb8d72d0b91cf377ea518a92ca9b8fc1c8ec716daf80f26d7ed73e9ad9bf6d973de1c128a3b76082593b6ca93d0e4705adf57bd5da8d0b8496776336726bfca8ec0cd35ac0239c350657803637e3ba334ca8ab014b0af8cc5a5ad730e62173c488892c11f5429ed6074fc82e89db97345accb8ea95d96cc1787e72554b87ca7feaae2015f38f3f6f59b326e72c8e25055f1b102bb20b1a013766a52e0930b2a52e1f602c8dc244f4a656296623e8f8a1811b0599a88c76226be4a83b478f769f19f8e9d00bf36f299eb89b8e747176a7bb130ec9585482cabedcc1a953fa7f6ee65fc754726580a77f362e22f9379ee24c7c1d9b473f556405e31da3358fc6f9b686b5ac9dbaa74352be665a56f2257d0f12e958abccaeec5c328f2a3f5af27d4f73006adf1080afe1abd66113b2982fa5c596052f5fd0732f2c23506a721ab30d9cc81ed588888365cfc024e7dacfdc541d4a94d9ab6742c24d78c85be3d8868c47833000d10f4d1f429a877412748c7b14a866efe89b19bd53b516316b92cd26357bffab7db4da9ef640154266d175f1412b93f3d1993cf7ae1f5178b73a910f1864fbc5924e83472c02b6dde65c65ee9c020af29904dce329dfa014ef54432f0802bce7f9255dfabb3cb4d69282b5bc4d2c1501c2df108256a07dc9d045ff2266b81b6d32342567c42370700f331885f3e5b2833a3cdf86a4d52a807a67e82b41b41a3162768ca5dab5b8f93e54ac8038412c2d89ae875bd4b7e5fe50266a8f656b386bc6dbdbbf021774a7fb0e1fbcbec513d3d9993bc2693564930e326a094cc417e54198b11dbf181cde7a523d5bfe8f747f06421e518e8ea868cae88d5eb89f88380ddf3cc108c1eb52de1c22e83e4bf0b9a984a29ca48407051f0721b78868ea210716f3fd9458a4eaa550da10edf3db4fca60e926b02010208009c7ec7f9c77e4f2ee37660c02f68838040bd19a1ee9739aaf9ebb209ce7916ce160b6a322c60566bc6fb0ed240b62db4863556854fdb799945ba67e6d6e7da60a53d60ba36856d6df1c1b4cbb0cb2af36e9bff96358016f9e63120b619216ef79fbe90e48e093f44925bbd10d2e1fb00497ccf6c2c5c968ae62a4211c49952b00750e1cfc055d58c910b1169ccf765d50b247314a67f9872850f00be251dd69de7f2c61469a5dc292d6dbc22037a76cbe238139f69740784e87922bb50c87c960403d0773fbe344ee96ff44258c425999499a093089c9dc46fa274291397dac16d163aa19ca25e982f5f284d398de7651400b64139865cc4056934cee6baff1c1fb9eb1277a225391a393294548e3579ceb0884ebd79c5a88d701ba3cecc6ae8cafa88cb339da5cea6d4cbf863337bed2069c69f2ee0dd099ef97776b1b26e55461de2ecb0ff423350539eb849056f0f4e21db8bee8d5d32b3365d06791d81c7dec5191008c595a7f7dbf443a1061e157a57254177d2cb60ec249938d606517ebfda7246e552018dd52b6e84b24007d467b5ecfca92edfe533779e52715ab3848f99d4e7fad0669e986a88ca8f1c402d35c72294f6b0bcab0fbef5b39d4d488e578309114bacde05ac59de7eaa6419f5b360d783e689c43d352d4a44369ad473be255c481545aea04845b5d1f673f47a538345b5b6897f40fadf0177cf60b7fcf4c6fea38477d02b3bb32b2c1299e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
