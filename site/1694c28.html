<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31b637883838d7eb8482835fcaf7527e759a48057a1780a0d896fe54223c3f142c2ad86485ff66e393d6021deceec65ca9b55b4ae29039697e8bb806ab045cb73fdfe56a6fdd4511fa75ad54e1b09133a1bb7b2724a51ac83088896cd102dabdeb38359d0d0241ad3fd43e7d34b507de36533dc442987700ef457e3a3315c37d8746cef91d67ec9b39d0f6e75b0b2c993d09797e797be50f57effd9fd2286ac7133c52acb2198102023b4ef7afd4e3679a6172f42cbce7f6886b43b37f7726afd99fa76e6aed90b118c65d29bbf1a2be07fd53d65337b389db86eb1b1f5706e8cc89eb159e441489e747b0ea8a01e10a71c3c2efe806e1ff81050b2270018595ac5971a0c75e195b7a5e3be575cbd9da1df533ccd77a17a091a4c766a320bd3fcf8b5811b4aaac1cbde4fac32a74c4449c7eabf27d8b0dedac6a71d214271649194ae81db3e9a421d72a7e13bc5069cf471f750193929672ff6dab766807dafc33c050d2dfb9f9a5645dae3f621fb75cf458da2f018b42bb49812625588728e86b6cfa4317bb9a43dcb5710c23809cb658f671f7b792cb75cd3b2118723a18fca35a499a0cdad84e5f53d6fc323670ba8b10bfbb3bf2cc6d93a2392e34cf4a85b3be3b9cc97ade619bdd2611a2dc9f30a2a5cf9c9c2fa888c6b7616de2b162c66885ec21d5c2b402f719ec95e939442713edfee18937dec2af7be3cdf3c215b42316f2635555767a872d2517ec2628a7012bc9f8aa16ef0407b60c42403a5c1394ff5949a4010dd697098ff62c3aca18194f3cfe1c5576868a92b54f571f64966fa675ce244e1717dc7682bd321e58b3d68bc011b9843e838bb937718b1c0023ef2b6e4e162362b04caac1b27a92b5cfec0a28c299e9e822c58b86748c9a678b01fc7fac10c244deaf6a452ac5005c29283a62c3254860bb6b4aad6fea488eb4e2345f9337df4142e34ef62bef6b511eb2801854d008938e20dcf8431fd7e4644127cbe4dd21184857db786bb16ec61adbd07b6dd858892e9300bfc95790f00525053659a53114c35e14375b87e101cab09c779e17f819ccaf218fda660b2759a7c3a031c09ff2c7698c9085a396987b371fe8c8a9226ee78e73ff784bb0f2ae52936062bc44599b1c540944ef2ae90b80ee36c3ba8fe7a52d960e26a25c108e42592f0619ad7e7c55e9090cb63a4954c36583ada5947ea245926c06c2cb0f3fbc8dd4a05da7af19fa901b3c14843bfcc66bcb8f12ab8083ad3b5cbf252e2df9864f854c4e6e92fb75b8334eec8b4d758945a5c2af0c2cae3d4823f08019f7ff3bc84731857eee838fd0356bb277ec1ae7bfe816df8c9aba14d96834249084562951ab686f5d903f445f274eaad50bfda529a9ad7c1f1df59644e713dd72badf94cd1c17d7c7bdb8e56cca62850987bd431c61966ff99a1fd4cb7b713cdb0ac7eba8a60c2d1db9deb7497e21133e73f519c58a3052b4e144054f57d8c2d4df17c3f15f1af9ebe451e7a7f08270cd8d4e28f53ed4af3916e47bb228f9aba8273041face6ea967614240e1be60a0c6cf9c2efa032e65416fbb1451828aefab087c2c937871b27f0c79aa4646b8faea0dc7de3e71858208324ef04a89a4536020a9539fa9d77b4f26286c6296ef8913b1ce329ba5be1761d157c6a81ce4bfee80cc2eb8ad166bc3001dce433701f3e0c0de95fb879431a43eaf48d35bb4ae772c61a006edf77464bc2c67da79a1c90024de33f4c5b3cc7fe5577f66759be960357b01b73ef775e1eb22d1fd437b469af0356055cc56f1374d3b3b428f05afaae5709183fa5a6357d5d536870c72193983a30e7b25885d71c1a5997a4273a7e8740469c125b901f50a8c8e12a72f8d0eacb1e51e915bfb5886a04112431e4af42d5cb1a8bdb1d6a1c60d1413b5d7e76523c69710f0eaa342b813d046418c2f1e70500f5d1eaa56ecc008a66c5eccf88c8bcf37fac1404a3629b100c2b0bd1359479da776f28e5b9dab8039cfe420daf6eff2a548defdda1546f4fc83e4b58603eed5f6bb9f5c65d0577750601013f52bc11e9bc1be36f408642a3162c260abaad6b0ae09271e7542076a4e86504ddbcb72140e622adc31502393168c4d3af50a7f054209c185e63bb0d7ed746423884f73a8f2750fd8c852890b497550089a3665c7c90f8870b0038f3081581a61ea4d6d75de5a2fb17c01ab4d745a59e36856bb0878315ac0733f82b38ebb98ee944528c80c53a94bc1c403d44bef3fd3aba67d2eca1189a3300e2be55f39197d47762b757e595eee229b187d0cabc14f000b6326b43ac448088546621f36d8ebb7bce648c40e1a8a05f7d1afcd99b5b3c3ff476f6302378c1caeb6d5245e724431a489c964351e3cd75ac415a3581da44dff8229f899f0a09b23a10bf07a982848702e1d3a612bf005f42c1eab5a1e2fadada5028f094b6ba1d3e839acae0e095eee727c13ac0fff93470221797fbbd414829fa677fe9c6215d38688a64c052f1ca42fb0973a46d078c59b98994671a644e086e40108adf2c5b5b512c2932c3e9eba3d21258e9f33a6cbd7870a60a4a7a06197c7f621d7cd4b9528dcd7cfb18d85e7e9e282918442da637de1baedaba6221a8b386b2d9a79a7fb0fe261339f86e110a533a1a37e35557765062df14aa17bcd8ccc5dc2d868e981c69b8b0aa96e074f899f8a062dcb11b6656bfaaa4b944194af77309fe96bc043bdd02ca7d23fda26324ee0a0b555961e7ec8a2fa116f3d0d19b6ba635471236b60c4bbd5c0d99673da410aa8b6cad7764bd4cb8d73301450a7f9e44bd1421c1c3358e4fb8a726bdd770c071751cf111d278961b670f90101ddd023bb8b34a897973cef1fb6fcad4c94f3b6426dad364ba10241f2679890c82564a3b3ae6c4fd0756e6f216cb7852807d107b48fa1e818f8ab0570344dce2f0945ae092d09e71f7b1ba038d50993a440933c712a3fa73cb14c0f3b20fd0b907d96278c11286ec13b85606c4289cb33fd7ac291b8b2610e0c861b4b6eccec2410cab5f3a432e5c5858a424a47a7186af3ba8379d9dd5ae217b3ecf10eac2bffcd5f16e46fb2b227abffda623d4d8a0655055e421f48c72c9a4287d9e296e8c0bda93a724ef0944debdcb17fca478de01cf3a982858fa7524e399c7fad797ab2659a16f39e15eaaed777abad92e33a4061070f7912063ea20f605b178b6a4e6dbca9d6f3da44eee82821e155886f834d8b923fcb80add3d48346cd06e66df22d83640ecb15a7e4ea7abe1627a3bb04aa05aebbb958933a39732b940dab973e42bcb792a944fa711d01b094620a7219e997107961736b72dd2d0f3859dc227e1d5006053122c3614fc829b890b83ca84fbb21abf48d478e03d13f8d9543634581cba5c94c0bb56ace9f59acc6d2043948cbb05bd9d7c1125b1fdd80526de9df58358645be88d15266c31f6dda49d93f8a34b25b48c499906f57d4131332a64537e04974418354b867d67775215334f0124b189d40595edd7ec69e3e7736fda0f3cc0d5218fd62fbf659ecf66abdcf955b0a7f06d6a4f9ee340e321071e7f9be334a1d43165fcdad3c48875145505a11126d15dd9cf71f5e32a433f7f4e00a15e0740ea7cec0066b1229fe518767b82176479286e8c88b40da9f1b1eedba7452cd9572b632d876797fe1c22a59fe780e9f56f1f0550dd13f38ef85d5abbd83e0b4b606b2a43344c28a8d2a039d23d4f9a8e7582a8ebb0ff3ad73c6e9613a4030c43e733c2b97e76b8fedffa3d87eb3fd621b6d74d3b14dff7f9e8d03903721d42e1d96ef14843169def1b89ce9990423998446d85c90e7e93736001bfdd77b9c109925354961465389749e155d8e035b9757afca9f0b3f3d977df5c93c010acb072c87a56536b6166de9ae3b344949245f212a0f9021874ba8b6173af68e3bec4d2afbb4aa26ed1f8dea0908bae41aba01f5b1bc009dfda8519777fa50e7c62f3894a0f4e45d67e81b14939163f567760387b349656e475e5212b439765f0c6179a50670a335dcb25628905db4cdbbbbf880a503df8407cef45790168c3a1c1b703152308c3087328c9d5744e0a7e9270f20e4c44dd2814783b203a29226c1a8ce6926cc75d47f7119316506e3f1bc30b248d56ec751c84de680cb69369a3e59e83f5a2ec1e1c4dab42be5fbdccafa36c0bac023d14b5013d96e2c02fe4201371c060c299ff5c8000761cdd36e4898e0e9b7e3c9c445de9e22a381365c30a3698814bb2875d14c7864596e99720a7c54cab8f162af65cb64922a1bd144f8011305370b613a0da71a18da9068537b58fbd9e6f502f986ff3d41e1abeb425b357996ecc85ea6c69ebdd17c86e171483f2ea6cfb201b06cfe71f12924380364a0edb02a80c08f682d95409b607cc95f93718fb8a1ae32ee430fc94c0724d309d5726b9a60ada84fef2f3f7bae590b7a2beaa9c3844b98da1695c0f72b99f64f0d463fab720c7d801e1cbc0469e9593b12c9cee94432dfd546c28d829f34150a3a52d137870839ce5982e9134e866b669cd6fa4bd347a8806522acbc5e1498a3c47d72c2af5f0f6a38f451467484285eaf353ef6c0ef4ee816759633fe87dd57b630083cf04be0708b29d1a6677a323c83b69a1cc4b9f099c92b524d7ebee6b00f9ebe4a57c623fbf9167882b288fc3525ec053be3af797705797e840e397c902ca18c056b647a8de487eaca28cc835ac47f3fe40107768f61ba83725298c4886bbdd72a32c197ba3098a2b2da55eb182e7a344202baf2cc8cbf6b427b9e468d2c66a870dc4e65f4d735509888caeaa35d6c9b8abf1d282b78db885df02b7ad8ca86d68dd8a62d1ec80850543f208fa2730a8450ff42511f71602ac0aeba4210e95739cdad1fc1ed8ccb7d6ce7a12d9e582de098eabd171eccdba7514e08ef184ac1f952ad1ccf66249ce822cc0886972b118b3fc99c530a7897d4b0eb0f2a36aeb2f35b7227862e3e655ae3450b8ca9c28e8017d7f404116f4acbdcb7663cc3f2ba9d920a21188d4fea49c0f475a3b8feb474412cba0bf5f3ef267e20c963320ce5fbf0aaf32e8581d75f84a2891e645f2a0665b4ff6ea02ff56508f671d92bda9e132cccbeff4f5bdebcf10b3efb6a470b0416ff57828714bbf1187843709bbd86b9c9e8feb6ba06c5d092c1ba26b75be4230e9510258bfb1ee928c772d112193d48bf74e28b39a4e3597673e00f7d7a5563f88b40949e0238efd4903a1634b71a9b06accd6ac439137d0cd7ac8270c039883cc207d1654a12050e65ffea0923cbe624fa7fbafe500177e92c7717f2dc3a8aa8b0efc787835c9b638d1f736f8b12b5725072d6e915f6386939e913bde59f679f2b74bf430c9c309fc4bc463ae6cf7da3348ad011c136561437b4ca4885e2fdd91c9882b786d30665d3423d1c61ddbf0b804882c914a976a2a6106665f1b5a4546eddcd7e83a5936f14c17515f806935f1e227ee07fa14684c01eadb01ba874dcef2cb0891be7167705af91c46f158062482d49eca69fceb8ad8092a614723718b9d6b03f3a04f1fbcbeac6e7ea3c82c93643b7b5ac5c557063c9c729ed0bf1e754d5f078542ae37f181d7742353ba5715ffc16d00d2a7ffc6daa53e29b9e72cee47b112c06bebf2a2f552323948197a87a0410156e18bdda0754d34b4ac588bcd9e072606a8fff72855b2c83dfaefbb5fa84b64a6a36da54ad171137dbc34b6d87db35097027031de5b0263aa092ea8c7749adcaca007528c8041b4c6993086d394a4b584dea293b1b347874e8e2f2eca399a468639bfe095d30be58a92b77870bf5b4011e19e03d528ff58a5b85a4300773c1272481ae01f80a6cf50f3b2820cab848eae0958d1afc2a84dbbbe917e94361cb915bdaafc74d24c242fc9d3dd97531c280aca24c4313d62d0d271eaaa79ebaed578bbc78950305958a5c2601a63287ee08c2b902391ef59967392934fe8789f0eff5198a4c3a830347200aff00d202ff05d07ce7aa1571379b0dad1d658812775ef6f618102d9d92c6ea5ad4049297b130203a260dcdde98b9fe7a50350a0d8698ab565b2d3947bcb4001214bffe3b432360a7119fe990334ce7a73d563dbd06d6fe4a53bb1e3f9eab539ceb5c7464b94324005b7af1d07b69b7efaf3524f1701be6816f9235ef5e0531a4c53bc9d9ed84fcebdb6fc93c9bf6b90b3a5ff8a3b749a2e4d08f267060fba050d1c27f868b2c4e811840134fdab220d89d898584f920e0dca508967b0c76ca457606532f95f69cf5f1b431498293fdb079c7236dc6c9fd2413434e230c87544438f2d03bcf35fb2319a065ed368b0f215fd417d768ccff20dcb4f7ea70bc2a9cb083a22dab3133ef21ab94deb0ecabcc8594de7193e540e2437ddd153d291f8cb43c5933952c05787142b87df6a149f02f3d14bc0bdd2c6755c26c944d6f69af9f01680ddda5563728bc50a35b747eb47b707edb490c66fc4bb8c46407500e8e4eb600c8b7e93019ecc5b13ebc2caacef8206ec9cdb352e8412c0f3ccae3b21935de06c3281ef195c794c8d9ef913bf9e954c78c88fe18b81aa99a8fc13fe0521a5321b4659c4b9b8ca55e522df0967532f0d4374632db6052ecd19b85ec9a7f471f42c1d95f159a7332facbb7a7f9baf18ad36a2fda85386815a36b705092746cec3c8d2d71525b610d50028da9d407d29dfdbfd49ce4b121e252f58886cdc14fcad12d2d93efae7759a34e558be13f5846d4e747a434cc6630c521ef0337265d3836795cb37b79ac77e3587835723089e369c0253008ccca1a44091778f08740f8d409c149ed48cfceef3e6d74b64706b9d9d11c6f578ce122837e22282f61b2dd96cf38a7c3b2558063e1c3c24a3a2d31b93779715dec38942fe63ee326cbd899ada731d99c19167638fbffe4b744f2407ea433f02ef34c6c0098469dbccb28fb37b38d63ffc957c700286d03807c8ffb6ac4d9d573d9307819e7a5dc87ede5710ec4054c74420c3594d683b3389dd46771013317b58171ce0958abcd6fb49559acdd410afadfe143033e594b1c6d41302cf793befff44c166911810d2bcaaa010e2fb704723a4edeb9cd95778b035e24ebc5aec882d804ebe0b9828af44fc4d4303d8ced46259a6123496d21453b1ca5a60f2dc9994d9996abf720925aa2226820ba4eaa15e0ffc55b069161f260dfc8dc0ed09b73a27596e9ab461e337dea7152419388eb1e70a28393b5991fa1d2169f4cf73859db3e8175a4b159841c197256707140023cf015793dda04d3d1595320ef02c3e5c7fcbc65269e6f3188305b6614248069a7ac99d2822dadf2d8da31cf1dbdd70bc319f17b4284a6553325215944b1eede627191ec34539a460cfd965f179feed13c8b76343e49e68679f3c66dbd9b7ca811814f0a9316c04863fba47fde9ca6875ca49cd211292acc009bf5926e70b093613ad7085c47224f4126e7459dba9bcac13c021ac89ed6cde5b025171e7cc2d265b1154d493f23a817a7b4050aba58740692a138696493f59a283e7da443b75ee552db0e99aa7f0e4b9273fd5ab94d58d26febb558e36b0e1df4c88bf102fc91786a215f33f6361c828084ecce683132f39878980e525fd11328500ab80dc2c2ca2a1aa599405824ab73e0fd581b23de91c37cb242e1d97c2c3f169dd508e01196c7caa1f026698c9f15475ae93f396ec2ed66bc7030859ed314d348f6d8fdb64cd21d1720b46f99073d5c23083c585a4dc6a2e43c5f1a94b2da0eb1d7dd41b14ae06dfe624fea71f7cf09784cc854fb79f86696200f5c999573087496bc3ff4f0dc0311a0ccd0b49073892ac310e7bb46cfbba4c890d9b173dc837efc29cee087f1f90e4f06d5c18ccd3329262af52ae5b1aa0a867d9e91b4e62cad6076de26a2b4d50afdd40bca91bc1ccff775e8b6f11aeaa51b9803e708c72414006f9b5d7c5bf312727da1cc95504d2ee9228facc1025990746a9537c41911010d2ef156f072c6593ee9f986eef2d3e25b8f4f21f8d763c99e682fb9e6c7d6f56f54ed62c14a3d4bb3e8b15307874dc864872d0df09e4655a0695498e5dd77fc64006cd75ad3926737721531f0cf9b832424ee87cfd9ac4761613a198b71e235fd035dee886d2c862dc7336071c788145d0cbd41b0e49a2531e9065d4a699a32dbccc242f0ff5ead9648e08a0afc997e371e427e2052460c840bd2ecac1ccdd5673bfa1d2ae9b3ab8e8209660091a6f3943b517a3b8869695d6eb3a48b21fc8b5d544b4c2885b2358780c6cd3490e9bd374a48ed3d0be7071e2da31911248c91c6b040a779b77b366a2753493eb4e276cba7b46d9788771b92c59a45dbb7abcd62ace664abcb1af2a16f2868f01b12f7e18d6e88e48e2a486641817531e810aa77e983fe6ac0f1d6c7b696cf5523340e75fb5467d41917e66aaca0aa94047909a839853e506480d0ab1ced6e1eca70401dfbb01e8bb0289d885663b9b04e1c389beb41285b6289fa4546b33beb9aa82396626cd2982a950a685ffc12d4f5872b3fcd8312994826d66aa974eda1d858653b9a59aa581665fd4d28f15f58707592899ab2f844aa5dd1a97b7bf1ddd3cd5648bb054eba53d03ec0f78b32825d88e6287775dd7aae2556284d79e7bece390a4ae0d15048e6319a5c6d7865ac5902be5b395dca86aa111a6b89e25c00cb0a98aed26db641f456c94da2cdbc6e0745c302056f9a8e65415e789d1d28bcf8f47a06e97f16317275363783e3a6fe955f849354b3e54432e145b66c2454ebefa90075b83b56b9ea697325d023f9e537e34a2d2517a852aac0a29c249fefc053f81faff9d0e4a50721c993942c8e80c7ea65ecec91e95a97b62c6479984f7fbe2f3b49407a234c2dabd2f0932b01487fedeeea3522c017e684a4ab938752afe8c4a1f6703445bce64c6e6a397bbc18b30c287d30b311c7fd53a47082030a47013418a6bdc9e0fdb400756747b03ffba0fb97d61857d336bf311da04d500acee56f25c15a17845199d20e34acc249df4d339c9a1a065abd920903146db305fa63d12cb038d556c53278010b8c155b3aa4c4db59c868f9e7d3b5caf41300b6393f1d55f798b19a2f023d432abeb5440b1dfaef4b0cbe4cfeadd71eeae58cf21ab5801742d7caf7384496f9067eeb06ef4c17a7a781c02576dd05e4bf2abc805628e72e1d46ea0061264269cca43ebdd627dd3db2239a15b7dca57d53440ad4d2f8adf578f9431795d1b760012a8d61d42786b09d2a948e1d8d49df3e183d25ab29360c38c47633ade31cd4884b99d67b99e0754e5787c7a2f2ed3aa5aaa0fd61da0033c32fa0e4ef3f842f9daa05ff63e59bda6f191b20533a728ddb162dfefaff2c6a95fa8642eece1732c747d917fd8aa7aa8d8cd12a1148d95be56e31d6cc64666e5f1f73c5694e0009ed1b0736e46c909a1eab63eddbbff65f5d611e846202f225b3ac8279d9411ffba6c7ce1ac72b49b5f92fb8a27c97b2ba9e5d97c6dc2fb6b6958de5063ac4a0c1b6e54e826ec4300bb2b4d83f637ab7d634bbda7ac9d288aaf806dfde743924d6a5a2c0df9220ed2efe9147eba407515248df2374deda7948f88b4e5deaa28fdb89ebe67616647e311804486850c6844a2d5f649a21f2e91194e24df28ddaeb427189535fbec1316d8b26eea1a99d824a028084ac5d0ff01f9df7256f398e8646d6ed96a2eb457cd993d640806da4195d70343035430186104990d0a981c328bbc8e566180ffedbb48b14dc891095f3773ac7a6da81a2ea38b4592c20aaa332d9db97e703767fc6e93a830b9170770e18154760db6a1ffb08702290efcd4205c82b26607b90d10a6cf813747f519fe320917cf8b56d1709a10294f146a4ef3c298a51119df0172505030bf3134a2629e14b186bdc504a6bead0fce2e18e06c64bae530301ff5a91b1e2b6366676b9846c49f93259e37cc0d7af234856550184c3db4817ff7513ab7df74099cf4e1d3892cdd85c1c66783a2c47c491c31c6ba5e4f05ec3862383eda7e393f944085b7b73bc14d26acd5e5f0508f4188e2fca0997abedc8c7cb24c20d0ab5538c2b18cf2d1f91360161e086657bbaaeeef43f46f68e834965ebc42c9ac872aa8713dd07951da45417e50a153c5179e596adf7dc86ba51d9b4c8c59b8c335d2e3bd82d8202907485d64a4607637cc9128875b0d88dfdadd823c07d2076c666a821f25bbafd5fc8e1712284a66bc92ba1ddba90be4cfabcb4c5090e0927fa4b4d0f199058f5cf34653786bb3b92ced20ba216bc85aee1d0c1db8ab6cc9db374f766021dd1c62b2833115a07e6d64cf062a6f8364d335a7b736f57ee06cb7ccb64592618fd330427e06e0d2ae777247eb4cab513a4aa2de6240f968e0c540f1565b045c02053eebf24d5ffeb5594475a9cc610f8f0f041cf909209c58a04ad36f8d75a0ffceef79b84e9b0f3daca283840fe85629c0d1aebb532e2ddcfd53545ce37c0484f133d2b5111057f3db672407c8faeab8606865f6c7c2f97005d0321b3dae560aca49d5de538d79e91eafe1ed4e6a57be2fe3fd78d830c64d841b6ca75f727d878906c097605ddd10883c883bf5a8d2df0b93ade96990be1b7038c38bb47519529d3fe6ae814a6101b10e5b837d91a13296411ec0ab150b8d2ed7e7a2bbdd226286b4b209f13777fe905ad528bf8bb6ca5028f25250cb68433dfbf7b385f0d49b189159fac10b890f5e6d4ee962ad6ec6add3ff374692465bf6458e41feb1576a3dd55899fd14485b9c7e563e29e3ec265c592b41a419e0c6578ccd5a70fe3e44ade5028a9df91ad76f24fffd2e88496b400e37406ce7b37f0f68e056d8b26d7f704fa888ce16e7556224914fca3d2ae3b3941a9df228888efa5408bbbe84f65f1145c61930149a020f1e131748f3aa1f7df7f4344f94c6aeffe05baeb21d36988dd470a3f96e2e09d63f57fb142b1bc8ae644b75ee7dcd13b71b9138f8322eb9df64b1d70661360a34c1075843b58e6e6f3476b56d187432ef47a5e0068fdce9eeea41f4f1fd0851f3fb9dceef74c165f6a744729d92b131dad0d352e430cbca727f949c132b6b31a1ee385a236c37ad7b0a55d1bd802f2126d41581ff45da286ea9d1efa2b7e03cda37928c1de114b9335bccfa4450348b8178f6773d68755a9f359c9c3825a43dd3d4bc3b6f48acc55f4b76b44c59a1bdf04cdf63dedcdff81874b8870297f605060e3acddde7676a83e50337619eef6c48d8d00128a1c7253cfd59cc8c86f247a84810246ad44d2fa158a2e1cbbff8154dc6c9f2c79c142afff44fa69d7c05c9df6026816adba44f01ce3f9f515202efdeba067c43633b1b73b8c42928c6dd805f6b72362bf814ef06fc00124f8adc16459a9cc70105a4255cda37a985c17e69db4a6ff19012819f2b27d61d6dd10cf5ba41ff9d9687868a80d3c46642408713ff241afdc89f27df7dca46f4e858ca006c719c6dfd8350932dd46434f716e8ec92708fb9a024b596405c10ef29703eab0c80b118217207d0d5b81baf3d1b21357136335e35f1684f384dbd61348dcb4fecfcdda8537ff90442cc7f4ddccbc244590cdeb7297e69911d8e7171957ee3c3dd6e08446fa0465009cbcd416fd664fea6429f24e4ff7d03f02a40a02ac5d5a0b3049c1e869d82474f38e7cbaf48a78733dcbfb21bd48f3876834fb7d3dbb0e6e88499a1f4667a79e1ced50a2188c9dd6acb95340e190a58eae74d11ee08995c6f3c9b115676dc1e1d46add0cccf9ec7aa3f7e22a970433947322393496838cab9708bad4de842e909fa9b2ba603c07f08c6026bca8714835a69e7a2822859731cf8daedc6130d1a655165c06e328883ae31977f0dccc145ad05bd7bb45f414289b5639b2814f23dc65e319f03afde5e764b557bd26fc0c2c521d0f5eca1a6d19f71117cc135fc51122fb1de31f020b6ba9d17e146522f6b02a8eb8fb559ab3a00f03924f277a104b10c91f70e58952cfd529ddfb54c6d9d696a6fbd0baada6d6f76d63e76354f22869d25257a8cadc7292d651dd3bc72fc6546afcef6f36961b5e8cb9e4a79c2a772e88992b2bf8bc8574a2f49006dbdc4f3bb1af4138548f54b5d82025915859c8cdda860869dd4d2cc756f3cf72c72e378600c4a8ddfcabed8890d734391aebbee0fd677954d4e5ffe0cbe837c1fec078f2023f201ae68a6835acc694fca58bafada537c714362ed69e4991521253ed7d7e369d5a898ecbf8d45db548be8c5c3b4c5e8c6d25107cd34c94b508d957e907252bad8d72ed81cf475bfaf1038efe435991a58c0d1a75975e883ecf84a2840b9d2d5db964ad0b8986520e885cc0e2f04f7a8368770f850ae4ed8b7befc3d25ac1356be793bffbb9423df3e5ef3a351b28a4facf682248cb36367882e19dcc30f87a731dba4286110bad2206112dc09248f0c080953c21874bb4e1701cc2a487e3c55d674331978d3ee8872999008579548b5032a53dc4e7ce0bcb5c125ee065252d977f64fe93a14dc3fdb610bedb8699c5383de3738e802c5c0797375fdba430a1af623c97ed7865b1b56d8496b911298e1cb20889e24d32ab49c48d9059f3910f3cdf6bf94613bf34b88ef0f62c7b99b7579213fc8584c1e6e7e12ca8a53d1fcbf9c3eecc509efc9cb0dc377ff25761f4573cd10e5b95c8d9db6a965acf8d1894d02b3bc4de4dffa9099349e979653e5a326cfd6221e73974535cbab6231b02cd6e016e0500fa43f2b11af54405ad811371d1ad2344e4c9e3c713194e102d3cd2fe78f5169a9eec2c9bccfe20606b80f426089f6b2a7f3f510f7799ba669046b89f08efa385b4ba31fe2a4bc230e9bd7f9de80f7ff153b753cb233cd6fecea168f9b6aa23c9ae8d71fff53271012d67a089eccffc4a94cdc8b1f1283bcae83cdee1fbe9868447927ea003a18d9c53dcbc4b881aedddc93fffd3cf8798ef55561ce961e52e8762ca2a0921d8428b8decedf366c9accba0f7bbcfbda0088b251aab3017d3f5571f69f54648a710f956ed39a63c94f1905e76b4adf53e46285038e0092043bdad82484a6af8a67773c5828d061c6d2f9ef8ff1c97ec357d9af798fab6c856761b48b12c5af541cf50c35545bba47b081191b31384173d7b6b2667b223fb4c9e75bb455b56592a611588ed0110f930b70c8c21aae149d09d396a01f3856bae3b59728e0ac40a48a5d1da9aa34c1d3799f7e6bb8b434349f5631b4c5fded9b453c6dd1b8156c6f2ebc46b05b77cd88ebe9a7365ffd3b24befd6e1c0e76ef958da3c712663d5877a55f3cbe8f62f5d6f55a7400bdc1049dd7dea7148565f942f2e62bd0592323c44e9ad2ed374ad53c9acd97f776c56fcb89d158540664186d2ecc56d7573f75fc7279c13b1a7d0fb4c7d421022a99cf85d432a604b6d14f9812b24df99e36e40552af6c6f79679a873531e8a45818dead14cb61526de27929a46a23ed7aa813ba1632825809633be0391701222b93880f14fc15a24e16022a021eef40d5c309fb76dc7b3382053a0f91cd7fa1bf3a8d9ccab85dc3c7039f92fef590d0435a10e2986086297ff091742c1287f3abb246b44000ac9f651a1ec0c5ad4591a89b6d53ea1090baaf46579e697df0e1b6cd17b419dc7bc48f1631e9dc4a3644202afa591477bb1c3732581850982c2570c9a58a3a14674423ef11cd0a50579033b92f8b7b1ca2467f2d67d0536f3b5f536c369cc4edf733e8ece9f7ed411a1e81e0da33d7fdb853215e743e32f2c706d308bece15ff1c67d47e12bc7de8fd912c858df6d0519c9e21c417c1512292c5ef47e2e7116a7dff659dbe373dc90104c24c54ab78dda01e5de607d54ba23c63a1c420b8c06d1c638e7a1c67228a1a642e8d6d14c842010cf5edeb7dbd5a6a871eb893cc494536d7c86debd80147307ecd747f87fcc150469496c3291dcbca7fc70d6400d52de558d9fc98ba65ff3a403bffc2b0f10affb3e170c2bd5ce5cf782677e2e471f30080c984442ce90e5977c88372fbd49badc52182c71665971d1d06dd1215a9b35154f5aa6fa303d8f3e2068b08cbe99b788b45f81a4d5ad45db327f09dec91c3258510df42ba162bf4a86f1ff285e333c6a25cce2fe862a10fe8349cdaf16e92bb85348eb55770a0555af6cba17cc5b352c8053bcfce813ad8f971a8358dcc123d60aadf2a64b052317c21418c5bffcb19ff536c7c586c6a68cece8a8a9b295820506120a787f13a6ab52b775ac55fe559ec8158ef5cb0223d41016fdb40d52f63a19c9d2e78e1ee2adce704453c30cef2778905c1267e3af414504875244d986e00e7757c2fb139353318de299d7fe7010fc47b1d768cbef110aa506d1bbb70538717e36f3c6ce28e52aca9f33b370b20c4f064cf6d35eafba3c67b73741bfc76af3aebb47f296f3b3748d3e493d261e60097f102de9e633d3ec53977416a9759fc8237e51eeb1513a5880438ee1c8455870cfa9d862397237e7056aea53336cd736bf5b05216dba43a377b192febc012b4de2246cb07e923c987d405dd1765498878c5d73b359b2223d3535319b53e16bf76fd0ca7c8a79f3712a1968af21706b7d3864b60d6b624c0dc2c1b7bf496564226d23850092a51288500180fffe284ba4e0fa913ad14cbfd0e8a8e634211b61e7ca5b8418d842b97ee7a8b57d1bce5bbaa77a8af2950ff66bc4b5f590d4a0fb80d019b476f78e054e5bc2fbd652ea6ab4167f6cc24ba88020d99e791a7944d5a9142bbc441050f4c21609af99a6fae77591f4b4448bc8155c19f8af4b761e996bcb01e49f6c445eece7b8b6d80fc6a81553e7afc04b903cd783fcc97dc4bcf7cc9ee3aa6173bd601e48e0c5ff5d43fd80a666654cb14852fcb1594bc7ca2df1061ac5c1292596be03de0a42c6fa7599d3cbc2aca7653064dde9575b7384d04cce2450616052b4175886e8ad0ef60614c7b44721eaf4832f8dd8ebd9fc3e00dad11c51d725f6ecfaf3e0d0bf2cde5841c02f2d1f0a552420572e24562e262740c139fd0c5164898e049477c5e435ebf60441f97a424ee5937c7d5e98fd4205b432ada0a212c310cd1f8376c38422bc4c81e057189bcd664fc3b19304eaa51d612edb33c35a27cc71f71b3bf24e1f51b5659a7b430606557b82a8e097323fc88d09f60fdc94a887590d96f4e67f65bb961fb340b7b5501e3346cfc422b73b35168311e22678c4010a9f2ab6725eb0557dab2fba95d37ad692854a4f1c5bd85edba9739aa5f4cd2e05d3dafec5e39325d53e1c72701ddf94f710bae28fa548f8ff97f02cbf83f04d332d76e1eb984693a4d07c87629d00cca29422319bcc70b847c844a96637247be9a6e293ecabdf6d81c35d199773315b6ebf3ed8e6312f326d74034590303f490324282f0bb0deb7b6afa30ce8d203762d998dfe14838995cd628b1cc854c306670703932970ab9c51f104cc8fa00bede313fae28abfeb6db25515dadb17556909d3677d2a429650f9c1b3c21ed74c5aaca0bacf812f1e6e54397525b44b7c3d0aecb85dbfd5aa2399926eb8ae8e9ba32cc3d6b874e8377225098e3eb3008fd4da60e760408862d8a44320611e2028e183044aae686346161dabc0dc3a1d935dc29afcc93b013d08f17a9b040302c9db9663c02df569aef098c11ad1634a64afb0c981315a5ec61c3402fb9f7845ff86b48389ac06978a24ec30a38687d666886d6d2bdf1f7270619f2d3fb74d5d73438f0f476a1c6c59ccec45b85f1763bd74bd08da90e01e5fe1fb5d273c3177d1810fa7f4fef550e0ba9fd1c7d69eb8e430820683e00a8d9aa14c35bd405cd74bd953ae1e88fd5d8f18c553d14ccc0c262d4525c99ce9bd743ca089427e439b40bfe9ae796224e4ca8c70ca2e6e9d216cbdb83fa62c7e5089cb283254408143cc92c7fc5e501cce858fa21cd537a4937cc77e732b9e8b775cfb7db5e53013246be3f360d74c80b0d9ca57f59b7bb98b3a98e087175e9902c16f42000bf71ae7a9514497fefcfb488a06ff062dff2f1be75e5d0890122a09965272c786dff62869c4b9a9c356aae1a6ef5770c0401ea2085cc03b4ebd85d451dd08bb23d34de27b2efbec792feff3911db4d27aa5c19249c97ebfb93821e33992757b2fff78c770d3b4e02415af0baed154a8c4ad758144dc263ce86d9ae0dc546d3abdc96c3ed7d304e280fb7bd8233e34d5e75ab2b9c98d4996fc5f75c95e36bed3b4bd3346e5fdf2cada698dd52d79ca7e107210f3128b268631abfd843c7b3555d2dd7a233f1415caffc7cc71201c802841e0eed77b285090c1318823ec0e2a556ef82fcfda591b0a60f15ffe4306b824f10ce407ac7a91fe7a4dab50bbda53351e94f44a98b659fb5a6498479ff8253b63d9dc8ac634167d8bd6a3067e6d62d5afdd6f714fe4cf10f038d07828707ec05f985c0e61fbfefae0b330c965bafa3a409f3897557f51ed63ef2653aad5626ce87dd713add5ae78e6696a3a21b7f8d8863c97e09862aba0acf43e378ed5fd7f67a429f7acf373511510a1692ecfa005e289c5272cffb1caf0ece4a465b2dbf65b2777b2040139bc650fac3820e0e148af53e7b8f3a6c8649a4c56e80adfbcf32c672ef40d30f89e06c74bc42244abf24d39aa9fea5c2677ef980ccdfa6fed1bd7f422485a4e44c895b3527d560977b5e7b2ec13cec795328b247fa53e2dceb3d0c2a2f256da17154b1c38057451f8fc82a2c677ee04d9c04e44f2b14f9496814ee5cd839e2416dc0d38356c1214d1b79f63e0b2fe0eb8334acaa169e1b5352940a9c198771dc6a329bd227f3b2b49e849c740f2702f9f5702d2dd9cd5643248f978ef2c50f0de87c5a4d7f0c688691af5e97f3500b590e98af94bf3b36b85b61ca6876248f68b19c27ce3eefd59fd1269973f892c78032b696c4b666ff2b564f16e29a5f31b15f5a99a7f96569cb90071b73aa1667cecb3072a034803ea455385ca3623625d4f79954d2dd996da01952c2e8c075582a9bbafcd747fc4124bce99d651c9bd189319b30610a698ab38cf3a7dc4bcb1ae27a1e104998bb2e0658bf3921a318bcb218aa049d271622b062c16742dbcbaeea83214b2799045936cc699fe597399f02727ee7f8c097c83f1850516b0d4c790e6b7faefb4cb0df7001493351ccb65f67b2c17ec6a0ee5f97584690f6c3559779dc7de2448ba6e9581b7f2b609fbba5a8a452f890047feb5fc3004548ac9fa6b237383f6133cd13880f51c9a086a3a03a7ea1c672880be29243ac337c5ca361a24fb7c474b757a03a85a111824572b2ed2c5b87fd2cbc79c67a036e6602dc30b58dead79a86ab3ae4e98e154aee1c3f30773","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
