<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e321537a88a445e0f5fa016189fc33c6babafdbcc0508560708a95d2fe80282a662ad1fe44056f5b24af8f80a2687325e77b57194481f2efd6ba2b9c0f134d1b68add3768540b61873acd8bb8f7faffe4b83509d8a5528b9dd9c51f5c378813c687d92a8800659c67d82e9c39fb675a17152c240a81febc4b8dc8f1d0e649a680bd4fc6b630ccd825b4b85468c8620f7c55382308309f09212b72cdb3197b4efdd4c4e0b6dcab3bba7a5bc40d143d9f9671bb68de20f019565a57967f879ae55e3fda1aa1d39462c47f91ee551b39cea2ca7bdb3dc502bc81caf0d84c12ae3247510259a05d430f716845d2068295b65ca222edf21431d4d2d932f2c1568625ed5db062b2a50813fc0892f93a43efcbd2dc1887c9b0d017a387d24ffc427a2a93427eb0368284062f4d9a7b448fd2e5f1a7b2257ad0de831a75734173dd7453c17d5f36e175066188eceae368ccc3796cadd1101b30f7091bae971df7ce40dce67112b88c7f87d83bee83f3a5aa23459852e90ef0e732771b96892ea713cd305dd29ea9d592a3711130bd62c204df3d130af2f4f3335c12e0f003301f9c114ba8aec6c222ef4f46935e9ce6a3a252a451b886b02448e3a9572a44ec740d6969c0e5d32be2117f95afd8daa259c19527bd44fb329eecfd3c80f3e0d4b9441c19c72458aa556aa9923c2d30af151fece36bab359478f5069d5bbf25593231359b2d70b5a9270bca86369a8e395c456d58f32a526f8d289f0ab88e9028db14021db8142b41133d9f16495184a51d0c173b58cdc5db4929422ecc3236523c3cb9c85ff64ec313342c3d0e2f6066ab25c6dea87243d6f144b427697808879b3deea21ccfb228bf65902acb12280dc616af138baa7412d24a3f7ff77a72c18f78713b766db98a1cd9932050bcac945aa01b4e1130528f56c24758e2a777de51fa868ee0ae74dd6d2c190573365530efea39cdd6944ccab24adfdf8f018ddf3d672f69eb24095b3382eb96fa4bd2f02e0424a5b2ffc57c61803ee2a5e4ce08303bc3749f36bf9a6138989d762da779889faf97999490fa5122b1f9bf282adc5fee1ef48adc28b81ebb1e1c55c2f8b0bd922371a8acfc326751281c57024e5f8b383da92a41ab3d6520c35fc46ed82f98cbcc3151404920ecf8ab87178e3b52e9cfe7696d307166e07944bc9ce3b56f60ebb8322bb6ed2e7a69a51da21022933d079114b4d546856c102192daaa37b38c8661086e5a4231a9a8f10bcbc56acb56de3f3450f6464dcdb6c325fc598a12c11128dafceedbb6ddc44d6f0e2994827d829ddffc1439b0fd15ee90274b1a1aa45ee8f3d2a4eb6d5ed9a288729488d396c9c9e350cf190912235958c07385d81d801a37906072179fe683f072d8c05feb2d051737ade66312b976dc0c299e41a3a8aff819ceb7c015197faaf756c48e7f78961d8e761eb9961fd651e5ae8b59d679d9e0a129934eded1304357b91c508b854952f35862b6ce81de599c4f1f4a2627887a4ce729bc83597da19fb62df75547c88b43fb62fa4411c019c033897cd4b323e33c680884827098a368e13259bde8aa0f20dfdead3530cb508186815069113511c3e5816c07ae57e861aaf845c08b1447fefc80d39744007125ab2ac53a156996f052d62a4bff9bd5523ade46f4f88dddc3ad3887b697a487c105c950b16bf4462906615043dae7e7db240345efe22d9c00ef9946e10d7bee2e3df143d11413540fab1bb05eace17f4bcd4894d1743b13ed709bc3748c98f24cd72eeebaed3a417f6c364a8448135a8030a9faea8216be7fd2c97f827231928489c488893e2e3b4d3764bfa1d4b884d7f286705e0967dcf27a00a7313b66370c3c2c884e79997fd5356efc91a7531520d03dddc6e73b44e857876093085d377800df7f2e9b1ffd43b37a7d27dcb4c56b78c81ce25628048964a6907234d3134777fda16cb0d0e5bf81f1150a923d3aaa9d07a064788e518d36cb1951c4f6a1c9338505e9c02e42918228ca154c4e248355ec8ade9186855bc663563001ffd18054f0bad98fcef7259add57407a09e3463a0a96bcb1a09cdf64b30733a93230cf7c02f9dfd7d480a041a24e5aa613b5aa9cb4fbaeb587f92ae31ee48a0a7fa5f5e60b36443b5e6f028e95833b3d7bafd830552fcc43878a7622db9499f3b7aa587374e76272efcc0af01ebf9344fd1ef7031673539dbc78b3e647377195ed9af69279273511495b4081788c73b0a6ed51bc5456657d6fce04bb33f02ddd571c98df1a311c5f4ccccdc355c8eb464cb554123a144735d524018fdaade67509900aa4afbdaceca8484137d4858e9f1f714f6943da191a549c07a11b43f1ad3460dafd79c4ee623bd71bc5f9188360993d3bd80abab3f0f9869b8c6c0f740966803d42f80831715865a3fe5b1c8ed280c10953fc276c9d885e105c77aead54bf35f53b6a5b5ad456e454b1b0cc77d3ac7a070600c69839a348758fd85d3d57629be5b80ccfd7641cb539f30f8500007cde82ad9dd426c3f69f37859829fb66fd31e78cc48d0e9ecd30f891054e721276e34c9dfc947ddad817fc7b16448b190988a612403be4a64dff681f018e8211757cf2a5bdc3561875b7a2d0bb1edf743c926dafc9b77bf3df11e3472c199e6e8b460d37a42d9621118e244508534bd2f34e72e2e37494d4232af4bf1f235d00116e171eff8c90ff79309255e0dab9a43066f49f6d6c0c0968c4107465d154880b539357d4a11249fe945ab1b6151decc8876cda121e90d09d731308950c04e41810240021f850b16c2e90cb6aae5afb58aacf27158bac33766b1854a2e72ca824ad2490b0379c8e15d45cf5cacd82cb330cdeeb5de272aaf223586ca1bf129ad51727d029ff3847e0e78d07dde051a6412e7ef0412994d76a2a8c45a2c7c78983056c5b1879af16aeb8d6b4e9904a2a81ffe9f7436d1614f37cc33ff90133a8b5963ad9abb79c710f06659f35ffa9e72ea289811e0bae2d014df826c038eb0ce67d89a79bcf566cca0286e2ca422f6492bb9d78e7ceacd9f05e0a3b242ed00a2a8110c7b4ae977f40d572b0573f0a8b41ad1668684ca7c3c60d5cc11b02f715d06195f65406f04e08e599ac6d7fa52ff461a19a6c48944bb7a8914e8c43f857f88c5d0fbbfede3da954fd77022ca89d71f7f510a79cf4a5f902b3e5275c54a1775be43a40542b7b2d99ac1ad031d20f7f74afa64b3789889693dd794c6eb78ef4b4a8b20681bbcc04287b39bcc5ff55caa5802d7f954c408adcaec33a9f43ae89be4a9b5522eb7672a79de42f5a13e9751373fbb7234ace8afb4176c4f2e13e8e892479a40e1620507ceafd20d9aea17f40ed977e2283347bb74bea820e60a318690598e96429b8b96893fa727dc3aef0750f1c58a4f4a17841957522c2a59f9d17ad500e2f6dc478371086bb5978099a1dd3987ee875d6abf97f1e992d589ee3fb42dd8a97101bddd67feeaa6c16680e4dcac22c610fb19301230bfb07323e8a119f19a65be75b2927d78d4cd3a408aeed3f0741e7fbc04ddc61557a0eb4b3f467f11ca3451bcec35e7637ab500cddd3be332823a87bf75fae81ed8a37827eede18bafb8b65475e40ad6ec75d6ae954080e08e30d764321f584d1ede7e10e3f738f52f7f5054a4b76203aed8470c1d24d10c57e5026484eadc6ac28eb7df70aa4421cabeb961644b10bc607abc40f37fb509af21b2741cbcd1a044188bd0a4d3357c3a12e09dd2b5d9e65b10282ce0d44b11ccabe61e3b6e7d4fbf66e7d825aa1908881a7792175853cadea3e78c388913eeca63150956969108c2d4f56bfa3eef6d573092b73920ce833d7ef7afffb9d60c23fe04cdc0ecbe88b57c6e5d1084450d8fc65dd7b7a8e8a579bba7587e91a997f435817006b2fbd098555166ae785c67f486736c4f4c2e61c26e36788f8ad2cbc7ded1a13830a2d98f8582a8112616c20746158c1301b8c9c57be5a81d98a26b9f39966d78b3926c58aae9ab5b95a10a0f098ca663550ceb802345d428ead345a04f05c2d334d886dfb65c744c60eb87996d39ddf23703999192bd3369d55e0de0555e6fb28297444e673e6d0180aca59213af9dc2815a141025ca539aaa036f18afeeadce8b92db3d128d57acc66d87c93d83efe97655e0ca865731049bb8296455a28304b6620daa593f25bbb6a2a38961b5d98cbba3e5e739f769ee2319d81442c77ae8fb70939e27357c5162d6eba1cc5930e0bac917ffccdb1e00fde50b0921295ba56915bf8baf453b77ca12d28ef6971bb51ddbcf675489c694ec4d6554b8a490bbeddec846cb406584fc52c87a4f2918d39224a4d609d813bd724116b1f1bd20c78ab4eb9603084adcaa7becbe606be9d11491c37dda191a9e3076f590f24e40f15cfe6f13fad206b282a66e5de37f70a7641f3d1cf4e1894c071d3f6d30c2664ec568dba10eb145ad4e1e1665ede43bf59ab0ff7e0982750adfe0e4bcbefabcb009c9758296449a79353e6e77bbb91b87514eeddaf0e1558bb02ae6148bcb15cb8681f7c45c027476318895e0b20ecbabdcfc034f2304cf22165431dafbe8a776c294d440ec0e966b73169bc1f7967f5cfcf68b604219dd440c40715b6e872825e8f3ae31df3f69ddabd96ebaed16119e486ef876c2e7b289a62bb56ae426d74045c065601f371064dde4976bc24a35c232005635ff3272cae72e77e81b6ca64cb2352900e8a1eedd7254c134ef78ea4240556066c5f8579e6fa26ebb76dd57237b8d249dac2c94904310144663355da6c03cf165e2a8c13f0ef620d65566ca9998036870c5a5c8f7273453a0dc09c54b58923f5f3b1ea9ebd7768797094d6900b5f439ed88a44b7a28ae2a540b87c8e28a74befea6b2fc798eebda9fe7cfcd22b5a42e8497a8100510f0e200be393c18c5592541ac3e915ea790fa08c3746dc3211902704317c348c5384202601b81ebca265fd18c8bf088ae471e8daee6f1b7a9a7feb87a85f1e33c5999f145aca18d91b9de8e7f2d140f7575480e9e6b8350de9ed15f6f6d4e6bad160a3b3a942d2d1e7071e1a43a89ce5a389749581b3565f9c11928139c0b1823fef00e27e4e230640ec127f6535be35c6fe564ec4c4e3cfd49cfa0dd26da4f03898979a0802b705283146de22dc960714923c905e88a0a428c94e9778e14eb82a8af71b30d9743ab868fcdb1bbe973afd4f48f443088838c74498ac4a374db546f0fd40978004494b5b57d4b6d79566f0ea60f2a226f0038d8bc1e2d85a4aa4986d707c4b84cc1491471d013fa33c7dcdec634585a755e58d1da418219e65cbdd7b7c830c5346aec79504bc453413b96bb204a2b8d7b6b98292ff590a93d5090e1138bbede68a536f4daceeaa5b79d02c76a14898f114ac9e2c1294a8cb1e71b2195f466fab58a9288ff4ecbe612ce5ccdc0d59bdf0e26d63d3258e715f6c4a25152b11e984a4c174e286adf868927781eacf14c8840d9096b2b443c007036dd4c6332c7cab129ae99f9054ee53332d828c54fbdd2d4cdf0d583e13bbdc3a1633b4ecff2ea836e415a47c5806c3ab24241fff43e45435797968ea54579810ba516f85d70bb3d1c78d19f7e92beb9a2e0f281eb1248575478aa9783c5dbb73e0a321f16b356b9ae51c2dbc48a144f49e42dd5403c3356751f2134fed9ef6d3231ef4edbb9543369db715e7bd719bcdb46a58e9d1bb02ff0e4f8764db465f9638d37f9042a9dc8d0700bb8f4f2192b331e35f6d9dfae43baf674a90ffea82fe929f172f979d9567b36dba27d62112e6423bc3d3130586a668f1a1717e8d5dd753561ac6c179872c2f376cd74c72a97c1e0a308482fa7d8cc1c2978cfdfb54f7485c40272f65d20ca889191aa086d1a5df55792f2fbc35576e80f312918e833bae23ff396a08ac31af2d4fbf8534ca838b03cf282ae31b326194d42fcc73be1526ac6522dc138a8eecbf0de046cecde240b3d45e4462f3dde0171a45c5316bb2c1e2b73bae229900d108fef03e439f879d395f0b6af2f29d799b40987699df02ead009a123d7ea4499c60f55986f2c09be032acf8592844eb587d9d3eaf34c546b3680e20719b9f0ae29200689655d6f269d1154f9cb7e795edd9860b8d4b2e2238b06db26257ff98168f8c1a9f9dc37b6fe36d459bf2cae46d21111147f9ce01c2db0e1b0bb57e1550a3b312137d993df4e98f8ec41f183ba9a13b66b0f35a61132441641f6720ad36e2cdaf18dde0b3a8fee7e3cdeac3621d35f303a56f9a30ea2ee5a2953dcbb1397f4351466feb20071d8b86072712c1fc5d5cce217b4570512b650cd1f52ae983b353e1d9009be4395914d576e604e2767dd3e9b2ec80616ccf6199a384ff9d8816a6b40e7b1505cf1ad70db18daf0f322c862eedd9aaa506c5abf8afeee6575ff1262c85ae3aedef3775a7ee569b5caa805811cb92ced9ca1ac04c56ca3ce4879f0cbda43d7902ac244cb033669fe92f2e00e02809ba7455484f5f0232d4c3c84b29090248bda138bf118cb7a5fbe58a60883b4856b1b228f20a45331a37cb3ca123b714371a0299751ba210cbf5665ce3b34ab2b66fc58eda350d2dac9576c0ad1d81b75d87b2c1a9a9c68f9d86fd3e9e2e7e6dc51fcd7f0c4030d6ed741b4efa25dc35f4ebf7afce9569faab7b96c00cab98ed56d4be2e8905fb2d84c2f570a656e87b415f2ca0337c6796866fe6ec00bc15a3000616283e9e4118fc92b9d6919959dde52598a81ee413531bb57d18a6e09313225764196ddf17cf511d6a760b982391d71d6b31606e94fcb2a59b7d398205209581576b7542b51d95bdf819d978a5d57f7cf8969e29e238aa8ad21643e5dbb680e2d9cba5cf00f67ce2d23be8a2e72b68624d7aa5959dce61ee16c7e620eaeb911ea0df758119f27fa8c38c66a319a610675d90f8274d057d6908f5fd7d4960469a228eaa29e0858845494e77d92348c61191d0e0331e56ec3663163ca6bfb0c50c5f53263396ea16b341910b1e192212e77a8684f5bb72b2cc9ee22e451c7ef6c1efd075ee57ec6686db6a99aa25cfb70ef91c8bf1f745df67c42feeb81fbfce8449b9a0ec21a566fa7a54c13c969d006c5122a066253d0830d969ad0becf0d2d0c156d934ec6d25442df0d1bea2aa8508fc3cdd45e2e68c4dd97920e4951b1f0bbde07d9e584123f86fd9d4eaccec8fd667dc4101642211726b74cfaa7f0711c3cff8d69d3deab8a2253d42962381e5b7c57d562b6829bcca771e88ca39b24ce2f047d3945f0c44d5b3b2b42b690d1ce602b43bf670bd80b10d01a988aaf7289f600696c72db10ef8daf4a65ab9ca64182008e468d130547f8ededd82971cfe325b40c0b82a0c3f7640ab3f61d9ff5aa3a908393d4bf16ffe30b9b497f96373febe8f88434b760b5c2cafa612536098bfb3d7247d631e48694ada399abd4eb0ffacead9ef431ba68e4151d1ef020903033f275bfaf3e28b01d785700709fe00774563085b7058ee0574b863fd929a3cc5f3c09515cae84af1c8874016fa0d800c94b9515f0ba71c996ccadf1c1520adcc3a76550758f72f1c8728819722fe9334ff2e89c3aee2033e59c11a6bd80cf5818ff87b231a31829a0c5f2e05c73acc33365cc9f86d1cd8c3486c452739edc28d6852245253b0255af379a215a8cc17f862238382816077d0b88eb540d06db6339ad2a50e24ca0745b0d980c2870f891f812a9434456d0ab65c0fa0bad7e87ffa40abd06d81664a04dd3916a6451394a4aa208eb66fc89ae779f06c004863a10e23f3ca180335b5df5740d6f157f266a7ddffc793bf87f3ea3266d85674d119d76532cd6f9e61acc61776b22c0b8d776a7aaa51f1960e7f835dc54528d18d1bb3324682fb0a6e8b8fc9c309669f4cfd5b8b7b0f0d055eb84512bafdd7bb47e584b5e2444937aad12f12a404b084942e1c8ea204c3c0336d18b9d180c666afa05f0dfc4576b7050e7f280940f83fb1029008aae65453a02211615acdcaf4cbdbcfe80c702dce2db832b6ce1fe20695f7f01dd854d909e1c15d7b0f8b83728cf20b8d9ff9e9a7a7ee8036b1faf9dcdc2e51233f19c9b8ce4b174dee255ab8a34d062cded310bc34d74964d8f505cae804db1b88b4b266762b44739fce48fe9d7d326866e686a1cd863a2cff7ebb6eb9202aff73b77a9c7558fdb603b2ceeb8577d6f62066703b77ac3dd8b8b9605ecb29d02013cfea64a9b282f27f05a2e94a73047a52638e37c1a766ba259de0ce7a5d76fb32fe1abc15319f5fb444a4619ebf7f34753966ed6e889f1b17d067e43d421c234ab40e702e18ee8cc12be7b61d8c533a09c7cf6bf25ca1f671e9d368e1200e21482eb27dd36f0cb126f1346ab909872182c37ea07fa1bb03bfcd8d464400277cf2595581a72448b8870aba69d1de78bbe2ff07384787d8e1bdd8c3946f24ea22ef6dce1a54fd6d22cdfcb1ef4c5a8eb3a7c37e02016d94f1b95b867414915643330fc606e84454c8add6aa31b95d96b99306e439ab505efadfba794be951a0457814736e9585360844ea97353a843303b8b8fc8775b77291a2b916bdc22ee5fb4fb0357ec818124b831a338576fab032a849e38850ee5864fc40e9b16803846008b520b7cad866304cb8ed93e8d0ca14f3fb0a5e2d37b5c5f7e902665b276c47b1396b222e547b738875724f71bde8ea439f19132c8e93cd65f824123dd20948548a14d20674c44b35b1fa9aa66fa4b023467a55ed474f4ff88d528e88e6b0a1946b42bbd95f9d6ff54b3493e63db63b78d113e7f6d610f1a072affda0610cdbe8f553c7c5b965d15fc4e2dbff6bfcef73dbd50caa3ddd4e0d7c87ea76435d993e46caf2c55e5d9ded91a0c47ce92edcc05d390908f66e7ccd71c6583982f99f05ecbb530f64768c7de34de6b5b198bebab9be9441e1ffe64b125be23be5a75ef12987b384c6c47b184dafa4d72700a3dc87ff3b44fde1f296b81d3f55c567860d6a1d5bbd5f66cc366adb5127ea40b2d19d5fe72b70972ed84ef21fce17012ba68d2477fb75f17799f9be3a5d22927c417d1c1e1cd746c6c24ce70de3165a62b2984ff769b5955885e4d66601cf92493c0d0a0a36b9a2e09de1b16c6011d1f27155d3cbeb44af379b38e993fbfa084abc574871fecc32d33c12746b3f632ce62d27d27516ef26c21765cde28af695adfd5c3eb7d53081c73407bd49964e5774c6747096a67ca4ed196b5b712ee2caf250943627ea817f69674594b4a579e5e366b4b815bb0efc57fa1c56c1b0f06356e3268e9df9a5ef3e228736a0cf10e18b18dfcbd1bda404f71b36ad7e45583650f10f1bf3793ea374fa8f802d6959875a3d55600f26ef4bf77dcfa7641ff07bbbcdd519f3d10616a01172d75bc6fed5d67ee5fde377c9b6d65d0a11b74a178cf9bf8f41c2eade68b4ef01cb0c7a67903d77565574f97d6657a03a2056d5469aec48d1f3ac7033f7dcd79d40d8484ccb6570fb4af23a4f4b07979ae7282bf7b46e085fb3c7a11b0f62d6dd5e0b288aa7d10ca1eb37a84d0c3b134baffe5cc43f63500db3b642b04b48ffef5f011c0c15562a4956fce57fa337f0d9be37acd41faf7b31f529afe220312783b108f88bd3dec4c8e8ea93d0aa7b0b11ce37120f32fb98e16fe14a74301324d0ca125b5d06101257b1c64b9b91559899f5823ff80fa52c2c7b4e90e68877728411ec5522ca6cc3433958501ec79b59a9f208a01c547a1a3c88244390b61480b6bfc183a289022ea246b3abee5ef70e65239da593b972502314fb204d8c1f34d17e41da1d6841c4d202e0abf45d0b97843b194ca889fd6580df07244cddfa929ca18b5f431acb8d2b07ba3576431c36d0f1de6168a414367184c85a8745b009b81843722ed82511538db22bec61bc4a3679c8899366d6f8933a13b7f05eab963c26e880d08bdd555a7687d539f863d244a8b7852f9d2909ad6f6e537a3e270d77b4df651637482a725f1894b7b78ed951ae472178667b804144041d79db489bf07371224d8e67723df7791037627a9349e61e31aee6e88857e106cafdc49702f6e5b88c731c8acbd8d59e042bac5629357e067a887bbc54f805a8ae0414f706d827cb590629644108eeea09c1559d515bbe9d82f7e22196a31e846fb72225bd50662bbbf6dd27244f81ea880c9db54bf16abb0175e771e2e228eb236bc74dc477a00d61f84ec0733483fcf4cc89ce2a1c4db0aa9cbcbc97a13856e6921aa264eef7c81261ed7001048c14e7a4c916500a46ba88fd3003842caf8d60f3341195fc2cfb55bcb266b98db204f9b3a05a853881dddc2a0fe1ef61ad2730f97e47c7cb487f215eab9a6e5e44980d69b361d127d21da059d7648c40a4307e0c6ce52385b63ba15b1aa6152ee4e502031e29822e4fe57f60623e8293bcb55096dd93eff1485925a6b33dc71b5fe7f7b6b11a274dfc96330185ffd922faff021dfb4844aa06a4f8491fae7d0ea554a91aba00be0b428a5a848fcf943462807f03189523de8a2c65535d554bbb04105363920bb0396fe28762023f3da6f84a947fd85b0c8257ee4a172f74bfbe2b5a0fc1304a93fde890bff931688b8152cb1744ef83828f19cd6fa53af3ae73545dbd5ff78a18eaca6523357985152cbd09b1107848b84a86c17159e3e7e68d4a176f8708607095a2e8b0037912a25b15a7f027ab30c295a783d98c2917ceb31187326810866ce296de0fe76436b9971bff2e193f610bbf55829770233109b6072101940cd0329e644db3cae2a8e2b735e485eefc7228f4f9e4ce85158a3f50492e6737ac75c1820d7d5f15ea13e966b335a9bb4d8dcf7fa2e475e315f67d913a99e9b532f2d639f5b7f87c09555de8d37a1c61356baee4cf517594151dfc70ba79dee19e536ed005c20dd06278936bd5d7d2baf3568e9967314102aced40ec00c9e1c48cec25f00080baab3a5360af1b335b5316130417af5f6c05b9956722b8c23a5de0507171d9d3e58ff63be5896dae661a0f273197dfe2046a747bb59912c9df6554738051ef4721d67cbd309c15478575970105632b3c873d77b75264b14a2203a849c44749ebf2a6621c9bf54104a7481e04bd74beab5ba672701279b608c209fb97e856ab36a532898d0ff7d96deb415305b1bcb7c6b0a7483e5f29d057ecc2b682369bd7344aa25491d86b98c83070ac2fd329c53b2408428698c63e8c0dec61e9964aa68bca99e570614fd8e49ac65010ddb17f46a771d3b09496c05f0408c1f3c495d6d0257e63bb33ac28f234e411390d9eb1977ff807968f2234af29cdef1418069505ff901a4231c2408ba722438d1f6c4df240f890ce09acbd98c4cca1729b7a27d3ef37cb2060c4c4aea56cc005273c890d64b809a839e2f0d68662a5d6a600aaca7e4f6aefc4eeecaba385c48e8c1bf6709b4d96053e448ec7153ba669298bd4994292d372734bfeab0926abf7edb3060583210f0cd4a646a1395440a4f40171f656f37d1bb08d3cf8b577f5115ec065913c56aed78c0856944b54482f5e519f7d41323a2e0b46896ea6d316db741b8553aa2983a053ae058efa50cb3132aea75c920f1c1855ae2b200b4ed0473e1b3aeca55bb7dfa33767a59b74f8e4c7a85c162735e97ed37e33527e627096d6f0cf9aee39fd16fa6c5cf5cb893ea4d19bdb485f7abb2a040251848e6aeac7d777b5999e96c0b8c79c8ae72b66a4b1b36b645cfeb1b8d4230bb66e47e6e6e99986bc6c493ee791af869cffc28d83088aa689335a6366543d36fcd36ff9055c3a95649f416e9903fb8ba8080708a3a9c240a6cd19801213b11f0c4bf21ba6fcb2bb9b72c915502371947100734e2b0d2afed9a2283e082da676b42abc9c242f8ab969da47d0eb85113fb46e2836cb49e73cb7e9e0484c34f711d4ab2684f6cf356f30951eff72a4bfe69febb59f62d652f7110a3ddd3229d732535696d6ad35fa47f76690bd9943854bc7bb96befd3cda1848439e493fa8a5475f401ca9aa7abf03e84a1243a815b9eebae54a24275b5f231fc9cc1db4ce51401c297731151be1158010c71d1220a02a0cf14e1f97d137aa5f2805a5d2a8ffbe98d743963892b5e4e79489bc35f6e84a7eb5598a6ad8dd546e0475c5aeb95ef28cd381c8911af6c03d7f1a52c3ab880449e6afcb2a90654acdfd0c669bf8412176df8efac5da7203709a349671d7c12a93ca1f8293140693629ac1e00d27ab24f21df6bcd73c913536e33d5e860286cef47d5b35c7601468bd0e163d14486c238619ed89d282ef12df39447618d007e576f239020e1622de08a54b45f259a23e2159ac10ff0f30be3449c626908631b8f4e69e09955c0836920c1f1dbd4705ea2e702c673ef0fafacfd0d01664d0051a4e1bf08eb123eda8336492fab2f0fd302e02a1eacbacebe3a3c7514578243f8442242312952bace329bb9d50f40cdb9079978aecbfa4c9e5151ac6a497cd63378dda8b3fa3b994b5475b9cb7bcf4d4794de20e7b322f6d13b558a86680c26e68ceb2c67d6523793fc19f9d3261f4c1f65250c78719c7aabba00ecfa36d747f1f1304cf5003d859057425d857dcdcf8a213dab3b8f1d27fd74b4a7ca5caab1b13412a94a3aa75abdedbce08ec43fe5df68ea20fe371e225739d22b936b5ccbab5abff8a4731213ea051a80cfb5ee5e96a44bd207a0b52e82708e8b238e2feb2a4bfcce647a51cab649cbb32cda1ab87143e26ae4c650ae36e4ea4ac8daf597486bb8c5a600b5c2aaf21eee48ff8f9f80636d50ef9aa492d6064ce09b02f8bd44d9cf89bf6d2b2d1adb02c45b496093fc034f94b85d15887ae3ee80cbdbc05403f7f55a9157118b1da156767a70b540f804dd56ca190c6c4a1cac457fbe7e73a939fc72842d9764527199e8099c8df3a7971921fda600f787790d251d32111b03b3787508f654e1130285f8921005f9a375d3dabcee67618d41a68450b55fbcea014f58bf16b900597c10e8ee3d36e51469ccf2c1486e184fa1a3a2219c5a4d99f2ea551821782e1c3dcfc8cf9700fcf914e0ba99213f17ebcc6b2fad933e7ffc8623f8c5889c110f9d625492d2a81be2282dac7e6a8fe45b22518918d2474523ad57b6ba4f4d5367fc130d5a0720e2b8a48002742e58c6ae002f2d2d46b2f2a4969783412b13a944fe8b39a7ac0b8182bb7ffc747864b1397c083bd647c4776180f2421d5165188b808309b5ceaf04e968d0ee7f74cbea130e40ca182fa62f119082288da472aac10054cc805fd324a63f086666d2451bb9c8fab4e038858696ab16f5ebafae3a091cd79d3ab05ffa93328c8ca386fe7d735bd515859594bf2328fee2e527825359918dfb99254c13668d55e029ab71aca2f816d783bf6a02cd0d9c7ef17e56d4ec9ab8dc20972b7dca2f75aee2676f9164e42b146a91078d0a84e49396b2ec1cf5728aea7ce8a3d1c4395a87bec514b47b06af60268fdb1c0cbcc97096dce73fd09c1d55e8a1d612867d9f6ad1ab70dbbdf3688c2d63f05d8ca98cb00e780c6e22286e9ea4b698d6dcf55c115d4e403d20c8cc423d4ada80d6f92963228072c1f233049593b1f523d773de35fbf679beaaee17311eb8070ca3f0944424058c5f62b11efb214e3c3e9f810a23f5ed47d4b0c7f4befa26f6d28b59ad108322ee9755f3b40dd93c59daee93b13c3e51b88ff7e3aabcb4375090aa4122d27d060368eab0619c6e4278d18f74e24a0e267c0610798724a8d26205ff0ab6cba26955c5547b84c95fb418c31bc9aa20f43db15082a0c9524dd83e62b69b1748a530cf45591c49713a937032f87d5b4dafd38ec2ac2bf2ab760c86be0613a178861fda00e2a5363df12df4514e74673f2eb8d1fb6d8edf025f97b9acafc1b2bfced5ed2cc1ca43ba82e93aa29c40f5e007b29a5ca80b487fb9a53eaeb42d029a5877a882d5a12fbc2bb90711503979753445f07c049f9e3c0a967394c45cdebe015e593d49865c508a4a11d38f6d346f08b77bd2f99726a216e6ecb020530cdeeb2f14ad92410fa799ad58abc4f3f0329c3644890e31912a9ca5c2dcf1b7a11dfe5454df219cbec8f04c28abe43dbe992f4f71a678fb3327b719c6aa17ae377a95c6b445873c543791615ccbeca97cbd26062e6c66fe414c0332fa3653787e703810e3e29e0a9a9e205c23628614ff54880e3b741483aa57b77ad4814595e9dd3f68098efeb912b0d40d930072a0e08550addee46e3f8d6e68ea8440081e3285e71fb068dd507db6f56501beafdf6b12dcca9782b2deefc36fb303d7b807bf2cc165dbb9dfcbe71ce32cd733356959ec9eaa13120168e7dc79a95e6dd3c7c40d4b0e841f4305a451c5122d28d82664ba2c0d0dac6f90faead7e5b460377e2794e0ceea59d9012f052e5fc6e0bb6e98eb766c9fef2034df025cc09ae50f20ec2bdfa407a6464015d9cec7e212f832b505b99672cd99ef11a9da9bebe14551662a3347c5e0d621ecb2e4cee9382aac7cd4ed803ee8512fff7d35e5f1a54b84b582e4f4f6c60ffab1248ee49dd5303a4a2f15e103e92cc3eed21c8c729508bfd7c6b8c3e7f28ea473e57f22826ef4481ee3e08e73e9094070774d9e8dc720871e8224c34fe5ed63e3c912e0494e17ed428e1ab1acfb68b283f54cc6a69defa4d8a211e40601b7e24a3adbe51e91c2a1dee5f524abe81597d3eee53ea2cf452e97dd124fe93a967e6cefa0c98eb8550fdfe8f16f3fee3302b75d49012547a01a038c47eb6e5ea6ceec49c9a3952e36fc5266369b49a770c1eb9f8ccb8e6460929c50bafa95b71bcddcfeff8a0ec4a0a8ff36a6c27ae11fbd34c0131431a12795646b216a59bf05b4b391cfca2d98fbf5d9f7f012ae7ccfb92e7393d912b494bea985bebfa7ae96d5da40a9502247782ebffa71ff61ad897631d607385c317fa86303e4ed6e9056e8e303281a3dd7fb99718bee7d33b2700692c9fa0c5ee6dd0b757cbce4e7770339e435c9a26000140e03e8f75fbf1cf62500bd88b86b992d37de5d9856ea7b04cec9490d9830ac6bc1b31e71fb4e87273ad05779b5074f9eb06576bd2de5d3e15abf608003c1a6a7658cd865bdf7883b4638a10df5a80c461f60d282bcdf84113085608fac9a48a753efc60fab4412bc8644ea8bdbbb45552565a7384e4aa2811079f8266557fcd0a9f25fa800c5597357f1a2b9af740bb113402d78df4592cb092b7de87743f2b82f1b161d6e35611c87a15ae61bddcc075aafdc7e3d8d507a0d847b5f188fe63f5d50d4d00022d339b2a4b105eda8bbfed4fc2d1603a80c5de69eabb0c4989f8d1e3d21afa19056de956dad19972f8d9519b4953af58e19014317d455ac153fdda9aea599c4fc2ab4068d9822aeb25329be47e685144defbc8fdd1d53ead2b8b6fa8cd586ddf3b545a4deaba71c71a3786a26f104cc5674cdd4b06774f663c2636145bc7f23ad9e644","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
