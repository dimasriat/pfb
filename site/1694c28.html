<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cb11fd43016591e153d372dd485e65190dd36906b4cbf893cc7806cb4948c2675b379db5c89f031ada2e672c11aec24d078d49f6f7a17a8fa943d0594cae0f94d1f6ac48f8efecbc405aa013c2f17278c3f7926ce9eaec8e2440eeaca4cf52bab81f5ab8b2b1994c4fc63f495968df0bcc296e509615fe9a609399ca1ab4bff9f2f889802a6c25799c75b2665155916c86a21929990aef28b3efc9737796f93afa9ab50297abb9015cc7aac68bc2e57e99aa50dcf7607791457aa1c71796ac4f1658f241e25c54a4baeabbe6e9b75417556868d32f12c0210949adc725f81ecf6f5635879fe26ee1edcb6aef6b400a73919727dcefe4f012e9cef7a3ecb4008ae22e57c724315975e2d8928b1980400dfebc4cfcc073564e901782fd496b752639fd15c45e626b3e2752be4d1aec3ec16a368af0089d8797eb46e83c1f48780454389c18455169650d5144b10434e09eda05126cef4d286b2eac73f6714a72f455a9a69450657e3fc44288462a9e0d930c008a30e75e2d92a83b1fdd1e99482455b99aec59e34e08d48b5fca0a0354ca4be13635195265c3d02c00a5a1a62e9976e8ed85bdd85db20c120cfe81ff30c187c0d0c9a696578940a2b771f0bbc355a316b2d66d2e81ab23a124dfbf65506a99164f1c5f0ddfeab293c571fc39d59cf8f8dd690fbd36d14298b58e7671227e924ffc160f873fd8933aa50f940fc387cc7dd3048e040e4ba8857c9957c674fe2afe35a0f5112621b375c451ef143273909fa3948c75442c4308892d4319bef068b19cd829fc29603a2a017f31511a072f6d915ccd216243568caacc0553662bb6d9a53a51d5cc0af557fc29eaa18ae22fe8d6478b69e6a0db79089a9dd7c77754ceb23b2cec1ddfe847f3908117410577b949a7d94c7f0a56bbfd534013d9f9f58cb5b5b17eb2d261cfce59d52dcc6226d13097887ecb2647739b6c69fd204f36a2c4836e4b585c6a9df78e06cc8e94b104eaceebdca3a57f8801445d44f78a47c9440672b5e19429a6c41c18baa8a65095505bf21cecdcbc8d1121162e0059f28a78be8fa662e548bccdd90db1c5103b76f00669203a7cf2304324ff5f104f5991a221ee23ceb3851f1691e6cf902f9e20e553f734acd14c0b4996a3c395e81f9e1fdcf1ab8ecd361b8cb00eee705a762e2097eb1a8e6630bb8145c763147463d34e5682424dff4f055f329664f14bac1909f2709c0ff60a6edc90005b2bb2da2099b9c325a891d11f91e7e87b3dcff2f06bc732e16b92210c61d1d97ddc38caef6218799aa0316b749287ae40692f2415c7e78d8d2331826993275593005a474d5030eb6f1f03807d68c521d0d261df85b9a3c45c1f5d6c66ec24f3fdaa178d254113b08c72e5d973f0024bbe45826b963cb0bb284c35d6a3b8f08018d8bdea46627f89fc8d8904e8d593d4dcd41beb7c71699fd261692a2d4a79d6daeaa254a6004520638ae5009ab2ad1018cb02cc131d9524cb268b31e930bbc8e24a1238e001674772cb0f758ca4ecb0b91b2b3995a7c6414dc2057f999e22e8a57d6a69f6ffbc10a8e19e61f8b0be488a2b3b8eff52a8221a76c06a33b1a60d71c72cb65efca117e59c4640bb561f89ed95555371960a69433dd9f02b0117f65f8c79bd28739cb0ba63ce3bbbf96ddd33f4130da0d3f8e327a1ef9f61a7b217f0c7c6471fc998bb7b7cf8f12f95a8bea1688afe1888e4f85b036dabb0fb6600e2f2ef72906d839194f0845af634f339838d2b32ed849e7ea0daa35b8018109a3343efebfa98967d98388c4e8b2bfb03ee0c2e44ed30df6c8ca2e8e33c9a372514d3d16aaa596335ae53a521a597134d06c20444b622da8c5d3a5fc0dc378ddde45e1498aa7fb77432d8168eb86fe4bf2c6400657c5da49f766f17c5defbba52cdfc314c62c2d62ac2e64c406bb316a2bef54fe1fdfb1dc2ca4c9b21df248d8f0ff75836a153f3a140f18db6902be69d71de5e331e449b112bae4b05ad7137b5c54070470ddf82a28a0ce9c3a3881f67cb90da08cc379e33519faa9fc684cf8cc12ad26a1fb6264b3e75bca98a2e2afa3061eac525f0b82c31dabd053390be485caae17cf0edff6697740aa4acc60c3638a4f736d78b4a24358611501b709a89ab5ba8593f7bb60f544120672fcc8336d85bc3622bc73c117d17aca099fcadbcc4c0117f3293b62fd623ec236a7fe1ec40be0830c732ce8f4b4ec5ce620f185c1ba1ee04dc712d8e9be206739956bbdee6a84a607c49e9b8497b2ca0063c67e61cab5ed7a5f15cfa52b7352d527448b525f718e7fb00715db531d472ab612051f2fc861144d8d431a8dc0673f343aefbeec02ec4ff48c96b80e55b8de9ffdbdb5ed5b0b9e9eea0f1e812bbfa346ea4dfc45cce9476cf9ed23feb1e4088c483d1a4280e2a5eaaed73fa79c8b61bb4e3e77f8b612f1dbad87da7e6284c9acae3e2831f6699b9e69947e3492f3026702d1ffb996afb85666d8f236bdaba8e9c0bd3af3cd0b40990199f9f23288694f89183fc30136ec0f91878c5e57f23baae8cb322c473ed62a4a97cd433b9e1348ff28454afc4cc94844c5c3f851eadf424adaadf19925ba37535fe58baee5becdd78a785597a2eb47cbbcfa51d0c664f2224a065542404ae9fdd3cefbeef57b825d494ce0ed93c63d1a57fe3bf059a097091d6302ee808fc9b6a435692f79c63f79c5354d402d309f9bafc3152ca0542944095822781adf253c64dcb3f92e4b50282d0e16f1f690f5d743676cb253a08921c79cee3504bd4fa9405fc022920f42b1fcb3a00a51d0952303705a022eacd47d45d835ab921577835b022a4668d5598c5665290299cb635334a5ee36ad3e7e413711242cee034f22ed59f765729dd54e8abfd93cfdf965dab32d6423c138af7488158cd768933886927ac83547d2658d4a7de45f795390d3b79d1cf0656edc1197f797c085db66951e7072ea5c5b6f11a2383b863fcde5c9456480024617a60b1f967ca94a5cf27182c4855528d916537c3b4558cdcab621084969169d4388cc4ed61782fcd66859c7923bba6d37f97bddab24654d053b916b6a5ad2b851d9600a62368f79dc168d05ac1fe5ab18a6f667a4d5804298cf8f5d5ba24e6fd05a0b3a2e209cb3550613c22965b1ad32830bae7dc11162ed551595bd035fe3c1f3a2c146d0dd070f45cbfd77940896082be280339201f7478e7d50925de9f17568a651015d7494fcc98e06eec54cac1a2341f3ca676e883c2a8e6f97778831f268f63bfb42181a19a8e3bb98ed18f911641e6e18937f51d48b50422b0553a6706c3489aa74374a9693b5b2ba78af877191cf8daba9137808bc6e2ed2945ea9310817b45dc0cab7bd7f9e487ba1e9a9319db7409efe0caa3491421c12e0fe2e84755d515d8f9d368c06e1ecba9514f8229779919c9203d112a605eab24200353383b96d974be7aaf15de412294a9e538c91d5424fd5d6612b2524b8e06f248560f7ba37befacbb589c6aee1a70330b3307602f2c03d73f6cf45c3cabfd570a5825da84a1b1d3b46a2316da46575cec5fd807416d8db32d286603a48e7a6c226a14504d311233426c519b231a5590732ef0302fe7694f9a5cf8684001fa368eaed46837d15540bdd91276e23be5ee515257e71390dbcefc15b7bcf0699f4c9a31983f6d213852d9042056d359347029a76c2531db24c5e84366c50696d03eb552c30d31ec87b0b19b91f1021943f3907b5965fc13e7ab39c4b2702f58dc9913942d16b1945236bf6725c63eac8d9284fffbfbd23deb359d05e373c292a413bcc3e43e10f94b8cdf7dcd8caf52b7dafdf86400b645c3a494ab11d24e83590a4e138c640560b1b26026d6809b6c10bbde1bef59d8a91fb80bf540388aef695c8c2cdc63b2b185c498ab5cf7fa87dbce3a3b8fe0fae60b016c43d24ee7930513e71bf7ed446fd9eca1417ae7f26626accb943b365c9acc7ed7d3e4f41289857f5db9bc8160c3e423a750d323146816cb92870d0aa248049238d1078979826980e1ecfda124d272a1afa2ce7669bd97fd6fe4a2e9870a9947d28154ab8b27e852e1df9c7c4df1bb40b215e4e82c13760ff2e3ab23949beae68c044aa7affc36506d76ef1043bda34db188aea3ebd353c2706b98edafffb96a1b1b988f2282e713e7ad3e6c2bc3d72bd398ecdc11eb838c00d5de8844fadfcbadc7a8a977f76c18974a74388e00d13e1d6cc9b83c344136344baffd850df1a0fa6251d6a87e3bec497b3433372f97b1bd4f8e25c15426a3db3723137953695eb8c1ecf4be007c8535b595213983b54ba6ed32e33b272e89b1d5e257169a858e744ddb8f1843ef1736dc659c7997120570bd68bd2b19f4df4f2b6840c510eb470a5c9c255299e2ef613a6ad45662c11f2c43c192672ef0ed01abdee54ed92b78c33fe5ce414c831243e50229b36375d47b738eede7267b0bbab560cf1ccb50a5fc83b139c4fd9267ba948a9da6b0d2f1220b0d327086c126c1788f1c99c47d244c24dc693d3b4ea4f241aed00287ff65fd2b23aaca5452afdd624c1dce56b8af285e671f64c7fabccb27a767943692a5b7e7c786a7798491b90dbbe5f9717610f9c720b39d9d40b8924f8dc9a281d1688d1df3f13dfcd93728fb54e5d9b5563efc5070d41d6ec88d94e0f7fa7226df1848d35c7decb1d9468fcf5c3c1c02984e0564577cc7f768c32679819dc94141e95e275c0f5d4ed42dcd140d35dd5bddf79bc0aba4943dac8cd07e2d7754caa60663113fe9bc901a5fa9ac0817a6f8a83217f287d3bed4b5a0f18f466d9ece08c4414ca746939b619030b125fb993d1bfcd9478cf82edd4b8d3d5dcf0a157f1d4b6d86233f023677a771a2128fcd570a22a9f4e23d2b0c0d4d9270b01aebbf16c589d6b87064bb5598be6f57edfa86f853664e9437916ab0a6779d28ab3ee24f899333492dbbeee53e6ad937421b1b0e78eff7416e2aad6bacae14e4ea8baab7b838635e7bfa61c90a99035b1fce72be188096d09cdde48370285c2957fbc3d55add3c213183e254f154ca6f662cc3062909e6335d7fb54a5321a26f8dbcbce9cacfa751f0549db831005a444be95e8aa0e2440477d46a02e5d9433e4968ec71366266f7f990d5868c07ada8bb81278d16d5176297782615744d7fd99148f128f9c48becd41f22b553a63908161c2fe90c5273be0e9ed9442d03e4e94b2ab1d8cbe7c51ee17a63b73ca0fff6fef84b155d18818d7296209a713147b1155e8bac9d2d3e51a3cdea85f617bb669c2e5473330284ed5f08756c718f44dbbbe962d81a0152e70232936791eac91d1c4db6829f56e4dcf96b78243356c4593e2890e8da7b116ab2d85bea5075fd94ddecb8db6ab9ecd55cd74d5e627a339008038fd52e567a612e154fcbee0c509e6380161f8c7cc23829c65d412b0d0d1f70287af8ffa7c21a09718fb2d9369d05dbbdcbe521c5ff80ca40c9f74e258d0133e5fe7d448b2627fa0ac403b8878436d6886daba36e1ecefaec88769fdc3f16d3c9c5542b5afe35e04dc46fb483a425cd0d6955d4a02ffd7a65f30ca20e50db817ed0f7d81a230498e72355f5388f837085579cd30c1d82df63fc4293a500ffa03c94075b829f60aa10f377a5188b212ab5c6f6738cccecaedce2f2a4ccbb3bff7e63325c47a4e085e3a488c7055aeae1ce2f2be35e424f93915a223d9c8026b21d0ad2f0ff7d5c9a49c3cd753ca5b1c9570bb48c0e14f212303629281ca50a948812ea81b19955861c7beca996a309e421f6c27a50b0429d6c6bb427f49510fc0dcf80d2dd0fdd9156af9ccf0a26723f9a245d42ee84bfaa2a2cebf005e8c7f66f0d5b8d0c2ffbdc4c1a7b6b4ea31a3b202fa05616ed8f5d5e0e572bb2cdeb1d3dbdb30cb3b8ddb299c4012e4d6e2c14adde73e80af27b1bb7d979f8825763560a9e368f2775fc60e06d57211868e93632add186a41730e7417ef867fce4952820192268ac60fa23383c46c182538bdf7f3688c261b6a42d4c91cfcd99d286e4eda450bfcff35a23532f4921444a162c20aa46ba6750ed3c9a23ce6f810c15d73cd5b9eb5d1c93177d55a035eb2a8de347f3a71608b6188c77855ff61259b8addb9c4e9a74312baec08eb0b47baf07abf8b3f1486b5dd2aca00538cb91e7a3d90995b779b08dbaf58ce3a54eebcd02c8155b2d5f765a66f4918cbe255e13b2e8017de4cdc9f8b8b42649b219c946107d666d0e0c73d0130609b2428d1ccd9d2f370cdb8c1a4700cfe2c9bcf91ca12b814d49f26dbf68a81d5840915506fec3ecf3af912ce0f36ccab2049bbe5d0cb485195e0bd0105a1dd4baac9e9ec69a8412da922ef2e1526d2ce256d0dd7babd48329c136165f13a2046f5fbd294897411b7a299ceea217043963d29bd9bcef2ad8c74e4bdcda11baf483d414d26cb14782dbe9780d519400bca620f885db6e1973b7cfd518a223a00e139b8e9aa8af52c35cb4aeff3fb8f65f2bc4ffa34a197393aa334a8d93cd3a24a90708635de1c19db72c75184f12c5b2c1b4754b5e3c20698c845204d6aa1e49fc2d5736d9c1e42c04a33e870779c0510c2ccbee516fefd5687fc9b4cd0a6d26de1a4f154b1e5945798864068e7c88a3d48c0ee8cbff67111b90f86184b8459e58ebae86a6e306b76cd6e52385d3a5e8303923effacd5e7225a365ba1c6da3577bd60d55df10424339040727c780a7c607fff8777a63cddfc3eb81df8c5359a821b5cf1f3a43bc2fbe5951b8882f365569de13d38652b762aef0e211e4af1298e38eecb5a0c504e84420dd190d7c8bff044a3b9c4fef833f5f46944be8535acb70bd1dc1bdce38f88845363ea3ada94b8590024b4d63ab8cb6233aa69b374287a925cf7ded9385afa70777eb1585f7834f53fc7ea8c8f30c4a3343e75304a288d4f3714be5f110cde10e7977ff55252b1c0200e4ad2c10ee6ead7eba44a6fe85ab1c64fca9bd93a2332dd941eedd259da4412a29f2405092dafb77aaea5d0b72ca688fe2af4d889b7fbe825d1137226c773ad89ccbec05f30c63e805eedf4bb30b4180650b343ac02174cedcd7a9b1770d279b2c0ded75fddcd1e883c572b7dfb89729d934e692bf60226b8a82e5b22341dabed2a32b1eeeb371734a4a610264c21cdd3fe5d4c4fc27315f58b7a5ba266a8cc464b5ec1926773cfa33d237e16c7763c27c164061ae4a16637e8962c58f2bac265488a2fae07cf02499d559181d2b9abd28ed8f3dde82d5700595bc020494047e7b65a5de36f508acbaa248104e55a03b14e0bbc1de0f068b9344f377218ed395888a3dd0f8b2d09a0f70385041785fdab3f353680022d56358b7aa9fea97047ee42a019afacdf80e2839a8cd02fd3a751cf944f08bb2a023db8d18d00c5bd793ea2d5b2d0b03d697366cbfd4c79eb2191de949dde1f59c01319e0a6744f6e578ae41a3ff51d5d27de24c97f29371add3289d6cad52895f2e2c0216cda5fa939b16a00b1327b9768d9142a8f61199454bc55bce50c655118b42ae971d401b6f468eba961574dbecb1a7770190eb0aaf4edb6151e2e542924d18ffa6842b48a75b537e63daf62cf5f53b12aeccfbba95e14f65b8071f4da2650aab16a03dfc49f5da3afba34683b60156d6fc6cf3a556522c7f215b39616f7ee2b4bf1e1ef868802981689a895a783eb28d0107100251dede335e3610042c0531641607e1d14d698a07d9c06096ea5e02e69fc464f6be8cbfeba9f22ee4e72aefbbe0773e59f6d78590640b086d4fd0bea0b1b93687699309c9a2e1f2692249369366d0e1fba84182b9e1e84d3455f945f21d884da5dffefecaa69f8ed84e23c7b65c007ea4d75bef26a852ac2cc1b490f038bb7e52f714a5b581ddc25189a5e974e9ddf7eaa167035229c2de7305efcef3c7edbb96da9c31a57d82e9bf0cc155bf26f897908cb177283a4b8796a6bb1acc7f37695ac359127c687ca3a62b3077d5768f311807bc69b971678fe59ff0ce8d235e66dbe2f499db6d68e32ed9da1e596f2cc70bffa47cea5a3302f61d655464900eb7adbe34d02bb4de2edc0dea0cdc4f334a308c40515009202ab69e84f93a56c69e34e837bc7294ab5d7857b5477b494568457c1cd3acf77132633a9ffe0a0eb2a9f8f994b851971fcc5e39c323d73e2202e7bf9d888ff6b4122d08d27613532532cccf31187838d9db8e44174e97897d47fc153169d8ada649edf13f9e917f3583db17d07e1cb3b59902fa1fc0e649b93739ab74fdccdaa15b1895876139826b6199802558e55793f9ed1c2b5405b9ba66c4e69e4a57ba6b5c06f1ccd6b297fcedb321f9c9f1a9be70c0184a4ea3a4b56caecc4846cfa00c67e912b0fc23e705c1ca71fead1651cf17b8de2c23628e3e61cf4564fdbd388a2f64b500564c412f914b49fd6bc2613347bd35883a3d8ed8014a09e27b20a03325f6598a0bf99ba40e7c6139e0f3e922eefd3c3ca320d74c6a56bd8d9033a04b26c395ee101157ce3a464455a92e7921a0ed9d7323e2b9ee6c96493ac391a567606be8af6ccb7be600c5ccbe8ede36133c39ad94802d7a60c21003e608a9e9a9c1eb3f2dbd29d50c2739b46db96e10e68848136c869409ab9bb2dc4f6382093a5db2939b3b9402a2d0ead835dde0e059055e03d6f9fb74d31b64af71c252a6f20fdf2309c354e697ef5fba1e2374473b0760747b5d744b8e68fc6cb0fcf6310cc54b1e72c3b01fb34560829b7902e698aa042f1e8d815759199b0492b045727d724e0681f366f72d5060262a03a3f44b1ec70c7e825ee49d3d913dff7ad1a82f4a4d877be2efbd9bfefa4204fde65d52cf718c53928549c0c460bb38e55d234e6d6c842c013a77c4b87fd80066dcd2106f75f4650ab467d5f024f2e506e6fe821419d71f2299d5c0a268e2e2f270861bdea00183588251a0ca0844896715b014ab1dd4693dccf60832c8edcff8a969ded90daca256aa0c644b67e38da8ad9b76e09c11e4df046e7190b372f6c04cc5e2842c56f369ab8b24af1f8cd87ce5b9fbf1ffb9b132085aee4f28131791d1e385deca9915522ba0dc74c8b0617e2025e4a48f0739d4c2c86fb21e786e87cfc341c88f8797092bab1c1843bff2923c8c31fdde6095bc4454bff0ea404a24c0ce5ea64fe53344266818f215be0293352be51a5f8ff381891083ba248ea29665b547bde352b4e0463149c8975b8d441e54491f97c15fab2ff89ae0634eea42bcc16dd4fd5935a2c70b6a2cda5a395d52c4047947d45bbdf7ce8b54af2859f247c1cf5f0307830ed564305f12de4d5fbe1d0679a90d580c69f88d68e8dba1bd713fcfaa3a0a326b130b706357a653becc4757fcdb8e614047ff7874b59551b883595d92ca50680f928c97597864e14ebaebba4061d1f43a1a97af71b44a4cc5af9d790c433d9a3e60df8fb036868b847c27a4bf114c050c668721d886d0a30a95a6c665105f45a100b108ab341568eb63647b84c420049afbd590cb6c4b3815f5b7a8d39ab50c2885c28008f2be6eb281cc5a079fcba150363e9e2ecc3c08794e265f8b52465a0bf39d684619fa6455d7f8c1a2f131c4a2b83acd27262319a50ca27483ea3ab218e5e3c8608ea901eecf3424c0263cdc0ad07acb4071057bb9c150ec236aed6e6f73a882fc436977f9dddcd9d8554cc2ad487d7630b4d88cd2d11dc7fabaee0f8ea303c2dcddd6ddf1a2ab9dac75a6dd2af0d8ed5877a366c68df014e535e87d9d1f663af317971d244184419ef6e52dab96e22a71213fb38f05df16f8bf9f1fd9e39824ff6957ad23fd6fc8f9d12f44d2d223abbc70d59c0455b5bf517831cc0759369f5d1f6ab0cb0765174d078706eab89b53e9d2c0bbf8c3a8e203d2247cb3655c3dca1919d4f5fadddee3e2c9ab05d03fff06c5ee1e193a7d471838487d62c848dc4e56fe8361c36e2477a0c3803bd5336dc22382d45dd496a7440a7a7ec47ae570ddefe6a775cfe4a0cadbb24141397f082e42e50a6ad4d9a01b17606f1a6964215d9a4888a6829a2a923207bbe6545e5e876cb40a19f5930da567c7beeb1ed31193ee3d9b682d35d29ffe8f62fd59d0a5bcf28090028793d44b3799b9596cf9e6891e22f8c78d8b5c9d304645f01f4f04b747f7bc644714cb4591d764ab0563d025326ccf321b251b70abb6520b293c0558067d96e4289b66ffdf6cfbb7d8567795a3a88b49056eeac555b68e109360630e9f538c802ba8e54992b1a3652f8d590f2bbd4bc8bf66dc579be823ca20f51cf063d46e1abc8c58e5bb7e17cf356230296be9d9d428514863d4c3fbafc0fe6a0705f16346e84961554232a8b104e7393a6541e3671c2ab32810122c07f63b2e8ba8f07f6b04e580f750fd6f851b1e0feae7cdf0d8c4611fb9dfec834a1116a05a5766968456138821e42beedb463e7d0559db187246f6e82cfbb03e973731c0fd2a02132ecfd57a4459dcba214714e88185ea749c0aa427c804be0a21d4d26695cff78832de907b77138b162d1602bb7eb112813774e1c6d11e54857d5a07c40647a9ae789ee631f2a3c4fa184850cc80d3a2441ee796903092acd6fa540dd8ac3e885d2a5a71bbcf255024896e4d63232f3b1d37b05f08e85348cb95e11aa4da633f15744f7caadae33deffc6b8f0e8f0eaf046351ced093308b55e60cca3c251d281913f8d26922b6c37091ce687ceb4556ab017d92650b862969e197c5c2dc7414f070295d973c7cdf86bd98db2138be1b74281d323daea4e6401e6db9d0b2903a8510b45ade8827eb8ede01ff215b8109a4207eb016483eecd150978661824d24556e06fc3f089a337d07e1a9b7dd77f5680c60d4c10a9a70802ac17e3f6e586e0e890023dac7a616a01253ea3ff48e233f6687a6e56dc26484ae8bcc23b93c71061d7295cd9b394b300ee5178e0d441a0d2a15ad1d84d3db62eae2c7fdf077e2a92e5267c2bf660b1cd04c423afca8af88d5868296856d88281397c8d105ffbb048a051978054c229822cf745a5338ede7c2d242d2abfe0946e6e42fde6f3ca1e361518af0dbf962ead301efc0211b97d850f74aa4cc0006229fd4763f5ab19fd25dae0b95f4d096234a911cdc1fb0aa2f5af12f4aeaf5451c2c56c5aff62e2b7a2577f4471e084681e777a27802c162a75d67c948962ed2e7de18ea86ba6caf80ad1a3d645a8473410e62286b885adba9fef1dbdb212b359d628482d6643ee4e53d371f89a8ca0adaef5413d67c59701269864df42170d17dc71a40c5bb8e20bb7971974a6a83d7c4567f69904b31a940c7be752a641ac8fe05d7ab0790190e0e6dd9a20b0b36c48d5713819fd5b732712eff3835ac3980ed0a32e88f04efa8c9e176faeb867156531369ec10bfe22b187c1bfdfea686508b5ab32128fbedb6bb78a9b76359ac37cbde745f52cf1e9d546fc7dfdd519d7511af7218d5c5299aec091e8198858edec0ec0f7e77f9008471d124b78cb87442be64cc9610b455135d6cea5fe06e5d17bcb85359c5c66edcaa5d1b73699fd561439db9a830cabde3fad9adf03a89b9a008798485063825f0a7315e7e51a7e3c9fe1f06c8cae0fa1af32411841a15ce7479d4d2b80f37c553916289d68a84bcda92299369bcfc82a1c20f39fcf8f1235aa64b72390a21c784d8578be5ba970ef62d92353bff95cfaa91d14b660c6997d6cc311405481d03cdeba57990319a50cfca35baf8e08b7a0c1328c8f6056eb3cdd4509dcb0c84b36a9bbd4a6d89ba2ec66e9ddab5e5cd25bdb7f4e03a154fa403a4fb4010aae1828825063cf1f8329359e55b3cf5569cc91b55259c663fa50ca49bd0268db84dc647af53a61a4e088286edc144f5b5590eb2bd2874174e0ac5e5ad4167472a4fc0b39ea2a50a6c2d580af629f670188f3d72f787dea6cc979a3f89a086c5e59535e158f987660b88d6c27afdb55cef070126397f9e32921a03e8fb269a344d40524dc13c5c9c38925517b6aa7fb33a4d60cd2de195a698c314195a35a189b5b91f3a44edba2d085baf974354a289338c085c4882d4642fff75ded561f5edcc03b11ccf85d7f0d2b6f1e94bff0858282254e9d70926ff4dd4e3432ad52a200598b20018322f69316cb8777392019b8a6d2da020c2ba5a74a0042e98ccc9e73d1da2c6fbf17b8459840d04e216c657bcd82b083ee6b49e4f42f72963d053873181786531c06b0476d8f554496247943838dee1b3e33e44663021686f73129f8d96a1d72c11343a93ff194cc4a30c210f9b4afaa7292a1936f9d17896b74867740c4c38a6fdd8d057db6c1882be98014ca4bbc144c198dc2da0e15bc1ea6208193309b826bce9318b194ebb426c82e6286c78e2eacde9e1c8e97ecf9ade9caf69733bf0301dc7eb078e60c50793921f57c3e74ecaf5e6301fb2ed255d17ed21c93bb4de8920631f47ab9abba8fafb91eba6c3dd608ccf0cda6fbaf67dec57db01978d5935c8f491b5c4db97cf58af52f56469f7231da010aa80c617261bea906f95aca85e92a878c7ee0b8235194d975dfb7994254a4c63c83b055fef44504df4896eb9374de8acbedc9d848382e83eed651db867a8aa69763ac567c5921d3f6054c149f64c35ddf6bf73a00929755d5ecc885c51231f80db17ef91102f0d9a09f9ffb5291f0eabd3295d338a12e445235fc6883cf5b5bbd66e2f6cec21a2ddf132859061f32845b5cd8264451c04f843bef097fadc639ec44976657a55b211afbd352ffc665953e65810f80bd54120fbf78220cbf61fe5402ab40c6284a02d4d070d404e954aafaf29a6b17176564168ab227778406985a4b35a3cf6b5c113ea3feeb1b902f67dc76b2a6361faeaf4234d0a625d740ec8c34f6057f8cd53d94d777b364e5240ca52f9df93b5b74f77ce5350b778ac0f2444287ec38c92a20511d3a6d0eb9198d1f9264054ed1f48780c27e42fcb1b3b84035c92df062375de3684a607093fd47ed8ffaf349a87e63944d4d9cfc034e64533c74fc6902631e9b21d4537384f1e8f1ac8a69f0b93679a1b150e43b53b422ef5b2512b40f9c33c1145438475811bab1ee77cfeff5ccb62e0f980bcc81358b1c2bdd1448100392a46622d75bbc7bdd9e41d720c7dfc54dd123b6df3d50ddf8e44e1392c19cdc899c7ebd677d965513c2f5be8342ad118edfb1952b8b5d8dd55ed11adea135ac41ec7f976451aef8b32f803bdf6df088ff79b35203e15b5c1a13ba259d38ef29bc90a49ceea2ae1bc6dbbc7408a384c497a458c3ae976cb8e2a76715f00712e041d3a5e263cab07e27bdc44410558ace8977e7bcd8acf1973c059ba7ffb1e78b1ab71f5e234067ec952c7c081f8bf49b31ec050316ecf56e7cf309588c08cdadba9590ade75b82e94b6244a367687ae570e2821171278ddea0e097e02e8080a5854097c4e9e4e9fbfa53a5f02eb0ccdabfd3f37f10b11d1bf575452f9799a5548d16c11b72095e97716550462b02199822f4658df754df38c931c4bb4c4076a8632fb32241e416f8ee8bb72aa7e07fcfcd30e23395fec0a201d075fdcdbb27efc7aff1ad12e3988fa31ed4b3cd4f10c0eff919bd2385e035c8eac8fead7911645221c02b8907f2751171c9ec82e76d8e511254b2af9963560ffb9de23d1fcf9cee423e806931848f66851ebf2ac390bb8b32e197c04ce4ccb1f2f4fcea4cda9a861a65f849a5e267aaedd97e14d20f4ee2eefcc8a95a5e1c168281965c58e390dd2ecb18fff3c3a1bfc633e64f4a7701bb06f2606e3a8186813838bba4235ff44007a93487378ceb2593bd98ab691a4957b5e7b7c792b3edfba5ac2da2bc2618f5bb0f91b60b9280fbbf275748d865ed04ae5d0fd4d90ad4521bc163b7638fc653740d68bd7216c34be3ab22ada982cb50f4861ba6ca7e2ee83dc4329b52a30a89d4a3cdca836c1ebde9576e1532f8760b80e7a1f80723e9c78a6a60b193363dfeba7eff9d1006d7989deb492254054fd019e9896d8248346ec674dc009176c683764d949ae8e04d4c6cbb803be16e797539d02f0518dcc8c43cc0404b7db926f11be0c4076f9a7b280190a9fecb9c974732acc2827c214c564b017bbfd11fef585e1cbae01238902549d4957012f3bd02e727048b716152d7dd76320714169720d8f87d5d3322bcba13ee7b9278902b6dfad86e3d6eda8cf493ccc8d5797418b413a9aebc33e8807f392e4964199a21bb5d6932e5a2a2df99d09ac5f08ba2076fb70ddbcad7725f6e94b513ce50355590f46db742cb246cedecb365149f6a5a7ac3291277404977c1a0d513289714f14a9a3f57a07bd58eb5b74c4e4ebb272121a369677a5e193c4523d47cc512f25f225c7cbb58b46411b644b05a8f284e1bfccebfa809202d7178db9ed690eef4a35ee68d87a3e257d19d355c11b47110bfc6b9b7e44718570eea6579b8ee29882b084a8233771e056d957d69676c4f463012cd539735a97d34a428b64431d15ebb4e4162f765cac598eec855cb5cb923ed9a34aca29fb955517c6c12336ed7f4bda090e3317cdb981ad620a19b2d418567fbf209a9344893fc29488bd819b221286943ff6f4aa7fcff3f852549b4b1689a788430f0c8f290bde4f25c9db821f9076f3045026dba0e1354a41f3bbceb0deed6b337012d74aa04719718a8e5a553d071b5b4de298c2ee97625a0b6b4dea394176350f9e64d5ceb00c65b96904928ee61191ae1d3bfaf7236822f969b792d370fcd9e5f7b57ab05a6ac422abd81a758e0643fe1f7cc358292a4ece269126110e04642ae634272fff3af38e9d31497de3916ff30d402e2841f3508a408342792f8655c38b0c1410383ad2e67202e1234bc8eecf5fe2e35c3b1f278c7a09e7d275f125e69a86170cf0bbc18c4269ea7f39236893d9bef50590e8c394584800e40511cfad11e37104832ccd64a9c771e482aa43fd645cd9a25690d055222231fff973dd96c61bf1dcd2b75bde401cb2befbe1d5824dcef01bdcd36fe80f3ac606af8c93f1daeb56c96b60c28f06c31487fd818bbc7c8d604f15d1c49ba2725219c9acd485c3fb7806d0740c0d58dc2df061b6eb77983479bfd2fce0179ceeab2103df4d691a445457de4c955aea982acfcad04f3a6a92c2a4d7f6d75d4b160d38cc549600bb8651675f858afb8f1e3c6faffa484f8ad71e4221d6dbda48b1c0c1c89f367ffc363ccc105ce81e9c1cbdbded7922a66772d712e40afda0050840b54147faf58cbeee2ae265445529e948c251b927c01f41cdf1a629c1a02b4dbdb6b53b0148d332c6786bd2fce0f9a4bc4f0692d62472a5051c6721d2accdf36c673084b2c85c0e1cf7a1fc0cf0ce391290f45ccaf26f6e16d8aece268a11c7750b9300e5cccfed99ed9f58465dd5e8485e01d0f3bce935c9f362510412f42687de0cbb1efd98619ada4233012c0edec777b311b14e6fb173293c5d19dacffc49fa3332daaa3e1f6fd8fdc48bddd85628af35337aa1dab0617500ff4afb1fbe6b609a3f3b77739d9ca247a78cfd9f9921a0d8ad14f331c66b4f008da4f4a55daac5ead6004a0ad738a31783dfc91a91609bf2e574cc41129051924d77bfd0f8c3c75313a00ea40e06eda0575e8e89225b813fc321ec8258d7a54bb9f6a66b79f4f38abf5282d4d925942a01b6c91f27d5ae4760d79a7359310226bb2801befaf850bf1b7fbf86f6d0ac31b7552f92aa974348e85a78c275ddeb48936435d65098f2bc7130e2c599a9f71229aef59ac08989e1e6c69990851b285bcbf315910222faf3a3c298f9d96811fb7bef6e58a236e4dd82aa5995752a48e1a6ace6fec1975bf1a0ce17c4e7ebc8d5415c72be4695900c7d4e5a48436cacc10a8454b0d56cf693a671affbaaff384021b4a03d968475e1ae87f166e9f688f0fc8f42b9af2780edc5586bed67e73f34441ecee3e5571e53d43c5273ab4908adfa585909e05796bbb8a8b7b9a04962485eb315260a59fdcd170a8932f306763f903b10e6925cf3c4ab0a8e4c65bc2b94b23f0846f13215751fc411c151eb643b8d89e5aa23e352d48d6a0d772c709f5c90fc055795aa0bc44bc4eb0ec3976a7fe682b0ad84a87f533b61146cbe02ef7243f1d51e96090753c40e18e1110142cd9512960b6bde9f0e2e1d8047da30cea06f9613401e0d2a3b7f0506fcf096b063e861f8f1ad238bb0346aa36759dee1751bbf7d9651a4058d71e80f822d6cc376fa96696ce76efb5719e0c7254428d1cbebeb6d32a59de36d25ad56efa87a44711b22f622be083cd9c2b8340ef790fcdad74630821c8cb40bbfc4a67f702158fc83853e096222b769678a061e5fb1894c4f0cafd29649b95a8980b51b85aff960d2b8187250de9ffd885c34bfddf8589a1e98784b1917ca0dcb22160f0146bcb896ab93a5c9ab38077e9ca9c582fdf6adc9d61ab368d8cf44c8d640e889517498ac67c0a0d78c0d5989ec2e4ae4653864dbf9bd93e8798fad5ac80d918edd123b66f7c918ab8fd986fd58c1e08bb851e8bdad0eed7673523efeecbd0d8009447606a591718559cdfea43b188117de9fcc4a88da730ae43b02971d4e37babaac85d823d20faab354ea715442b03e5cbdf08a04c53227cfbc0b1cd088745139ab9e69198fba989c80bd6c6e3c91bad91a5671429701342815eebfde7e2c51af0393a67329bd7275ae07f31dd8a2c8db147706bbe50879129d737a5e32950500224e70d9545f9924f0c58a05335d811187b7064c9a1cacd9d467a6750dbfbce710963697e3d2d30a88f61ac109541ab986a069c7b07baf0f622a15b2e3a136b37108d129507a7263e672f01dbce2fbc35b2a80394cbf8d50e47b3401ebd1bb80aad6b721cc0a0fd51db1c375bff562fb2e9b9da6ab3d4941bbab74e241a5302ef8e4274a8386faf3e1953c9077d6d9a73ae76c139a79ca3222d7b31cda55541f938cd53c6705d8172dcca26d4d53569e36b9f132986142e1c7a80f7de0c77708f1cb0d0b17d97864b9e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
