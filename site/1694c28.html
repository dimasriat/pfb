<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a0d6ac51f2bc38299de1ea6f573842689bd9720962f1c5b31bb5c9ebbbd8b72eda7efa851bac26bd93d1cf44d69a7264bcdcf04de2fb235e718cf295dd9e815415ec8c27dedcea314b46788bdac7709e33c2ad62cf8c2ec78bad34e526d395da0c99fc044194f1a92694426451190a821d3e6fd99658e79cc2d26d5c6baa358ff0b2ddb3c54508fbfca2e6a6282a20b847c178f70b08a5ba9af0cdf3cfa53515163401ad4cd9ed2e27dbf81aa167d815054b08b356c45d2b86012ae1f8493f0291fb8b00eac583012ce5512064fd7142c9dae0de74b44284d857b382fe8e6f9be52d38282cd4073ba176916b9c95a672cf56c1de36e6fe2a490540d7cb2040b27ea5d23b3fa1419ebe1d73ebfe21c1eaa64c8c5d895b45ea6642b124a19ed5123f838c235b8e9125d791902e983facb77551990d76b3b8ad6ddfd2e9d6f8a5cdf7bbe3f78a86b97d989db1e4b501607787139c3e3d401eabca452ade4c9e5728b659b2d4afc5d69f428a5af2ce209d9edac0c16a64bbc65132db7ed2a564ab31710016a1e25eeda18e726d657105774b6e7281f139d369d126fe3f15e39778ac311df045b7ddc1ba08afa6ce9293b3cf738ab013b4621ed0175574f45ef8ca692d96da2c34fc895f7ece7d2eb1684bd6456d40f2eba4c9e558880a62642691b5c440e8099d6a7ffced236874e57678817f7be88de1c2db2d53aa821254f0547159624f922c5e84d2868ec0359a20cd82196f4851e9769809586e606c5d07921800f0d8dacaf0c096604732c7ac312e300d188f8e65dceb8bed4b76355756dedea48f840718a27429ff5e80b3c087656aadc16b2cc638224c3ed0c8692f1134cf20894344214e5105a8ebc8584e229a7a0f93148164d641126bec2e878a30d2ba225acec1c127b380d041cc13c5982b93bee1ac70d2abc358038186c2bf3f0f777a1c620a5eff455a562fc01279433ab00ff7a91ff07caccf8820b67a8d28c91a9d3ceb66c2389bf75e9baa7d486f5fdd927b7150d97dc256a58132de031df3fa215ad1a8769d216d3e2484f57541d9bd27e480727ada46274ba5e23ea9d98b90032c0b723d166087bdde0e3f39a6e2c9aab6d2a978632baab2954e985816e1379a10f6f3707b612e1433b73f32cd0567ac0b171405dcaa3db4e05499e46be3726c60416f815946d77d99d2f08132a6999551841ddd45083f6bcbb75c75ed5926732e58b623c64c48f3a2c7dcd7ce12641cfd2e98a1633e8761a8ea5e141c115a5ec3d30ea38815bca21c6c840691976b490182f5eed31057ff1f67bcd5999bc48a09e46c1be0eba02f485621d1b51cfe9920e4546295c3eb1f9b0a260ed1ad983b1cbdbf245ac5656e8b11c88c215db59a2a6c5bd9ab6dec47a06e0cf7dda9e8f262b51efb486be0df7a34629b36a1e2875b35f6a46f7b506fca6346623c674a0f0f8648721102c4bf5c9bd77242af51eb2c0fea370ea3610794d9c88fc50b842850ac9c70c968178146d78d82f542b12893671028c38f9287f45c8d373b5d219f26a0cf5cad57ae2bd7e9056622304a9ae4ba24f7220ae0a7c78efbe7622a8a30028763075f3c4d64402395be228c5ce792fa9c01cf570d6a2826f8ae508c5f8850ea7cde8d94a46b505066872645ecd10fd6a8e16b8d6c9901952d48908df9a3a700bb907744bc02a9f10fc86262ab4770caa623d2dfb7650a2aa298032534198c24bea90c4b64f6a336e531a8926cb2a29a85fce5bb0dc937b0f33c095f138b88303845de3c79055e306a186595ee7b2b869f9106977f7dfe9ce2e7eb46aa260ce72caaf56fb4e710006b21ee9f7c69dfaed7d12fec762d7c4ea573a9ee228e5e3e66270716adb1ce041cd1e42715fa9e00312892cee964903b73e9c0a8ffd8ce3ab8ad5ba341d466a93409c095274471745b6ed307106efde852a787565386f071369aa6206228898e0c938add448e0e1b461988c62154b416923cc3f6f1c70cf9bf3bd55e7c151b5a49c8e27f782a06f01bcd4669893903905fca0bacfc8c6cf327d6e69cd980ba292aabc22e34c5edf773333d818555b28731ef832c0c5839c35fb99bd65797c45e86c23b423d44e35dbce2abcba9873dcf0b135457c9d008027f5cf23008064e2e04a14a575e718ce9af2f646a35fbd13aca7195b0f86feafa9f0d024560aec9c4a097dc09f8a4449637e5407273b14c98ca8e0f9460e76f97843fe9cc390f1702455db9df99187a376a9446dc1e790710f42e1d3124a8ee7f6b21b28ae1318ba8bd0b8a716065b2f385568fdb04d96f97a1ba60e0d6cf86f6cf1846a6d93eeeb172575753389649297c3a8547c9d8db702a1f03063e7137d267f18fd04529f5da45c0137ad4ae6522c220813fec622f8e4ff6661e98280d5b0b3e44ac95434bf8c3ae7113028e4d443368e36957f7a6332c9ec3cad42e1852d75ade70723f7edd1956f8b20d532e542ca13f3b9c866c6ef13fd1bdc0034ded071a2ec61876de3c8b554c8e3687e386dd5e97bd6365d862699af72f69961326df360b2397d4c2f552f122c98f2557b7e4cf339ba64f510c27d249e52e30c9dada345a9bcc9a03c97e5b6c5ce4ae12bd305974b6446e6ec898724f246a05bc178329bedab48dec373271c6b0de14e8b673191942b43428ced8b4af2c2574455500c11d73183db918661437be0b0a2950b991363d6eb44e53aab41d8ae24544d078762e309f435c10ebb444a72163dd130f66a0630bc31f88d0d4bbcf359465a9a98e05d20757ee24e0df624ed3aa98411727a8712daa28a033adae472b13b579a6b830f39cefadd4c1738991460629361c8f69c43531ed9bea5903011463e0c1249bfb80fa39d21c4b38544ecc2ad3976c70ed9825c1ed74af37fbf420a3ab7dc57826be92c1440d055b6dd70491670299acae0a983d6235d77828274ea27b9852df23d54b241fdfef712c4ba004933bd8a9b43ca45c232dd2ae3e729e8303e1ae595e692332d415fc32dc9394e091876862bae00050b6aec601744698779dd1a7d2d26a06f626bd1877a208537251794518f4ce67c440ec29cf448811f76341c54f3ed32c2a3e470d3fb237b72dfd835ba2ad43d475f162965829dbb688fab73fc6ff767d106c2794d08f11ee0931691a5ad71bd8e2cefcb73b700500793ab25ffbe420c5989f61fb750889fef93ea32afa249af9e76ced7af13a95fc5904f78b61570dacec77af9a2fe5405cf05fbcf89765c596c7d1c52d2bb0aa04d5ba720edac2741c7d9bb8aac7db74dc8c6768122e4885ed37f1f81ed58fac7b43faad22a62297a63f753bcaa7ec55fe2bd6d1dce53871fc051b43e3dfc26c7882c56dc72e53e6e788c26a94bdf5e4eec51fb4724b52a5ce952d3bcd9f4b52a1b8f62044a2514c0277cb69018ee48cc2ea2ee246243b0784c5d574971b967de556db1b38dc0628f3970d0dba49d34537a7eca609c24f37342c63f2d574ca5320dede5319c140bad359f73c892b56e910a455884dc0ac0aff857c4d1e5ba8c516043ee972c99e2de86b3ce2f1f14fda910d8d187a7b7077a388a62195a247b9423cae0d0c196f240046118f2edb3670c6c2f6b9221bfc356d58bacfd2f4ed755f3bc205c55a92129e9395b93c1b75dd8ce50243c0429bc29800b7f1d37fac88c2cf8dbb18721d301f7ad076b71ff780f4df443961ec69858f86a3a3683e344c132ea070bad01b62fe8ac831010370a3d86c3e10a975391d63c99b5bab539fa5d64ff688fff6b917b5e0d4c3349a1e79c49ba8cc7a13e275fcfac3a45bd15baa0f181e0e9764114d5be4561a3fe12551b3347dd83192d0dc17ddd586d29be16def217f1c56985ff58968d6d1ee9f22c136ffe3fe952cff3d37be6295e5372a7b301cf040e05041d887ce881094122fd9ceacb4ba6484732dbd25592db983742d6f82b04857a20dd3f71e9a9ea382bc293e9169fb8261d94d1ef90d28af07c628a67fe8b4e6e9decc9bd0eb9e6a5f71326091e2777758ce426c6dc6c819dd9f5343f7570ba8405b76c25fe65b8789ebbc57a20d195a68ed318abd76e39db77953633c9549f4521f992f6706af50795927fe6800ca300d4dabed160d4d9f85505750a2d5aa4ff928fd89adaf59d1d8c3be74da245df8b46b0e396796a3fe02e13896ce36e841e52911513785e418669989151f40a8fcaff3629b7d747a10690c8bcdc2edb7a31e7dfffe8653be2a3c22d1a4095e2ac3ef2dd8416832e6c2c9599a3b3100df6d48930d66b5c263f8636108e3b84051c127519530747c0429a74d9499dde3e2959af8635650cc5e504cfb5c23e3e62c2bf3cb6409695472620a2c431b2ef532b14be4baf213f2cfac135f12928b4356350bc71a17d355abba72e5e9535cf6066eba2d0cf98846d520f42fc40c785f39f6499588193a6f05e76c8d31ebfb77815f6ef643485c7b6ae30ead63ffa35d171b1dbdfbf3b9d9c3d178a71ac227c87ed534ceb066651d89969bf4d140033302e7a8463baff6e47207b8b1befc743f2a7cc7add9b57b30cb839ab79e16f7b5c6599d3bfdec9f878671e9fc45432c84ad9462d0f57a0c9a3cd0f8f2a67d2c936e4efb9c5eabcdff2202bbda52b2ff2aac0c4db80cf701aa295639daf6933a6e9dc0322e7408495d55d15788cc372cf668de563fe404446d6130021eb3d6c24d930f1c7e0f0db012b6590d9eba2fea4bfc14bcb32888bb23144b91dd728ad043369c8aac23f5fc57139238d3e9cb483e1088a413dd50114750882356a5f2c65efba285699b6f9d8cfa6b69cb25078c3fdfa37d763efbcfc1067deba48b03e87bd390b1a25fd72b4a56147cb5fda05fa2f6c14363ce39540e5f7a59cddf53cdd015429f07dfdc0321af3495d2284369535ce93ddf5c8cf0127443e9c2eeed9bf69c98f7bc9eb2a729f72444c03fe6e9144080c54fa2155e8d2e69c2ccd8f3ae6daaa8d624cd7f31a20b9cecb7f37af0ed635c1d6f39b3a2c69c1e608bdb7ade3953cfb665e22a818a437273c25b959a2fabfe41d007c3eefcd1bd008da2a788d73fadd0403ca0739b367f6e8573d2348c2e635386ba8068e3dedcf6e60f45c3d182f8020ae2e894b29824520c292fb2155e61a53eeaa1a5a0974a23c019ed121609945b7ddc42e06b9946d3668e00a7362209a1e4f70cb4b5f61a1397b95a877704c9be13e62174983e6e5aa84cef5057ba02c52a31ca63f5b16fbd8d0b0d316d867a43369bbd4475e654689894eea3dd717ec78cccdb107b1601d59f40cfd202a9320fba7980e3000f80afe0eb679ab86991287d4d9e837ba124c7242aa996497540c528cc1b4b633edc712e5eb2dcb3fb9251eb46d24f9e0ffafd7a429381107cc12912a90805948fa2db9fc5d53dc9e088de3a339b05948a0165bedb643d45923ef06f62fe135bc0dceb5865063b2426b34a4477f4cfcd828a53b61bccd918a813e292225f00c36d5c6d6c8fcc03b411c4ca68c3e2c259a1a1da1cc77129ee092bf8c62bbece9f85e33ebe5cfc4473c8628adc202c3ef59c2110d3cefbd74db4f32b03d412071a9e8f29477993fd10561ae59655848945934643a71551e7bc0f68947e7d24cccaa290dd4e3034db88ccf993f917bf43125396387622f2c238082110cfe9ccb17a1d955d716733ee99716121f76276cb37b3cd31f160a547e1abe69ba5318c05ef6dc2fe5c4ec9f4256a840072b592f490b108a9cba63cc2f4cd594bc49ef98110143c3664eabeb4e99a68fe2a23730eceb02e00f6132c869a92458f29748daaccd3c6e3872fdfd082880ec4955e21bdbe9db4c2abf4c3bca091afbacd4d714ab6b942932b279c69bc46b5ed7c9a7b431b60b66ec13858df3e05a7af2624bacddf81539af91a1b74677c09d05ad236306c4e4d328df5c9c757264213fed2f5d7d98e98f0842bd71ed50c29c5bbbeb3eab8b1103eba7ef6a449f53df4315bb5ada6e477b2a199229bcd7b492b72c80e5b100ed0dde1ec439081963dcfaba888c7c866ad95a72d2b34f0cf125545313208f152709e37743e24412ee5f376d7d0f056687bb8cddeae212b5ced3ed9035c16805f214d049cb1581b512c90386254e98ae139bf028723709cc2870eaa029ee3cc616116e92b5793d291cf035f77052e8ea371880472071d8cd453f80b8b1772db46d9e5acc25721792578616926622d32cab7fd559f75831c8b008b2c21827593a713aff1085563966b1e09a120cfb3a372d2b60554cb9e106dbc8c7140ba83196ad44bee785d91bbd37c1f831535077399e6018ac5c3066275d3dd70ca39517accef1532033d4946216f71fc7b26a80add28a8059f0ba6ba484359fbdce8c1464bc5142190b7d6dcdd16131dad0a224dafa23d870bbd2b3b1755a850a021c508cc50f315611e2f45d702503de1f0b2e6f70f22350d94e737dbb7a5f244693c84587c86f936b8ad895e8f1d499c7fa3edfefe656e05b87c6540555698320b552d15e0eb1ad9c56e0518eab5d293946b3687d6a7b7219710b064e98bb4cce0f51ddee9faed92cb2b686a2769ffe1737bf8b85a85bcdb289537bc08bacee50d3abd4592bb5965f935f54f86d146015d0b88c65699ef9779f077c80229afc5fc3b11abc4b4cef30f3fbde325be1a379d689d4e1952c1def48de70f601ca4fac3f75b8400b7627170bacf5f2fba20e754d651defef1719ffc4312cacdbd0633d8442aab38f92eece5dd5b94831211ff3d60c7d6f3e76319c2b98decf9fbf87b705d06ce8e68c18387cbc5b049b519ae30ca33b7a7f7b4ddcd841f3eea904931fcca9a5fae22297b4dc95c368f90085235a1972197d5e7a1cace90c7b3af36d65bc737120bcead6a0b72e855ab6671f170233fd0e453b368874881767a16d776f823c3daedd781b28b582c2972dbaab0c3a05174997f20c36ac5f37b1b559352b69808604c594e1c92cc1e976edbcf1d6295901b22f13cd80894b523414bd45c6afa4f3631e477467b6576b1e3a4d99bc1496711e1e6df9b5923b78cc8bf8d40e84a4e5c0376967f1ad9870c5467d64c9af9dbd277300284e6a057bd1017acccba45f3eecff9cab5488072db2cf1700a8608a623f48638b286f7865969e981d3e9bd550fc75315e4e98e7e2925f23d61c70e819da81f151b5f8ec84a08dc20fba5c10b65715145bf7eaf29e68e57b21223731dbdd4836fd9d61ab20055d73bbadb921c393ba3d8c43815757cce6ed876e5bc944188350686ac07133b667d88804c7a9d7075f8393bfa536ba6fb67fd9c0d2a3b166492bd862377dfef5ccf3063ea2b073a6d0ce5b4ec05913dba43895dd8cca724954719fac6c9d454eb6093ba567ad09df4daec37167781e1c3ef565c212d476a3f29235585eccb5ef35df67d6b847db8412d72aa5fdf4af9708f89359fd890010894fa5c581e0efc15cb8520cc3e0cf7bb257601e485617d1379182d8b5f168184b0f6c61f13d136da117f03f40a08c2bc6fde33a504e3d73a61eb533f0a2a9862a0fb1294a968c90d732367a1468c5667f5716e9539bc250ad4f0d5fdaadce546624c62b966c1cbd4bf930bd9e16be81fd92eb8297a7c63bb5e02a8515f99c2f0275d207591adbfb03be40706a7c9c8034befec9d0b88bb405e2eb5e562e5783997db7d45633098672065e0ab7fbe3b6acf7ca20e14611ae280bff382f5abef239cbe0143f02f489e1ffb0f896cc1d02df33f11a9d81911bc06d19b15b6e423ab3d37ebbe07374784a879972310513af478d76d238919b2d940002ea2f50c3ca5ef7effa415e1a35cc85a55052b27ff6d9b995a8e6d3c7a1d39933e4e62f0d06683ed6373d302263977f9005101b2efd6a1294b06026d66d5798f84cb83121d36e85eb2112ebc2ce3914906c90364e9f4b21ef168df8f0b8f431dd42609c79d8bd628249da7fc23b1b72aa574b4e390b1fe5bc4a208aa176c47debac98fa23f7241596bfe438dc7f336b863b22d152578eca56697af7ad7ef6edd43f6c9444fe0df899dffcfd2153b6b7eef12324e0b66f2638bc0adfc275b3de3f2b9630f4951b2a3cc4690580f1a1577dbd74c238f9293727da550cfc0fd2efe4f778ce7b66dade04aec939abc7e0e3cb5e55acc69946ce892d4994bb39546f660ee81dbd6ebb6ab395b8e333266d362a04ab6d58394f6f7bb44f93975dfd12d932a127008b5b55fb6034f2c96ab8ac6fe0997a28093da4269a04c0bbdfe8e2ef5baaccb116c07be730ea3f45610f5a597901d477ade9b0e1ca646115802905e27c5ad3e4d6a5accfb207f0812b8a617177b649f3d7a1ee21bece755f28cb0b44f19dfe85fa6a900f75766cf1db5009a25a9043b96fbb1639e881420bf86852f6814a12a281438bd586be479384906ec9897ef59d6c4694df619f805c66541e11fbdcd8f6fa5ed3583d40d94cdaf45c4d8dc133900aae7106fc39346fc0d351ce0836c886749855be47a74c1a7e9fa44a8818376365131aef3cb0bf02875559a3df2fefcfa072ee889f66009dd812122ea3b9f7413f4eee1b6b600d407221771ad098d2783fe3f661dec5b1156d36336f2dbb9f9a59721fb1b079d188c5d4dfe9210548c0b2e357b38e02cd358b0bdbd4ba58968759433e497801b95355e38e9d29fd7c55743d84e249035c9b081fad15a4b51be8a9db6b97fbce289a014a21b5f08787bd90e58343df08fc3c3c0c6ec842b9ce5264382bca2b3cbc071930ba7f657bdc1e787662b60afe1de6207f75c272182d9383c8fb903b93a88a5a86cae11ec8b30f6c5224a0c031008b8a63aa7d152cec1fbc0620ad78412af9a63ba3cbc3816898a579932a7896287ea04ea590bb49104a54c2b7b9008b6595226fea05954fd2acf96ce42248ac521def124b1c3b4c4644235b998221e8776181696d935fc76815295b9ad4a238d01080e5d1c3c7b9d4bff208e795c8aadfc8889091290dc06f5226e1ca03a673c842f0bd1e9ed5c4819573ee4e8401793c39cb2f497ee045cbf51d048c7c41bd7656f693635dd89433a03ebfaf6ba250c0cf8d553297c4deeef8dc17934aac6ab1cd5d9da5b4d9e94bf9b3cbdc696089ed6d43333e7f9b9976ee5a379c5e102e06205896c71903f30bd540ccf34111d3b716d9d6310a6fed38801e127df2e3f44a1ee1eaa040f0de6e48d58cca1137de1628859c58ca3cbfffd2aa18b450c94a63ec144befdb65a26d79014094684982b4115ad3d2da42d87d3cba050fac2268ed9327fd5b14109b1e94e92cb28c8d280a59f831493c7ed6485c03803fa434c7ee4544e09c70b7be17127c56f009b89a981969be0f926f6de1954721168af89e2de3d5524abe097ecb78ae4afa9f4d67b64376c523fee1b3e54efcf201d7b320212164e1c848d9517c86ccd5d2383c3cdf96a36eb8f583122605b88cd3b541c924bedd5699be1b68dcc448a605cdecbda316d36f1e23e3c0b8d14499af059cf5e6d91b75dab74ddf5ae40ab5acac3ad84372f6e6ad6d62043d0c2ecd11a0d6a6e209f07335b64acdb2cda5311dbcf19d868a270cadce97b946a6913307a9d1049fdbf5aee216cf34eefb18adbf643e2f66890866eaebabc9444b38f172ee0454b2abd0258ea14eb8104bff07a57d7c98bf303250d71fdb18bc3dad73ccbfd9cecd8c001d2bbfce66496abcb4fb9ddeb6e5db4229b60fa7cbd12873b385e38461b65bfd4ddc0c3f08aef1127e3a572582b222c642c456fc1941938abe8c3b33bd0aa0c49ab7e507bfe0f11a6096d44cb0fad29ce0caab02246e339c1cfa1251e7b7fd22903ec6b4be0348315622049b4e7f0f04a89842bc209c281a52b645fcf829280627ead417c033b012bcf54f555519cb509e944a0f348152d11f30cc4edc30ed3f86ed2404a3e8f02d520a8c4aba88c333dd007310e4552c2cb84c1629d15419db6d702fcfd085a34271d5e4f156ed3c6e1a1d0928717648082c40310f260bdfb3455a5ee8da3ee4f51497dc8e11f696ef5f8aae10dde06292a5fbb622d9ad415aa180d04ebb58293c4e8a861a6c543cf93cf416476b01dc082d9b948a75d90907d69aadb7b5a98d5385dcf159c74a65040bccb00f63fdb0c2fc274a75d92939ae1047cf8a326864c42edd9bf7e00eb0b0684556526a6d5a1a9bea0567a0c39f83e669eed5870d2d97d4850a358229353c01d02b65b75b17bea2e9fbfb9f4f361b3abdfc73e02a040b4a6834f1f406e9fa76ec29b660c5f070f13b0978d7e44f072e039376ca0c9d80c85cdff0bd5b071b290ae996e9f520842d1a72664bb24aa6173a695dc361043724b6718896a361aab6d6358e3ab59942e631bf65049f1028fef4fa81515ddf69612f5511dc9bc3d16b25ec6a932962e57508f46e2d1ee14f1b286174a8d834492e51c8ef77f3fb13f13c796b75cdfc7c56f76ace0fa7ca1a04939137116bd521d9a62b0d2605f2527bdd4026ff51e1491f5980ba92869592402c50ff80892caeb0f0d3712cc9d34a6d11c485ece26d5e748a640fe6571e1fa086ff61221fa65095b614d11767296d681fe0d7c026ec60d4ea1a4a4728ed1adfc26f1fe57884dd68eede71967b28c275783c1ac92767962d15f28e4bcaca7fb07fbada6b1e2947c08ecadc23c00cc6c9ec426136eb97d3e20012ec0b401348eba9fcdc5e8c07353402eae04d91292bf4ddf7d45fc294adc5cf2264de15b46afd6d97da9a9ab6511920e41130629b87baebb07bd08692193c515a6c7d5b8373fa1a3f65362d16ae1a5d2b163e091b61684e4c8c5536f927dfcd85ad9ab6c667a8bab3aa6d1ca674b8208e77941e2029493e002a18828043a6b0e2e9f2a6cd2fc258c32a9ce1e4f63084224efe312a3450d8c0e9183594a043e9eb253a70819089df823655b2a72cac08f84fdb182e24e9608e0a4ecc244182db7e68d3782ba88702f92a76f80b39d7c2176d39c9872d8d95f630fdbc761d458472ac2131eb29d4d8a72f524f3dc6515957b6e0e539995cd9d9cf45378ed26360876942b7defe78d0e701da83a7f952f1e024fe62641d307b6aef854222010e65c0d53c3df20b03f0a82cbb5fa023c27b5b62ffac50276d9daf7a5294b6628330979aa215f182afae1c948cd42132496527c409761b63bb421d5cf1208f58eb6568ee2d05b1e9347d5731f222d9da9ee03375c4aa7a2bc8870803d1fb0de6dc0d2bf7ef43f1fddc7cea6c24e8193e611a86cfca1afd6a744138c59e5d8dfd4d299717d95b6ef1ff070fa0987644e1d70680233da9caff0480f9b14035299a2c0345b8ebcb4b669349644042b950f0417cfa32877a7da06ba200ff4abd15839303dc44fa8bbda465d0307c1d58a0c5235999f0077f9e5fc9a2396045b087cb3349cd2c82e038644a270fc3abd54db76258f82f57c5bb51635f859a15dd548ef80b4be5353e6dc8bd89ac710835845fa8ebb587662ea7a44e30a93bce63b6268537dc52bbc554191d3f6886a80c47dd93a44d2684c5cfe5bb046d951902d15fb8593e380ca9c363b4c925dbe33a8a881d1f1fd75b4f81253a2412536c7cedcf0adefa9eff37c94c12e08a11d2b02a05d548514cff4c6b33473721c798067e390faec9628c77befab2c460f420c4e17cf695b5679916f23944d7316164fc8dd6d079197150e6910aeadc0c1f01e8ebd804910041b5fbebb89bf1fd1333cd4d5e2046e9d8e751a3cc4faedb279ef8db90a3eea6528b38f5a634162a6fdffd8b409a9b1225c5da60cfdbc2f8c0449dec3edb9545ce0355550c5035c328dadfdec2bd64011759ca6546b360a1fc423d76cea22b3e6e39d2f4945570c96a8f61d9cf830b9f13f58950f87ed1c3e1b4a3c8ed9fb7571a452bef44e6f4500ae71f4b14066d6fbb8582bb39c799c7c592bd80ff84167e53c5fc3a9ea7ac3ff469d9b91db9be01a9ebda3ff24e403e0554687af79733623ebf70da82893a08f0fae5234cf02616a7b41eb11beb729ce1877587e5026d7077430bebb9d61f6d1637cb0f60601e16ed714c9fd1ff16ed8b7c258ddbf4ba2ec38c9cc14cae916d7be740854df456e176cb815445ce369766746e292bd4ec59161ab485e9fb0408ee9d2c1f14e5b1a3b4b36fc9f54b39d9bc2cb43f4744fb7e6d304bdf0cebe2603cb905c129571b2ea73a894af9c013494f02216c4187078bf6f3f5d3e131bc4553676f96d21d220f6b13127f329ea72d0f17d4b11a6d655d53d4fdd27d38a1851a8f446cf687ae9056db028d00563816537c19d291ec0c4d4da2128de1563d6c8a3066243cea6628c1e66230d9187cf5d7e836d562886b982c003703b802e84eb2aaad011c7ba4ee0aaa33ca71137ef743a1244ec29dd36f1a150acfca0343b266714b10768a92bd81c78cfc45126ba0df9b589fee93459a7e4bdb1468cead847229702086cf8f0ea2536a7280871b46c6a5619f54d783b16ad68ed12d0f4f6fff8f58db852af9aa3ae2fb662f577de330cd1ac9168449b9d7959cfb9f98ccd2dd36edb5b83eecefae28596e7f77e3e0209b4f14177e31405287f94da38f57529709b5261e8578f051b98f02058151b38cf08cd5157afb7b647f2d4fbeed633d2dab474ec2003b59cd7c252d12c14d4dd7da7d5c7721e1017929682538d09d723f228900115acdfd485622d0f0e97efc9cf7cc5d36f7d9039163788d17a8339d116a708c147f4b06c9adc0e80dcc063399b665bbc44044a9e488397a31b781b5437f44cb07470c12a243931d1c2b27743a91920ca2072e3dc76b10c28cd7e749ace40fff911e7811342f568a31fb5e0bc57dee8a93371e00c155f2735be4cb29bb76678102151545a633f33476210160217b822423657f003a510e019547e0af61bb7c4a870de5c46c6c46a1485e2aff69cf2f48348bcbb60554a767b64dc75c92224c9fdfb5e49c61e3879f6d843665d53730b8f000446e6cfe4b3ede5793da4644f4de22943d704f09efabc752f075cee84d86541e3f249d086428472bdc5a6718eef5eef5370a7612286949d26553a1d79ea130e90429fe78546eaaf3ba3da59cbe188a9bd9c18d66e07f2b28abf75c48adbcc50919b23d20efb5796894addbc2e43c71d1c69cff01edd06a0f89f7cbf74139a9042d121c0201c378054865c07c0a6725a1102f1a9c148a9d603a29ad05cdee552a107d1be3d3bfd950da1b0a84168c5ec31ea64090217562b6e77bf22bc197dee89da6334f1394deb387715ece41d2bd9bc8529f58312a220f2e8c5f8ebeef7e47f262f5eec55c5c70d6753df6d94bb88151a7bb8a0fe84fe9ff0c1269059bdce95e6b1a4fd9bab1c33c099d20021a281707de53b27c51fd39445aaa7633203e1935189caaed57046d48c275a2f48ada84b7fac61b102d48b52dbbf825f6e4990b879857c0e01e1224676f533e28cbad9cefc5ee2ff7e65146cc96290bb72a86e6cbc899e00ba690ddd807e4a806fd97248857d6f2850166ec6d9e4e1e0e87ae23f16c7a93a7598cfa7ff3e5c23647593ec4a2b09ebc15ef21a199076f056f876457460e7d06e1bbf4c00ed17078bb8c60119d64a9792726e382df61d59d94d98906397111b9ff8e0312a48668229bbe82386a5329d61e7b5434fca71587921b6e9d098999b06a2b3df5aed98446d36a8c5d45e42d827c62d067ab2e717e89262f9c469120786a1957c254252556720b78148c16d985fca1e31a0f7bfefd31f90f8deb62e9a15a4dd77deb1683b3d0cdd06bdafe4ae514ee6e51e69a84dffac13be0fab0f385922c55d6a09adfc9196e131e78b84a1f6b45c8d2db314af95aeeb52858d666eaea59837a6adabe0507c883dc842e6363e87bc2d4a9600128bda54002ea1cbf05e4460d6229d98064006d2f67b3ae27dc6a80e6b38e5b65a50b6dcfa880171d78a80772fd2fb17e85c90ba5df19299e0a2b3e47804c7b12d9c7f6ad45b8ce41f5c8f10c7a0672a29fe05204bf116d2bfed6ebb0023c40b54da080a827c12d9515415b702b61a4091309d342212caa6b912f5cd187b3a5c344d58713083189c788d510f40c9f4ad79213358735bf080a9e333032e8f63765187fdf84bfc2e5aa640f1f8a276be5e232d225580420d6d6a23b56b2ac67635fd0c7d0c4516b0be2461e50b0831cc835c90139b90dbe3382ad4ca2666ec83a14b37f4628ce5a1751a9d01f7afd7ce16047eacffad9ad621157c284049f88dd76b2a079fc29e4af93d2063f733bbcdac8ebd3cea71a74bd3026706ba3ceca34055dbe993e85906effbd5420ea1867ade8b2971253480cc56657472e16fd494dfc609888bce5cf1dcd6bd1aba633ba76b04db61026401f5010e52cbea8bbcd1f2a6e6ad57eac651f23fe9e5fe9549f0849410bbf9c52d6257f0b146d4d72d6f80170b0551e353a956aeb40f9f161ca8ef50292ef61504c470f378e60c82386b1ba48c08e1c1776d4cb6dd376254f6458d1d079601ba3de1505a93e7cda64f11523eff363b2f2f33428fae65ce4010ccfaee3fe7fececfb2251fa7ab3410a0f2bc43674b51d36478cd540440a286058b2bb2ad9fb391421e7d6ab15f2d4311baef7b138c0d8434737d384385b0d7010cda6caa6ca6a0db4862595c19d73bffde62fb737f5048e04c7e0ea47be6f1efdb2d95d5864e1953da207e159bf51009558bc0bfc75ac6c0ba0dd222e5f49cae790b6e330d59b2299b95c5f1dd7d20b061ecbe41268b41f86165ee5e59b64a748943111de8dfad99633f4daf83ab52b952cb20effc7adf4e1619e97e5637c4f792022adf2b0d3d535b57a68278bf8faf0f465f12c0a311963f4c3933247f8773b82c2383d59735e13deb7f420549676f7b7229268540f975a830c470e724f28be5bda3133352f23a6bba0d0b9c236a76d8dcef7e6eae69a7b2ac546a77fe5c257b423ba235a5d9184693d38c440b344193b13caec0f563faab6fd46fd1739479745166a6f221a44fe40183d680c111e407c2170c288f7dec37ba15c00159fc53996245a6d9bbb751d7fa84349f1b9d4501daa00bb68d06c09256d0bbb04fb591ede250066a1575467f272fd5c580112246311fc4132513730a98852afa1cc899211a2cd39c904de1c75b081ac773db442bce221be52973b621f918137c327033a841f1be6033b00f58a1f47f61de0dfe368adf6fd6f46999c3ab869303302cf9da68d20197151596633eef6eafd1c218a8b86e9589c10a6d689bc82d1b3d58c14abfb06150043ab1e799b70db817ff7a9a57b7e0b81913410b18c08604da69cda80c1d8ce8df994557ba8ff10f1bb13940b332784157081515fed6388d122020146d96a9b17053670a2753d068a88cefb0db98421fde13ec6d396b2c347228ac6cdd1b6ba407bcfc1915ae60c55bdf079574507d66ab08ee32b42d4ca8725cd217738191481eea5016e46d54a6e7590c4f91e76b9028888cc341630ea33cb525e0ae18ce1b41298319a740e5e7caec33f3d56499285b574d4b14d07601cf9180e972695d2cb1a0ebd95cea45ddbd94424be00563cd196d24f82ee0aa85648a4952ec7cbfa1405dd678bc4ba0a896b910b6434de5825f83d0b593342132b6f5b094f304e3fd1cf66ec57992b1422ea4e804734af7cadf350f7228c56a74f876608475dacdd5dd366c2476e8d74dc31b3b253b7e00f4d99285198f5abc9b106b56207610deed1ac1563fab80ab3ff8c9d420ebde5aab24ab17dcbed9e7528b5a9aa4a8d4db2d838cb5ad30f4eb7cbcf3e57181c2b7da82439c26d62479dbccba51cad9b8008ebd537da572b269382183c487b686b5f6075dd99e2d06c1067437f4434273ca33aa562943d01e966cf9b60d39be720b9e66c07655ca55b110f9363c329539345c739e482365b800d322f2b9e727e89e6b8e0b1444bffcc991157b4e4ffc5eca7c9e4244b15e4b00b2990aee04ed4065f2ee39b198d32eaa9e1c2f12a36c0856034c7e3d4930ae0143bceaa7b6f87d2d018fcab3af7b47d35ff3c0915bdba57b061ab19830b0757b9e68855b7354529dc133c940f370af494376b7d27b44160079ff836a219874a3695f6992ec84d5352b0c508a6376084ff7d1270638ddaa78062be645e576d500d846e32a71c99b94a6de7a47ba9f0e8e868b99c2511828e5af08286ff8dfb77251311d57a140f2d7d311086b04cb543ba1ba92c0485a9a80568f843d530b31850dd8608376fa060003cf6c48264d499413a9a321f95842c7008b06786115f09b955961e66439a53b58cd9d82ab8c0ff8c3a2a01dd1617cc9acc1c0e84834d228b3d78ef531c773321d174f50b697e1ac9be1f4653194707c61295638e08f3ec3841b53604a56182cbced0cb1ef8026275758c6ada313e4370250494c1fd16e3a92b94eccfcaec888602cf6143db90a099ba8d296c3d7107ff2016307cfdc1f43b065509a5132abf7f0efaaac4ee176c92e6c9529acaace6844460bad85cb321721144792504de7a4bd7a4f29be10af484fc840431702785a6af9677039d30ad4f6b65b764854d884f46ff0a1534d537c8b307af6f672975c75757146b6a0efdeff8913c15e3035234dca172b56950a0a80a094ca6bc12ab67a1f512b720d2be9648520a982c056255d19fab2c0fdc135fb0f00189cba1951af4c4f0fa05facbcb550ba63b00508576deab74dfa97ee1ee291a6e747c5718046df404da1ddfa268bfab0d97f6948c9ce26d96a6d603a75b10a2db6e400feb737667830429eaa8eadbd51ec978a2659451f44a3d56778c78aab64c5b88feb737e27bdda5c683c5ca2baabe31c00c465890c1507966f55963bb24498c1b79025e8f8bd18566376e354c99c31ef7c6457d362a3cad7184ed32e18876154d768cfcce65d5ce68cec9b25986582c4567e5da9322b207737f58d9707bfbf8a5f77f53481a96ab9e3feaf048aea92a6cd81060a83be76b72752e008374c53075daa5976e0aa21dec5150789ff29890facaef7100f6b58faa870e71eba9a458080374919e3457f2f8ac17b4dd3b4a3a112ad7cbafbbd2dc4f9ac7e02ee2fcdc5d9f0986dd5ddff9f7a714b230143694e9f8f395242d0e6ae91e7bd73ef239c41dde2b9af046015046a32e521c7957d6a61b450897445192da6e07c3d866c0ade953fe57b78455b323b619ce9e50a36d286fe4ec8f1612d9eec67841218de5a47cd02586d17cae4cf7d90338b9a9a89518d44bb28922aef2130a78b1ed97ee43b63c72f9fa5f723cc5f6e7c1209252aaf054997284a7147a3ea48f5151335d618068f35e3a3630a0a3ab302472ce4385187474ea3531510b62be582c5e3c5a080b7308af25f1ee92a139592798ab186ba7ea267198cea02f441683a759a4914d3b408ef51d476b3723b3d455d9648e69b1374af271ed165f89896554c927e88afed9053df757e7d151a377455746d6eb1e75e6829ebd2b4121d32656e9689a013d121b88f1457215fc8c6d41a9990c31c89fa5d5b91d6b796ef2ca988e137f8aa844b30d013e69b49f380965d6a46b9c0c5c7b8d48e7118502cf1a4e94493042b8199af6589d8dec5dacf2ec7532f628dd51de80b0dcb1e911276443c197c10afa7fbfac41c3678d5f429d241231fdb7336329f8c4502aebedf4bf20d504f2eb1fd290aa3dbf725c349cf92b9097cf70a6f70bd9dca88440820","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
