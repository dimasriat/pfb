<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"069e1d65036fff353cc221c693ec993804356305cab8d295baa6df602f697818457bc6fc746c512e02ae0a46aa3cc37fd01851ad01fd1dad6fd178d38cd6335d390194d651bf0ac8a37c5ac858b38e229874feaa09b703e3bd4648868813f2e3e10b3cf2084c863c00c5103469e4dc42b09317ff1c641dccc0ae9fb665ee1a01787fed8d21140c64ccc8255dc8be644f3a7b020f9984775eacfd680939892bae1fd00c6592f8894b705d822294f9d04d26e98b69c6e05917a6167b3776482901f7efa2abc3cd07ebd576c6d8fc69645c052f9fc4d5204ac32dc5d06a2223e132ea5cce6ed5a0de0b25d1eb5dbb20d134df858c3e323d62512aa669d129dc67fa83fadb59b904a93c0f1d0903dd34a3269951aea16abb9b311ffe474856a84be020c31d4b4af10b464eedb705e24fa30b48e0256f7aa96e10f24ec7179949a74e6d8ef00ed855f06e9c78d20701ea47ee9be57dfd52fa99c80a2236cb0851a848b6f473d367d6fe3beb5d6673b7a0a2c7482a68eac12eb40ad3c09d3358e33a2c58793e512d4a7c69d9a553315515328e1882346396f0e53345bf035e5240d882da5c75999b00eb28fef14e32037bbeb93a6b1e8f9b06d2276f6efaa6b230f6dfa970da40494866b3041a140696ab23196cd4326edafe024d78cb74706f6cbfee02e3ac26ecc5cbfb4b86ea2671a7d27a5c80feb2eccb01c81c3db76975214d82dc248d3e921995a84b0f57bac4c17122231437cb8f705842fb80ff1b176c15e8c0c7087aa15ec654fba26bff601befc3613f511da2757f31c3ed33a4890ef90880bb6b8d86db63de01bc9c93a0f84c0e322eb926a685c5edaf39af0ff89b27a8612269e724bd4e9aa5099e389d3ef5a463bc5dd9dd99426afd18e420e677e054cd50fac21039c0b40281466e3de06fed4af7830e4d880666231aae82d9a8878e054874c088064c55636f4a2218af4a179428fc8cc66d9f383bef9b3db5f49b2bbb6afd791ea004edb3d4e3534daa7d38d5b3cc4500798780dac70b0a3f1dc797c18b94ea82004fafdf4a63c463eea6723d95af66ab6b4bf1bc75f255233d2c14c8c8b1c4447f325de408abeb4b8aa70046bf97e29a15ba457bfdb0407bb0d8b780d11680ace5e5bdc74e4038e7310ed79ec520e38230e1873e299fcfa38cad7265e34f6ad831ad16ae5bc0b1e50597f684be272d5cf87a87977f09c417d55c43006b2435e16f8fe21907e3d55321e938e08007da217232d9b6754a9cef10ddf5f770260003ba3ab9797090e57fd557dbaa8ae90b59c60a23b1a2ecd2f845290628ce28c84e3cbfa67d20d6047ef9bf60af30859f3e7a24b74147b2fb8bd4dee49bfb602fb5d8de3e153ba37a674343096209e2dac14a42175d60c82221fd750741d0c367a6c18cffda49f93050f1508e384f67d07f798c498ca9f5d0f0215dce71a504000b95ce26cf184e4e82777a2c5f69e3bc6106fa4c3305274c6cf33fb8bfde82916d6ebc06f6a75587870d0949a61487b87e674165931fc06e561839c25d19ff0ee7dd2f9a3a0801f92036c94f95dd859e5c5a1fd75c3035276cd2f8164691fa8ce1106a7423c0716b6bf610f3f6a10469666c063add46a639f8324c71080ba69c3124ca1cb657570a24febe737b45288bbd494c33b1ac201cd8ac8c972a7cc971460a2d53d8465e0764fd9913236fd2e4c2c4e37e979601032a0d35621ba96d760c125c7db60e0bcaf1bc639e324c6cefab8c8c4665bb8ffb86a0aa222e7259b56defe283e96a84d429c0f07c01e52d0687a4f7b79d1de72453a8a0d41f629a49da6c36ddc51c485d8fe37798a90b583bbcea85ed8c8addb67c432ed41e7f68ef21fe905dbfd8c6f34f760c1a6f4c1498015110b9f3454794a1389549a11f5b9f11d378788fb33870edd46486e4b823725e4541e39cbaa3ce3b7752f9b8f45f8867074f69c665423733c0b9e1ba27d26acb377f2be3cf9ebfc9c99562337216473edc91d2ff2913a0772a8ba963075d54feb5451391d2c1e2a12a9f4158a865428d1c736daed236c4d2c4078f39545f149110305727aa89d92969d7f9319602bcb158a112c4714305633a676f5be6c7459246c86aa1e794a37445d918a533ee3d91eae6d45dee120a8ba0324f675573d6c8aa9c8ac0ea10760334d7c256603507230d44e3ad1aa9a12214e5cfa877cbf695c2a0f4740cfc554000ee87e92abcbad0de1ce21436e34661b1ef1a54e8041f8c534254be543115d04168cbd1bf13a34baf74e91e775b5e2137c120cdd62a9a238087574afaa9260c25033bf756935ac002e186657b5e881bc34a0f46248a5c0f39c0ed4063d14104f1df33b7c31c12ae230c123e1ac07e739b41eb438ba72915288e3982335616a9ad9e3ea44650edba74bf5cb9538c6ba72fd9f326e9a92563168b0002a0724dd9dcf1f5d6921830d83c6c3a3adb7ef8b4b232ba4b9cd9ff9e98f703add030d206b95eb78f1d61e262475d3db12ff03f35608854c7dd14b963c4afa51559e42259d6d60afac33725230296db5c5facdb9c7ac6da8de2678b9650a5448b3bb623332641a55e10201e0a573dd38071af18fc0b758596439e6150dc58b9748fd5137e49c605897d90b6cb478f7e14c1642187dc2784182d073eca7ec41e28259b965d84703074c60846309d4a5c8725565d7117dcf9585d07edbd81e3f431ff96730e19689f0c8e6cb29469525ac7f88d215cdc69eb7fa3f10c69a488b9929beafade2383b16f1fc417ba676a891947782fd7800e1f4d982bb55a11befa55b052a20adc42595be1a0a94a7f94415d510a5aeef3f3a5f0cdc5e4a1da5f30975f9d3efdae5a4a2c0ce9469b2c380be7d3a2d2dad3bd5bd50e761909a9d9c0967ab734bbcec167c10ee4070e5f838eb49396d7a9577f2ff4310447695b5b409c8bd9e33e64e682673312a008797e0fe5d614ea3e59cb85396dd2e05c44469894bb152f9c0a467656abdb4504e21712f65dbf692caef7cfec682756c4e26e1d071581bee5cfe89b83a59d5ae6e94c1fe9d8ad489ab82aa26b3269582857e945a47e005c851c55410c859171faea654e8e8b0af45a9b29529896115287cbba5643866999c2d6bccadc2a604be6e32d130a44a55c2755b4dd9ff55131f01792a7b609650e8ca5c621bf7e0e2bae42cf6a032451fbf81de326d5797fbdcd4cc447ef3e9ec856a56e0b7c45a9ce9f1ed36bc694ac8f77cac97c1f522f2300f22664f3f43b531cf2da2aeacab47a8e0a3071a3c7649adc153f67e38252cf996f222cd004ad2e10d836ff82b5a24308f69ee4d87afb937a2130e77fa95bdd2cab8edff8687b8f21f5ea2b9f81f7bcbe1c8193c6f09ebf6e3890590e98ca380b185ae089858d9e8c01fc76189373ccc24c4d3ad245106885f815a0b23b39b2740ebe36a09e9ccfc74227aa1733136a98ccf6704eec3bcf2dec50adf448a03128192060919b53acf2425247c03d514b9df721dd7e5143535f3c9cce47c049bec34cc2d8b5b47d97dd176d4c1e6e937bb3e4ed496554a5fd7840af643dde420e3cc2d56ef1eb882be35a07c7f6aa482e86ec1399c3c09c8d98f455d4a673f30fa49eebba22b37b421817216b06d548e712dc570d5645998f35f2f403867208d1d3a1cb2c8c662d1f06700fc06aae20d77aaf114c01444b7a4735eb98cc3fd635a92ccd8e892c9bfeedf78cf5401e79421a065c7adff610e9abc2f79dd6444d8b2c7fbd44be80612473c72e8a008d1a4377e0326461c32e4e65fdce35d2707c8c5c928e6708b47cca6cb65c9788637cc1250e3e697d7502fef33796a72f2362a3f98106cebb04493f90624bf4954b37fc3421c3bbb4eb00d07c5c1fab3d9abdc279eb164ede33b0fee346c2f6f10e737719b4854a21d3e3e90c8eba1ddcb91b0f0f4361e384d7ff92c026d59199ce55f80c5ffd80ecd7d8fd3761bddefcd3e2ed76bd33b65870ce3229bbcdb29494405a772d2ef6ad812b95b05295275db0ea6510b80094b5ac35a0a2e7655300751932d4fe3586c8f3abde0640dd869c2f8bed9c32e5654f4edec7e9a966f9b7a4a07ea27a6df020b593b4e41e08bbc73eec4a26e313c14648a40da3cff09aa4a3645e2a04cb7d501896ef6abb7204cd35cb204486f39167546a8dbac26f10a67a320477d38de3dcf65227f3f558a2711b63bf98debe31c1d9969ebfbc87a3d12e5a6d7ba26f1611b9ef0aeebec731cbee593381e044960e7ec9300e7b6c1d3c6c7ba674ca2cfaf0063f40c168c8901944e632daaca9f42d5546f4814535296c5e1dddbff7370a8ed1544c325976830c9e95a3d5822acd9288e994477bb260a21f17acbd3fd87d15431940d67e46102e76d69bd4077429342ab3ec4b1754a9b72c0b88fe419417be6d9639d1c790454ee657c2b952c3931285aafe7651b726550176c149357ef4c9fdc7003437caea1604c91303b069bc3334133332faf136dad0d9ab934c21cc6ed5a9682bcb0aa0b96bafec4d971ee8d46a0d2915f68c2ba083e3fc7c1af732a7f8306350ee87041edab42e7c4c6c1dbe99c69f97ea012b17f08e265e0447f1efc29e26b0b2fab2fd0293c6654941102bd7fa5d96c970a8413895834efb9d2a7a2febeb211ee73c0f7cf4a822242862634de8294fb506deeafabfa19024553c9a52a4418c0f548a41c19e4f400d1fb7f208d7f8ee0b9414bdfebad1dd41eab569f4e08d3b61163b7bff3fbd1bc81b1558fb7b1ad7322a3fd01aad0191a00fc67cb077e63204950f714905052fc057be42f4c0f1b9a555bd7b334f2295fe480d9e4e6f00de06cd93f91badc60c94e3e3d876dae8b75e59483ed037c00c0f5958911c870c72af073701095def6eba80286cc5721787a795356eda75418032ef3833e0c540f74c0ebe7cfd4021abf3c13fac5a5c9f201c3eb4edbc0863dda5a733b597f4397509057e72f0fbfbe103c543f1361e1d8723732b340cea2dcb16557004f442cfa59901d7afa70bc7a8e33f48d7457f151a6c096809a0de46582ea641a67a8ad05cbfbdb1ae75bec3da15e6d70cb7401930382e200fc65685f93586dda547974395cd9225f6426329565f12fce149ca4d08eadcce3ac79262d2efd1d2593ea9685bb55d637cdeea968d160ed6fd5f19454fdb54fc3b420791e891f49d212244216e48995ded80d87cfa35688fb8aafa5813c8a61c56868dfa7e6d235176a87b91374456a03c2d889a5d88ff78d6510ea6c7ae0f32f6118a801b9f44269c21a5bedaff26a21c1c2acf1bbbe9194aefc0385fd45d98880ded899ca419207851b49441cdec833aad8d8604177851d81c9050683a612c5442e3ccf0edf1113d5113649fa5e604ed52b35f64736a6ff3cae4191ddb5fd42a836976875c3ad2c349692384fb944af0866367b1190c432dc4ed21f9e34dc675f047d564e2af44d95586c58a62a2c35a3c2660e4d99163447155175eea68623e5a5981e3530b0e75e56bf6e02c077824a7c587d74ffee538df523d47f9eaf204a92aec6f1a0ca26547c62fc6cfde7f11a30e055ec3e32792a2ee298ebba7b65ae922391b7e34e78ada05d61c98fa792af92ec90f86806100f594f2413e481d2718ca5342d3c4c1053c31fe3dba3b5f9b6f30eeb6b70ffaebdf9cca6efd8ebbfe7fd2267163b3546424ab2fde29f8d1e746a65830d52ef0596de6fd934fac07610895606ef0bc24db102e0bdff2efea267951431a117e0b3ded8245f642a93c6dec6e63952b4c92adc0ca5196286f70a825ab79f2640ba559875c550de31d9c1d6adbf9b8319f3c423f3b5d4aaa2055bf84f3d5ecc863495c1b597c8115f8ab35c4871cd061860a10d826bc2ce8525b5b39202a3a31174114759f261cf0309f5433b7373beee04138cdbb66895e7160228e63f57085b0fc50c87af942a5e6f204f42776ca47cb4e210b883439ecd604ec045a0467a4135beb9493a702198e16f9e45b0d9159b8494c9b77ddec5d8e18444327476f142ace0b64ed70018a93926f4bded075a1a7cdacb442ebd7000a993003ebdada303b67b383b2403f7f1344134fc475ba9537253dfbc8e2ef34f2fe4c7373636780504d1ff2ce66ec93e2d4d5a853d71ee79fc7afc709d73d2bc553e588479a95b373b73ad2abf309975915f0175277cfd15aa68ad9c0871d026325c32b0837360a7f8b75e50e8757362dd43a9666fea3d86ea5f3b3d366e0ea946c467d775ea531305fbbe843b62d1a5f6f2e078c0fb5c0513b741386242225339de531cd8cdbe81f78e39f6aac13413ddab7dfffd9aa6dec7298a530b5a4bf4de129f186d71d5dd659518edbf0b1d5dc4e6a61a2e01e1cba406c432f05f37daa29f4ada20b47cf1e8e1d00c3407e75db7d3591dac7210562c7c347349976cef2a393c3107eacb36045afa9925a812e7e6d7a651f048131d6b076a18a892cb590f8bbebb800ccc1bb48b689e125d538127b5562826b7a3760c93df6e50106de47bfebf33f7ed89ae24acc9670fa24be93e6746cd38e8a92fe279f119dbe431f3a0df5b358b71c0de8150324571e6f017146f7df585102678f87dc260f0667738a0c5ac39e58e001179620ad721f837e55720752d31b921d626d851fb2ba0e2088861ad1c4cfd8e0ac80372cef22ddf54a49c4f449e3c99e4987339894a887e332655242be279b0ed88610364ce652958643f9b682c4c0d93e61b389e5ca3d9dfc5582e7879069ae2745865f88c438a2c6403d59284cd7c07d5b96555267554210051062d43130046168c93ce2367fc076eae2dcc156150cae42d016b2437f0e58b5b6a16be5844278a59c90bfec8e13e8ed8522cce1ee27591210267ced5de38121f3421f60b9cabc6e75e23127e1aafee31e676048eb5ec3164d9d0903b3fc5d5d3dd06efd4acebc4a2efd6432cf9c40a49e07ae364148e0d115a9f464e36f5b7af358cfe363906a2d7a9848b1a13d0b1b7c1c23ef3773ed092a98bd7eb845c4aa050a351bbd9d09b2003fa0bb530b93bfb2357c8f55da8f4ae3ee40becd06e896e10a6bc2512792074da0f94ee43c85ad667250c0d5fd988d11ee82f00c9b0c093ba66938d6d95ab0803cf39aa9e5937a37f64784b2f7d3e79c3acb5387ec5e6927fca6a799580cdf767d260319ea17ff9e83811a58da772a4c268a5c8688a6624710a0bc73ba79abf662eb49c9b0ecadb3d2a5eb55cb53abbd24f9a714f90dbbb3c932683675c05349cb12bf818049e438a648e6ff9f315dd068cb273160f67bf8d850362e238af599bcd0f01a51507da827a80388f7d1d6a40573e44b2aea47ed59c1eb39e3a68dae76c681df46d7bc8d521d8ac7dd4a0a1be46a5ceea3b4518bb838360beb27ec935a7c641e02d7db06690dd84d53c1c0aed37a1cce1be25136a748100e5f2fc8758095a685b39006135b72fdf8735d405ecd1193e10b0c00771ea39576f3b06c647e687bfa9b05ed5bfbef49f9f914bb59cf01a9bfe95d74df53c625aaabb660ce8f71df20286908ab89caf71cb37cd1ddb72df23edc43c2e7bf6ddf79626c09db67355191ebe60c808d9bf4e2eefe7291517fc2b775798724fc8babd1dfefa37ddc3d40228b2b19cadba42b2a39280c15d61576a49168ef74ad4d5c3bb78a4e997252d8803a1c475af40b1a8e7787818a29d79f995f0cb48223d62c714f3074afca308f701920e55bdfb1c3bb966d8153e08d3390f5e247721380accdf9eb3a6b6b7cfda713a14eea99edc077f961865db1f8ea1b5b35f532a9e2a41d487b71f1ae45aa9f84a886569dde2248fa230fd0d8471e8030e954cbc436c3a1827117251babd0f91cc73cd344de0725237525adb85fcf02a3742f0b888999b288f01655f53d3597279d0d059df4e7dd1074a91a2029466594859c529d5a6694165010681a33e7ab42ce53e9cc5c2014a387c779bea6d03db5cda38ba56b7ce3cb3363c335424d0137808557fcb82ddcc6a96fafe31a96685410295a2fc6c80d79bc6daa0ae07449a51e38d7ae4dbbfbc8f52a4ec6d6bc9ee0f32ba94f7ca5b7756ae6ddc2be4fdb042677697a041d1c8196c8b3b1698dfba5f4a4606371e6dcf40bf1e02fb2f6c58082312a26f5e451c33d4e08c1ce723c6ce18feedb12e892f59c1edc36123a88b3d2fd7794ea1c8e1170e562d0c53d52691ef25ced9006435a760927cd61880ac106f26df417f25541c4ea62bac233f6684fb1df952a6022d8898123072dcfbf726f641d36ad5e042c120e187578d8b86da826c6ca43b0cd00d57bf244f9a35851fa2fe32b5c62d2b94771b0809e7afafad18fbd0404fb1860c075466facd55a44fc68b5c2d750a0849cd008c007b53639fc1f913c413c3052efa0051bc38b6ff037da554fb299fd5f76aefa2761546519bc22bb791fa309a0b5961b9cdad0c5887bdb1e8d2846aefc8774108e942688816f5b01969976f77db18e05d81db4cc645f830f69a3cae11b918a33bf59829d4dfed002eb24fdf59d9afac36ab48cd92d4a489f6e2f0d1552844d5b4544302d68dfb3cda4460ee8485a2f2f1b0af302942991c698db78f61d254dbf2500ac6b7c2f8884bf691be95076870515fb0e800f076008200278b6d07e641e7dc13a18f6bd0c5482fa5268cc2a4c8bc87e770488b7bfc6f45090d48746b4d84f8cede88723d68c95de2f55b0583eb607bcf201f06d8b5bff77399891632b8264bba18f805855663e3b6ef9819f689d3c346cd712de9a9dd2bfdf7be0deead3144c3a756efe26d5fbb520becf4bd6940521db7bb8e13c6600480b8b1eb7243ec8f4e472181cd3fb980c879a9572c3fe013f5c82c9e39f479407d245c71119d5299ad6bffcacc923cbe823001d62b9078667b07ac0c84ad348d61bcf050f582786c26ef024d450293d7fc31407d35bda51af45ae99d4fdf4e8478c914e3f073872df12de78fe1e088e130c5eda21e285c68eb2a6aa4805ed707fe0631a73d044144e21f8511fb60298bd7795d929890c020907d5b6596cf518b7e15a0591deaabf097a0d23c4dca2135047203711d1eed223fa20fd8e74d88c1da0bb5b2b673278fed195ab8977001f60f54bba94611f434711f3f467de7592e8bfdbd4578a86c5d7049fe163d2021fabd80636f19574a9137b675645e044e391205910fa1ad0d22c5276ecb73e8272c0020377e8786c3d2f146e3ec9d17658c925296b982261bfc66000881d536c79497a585db042676e7a1f64c57942a9ccf0a54c8de9a44cba93a8a6c35123e2ed61e9b6fbf486a556525bf5575b9dda750983dc86549b6fe8665b09f36fceb020a2248dbce9348bdb14f87bb562a099f378a0b7383654190663966d661bfe76946652eae905218c7d3544ff811da987c3bbd9065458e3f1ca2d7948682d12958e975dfb43031af632f67c25438820d0187d9fdb8104d9cc780f363d04bfe814190e4d8af5b23ac0a266dd3e316969f9f49ddd2f1272a110e58779922fd0c2b94f94ad5db8c48dd5415011c3108fc051e787d62c4fc597ffeb00c5b2f0a5ad3a8ae4950634bb6a1536fa3369e1c81d51297e1376d997722524bb8e3d9a8fae640ef0a646ae0d80e44e3eef58a3a4fe049e84ecf3277d3fd89455afc9a836fafe0b4b9bb12274d091b641d9cfb85d7f6e1a65891e00ede348a1b3d402454318c7b6f3094ca016f8ea8a9f6e71285c96a505d700d3a324b16cfd7b0ca763687442aaf8963815a65cb82a8b405a3a687b3b7e35c2f9461b2059e968f145bedada16182011c7ef25173c026cfca4a003a2f254f98e8099aafbdd7c8b5120bb7e95a2cc93758dc9401d8ee77ac4d2a4f977519084ecf5d8ec79fd1709e9958c8bf5c012d115983daf6a49dbd9a48920ec879365eb82ef3e2e2cb7c301fd2fe8803729b79a73adbc5c9abab8b03562c52986b3626f09c87e77b3b1c0ad4236c4877f96ddfaffdb91816af3b268d4647f99a988f6db12c8e38297545e2cca2243b4b3409155b4772488611e2cabe28f551b5b312e4d2175ca2430ed6e53b9c68e0c2b48ba08404577992878db93e20ebe0d4d15b5958fd7a379bad2ef5e26f88c4a0909b82821a0292c5f3ebef7b963e27509b76cdbd935fcc0f74f08efc935cb909159d2b6d2c811785adc8073e9a67a85ac9f8464def87c9d29ec452d6362aeb6e939b978cf396c92d5751bef86f722f3cb756b76dcf4cc895b4e1580af52cdd7188089349aebc52eaf0cd7ef9b9c88f349556885d28e9479165388fe7d04d28f03ed97c306a96888ef8fd516221222efee50e4fd8358cc963b48c50d732543509dcb6e0c5e3e67bbefbea86db01da551b9053b4885943d17948a67e14bbb77a65a4050d36a550b5f5647fab1508845b1c957b8c6f4151c700653cbcd8a9b1235f25bfea17cd7ecf56cbf4e3158927d563fe8aea16ec1eb0f1cf151fbf762151b4f4bbb94fb22a58ed922f111c1c41768aa9cd910fe47065dd7d23f0e596255ad0d87b85af51d376478eb69bf91beb081b5f2916eecf1bdea8ba153c1d73579697b73a12acda381cb640d9a004b780707e1a9b1dbc9c1d14077dad6f5f171d2aafe18348301634f1b924b1d535bdbe93985f76e83639cda360c8e155c854a5240d3f8505cea16a26290ec8e66a9a503ea9f4aab9a7ddb46ce6251869d0bfc176d07c577a1f5c7a39f5b3e72dd8aa215fe6d8107dd44f4e33fbd7146641fd46c6d5ce12bfcbd64c483ed9c53991053aace2449c39d72d370e9cdcb5032efe650bd31519cd830fe4867bb86a11159f8d629cb65a8a63f1863ec4d521605ce8879357145d92755c7ab638c6aeeec8e4b0b73f8f27f65774aaf59ccead08c9e5500f463fa651a1e15092ed5dae2bb2d1744bb411a3c76189a5d0d8e645deac2cec48b5378c5348c46e392449f2d3c405c9c09c280a6a762220c9885f90190925c96eda498479ff1f51fa23c3cf1a580288fdae5e5bd33b8e2036a950debf5e9e37dc353c7ab60c6d5c3149f64b7e75a52b0b9f1a748d771da1b07e613f8ea13ddb6a0b6f2101faa8b0bd2f477a502dd1de2ec102ce0fa3e13af85b658f27e7eed70021a27c018d7847de9e5b6516e01ac14315b26abfb0d7f6d4272d996b5a3c0f0ec8d276f581ad3d2f5753bc3eeab05793347f2668ce3d50174f01bc383694020071524670c7be12a9827eb17154e3c950fc0b23ae9ce5e8d81b8a8579f0250a844f5911de5248b1fdc7416243a29a82d6296a37e720f411dac630d080f5bb33495a36cbf8fe06041e1ead290282d7c2a9b129f7c833e3841c41699d1a704e1db5ab93cd3ced31a68513ac1357c6b36958bc0ffbb38d6bf57c1d7085837f32e3696987028434d2b74f1215d12782787a87e0a35219b39c2a60d3d983d5c1f9328c3d9037eb92d4b35338beeccf4070ff5983df03a43c8094dc56b28a57afbf742ad2af2bc90a4ebe67e270ca61154e44c44fedb1cc3d6fd712819a5fa556ec96a8e1a304bd752ec8314362c95d8fa4141cd4819ea120b8c1da689315e49741794110e0d4179ae48eda415a5973e4438e836f1a9d4e16ddb74739d176d3d18d37fb6038cff61de0a5cd26fd86122636d577f982baafd263c57f8a965e38e7adfee962487320917eb7316202c049fa8aa694bd2db8dea4a000845b09206db7568acfa69c3eec4852ce437156645e550f4c42cf4bcce05123531688f86970b5e634d92857c7d775a0117f65c31e1723b03011da010b83f44f596af636c82ffdf0ec7b1f24e7058d505b3896560aeef814217f8b27abad41f9c63ff7e70eecdf92cf6fe474458d1308a9ac9b8e5b2263941d70f6355c9d5c15116fb7b3177a4f86189fa18472c1522f87384f5077633e7052bec63bdadd2203a709e9980ad9599d16c5423d397f02789d8b726eb118079aed276a08d50eb49e0df1431b2966d39cef7828eae1048d6e2ee3ea9cee4e279f1c484b8e0672167a5426903b5a0595c7b7f93afd3a4c27de02e52cf46e61984065ac614a22d347fc4dc7ff7810208a00365d4c1dc0d4fe684ea5ab798d0e96bf6290f4aaeabbcfce80ec67a8ee35f4c235fb2a3d587c2f6dd249f7c953cbd1dd37b43df07b1cb739a81a77e6f17c2689608e2ca0300c70d9df9569d0317552d8911186879cd8fdf27f315bbfb6d5b87e22092bfb7186f446d3aa9d5572b85f2c52679436dc82785ea3f9ef07b40e4d8f8ac7738b1195216c51f432e25de5a3123e35b23019c2bebff1b64c78a2d820f3a55d81381d6136c78bf65d9ea259ebc743bbbb26bff1ef582f4d4705d8f38d70219982cc4668ac2648d1dc5911d17d39ab27cecf495ccf9299a5c347341e35f04f4875d422237159125c7d1154fe809a1662fc4e1283b24e5583a740ee1ff326db0e7a207b9b390b507e74b62e795c62caa31417309b13ab3d175a981439dd4272842fba7424bec8ff6f2e95fcc15ff2d5a317090aa570a3483ee04d4e41065dd69c017bd4aa484b81082af14623e332bf354b50df416788c1479668ef3bad5eaa0f9356317d9073a0e7cd4ab8db3d3747a27f60a308b2ade846d5eb171cf4599e02c2ffb11a6fe9e8a4b0efeedc1076470a724b840671f20dfcd3c9ee47b92ed35f3b6cecc8ceca6a42281d81fc92f0567187c71efa8f89c17e64eab75ca17fd338619f471ea334ef4913a2ff25a42549b2d17d56f21f1fd2b8686ba56526caf426b2a7abc3f6be07221fc08b7e3912fcded24990b83681d6f61f64e725d015ceb7594dc261bf87202b54ac37aa8d0a32f4b87c5e59f609c3c7f6195b83bef0f9e5c452398e7d817ec9f55cacf3496cb28ecbc1085af91d680e6d790b9872baa05aeeb5057d7eed0d6da78f2c11c00e0d6984b2a12394ca582535a56d8557fb2a34d5a090d3c9bd1bad7996bba23f68949c810e80d5ce76ea386c690b8c490aedf15bd5200384ddea518b2ebb9d4723cee431e5d9e547a805143d7eeca34f9c2654d3c4c695a01d75ff3b59fd2c20d37f7a4ad90a461839c72166305a51a77bff9bb52df2252d8b0d410ad863f29c1157a33c0344244354ef69846afd33176314705e0aae4d7b2979e90d490436271e446bd2a4c5c394f7fedd0a69beb27c799c6b2dd1c829d73976c4dfd3b698b1439de04d52d4633a6ff5c9434491483ffe650d7244eb005bcf753536b9c47e771203490ccbfdbda03414e87108821f7d370bc9ace8ffa4145252892d107e475d3f249fae2a6a2044099f3c38a9ef46ee940d72fdc806ced0266ef2e6b28163e0f484e6cb07add8f706551f9fc58a8ef55354cb971539c437d2b7bfb71fcea593a0de83ceaec0f4565c5053d4937af7ee584bfefe05cd17f29f6cc8d6538f519dc56c3a1d8ff43eb211bb58d43f9ff18c171efdcd549c1ce8dcad029b0353328d52f9a8cf44b99776bf3050a645d8400bafb760d47843c5f2f6ecc6ef19b8cbd361cccf10855dc8ba00daf4dcedd446b7e29332f9b285ba781e6efdf8faa0effb2ea541e550a7b3eb696d25ac170084e6f2e2155a63200413b95333b9a046a076d19496180c9c89e73b5d71a3fd63e9bb237dd1a9a97c25eceb4855b1691b3b5838ef1ff10df95cf633fbec8af0b8c885904b0b192b0b86891120f012029d4890009aa387da2125edf682e61693487b176fd05fb83a478aa2bd35819e4ae1c187fb0af60c08908c0b8d293c89c38db7659e447d5d5ef5baad2426342c3cdb6dac1227ce14f129561e122872ce2954e93122901a89c4cd6d285f5aad060a796fa9e87ba53613826cb9a2225de2bb73695ccd81d56adcc9e413cb01e57cd3b40dd292553e627e9e16556f367eefeeafcdcbd0056f0a3d515f1525d872bf690da4b607995f1b1759a7daa7707adafd82494d4bb2a9bef8f41eb01aec445a1b1835c76e0aac03929133aa945b388df210013cf8a9823d0791e11fb4c5a78e1fd0a2c1103ade205725e2417ee1fc72237cd54f7b870b22bdba9000a79a28e7e1c01827a96529be0bf0654fa26c27077fcb64db23c96da337780fdf84e58e5fb325236e2dd24557b55d7da138fea91661a8071a3788a6f4f85306520da93fc53b293000c802c91cfae517cfa3fb66fe88f9a42b9af8a4d9526fe0de047cc386186b945e52c85cf5ba03e7b85e653f29da513175281d15e83ed4b85d9e68a4b6f138ce87091ecc0856579629e235bc690e0ff0ba64c8aae01be07e4897867b4acae32375c5174389f4abeabbc2b44d612b331db5cbe6f50635418be3a426b6de2f8b60516aedd49e447b0596bac6d856baed4358684dad2db2a5556ab89ac61fb8bb08ba4c772fdf63f5f935c49cd8f5b3b0180c8044a05299cce1fb1549fe74ec3bc7ca64c262a5ceed933bf6101adb15e38fc112e020305a43dec07d4a104e01128ffb76c4fcd7444d2b873a816325a2545599787c7523361fa6732f1700cd3fd7a496a65d4c2efc1ea5373a4119b9cff76dc77105319884a0549a7203094cefcbd89f8d09fadd25bdfd57f79be3aa6c20770b4c8297c958e54efdd4f9af641a62b546fa7013d20eee99fee3fcf1ca76f82f7e7060160fe49ccf51082e480080239b5dc10598f7b021894b7422d989f259f5fcbf8d1a015672a7c214b4045d6133ddaf5ecf72ca7a411433341dd3232687ef35fb283d225b8232dd92dc5e2c328fe119e96ad09d6704be57c0752da591c19af2098d2ff62889cf1f7c564da1bec5536a1eb4e34033ec3d043218a7cba3d9241d6280ec763c628d8baadce9c133e0738379c7fed155fff88fa66a6c6fab96c3e03d113079fe96c417b3997a66ebf7cef33965543bf2d30b15e9e3c184c2f0df005958efbbe700ce03aebee6da4c34a575894ee8bebbde9cc395c583d603e8ef860975deb1f446549613a4bf398e14c3adacf2a52e89a7805563ea9575fdc56d6d502a9663aa2cc4dc24b8cbf68d64c338cd5ac1233db1273295e2be1756fe60ad7c7ced8a528f367ca9ea9b0cae26144210474be962fd8ad282009f42e268832ae37dc345b38b5adf22df8dc90276114d5caf8944505797c544c1c41c4b6d71d7e8ab9dc9189ce8a8c49898b1f3f716863410ec64184bdf68c540b96865c2604adc114d67642d0d56e172a3733b411f99755996a5f3abf18dc52c9c4e6704c50e1f24e249523c9f6ec9140699ce23ee3808257157049d172d83576ed697e39956bdf099145594b49f90ec2784341fe8e15397741d143bbcc0411a155c8bcbbf22b3923d7f221c8fae7ed8886fc43a3dbb2020d9a20480de0ca861c039a8a408ddcbbc8dde7b0b04895559f2999f0e94db3810042d8ff9481d691721622365748097cea9838f2480deaa15cd0eef07d257cb0711c6f20c1cd007fbe8a491ba42370f24d989b606414aed6f194cf70c31b9b3b9eb3edb08a4dc44ee4e2894f3c13c381c752a51ac85a7acd18d9010f509945dcb90b1cf7cf85f4b7d8b2de357a083874ff7c56","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
