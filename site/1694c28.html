<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0cd624e90d6a4feb924c5621941905366446fe2d40e0f6289791be10d2dbdc1fa93d429d3f2db16ed02a48174f30ffc54518b0cb1d8d98dea6ac8b554116f87b018fe15cc4f0159f965c374bd442bdf7e1517fb409d8ca1591786ff3d33fbd87d20eef1b44a4d2160e4c56f6d512931cfc337fae345a6e5b136ef02ae1f9041fffaefcc50b820f54dc548fd119e44cb8ed2b3d7cb756ba8a3bd0ceda54ebaeb0b47830b6ef96cf1e80810e29812a8c186d36a401496ffceb7af0cdf6d4c93f88f9444b941abdb75014c1d91b4056fc36ac29a934e8acc3e592bf5334feb7e4fcf92d5c506ae1e9ef4e4dc03868380ded2c0c75324ae42d828ce028566e49084fbbd48ac836c04a11674844593238f848917b8d0598f341574e3af069f2b22374cd6df28eaa12c87f065a75084c9dda577e3b2a2b80284807c5b56d03ac4cd170750e78b29097af97b92efc3afdbd38a1a58b331c86b2f66bb3d9e263753b39a42630bf8af1c073c527c4c59b9b7842647ae8bbef3baef0400ec83c6f0a0fd591f4932d3363b0bfee910e37820116ceea3c38666f806f363b9c70e1a560ca0b34fde564622db812cf7ccd8709b589127c9642d167322c95d52fa27b16f55293d84eb1d001229087ed540cc84c11baafb14b9e87a8fba95faf56f5bc696cfb5d2019f674cdd2d5b40d7e5b3c0f1092f83a383ac6472dd40f8504f8a5038a09a003e4a49190f6dd31d5a2ba938860836016a62bc8cd66238e1066b8bf06c27021f7066ee5d24dc8413c2a1a50e3a0691d98f78cd6ea3104347057ba89ce1eaba9dc31dceca5ed98ab51e76406a56885340fd402d6dbb9047b02482cf409e03f20e6ffa045669584ea9749a8d2161ea5a8f6a8e1651e252fc539faf902eb4b04476d1697bb08974d8a2da59baca6f9a117908e39c62280bac11b0e28d7c460473cf479d2ca14262d58df4dead2784ba7903dafa20f5a496aa38d3b408b99b74d5581b894cf7a40a8f42b9ff19bbd863c9ba8887bc14878e9b4ead13df1c4e1d2c27a32029422b5de91ccb209df31ed1e6b3e6800a3019e5e433b907d88affc27164e08975d7d33d35e08fb4409ecb8fc3c29ee51d79ae964df1edc4a68836d1c057397317dd52d0004caa5b0d4d981f5c1577a7e40ed5795bdccae2c9543c49f6a82c7fd2ba13ea0bc6c381a616997499e2edb94d71a173b504c2573d0f5931092709331cee18401921796f12d8227e24b06d8eec02731fc7136a43a3c3d953b9ec28c170da4926d01fdafbf0b94ee6b3b67eaebb3a04bc4390c9c5a89f326e0cf62b8d173a88dc782ad6526d80428f67b1594df7f862cbd32778f689621c54a2c75e01f02af25e999204d4f9b63553b81daa3034c91bb5ac65b77e008282fd85422a2a45f0ca99827531623779cd183c5e6fdd7c5ac87481e554a7723dcfe282ee17c897d1d35096d12cc3e573eb04b2353d5364fa774f8aaeed7c70d99ef54d6400d8b4cc6f6d277df4df242db185f45398898610d075af2cd9e6bb040afc34f7abc38e9df2b73f4cdd431f2f1fd6299b43f3f91ed6dfddf8c8e0f3adaca918f8eb88205535527ed03d49f47fc8ae5d4d92b51afdeaf357d9268c76635041f31e7898113c064b20fe764f3d1efc2dd261d3f2c9ecbc48e61a7730188b4f0ed80513b2de3e19ba6482d49d778e4ec891d5c581f996a2822d61c5504cbdec8c754ed1e89cce9e13f7cbe310d33f43fb9ee0006cc05d57f92630098187bbb6eb572d0ed592430f80336f86d62110d12ee9a70e9226b3ac10349a9f07a14cafe670967787d82d925baf7db5d352fdd7dcdae9d752201015f4d109f04c9b9a0df7f51e135a07eec9867bf318b68a41084746c1a78f77c0a4352e6fcd630c09057e0efe3a0a9423564cadbd064c9858d3b93d3ef978c61cebe882bac1e77269e23b7b87eba247c63ccee2e4377a89f0a8abef604e1a524e362545d8d5f73067733e37b8e9707011c92b4fb60eeee3ef1129a0bf2b91f53e8b250eb7c69aa4bf960032322532b078ed9e3a3965355a8a039e511016e64e7c1be5bd53a8d36be43d94dc8a238b81c5175ada375e4446e3802c0ef6f7e82cb645612a67b664862e70e2a8302636d05a68a6aeaf370928f5280664523b7b373d2c66fb3efe1b3fd7242de12e7aab4788de03e3b3c4a0ca52291726e0c45c0f13db50683362788fec282f96448beb95bb5b86d395e7b657fc8186797b52e2ddc27bfc02f84c2996bebebb8eabaaeba3c40a99c702674273e9a997f9709a21bf25e9c2f223db87c0f396491240c787ee47a26d8cd997f6cc7b1ccf9c3144a9576c43cd5ab00db0a7b07ea61fdbd7f851f98c62e4d39d57d403aac7176ad13d511a31bd57b27bbc775ad68c2251dc3892cb828f9b8585d01bebb91dee5192466e5da356cf70e0eba2b387033cd702ff10da708e273f12bf9302ffaaf44880db280d284b0c5d1257fbdaa21b574e909711769d4ec56bfd756adc6c73ff502a4170f2c8aa461da3928a5c1f7d2750d43d19d3957dea8631934d21db02827011fc10abb6b632e0162d739f7cbc7a3d273a6a16cefc8cfb13049442a10f49a7bb16c93ef49448da0037f25380d2f8362cd98777ff43421575c66309354338b5e29c3232d1f486634b1707cb27171e7d8c99334a0aabc831117fb1905fd9a2e30226ce2a30c4c6213adaf712b07af5cacbd8bfc841cd6f723c7e54418f383d46198fa414ba93340344ae67b52f73845ce8fbd237cbb6e83eeac1b2e0395deb2c97b6cbe8a5c90e0d464b1833b1c93da3f5fe55f53b5065e621fc5465dd885924594cc986f9eb22d2ddcf037d40f9417d353cf27f1722fbb4e2620acdaa1f6c45ea75d48aa41c72c6297a5664d40f3c6953070aa59d8bd5ce0d21b6853f70d8757d92aa5ebf04ec3cd11ee3827d927e74be323372d2e159bfd3c5c7d39142f4a84277b9c014b1716519f6bbcebb1412694e7d4782cc37031c78dfbe154d378d48b90247d0c884c5a89019c2f86d2edec13f386cf1b3f9a810ea2b6047550759d555f10eeb085e7f1d7296367e3665740076d4f934a8a5195ecd351bd4a62c4b4753c819ff01c9469da4101c3aab72542112121690fc9907b4bfcd62cc77cd25b4c9cd2905c017daf8a8ac59b640d4bbfc46d04186576bea922bb53aa5161928d1ad4a1b8c1739539c15ef2409f735c4728a6fcb5606eab052c2f0532fb06072f14292a8a7cc9e400d71924e2488e5c6c05309947e96240e1dd40291d6a0edbe36dc4853c545b0c398585db80a4445dd473a7ffed4bb8deb8f89f56c9c837c1c69256cef915daa30873979d4250d812eba42ce59cf178f46a750fed8293ec119ab979f7bab8b86fdb334e16a07a9d3026fedd7c32de1d560621fa64ee095fcd285d607cf961ab1472dd18f85733f196347acb4416f81c6ae7f8d8fecf6e1bdb568c5bfd922a827ea84646c0275d0fabb89ed2c0241352633a1d798f74eb00faad988a19e683571adbb5756c9c913f4f9888687e95782b08366bfa9d1dbf5220145aa156a28d458687c35dd5cec90d5d8e4b03cfc10fa184c4f931143397b0d1b5286a2aca6f930685ef5a075aceb5f26821f585828fa7a9af00708415a81edee9fc987ec1271de949c9fc926533882a8b56db68a634e927f6f8ac97775f836d2505854f4170be9f7eb0d18d246b10b1f10f5d636b319927e41618b6cf4bd1dd730977bd374d6309d409ca408156d6096aeff6ccb23347fe732e3a670a363710c14ee772b4083a0d3d4c114748e44dcdd7b713b8dd502c8bd66655943e3b33006773bfd3b10a9803260deb0077098ca49967bdba469f5e329220a21de659d357b9da0ede60b595e69709c8c8a1b9f66870e938b639c5e671ca9c3c45edfdae08ffbcf95da69394a4dec22d5fb72bc7a64dc02faf8682e45d10463797819266d290c4bfba0c94bd428dfca1685af4a3261834a3aafada18f8f53b0916644dbdb049b6f3c64e23d6e0f723d4ca698aee96186866be7580fea573dcb5784107ae556ab5e77c2f1ecb43e35158b9f13ee70bfe3b2a31a664aeb821be76e7f1c388d2611c7a142ecefbab0a70ef785a33b27ac8832ac88c92c7fed026a72d186c1f93f1826d095b9f068a9bcfe53accbe3525aa442efbc7516f05075be9410f1b2e9c0a06987c30d3b80903d91e4f203407bbf46cbfc146f8aa53e5afcdcd0e15a825fd1416ad71e12571920a10e9eea9c0688a9b9aa71d4588cdada1e62f9809748465c168f0e44040b347d5ebef7f0bda36e767b22d9ba6361090484217fb2a14cec389d0a02b574139dad27ade96c78e5c6a895a46aeebe3135094f15831f6a8e11ae3b410825bc87d8581293579d0593e4a75604c73019aa0fca8abc08578d022cb3c71cd20a85d551f51a9c6adefd1fc943cba23a93b4202dd31045cecc57cd9dafd2fe3a5a3684a732ff70bbef20a11e823aab5aa14e008484720f366cde11616fcc7ddfe5cefba2f7ebe5696004fcc39c5bacec0d1063c4d074a90be53aaf494b6bdda482b63507dec7ce6082dc0ace2d5aec7e6de4ec6a7d04e5b93947ac21bfaa8cd60a587e949c3312341c440d4ab39f042dfdb7468d7128702b5bccc4ba666bfac3150703c87e04f878ffc18f2396c87a4b1779b1eb0af0fa6fad4423ae765aa31ace0aa7b62390d6e58faebb7c4a9b3626af97e3f5b0fe88d980962331fd749fd90bb753edc60b605df4b3196e20c6101908c5d6be6bdb9dbb83825846e6e3bb058a035c0856fa66994c4c5845aeac5e0a9c97d4d0445ea6e785b27bcd3a56dbfa533fb6da6a5ae2779a13312080b61f08ab352bc4193cf51dc8f34030fbae594307d83cc033812c0231c70938a0704a2a7bfbfda000779371a32be7b378d983b7b54642e3ac37b7b645b967e1a8ab07011539dacd1a14cc9a442300336cbb958d540dddfd3400ea7f3513728b9a617ffa6208b4c7dfaf6207a960ce276c5a233f38cb74585d97d13f377ca5f24b764c110bbebd5f4faf8a3a6a92197e3031047495cd4689d5caad46c1a10148b3964e9d8da906955dbe722e93dd6190c4f818ab9f57db1732cea7ab7887d1f04f084f4e419c70ad82f1ad09af9e79f3ae0b675245c16bd8b69463352bbba1877a71dfd7320726e2f16fc8631e32cce6f286c8de51fc5e0779141243453cc92e74b858443d7cd03b937433e8849d127167576a6c6ad5fa2851b38be6e6ced3cdd12a2157d52943cb5edc01ee9768940a40e4cfe78ed81f226750d66c157bdfca6277205febaae4be5cb3e0d45d30715e437058cb15b00ca3104e05150e7310b827390014923e951dde913f0c271767b710404190ea46ecf14584d02feac94bfe83b09a9cf1f9d38acbabf0a45d0e36ee75b30c9ab6d0b26d9d6f5f2b2e824f86947a3fa54d1419c9dd555cb90bec1d578d20635e6bdf1b4b206b188208b8fae0b48d2672a648e2a80835a64837bd7bbdda18106c37f38cdc29e09e40aea0ce8439481fcbe2058e9af91e59b7dee99c48e53738db426705522e07a3a05eae05d80c0b91a1fd087ea7d0e4f76ceb7ac9e7e60bbc85e628f326337b4c3e5e4f9a5a570501a64d729db173038c4c25e4bb98f63b1cdfd51ec8dfe7f52a8395073f46ea1765de1d45644e72b81373bdaeb1d214bdeb9d14a5396d22f1a2b0de122a03ff6951d9b521aacf6c42cb5daebb3d7202e42ce01b95779f0c4df40b545c3fd33e48f5d980475e08b04d99e67bb8d21a75a2906ef9e43fafeae4745cf26343ced7d8d71de4d372fd5d2885a5a5dd36dfeccd22f9245442c42886176f5635ae267b252ba881cb8076179a8c8152193cdb79bfaa64227d5dc0e7cb4d426187b1dafcd48602fba23f8072ac615b07605811b5d48baea73ead91f938a56c8d49233e0789caae40691ea6a520fb9137543098723fc393ef8d5348d679557884e734f552b856b04da55ccd9be1a48969c322988933b7e034817cf4ba7fe7b91bd4b9cb87e6cd34f261c7b6199feb7f474ef0f3a468a661907ccbffbe1c0858bbb518081ee30a62c8c7a5b01f51d25b66d6e780b83d89ef0a58aa175a4feb3a7f886983a03a34cc7e5eedc788c588f92136ceacfec662a11134b4d2128face27a4513d55b36dbfa8fa04fd9f3ffd5f4231259e01583bbd492de716980f6c821892c6b5fe3c04ce769d86268fa71ee47c3a1a9f900fe3a3888aded3c73dad3e23c46ebbcaf59c2281c8c1f795f9ba6d4cb4e534635cae11d6bcc50f904acf7883509dacb09114c1d3c62f1b3ab9be998d6e12fd2d7bc5b1f31915b0a5f81e44716b68d6f1cf9d258b01cafcd2a2eeb11f4bea6d369e7f68d1048a0acda6c1e11d8873e60a299e804f1c3af5a3b6b97a3e27569545358ba390ef836668c6656d551d3cdf7f0ccbc6e89ea25a54a0e0229450f17b720a14c4c815a3c0687934645172d1b7d2d7ce1e292b20570d9a2c81bd1fe90485a5c3e32111aea76cee00be58e970c11b07f2ce391fddf450da6340bf8b2c12ee2a940a618ac6d87e24d4d7281c40bc17ee309bc3aa05193827be534b5b225fb11dbdc05347776494b5dfec83f7e1cbcfb87120845ac53a083eb8e087312bbf8f9fca1836058a4b833087b859632ed5ba0f70aa4ec17822bf4a0471ebd3599dbab02d346e02f6f95d033d82a074f50d9be15faad96487c5a22056fbd8ac6e7dddaba656dc5d95f4e9e02ab3fb67d2cdc36288f0c078cd7a2ae943bf29e624483cd1b85523273bfee429acc533b88317b2f3de5994227b1825d710d7331e81f4b59d6ff326a851322c087aead01aab09e0b83da610e5cc177a2caecdcbbc4286799c0c54c164be1d4ec6c34202e6aea2fcad885e32a178aeb2ee75a3a4b321d112611bf77a5f1e2f03b0bb6baeba7ca388c58ce4a94164e2d21cb573d5c9c208e8e792f6d5f85816566df282f08386bd0f662a4db2a2cc1ab4a41038bd1f28e941d71572a4e7a9508cb56ee4b1b63408a956c3dac4551db5877a2b55ddacd991f128a97049d5ad4d879aa206514f4f3df62a3140a8d77e5af85bb108f3808c9cf875cc511bfb1d60f046f43d152ffed16b553d2f6e84dff73b12badb982d7bb45583c4105f80be32a08a5c8921086b07537602a4c89026a786cee602eef6087e3eb4d345026dcb23aead709a1592ec5834b42158552fd6cd28a91c9484fbe94eae86d7a07f9f1f861348628a6fe4fd77c9f286541de6d4976007e7e6a67e74ba4a52a7fbda8684b0dac17da04be002676644e40eaeb53210d3be43b2f5e40c133df2efb0a4110b2617963382495321eab4e093d53d8c201aea2b82e09dfd73035f229cee7cc66f0465e9e32091b10bf791ba2e67b52f44b2e4ff3253f80f09f4d9affaa307c718602a5a1c3352e1024aa7da5546adcdf07c00cc88748fdbc7d9b3adfa176c703a7ca176f91331b7b96b3760502fe5ba2e5b4903fdef482808534db2eb1cf3e806756f98555bac466e288dd9d9ef9b25b042092e017b4e9e5a7bf570b91d197cb96e40bca1444e9347a3d77ef14259ecdd4e33490ef171b1d7272f6a5204fca12c26e2db716c6d8a4a7d32bc1081ac4fba31929df5e3c3659dacd56d6853c6c057533c3aff8a569ca07830038faa2ba140f6a6dba5e1641626695dee0cd8d9711797cfaf8357ca253aee4b2332ce241fa12ef1ea9ed6802688b7fa768f83f75a2ba8419bef0a07b1bfce0fc28c3cfda55c0de244669da3c19dc317486ced77dbbb7580cd0c8b659d685a4bbae1b486171b1e8de0ae6d48636be9446c12eac548d93178ac8311d249828d8c1a24d61aeed5f72192cc5eb29ebe681676acc89837827f642408d22e74f6524d75a59ff2e2d511e2f5a7bf7dd7e965d67ae23693fd572fd7b8b61d921ae6d0633796de5167c454eb36dcf69b92684b3d75aba6433d717983f19c8311bfef85d873990173da80e022f0ad61ef15c5cca64ca5b60992cdc9673d05cb6997cc7e4f079e4cc6519882a9aef102a1f9fc6bfcde54d9dac2b76b6571fcb96b069f5369627bdef99a5a999d929c4c7f7e9413be6ae90dd7b8ecd68fc0e26a1214c6d56dd1c73d1e15207e540f69acc74dc55714eae3afd68c4d94f006954d6db23007e51768f1e444aca287d73688a672caf9f27a5239a92d347d60bf4920c8ba0cedd47f4421ca810966c5b11f5e0425914a2daaefaaaa70a2143ef7a37e236739d47e840779832a6767912804ca71750f4f6f1180106bd17690aaff52a65b72b822f8c98c040213bd77036bde1e1063c1ede05dcf6005166e7969c8e79a08638d712c4c94790f72475390b36c1ef7dc2a0549a36239800352120cd605a7249b75afc99a81cd83dfeb3d1abd30f740f23d7a526a35f3e4bb5d137008e123e0739185fbbbfa82a7adca488b6cd2d3b73c99803bd3a3c85ebfddced351bb911d9caab8b19f8b513a63edc4b8da10d712f7d106790b544787761f112dda45b96de9b258159959ceec0f9bf81cecf7b323c0db0c0b574948de14ba5ce643414ff61561263b9b2cb65edafd401dbd97421000168c6e7be6945965a10a59f18c6b894556b61fcea0d9d4cb2a4eb86610d3c2b3f7bfc579c246500493feaaee7d47f3052dcbef7c44002248d25da4b3f02147db7d97bbe771919fee0b09effafafd589e0c99bdeb6bc99b747b5400f1b16e149549f2030d94c32b7ff4e4a8efd67a76473f0920d21b2b857a31a90de180736bac29dda2555301f07380436ea045ddf4a98e54f933656109ac7176dc0e77a99cd9c44b395848a6ebff1a46216d72a581d37765e898aba163dcb43c96d4ddc438e4188458e1fb16575b0e2c08476aa61b1c6fe250f318dd77d1c571fcd5ee7c66ab378c969296f40a5ffb1f0db47b88a378661410b57caf211a7383a16db89ad4141c186f23392d194870cb75d2a8fd358dc99beb414f36d8bab0b5f4d0cd586aad0ac32daceaaa2c479c8b7d2b4c52bc49fdba0ec7f3f04047f6fb1e2d2da37eaf3f450b3e8f09d52e8ef79c079b74fd72e0c445f8f88352016e33ef4b1283fc0bf5687cb987ae592030c464a9705516acf00e89a28c29d635d6ff50086abc8072d0303f366a15635f09bf1c346e9733011514e7c104d963cfbba09eed126278738b1b9906ad98c6f77bc4e45f2e8a3bc2643655e98a8f81160544ebcae8045ef4ad840f079db66680c170d05b21556dd72424725459f6199fdc733e0067f92286b177c725329cddb8d4604543770a0b2c9b8fa48020c3e41438982cf8a0f1de244cb9831505809ffd44860b85973ad9639b44d68b97a02d248893a22ac13232ab52891285a5a9c2047f8536f2742f24c8d509e39b105801664f85b39f0db870aebb9058276e57898ee8fd86a1813eeb854e9251d3c7d843064cebe4d1828a59a91272efb9538d576fe772a502a5b594949fae95b7afc294c97df97c4a8198b56e6eb993cb357fd56ce552b28d9b42d6acf7b41c1eb7f8457de3b0c84c14230410e44467d2aa3a06d3ecdab270269e7fa501e6a59d7f184c92b0db15187547e9d861eb1f1c6d86e2a645e83f12e2679a6b1c7307e7f98adc10c0c5ac74263da63b8ec362d30b72c41bab87e6c24bd753175ad3c8d9247d0ade42dced31232fd8fbf5639346e620f4a366578fc48836319e86045644ba783149fd3390d24c534d8c20c87a47dc6a3ec7a858c701cdcf579afd50f96583c3197fcc09b5d6acf4b785be45eb7add9c7c5519f452dc8ebf4ddc96f1434fbc415234394277462f7fd153b6079a3a267794103a347caaa688f58ff79c413dca040b6862d453954b0d223357fa0ff621b3c9e2aecdc09538be02478c34be2139c9c48bfda385d124d2b2e322b3245c4ed0411880c8517208b36b3d403af2d5b0d62ad209e99a7927ceda3468cfa6b46db99d45ad0a872f4d8fb2b723c5e049adf1a4426e48749308bb704e0c7ffc2a611154f7cc4442582b7d601866a1938484555371249cce12d50167042bf2dea14586939753218e1e14a5208ad6f342e20c9df32b6a729b7c66d51fedcbb598d394b9aa9daff205b3b2229006bfce79c06cfef99a457a015ff34172115db5df303bf26e4a79adf5a9831ca766499ed946ef9529dd17d90f1bfeccc94e9c8665d0bcf5d04633c1538b8b0fd90ebddc24de51bc4475ec5baf3a0edc785dccc193587d6e666bb8114e17dd50c58aaaa2e7865a62fab103e26803044dfd271b345679c5f790bb442d99616fea47a7adf44f13ffe97b02619b123db1442b3266f88188073a533c8cfdaeba092c3716fbb070c350ac9d85535d07e61e45f0d286b5b653ac27db96fd579900456e190842f8cecad0e3f6a71f6d3e65745c19ef01e71e5bb29ddd4299cbf35f549301c3795951a38b72c8366431adfa20a9a6efd6fd4bc0960648f8da3a35bda47e9033c9a5deaaa8436de57b24e092e46ac6d05b482a1e353e7854f15f47e14a85e01508ebb830eea9f0d3186e77bfd5af4250df80c1a9aaaf9b37e7f20ea42226fe253f224192e78e6224815ac043f2c9c9e8f382d8cfdd54f4f956d08d7ca72300fe53ec3505550a0e4d547b0efe4229df6f3a13bc4e341d9b51d11fff0d794ece2f2e7eb814a9351a475d2f3557ac1c83d02fda256a0d083b6076e4eb14943ab9df69d58b92e6c140439c30c43ad35c2ac864ccfb9874f1d2d34145c06606d1756bf5675600e838f27fbcc42b0a2d498e077ef1d52a7ae9461d5ff4600801576d3d141845f8d1c6cd5e8ffb31b4ac306e627f7f29c081840ba8ee4212ca7b5fd51763124cd8208b976d6a355e908a26c02e6a1355d4e9835aaa028333c222187da0c6688de7a1230ec6b00a209292d74bcc412f4309eb0f43a45c15005435153160e2fbddd251d7f754011b53637a471832777de3ce3f77c231b51729de5652c28684d0cd660931fc06c8f709e16963b7803006e8ea768ba459efbc3af3bcb0be95ab65cdc3b92c9185f7e9bb1a8f1d695a5265c1f85e0fc77ab801919a21b6480d7801abe93272643ecba23ba3b3f3650eea02b2081affe3c149d1365616fc9fe150a1afe50c19ef2e7731d5ec73b9d3b9d13b425ea4ad0b926307a63997c02364f34d46ba468ebb05a913a7981bca101e9cbb50d3755dcd901e8233efc86ce77b3054129f128d947bcae9c7806f334499a49dadd5de5e5390e8681aa3513a7f0a75ab0e7683df61cbc33cea6fa10765c8e335a2ae1af20c066ed832201a30aedc5cf9d0a2bab311e3b80b33a35a82704c1fcc29cb0d60141a6a3dd46756cccfb123ca104a0dbdc13110533e118359d54b52075955590abca600ea76db995cb38ff84ec0035c23561828ae887a5764866fb96eb19ced9670ea78f0982161c6546a59651f0cf1fc14ebcb79de34933ebbd4725669d07c40fba26f8af1da4e343b83b75de761830c9324f49b94bf31115abf499e4069b78e1df86d7df3251fc586bf3edd26375e30c70c42bad9d24a028bc2b1021c2fdd54821db9cfff288b7daf0e4c3414db104aad50be8d83ed5269dda5b894346fbe0ab70a939fdb3c197f37d34c744ba73facf6d8b4b0cad427a62f1ecfdcf997a609e1040d32cf9e6a49f2f98205725b23d8d18a9075343500c7ed1368ee46a74e7989ed559bb0f48b2341514ea10f59c998cd42beb39e8ac6478dc1d8d7a6dc279ec63027e51deda2a34f6b15556bd3de84a0025f716bf84a45b97a12cab5c2499dc071bb37f7511eb3d0e1c767ce918f9f8f465559fafba52df75e9c70f5a34623a09e0b198d966fe4342d3a418f7d8478f81dc81c0b6968932e13101cbd7fa076d8325d08511b59f27b398515bf7ffc3167100872080fba09fe0b20cae21f667e5bea4cdeaf9f8ccbdd185e45ab43b3f7c89f42743f8f82c064894eb1541707e6d9e3d042183f01bdc6fbb945d5a8fafd3f4ce8fa9d8801add60c085e68a760eb14cc0bf3a5f0290c75d2556b79634857835f0c3808f6ca1678b2da9fdc4c468b80fc988508dc31a75613467d91bf7fe785ebfcc24f2d6ee8096e217ad1189b41558e498bfd1bfbd827d403909bf7b1011518409ad15df7137413200e25ba041464921d0ac3f95e8c8bb585bed613e1210329474778b55d2ad6116fe172e5468987be5c6fb0429b4f9a2b13409f6c3734b263edbbc51265f55596125c3770aea9e4cf49b802ee5884b87690de5a41b31a7263e9f1c1d24e2783ecd78130ed398fdcf5ebbee5c1170a71c5794112d96f0c6dcc11eef29dd496069cf46db543dfff157eda1f2c45a7c1ef068820d815af33af76fe1104a98ac4aeca99c22d03e8a88797eec2938115a07bbbba84c8fb55a5cb7e958bfadab61b2e4f28b4675c2a743370aec2da4b27449336caf9b8035554242f283b56dd664392c77d65c254c29d43c76779d4e6a476d42350685c1f7c42960f948ac0940acd9d3a55de43b4396b68c98ee922e22578272145ef35f13543a8ce775524fa057a6d8c1e60130cede61b33b8f48873f90205b928d8471cd25183b00869b9f15c8e1fb626ba1f3f3c256f97109eeee39cc7865423c9dace0954f29104c0733cfebc489c6f08122208427acf0f38bca7b24e6b57bdcbb66f9dca6195ee035255b6e46caf8ebf017ab06ac9f512756743b4a7d62c4223f6156fe4195a94aa52b1ebfd0dc20665ff78ada134f4c4de87cf4ca856685de7ade1d87922aa1a8a4eba1e0fd841d8528641c45d71387fb14e417c3607d8e2e2a1894f2b6713ee7555ddc419a19d437aee50296b8dec92ab5381befc4a03c8bb23a65be7d935374ba987e8111b99f05690a9151c37a65be0336c68825b7257203352baac3e6e40447841651240844cdb75f6e77d1b764283ccb62d6e85fe12a788e75148e96746e2a6e97cdacbd7057de21c324ee794d2a872bf46a0daa92077589e4f5cf3264126d059234a2aca1b1c5649cd681e0104d0afeea66bec5af73a8939d030249425caf43814d11ea6239e7424775a2e8bdbb542dd478263b3bc9d4db0f14ef65cb9c559e93ab66ba0b09f0a7495d20ef06256ea2f8b02fb9d38f0a86f1a519d950d5e6d35dff0856fc04b19bd8653167ca732791d87699a54a4404abbd87934714ef57c92ffd543b42563e26054a1a6095aff54bce4c09eec80f2a2163349797dd99a3e88e425bedfb2500aef291c6fb4a543b425882307190dce046f0493e8976eefecdfa7482017fd63f73a1c417d23eecaa7e8b78cbb7cf71f5dbc568788192dc3cea572997d24217198c338dd9e5c8d41738bf3bccd9cf793c0d69aa277c883c751bdc03c6db91d65ecb5a1ae68a8a4a1095089299a93483083e2a77b7b749a230af09ac6cf2f7b84c927691bb095418f2a772b688e4defca91d392ddb75f8d10ff40944bf046cca338640a529568f789154a1fd07d4df970f353d5019045994b741b537e3d074f6e6ddc9bb980681b914432bbac236608c939cf615a7873d98b27726db79194301f2a02b4aae3406fd847245b9cbd2391783afa5e06713974f103718c5c8ee1ca38b7e795c4f8a6ac108b5c467cd9f56ee3df15f928457c85aa45b31f8497ce8f1af8a2d28c03525f2df1a7e6b2629bdb73249d05f690a27d61a2efcf97c0273e081b5459202038de4bfc1d108aefd410d685717d604246266cc800b51ef017c3878ac785c6aade5e7c25df89badb5e4663ab99c104996bed2ec0acd2bab58394becaecae7952ff44b89120f5dcc38ade62e55ab446e801719661ba182fcfe43ec29663b79421b62507da9f16ac725c80cd8dae8e1124d15dd9f7ad8e64fffa6b5bc44c8f3255aa405c990a7e11a63a182d42137400af989beced0982f98565ae99a4f63da99b4bd8bf3d6c6226d64bba7bc3e737678114710a430855b9e6fd711a56370b55d9f8d6887af6a7e42d20722d782982eb6474458a2571bbffc040b1cea7344911ce6bdd63529779c3bf6598fc73c3ea149496f5afa4f1376c7e8632a2c01d84783ac302119b5d97b6012b75bd622e1d36dbc6e2c28b60cca374e12e236b22465b441f604428174f96b5e5913e5b26997ffc6f92e586164c36f78f270b1e5f948ce3b1d0ddf030b2f565d90565f25627eded93df6e04d8fa185d867c738caafbd86578d9ba379eb725c12b2a04db60b3f9c948b97e741ef5407c08f772c9bb5c6f84fe7b2571a59ee3dbf5e1d997f85015dc50b28a7451a2a77dcf678beee3af7ff2dde8e4604831e251d0a7048cf0cb4b305febc8baa21e466cbe63c8d31c6d79a7b8778dfc66219d8821b62595fa3161a5cac395a7f2cc7893de33da836912ed2dcaa67f58497a8e70e46582183c862631db8e66c0bda9bbaff8407f4b24d4724291b79c0b12b79fe862db5e3be901fa4a538b32e74eea4bb52df076b3bdc282a8bb6d6a5284b8440e955beea155cd6879390b445b56711a82bbe0fc576b178119cfa1cb682354f2fc92d473deaa87f841ffa4f997fab74d984fa97bf703742ae134c2321859dbe0a58c8e679018b474f32b924bc7abafcc9ed517bdbf8f4ac89bb97caa7df64406db8a53d50520f19b242b20f490d017e6cac2a5215e6dc463fabb7cf196ece04ad079e593bbc26f80fb1db2785e258cab4693fde8343456f59fb49e3e4d7fa8c5e5443c949773aebe9a8ee99115d68629ca57d337cad7a1e455b55b4e5417299ee80e3f00a65e5fa5c9518904e3878ca8bfab08555689bf842d9702a6f009fc2bab0c7a1df8610735a6cfff372ffed4c670d961d4603645939fe60e748deb90adf2ee065581e19a6d55b8b48ed1ac0b8ea52b7fb5f895ef910934187e623fad532162ec5cbd1a8dcf6af5bcfeb5deec9fdaf9b6452cb8e1fbe08b714e617174d8b178bdc8ce8f67a93dbe19159a70d231bc7676f4af13ae3f73cb8414dbb324a7b6d5db3930e5bb4d8c2e49ad8c8a2df704eae9b0e8345ec068f39ae7dbd95854fe0bd05a2dd982acaf2bba5dfcfe8a41d3f9ab4121ac9219b92752c1b51891facb964acbeef13406fe0a6a0ee3ed201e2e2d97e234fc046e07131c81a2b27f12f1cc8455dfc50376954211083e4094254fa5e531f1b9f13f842b68972f3e2050323db3638bbef5b9ce1dc9ddb59bdb7a73991fca3655767166fa6e54d3e4ee522ea30def32c45ac3f4fe48335fee23c6963c10aff5b1055c70ec563cbf79e04991f53bc7fabe1e99413e77781de3fa9e3b25d2e888aac854f545d32bf58a1635ef1ddbb08c2eb2e77733c75b9ab1a52022a4dc63a8bc0f8b87f90603bdac0d1b672d74477c411116c1bc69c55d0eb54d47d35be3604cc707042fa12d546e33834771e51873aecb70daa5d84020461371907073765dc518738bb9f3344c94222835bbd0f3f0c78c0a14773046ebff64f5b73907eb1dcabb8afe8e33721c01933da937f77e321a1b89a2816cf8d3482b9eafce99753e32c7ea33d5bb04623d9b505c26b6b3e851223693279d1185ccc6977177d6ae89da4f99bdb2816e4e8b94313fb27bfc0a52332cb1fd21a6ccc5e416cf2edb53eae52609338d9033b152884185bcfe60387625ecb6e3c7827c1215f97d08c1ff3f30971803df8fc5e4d1c5d1998cbebd91baad6eb56cb1ecb339d97fd6c729ccd5ed8f53e9a8cb08358cfea8c7df5664d77bb56037c809c1415ec843334a6c1d3ef810aae66f731323ff0af6b2449cab362f61ba7ddf7ee4459ef228907a249b59dee0fbd171c5b592ea1307e82462260ec40c8fca7e92b4e145476fbb6f562a9ed36e3508179b42fdf9ed434e40328c2e75b346597ebf4fd02aafc2a254f6bd3887369910023949dbd73f38154f98ab11368dc8235a89f315d19c47312fe09ee621aa6dd225deb3bf55d5243b7cc3b2cfc61bb412cde5f72c9ef2e476c91fdcfbf6ea889a5a25aeb461b643465654be7153d10e437250346c804b1629c0c33a66ac385b8f4745857967b29b9b98cb97f3650c386b7f5d62c279be1fd56834f972673d4365a65a98826ad9870f70a9dd8eb6216bbc2390277600e29e9dee508545dca78cd7b6289cfb7ce9efb9b269c3e414957198d4182eae110cfe90902e1a49381cae5c3db8da240e06d4de919c07d29caabd0815736fb84fda6e4b1718a2d0ad8b7038a48c41f3be2f70004774515e28fc1a4a537bb408dcbd15ab3d64362cbfff1a9f08ec1bacb8f151d4e82191a4f4703ef8a14d2bb0a561fd3d660fff39c7ce826724d8ee7a2f30a7add602792ace8567732d4b73284e7acfa2c54bf4d34eca432758c9ba10d0fd1c58bd5c75f3f360d3f1442322a97fb62f47e2d20b797fc9752478dc160fc0089352cbf1d26cb14d475875d9906b1165fbe8e046fd092d46c30214081a13876fc5c0d2382d63b397e4df098de0d8bce9532c25eb6402f629b3e1eae5d9e492931f42a8fc7505bc78f0662669d1e9afac064588df0277d4820bc751169d6b955e180efad365018d50c56d03b7803e1a9bcf51351d2761073b0d15ab3e26262a82daa43fa38e1a285238684557fcb2a269c8c5c453d5493507c53d7a8df83228ef3d310f568fe9c93a6d274bbce68114284a97ef04692931afc808332a2a10e32c987e554281431be9dc9f8c3d4950e1d4d691078be49574781ff0888d85b9d6e7b010606ea23e691e6c44447b06a1705fca8898d82c748fc055b3921040918481b5499000875fc3df16e8874f8adb23fda1b534fb1c0184310306e089d61886145c2816ddabd6a9b0116e9095defacb19c20e3a85712f4c724ed0d62743c0debfa2fd072e1c38eecf9d62dd6cbf0234b896174a3c1c08042751e353bad40f569fe9a4a063eb8082c7ce2422c3675941c29ccecb7f17a31ecd9cdf23945affdd4008cd3acace95f94c53dacb8a15b157561c20325138a69eb81cffdc750dc9e7e6c89a95be5f047dd800c413a7ca4c4a5306c8c81575546e7bbdbf9a665fbe254ddd7dbc78240f82e09ac0b3c5cd5b2f8f521e23537a852594c975ebb10d3ccc99de935e2696831c0f8de60b429c4be3a784ac546f7755a6ccf8df9c9e1f43e2f79cc3522523298e762528df2bf5cd9cdc467880d276e0fa612bb4b177e4809bf7aa7e37436f80d19de03df9036fcad405280eb501d0a70ec82b6863769b39c55fa8b307a03c0e435df6494127e82b7469eb85aa1bba4dd30bdd1739ea9300a0681461287f70b33bcc2f93731bb6e2c80548737fed5b89a8b28f07e8d71af7578586dd4288f00a32f75411f83ffa40e1218e4f6bcb467e6d478a48d383635dc41e1dc83f72343fe31cc2e11d2e06becebb4774ce4e51467e0ba0eaeb5a780695b735b8ec287016e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
