<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a03308027d58051a6f799b77a588007e91eea35053cd837a4d8536ac54c30590216af8b38253cd8aeb3d60753604a84f83ce0b1b272a931349eafb642af3e89b2a1874c7981652aead4409db865e8c0847c14a0979b764fe6aeead4b7f9a0835d1100669b48f380b90e29f2517e4c7f91ee487a7f54b26aba4c0edfe488d1d7322c9b5e6580182a35040c01de62608727329315f0cfc1e4d28674ef9d38d0bb0f194d5eaca100bcee942a7fbdfa4c0934b8c1340908ed2892d1b3ce8a73a0a7d59e42bd0f2c5cc526e3ca62174bc715ba9c0221dd4a8813c524b5bbed2302d32418f93e77c9e3ce744ed328777252ec8a130a9249fee866bd9377996e22cd359551c268e8e4a3eb9c935cf09aee7fba41930d28d026600ffa871c58ea3d56a5c98a2dd910b904709ac8c908c59cdaba8c9265fc91c6aa8cc4671bdd2e9baf5f929fbca2baa0ed9220d71a91945dd425be1ee1930df0159df39c4888337458c615fa317e3b9051e4cd48d3cbe85b2edabeb7624a2ea4ede3b4a97aa79ab455c41b3acfc9f28a57ea2992ed6efc98a1cb6a4af77e8cca48837be43cc90789de953a873ce0c5a6a79afdc7c979d71b6e75f8f2e3b5a32ef079c7830280c168d09258040d076e0689250884b975a9ed3c9e205db741dac8d625485438ac27f7496cf3329df7683366f388071b980bf5f81286cfd6ceff24b8c2f75645451e058e02fa56e1268e8e175960c34d8a847df7cacacb3c514ea069db949b97e186c15d8273b517e307468c08d7e87f28aa944fa1c5145a365b8dca02defd6546b29164c6853916963742314c734ec56a0df68415e78589df47ee5b5bfd2c0cc5f01e8eb664ecca2208c5ab24cce9b35ec97993f5a0b013edb5844b2b23aa0ec082f1618d57f5ddfee80dca355ed8d0b5226e91ba6d56bbde6f3a3bcbddec07573a2644efb87ea903f38f6d6332fc413502a7af365a58c06514b525b497d9e05ed43e2ee49283b443e9ac91ebec0ade9c3b9b671d7ccedfde6218e5038807cfb5e1ef8868b60dd54d6eadae3231609f6d99c97195280c251d99958512d6b6c2c70c83e83f99fd6f9d8d639fc59df1800ab361bfedaa10466af8b0f3c812b5775389cdea2b31cb47cd63b8eea8f0e11f439bd5767ec54340838f6ceaf7bfbbda0409577ef3b4cbb267cb5851562fc55f44fb20d8f70d917097acc95287d4fbfa76106a0948419313f85712ac356dbbced75883ad7ef2a3453f8ea4f9cba29af3ef95235822a5cf20f51b0fe179fc50ba57d05e059baf3a2893e935c5d9f8dea7e043828280d8a8141c765ed1a67a60cbeb9d450983f09f14950157415a087fac561330d4392299b1bbfa3ed1d8b8e72bb7dc9cf3c4506467206052cea5ff9e912edfedfff340f8effb01cd99f5390285ea40fefbf3f38840724560b4bc44468797640f902a6109a87d903a0292ef0389c9f53026e43efa78a3652d4d216997fac3330e97c38e4257b5237f97456e0808f650e51938ef7deedaaf9103bbc7a6b4761fa647523b7b9dd5a37b355b93a8b88aaf4744a396aab8a7f2d1ab015335748bc99f14fc1941871606e6ce2fbf54306cda5b9fff78fdc001284cd01657341787adc44645922d61e01733801c2942b0c30051e82c466be814e01eeff7fd820d902f1166bb5fe4c2e274e8a4d732866849032cd524af982c86fa0fb1ffa336d1a02c593bf106741a9192221a0a4933ee6c7966004d2e16aaa72de392ecc9fe32732d493f783e729b240f56728c1f7a43b7d19d95b27ff6d51a8b758c133495ed182a7b02aecf8f6b483384ff9de9e7e6660b92741473cad17f8fb0ed27dd27bdd242b83f1e7f9089d4acc56a9bcb99f9f7a46695668adecf53dc92044494f808f9120768a508fbb84c36a8cf9a7e56518d18c3645be5a7490d2132d3145dd1f3a2fd036ad43f1d80db26ec2aad29c266576897edc936ae70234c18ed00d22461b9332c334734bf787d7e70e092156043df97c733d2a5abae84c12d2b524be115f0f4fff1533580142541dfbfdfe41e43484aa8699aa7a2d9091bde263e618c0d895f3c8ed8f4f00ea6b359992151694b7bf902b8cb92aca51ca15123067f52804aec53b6027e2335b4e23e9fd3dc45f4d489e369d9ade46d0fcebe444d8f57aede54360770b0fce583b7636d24ceedaf216b49d846b21a616d6032731f42371d87368a77ee0da4b61703ffe86db82dbde8218fca6bc3e71a9532acb4c4def44e5c4f5f3127d6914779558825714a851edadf3ba87405bb1a862e64992678470cf4c88c0be8300fb152b5ba6ffa028791679658bee40f66c16943d8972f6ae327cbb4ff26dbec51d1e5d6f370f6490b3bc59d4012c4878aebef6bd60c691824e686205cc717819f93d186759da2620a4553d6d6d02c54ec398627dee47ff07e2f291bf23e6729ab5a49db1acf0fa2876f654eb2f5188829e0a3cd10e2b5ad7745083fd1c2355c837fa263bf3c24aa85d1dd373203740012bbff4485c26744a999c303ffa23d5e235fc0ffb4dcde76b8aeca483f6f7b05b3c3cf4933e6f70b8b04ef8abb1a9551fff0262387f1b5661cb59f5c3644aa3fc500c313bdb00ddf412226babb94a4427de5915e454a2672d88fce9af1b34aa8038ca3c2b73bf0db89bf0ffaaeef6d9ca35e817bb7da92f1ca52bfc99a27922d6f234da01d45a770c54c5095f81c24a82ff2f1eb87af742a83628b50d677b2d0dce357257aacadbd679adb6eb83488029f644308a34bddcef588735b416f7675cdf8901d4d61df634c87d437473701bb25800d775a6c72f6a3a0a3a6b18feda21d389dacf45fd4dd2a87dc055b8beb4a0a3122cf42a7b30920a2fd3cc713a875b43611274a09768e3e998183b26f3184759a459af7ef9c28826ef881d86f4068e63747ea4f50a9d4b962a052a57e191d122aa31615d5d97f7e921904f0313eb6f62b6bc092983b807e4aa05ad82be38aee271b0df33bfd4cd8408c8c506b9c587760bbec34c9b8da4c97b175880badf561cc43d14b90960147116ab14e55376f2632ed3f256d68d2d85fc6a0b356039a7da98e98a55bc94cb71f31f403edeb786b97292e9924df317dfe84d593bbcd588b2d7b6fc9987cbef6789da89b364e175e8c1815dd2d9800723a0c6e6f07776f9310f7d26073cb3e0acab0829608bc3ac7936f22cf49bc80efb1bd8885371445b946b4f935e92e7bd10fffbaa9b7b622f2e8ba5490d21abe07fc3f5526dd0e92514f63d4d52e8ab85f9f70869d5eca1a330616bc35317399cdd9b210b6fb407811ec23e5d3ae59b06c95c99edbbdf2f7f971a9172763d1d50403f7d42ae80e765d5d91610fc49a8755cc0ac79d2402393c295f3b2e5ca67e2d51395812d0083ac8d544df38a224c3da813b13722032fa2afae2d346fb54fd62176bf8f1e0b48195ebce362d1842f92a9865c42c1c12072d080f5497eae3b235c6ce778d48aadbb82db4feeb8a26f3e2e4c2100ebf73c0fd48188ee9d88f0219ff9847e827e47e3307043cd9e744b03980c8afbf33657506b790ad765f2127c9d03886ed8eafb54e136d3dafe42be73583973cbb8aaf9e5e4d5bbe282c4eeb932bec1c5051d2f1e8c9893b5c7f227be3206d089c3b2dd456fb07f65d5d34ed4a3e256ba00f36c72ad0153f88d91725c6c7f87bf3d20236bfbd8c5895a9730463a8c9482aa5ec7466f82c882ebd0e4d00023c3fc934556323d685eaec9e528310f15473fde50da132de9237e2f51b4cf2a63079e399112e0d68c064b6eda0786833b835c0fcef2d3b268a5cceb5031ad7cfad8782fd6c09c47930a4539529ab886517d0545c0165e42b958b46ae0f624f2aef5130887324ddbea2155653033cc2bbee85b8bb567c5b1a7b88f145e39eaaf3ad6cd8f66e51866e1e09ccca3a21f4f36e134104c87d0d582e64402134d2600034ac5dd99a8e5028c1aedc19b086bdb59b4e01aea4198c702c5f48b0923ebe63d746efcf77de28ba751081a81f72764cf446121524d74802de61b136126b3c9dbed85a045591926767a65fde8ae631b362ddbfb79636d9c11884082f9452c8d8978a75f63aad62fa39e0ef92eae79a7f402ec258738eaaa1c55fb63910906021f5c9eab33b666eca5365ed10b8d246bc230803e999d631a08737c973bbc5e14bc00050e1c9062ef25a45d79595babf4fe7c266086432c1766c7f72bc204d04c887b0de70e37d9fcf8eaae713cf9ca287d599faf327bf8a9624479ca49f17467261d5fec96aee6d909cabdeedaab3fea0478c23eaafc185688abeb03dfb9745230d790c4c2d8f12ed0dcb1de1a61f572825740ec933b1522cad7fb5e2cff1992defde80871e5d77fe5bebeac894a41f728bd4fb1ac3d224c7f11917fde01b0c2bef1f1890d4f07ae1d715fddce5692f5b4e24f2ccb91aa951766ba1d3b61efd6157d6db840616d45b683f3cc1d6340745cee1fb2e29197f4390da34a3c1c59227116c5e09edd2c1666144ae54c731a99e26a06a6c119f19a7f4de79aa5f9bb7e255564695a4a712d4f0fecc6836cc8acd8a23e48fa6fdd8077c7eb393c2938ecf1579109d96712ad49b58f90a396d12943c686dbf7773c792e119b4628848b4279a7994832657c336c908e244758f537ea90f7d9241552702df357302866c55f82613dd7b3b1a6a6eff684280963d803a2c211166fd6c19d62778c81e00096491605162f1c10db31f8a44210400930ee46943635b46c29e8593e1642d8312fd60e62ae0e2b0c1f105f612d08f98d42c0ea041bc545d610e6e07e9be4827ea795c9bceafc4101d9454235bc3aa6b0e9abf2e26078cb981fab233ccd4a4758438d69d630b6c2d0792c1bcfe111ab03071cd072abecbe114a67380357c8d93f58f403b49d0eff193e73521949fa6eb032371b311de12e87e23bd8f4fa0f787dd043a24ed75781deccaa46ddc395ed782b3b2533bf79b0c9b80b50e48dbce3e5b70c62b5f50a7b75e6c9c0f246ecac41b42d1116eeb6ccf0b25a6ccfcb84503818e55c203be09c285692a1f62f000393f93e118425cfc31f44d288a584adf72eadb466fcb2d183fb94c5a281cd9a772eec3a7581f4db1d72b79310a945f03e9aa39266a5cd3e3c71a25a970a5f78bb0606b58b8aac83a074d7fe7bb403f5a17b7af9893d3e1f29eb93ebcda31cf7c022aed3d5d72dc2c18a2239eeb0a66e76b1271370ff1954b7674a66b2cde4091dd03f85625c7f2a277e23d870cf881cdd6da60e0bb88741cee07732b4aad51e430c0af66106d58890061cb6f1eeeb953bf9fee0453132102ef57901af1736198df7d72e6089b75ceeb04c1a2694c1a1e6b1fc02278f4bbdb98bb31b2caceda09cb05b227d502306f98ce11f1c206fc9878e4f754438d1790c2967f7b5b0619b68a84193937cc48b9dc055afcfb16caf41a22278dd620588d1f4091e2fc8a083b6d64810762b92b63d525f42fce6b115d998de2229d7c451098a314d2f8aede9b76014ee561ef8510a2c171872e84893b95dbdbe3dd517fe6c89c9e4064843bb810bd55172796b68edc09f83aa6489bd24f91f56a2c1a821743bb25af063dc8b4b2b962403f2a71efdc61ac037965804a93ae93a1746d6edb3429740b3843adda25cdce2b707402222193ea77a3205ea864d13e54c1bd31a21fd5c7a9e85090ca6f9080482c1dcc37e6814a7be3be9f8e48fa49df3eea4307487aa84af05529dd93b077394d305de9ee0ec5c350c81c20e5f6a2574dff61237ec32ab8ea94f252e697ecf50359da7bbca69a7cecc948183dbf16cef10f10f12e447f9b83077decc47213e613796de702c8762e1d4e337c3a40af8fdb5241dbf4d12b91392f38672e44c606cbec6f27fae926f0c2f477f599551deefb7dad18debd91d5da304e67d6463a20cc77eb1515087aba69ce6372aabd17bb3081829d3686170c3781628ba0f23a712611430532464ae45f5bd3efe455ba911454a5765d29e4c2aacd41d3a31c2f83ab515a7bd4df775b078cb7ab0508c94dbb3f7d01aac38c5ff484cd685533990162c0b6706c6e9762aed4a7c95941a582c81f38e5c84369d6c59a4e6fe945660302cb67f28c235e3c83c146fea3d2b9f653fae97834b0df4b743624059bcfae9e994f760a47c5f1c68225566c34cd06ac4580151325762ee37e0640db406f88490e9f1de6dac6da70d730de68c82b1fedf7b96abcc96410b5ffea71b20f2b0c488193e3816a7e437e29ff16e0b97802ac8d896548214160ed495a1dc2257a40aa4e432b3a1645520de4fa1af3cb81224bb9e0ce2d385b740628ab3302d77bb981dbbaae6e9dc09e1b6773682ca39c6cc80fad18d0749468840a1e41fb7f73a79101711c303acfc30b0794bb770e1fd2541aff38117415a8250354b5f615d1048b77ae96dcc8efde8515dea174de096dd04e4c015507aa865f90416ca2cbddcb8851af1f6764133eda199209df8473d5af3570a00c00a19c1f1083d7d8549400ce5a6d3eab12cda820144ce3a98e8e960088c49dd048812eb24aee362a43246eed9488ce81ef4e5aee408eff3ed124faaf6a4e7581f0b7cd332e4a2bbbd2814604913a02056b340bfc52d54a97ed5c54697c3ac19216e2b5cfbe99a9a8c5b983dc5eb1237ba69957b5cc160df4d7deb15be5e13b1d6e622a9758f20fbe5b8f9f4f4e8c69962a8e2d5bda6ef72cfecca6d9439320babb398a9d1e3620981124d2c50ce1303345b160251473fecaa1dbc43a0d3afa88634a924e1a5ebb804eb290992a13f044078e7cca0bc37ef1087d205c729ad32b7c94fb553314274513a060a627ae0cb075ad7fc5c20e8ff5859ccd04bb1ef5fa8f66eafc7eb525e1fda3a31e30a8a56c539a3be91a3b73cad4598d99e2b4363dd7ef4a8dfad48fdf9eba47e6d15a011881ae07e843190c7cec51c87803300dfa76bba1ebf5c256361f6fe6d815ec8ff589501fc081cf5fcc03ab886d2e4808b8e189b5a40942a8b601a5ed28ef04c078c6684a34e502df945dbb4cf09879f8f8872ff374744741646c564e39a3ac7c49efbd9e2850ff1bcdee57336cc165c517f951a7db306f311c89f6d9ea8fde3076e5542ccfb72fc8de55451ceb9b5bf156b2faae20479a6442a3983e99f36af331d47fe587bd6c96a79bf02e1c3ccb37c13af180c88dc646db0ee4a9de30ad78f645f1292e733d9f9e261b720628dc42dfed0dd60181368624e359f738929ff62464313f05450b4f5b074be9416b3f7a7a1bfc1dd907f06e9f9a5f7ae22e304bf9d7fafd5aff37addbef659459f10d46b7872590367fc9c52bfaa779f5d231c867b73901653e50fef0ba447b4c860f094df2ebf4e871e6a1b23117c0cb2bc2fb0e26120d4620bda97fb8d49b492e1ced41765a8545d692e78ed9af858c666aa785b82db56fe04d46b5164abeb35a9ab8006c58d7c4571838bb7f874b2a7252a298f3a8bc24999dedf6141cab579dae708accc9c72c432650d8812f7b31d0c79fc4f9e57a63734233957c73da882e7ee38ea8a76a9373defa8aee0e5ddf617d7c9b3d0d0c65d13201963f643577c90ba301cff69f14d12c459bb2e3f92bc4d2b070ccb92579551346ead92c549f314226031ecb629ffe87611fc9d53853709a93733437ecb382835f6ac9ba46f7d58254bc1ca49722793eaa0ff1da1e285ce06e4910b6096bfd99e1be3f2a97bb62c5253fda0311398d1e9a01798df184f4338448ec63f62d8c78d46de26a021fdbf38812c3fbc6c68c913d9836d656dd5841b290ffee9065d09c75a65752c542f3b14d5fac7c1699d1ebff8eb7ebd9bacfed8d14045c740f0750108eb3c1f1deefc47ef120a498df1afe61ead7c52d1e6be397c709295f38c72f769161388255bdaf699f434ba08247dc329494551ff6bff477fdd3717a70cd09b8b25f949da1bba2c494e8096e2d66aa5219f6a4ecbfa8700f395799c8a099d975f68a10790ee994a537422aed19528c760e4c7bc347decbfb8ab2ae160a553500f2ef3546040f240b632eaa752b000baf533de4805ff1be5d77bfebf833609c949e951522790e86ad6d2075ed87cc87ea8925269b9569fbcf948b524500ad87fc2bb6627297364efbefdab11ff852de0c5526e7c432d6e168aa56496610acd6a72237d537ad3ebf38736c4ed4a7bc68f4c5038a85ef4c404fc8d769a4023ee06d2cbddb0446f9c5f2c2074347724f32650ede7ebfd01d7cfd93a74104fcdadf3ad76f32b52576f4b428403c048643751279c4975f51fb014e4cac41f4910b850344bfe9e72f7eb30334448ddb8a124cf7641322ad6657392eda2c1b7de04fcea3eeda2d5e228a5ec229baef265c0ffb475c613eed64b7cae9c3af0b25e77348f7e243c336ea05b06cfb443b87563b4d59310742732ee136cd72044b4caac9dca4232dd81974531e05bc8128df890afc5d5f0f81495d15d9830f69ade9c8fb16baa679dea3e4690feb759f480a163bf435d8b3f551bab959cb984cd6bf5a61ede904a419c150f7a87c0f8a3ea638a4c54ccaf85976f95364800b1db627e2669b5f55dd068fdbca5f6a7e6cc987dff9092eec0026ca17eed86d1838721540814ef79212806b3096e772e0bd245128efdfa4db89a0d6dddd1681153c1e375aecad8b8a6e5b51147edf34daf85b6037e836010a914d793b1589b7909cc8142dd655cf05d3e0b902d2ab9bc38bf9270649c1015e245e47f935af3f595cf5a1567fa9d48883eea5f4da1a4d4e4158ddb66c433ea0ff1c7dbb052107e509828942661cd05036bce67f868886e91ee090072b5b17ffb45c855cf60bb31a607cfcce21846b940442cad5835a617e4d4b1b76163cfed5e9df91410b5062b0ef4b11ee4f803aee1e0c814973f3561968b8e92df1d32c71197f6388f98c3709e987f98eebfe81000c2ccbb663dedfd44b02a211ce6b745fcb82b22c43c80da0e3fb2ade751f0a2e352502ab36b158fbad594e503a4507e838aedae4ce6e5903bb40a67fc1f3f274e08d83517f8130763fb47ca2c1d7f2d69dc0f7ed4cfbb71711a73a21cfa658c52346f13464a2f8e024109418ef836a8b6ce2a74452ebc1c6b473745b7b642811e38766d5503e693396df7b08ab5cd134b57bc8608e9fb6030f021147f085cd1bf682a1fd45bd41e36387a61994b47740d1d3daf4423c360a49351d2625ad156f40340fa3ed8ae18cfee67aa1c3cca0ceffcc35af223ab8e1f0d9e470a93b9f9421f5aeeac1653fd56d6b411d040e7f9d097e43b49eebb52231b24c713142a02618173b828b546dea1c4c87be0709014f1952119d1aff34cf5397d95f544a1281804e1c413ac8c1a1cd29b8c7d12c0781f7852bcfca33d33d7f50830d1ae13435cef6b0cb7da1f559278b1ca3e5e963d2890b425cc50fd2213f738f9b4f6df5a8e50d29ffb6d4921b8a06ffc93c4336bbc0293a82b638be615614cf00818bee450404b5a8c788265eaedbb9275fff0623eedac2cdd773b039c9d4c1db880de5a84f41a1cfa13d58db396a7cc68855ce8fe3591599e2c954dd69fa17037ca6684df0280da291d08ea18daf99f53f116573ff440538a0fa87c301e59aca3744d39c28bf74087d1d42e65f7a9eef4a3f738f985df719b43b1deba29055c4e4a8d8cf43c84504fb3f9c8e0f599759407fb87b080ed8b5a8b9d71f06d004e706ad5bb2dcaf5946cadbfd684315e9a1b45bd0b5e97339b68c1835f35a1bef908423f390dc21ce1167f7ba26c231b642fcc3124c50c134d88eb95eec759815061a7c13b414012c5f883c9f069dc62a2fb19a1f8003186261745f2b7edfa73139be87d5b353f71ac5ff97c7d2c23831f317a6a86ccfabe3741a44765b4a24de5e3151dddd787e342dd638c370b9530785999e577e411324f3ee458912210e7f76608c4a02d92f3dacf3eaad845febf5f2be0aa1a97110baf3adbcce064a9791f79061880fc827fbbe784cc209af4137155fa89d9f6564f37d79da9e82dd08980de56eb976202a9b843ad05850458e56b9acabf1858b5793c56717346b72d6e351014696d8c039c936d5c82b071706c665a1c6603a03f569ba90b61b12813a205120772811d87f49971d07625c6a1084f3a6727c5a939edcbf609ed0c163a4b6a3759dca5b3df663bf765b1bce05895659228939dcbde83181d6667332d2dee441dd4186239a082c59b28449cee9367414dc5424a70f08e369ce172edc121b5f79d0b8eff6e5c76f3713cb3d6925f2820a6b5977e273e631f05eb4d82f552e438935b3b070b89e0a79273a15b33a86e0a5703d777ea8640740a405b66c66ff2b541294747d353b1214ff9f961f2a1c262976b0162134428e4424b8f8489b67333b49e249657ff371ce70d88cb2aa41c9c6de5f8dac9c94bf467b2f9aeb261bc7d95d0fb3b4eb9fa10652e5a0cea2aafdc70cabc0c35f248f94e66a8f1f211141dc3641dbad57e755c0e355b83b324bc6117967d093c84ac787a62fabe0b0d1fedfd512066db2836c1747d65838baf29cb2de03edb8d6e657f1cc907d1daccc444c633222a02fcd66d4bfa785d1de6efe8a7417fd98a4cb020eb79865b7cae9a6423ecef0bfc5b5dd1f01fe33b25d1bb98931e7393e6dd0d6ae9e5009005695919358354f2019965f9479f8a331c7625d61c810c1bc2b7e319c2abaae776f425b17ef5dbea73b643f2572f40f64b36cea569c219fd6adee891efc57df60c8fc8094531859082eee26fcd27e3d4caf7137165052b71ef27a55aa49c34523579dbf09e23d3bd4926309c5cef142d1d94815a9ec60185325439e833273552e71a9e0844a64280f49b5f6179128ad0ec7fe8c5fc527cba472bb07ebefac7cbd4f8ed793458056413ffd675d5b74396d5e66391afd668e4c34ab50d4de0aacadc51af630ce129ff09a6093b28b5b9076f39b00a633a2e4119f30d6a3e50a051baf83544dce65fc85382eb9818e06e1efec8a7b2d2725f61135148fba293273ad6b0065b6ac129d0f8c016e02f677dded81fdba53fd303291c865df6ba18e4f38d2eb126a6578f81172ca013b5b874d52c2a44e546877682f146f83ba19ba44f69f240502315dc8218a7a3eefb6af09f9e4983c5bbb6be15b44b611ef4c528ce61a2ea7ca9ad0da378100897910b57a4ced0f5163f9390cb3307c3f264401b4c09708aed4cac2cadff2ea772d61e0d9a1304c5f79ac85d4eb8cbebc8591a06a5f7fd9c8dedf656c6654782bd46117ccc2dcbc85dfd7f09d1e612ce694ea5b99964f2cc997c2c5093b40a9ed942d1a25608545995e88aee55ae5326bf36f3eefa500573927c2218a308b15d96ad8dea625b7b7d68df458f7d8389508459789d7769f571a655e3bbacc2b080a45992aad99d2662d86084ae8a6300cfeecd8bb1b2932473fc7bfc8226854fdd86dee473de1396771018d90fd6f1a7f5d2cf89151f0c971e1a4f689c7db86f4013b4ad01b7d558a7c0a3d88ee7996bde53e600a5392d2f2cd7514407d361873626f1864c4f9249b4513673ae37541b213510ba2f9d81418b60e332e27ce454cdec0d69224fb6bff4893b21366f3287a41e5796727fa92327bd2404c6eb1c9eb092e0524c9454d052544a5a2159a565f58cf5e9517b30dede8ad543845b052d8c0b9a0cfaa5dc894fc1b12224193f6071ee7b71e426792ed6ba1286a780fd02fe831206649dbea080dfbdc2b4809cd5c8aa3b58324f41b5c481cbcdad0e6f6a04962091cad69aae66bd3cc46d3555abb3d95d868336a76d5ecff90296191ff7de5deb45c899769fe6bd021eb7d075a2fae166c051eebe394cc48738cae47f35744fefa9452722e6d92c0db052902af1048b76d53b099769a036fbb4a0d7f3df37209a5bb0269da962f4bb009c491d4e3cf4ab5b4df74aa6df0d774333ba5af521a84179e3e85a2208e707962dbdd901ec10aa9c5800a3656e63898f088dafaf6202408bd7abb5e0288f9579592fae4bc71d837a34f61508f98f1ada45565ea952f7c0c80fd47c2ffea507eba7f8980a6ee0306b2690ddced42e445efcf227ed84c265cb87a478dfe2012c9e5f2ba7991ff749c520b1c213cf863a5c5020af1b9c596d6cb81390e74061f3124e0c69d260dc3ea30c42070fafa531bd8ff052291b49262f66b9dde138a17c8b6f3c690864b12d1989721e7185bab15bcf4448766deb2a51784b456609cb1c94ab837dd0d770cd4a7a019082975d18479b9a03a75ba2c7a9000c23b90c3e4743c5a2d3a3955433bec5b4d75cad80e4e523f77204cb23e3d1720c642139c61e9f9b44f44fd6dbfa76a15748033b7fad44e7b276e17520f2380bf3e67280a6cc75e7b03ce21fd1a049e8cc43b70e3425791c597fde3b2fd8da5b9b13d72e75192fe5cdb5906b0a3069120bb56976145f8b67ccc16e4d4628fcb5706f9011fc73f8920ca13c8818ff7c696983e06e121243ae71ed4c0967cb5a472b58e13e1c76b292e39770f7382fba4e669da9b79b4a23f64e82e31894ec35aa030e6a0cded0d432c91d9e9105180340114517e1826e1ac75970c5b236402212244cd57eaeeb468de611c5d9e8c2938fad0509c4891a7846a6c78138f03fe2d46a1e5795132f5457ab7ccf70e368656b3f43403ddb6753ca43dfc3d72fa16a1eae6aefdd8b281f928cf6015ae57cd9e924ebd2d50af8293c87ec0af21e883c866050d4349d599e76199c8e49bd9126b2a0979b09bd46787f32f4fed97bb9ddc1784386cac2d609ee8872b244afe98b21ea2c86a1dd58686e91ad9ffbc31b19568b035b8501731cd81e8aa24dd149aa8926f796de11f4c4f6319fc84996eb97a8a4a83af91b9b90c274f251ab34bb2860318bea6a3bf9ba92b91adc7e316ea5e51a2ec890cfc484d20264f07b22ffeb38a98f5cc39ec54a3248a231516a88031057bad56101aad164a3c06b0b46bb2c22d7aec4824ae31fe443681fb8b9824da4a3b109422493b7c890885f5654fdb3b48c04710ffcf6e51ba4e094dbcf4754a01d701eeaefbf35aa4a0d16b059152ce091bcffb8fdddfa6faf428344ca02daa9ec808b4717ceb914bbdd0272a3f11c18fb5d6c181ae11f964f0a6774468e307434a43585e7eef8a7ff87533bdd08cf3a0c7765418d0c4fe08183fe1f4d32bbcf66ca820eb3b23174739a7a373451456865152fd54120a3d7aabd91983c504267093e3c3a8e4b6590e34d3fe18118cd72ab00b1ff28286b07b54f0ca75d50084e372f891b1b9fc039545e5aba74d49ed1c5ad347f67343da5fb10d163e1083adfc4e6d88eba7b9795c071dedc32d62fb23e4ebf299544c6d6322eba050423811cfa17732bb98f3dd110076a42ec1ada7b5de18335fca35aaea19eb321c78481de34a03fc33d8e227fcf12478014bd7899b142d48577f1e20ba08a66fcb8eddfbbea59a671471ebaae977a761aa897b6036f170ea34d15db489383b2e98ddb0c4afd89eda5680a6316478adbd8ebc7530954280fb7512ea766eda467255281d0ba1741c5a48905b9be8516f8f0004208d7ad0a13ad830d9acff0deaeff889184a225d9750d2e34102c62de6d5149b563a8509502afbcfd3c76139296ba759520656fb2ade46efb5ae582389e75322fbcda8ca788bf9ef312e03be265edafed7bbef2dc5cf92e0e75263c2ebeeefb8940e3d6249afb32701ca957a8ca3d5b126c736ecbf56a10a13b3443783e5d4aff97df6c8d4ffa1717fae5eb4cfec56d92e76a9d35877f72ea07c0462527989ebf0b589e883e6fe2217b8673157e67ee1d23aecf1839fe00af3f18a8f36a39570777313dc773a46e33c9d4971a770ef52d9f351e4ec1d4352426f7b371f5fa78c2b4190149fed1e2668b77e58e46759153808f61c4703e068f7da762ed960937fcf240d84ffb3249b2daaae6c792e45e743db4075ba6caee5017bdee7fe83369b0d0b70fd23f239519ae2f1f15629cab606c59d33ae169f91d602c86f0819005e7cf70f72b7d7990a2d6bdddc9a6cfb212002cc8ecb28200e4ffd8d6c8ca0901544e8caf17ae7bc2268fba964a7388b6c9aa3e3855e85093b6065558e85372c4dc239797ff8c96204e3ceb4c7a0a0639f0e8712e8dea97ab43c93187571be57ad819292c53d835bf5975629c26869fa7067cff06740e389cd03897c7e64d4b26484e7011309c4f178633ea8ccca296f6034b36282bf2e0289e1fbee72f7278226888a095e6f8352f0b2751930d1fa0b5ea7ab84e7cc7572f8d91a876b3f54ac72bdb25d3bf843530397fba786ee4648d1a59d769421eac4ca284ca58cf97202539e11c629b75434cb14284231915187cef3f3f61240052a9c916fd43098becbf2fa552b1999d651fdfa21e964a9b5b4a4989cfdfda5280d1c4cde5541f75e6805082aa80d4d248d090e9be0141591e925a37359aeda4c1e775dbe67d7f1cdb135591fdbb989665dad0781285cc611285d307991599437f36ace0791fe310d85b1271fbc4a986f1eda6dbe3a64b884fb5cc081cb238a8fae4cd4055fa00c1117d460d18f9c79bcec1096c138134d273012224c591c97dbc575000835a5c6f0214de6fb7a75b547f816a7a66ba3489cba998d67ce6daea57290cda09f5bb2145a92e9488416499df23666936391946f2306818845cf4a44e285fc642c54ba80a86e8e24a2324b7bf2e0e0e1778f73dcd29822a36a24fcc06902b6d6847b09ce430c7ac7d26ab0b5db083c51794581d883d3c09cb3dffde7edeb3d2d9a7eb78bd8eead51f3623e19ab3030135e5eeca9587a0d3a78615739f2882f3f3bbce9acde85f47f9d43e085fbbf7ad3d4971ed3eb60787d2e20e0acdf8cc240732f4fc7ef36b93f213e5e13beb140547321e762532307c0c44525021b162f0733adeee782d298928269dc72e6ae435eb19ffe2e8ecc41fa90dd05554a8c3b3feb434ccaea9653a96c3f508e6139046dc431dbb6299c0de0fb3ebe7945f49636fb51e2e8cb91d3d3980f2a5098e28d307489c933aea6df4e2a5ed3ae5fdb73842ba680273b005f56f87dfbccc6f35bb05124d2bfe833aad1252961ae7e1df951b29319c01617248429efb9e9711b94d83d1121b48530edadd3efc3123ca30388ac002cdab8a5b8e43801822e31f8b396efc1f2f216eb478941bbeb72a66efedd8668b11c8155a1089ecffa3691030204bfe386a694658ef8ebc2b5a800ce8ea89d0ec70ea95ca612544c95b8ebc877819d466561049d7e784488f76a9e545bfb72031eb8c3c07772dd4e288c5b92648a061ead75278529ceaad92762e41cd698ad8f0174630b63367bcddeda42d4a93e4c61e2537231147bcae7032fcf6ec6db8601195b3c9256ddd41e689477581f803ec2887640f8bcd686096ac00231bb88e6641c733d7497d97193020928b82c03adaf9208a80482612f462456c1aa7b58ebbdac4aac2e10fe24d4d03a32ccc033de4ca6b31232e62a9928822ab3486181d93b130ec92448ad77661cf3f812dfe446c1c60ab77f2cf6337cff0d2802c6fac9078f3d6626055d8511f72f219062c7dc3301e079b2af978f6f3f5d5080c7f87669eb3285bceb980318f9ee7d593d11f89301ec6ab55949d9c5f1fe9bbcf1707f7595e74850efe4a290e3ea80a38067a9c4d7a79db2a01dbe8d3298e7e8e5a70a2e1e0d4a7cce7d52bfba06265608742ec10d6d21e2db6c043abe59f98e2c1fff15ba66988355ed6f8031da77ec30693a3efb4c527894c01ec319451fa988cb2dae4200954f414b34f5068702c9452f2b6e8890d007f69bed71fa38f06554997018b57c3e84c308817c6d67cae427161a4417761f149f1e021050ade3dc0cd1aadd315f68a99a1af4472d71e8005c7a1954265f69a27698c743696333b4f07e570b019a854306eff044fc9729e503c3cf9e526ddf91e38958cd55ae709513cb7290f04c980c1bd67b8196c74fe1e6793e2f98f4b895a114942c0b2fe86e8ef5dc62f96a8a4159958013fce4b3ba51534906772ada933a11186619ffa3a3ee5d1ebcab1c9cecbd82624e07037e96b5b6ccf967c608cb3055dcd1ca682f7d1698a8c49961303833fe217be0e1c0bd5d0898d060abb707f77789b689b1cac54db8c59ce05c693709590027e1bed44981bdbde3fd83fc6af04c3241fc68362d4f59d8b02dab59e33c02e2a42f95c618aa374e70ac83a90782377f9e43f1086d9ca0ea3d9e74086166de94f2677aedba5333874d890ed342c922a48fa9fbccbe8f9ff85b86a5c5ace5f7ead5914b8cbb381822ef83fe6a4e3f4c33271c50c8c570ee0b7d7e1af100116719e0611a95162b6fd4c0021ba6ce53dc492278265dae905070510551d9af977bab06feaa94c0ab32189880b9ec728541ba7330c0c397bf9219de8a7c1e5c377407575cd6e4426fe9fbb7ab1d03ddee6a174b64159e918d39c3bd00d25909ae32874cc4b07e634219fa55e93cd10a4853ea6e59ff05bec52e010b73d092732173bc81dc51e23de490cbbefe2266b3ebe2f10d66628a25d10bd711bb7e6e58e1711ecb39a7969ae2c89a2e8e105eefd1d8ad3120e6c3b7a672388cadfeb698a9a006f9e87416afce5a8a8bd1e3862b994b31170b3f978f2898cb578e351169102d300c9360a8cb63904f6ce9519cd534dd24cd0fdc48d228c785006ce8a93e1c6f4dc830db378fe739912b1188c0186646a461859038d3b5c7b0ab567e5e0510236c2efd2c0b98a906993a0c658c3d655defd420f59248b5c9c15b32cce25e27eed50eba1ebf9597ba10526b3c8743fd2aa361e6aa0c39f6b4008e89306228876797cf30b0007c21790f388dcea52b7587361d245efd9a9cd5728af0edc6b32a674d784d2b55aa8972aafbdf24e4ca40da753e2f7fe54f320a5929ddf7a5ced7ab550a53678228bf274e243d7c72e521491d70f8e9ea3a8e3a5dc74e6ef644b6139c5a3f59745bceefd78dffd693a84d7b5ff0cb1c17dfee5188d5f3a8e5f51b5fd821709b54aeb0a5915a0ec38f6a58689aa2f72","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
