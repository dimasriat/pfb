<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66439f8586f6a17640f818ba9b1e9d954d5da1397846fe3f6b2d88991fad5c99bac667fb93839a46f44bf201eccc13a552abc3550800e7997e25b660abeb96fe4eeb21e2b618a7f90b79caca141eb3c4f70c478f6d99beb8cd1dbb9cca6f959248c9dbbd300c57cc309e96d71b9f2d6e5db89f332ad36c86b11ddc94b546be6948a85b2c538cf46642fe6526ff8337f0aea126371b839e3f3d55a855e78ef2cd9cad4e8fbcde765e26b9fa04c81d15dcea5f07174a50ae51e03ffe33c30f1f857fcaeecfebf7a48ee014757177c65162a1eeb0cae62c6c8b03155b1718c725f50007a7be0a1ff315151be83f513143b6495a6a18ee7adaf4c2e8c81024f84c2917f9eb917495ded8c11e580714b14b738e1c6092a6b44b1d81f4e28a853eab0ac74fdc10ab917df425d9d48d577647004264597ac4478c5727d27acb47e6facf6272de7885dadb6e6297c6af56553f0a160b99c93d2944e1093a489f2e31f837d6a6c4fc73762ba90adeff3c11484e6b852f106be0187e6dad8fb75a4b133ea0293b9a13d11261ada24a845b2cf010ea8d153bad9908b3e952f31bc2e465ee5ca3367bcc2afb60772926b6ab47fb59d31de3c51bbc0d29a24e110a01d7915c0ef7ebb4413c0755db9ce3d58cb493052e03c81d5cb08d3ca6355b26d5c73516a3ed66e1ad8911bbcc92f1fb92492fbb9acffc4bb6cd98197d8502c70b3e1b85f18e591ac04ff4b4e51d15f21bc7ff4b84f81834752774e8bb6436b31252479715a683361c7aa1164d57eebbb4fd3d558cb08c31dae8cb4bca5f0637b70558de7e3af056cfc92585e74e6205324c087d110aba2d84b0efac6ad9b6ffb080e496a78b690fc3431232a6ab2a052fc4092205eaa02807de4f2c2075bce467bd72bc061c6c180b7bb795cc77a76e8ebd54df5327cf4a623a49f645d6acc7b4048119cc4382876f501e6ba9723e57bc32c7fbccb1e8e4deb2b78ae294016764aecb653f493b4558347b13abca637e028912ff607e8363f746254f3a18c92e89c9304cdf0e06e44de78563b30b08872bc702db0e0a5422d7fba17319e096247b23a86fe1485ccb6b12ad0a9b1a48c6f60c1c25a9cfa33fcb33ea5b96164579d7e62312ea27d9df487c42731d245af4870706564e1a4c017a0bf335c2532b45645f4d4dfebd64b75391628818f3f26c854775ab831b638c0d1817cf4d2759817933ce06125c883a8908392378da455de6431c57a9eb8bc8fe34e09a774d6165555f727f39bc1c765df57309c916fdbd8f37916704d2085b6005e8515e6db47bb8e1545939ccbb18a4ec0c742132f01ab466c29990f1262550cb9506ccad6fab68413df2cf1a098808aeb5aa3c2bfa448e1cfe6166a8a84c11d82ccc56f1f8a2c242fbb941c5fa4f4b362d790a89a2991ec8b9686a083b87bf925c34cfa5eb2aef82da2e0353b9f0c79e2682e1f66b46331793d8aa094ae7764992073cc3fc7ba1aa4eb6641817245f6d06c8468ef37d6561f5cd6ab99896f8e7a0d9dd1d91557ff5cd9f2af4f3d234826a8f90ae9ae2ea2bc3df7d92b77036e584151efad626047e014f11397ab9d01e35eb3a276e5cce9f732bd8c1ab18865acb612b9afd04b949831f29ef4dfc42b124006df7e688e24328aab6487a060fd8eb320b4fc91579233a1689379785afc4b207f0148ffce141b4d2cacb98e9c7ff4a960e46197c96e2234d1112655b53a8b7ff09b16b567d4e790eab1c3ada1a8a69d7c01606fcde7f763fde8c80e50324708899e8088fc3e8b7fef7e478c839e9d25b8094f386ccc0b571a2112595c1503b26dbbaa532c061e5adf19c536da8c2f7dacd3af7aeb95631d2b8ab8677ffcd097db788c0c031fa289ce33a05793b8c31d39428d7b2db5c7e28aaf6a379e7f8b22bbf72725f76d496f74aeb22e1f527b7b1f55d2f0c6bc47413bc98f2ab982b6d2e568a462bdf012a6193df185bf2180dd8024cb32faf23dc169f02a96b6556a1f4a55ce6fd9d502525b345414246591234e4ddc0a7236892be81267efa87e7cb5b380ebd621832d1afd59e8b4d195682e2774f921e424e7009af6e67c8e20ad35bb2cb65f007aaa1aaf85d4c06f6e7e75b0266da408826e5d1aba9b295f89cecbbac678bc76c2d668f72d89639b7dcb5a9c72fc794998536dc4c5531d8aa4532884a97763623c84468525b2f0800ccb398924b60d8369154cf1ffb06094ace501fb17e236e266e1c420bfc8dcfc22b75d37b927728452756d475e628a5e6ccfe6cb1a7b7bbfe84cba21550d45147a12fc0b7c9745888385aaaa01dff73e5f31c8ba88b4ace9a1520bdf367f1a76950ea0e1f9426b97de10919eb7a89e3b3a41d5f88ee57c4d96fa4ba139f0b60798c6536f29dc86f2ff97329c0ab8ac435806601cc3f77905cc8f2af4d9adb6f7a7fae572c177ca31d0f9943bb50e4bfac5a964a521990b4269912c8fd2e5efe38bbbc54f321fc96d03c1134f818fd0d9613c4bd2e6b785e2e626beaba977e8fc02aeef77ae9c7374775458d38bd60a7ff5faf653f553b393cd967af8f12d19532d3e1fc7fa4c02ee63aa9a75313b50a5d2e961122f50c78dd2494c02ced1390b6ada57400482e6ea644e9611b33e8ba5f1f5bda4042756e8b27c64d0949b5585eef32bdda3e3c11c71fdb4e6310107255409e6d45bc2c47762ea0ca7ed72fc8401e236137a1a5702074b678c1ca29bf1103c011d27f19f91e669a4b2958c54852fe00d6be4c614e8ae6c0feeec45f7779d5b1bd1a9fa0dfc8b0444e8c54b3265f50c88e4bc15e64c6790c6beb248490649b6dd8f3a07540c34671c2f4122e32b455a9bac7b0ec75c27d8f57c3b38a345150776421137d80acaa58e13121b2f40a802942ab4a3d1223e19370ad91b51f7998b20e6c2556c277a459bc55512b17b9ca30e2fca2218f4fa547fcd82f4f35b551e7671ce3737fcb9ea6dda3a557f79bdd57d3c28484f92ab534613841eebcbe8e5e9170d16903eb5ec613e3bbb89ff220bed655261a08eafc393ea18b025c36beed0cc5cbb4c44f8944cddb62bcb7103d5f37618a09a64946fd124623336210884df551686505853b368ca3f342da0c1f12594d317e692e289bc694e7e1d764a6c1ba60b503add0ad87f6bfa0869e99b574cd03d2d895d7d5b3878d835a5ddae8821037748a2a8a1d199b5bc508cff4c156480a424407a5aac182ce2c3410261b530882d7f052fc19e67b4c9e0d62ddf8720e7c5155ef2431a188ffba02126a5d62a88c334a5b3be58aeaded0481eb5c0019d3ada865de7289f53ae634c3c9b90bf0fa8c67cfb99a0949840e41302d9fdeb26616880a2c0ad7fa86f62975ad4f6ddf0ac93d0b3a497b06ba41fd56d735210f15e0b9e26f171a92a8a3feb8d5410b3a40c9f1feb3e7c1209ef906621b68492b0be8f4580aaafd97ccb7b4b8909ecb3f49e3226ee5e7c7e2d3b4c31b68a0a5d18d15d53e44babcf1c770d1f50fbffc5d70aed701c74afe094e0b1f73b2442dd425231191c172041f58b80bd42e36a0b73ef670ce7da96c7f9f54a260354956b34c255eeaa9349b71b12d45aab9cd1f258a9ded6412cf03f79a1da7169775d1e78a785d94eda3bdc6d7c421505da3c63d80d1758cd011014fcf26d1ec4001ab93a5a682f39d7fa4ef42c597f0e20256e79c182a7da4bb4cff57d2126b658b5c87072645029bb416a4a08f3c491b81940713060c7e8731c9bce08852f437ba705b536f80f325d918b96302fd7cd9f562551743156d02b33e826a3acc708f2ff00b45517d76e220a5b25daff7341bc529f8055959e175b26b9bed5091edb2fc4bfd79e6fb11e5718eea880bffe05654a49e08d5ba58f20519728b2efe3f3f8bc9dd6a54849a115856844b1aed4714c6f0f123031d5f4d8098535857e4598bab2b1608fa466ad9978fa2a246ffebf5f6893c58e8f286f6dcae0192bbdf3375c5544ab732f054cadad2ec4b9bd9811228c2f611f29414bc85169b44b0965d31a1755c838673a658df5df84424970b0ebe8de02acca2cae02bbea68635a8915d3f6758acf01e8f9ce2ca567380d77db76a3c182834cb29bc55a28345c723349e5694a47e3863dd8d243f97f331bef5a49b08772a6478cea0fcff83109651f8b216a75a35af7f7d13f05893720ea0d3de0059859d186b0003648fa2ecac639c409a6d3805cd392b35a1febdf497c586e5571e7cc363e4c5a3d2525852843cae4d5217a5544928b22713ff6c6d8b58d3f841af53d975481c6a1ad3af84586990d004c1dd0c61ec7538c701e562cdb8599ad37671a5ca9ef13eb30af07f361e01c0805f59cf46650b5e17bddc33e7d5b6a67d0516e357a831a9c6f3671c5640036af5c7d1b3f1940bc16ed20778aca3bb5355d4094392c8e032359395a4d8d4574a6cb0cd1c3b5333c2e64b86d5cd530e7eccca3b41bf9084a21ed90dbb548505e51ffee97831f9290eaa9e845cc80b60206906674c4e989170a434ef426afb440f19403cfce940d5cc8fb451f78987e28743dce1a3bbb12daada925e7e61b8ac1bdb15bb5126dd83c65348a856f75ef08a28bd31be4ba174836784a621bff915b32e7d7ba8d7f58999c7c4548a1163cc6f43b8ca67850f1f77066c282673eda5d3218df3b790742f560345fa8c04bbcdb3a494f510475a491642b3647736bacf53ac062595384a6538588b36d8dc0ca251d615860b6e3b4cea93015e230a34714c281f3d7b145be78f7f3f8e3d5dbefebfb7172b58499dd1133c8768322b83837b63d1c20a9d7e01869b7aca197b3535758e027d30706437d474da71a1b06c7ed967f46bb962f682845c99840dc89c18e823070c5a6cd27158a549ae850b086f99cdb1aeb5805afb69a3f77a3b24ccf104c27f17f4b9d11387aa889465dc8af85dd9fe9f7bfb933898f83aea74a91166a54647a4fc0c6b4066ffeedac08c05d3a86280759df144574678ca1ce4e4d42ef4a20562e55faf7cd7535e5f2a18cb6cf98bd8959bd696df561c325722021a7e2629394915918ab6ac43adbfcc3dca0808aad32e8f0be2acc1eb01fbea1b9b37cccc9b751590fd4dabb7f2f22ef8046d121e1925f7f5a3811d5877fe946dcb7253e0b06c7489bcca43a7ace208f7cdb5e0cfb804e3c0af3a3aef7e5289a90695c16f2d2b5ecbfa9999a48ab2a7847f8f055b933b052631fdfe420a1ce5887b6561826ab283b3d694c2cd9823728f1c5a9b0cc41453a84c002b38c1fb9b7229bc2b365f2b58cce839262b529adeb335f30967e45354df3e5c6356b32e4109cff75766bbbb2344807e8942d0c6c9ee3bf9772a821777be62cc29f1e84d9f9f0cb37d45de39d48404be437f77eb35208c9e1343d61415f2e7f81d63a6411c4806cd0973ad12e260c43e0d568b555366400daa7b2ecfd01d738697e711fe9d311ee30e75e35928621547f46eb7769d61d9a3c5b3f3740a307567536ed949d87a3ebb3180b6444cbff26c0a794ef0c27285c9ab884d7bee9d351568c5d1c0b2d841b5f20e2305431f3f1c8324d77130c62b5559960c5d3af83fdce8cd9b258d919f818a7b779d4916f25d0608d2376f7e53c0a357bfe32a668e591bfa5982f5616d31f58021db488a428796c848a871abc9d6e685c05194715576250987f480d33eba6508ef44881a6af833de83bfff7654457e76b7aea01a13aace94a44acf37236a551056fc107bd3a9d97f8f37818d8c45b9e9fe6c2eb490c4167b6a2220eaeb60c7fbc8cb58880c83d28e8a323aee3b116410ac434961d4f2fd0e2d9deb0ea907f0db597e2fec16d535079e7ad110f64de681e87c37f5955fa15710453396d8b07b72e4b02ead22ea94fc686199b15611926a18339dc4886196ac4545f52784fb100c91b4870f025141cc9460ae37a0cf7e7faedf38734eafde07190b744c948732736a6f00c5904baa42c8264238f1f63b3495ea9e97d1bb2d8a7cf84a49d2054b0dbab1ba5b74be2cd96d588afd0d49465afcebf2f59c769c73484e85aad32a051bca2bfb30d0124554d16a80f99e9c12714a04a6e98530afedbbae36b3acaa3fe8bf939e3a1142a69f726d480208e073bb32370f3e753c5e91b255dec617e84ea7e74786e717e0ec22cadc803ecb0037087949a890a934f8780d85e93a9734c4ebf63d60b2900e1ca963262edc8f6c8d1859dd42f5c4137d05861dacd56b420e9233920f95ee395d546a02ab0c991ce2bc1fe25741e5e4c860566e7cf1fac12c46da9521e527ec1fcbfedb1442fbe08e173918c6554267150249005d258197da24f58756aa3b9d30df83198b0990058c281e0ca32f419db84a85b3f1883ce10e61a2e39c2909f3f7889a086c73bad5b0fd191c4b78ed22b83c35d5b7faba82c16b212153bfa3ee8bad4e58e3a6b84aa79a27aebdf3c3f265d9336e6d442c908fd46a3025a4f7d499df9647281123d6e01f1f83d97f162b5d535310eb4402e35021b3ef708070f3935f38a93ab6ffd79bf93db8f5a6c9e92f2dbdba13a534ccef1320459aa31908c448cebe515c04532c284c7800d7e5903891c4d071ef070cd936296735a1408864e9c4423f43e568757aa18121c3061cdf1b69868c5d3a933b0dc3adfb733da4640c70581628658b54527447f80931ec310006629306271a2d5534167090cbc47cd414123c8d4c64d2e294e7992527062429f533cf3ffb4cf40572111b9bb4a7f205f2256afe78fb10c4bedcff0bcd42177e1de7963d83aee7ab648ef96187dc9e69c37e62dc345b5c95caf0e53e2acb0331248d08572bb28fb02f8da230363b2ed3316d4d3cfc45fe02cb847094bc711542c50016f008d30b2d931dc1331044d2e2d22da2cdca81825d16fa474f02d924d51672dcc53857417495e18f9f264082b0e5e13a19c1299928b020c54b84c2242499e9ec3d810c1d5fe3bcdf25d07ec6bc52161e6e1804c04238d10ea5a0ed1dd69ce1a1adb59d74dd9231b04ad7d74d999da2363da18875ba536f85b7c5202185989db0a6045e44338c36f97e87b61b94b65af854170cd3e4d0996259a66af3679dd82fe97363ddf965dda4a58a60ae4a7391a2f823c45081c1ba208369290e52d68b15c04ea6d28b77b402472f898f77828f17b84992ba0967605abc7f2a327abcd57c88ebe465f27bec4f795fb5ee080cb221e06874093369840e3c1b332d514b6480f6c6c24e56a01928e3b74fee540c1b4cfba4dcbf6b1346b5ad40ded576a20a12f158f7c4aa517b2bd3198a0c2d22be59d4df3d0a0d97929031319ea56395fec25cb41d142bc96c633f35dd77e42afa430b1f88712fc732f180ddee99bf6d1a5fc06efc75a66cb20c3786ca11e9d98c03930d2e577b5e34a152655a9eb9e009440ba149518275e36b1e7e65098b7dca1b3caa2c3ae9bf2727e5a4b207183bf87c0b3b3ad4effb5863a61502511dfec7f7d14150b84a9d4974ec4c4a4b1fd6d210f4897031d0d5228e7b64814f61decb7e2d0ad72311c63db9fab93676407d73d8750012588ec41ee45c2eee88394494b5e35e6f925ead38f323d5c09595115405817a9366a3499aabc4dd26421eff48edb35aed2389950841f0487006858258b03290487ac23641ee6bd1501941b4de2eacf9069c3442c9038e5d2f5a9d487e2b13532400bf4390286c527477e7ff59208adf3716911f8a03567f4cedc784e04ba1b833760e47697757ed646f884888fcd085a10ac58b4cc080d6d08131405ce97e199bef912efd901995fb40068ff17bdd47ced66e0b91b75cf10bc5d37291773d1189ebfb02173a236e78f2830ba85650815998903d83c1cf53fa0172fe85a23ec945ec78791086dd16476e08fb30d645c28542f05a0de7c58484a53e3dc3e73095d28794060c1af249e151596943568b75de9286ee64e4881cde9bc003d5a62711bc8ded47fffa92bdaef421eccd714026679220eab1f40ff19cf36ada27b6f3ff45b32d354832741919f6ef8f4ce2299b17caddd3cdc234d4a3c0a296c4c745b06ca3bc9abce9ba80708effe5172c3b06bc945f44a82c74be6e1a3417fe29895c166cae447d1020b1c728acfb6efa94ec794bbbb2830849bc800f2d563239c215c3df97d9182df44aac304d52dfa83373ea4ea5029c7b8fce97115b7322a7801d4ccd0e3f43e11385d4cb4534954c7ecb8e5c068ff38d39a6a1e176c846fea4d57468230eb645351e396a5aa20a27a34b15ec9f2eddf276e4db409b978db208d63ee29d9a7dc61b29adefeafcfe64d11abc46179945ef0dcb1340d054bff0602f551c837fbe29f0f1d14ed48be69da85acbba251613c0713a0910e5dbd432da373015fe947595b04249f87d46162b5a5e3fba73114090870c50917e5109377cc1d30d83e14bcb16a9afee4b1c7bed2be12342241bd1dfa584c8709c44d77606223c40703fdb7fb4f69d9824e5215f317313f773ca2c2e64a52b748bdf2980bc1a43e764d592099cd23ad57542284fa4bb9bc67ac4809b32504f90314d11a1d613dd60e57ca7a56b92a7bbed3a587cf510446b5d0fd5842a386411f88bbd3fde36556fc2084238661d2d8c2a11666e403397ca130f38b3de2ac885536e38c75ccc0a04b6e8ef995305505cfb425e2ec728c9cdf7072776fd805b77c7addb19f5da10754a67d1a888474d161c80c2189ba322464a675788aa8f79d637adea0af76c95d6953aa4f36725c21b5d82222dc05aff166920023ad638f16cb65b316731c1ef139d1c388ed23d9f7de00190145b47ddfb132dd68a10639f676dd80e3836ac27dddca9b5ac75405d028ca3271d3ba4e6459e5ad849876777942da1911a957d60fa13d4f076ab8d8b307965d25f4d38a8059ae91d57aca101835fe941e57f09f606e1819e421825440510fee5fff81cc591d8e98ccbee79904e3b104aeafc101f51a1d1449528388c05ac0a7a42b332fbaf6bd7607b7b561f8d7360d9055966a32f81dd19811dedac02b1c46ff1fe6bf7fef73b00276577312b67cf8ef7f28778eb70cbf64c96e7fb65a043f1474e26abffebb14d7e1f296ba409ae6f9c2e62732c7fd573242ae80aca1e85608a8e50242ef03490d080b581453d62292118db8c824fa6eea50f9129cc23b7bbf7eea6b66bab396da5830366a9cf271febcfb831fbbbe445fbda1d86eab0c2434fe55f11d77aee069172174a83fd78324daafc4b44636cd8c1fec6137cd8cc44c6b21e9f0f5c4b9b2574e867c87c45d7ea9a031437407f8fd42837505453030e584c08c12c6637b5c518df66705ab0e80e1aca98c0289056bad57ca6d186003a2457f82f0a43ef328cd61db4368e1ca5b7035fd61cb34629e4ad1f1cdf0f4bf6c48f1924c03d6e39a3e1e2edd6623a3f668cb80b14761f6e474947cf9bbedb58bbbeb3153df50b5a71d8e995988f28e36bd3a11bb50284309da47657552d2d684bf17261f171877102970b1e40e196eebe74ff6f13c897b52f8c6713cc30622cc49a0fc1633e00e2a516051ffae0a23a1daab0a0764ceb3acf0df7365b77c4b05b3a6283c636f4087e4669d7e7fdb9c3e25d9a3c665ac48500839b9cba4a269a801a9978cd48c0aafc5ace6fb030b7550b12abb27054c89c122cd9249610e33f0c863ad2592ef1f61c45b3952360e0be5b30724ef480d6e1e8742df03d5db73ab7fb522de1f88dd5b6b51fc5567c4814f9817fbf54878e73aabe1038a1435299fa300ee68849634f872978c6a8c0db76ac410e3924385b6df2a87dcb97164c3611139eb9a9c6a6a08775c98d17607076d4b5842c427e54fd02827c20cc3bf40d66b1fe05ac1678f0376d8327e01e4888341bb6f608ecff52f5b29c06ac2e26cefb2bf3b3b5a2deea1ce45d49ba93e287ac39e07cf3402efbe2c5032fe0df3732c1d33ab77285a26a058ea848ca303b66e25a92271e2649f7bd3c3df0a3e1cf2c8811e0c006acfd6bdd317fe4f809e07e4036925788cfc19e985dd7de75a5348638e5b1f248a09196bbfd893b87e35c1c8aad331b9295038ca208fcfc888ecfedc11ed693d8554eee1ef8e5f17948f16794b65782c46927cf9235a65494823afc92f927f62f521715d1b83c719d2a944330da41ec7aee8ceeb73ea5c0a2315d40603542fd028d2fe48e990982dcc3f9cf18bbc4c184e15b8f3940f8879aaec691b47b05b27bb7f9c6f43036e5d12e168592f69191a40a53d142ecd4ecf4db027259ebc12c9efb1e7bfeb0dec1fe24359e2ba43b94e5de7148b9601181607ac118938c30374184c17bdfbcc55d9bf4eb78f0fc026de64e9851b7eead15a6efe0471c7b293adb7a07276969e40b579e134987efd0466472619c9639cbda138d1f295dad31c9b2eb974ef49c1144ec8959b9c27befddac8ce370e606fd66647b07f503799da1dfa1fb8ecf467d8d7197d99bab8c0eac1fefb8df59dac8444d8701abf2c0ef7186e117fdeb04ba5084a22f72cebd1fd5fac24c813b3a0b6c15251f349ee91b9e4c11d0185e856a7b4b16a5b1da0857acc2ba52346ab081fda8d74bc67d36460c27466331cebf65d4549065fcf0e3b0e7f7728af51dad07fe707a207d771ee2a5c5aacf3fa1c3813ab7ab262594288bbd7fe8bd63a2e039c50ba8f4d39dfa4a86ef93d00d38e95410d03d287f73fc1d6888c83fef3719bf353e5977a2bab61b5a28dee3f2d4a4b2b7ad3b2b6a5b9d9394f2ac5ce78bc0035fde915bb01573045cd592067b0630375ca8e497694748af0c66a2ebe2284127bf16604923923222f8406daffddb054bd2d50280aa9b0522f3a04bee06c54ca20b3d1366d8d7402cd7e5844bd18cf34128ace7da5d972b0a649e3e9b90d3234f0e32c6d61afa5e6e3266da11e162b26974acd2af0c98523b5204dfcf8f7b9cf67624980ffa0533053f6235702a3796e4931b84fc8ff5e6f816857ba765219e17c9f9aee4a561ff23e5d8b4f290c52e7c1c842c6f0bdcbce5255218122ca9b61dcb570387e491c2372b605eaff3a2e53294bd7d3dd8a0e6ba4545140e6ea9a65f7f6775c684f51783184aa00027003c49c6eb1116a4d4cdd1e8c78db6ae016c304e2e023d1c40f765b96ae6ab6687839d05c1f7ff24636d8f192598ee1b74b50019144495c7e91822e7a8428e5de8c2d5747f694d2028ec44f959f1bb4531ccd6e32fcc02abc2b1ea0b2a4bc38f42ba45d016adbad4428d83ab03df85a59584516a47439ab58ca80d46a5561a37e6249c06392e2caa9f50a64187224b3bb15e8b07845313f672d7503e76caa05febb4976059487112c78d4839acf5e69d21a26fa7259ae060349b8b2e9504a2104d707e620fbc44331d949917cf4544160bad9d1da1ec793ebeb0468dcd26ae32bb971709de199fabcf9d943f8ef084200b92c2a9a2466d395bdf6fbad0335cfd5a87a60b8c2556855900c4dcc8eb6609e5db295487c9800d33256a7fe02946b52661ce0ba00453d874a93176bd91ba5db5fa971c1d9a76ce4c0b40900f97b8fb241d8717fb5f502127901070ceb4a71cb03041b9bec188cc7ed53f4ca305a7687f1077ce84b5e200d1613f856074cf4fb6418a4f0816fe6a98b62d62224013a0ac4719449d8117b77661cf9bbd8764d462fbddbccefa81ce78199dea1ce7d1b3d2d397aa2237d063d1725993474815cf100659daeb42c01ddf4745997d37a229aa4b8e1aa9366893f857431ea768bf188a6e3a4c74960e93eebe7cd7b39baca51e036d780d4ac1cf72b5b3ddc971358dae81c3d340daba086f09cfafc5ae607448c1963a868d344638f7598e03a5a405d8543aaae1726e4ad4fa19e5a225c1edb7beb7300b7abfb0d556f97233921827b6be9d702bf798e8d61f4194f67917468e4e9850eb31902688ef8bdb9f75023bc83c07d0de0503cc5304d80f88b0acb77c73e2ad48567f5d4dbaac5be2d3f4eac4135bdd70c078b82c683ca794e8762e43159cfcd3d5b4ad4b7813a1ab5d5248484c0641ee4206a1205d7831ef73b6d7092fae8fa676d12e1d4abc877266ef805b21cc4f9388031d97cde3ee54ad45c76ac872ce4076b54d2c08c73a2eec3aba702bdfb30805ed2b7c6b5546f689db6b645885f6bbde1a9720568f7249debadefe93b30e21c72c52b3486a2f1cf0b14e8ba4f11e56c686f5a9e20712fdc8f2f505b28d6a7d7b7d6e4071658ff60712f85b5b0025727cc413a0119a4da53226da6615c33bdc1b1edeaffda9451da7e87800211d05f816ba85b35fff390c20de31d3f02cd44d26a368901b6184813ba264b1ecb8ab3a2f2ad327deae5ee84796b465790792734e5bc12b0324f2ad4e5100fcaf3134a4d1d3128ed8c0e56c62747384f2d81df9106e6aa501cdeab3bce21056c63d36208fb9bbc874f7a73e56f1d2be9778b3bbbed656e408a4bca1e554f8c6d0902ce26a228bc502e0615410551281cd344403f767b6482d1b58b77da3d8f054f30d400d035ea997359c446b63ddd76b3017dd2188465f7b767cb6e4cdf41e117a0c498cbf195b08c4db00b85a0e1a40e2c6ee91971a35076e4b123936ef9b99ed503b15799c5efd03b4e26442dcacb6643a786efa66f904462cdc4705683730d5671cf572a96cba862dbe13fab020bba05c6edb6a6748812375ee36f50bb74ef5cc6fffb97438dacbc9e4ef35283310e59423442bf92b010ea1126de9cc8e30c6c29b0cce26a5778f338cbb5a8a209f4d610b0788270f634a1a0131577a2b1b63ef84f0130d4485b0db18700fcb68a55d1ec38c6d74e94607fac3b5419fa1199d47802e82aa23e3be34e8b6ef440168071781018b68cc1288103cd0fbb53efd12ca936e3e0d764f399c83329d82178a4d0b1b30436e5aa3bfd85eefb3c0adc9ad4e1f13ddb4ca4eb411eba70013d5f11a5220d7b0d22a7b48a51b55d6cca392245f7c951fb4f7785bd469501c965b1c56affd084ce7ea5352e91b292e19460253f51e9c4229e72f4f223712d44dd29afd70473a618230ead1eb8f7cba1e813c0e019876f6d4a6309f98d5b95503f496b613842c2b74fc5ed19ba14c6544fc82040ba191bad14c8e7213142d606aaea9c3600f1013450a7e46eb3b8731ae159b017488c8b8533290954f46f89191c560d36dcf3276bbf3774297139d78e3e239f5c46e2a1c16fc5da19c2a6f48254d13b3cb78dba3076c2b5bdffb978182338eb19fe5cf2eaa8fb98858da62f6d304618c6f09d7cffa99ad0025c6c76d219936872cce458df5d255877b05d4fdff816f84cf2884ec606583b91841f8ded198bc6f32f4b349b4e4d3dc62fa5b2193380ba3d4266f061706feddf67fb96ad598a202560986837cf1bd7782635456c1baec14d87fed1dd8adb62cad8cd5da5e90edf7d1100ce52c17a369f7c4760d6e48e4048dba12ad789b335bed02b6406e3ac3f025bfa4a8756203b58469139d459f801dfbb7e9bed3e2d660465d73cba938f93c805d3911f60334901fa7c31b799868724e77b77b9f063761109785cc1fd7ba6cf10b5de2ce0ffdc7e6a63f0add106c068e8597042f4176bf4ad6b30f116c6bd1590280d43dde28efac7125b35ebd9b8b40aeb9b5b365cb8640af5339efd721b30ce5077495f16dd175d8dc9ef903f563a4ed3ec003e1161c2b059cce9fe51cbdb2bb695e99041f79add688d4ce103b183b385b904ac98adc9d1bdd2f109e960ead589f5a99aede79283de5437753713379cb9126fb4d2922cbb18a0060e46dbe7adbe7c6695e162df00990d7362fcdff972b00f04e7f6ca5e08cc26291c32b45231d64fcba16a84fb3aab0f4d3bffd8ed77682cce080f12c1852b6086e986dd88c53777accada96f17942747a98215ec261688b246e17f47d5e7f93964e1af104e057fcdc526aaff29616495910d8ef5065ae3c3c0b3dd1786499cc7c5df6e05fd79374113daa3f33c2d918706128c1808ec1b3badea7dfbf549e827cc0d1fcbacf1edc66a6d99673607a04493b78ad50891e18b55fe56c088939a680b5d3a4475a2d078461980940fd42b29d570c152d2edbfdcdb591f69083fdb64748cd2e1cac2180cd1c6f9370c1b76077c0a28e3c7b8ec2b27c0eea9eb0ac5310a737fece2e94a9e25e3d7ef5bca479ca6c6976ed0ba8cbd330e119e984ad98ddc89e2975afe34e628046c3be1911213c72288a181ae628c5cae2a3a5a1658b1328640d101e7d6837818549e92f2437c33e9caed3cba0954fc77089ed09deb058361b551316d24dc61b11f51aec81c09ab971e8bae0312becad2d6d07937102a10dfcb2e5723cf12bfa2cce3c4a79f1434560482d47a2694e1fe0e8f8027bfeb0bf2f7dd400401ccdceebd7d5052a125d2feea08379438460c64cc15730e0a504711059123405d992c24e4846ebdf4a19a807eff2f118b99ae32a8a7c4c17edfe53aea0c4ddbd3d1035355893924d094dae38cd6f44f9942b92827b026817ceedf40a1dbdb04c821b9b72f5c5c6eaec0d61246e8974d105fb03c738e9823c675febad97da0e9d4a32a2e60217c6d62292f47eda03ce3ae63f94ec6acdb4c20ec363a4f9712f907d61e8fb5c12f6ac99eca8c002bffe209d6cbca05612664767c5afa8972b864a45d553cd62efc3012ccf5e1cf791cf84ede032849c3f55c60db1a10bb3b67fe42c5e08662a70898fc3367628c0ddbf5726e3f09ac47acc0db77455f008d58ca11e6dbe23af21b22e6ee39879d179ef00be3d9ac84a8e82e33ae339bcecc522bd42fe4cd4803a2fe49e400cbd186947737be039da78596eda99969c23f339bc68cf2837eaa26a022017c7d0a8de03b63bc81ba3ac56b46e2483dbc3fcde684f6b03d0ea43fc86a1cdbc2a9dd2a2b3b80bb513a6d127794a2fb4c5456c493471f5989bf4a3e29824d66ab22942707e78a490c7628293b33ea799e77ef337ea9611e20456e9845009309b78fdba3a19b8abb0da825a7a9ce54f180c987209bfacd7a172d8239995863564f213d92d710676ec83b0beb99c6798a1c847de7ee4adcc6cf6d1382b90dbf2ab6777e58c964073bd5acda7882461ec095937e5cb05c9377a561e47f753b5d83cf12a69933fd8f306ab54755d9e364561a496450d985b3908d633714e84162e580a6b0dd34466f915ca87adee715e624517eba47d5ae44ae523d44c31da0e2c3222a784096065ed2a3f6d1bcd90c069b93044ff40ef642a619a0b9eb027efcc84aeb278c0fbc52f4ddb2c23088a30fce44c2f96a278921535c2e5e55c419da7739ce1493eead8703161b857d9ef58d4aa166633cc5b475374957447734ab240365be3e6f596637b47c21caf8a079aede0031940cb5d4f9102b5db69ae207e9ae4a536920fcf9ebb7b511eb2735920e47da44e515eb799556eb0ac1b4d1ded7716c1dd5520a982b3758f0c9344cd15b91e57d6886480b3e3ddb2c6acf65f4338a68e7beb22d130b15493b977d3987b0676edde0bfc09c72834b885ba72ada4b374744c2ff446006fae932a3fd7592ebe846da57c6aea89b5f4521cf6c82376cfa5e56fbc762c64861590317ab28588e4710117dcfcac7af0e463a9e1c0da0a271645aa30d75440458ee6f43bb70a23f2d10d312f4dd69ec3a4ecbfb62c87f990e8920a6ca6ae1c5dccf806d37d0bb2f05846e74616263a3645f6e38e50c69dfd66f8c54c8d536db573972db1b361a289fa79a31a17a4c2293a983c9bdeac6989114122f4b733ec8ea886a465ad9c9653d36812feb2d547fbeb2aa283cfc4a46f2fa0397043b5790d7422784f9b05c80bb2a32a05be10879b03f406c6b9872d815c2c43e2e91c8195e529105205883fc825933a03a56b27d8075d0a228970969be17726f7a2350c1308d7832c463ffa943f0eba8c37eb11909bf378898663f9ae8f9e64c045e4e379d71635dd97f4cba02a3986d6ab3631d3b08c5f8c499e8b4bb4b125d4508a014beca905e20dac7c7d94c47614d79b0c28ce5e537bb55f1e1085b1100cd4deb07e85458e2ac14d70a5b6ab266ca8ef352e7e13895ad5e9fbaf90f05e33e8c40f87955aacfa47d314c128e7bc9862b5416d9819be6b73f365de254095cf78eaae5241590473058ba0c5350c21a4e88d1d435dcbc415b192f7f90e2f294009bf0e9ea7480139ad1b42cb7bdd18487399a2cb35eb32e8385d1b483626e5fa6951c7c6dfafa0eeff41b4854a4d0b2859483d1e1658b49ea435504d5dce110f7cd6b26116f4d99b0e3a94b8ef78a0af6f490d4e5d2383a3c541672efba1e2b11baee47115218ea0e9882a12219af3d6da8789d4a91b87e09a0d4f56b319a2686306914ecc8a5b96b6e07b34516b8b35def105ab6291ae3b49d71648a7927d27d74477645ffcf4d39e19d25030e77c9bfd27492d46be91065c08634fc3f83370764109704f8aa265af988ca4342150e255fb4045d867995b25bd4b3f819b1e4a1f773d81e176df74ac1d4bd7be3f1e28f7ec214fa93d884e41130307adce57d8d45bd9e3279fba70517c08fd65938a6da7ee2bd770d4a121c137071bfd4c9a6c79a84f4fc195341759cbd5c1d93fde231b2793e184c3a5972afa99703dafd1b31c0c4b96a01ad55dce99962a412c4d811a747c568e3c19c22e8cf977e2cd9a59b8f5031c4475f85b99d6bcb47cbd5f67ad0acd8d66a4f88a4a54cc3c05e42a20f4c64a41b9d130fbbe78c22d191bc0c92048f34de4cc43ed17630a4965dca4a70f637fcc5468935b5921932a3316c3c6ab066012b45ec264804d5e8968a94c9ce686161e18c7810e82cf7973346e62f5819b9342e33614f6e396f71a7f8204b8033845c99b3b0edbc821f71c4b58a19334adae8bae82dc0ed4ca22ab7e7ceac8a52728745f7c6416594f0c0cb5fcab8803e48c075de71ff89bb6cbda44ee533917b85e6fbfd31723595344e570c7358797ff735d0aed0ec479be2d6f2a15962713b8a013f420d297c8fa1bc6014283abee67c764ec168260ff78f27a9e1df6fbfbdb624f37020fc50007302b0fd03396af338103028d9cc752b5021b527b76f195ab5043ab798247","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
