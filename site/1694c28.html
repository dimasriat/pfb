<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e90ce12df153f4868dec96fa4360c9b0e50e857ae482dce36ce3ffa89553b6832e99b4d8772286d6e94b85793cc221b83f84461769bf6a4fdda9a5b3d0d108e3b43d41f98a1b8a90dff53a386a788a9c661399aec13d5ace5ed815a29871295c8dc0fbcf7bf612f17dabac3d2df233087d08db3cb7686141e7cc0676fcc1846138468ca22d6b1d65797113ddaeaf393a6a3136a3acc82a5bc6b71021998fe9a012447213ab8ed67872efe6646a44830525ab19a0425810e38626585f941183f0c9db21acc959a0e51367c0ffb3686168d0d54580e79309f430d260aba2ef9ab813477c57d89bafc8b3bcc3a31325150bc6e7ab5d5feae117578abfc9dda490278f7fa64873efc47bf95101043535cfbbcaa6c12cb871b6dc920f6a7030f8cce3a9bb30a8638bf89ec601bb9f591f22b2340892abc61fd889623c6074240fa65b62f27d076962ada83e229064009cdf273877887456dd659f45dded0ec8c23b8bc9c30599b8abaa060e1a435afc44fc1600254761c956a5c5910c7c11719bc26a85be6475d3972fb5d97b7d5c3c92f543637d3c58b5951759efe9c5e41a3c60bddd00eafe8cadedf5f8d10ae7dc7ee4618abb676dd21640c747c2b6e0417078a8f0c601b94e582e7c12464823ddb84c6f0b822884b14ef90e5614dfd1b618d81e26c09fb59503bc12d61a75f01999735bf9e241daa67178a2021b1a637f89b749c56b8af33cc861544d949192ac47f55d9287b6d7ecccd77acf85ed371f2b8267aa5d45e0df69a6b182907d493d0229d4d4839a88d0446a57f0e1e7fa04a95cd21029c2a70ebbe2f4fd9a2bf764544009debc6bf3e8e2111062a5b39de3435e82856a40846496234c7794d5f70dbc1ef9979ac30c33c58821ce251e772b555b9a8b843a18fc0f500eb8ae52413f49337d0d1609589bae4a63e73992836042f89f6977bb562db847aac00e3f68ca3dd4838b24c723ca6f0d61bcc5b5c8fee7153dfe01209251a7d07481e7e131f9a11f32cb073b197f57908323c6dacf35017fa53e703570cbaf99e7e4c89c7820e72899fbb867d3406f6a5d79fe48caf447c2bbc3d97d0d88bd2d17b2e4cc2b8e523c573586784c4996bcf8d91639e1ddaf9b179f03b2bb35cce048fbd265f95e98783362fe7b6409d6fba655083ffba75e01e9af519760029b14638e2ba9cc4f08d760e0c61bdf6195a2dd4b36b3c24117f8040e1c7c7a8a1b5b9e194aa3e8c91810b30e6bf07cdfc3ef126ec1de07bc923fdd437c46ed1952f23536ae92c29dbc651e7b22fe02d85e3d445fd8a1b9a9a35631173975c1a5734f1165df77ad3cd575586d20223b81b9d5455ee0ed30a4196121116dfc0cf03731a9fac43c7591154d43d4be2997c4408386bed600a46593681a6606eafad4c3178369e938bf2c600a3087c262c0e630147d3c26989eda4fba15de2f1e7e67ad6e6facc87d787289a6b274805e3db116f6aab8e0421af4e962e159108f5788be1def4c02bf1df9c6d4d8c6ec1eac4abfa7cd2f7f3d60acf55e4ce464e243ea7695c6aa21fa7f6c67f6c2fe6e68d45c326f1a65a116b57f7c29f58882add2047db67610166d8159c904f7c2e2a0a263b046f8208e7bcfb888741615cfe8d6c1f1a6af18c5e95a62363098fb1398462ed299be11c3e83eb14f4fa8742e99409b223367754a2f2e8443efc9c4d44dd4a8c077523a4ff3d43d192ee6b6ad0fa877971e2243fa300e0309fe24bd931cc3c635c4058a6af97bfaff8cd4e723c049725e71472b6ae6fd4702f9dfcb158c7c7d509e01fd1dc4500b9afae31d43fca2b559fdbe49c00ab5dc26bf13e9cb62fc527e8377e5a2bf0530701da5699820dc747aa0a52cbda113f89091e79edf8739ea0c20f6ecf1a7a30071e507d89dcfe8e8bfff157f32a0810081a37b6002223ea0b479db518ea9c9cfaa959106c15c3c8c7d2dfac8346a3ea148dd381ef6fa3a7aa93fac78d09186847a4b1c60aed123893be7db8c9ad1090c280bf2413a6582757dfe3acd4801fd87fe2f631dd4e7ee49bb441e21e5e8b83663eff3ed26154e833e8e14b17184cc03d58a81e44287a26e7714a747a75793602e1a71a5ce68f906648ccb9d11cc11c58af7993c529a61f54506cee796f55eeeb2012af930cab28f1b0d328cf266d0eebb7f83e10144230cf726c6d1206b690032df61bc1289e7d4a7e62d99445c5f0c23fc390905a3d7ba78b735682c2339b5554f68ba7100b3c50e7ff80d197c34a74be12d898001d2e5b68bc86f1d68fe24472e9ad90a0eb51e28f762e50bb6139ba43bdab34f7db6457e7ab7d5da9da1bd3e5513f00dbf2f1fd8207b1a272245e24dc0eb80a8f28f9b998742aadb40b100735e1591c992bf4cd2cfe5f8b620215d639d1ab0129eec492be63c543fa695bfe61af639d618a23b4fad0930b91484e2c71bc6a0d32ffabb3d4bc2cdbc96231030658f6366b52bd4c24685373e5feeda440c62dcc4947cddc44c0b0e474075420e6e77b24118180cd3b0897d1466d1a571a5cb0c942715529b50f96dd2e93999c29499e2b7e444891bedf1df27323324f25610588bcdd98efd528670ffd67b77acd1da9c16a460008204431f2787044361c97f910218f2a47ae063f119380a8cc0574d20d4ce1d51256551e312bf9a33574b7048764f99ef572affae2dd9bda278766c4c91822189a07cc963dab4b294400129184b5069cc8db61a00bac526e8fda2ad178c6aece28230499f0ea356178c82fba99868e7d4a5186b0bc50f8e66fd3b4554742da576118c1ddff8d3bb7bb2d00f6e9c6e8a5c2b49b07e1bd0401276f3f38be2373ca7308e6e6023d8f7a97a60753fb7d8b2bc00482a2f8ce3b0a7a814fe28aa4b58c25f103c7a010ec71f9f894d30d14254deb35f7a30144153be779423dc58200b5a5b8a44dd6bf305ec70073f84c82cb3ac99c8d28d729932014271fa2c471bdf032a12d75cd7607e40a3c526e0744e3fee645c57a2cdf5f97ce9145d99257904e47e4c6a87556fddedad1cf88e19d917aaf6d5d6002561db7289a5adb0ea0096eeaca63c5a5298d3355cfdc6c5393f8d50cc21e66aa2e7dfd3c2edcf878cdbaa0db8d776c1bbfaa36f33079e1429ee583f66e414c1bfa4957b4a0eab3efe68477e549a7e8b7e3602f582da62649547cf792d03bf6d1a386d911bfb180a99e900ae898d34d94e5ce28f10097605726dc283c7dc4f0eb1461b9788dd071cd83cde4ce34e7041cdc535969f02674cb90d41ec5c4e841b6f49f3b9a2d5f5701539c541cbd6cf1770682549df20ffbc038c9e875c0ff0a83076acddf725366722064d40beff68dce82888173c117c4fab46ebc250877c5075f154fe407e10827e7022adab603138ed6ee7b4c914927a611ff9d34518e5b352c3ff6703318b51d300e17db009b5c4564b0e6e5dd27cfa2fcc61dfc853d5ad634a30379f5d033d2661201e8c8ad10dff74ab038cf387e6f036d068fbaa4cbb1cca83bcb26cfc35128fc0534377ce9f6f246486f3d3d68e627ebeb5ef44aed9fabfc755648e53975607c7aeae74413d00fec0b372a494e83fdb99b82934e45bddc99cef1d6073cdd9c3ec1d20e09e69dd3429219f8017117b139ac631336d5a2d957d040511db0cc91dbd7a0c9c24bb6f306b43dedea4df142566a0cb0bc5b583dc30699d7db6ca4042f320530254f61b6a7d756a91995366a119ad509dad7d270dad2dc7e67b33a9f219e706d6200ea26eaa0bf2eb2f54384e90cbf6d36501cc6d6e31a470e5fcafbd3c4b524d8b0d49f6bf71d20bae84e327b3ea1e01c3f63fcf4da1d79a274e8e88c0394c8ae83fd7abd5055b8979941ff391eba72eff40d5bc4709f9847c1caf379c13bc9b3277a155abdf918a3f3bf3bf087d2bce5e74865034bb4f5d063207cc6c24dae2f56ea80f972b793b4003028a9990b77b5a0455fde73ef549b2ad50343123ca218f7b7f40ee604e35e9e4466ed0eca322b72c2fac9852312925efb8926b26b09128f11103dc33df9cf0414db4b47ffa440fc12436c0b33a0ae1762c7eeb6ba283fac045bc5c8cc6e1470c82225bb0ee2c005ca6b633de5df5040642fc9dcd926bf7af212996c626b77f8fb73af558800bbbaec9c7df1b0b239481295afffb9725cb781bfbfc8c693a0d5b51229e5d0d7440c2f8123c64bc2587f7e7e8ffa969b29ad327f720f6295a879b0cd0d871a0763ab88ba4f154aa2a9a0dbffd2ab6d337cec64c173d811442fc42369e0467b8fce90c10bbce3ff0f3d0567cb17f04c57fa5d9b68c35159706d14453735382211338f4c8e5ecc286562ad36f1dfe0481cd1856bfdd5b7fd6b79486525ad71882044728d550b4c4fc314e58278f10468cf2cacff2e808f88df742eff21ab7f44ea25105ac643deaae9984a24627e83c39aafa49430b404f0d6380060f5c3b2f08af08e451bff6394c45926158a150d94a8573a7da4f6757e923f61c7d17a13220235587b75fa0e8ebdba6c92bb43c795b306e334c05f60e4c098717d4bde328b9c59e8d8ff9dd86785f1fcb2c925d04daf3c748ab3c4e77d07d09faa5b2e0fb52c766a7cd7a50be9ad313b79747cdd982b27a0a7875b0f302da474194a9cfd07446a49311b9ded97bdf97e08b048bbce86102f7d394b67b7a125b00947bffd70494b2613e118e454be3b883c127600850441fb768555e9abe7a022e59dfd2d4a34d8b681035fbc1db8706b5aab4788f77b7655e24feb3082e3ad379a54bc24b646149f0bed2a9770f257472974e2884ae722998a76fec368873ac9d54beb957f814150ce5bd360d653586d4cf4b26469b00fb66c4a566a370c4d34d8c9dd595892c3532f49e28b378697c01a4f3c19e16821057529e0dfcb1894ff451035ec694128f7bc635bbde5f026094c6b83c597ba18f8519ee9eb0cc3da29668bac1e601eeea9d4216e94adbcc6818af9c84108f881d1a6e1b8c742eef2779f3663a00eb52a67bb7c632a597a613fdcaa8b244443396ec3a9e6c44d457c7c42fe9a4612484863649874bf1b75bac6110b4fb6a73c29237c9f63c62a5382725e3675488180bc5212f9d163a93d4f54a8d4a3c49bef1ba23df633e3d9298ffc36436e054022b2303899abf1c5d6af618e3f0c60809221c128afe83e851c4f201d901708a223ee156d02dfb4a0b308f0e7faf456166065ce6b43f8a548245899017f5a1395d12381e16949fb81ce9838839765a35a03aeca40565f8738f1f25bcf587c7b970a751f18eb4f2b50f69755190b847c189d3c450d97fb9761dbde63fa94363434c4f40ccd26fb0ac80f08a584e3a6065f15d378338f5a22d1920cb7ab93276ed60402104a0a4c0e1e1810860e856ec0bf76e2aa029c49548e10c18ff296ec5bf0d1ec2c441de0ef468b607be0072d66f95701c96f14b39e038de2f60597e8353b70d3e4c91b766f594b9db5c83930cffbb71613ce3db76265a93ac915e377f18c413d725ee9b1397a453e42bfa84f2525a1f5513cc0c4b2de1b057cbcbac3e3daf2100204c875b305f5a5660fea30ebcab6dd110c3dea6a7178e7165f3e78a76f29d12576d6c62e7b8213eefb86e6a113e89345625406e0dad2538f4ea19e5020ec23a4d7292378f88d3bcb54ef67f6800d16d247d185952cbd32df01552683e89a150da4620aef5ef2ccbb695f1d2f8f67d1c671e3264180cf31d24fdb8e3dc97256a87b3a28a132ceaeb9f2a71753265945fb9351196a6006e8286e239ccb5a854702f55f9ea66f7f67d376706689a2ff3ccac9645b0a80834b69ba0165cb3d2bff03bc6ad47cdf8906c650a76b11b5eeeafe195fce26d0f976186cfee98aab0b32dae7d2c829a05af06e060b3397aaf05d31cf3fb89ed174a7e3803ae92df9a457d8225e5ce9344dcd6e494718ecb86fe6ff98ddd7ffea32cf1006b0fa22f9e0a794abf10f5e547b69fc9bcdd034d9fa61bf218ba21d6d0c415e3e5b9aa16cc276de15571786eff49ce95296bb825a5301c84f8074bff801dbed66562b5140312e844fa2ec221d2483e954377b7c443ab4368da77ca817042e088fbda590ac1b4b14ec85d923a2921b89731c909bee5a7691f8b1fbfef436d5cf0f0963f3432b6436b742833839268ace64e3a4960f075e34208b04e4c7bb2533c33bfe40099d6110c2137b0283a70be6724293e8c9db88f246b5cc78edd0c28ab4d9d3eeeb23b9e54c8139b3a239c828faef0225211be5c89cdc8cd71da54f24752a4c25a581dfba84d692f474650d32237116ce3d5be7a4613914ef7a2a13fbf7165a88962092594fb215bbb12e7bc7e3d028f2a01ba7e6b5a113ebf2cefbeeb90b10d34dc466815a9f2ab4dd35294cd85251010ac3367d66ba3051e68bfd812f003e25df92f9179af4271715e7000ab868df5429fb93cc6e4aa9b32c7bd5cbc20c342b0daa8787761e5303e219877b64fc9f68a0ae99559ccc9aa62f105003b3f36af952ac686c4a9856ba670895d46960f592bdb4f4a81e6cd23c647fee101102604dd83618daffe064726f7dd5bdc2188cea6d36591665cf1bdea8977a6825cb82a823d4b211ba4c0c2ab95701841fd57a86a486b9d35d5767e492445ed948817431d46a03eefe46e6bda28a2b1bf380a3bbb1f6d5b6a9003628b0702e6272c329ac0b0a92723f9c8107d84d4f511b1d1bb50a891cad8d2cf32d960752c7511fb3463102429a6fb092e77a5f911813e831c01f43976f3ff8a32e1cb2f0e81d10f71a62a140e34eb8addc3f650ff32cbf9d7301fac0ae46e8ac5f98ea656b526f94f56342690ca2191dd5f4dcf458c6943d4ceebc50ec9f945faa1eaf05960c2737e0c4fcd33e4b2a593c0198992f6c14f7d71af57ed37befe52a955a19e0b44ecb25b2953ae121077ca5bb0469eba68185d9681588d6191c609e6f188526c62c567fbca56b370b32fa301c58fccd7e5c3a082303c8aa7502ddbea2890ce4691cfcab397aab9f3cc7a8c52624586f2f310c79be660ee3c9a06746f91ca8aced2f7232543507be16bc8812c4fafbd0f063b101975e2c425dbca38a1480e77de59f034eee31d80920833d28d0215ce9fc26a476f12632037902560738d191591371085bb9a53de8ae9c27cdf0c9e8eaf35e08cf53ef367de9aface72bd6f723b221ede89b54f957a8524fd1dc7858c79a3a56aae87080a97d6104da061792ef5a33aba5730c910605349b63e4d57704e583ec997361536d783fae68d3b56b04a4dbb761d3680e9896c70e375225c0b5823867c6cc086b24f857749a75f1bb4ccfa213a1ec7f54d779fddd5ba7a78d73e98808dfaac2d354847e9cb833ed0fd13f006f44f6526886c1a316c35f37dcb75919b4b790c67266c388820b29ae8ea10c06a25378105449c468763c8fdebc3dbec3317b3b979fcb2d5fcaba862cc79d86b8c8fd79ca1d18d44ecb7619d84fde278d3a6a21ebb3dcaf9363557f5db27dcce467d1d4b32ff60b8142639d930184550f19cb54ad809f5834c74a9df3cb0503f76518a0ab5724af00ad440a28fb7dd27b006e283b28af47444b1b4250000cae66cd09a193cf8e7d2d865a3303ff07ce143ee84c1e23e28c46dab4315c6abcd445be4bca7b78ed8ca7e20ae5cb64b0be598f7d9f0062830fa3c16dd7ded744d7a81d07ebed8116cf2d7ed9ec48b54f7f593d6979cbe285481de27d93a13ac77054de795cccf1975281393d91c6d9311f392125da424c85e8098627f144fe1758ee9976fff1dd844ccceecdf0bc2c5502ad6a4a1b8071794d050be6f7a1bf47f07a9869bfd8f107576947a953a1a4fc417bf26557a9a3f3fc733ab77f41cd3fdb1595fbb4562c0485b4325d2dfe0e9febcd2bd283de96b20ecc22fc05b39b18a8686f276c9adceda360a62993182c4424fce47511be3c113004dffffb2d829e487ad7fcd0c8d237770eabc1484bbd6d15a95fea86b3b2a7b5186d5df41d87171564781a1146ee674b2ddb37c95aad786275395c72f359983bfd78c4924cf40547264f5c03d6a808eee4d9726ac9375d23d7429b88b75c806727c96c496191ed1cc350460c86aca982c590eae1f8a74e6299ec1e7cddf2dcd3aa05700c68f1081950032cbefcddc7c632edc6a9aa14c82aac002a2f8599c6c6da998120a0173ecd16f51e39db18355e75915cba623f098d505eb002a3118dc948713f0185dcb530304b955eba78d224a14f51f5ebff80ac4eef12c07aee6c3d8f21a35b98b1aafa4ed8d845ab1a4a5fed2c825a73ab1266508a7484797ea32191367b698ed8f3196507be1a5aa5d757b791621315fde4d20d01d7a7b7733d03fdaec08fb428f8be1b65469b333f3d1433a8ae8b24987cf2f9a25fe1636310d3ca242afed7903959466b7d13432d5e937d590fd300cab509ca794e194ca0647c8d8e0e58b97120280efb4a8e348a720fc9ef60b8aa64f1e7f3c299b3f2ce9659fd6dafd1969e5d98b3130a3f3caa48cf862b01f6146e84f1dde5d34e6d663a0c4df8dfe8153e5329429a2f3f1feb00a15e813a84bda59bfb074af8c6ff620185151e7f77b3f258e8f7f4e5ef848dd366ad643616a7d6bfcfd26bd968ee89b5706f8ffb63d400d70c554c5730ba5481b84e3469f201326b289ebc5ec52fc1955e8d1a6de3e18ab25a41d650ddb04292a38b87abc2101cec47e23632aed195327b42e636d6b83853ffe245f74545c84aff9dc940782bd31a07933f5b40a9e6825660c82ce43b2cfbb45462de62edd445530b3f9143e1c071db10b0564c6172508865d3d465ac2c0927a4850f92c8baa5354f83a5724e212fac1a0fcdde2bab7fc7d678bc89c5310739e7f332c7089fd4a5d21036c6272623ba96c9582f6fd20924976ad296a1bdda1bcd2d01c6cc7ca784c17f0dd7e37d924759369574365982ffa4914492eb4bbbb905a494d1590aa5ce5a712ac4cd18f08c43f00c8b11983b44c3cf8aea4bc8f13d9284e14f80f1447ae482e54e1b48f79f5e006b11b60220692499c0f1cc771cd4a191b93dfd4d7f6be31bfaa8fecf0d2b2761fe8ff037eb49ab1d45339acc8e39f7c44d9e0cd1fd6a47c5bcc03fd903f47893895cc0e79f42043663b7bfe9eca245574afae0422ba368c9cd0fa8b73aa6b0a820343e19826f7935f9fcda5768ec020ee3af3f01346b124f986c74c8505628475b56bf0e5eca69af2e344428a2bcb78576fee45ae6c52dee335fa9585af987b34379009f3a24b095a143d1b52f8e5c70c9f0ca1f8c635d3888213f2793be0cce62b36f33863dfa08b0271dfd87bb6b3d2c3c7ebaf8b1534db51344b9111788f4feb821ffebb0f2a50b8f722403d0c9e5551dd6a705e22846cd28b6dfaf3e5d96bb2180cfb240dadaa3d5c8863de7d4d5dbb1eb3dfe022e46a0303085563fcd6a566340cca3f08d7ed284eaa24b1be91291edcbb077d83503326a86b7cc5de1f74cd9c659b76eb96ecbabe6ab69db624a3b3eaa85bec20c22dfedeb33e5896980fdd1aa6664481c7c2948e1aad83cb66b148a3a277448eafb35adfbb4860f407562b831edb756a9ff9757c6a1fabc68c08cf9a87b0fb15563f1d26e8bd61e6958397c3380a8377e658acac0dc6a4d9ec6eb200b0fbce8abe90191b773c1800d70f94b88e673f2ff0954ddab1cd2752991da3bbfe966ecf09fe0483dbeb8fc3ae3825014146b547b599352a645396c7d551836b1136677d4a474dce06b4c44f52baf3c941439b79b2987d0ccd7b8accf0db0109dcc838e2fa175b0e9f0f909bf7cbf6b61507b8f0b8bcfd5093c38d5de6c74caea8db05ca89e47225e6a181c30986ee4feeca87394e0c0b08f66827d0d240a53d4e319b1dff0828cdd2673f117e8e6ed417dad84376d946d0b167441153f10a129d1d4323956e036813dc29320b3fbd872366b2a725f09fba417e0a7792ca4ead1dc3fb4091bb5ba6b6b1458b073620c7fa2e2f8b504e3ddf747255d56ac59c9bc0ffb7f31f1b8d1b20d3db7572f0ac51bd98ac8f1d6305ac028bce67c5b81a32c4781f82c479e0204ee5bd483a9b4a66dd18f42ce11dc5a7c3b34333ea03a76eb3bac432c4a26d99d1f2b2a688c5248a25cad43903b4a17f3e704305c91d5a148e26a1594d559630fcfee1cc9c290eb56aa1f8325fd3748068181187d12c46047cd70472a1f887b317e43187c1e51bc5e35d2e6b75799859aa87a463c819eac5579489c7f84b3aa67b062e0bccd69271d995d55ee2a96dd8e45a2c5fe63df7d3390907b86708b7d22ad2ebeca86f12a83b236933e7428cdf504b90c069795d9b5301b1391666bcf91806a838b93992449ecbc03e68acb4fb24f03a1633d78fd98782294c34b1be140c27e0f793c3ad44b41ab6c5ee22400492d480bae173098d417bf4ad82e9d75258cb99eeba5081567985b894ed9f549addc632b1d724170847ecb134ec1f5f336330142a7b6164b1f87298b69ec02d61463fdfb2ddfc7f4dafe5c11bc2713fceb9d1a8e998c04d15c48d71398659ca32aa9f58954813fb43af211528a8e2ee7008005f0276d2b4841c35ec7f5a7c6322472e18a7cb3e0df31d3a892d13f3c3ac033850ed43432aaf03d743babb08cd30f1963ebc43f95cae09c4a57a4dca45113273ffe6ca4a9e20aa1e0bec9a5a52c1994add2a360740d04ed90879ab41efc01819eec2c54059d1965ac309e495b5bdafced09a105b639a0b0fb864dd51f71bc2555852adebc1ea066ea38c843a701d5ae3f446eda5ca583b5a901afa62c2739d431dbb0ad24a8b922bf22fd816de23a0a22ba919a3098806c416262b4d853adb5285aebc1d1003174f38d00c45d632e0588ba03e49089b6d0e6307700d38c6a438f2fe5251880c023e7ebb8ae71fd0094161bfec7e8af24838cd40f39ae8c787de0a29f6e7085ac9e7cb7f8bd666d1d9ed9a059a05e9b0c3714a336181c2a3757c15c41b6d489ec733608952db227a55ab36955f95e98b885fd58cc18f9e5de89f83382c1a98d63cc39fbea5f6c302e4e6e727c4e388b1a40574726f4605e3f4fb9ceaedd5ffb2f601e5298ab7e9613f031e4817c36e6b16266221ec05313e0f7283ded2173bd868e6c31afbf85d31dbadcb6e1709ea7f3434c48cd570cef321e0e2b156ba473222490511136d33d99d5c7b40bb32085c5aacc2fa3f5c45183a491d810e46a757ca08aaeff0b3e8ab2832458f5726326832a36095b1124d045947ce4aa283d2daf23fd3b398d8c5bee7d1f4c68f9422be20fbd388394bd8a668762adf9cd9b1026d0b87c97620d0b7613e298c54ec482ab24e762c07fc441c2ed93b8e8c35adfeb8e0ab7f493d072c7eaace982b360eeab3b1a1fb1cc941ca4397833739e2e7ee31bb2b4c4915a90b702c5408abc005a06d89fd99898731e6b9ceac7fb11addff44774d7c18b94fc8793905e07089ff97a2ca7242c389458a210d9ffa0a42f5a0e46278c0437fdbdcbbb993474e6f1e8f1e265fdf6b64d8ab9f5011806b523d07668ec04b4aaafa286a73b55e82f0dfc60d581b3bba9144c0a4d7ebac142047b6082285612a4115564e69a0809d1aa6b5bccbbdff944f0e365d4cfdf2aab1ef61dd228c54be3731d4409babdff70a4f1d87a3a986c2728a0f47e1a94b6aaa3b6efc197e5b858c6fba3e51710f35193cf5e6976a677f0b18d8e45e6640398528841c12e841d099a997d05fb382d700ec98755bc8f22aef23353c2d0e5dc5e7b138264f7e95c8eebac17a5dfba236ee0dac9b71250797cc710f5383d47ad82603ac7cfa499fde1c3557de94980340211b6f5880d02af7f5efe927a238ba8cfd722e923783dfc0cb1733459dbc847eb746d4accd5ffddc97cd688cc11eb33e54c0c30e8d5b83bd2f0d65f3f7b354180e4fc1382e04213311599ffbbc0745c80641566b078da7f51c1c77d9caa68d8de4f58b4045eb401554443ca59c1248d76d4b2f7702f3ca7d318d66723c5bfd7090c6ee15684d56aea0289dbd2ffbc9fb8c2d49615063f1cdc4d7bd4fe24fa8305f28d093d2e711dd44e804b91ca67a11f0d824a3ab000149e4ffceed28adc09068680538d6e5273d3540e296ef295c2f0483bd9e8d14b03380d4596197bb26b492d6510b0d21908c462cc0257256dce55747cf680a3e7c096b51e990364e5f98ea22e47b32fb28cb273cedbacf337e8e2f37a5fb69f566061942d99e824c2921ad66cc2ba3fbfa2ae1fbb60b31e7b0e9b6585330b939f0d37d0c8f0dec0fdef39f274339b53e52f997ce140ffd823d79a0ff869ce91d41d386cb8b91cd6ee29d4dc2e7081278188940f2933dfd68bd066ceed707e623f4aa9081f8a6bdf32e28f8434d69588b0dfecf090c20e14888641a430ad3f87aab273b868d0a2a9c6f0188a101adbf17bfbe681cf87db2b5445dcff216329bb2506cd0492a09185d99ab03ac2141446974b3d4e0a79b73a80856b8ccb7c72ae06bbe516f5da79739c5c134213541ad29b63f981dc7b7fd78701817d9cd161915e88546fe2f502abd0f1b1650ae4f7ac2499ed91e35fc008ab6f72f7accbbe66b00c4506426772a7818aecff1d6d1972dc656005f38469db9cca5b1a9d8671adfeebd890e495c66fb6d754f1668909aef3beec61504422a530e548873f56f7fd038d2cfd526a03ed25bcbd644d384ece9c26ef085c28a3ab6720778f5d411203a6ebc83f6fff305b9d0c63c3444e7ef304494c49f7442057bbc90c057d62d954077d0920a9a9a429aa53a233a3f9c0f1937eb8189870b49dac8cb6facbaa2f5ecec08e3480b68481976391e6a2af696d7419f01fbcd05b94e1fbe9205fb59fc91733a68a4eb6ee5487de5f35587abe502902f3d4d054c654559173474318a67453647293b088278898d1e5f3c30a17f73370a072316cad19c1a6747580d45ee3675bf3431c83c7ac39f26ac73077ef843e9208698309e6553c3ac8ccf3b38bc3d7ac611d7c918174be7aab700fc7ac9fca1b931d9c993795e453ca9fecba89ac82ce0f6756a18f32f4d210939fffc6956c7f576ed78f6151a497ca5d19a076e1a12e0a26305fd729b7df5b853f961593b080ef3c5753ed2cf2cffefc76570be4e991695e22736b01d70f239bc95373a4f3975f94bc158be416ed3b62909f0fb2760d0ecdd3fdee2889d8efe2e766dc2dff32a67de496834cc84da9ddcba7d8ca71443be297a65a41a4e0ba215b8de94f31dfdcafe426b3002543af0437a73101138cee664392dbf3d1eb5b1abbc988567775b7411b0395acdb6e6064ff9fa598e614dd29f1ddf5b334895ac71033195117b8af7784d6c8d6bbb831234bf0ba67072225c719817081467e480311eae31afacc1fcd677b87eb5120bc98adc9c3329daaaacdaf9b88abe7bc79727fd9f8a9813fe87432788ae8b96c5dafade7d6dfa21985116e9aaeca956099cd72548d78e40ce5d853a77f49b22f358da8041074f68a06f78f5aca394e95d55e4709f3927fd99d60636db8b8f17218652ee9c7587a74a9c59e8576aa1c26e94b51f494d2a01741e0a74cf92c2f00d4ba83e3105077d20a6bb7227362c127a34fad30e329e5739f212cb94e43324290dafb52cbd1bce87297eee88e1ce08898a240851ad8181c5f6fba0ad9aff18183991baf061ea1ae8b65818ba997058390d6c7e96d13920f0dc718c131946932859c1c16a5306be7eb639ef6baa0f28c2da24a9bf1a3e358895d7f934b457734741b6b3c329d8ae5d9d2f9c24a6ffb8d8e4701fb736d42800f90e18dd75741fa6e3742475eaf4b093395218577d7e482e309c8d2414e88a248dc70e45fe1e39343d82c2cbf6c693ff795f2442d4eafaa17d3e89211c05c5422e65fa6ba5cf491d2dbc48c1364641d4e01e29748a5d3184c7d8bf7c84b8761a3436a2d60ce026c65194517570253f956d218af546947203fe96eb9e864b93a3b9931b371b98a0aa5e4b364564fc9794c41049557a26f2392c12c53be223f6f918fc6490d79b713c07e50c1e0cfa41fa0c714ac53352741c3859070752e7476dce80f0b7bb1fa61898e95e17ebcceadb7de52b535fdb1b9adbbc68ead1c933a890f7defed1250caa4f950343092e2c5e5714c52a2e164e490d49464cfcf75a00abe60782cf28ad306a0940aea493a79338688cc62698900d106c6e8f7ace02640a2d4f0f4227e9133329358c3be53eee0b5ed03dbe1bc9d9f0a9991fbbc9b94bce46473df4534e8358b12985261ab6b557a546de594f6f1835b7e7df95714b0e5b4f30b30be2f2ecbf91a1296749750d34e435ecb2a5d1a5770f496a7d45fe54e9eb5713ecd99b74e2f6d7fcd632c03251163f2c99b19f45cc2a07e9403bd1683b6760803788184fbc9e816f51b802a7de59390e173a5800626f3cdf0099aba4693f50013a86507d9162600a2605a6c068f34b3a2da09e5e2142271e183edb6d04cef340363d01ccffefcda270fcd9d0ad0788c6ee0518fb72ee34271babac7e26c154933461bbff4c1f2cee0be4ab6097f7f3f69ca931477e393b0484176715e49669ca9dde0f30a7eaa4949b352c53fb727b53b27267dd5d0b8f0a4bdf81785e7900ccddbb8a47e4585735ffe5d880580ef0715e2e1915e6e5d903cd90d7684a83f89cd96f0a410821baea0adf9774638ae00ceb0178d6a6ebdbccb245927ce8eab3a08ff73130decd29d1473334cf7d650231fab5e8ff1a63552c6bbf7031b8c4064b1ea4d29cf8985430863ff382479593baccc4e23784234daa0e799683a6b86eb8bb339eddc460c1e478c9455030c6132550acc0205e23bcab583fd6a9b4ed340afe1c2d4f6373ec5c507d6d5c72c857acf02aa38c405d75132d63211135afdcb0a3b0465bef8e139755e7f8adf5431f8be7","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
