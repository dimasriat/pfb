<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"902477643633a1d8bfb09a1fc226c539d5ba19243592fffc37410a82d056327eee2a0f2063927ce7e0666a88053aeb6da5b167ffbb2754da37c800e9df40d78264a2e5840065ee15d7a2cbcb7face1548289924add2c617ea4365166618a02bd7e167a13697fa6ece5c3b6bcf1d6286da17b7105a2fcea3088e83d7d8f64c89b18362c56cf1e013a42d4bcabde5a2662ae14dd3b10cd131f241fc399f49070c524a9f4b20208b1af18985f92bf47d352cf98794605808b54626f7f9a90319c8bca80f11ac7456badaa64d618735776ad2e31ccd3616fe4ea2032b4458b3ec47d325324948e93d8f06577dfd5f58f169129cbfa6692e6d043d6132abd086410da6860844269fece01ece8c150b73eeeced43825f17c5841a95803bf16d164ce7cc5078d2b6f15c06f7e7b37dd538ea47173ba4cccf19768119794f2c76c9158ecd2aad3bfab4182454f6edf82fc8ac861cbab5b6402dc11eba3c60534cf21c26f1508655d8a7f377b7a92299d12bc21795b8d5fdd4ea5131a231d216c353fe58740eeaacbe5f827dbd65a0aac8f3be01c4035bf043f47797b9e0439477bd82acd59f152a8f70f7aa4e51e7137e25ced8914016353ec9fe93aec377b2ec6cbb2a1e1099474127ba183f88354e66385cc06ed50120e8ec8284ff291ed09c1e1c9c1d496f4d7319ea6016c09734a0bfa27740bc34080cf44783041d93d16d23a374e83df17ff7c28bf419ad2bdd263080ce60c61547bdd13f8b50285f78a0751472b394ba9d8ffdd08f892be971d57f8326095130bf6ce10ee080f99da05b779ddb80131ed20240b5deaa9512cdea9dfa5e3db3fd25e399bdc5d22eff1a2c2c1f80e0953123d520424dbfece4a481967316efafe4f4925e6e160d7efb3a70b48e9ac4c52957420576fb2e102b38a402d6ed4b13d15103356bb78ac146c5af8334a75210d7308f3a9c8a45758e71a0624d5711c9476b8f0d429406549b6f1a729155116448c025e20546120b8abdd5a2c41629236cefeac52f6788968bfddd27cacb170e431ee2e773616313f518f26ccde5b5a431aaff006dc696320014c0e43d563da5b2ce53998300f62c590e5a9903783bdd2b57d609f3fafacd1a6d618568319be3a16ac4933c37f69c155ee06ee940a2b652c0125a643e304aa7285da9a01404e1b8302afe18f0ed643b1893b368c92fd86f99c4a547c75ccc890fb16817cf8a6ff3bdf8eef2dd38f5c25994ea803023dc9ff157fe19dc2738073bee2013ae5194a90463c00cb1cbb7f0899978725bfd51fd91182c615390c6adc5a82621b2c451ab0f9f31188bb823ba6df475cb10e7d9f696e3e3bc8e9f3b5dff2d2ed6daf57d7033cb85e3e970a7b6caf7f77a00ee7a30d73d94400afaab85ffae2af896613bca821ef2725bc5ad2aa3623409d456564dc30dee237c99ee7d32ef2be814d28cdf26571f5be4b727d44fd74fd0ec0d07bc4a859d7042132cd4cf8003269b71a0100d81f96e12c542411c0c5493ad006e0c0ddea192a3015bc821ed1c8aa3d5f6acb6deab97379eff84debfda23c51b77846a1686e109a6ebee13913f3f93dc29ff932a0c860a51d73b9ab57f48924cbcfe14b1f08fb9c47e39e2e48919530071909c6724a2123b04f7dca7473ff532f2ac23dac2afa2db660f9cb62257a7b7c9d7500678172d57f2145533890bd78d1a173ea92a9f196dea84c8d3b829a1667c0658efa58cac36f174ec2286594bdf9f75f2cff5bf09ecad60cc7e6a99c72c08b0a1f76447975b945ac8d1bcd46403dd0ba7ed18fe3fba9b56edd0c0be5ce05f006c4ce15d7df50c896cbb17736910415000cf05cb0680599d3b83eb589909e959f5cb0e925b237ea1e056c09ca4cd54166d784724e0ef640e9afe1af530e24e6b72eded12763821c71a8854bda3ecee9fdc1d55a8f270a89a43c95be4a859fbb2e9edf4a5fd6bea890639b3f96344d5091bfa0e3594d169a22dc0c63cbad03d808fb761ee75ff6cccbfc7c3ead153030b064689c64ea4623ca98695615b0c996165a6a1ba2aa25fbc11276106f2da7cc7365b93b8b58ab8bc9ee5d652326254ad84af45a8e195f23271bbb5e9af36ef1fada8c309f923189f8d5394c08170a9088856d7845e4d8841e57da986cd88cfc05fceb1b72a4ee87f8b016429677d09786dd68e3a7083688f9baf7d07689a8f695d43cfd1e61a1afe22ed46165ccdc75662a620ef08ace3767df79c96b9b7c9f3d85d51bcf91c81954b4c87ec234685245a8ba3ed37ded80784f418fb6c38b8927f766f1ce3832902071fc648cea70ddda7beab38d61b551510afa406c09c33f7de7a4e8c30e5f8557bda33278d85e4683c14af065399f2fc023cf483bc63707cbdb6a154d9a39648c105dbd6e2e7c725a0241afe8c47ca50dcb11eb4d12c07a19cd4dbbc0e31d538d6fea8c5633a6c0c1776366aa95ae4e713365169bbabb77871e856948d8fcd52c258063b946519ee2871744d63b994678f2f252d1b383f39896056da53b7f0bb38bdca68f59efdaf8e7a60635676cda951762ac734b4bbe71dd64429dcae1acae5df75901ed98542a87f8d78064a578a2fafbcddda28bf3dec288d09229ccc7e492edc9748ad97550d3a570b5a48517f9b557ea8908f830a7705611a5c01c96f87668dea218e84692a97d21612bbd0d694edefc8e03e7d49270c14c3b570283243ceaed51e3fba7c4f0267587a02efa45b716bcf451c99ba09850bdf09ecd05e6c5e9b1e6def502d2c6a1efdf59e159539aca39b2dbd31992e2c53e7db1862a688cdae7099122691aaa0ced69ac528bdc8ed99c71a1a2e136c58d439417c4512f04df190b560f981808e9eb93ef9cb2e180e4a144c84eaeec484bf64b3823224aefb56f970b1138d5deca17a4834dc01e6e16a112ec74f1b084ea9e6b281c7f6e2668ba1725c810135e1561b26f86d80c9408ff37e926e631d9e2df7fdf33b707aa1839f4179033feed4893abdee5f27f1f73d80325c985004de00170520841ef8ae414a257a1fec0c952aed048ca7c71737aa9393e7770c5a21455637894b3cb6ff147df8a98b0d5dacf70b77572923217b680a448c69dc435fe808e8d2263e447dcd1dd6a4b159a6a1a246130f9345f36527f6d91ee3d3aa4e8f0f419a638a38a29850932a4ebaac4129790becf15e75a51044551758de367557f006e8f74773dfad4cffe56c945481e0db2985404e462be7ce647a92b91540279e2b080e1903926e9928b3a1d7bc4be0fad997db81ba1db48ec7f6a84ccfc56371fa9f608d51efad5db5ac8abed5f4e387b3ed3ab1f5ecc4bb0e4de74a0c2233cd82aa4521053586abedfe601330ba959b1d974f38a738d865a39fc6449d8f4e698722d2fd04eed4b75066a0b01a34819d229da7148f9bbac9eaaa7884b556337beb9aff84d825d13e2acb5dbcfd0b1281695305e88152f1b5cf260716acd95a0dea6f44414b3967a660e8b49eff23c33feea60569022c8e5270519314755b9c14fbca8fc1415d2d4c0c106bbd43ea506b3eadca67ccb092d696c1f514b553f3da6e4928a9b07fd06cfe568afed5c13333577781c8688ef1dad61724117a8e7a8f65a0d42864533ce306bcf474483b4d73a3af605cea3faf3907d48e2c30e75305e4811fe3a88875b548c445d26371e4f79f668855a8dff0fb107b8d7e2e8e57078820aff2f7e6e8aecc8bea52579e3be6a4e45edcc0fa99b6c8fdc646c26d83a394a698714e3b46ded68e7986db038ce89b7175a3c0269c1d4791f4b5ff573106eb6aca91984607a88c9928e99f1acf205a331dce4fe004823106e4e9559c7156198094d52971e867f8b432e9efeadd98faf456114cf291e8ef31e9cf67d4f3dad5e0d32deb0c3d16fd8ff1ebe54901dd306dbe67218fb977aaa0700a1868816546fe842c35ac21cdc025546c8eed8be7cb8faa7733f9a3281c0061aa30e343a9b5f4701db8f62990fdf114c0ee1706dc3965f30a9b7ac6f5782929ed236ee296d8ff044cc4596ca4e75d252952ebd5c6e08f95afb877fab18467222adb4c45e711e33930a014400c2182397c430dac69678f590c4052ae4204da026b8482c49f01d2545c732dcd3ab6e911ac619aa338a8d9eee9539838c12030540009d83c4c68dd63647ed7d64377229e590e3a49f3a29ecf23927dc1386312ea5d3a45611435ade7b1f6766e3690a416d016c0f227cb0bfc4d66e304011d89219e005c87dd5bd3458702e7b4637fc3d58badcd0bcbbf44600aa36dcdd3fee591fbaea757e9a6735fa19af5ffe711e5025892ed37e27a6241b0ad8455842d52b2491b12579f5ad68082ed5ca0946841b4d8725d23d76455a6174882973e4021538ea267eb0d875c4be02d5217887916d24782b093c43bae78557d926890a5c7123abbc994e7879bd1ed64d412892bdd7793b6df6720e4a351097b69f4e008a30ca599ed4e0538e6419148329f10d09775bbdeed057f58cb72e48d2b4b7cf507931d729806ee9a7a0be0759dcb29037427d9b8b2e7186422910716181687685fb81f6b64e935976c113857178f631ea17d7e1cf857a4ec0f7fcaf56dc7bd0f076e1f98a240ba9d6b5a31f6711ee898a351d594f9c7a725a2966ee5411e32fa588e36bf717d87736d355eb41c5c841314449a89684da0916aa3b932dc4ecb8e15384cdf7bb5ad2d4cc7f4c74c881f398d2d2e7d70a0ab46b07801e5423204f1dd65dd8901e5c367d182fb76ef604b0eb959bdd49daf1283db07846e03d4dde0345ff2c907a534922c246267f7a6601ccef879feaaab3da869465ed4fab289eec8efc13c333874c3706c0d081229f72fe1baa5e671764df08abc83b402e9df1c4f649ed2f2736e77c304dc94ee64d3f80dc12661a17568b536245a2f9ce721051604e287054baa6fc482d284f41c2a4cc7fd2c2b24de89c5dcbd989310038e752c203b66da2f5103e077a19d262c91a35207fb6a4b74cbea06cefa91b5af4a614a7802e8bea301dd88d0f6cf938bad00004392e51b86bf26a72fbc13fa6159d668b56f4db8908abec9518d1f8e8d9e7ff049a4d218ef89945f232a70abe5bd851385e91ce7a413d42f65103418b41522c111483d450e713e5e1807d26c480c33abf06cf2e51e8e171db477938da9e6fd47dd2474030ca99ecc7581191f3896929fa4c83f86a1e83920f9b216c136228921b8a2945384f1f5e86404cf25d40d697c0485c5f76816dacbcf503e7a98e47c704ca22e671f3237ab6ca3585828ee594121e0770409f8e8d5579e9eea0bb6fe26925f9d919d882d7f561e284c3fddcbf5891687f04c471e318f5399b1f14d2a2ef6a605b01d6cdf4dd65b40f2c34e81eab78d0e679bfe662bee1af2ef5a443862c5b2c536ecbd35df6610b611ae6447729dc504ab8c0a682f26c00da9f3814f7fb17a798e23a6e530188a7a46b7f7900f6c26871861acbdc973cf8c669a265efdfbe025d06a6678189a61786cd3cc3f2cd398abf89dc3f90bb388c9c978a14ad450abe588e3b6f5a6be73dc9bfb6fae9037b49d21aeaf98c1e950c3575df63525f2557c1ea2f9934ae85d5167d6857d319e0257209215e6f2af57bfd2f546a9f56a826fb409cbe098144a391a50663ebfdc5132a3817f71d6939defa6fd0e6b152ca89e2a445d34a7890216d9f6171d9764c21f98352ced123da0060ddc93fe39c373a11d3b66092d2465ebf2edae26e3b7e67ea8548a25e135684220d025cf1106335359e5daf53a9ee4219a32f54b9992aca46911119a7082fc8e08ff51a341f759460936f1afe64bc9b8cb830b13b3fad0ef49f5a1ee35adc7e0914071643c855f67c61b6019ae279ab90630d7b06d4c902bb03d4c4a8966f00b9b406bcfa7def13b2caddf87a2f5eafc66386a0f7d121d5a104db0e66f70bd0316e394417fa98dce75a27e2726f2ff5e2b776194f0c73d997783125c08015c111a7bfe811b14022a422ed00f9897be87bcc9eb9d76226f4e87baa0b14be3f6daa6c705b1893a781da574331c9f3506e4756f2836b0a17b23be00b8dd82b6979cbf8fe14863d903133973b1f3698a1bf5aa40308742d716d1d98badb2745d6ddee26b55a24d9781e06bdaa98a2ddc2ffe013f02e4d855913c00a32626afaf13d0cbe067a7610fb40a914d4c8a4f59ab6280de63639da1341898df36a1f75579b7fb710b7627044f47796fed5354e5d2a2e4c869f42b0daaf88911191fd85b36e891570439270f46221775dbe6cc75926d7444b8725927a7e9adf6f713d1f1d57cf1a1e5b2f11b0b0b0018431d20098830de8532f9f87c0511aef4e326af56d88be788911b34de85a87d9b80e2fcf7dfe854a0310ff3f78f89049aafde2dfb7c8131fe9ff52574084c5e9b22c74cf09fefe1f9ccbe481f8bb3e76f7d66d219aee712c401a4f7fa59260b1d4959175612a022eb15553007c8a91da806757bc61b4d2d4dbb5655e0fd50dab310e1b522947107e6f513eccae4942ea97817926512a6be5891bd67dd62158f3f39bc05340a5a1452a26c4efa5dfc907982bb8dfc47794fbf57ac56be2a01acdd35d448a6d016877e71238b6c15e60d5195c3a8b74e4d97fffabeacee7054e06200011332c57a4090edc0210cffc5064a7c7b1433e24730cbbe07c1212e1455722bde58c3587e64c9b9d927de3e52c6944b02ac7666f7475d2efff599866cc75be9b81d10308a43e69930807088251f71b0cc23ef98ab76a8fe3761d62d6f722b36995240fa63b87904d49a810ae385281baffe30c158bcd2c50217a8545d900088dde0bb13bd63b318f5a8205323c205dd3f5cf02beb9b915510564b168a5dd8c0b74f1057f652d748d4320fd900379f7dc57b42bbea8d7d014152794ab1d93f055f2642f376e4f6da88e00d2638e0ed8e01b5fe2afc4af5b8568eaf7bef41f95b2955c22fb69110bcbc6c1fe39407061f0c5731273ffb73b2d9e55fe8d6170154be3aae3458728b9b55aee79bae87eab04b1652171c8f020a0b9b1820421b1e7adcb6eba3fb298fc1ea0a5f1f7a4731f17c146646e2534cc78fc6f8c6ffc55438c96b3c42c7d34bb7d9e3fcc08b03c418b603871bfed68fa40a63b3494a0be4e3ffd912ef90a4a039f1f06b680c99c293f136aa8241f382edc224910c8672d8702b43059678cc4646adc5ab8b28d61d783210d1881db56a4a4b140681f06c3ccff46ac4da2ca99ca895e5e291e4c832d4a161711e246d4261c645871237f3fd18ab3045af3f220627949b2e578b3bc9c2a828f370cc3beef6eaa805688b45744c52aff2b2e46fbcfdc2bb50288e6e4fbc51f36274736bf5b04fa5793bf3d3bbd48c0b60b82ee8704a8d82cbd54d04d398b699847eb8a83fdb1adc71c6facdc27d7ada5c7ff179924397d82879ffc99374e9ba194d53a516d3d24c092986e32b7bdc1c817a01dca91736874aad0735492fc09eaa1df163dfbba75904d61b61452bbf1157fefaa919062c44ff522a938da33c21b04000e22c0a9a49b743d8bf09974e5dcd90025c00551d1df5c319100086767edc47afaf1657914fbc3136355922b11212c99b4b460bd3a3c818cb0c7e3de089953d5866be36ef4dfac6a5b617c44d11de1e97a4a40a038d3b59b67ce4311dc3a09ec11c94077309892a33ec55a0450b058e502b2460125e4bab8a8b1be972e1b5ea87b5f97447ca2057453d6ebf1f234e107ae1b773c3f93aea5867d6e38494f5129204758baa252e56facfccc2ca5405ef8fa2eb851e3c3474bf54a2ab2cd5f080aa09f29582656006c4b74664d956e542bb21618283a004a716d55b786a5764b2508ef5eb4c8d52bf0a13ea4ed266c93c536de750c9e424f98cfdae8507865aada6065303208e6784f884bc9bd6e3e9b1d6f81d06e06438bce1bcc467f44859a3342fd6f7e98e510b2e16f549953fddbb6910fccb9e4af4395a9bffcd759d63c9076191c874d65d09feaf07b93c73a72cc3f41cf037cae438623ed7924e665ba8c5814ed7406552b8b4c0c7b7a7a35ffd3755c569c919f0f514b5e0ce29201da9fde47e71f5d9e9bffb30964346b98bd930d6c5904812f7859469fdf6a57ee307b6ed0d67f3bc433aef792cc8e1e558707442a0a9562abdf44da5a3d79a5d53b31b172e7b3f2e065388e0b169da8526c8ea122413701b1283b821e6919fe89ae4f810cc2cf227918ee36fc6acd888e33a665517a803f04f22457a225865bd5ec512b02fe98ca3f106728cbc4c3f46b8684ef42992a76258bf6cf260ab2649dae359b640d542c168dbe1579c461be08b2616fec250e25bbb8252974594c6f1c2d0d42a91d3e32439a85368c28950b1326194e99d010d712faab673c8aaed724674db09a209c9c6e69b82d52424941776cb2a261e32598c439fa5d015a8914dd30d39e5f7da9b78ed670005248922384669338e42a4a411caf9697a24142f9f4faf35166289b4000bdd1ef5ca79dcb632e788452e4b584bd532587fa95fc1046942c8978a825936243e9c499bb10aa558ecce32ebd3582362993dd08d496f93f4c9aab78d70c1c339527e5f02ca676d23b3605a7545902560bcc94f32e8fc270ba98afbb39fae9bfbe24fbe3c181acfae42432f3139f219fdd6e23e215addc6c38569bd7eb45691b29b7c6d3222958386bab90049593799f965b74b3462eed432e5820bf6ad12de372c86aeeacaf76495bdcf0d1688a40fb3fefa1314c248d465b71cc489119400d737f9d5ab83e7e613a07e736e482fe857b5be0071f2da34aef9c174123c74fb2b74a0ae42013583f5791439892c871b0719daa11d3ed0e8bf338e5a5a25af3a612d2435b962d711f6a9ea113cea2d4b42b635787d2de1048c0128e7f1220d4c2170ccc33589a3b3785e83a76a1f01023d190d3a4c73f8e73f864dafd7be45a7ef69518660fffdcfe2f8c0f91e4fed73d5e0cf35d3c23b1629065dcbe99111a0fe7796e32d275b83e099d8b551ba0f1218aa10a9a7ecb9c4e97b2cc450ef6952a8d6dc3e6daf9e496d6a20d4fff1935f12c689b69d95ab009ad21cc76f47d2caabba62f5e37a7f09fe4e83242985abd2a57964fa3dab3a420d604419bf33a7cc1a1e6f66fc83c36c326cfdb7a9518e55aeeaaad3c1eb189c236b18c6bd7b2076b0930ef00c27605af1401d25209a21cedb98d3ad8f652b40916d98d7aaabb2b9fa60c7a9b92780f273b4f353ec05ae0f4da904a6556cbb7e79e2fbe5aee518b1c601673f19d3ee4e509be30b3ee482b2c73c880e0a5047dc604226575a2588aaf259314cee62aef2642f298164e058e8ada0674acc808089c7b92ddcbc2d6c87e831de842b652bb85308179a800b7e851357744b65eeebfe4081c1472c4232543dfc5a08093f94ec0ed90bca45b69c4dff929be95ef014ab0c7e3d8de7eeefcf47ea2652b495c7ebb5189da6a794afe1b23c52fb580ad19f800331ceacd6a1642534f40d2f371209a6cde9cfb52877a1da08e87b9a26c635deb17029ebfa2a556b30bce106c9da4300b66d362dbf59d0bc4a08d1229d90b3bed704fd17bb47e3b9f4058cd750f7720bd72fa78e012fa27fd9febae2bdf4c0d30760fc4443ce1de1f527a6de47f9e9ccc585b195df61b2cf4975741912b56931276d2c89750dac6e0d05c58dd9b74307e37f33344c79b047abb781bdd66a18dc6ef1c8bd0e311b74edbc4e33f879becd8edc4db40e606deba0a181ff583a070fa195ed22d47d42d2354153225883825f2eb2ec6571ca1ca976137db6079b16ba8a1f1d69520fe2c736460d4daa27db413faed1ba5069ac74a29eca6119f0918e0d1f066f641a8bd57310a10e2bdd3e0515db4ed3b90c58b41d8f052d5f0f746afd8060b439867feced2e5f23d3c8212aca97e36a1214321a80f1218dfbce32d27f2996c4e4437b184d6b8889ffe1f8d77b03e73e1fb2a7609dffb6d2cff355fdc68bf7a92e124050f7f7f7d2f99bbe6ae571fdaeacc6ee122fdcc3287a73bfafaae654d4781d8be5aa806a3f3d7933fc59d070a0281e54698913c652eedcacb942d4b49efd84aa5381f1cea98d5e5e0ce80cbf37eb5850a017d982d1fed6f377ef0c5d2494ca1521d825cdea1d07ae51dfbbb16b8469e035397489cb2b2f5ceb428c3f22da8cbe4d334be2ce49b07d32560df7d0d0774d3292b777d5a4304e4b4147d9eb5ef7e9df0acd1f3fc10965ed10f37fb14ee54cd8c094cc04f5f88a5bf854a71fd3f4d55a65a39112aeb8eb33e7f950d0fb96f5faec09bdff6f5ab7910469592a8f07636fa4942155ec81a513cd64aa216328c131058baeb41fcddf3d4719c2f5ba0451a7266611275a7b4e78dfd51d59bf71a3e65fa1100411bd27773d6851135a99ce57d024e44ce845f4b126cd084ebb0a1be93a23aef463e510b2b7e762812fb5032f6e27db9c0ef8a54c25d5620efa618f07eca6ab4add370e1e8304bcf36dd53259ba99173c985b272832a56dfcc23d5a61711fe40b719841d9132b197e4d95d28bdf00d01264fb8508c21d7334ab6a8d818dea80a0121b42129f2ac7da2cb38707da9bf2ef470730d6562cd02ec9ded0856accf406348f0315bc74332283338a8a702a98d04c50040ca03e5db798f1fc5ab459c01b26f7e22aec71190a28e4f52fa4c7dbec923868b83221c2f9b958b0a1141c99341c3976d24544dad9b1d83d2614d2abae4521531eed7a348581cb12fce00efd80513c7f3edafbb86104d24afa9d9dd6fe21c733e756c8bce67d61c7563c92820447b68d8104c7ba4b2f18f13c2297460f1c44d9487b86aa456329a9a10b48b92b33cba8fb22312857b35b0cd87b74a3a544939b195eafde4df2cf8db318249049ced438f943b69d4c71dc9400bd406cd4269a662db2f84dca742b362b24ebfd084b77dd69e0fb6804ca7d87b88aaf95ac7a9da69ee3957451c7578d822f2a5e4084eb9378dad3c29515d91a3a2bcc88f9eb331929027cdf3a60ced36e33c3f058c927206ba489a3cfc85065c1aebd51ace6ff854632da95ef1c56a23b9bdebb15c5be6ffa662ec368433b6cd48b4212cf381599f0a3a637ed75d5ea84300aced7767d6413f9563d04e2655ddad1415b95d5df2cc80022c7256d804f9b523f95ac29ec0212b5438bfeae2dc516a022fb867eca0e296e093505a614f56272edff49e9018c391d94cbcb1e57bb604d1d1550dcccf5691f5ca1a144a858d4d8e090f072ad5a7db477ca59f471a4a963073c413b5151321ae4757d557857c198ab85f26328f04ad6229f44da49193d31d07a8f9beeff1a21f345359733e215fe695c6b57ddf597e3e86fd22e6c85c0b0e16d9119f01c7d4e470733f9b441f470176fa17b53e56dd8c7d3a776e8affc483b3110c7eefcf1df28cb04e71d655b983647abfee95a5562b77cb1a0dd3407a85ff2e5b507fdcf3e14db59747258aaf2f8ecb4d06eabd60aaefa7fc106ebf5de114b888eec608004d5ea5c706d501e8936e103f018f19c3c2d76cf228bc6b3a164413e7bbe904eee3305adb63491890ca13dd1ddb1a31c5939395dbd487b172be285bc92eda400c320240861c318ded5c937e6fde33f53b1e59abfac231076da9c1c0378e88fa96eaf490d5c0b07b19d9e396459d60687ee239d639351d5fc32818bf4353bf07eaf9155a1b08a654ea10af59d2e5a6c30448cf7b510ee00957e9bfd17b01ddd43a1b725358ab8dce190e5d184a8f30fdeccf0f5eb5b840f68189f6db49d31a095c302c16db98cf5433c6ad12e18eb9ff5964b067576643731dfdc698cd3f4c1777b286c6d7f538d67347c5dced49f5fdadbd804505eda3298f69cd27c169bc067df72dd47dcca31cf71f2206b47f10c04cad76be36af0359c5b8caeead8121cc2b388e0ecf411fcbbcf862434fbdbee9d032c20706d843e19a4cd5c7cd08b08b64cd2c80725d0833703879cf13752410acb2d31be17ad93340c4ec191dbd83c0bf4f4ff9d3379884d1f7c63f338fd05a30ca825fe90b1385e276bf66c2ac53cb0b8d8754f4c63982ae388e1b09367e4cf614adbe98f8c83ff7acb726a2cf966e09cc6090c4f3a8b993976b5c953ec11d15cda53dfbc61a4718f1b6022a388a53c80b86b97413114bb771ba57e04609a9868ac9cddffdacea3016282b4cf0382006c28325f09190e9d318c502df4ffa9f70ccc8edbc139607a2c08668ff15ffe848255651194526b78c5d181e6d5aa37e37f89c6a023ece7741d7e3f2380afca5efb040f7a055be0afcb6608f26101a42cfbda1eff61ae42bc88831141a9f5241e1c87955b0ab4949d3613352bafaf8e195933e354d2192703527baf8bc1427554a44616d655176dec3ef9e0567ccfc600a7a5f8d7fc494254a7e6e16803d9f7ac346477fe14d0894b2873875657a5f770f336900be442b83f9158de37ad9702ebbe3dfea3209b2c43f194f1beab95318068565b5201c41e043a43b1e5d906b5f4c3704a3ac49c0d623de0fd552f4f4ef6fbe65ab8d6147f3e2f091bfe7f1ab797df0e8a8d45c3e7fa7fe5cf60b6a896cc72bee814bdc6e392170bcb60ce6c92f112a625edd2b5c07278acbd0f591338c91368a2567a04f3228dda90f6ac538904f38a58aabc780ba081951e759e0ff6d106ad941dcf667c29eabc67040100b8b22a423d981b325c8faec5b242ba640b097a2e88109fe08c1158ee0477591d2f79073c97ea077727c0cae3c0f9f5122b6445751e80e8707197902e170df1ec727212b527d2155163aba8b28013409f43a95a10046ec7830fa74f9f4d2119d2f8345e0b59ca43cd92dd4b61e0ad0a9caf8e643fdb42724f0891c7503e8175ce33e4e07bd41f07f8a04edede5b6165d4b510ded415438e36e50b562a7931d32c500af825e2df2ddcfeac57d33bf9a0a7d8bd948212fdd1536c46a34ac9e72218b08b148c6a3caed67e667e4c12193a970b7090ff80a3047d2dd2b6ef9e90193a6a362d310aa1a52d069c383e00e99f9d63a69890b407bfc1cc7216635625386ed3c9e57ff5f09b4cd369ebfe0a2d859654b37f38fe22d5b44b71f875f7fa59ab8ecd5befebec0d3d3b8c61d45b3dd5cc220b9b20f0a26686b16ff78f78976853696553f3eeea3d7c283d28abf5772a0af312084d054953a551fee24b8a5137c2fcaa1c1bb92e891f51f5896aaa6ccb8b99bd752d5bcb0ec516c643dbd254bbd54cc0ad51de21ad91e2d476ec8dba60d5af8d066f7a5f61e65535dd1a416c29e7a34368dd073d68514f992b6094a203e0eaaa27530e3bc3d660a2c3424d320896da6560a07fa70965585cf04f6cc7ec4f73ad5ac0c55560c41a093f71314072c7c96a1bb2fb8565be03dce4b8f805a3b40ab5a3e1e83ac0952b0053537e771962c357a802b9f98e2bbc070f4e6e9337d47eccc6d89a9895c6d723d693788799769107e8d94e70c866759102297454ed32dfcc4713a46e70a03dc5b20d2062de028e60afc04335833e345fe8bf42d7fa89c1aa2b99999b54b6056f593139423e6e8f0dbe253cf931371daa89161ace7b130d6517ae653126ec8903ef04f7623943ac4dbb9c0e9c98df43d4fae652072cd7a1b703ac4cc13b07177bfd98be2d01991c61bc78383a79d8bbd66048022b3a0ec55558c8a8d7fb0656545640fd8e926cee3bb134aaee1f7ffd6cae693d2c87674f6ba44d044f8d13080827f667b24f84a26bfeeb327670e6929c52f4ca812d29500a5ff7c8291edee00aa778de37ec5db3a8e7162091703eb5ce0cd26fa031db5dec87930d6cb784466871480d34f1261fcc8599f9058364dcd393e266e0715b70cb1c2800dac03a544c2a4a9b97666899c0b5cb5b3cc1e4fe80a736b29bf71e5ce3d2f6c337a10549a0fc286e4428eb46a0787d22f00bc3b86806b7bb7a125b5206b70b66dd3b9bbeb1078dad33048458342f8529fc351cb725685c758246383d7aadab6acb158335220d143b508cafa7f6a6c8c2d798726e74284a7daf1ae8ac111675f1bc337c871c6e46ea260a5ed433aca0f4d87a54111861b02a5bde93c653bdddf748462ecccda155c808afbbb88c2287c1f5b8279305bd3144a5884f0e65377f2bce2976efa7446bb71572f62972898c1bf8582b638bfe852b2d03e3d08158274720056318d9cbc1dbdb321b13588e1315b258c9d4724a6e9a14da05669c8c622b6cca5111472042730f9db53cdc4d6d9d89b42fae4d286e12e91e1697261565a6f543223bbd94fa036cd13405947ea02fc75fa2be23054e5f38bf3a1f580b9405343d3084796cb02d80d7fe8c8d6d1ded5c27bb5d78814d04e97686343f6132a589f9a376bf916d52cd340f1d9eecf4ef0068b559847037b16c88d2c3a4b0a971186f087a5456ab14a6028b8e56bb696fc0f804da680bef56c6bbfe572ae7697f8968b354ccddb6504b6ae282493e718d2709df1f1c447d26fb456f90f858bf20e54c358edff22254783b0063d3beabf27219ec01dddccf2921be1945c84ce783c3161653ac454f0cd4a3e44de291a3a0b24ee3776deaaed449737b1c487bcd1a07287cee775c78f1923ce67b1c1c1b84d302f6f0d0b465929b3bbd71a0761347c258ac9318a853d927a2286724f267ff87935905c8e8e887aeb00231a3d2a11c8eb7cc8b644d068b36798406af82403a813f92e3d46737154915a2b10b0e1919925652244b6a51f648e73ebaa24a5fabb0c779cd3974fb1c1b57921ce4a47f0da66ccab31de793e289629741e88ae355fb615788d077003361e02e2dc2aca6d2414a2570d56f253ed43e71abe4002e6f7d5e6067997d435498a3f79857a8a77f1789f631b83e914be22754da8565865c21b3e8a4617824364430b537f0505802178b284aea7c8ecd14067e121ffb09ac0375f8a9975d069f04fa0c108f35617722af26b75ef3040e1e3bb8674fc7c3b9718faf49cc87220a31caf45cff4ef28998d1842f49ed127553b2b3d8157dbbe1cf07497c85288f334929d6cdc0f5a0d689999fe708e1c1bb2b0172692f4fb845debe671e07f56188b709d5004e3f1294ae1825b49f3e6ac6453a8f3a7feb1904d1cb4932efa5ba3dd92e66423cb829642d5777596a54227adee39f036463d49b35f665addf95362b7d0584a5b67479a5cb9631a00e06e52c7042a4183546fe22c16584d2ce088ecb36e9d71710aca21a792a9102dbd0b78c04738f640450759ac8643b4d567c6db7be8d924aedde0c2969990a33948e81066da007d9f457de76eba53edf60d7f39c39c2094998d4bcadc6083ba9ac063c6140a6fb1c163c79f28c581bc554d38818f28b1a2b69ad65a6aaa9cdc4e8ce24debf97d1c23ebe50be1df6165b6df0f36d83fa4770a499b865cff13fb13e2c363b9c87e338ae3e94a6e6ec94bf534f14c1ba4598e533d55fd336c6774547b59769761d33e85ca1183a7a67821f61aeb398521f7645dd5ede2728d6505204271c4ffaa6fa20c7f9aeab2f499078c5a8f35d79cdd4e3d34120f391cb5d1601a4df129674155aa530c122f9c287a733edd7d4f14bb1fac4edf2f02d3ed609fee6472531d32efb58d66e1469ba322abaea92931f6e7d5714f14390b68867472f549991b68ff822b5dac077a4037fa8853bfd6877c88f95c3b85aafb6fa4b0e718be63923d6066e476746c648e95afb7367b3d57adca3b185828f0df39ae0666242d0cc70c2237d8e735bd653828aa946a665023bc3c885d4955ecb11916b3e226b98e8d03f9ab0fac9c16cf668afc6d50069276e4042353e5c51a45efbcb67a4c9dfc963996ecb4e1e2abbdb61818fafd9dea1244e21d0008d2059f94bd74985cd012d41dfade0b6641785373978b63ce7fff7cd17ae7b23fde22705a49a20e14519d85c9592efe3bbffdae8db88c0c97f65d6d30833980331d7229e633455adb251926e99b82ec87d6a259d452eab1528ebf18064f375caf1292f2bf3699f45a2753438d8aec03bac4a0d6f96b670e4281ebfe5754100ba86111a90bdbc125ce35ef9bf33909d5c9157e741941d0efadf152a3980918127dc69dc9a0d6bbb8f68b110316f51e1300e87bf13a1fe8ba07ce2520d0ba607d95f71c43a1c76b687d96ad085766ee5052e284593c41dd3fb6673915d00095f8aadd6bc5db637d12a0a6fd20977d265a6bba896169ffd6ddabcfdd8e95e5a76ad21385aa3f9705fbe519de8beeb1bd8afcb13a261e15da785aa3584e4138f390982d6273e7e491d42809e99a56d5f0c992a658ffd3d91f37b81e392a692ea77284165622d7dcee165ebf3d55f131815ca78bd701020773315588b42710e7ae420c5b16b67715fb15a43847cc142a3854f9670f49c0317492e02718c0fb08ac76cbc31b557be9481e20318858ea8282d58a99d2aacb0abc16ec54af69e832371ea792062609c1eb18075058c6bbc01dcb469e0536cd5eefe894a2489d351c91ec06a8622ec380d326b2ca051f2ff269ecd4e2c3d11bada6972cd5c8d326497fb242e707dfca965e365990d69e3f900240bd23ea91045eaf8613c3f29eb6ecb7582683d2399ef3f16d3958325aa66392573ae5d27b83e7e19fbedef9763b6e9cc595dc844200556a6860bfa48fa0a3db63f682bcfcb4159e03049e030a8aecc3dccd96814a23fec817069f2eb0870f92872ed478fa0d1af6b18a30b5af0deb2db8d7e73337496451e1bdf9bcec4af0b522e3bca91a95d473eb10fdff78cbec0e138e99429cad2884bbfaf17bf3383e06d9e74ddbfdd6d6d8b082089fa50d119e9a164f672148b95e2c43cabd47d20b9a05b8d84bd31c6f9860c06fd08dc650f030d38cdc894885ba79a34bc3c2714dd749ba63c6b5f4c50dbdd34b0ccb0e21a8244467957de250d715283f0e1c887349069a910e1e61b4cfea678fa9751f29e7e20fa1657eeda424bc8ac52714a2cf71e34c85fd4dbb34046c9f0f87a2dfaa4d7f733406a3aa747944c3a0f806fb9e910c0921f741180fb6cfe089cb76ede0193abe4c8796e8d4e1d2b4aaf7988fb78af1fac3034d2d4c6f26c5fb594daa7724f71ae35e146baf0a166c496eee1d84d5908a9e9ec3c2e6c44e4b5bfebda646cca6329e11a90ce009eb68baaea1f85d7a246a745386a5570447cc027d32ca73cf40d7eb3a5b69460a73f6a2c36ce85053f2859a67ff425d44d4ef59f77bd03e0c33fdb820e124b668b8d1f1f7239b5ebd6e9f06722966dea242c0ce9b951cc967f66ef25cf621065c583f216bc695983ef2ca73318462a742fa357fae6a92e5daf557bd8bfabbb73db9cde69b6d8a806b47b6ba89d035db4fe658ded2dd1559ad0f1828ed6c461e96f59958a9cc38b6327153b094acdd3745ef17a94800f12853b8cc9198137b162be963d0693902a07151e98285eed2c99f51ac16eff674986edca4fc4144f36c39e38901c31bcbbea176b18b1cd4fb38624b76b3df50dc53e4343f2907ddb5341f9e39093fb08289db74ae54177b8d636130317f19467813c91c6581a36909a3badeddfc75e645e988ffa86cc8cd2aaeba5d0b628d8abdaa66d34745f6f6926fbfb8a3367b7b156686552636839d4593cd4c34da404eb1affeae9f1d51b113ec84b0b6dca4b25b1b84922a661d4ac1dbc5a889270b0f1949652a0e95425879c8ce31ea6286a2c9c626925929f5a13318c2","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
