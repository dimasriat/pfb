<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36494b976e230adfe2872154f5feac21dd35e72d5e5356e69dbe33c15efe2f9e59954fcc03012a2a28d444bb89a65e9be79b251458b14b2fafcd362918da935cd930cf155fcc95885a062f75f48b7265eb514843441be8daba9e0fe9a1afccfdb0da68820f68f9fe68f78aa815771cb3ec0bb1486d01be1ebffc382670826fa84295453774f69d564ff568231efaf0543971f9e9090dc37bba596c63c9d847fe788f1ea9885b1727e3fb800f5b8199d0a0379168ffe74897f2759a5407bf34823fb5f3a0afa88512e7d8750cda4ebecb7d8145d43c32f03f8c2c5af3deaa08a038c84a616501581b8e01c28888a62be33ffc5111e8df301dbd3086201d4e661675006e63e01e6085fbddbc313f38580f51023455aea6d64c3650052a9468cef8695770f3ebc557d1c72dad70778a4c2369ed795d842435cbf1c7555cf2bf9b73e5b098e1abb6191443ce852f05e2d9b30a06db475341c01cc2f9f5d586a92b2b210923bd56a82ae5a7906ec699016ccd2e08aa90865909e66f95a9d05da243a589580a454f9336184d28c943f71efb964772bb095531b1774dbc259d41d6b6621e6bb8351307fb7215ca6a9c295f87709fa03507860c6b997b5749716cf23ace4b2c3b025bec95be846161bb5085fe99f1332bfec6a58e89d28b561b70ad53d484dbe28b319b956c284e67f33b2620469f65df2cd3e934998ef2404b1e0ad85de40d26b08fe9dd66cb90c9b8301d2b5d2fb777c75951880dc89361562008a1e83631f780422970f5dbc63e5586b7340ef099d8f915fc11923089f895ff624844798fc578072a6f1218a06b6a42387c09a079713ee3bc2b9d79f7fe5636481f7c9c721ffc6fb355acf013b2a10e8433421849040c142e9f8d71e464777395a276f85f2c4d810c94910e2b2ae5d835d07f584f2a9d79492ef7769518bdb216c23f8c06c1dbde707659e5ddc0f5099636144f9610d9bae1704bff07660ec09fa817d5cdfc8b2ac30950ea223dba4bfc67c5ef4dd9c2860d05f7c5f1ff67d9ad71da363a29e2adc072f75988858bd5ce1182540a1ab7450230bd4463d031c414f7145ac513fc5ef2026fbce51c45b0bbb0e38f1fbe3ed2694462ee04900cf387aebcbc05fd660191bdac7b5bbef69f730bbd18152b7d944acfe0e1962821c2556cb30870004b07ebfd5417ef2921647dafb6f1247e20829d819779a316b941484bf7c3e88d4b261022c13942eebf117c52e3e31f6478f43f0d42a7192cc700dac4456d53e561e30620ae0798d4a371d01b5a11430d56e8bbbdca777ba2f83034aca76b436d0dde7790b17c51ee82a9cd42b860bb9a13603129a8a86a26b4204963f454505e6ef5ff4fe9be1d850077ed8e5d3be41d22e22944103d4922397b2b4862693e1cfa53c5ff20699bf5efb610ab32e864fbe13c4f7af0476786b8df800da4251439a991b9cbf3780cf31496063e9d16731709d3bc80aa27079faebbe5616d7a31be579a658099895ca47d1102a3e871335cf78c23cdd2b1c17042a7b9c01ab49dabb1d65634de336f1566da85dd4d0a86c23fb3083289cf76cb404f4e1fdbf87f252b45ac67c4d93ea8e7f47428928ebd497001568addbf0c2a11577966a9d5846fc9ef20495c496a0b3e83ba00b675bdf0898e59b513181a123e2e640ba74bc4510335241d337b1a6ac28a234239cb6583b63d546ca481f7dfce72b78e75c4b9d6e4646974f8c72c3552b6c9847f88bf0ab0ed0de1a361be3495fc323266591617af0c00ee962d0ab47736c1de1ba2b476bfd05b1e2c6203ca2e8b5ffcbb3943490c811c53963498a1e1f8cf3a1d25aae4ed6218d2907bb4ef817ecba77826f7f4c4555969fa3b13fb92e8698bae437ee5d90a0eadf44185bc5034ed6feb038bcbe0199a0c5173b8fbeb9bb77a6d66f58578148b5d0e0215c40a3e5342850e473cc595d3f5a1a76a05330964b1bbd568cc70ce3ddf978d8f322a9d73c1cdc2bc7ded19b0f99b8c34074863e746ebd454713d6d7177f148b4ef048e96df9f4160b4f195d15497ee333a86a2f9464a9ae9a735f5fb8ac3134b433bb3ee2689dd932a2ffa410fd695d35637ab61d802b7bdb77f1dcbf1949f5b66654ea00e01c3d8827c95918e0c394260d8711592dedeb0ad71e1462a32a96f697634d1bab46ce8ffeb680b2fcfd05a97528c8bc6fcc91ea80f6ed8dc2379c058f200d1bfc39d16d847d66f4dd749e7330ce91137c330dbb907479f300e01ebe3a84843c1398ed1b6236c3c01eeeaadb0f74f8d9bd38234f5aa076fdfd423c89d3a7068dd178e613dac93aefa2c87c5ed226f9c7961f3d19c1ea1ff77f35d71f3bcf1795e326099d3ee296de13b320456e875f01cef840aa8abc3faa9d2b71fa7cc0bd0fb9bc16e4c0d9e5787103a8a7b45551371ba92bd15849108f2c92d07d1d1914cc535eec332d3e6ebdaf79b458736878a10541fcb7addbb37e7b887a17c8f779e347f3d885ed7f2f288bf78c9abfe0ed18b462fc5b5c8ad2aa0b5439189f97180138b9e3f669422e1b1890415a67c12d5b00dd807ec329e9a6ed06958a5f67cc76824b72e8e1d19281ad98691a89a9b4294a2b0f46db5c4ffe18371e44734a02ad231c77e8814e6c14711df0ebaeaef74959eacb45a61ba9cac4291f32da986f22444922b00db753ffb387e73752a4019674de430c8880390f52ba9e0dedd8176965b5697f8efebb39cc8630978f15ec8db0bc978951bcf730d9559141985ed0577075363d3f96cfeb9414526fc54b626986b6477a676ea6a682bfdd8fef79201925cf87cd285b0743ecb51f2168515200814aef97cefa1a4622065b36ab343b4e1ca7ce0f7968367427a386664ff3e4b652f4c28d69814ac08e53e8418b88d303427d5c065681c39b9d308caad33b83fd87f96f729dd239aeeb2552039a61341f76ede0f67b6eb46088fc4d71fb78ca3d02c0893237bb19f7ffddb8aba61f13e10101147398f7bb73482eadee6010eb4dc24747dde2dd91f6e72a3bbe6f3954015aa1e3407c19e0615c6acef5231fb3c2ae8b7a2caa141bc440621d457139f3d1c7a37477cb0184986d86124b2bc43d69124112c294f5e25d97be9350b2f87b28bf310f5d78356cffdabaa9d95c7a2d3252d8275d914e867290d50be411093c09c509046fdf53aebdb6c00010a09e9752023ee1a4876df7d9e1de783e9578a7cfa6008e6805c82f25d8d129e356f3641d2b11e375dc46f5d85f7c520bcd61cd4e348f8c642d3ec56501b52b4d4132e288b85a97f97377758627ed92e03a23cd07252da8dc53ee91c732930cad01c392b0f8f421231d8eaa37bbe2a8c4e343dac1efbae4dcee3f17e730c0c1bb6d88401134bc6a6a3c86a8c610159513358d59f78073303c5953017e67411e95f1c884a50309594a100bdb2c2b35badd5e8b99511d580286252e5fb751b226fdac979fdd9af029e2ddef5ab46ced48c148d182ac93183344417714efe14fb86afca348e951413a33c13274d0b38ee7bc754169c0773c4c0e7d80396bb3e71e55b0abc45a5130decab6a089b7c909533420bdd46cdef9986fca7a5c226054c4ced2b5a26ffda1844307a4c7143d2830fce78e590370691f1c097de4ec8c3c5aa932c8e12fae948273d7278782e19dd9b29195f2ed8f986d5b8a39711d99e378b2c17575dd8b4ae65ddc2b10e037f9b978f1b548db5b3b96938854c40c30d7785eba037716a7cb13b6ae91837f1cf417694dcf4261cddceb40c2dfbd3e1905a02af074897b40fa5f6bab2d6c52edfe9abe08d0f4bd194c108ab297f764ee51f4d98407c6fb3bb05aa3f3dbcee1503fc127427ca939324d975887fc8a65b57d848309221662c58b900184fad48f3c374ed29f29a0fe9c7b83f0acfabfd14d06ca2a0db378841742aea30f34011f8d23a4d8583717d86ceac1820359abae356edeacb7397d74438cc0bb3e303320fcb80c1f54d3ba7c3c7449613a876f24fc19a6c0c03bb81e904470259fcb9e85b0d43e78b0bd5b0ca65658a5f438b2481f79cb787769935df28774e23bf811334dbd22063615361bd5528dc6f26ade82afb47c273ee40fe361f0b79a03e8b083322b5c4339fd0d069ce0c3d4048123c52f4e51bda1d11595f175d1f93e35fe1b36b5342a15d3a43f18877d0adf029d0d153c3559ed3da0cf3a45deb49c22c6c1580f5b16655e83a5cb8ce869443bfd777764452d53c59443c688fea0a95c4fd65573001f7c6ce30fb9bc41b5caac037763b703a60b60ec19e9658ce15cf057931c3f5bdb8519630a24161759c8c6129a65f0742cc4ef04313da79a61536bacd08023131ff76cb8a68cf699d235a5b5cacc3888a8d36845ec73464ceb429db7e6468ddd61d522a3a5957fe41425c0750b8e9a244c38b852c9819359334fc115e13cc3b6ebdd03e117b43c2dd3d0f261943f0ae08d2ccc6821b511f5bf6ba995aba1f97540fd707cdc2f860ba77e104ccec26f869241edac19bd725591f39ee96e903343eb8594079cba35ddb5f52c05aa972f3efd2a2980995dd5bf1c61de0c2c3a09b24d91364769c7025e464d0b47ef09c10ec7c8b5e603b179fcf73c7ae382e841c84559b7d07c5caeadccf05e685124ac0b3868cbf464d8052b38013bcbf12aa3c717423d88f0047a4d890536a506f68883974fc4133fdad5ece88461a512d781a9c0ad8c8df9f33846df79fdbd545f1a4624e64a40fe23b92f1a752163c07313f31f27c959427b963673ad21e55ac0f9cbe98798fcfd475bbaf640e309146b5f320072b37aaaf9e1b21aa6515626543c9387f096ca44af8b01a6baf375ababf6ccb32677ccb6598d82dece61ee71122f0aab6e1f483c5befa6f6b431a764699ef3b223f2badef589f32fb3a596196793e74fe58ce39d953582ce2de79ce3db7f7524bec28a15a032c733d9aefc45bc9c689c9071d1bda5af85bedb09f4d335b7e74cbc8eeefd0f7be43fcd75daa62f3c01e9ca44d2cbdacb4dcc3e55c2bfff82bf513fc174f1071ba02f45b7a4c38752e508ca1305073dae54ab3565229d95d7ceb1b74e0d309b1a3abae2928fc7f2564898bdaff5b5c73a98a7626ec834e591fbf02d0968335bb6a34efb71113355ef010c5d965e84d6f921c5748b94c23eddfbbd9d7305a3dbd9a44652f3ca727079cb7a2868f0c9759456505629832238038c850366907b69ac06015cdc12fafa7d9c74a56158ff9f720a106d2d546b06da63e84e715d46f87c461e44e72d5bef59141a5ac259d177b231ba886d88eddad682682b619df9cccb312328edce8b4f345321d09a72878a418d03eb7de98898e20459ae5b5f0ff978101dc995f4167495b8cf8eab0a78078ead81cb03db921bbe919ec1214c5996c82113c64ff5b28d2b38e73732e78fb2c6959fdabefc497cf1fa5b6ace1b88461b7df9f2bca398f0e6b79fab1c679ffb5358a6322522eb642eeafa51db36543285995f7984cc553fa9695b0c7afd9e815222108ff10a2abc2788e0666a30a34169e93fccb1fb162304238a2f32d50433bd6d9df40f63f7f817f20a6a29ab35cc2dd2d67cd931c968bd3c299724c71382e98e29446d67d586213d112f73c3eb77d4fded9496c9f491e06f2f2d3aec9c821e5af8a8a097eef61baf4ea510029ad796e936cee8829891db0c5f27f0cdb049d3a411f41b0617975c7691f58d13560a3c9c1b80634e4d2e594e1d414a941ca1aa8f2a9000e828d899be8ad123b12556454c29c3f035a245e9e1f035c5a2c5a0e83c954e5b5cf505e0ac374b4096442aa4828190fddeab9f82ffff72fe2c0bd23a08af04077bcc6338c02e0e38ea7f70567c7960beb86a2728a3950043f81b5b9af941352826ffc6a2bdb311c9576f2e24513b64089b19caf40ca2f81be5a2f17474aca557a2e5ab2c366053ec29cb06ea5da0d7c1f8e03fa6e2d1d11e749e4baa776a0be7b8bb2bd0349056150c9b72f79c4027b2767c927df1dd22224eaa6e5e0c0db0c185f099a8f34fa8a1cd504efc4c8d5884cefe4de39c5501a5b0d893bfcbede6aacee2bd6a0fcc27564712ebd64afded0b6e7f7d2d890347d1fedc29eea636d1af5987746b684871b5b981d56fae0084e11cc20fceee079d1ee5b5fbb9d2849bed56b0f1f975537d64dbce8593fb53e92e984fabff663bf70f28ea1d15e0ad21c11ec4be41fedff61e8f259e8e5633e0071772f344ac5a5438e30c142715e4daed2be70488dcd205e629d87fe14251068d631c7b52f1af36b315315c8e5d7e791aba2211fcbd36dbfdf0f57cd27a9180cefa4f15a59b5175adee76939c2354433853c5c55b95d9daf96d77edd963f5edf04224b88296b2fdc737a79939f9ab06dce69a5c34b0d68872ec9da5dba9d55fc82626052b012e0b05dbbb3dc89256abd2b4c7184924290de87da7f9d62b60c63972fe9ca7aef0592f63e7ac4830ead1b64b6897ddff4758c175942ea06e7e2523dd7b8117968ecdcccaa896e5d6ab947fcc49f3b6fd99387e415e04d32bd0f1ae6a46df5a4e03dc0d7c920908848102c86fd57475a53a0d8ff2ea594b2881c9ad2546c6a56b77be9166b8fdf8183535dd458f58aa3e4d94a61768a0b18004f0e96536751153ae2fbf9ce7fe61d8aea68bcc9d12e8bcb7fc2c3c0e7d7860cbb7c78bac6600837827421b0843320aebe17b780e71f49b4a9beadf8284f2b3f25068cff62b7142240d91f8c156f33a94efbabb2f0da775e33b5c81b942cf6d83c00af2287533e2de810a0f9e3bf7163ca606f7c751a6cc073ad911ffaed8c6ef95240852ddee638753a817eb2bddd897f26b59701e71dcda5abbe9c434cf1dcad0acc49ba06ca5599b0eb13c6a1067372eabc9900066358e75f2406249a9ff791291da7d34f941994b3781b7f34bd0574abc2bbfd5d4e3e665e78ba279c505649aa6db26f31ac202dfe9662fea0a608cc22ff15f87f5bde481867b53d77c84dfb9783755c9598412b4b0427619e315dd5fb93c9c16e7ce7b37287faef7ea49d9ec9ef8619a774120856f4c417bd712f8e60f8c7110f7e7c9d9261d435481e3e89558cb847349040a80fbe62573fe9e9b4d5cb98a017fe8babe28fc359d5192c232bf275dd3d502e45034bb333196ca367677f19a2f21136d0be057d9882715c78252640e442c4d05ebe3819808856d98db6d80a347f9eb42d4f78e096796209613def7eb83dcea45cb27135f3abd1b5f9c0a62ac9b1cfa76a9f54d0db7aa2fdcb21fa9688c3a4935bf1fde0ddd0ebbfae4c59a88bb69938f34198d9c593a59a9336c584725a6f73aad6e5d46b857af0afbffad19b1e2fcc49a4d62c42697c960ebbd3b9a74fd2c5a9fb9cf57507d7b16b0af2e501a4191a5606e7c4df0129f3a721656d72caa6336c060f9b6aa8396795889a4ec980836e584805ded91857e9794aa56f57e43faddcac4e270d5164b346e0f246925c28be7882bf64b441589c049bfa690e8f9e05982eeed3d960adbbfa3a457a5cf24d81073757f4a702fca9089fdee7e1fc4a0ef2074c44f3df566fb9a89d6ec95440ca630867a8e6c73eb0bfc3d2b09551034832e97078374e96e3cb91f34abb3e2ce6a5621509736af83b86365b1886f0f8e13689119c9241bfd68af2360cf97dfab389585527029da3674ecded7394ab55659b412026afb0c16938f49a837fa58d6f81b80736b241e254ef80b1c0efb03e274f08bb0d2d42a16fd82499fc0e9540d93690044994d56e9a2cfc3ebeda98d69de824d9d935862aab0d13a077ab46b759cf4849406b11433406b3039470f6e8de3cf5dc1f7655df002ed9dbc71005ac0d1292e315a9e8997e570e10dd47f745cce30b230aa1d2d36ed1b2bf4605894d73bb04a4d8db6e37fef01e9d32d4a3709795920a5edb27b861213daa68bcf3df8df9cd7bdce24a3e886a2838f9d6a5dc76a54883f87a36264a1edca279d4f94ad83c63035b453abd9b160611d6278fba1cbd528a0691ccdd1d7fcc8704b4404d39eb57e58c0b16dcf1235a80c78e7f0c64848efc2ac3c78d7edba2d1167ad10cdeeddd6225150f05660a284ddf5051c5309e63a3de244fcbc2e7333ce809b2d7249565ea46aa6445ec7861229c495f62396c8f2ccf1924b1f5c424e0ff5fbb8f4cad2efe97c470f71b93c9f18da6c15ca3b204042f6f329b248a7f6e7739d7126d4e68ef25e4195d855f065c6f3fe661cd7801ae40e45c077fd2d7be71ed8e6926d526ec76c5597221e9fbbd3143c9cea524a7e7fd4fcda97af7b7f33a76fe1c7c9c94d28231ac7366847b29d0968b5cf9b05b21a14b5a089c4dfacad671f1a16bf478064d1db87f8f77d8663706534adf6952bace871aa92c87485e2c4602fbafdbfc2b10b634350d49dbdde6f40677c5ee22610b958c0fa2630e9977533fddaabbc9eb4d38ce53d31bceaeb8b59f4e7e80a06c4a3495da840648a017f7886f9b8a2408c509c1193c1f0f9eed1ab357ece05a7af193a253fb01cd0b858865771cc979d52ce428e911500954c525400b0e3f09df912607f125a89c44e0a69ab0d8ce0949cc5197ab4de52856351796cb73b1bff5e7976a55d0081d61aff8e18303bab17507d9c248c34b3453d1a37e585319221b93060e70559715ce12d7f626a7ff28a22c0a28c72e168c41c93ec6cd3e3af1fd1aab354f1dcf3dc4dbf0ca7e918f8f7e131885e7bfb56c2bcaa9b3753633562291730d1d84931d2e81892d2b6c106f79ea3be9bf1151bf8e095adf886c2f9aa86c19a086defb6d7cb1e1cef76f9c96164b8acc28110c56d67e358ebc5d691c0189a8e59ae6cd80e2ec0abc48457bde438df01aef1999f6d3571c99d2cf1a9ae31932d9d74d71d2f92c2b67cd8ca10a09ba1310158c3ae9d15bc1ef55452a11fe5c9dd228357aa22acf2cb722d6755bcfa867de86c54e533ae1e832dcfc9f76e7d4c7c8ea19025381ccd4fa015c6bc93d29e48e8abb50b722c8cbf1a00ae86304b325292c775537fababacb3e1cd51c6bbd75fd183276622938b6645fc4bec22bd0bea4442152e9ce4c4cdd4b116d970920f2fcb7205da3d50fe7eeb7ddbb7e7c7c25c6a067c9c36b6058cca3862bccb55734b0f9af334759637da3959afe3439a5878a17a2d6f7bd0f449a2fe19a34ad4f347bae270c5ab571af266ad75a3fbc7e7fdb5ff1615baf2e82a4e3d93feb89d0dc450ab43ffb4aa40e8ff0bf75ea8871cd9ce23217e2558cecd0b029804ec009a7ee9aff25b6a805559d139a0ed6b1ce2b6b211d34608e2990c917830cc2b83325b9288c833c289c77a97567c2fae54a3089843502c357164f82ca8929b898421701da98df9ad3b602038a21594a9ef2fa9484ed4c5a2ec956bf654ba0a2d4a6f6add0159d573ae7998a5773b01ee07004a138e48179b0b37cb7d64458278bc770791e02d66c7eb5d198761d0cf6212b2238ccabfa7058327d860295946014f97add11ca69b087c7c23d07455b4ffef730b2a962961c750a4fb1c93e4d92ef5f3467b2bdfad1d28a7eb4d0af732fb0c757e5facc42819191393b3b60ae26cfad0a052fa770189d4ee6a12e6cc1a6c147aefce4880484c4a6ad99d869ec0ac1368fbcd80f8bf2e597bfa1d9da41642cbc1e3de4f003184710e753fcdc12a33e59b4d7aa0f651d918162722607975ce2940df1fffb931eb48a4a13da19607d5e9f47c5c935e5a7d5bd80b29121c1fccc240f9ab7b8427bc3d37aef04ad852c8afcb4e1d30088be93701b11ee6a01b599c56b9ecacb989355382acdb68d9c6c69556805b9a2d10e95aeef97a98939ec1ccc8cb1a63d34f411b65822d0eef3c88a2ecc48cb3684f0289587b6a8a56160f80c337cf8fa97b555be3fddacfcdf8c62584ccaef6969219cd8a4e209e9b26eaa495952da9800d43ed747a66cbdf3242c552088d99a780adc29a139ec2f12f8d799cee4751fdab5d1a810388c9286b92a61c0f01f8240e5642d0fa456f2734bd5c3434cbb0117497947e323795c33ea1f2af0a13803ae86880aeaed9b09a07120be42e4b14a478e1fb5a54211d6270f8605fe5cb556be16804bda4b49705a624a9678d7594579ed6575059028f974d93d4af00f00ff1408db7786c502caf88604036c9e592110e15bac874a1f1b0707c9e2f7bc65908bc1b54a22b31b14a185327a8682f10108a1b99e45b3bfa9a7d7bcd57ca81d68e1daad5fc06788fa919c508de106a9dc6b42019a53fda0b7ba73a6f87ffc997158562d460e278de0eb783cbf4b20654431cad90bad34325e30d2dea2bf137b03437809517b0a4c6fb467b1a4c541ec1eb7c0b7d03a20dcef498634927330b3cc762badd7f73086c70232cb3d1b2ba8832af4e3a66dddb0c1db01827f3278b5a523d03d53780cd837218295c1d50a7b6213a88b591078d53fe57a59d7baf86ad131f890c1fa80272b9a6eaab0c422b427b43dcd1e5bdabed3f08789900707b755729fdf2b2bdfd10b41e58368b975d079e9d4e8d28a6e91cee3e62f1623771dda261ee4a1786ec3f460bf2dda95a3e866853e7ad2f805ed7f94695d6e7dfaff9a276af31b9aa11bc7a52599846496c19408f7194e43f519fd18cc57510fe584d0bbb3ca11986280956954deaaf565d51d07c3ef4be3d59f6fbebcce96ba60d8f4fd3246d433f84c16616e2f221d49a8c5e75f93e28b02edfcea47162aa106876b77aacbb2af74cea1f4fb19c6ce638259085159733e05154486df019d8285bd13c2a0360093b2c5c18544b4201be3f78e400701e6b79c39c745be39f5e3b7e55ea234c5c49bd316e5719fe5eecbe06f8fc09123741eae530764532535ec4416972f033e3800d6402cf7e357f60edc51a96abe08f684350d57adfcd48801386ac2e1eb32b9a183dc4445324bba97970b3108d6781a3512e63edf5c98270da9a740073196a5455890850c32c618b2357a81734698240dfffd49fb579bfd4886407d834a471d8ded09dea17ae2ef96630cde231170f4a821ef7a2c0f52d0e622ce0bd699a140c1768f7d53550911ae86a24aafaef071f4057329f7a92b973570f0a749f7e043f66c4320d72269af6f706df302cfde1f1240a79c0e79743aa281e6d1b281c82672ffed89220b48ec331b197983186def7c0792becd75634c34555f23bb4f553e049433fed38aaada8c1363734d986170989f3e9c0e1aec4bbd027faa58350c36e76880120243cffade4592de39ee3d0eca1876780e4e967f5d683f29ba7df7e327456ae781a7cd768ae2df3d2021a666f712def6d1406ebc660ee8b1250d2fa4b6a85249544f7165fb98f6a4eb2e824ab1d78b788e2a46b0c341b43e06d388776c4e2ff9a18e08e07ac308637e08524cce6aaa92fba792ce2e43f6482d5bc49fd58b882870c799d31d94d354cf8650d516fbd4e80f00ee509396d4498a9180593560b69ee02028157e3fcdf8b69259b6624912385b81f88fc8ba7ecf609c40536969f1c96e88b6c57ad21ecf4eeeb5c161dc7226c7c0f5767d17b754e3d9691c821f8026eb40d84fe290b9b65611a74fb51a30b7ec11f50e6ec89e9d1af61041d6d8422a48904f46201b13d8d1322f2added5af41a0b7aeb2651253f7dd8378dae10b064d9f3bc34f6710752d5e3e2e27343205edccfe28208db90faacbd67d9a9e132d60c2a5db24ca5b86516cfb714cded987200af3cdfa082cdf0276642142a8f5b934424d68884b5c8a2def38db285172adb6dce94222b55abcfb10f5ae4194f50aeba4bec212d371d90d9df3185dcc6d1a0dc4d3660dc663fc9ab9830226dd3ce8ad60e8860577e81d22968c12fcbd3a426597e513d1eb336e9f685b9bcc0c8224c4b1bd1b3d4af585158c42e8f8c62dd822bdaa91c38840cbd120b98cf3d4d5ca97e1f18146b05a3a9d445ebb0527d2635354d7dfcf36481099299ab422b30b321869141e11bc8e812d204b679a64b31a3d07e27d82ff4d2e8ea033b42bbcb4cd7589edfd3dbd07d58d575c3af81c9bb0861ae0fdbc6eca2e98bd6e2ff2a4c27f0d8c8f170ad8defcc9aa5e620c3411df94fe4247605a3d4e4267061c03a3708ff3fff757a1a6258b7e7587fc4333b62d49f8c382a7b47ef76accfbfce297984f4428b0c869069f4dad491276d5388e35df6017ce894a860366bc0c3198f8a2f77aba86b32e2685e0d33d3fa6cbbbec72a7c972d364aa2c81502d473f1de4b7e8e6da83186133535bae1fc5c9c1be22a76dc1a7bd85b4f89c33cff5de9eef40c4b022163b8a3b3eec74bc7d1c09878fac333780e58bdcc243b7c274ac16ae983b5ab9f43784e1b2753834f941debfa368a425eafd7d794f647d8d75adb79e03586e23840f93effa290312103f6637beae7783f69ceaa97a864d9bb8e6ed9060f24431bec9a66eafa15bf7682ce2aa0d2b48b24d48075561ae3c87f8bd66207a9f7d4663001ab7eaffee154908889b13daec76876a699bdede38947ec1b9d56c4019e2a9ed07e29907907ac9b3dbb67a39576dd2748e2f5dfa40cbc02a0faae23eb096b96087a10f6d92d01817ef1a4bc73fc2b423a5e4079c92a5843aad9bd092b84055e64187d08df3d529a7a45a52f3233e7402229de0ec3664719ad8872d82b5bfeec4cb9d0e59facc859f549f4433ebb0ad7a55ba49c742c821534914956cb19945020d391f29ca4cc54d6102680da34382b1d32a6b461cf78a1909de25e833e09594e480d9eb0702b82c8c2a6a968da45b6be968c3cb70694a21f7261fab00b01def84eac86f212a165cc39663f6bae42a74c122cf4d538a68792978c8f191b82714d42a763e4e44343aeca4f48b057fa2c9d3b857d7c14302b476b986a01e85194d4f0fc5f9e437fae97925fa59bce8aeaa2b5d8c77063c8f5c72854879394c20a6e804cc09678061cd7afda4e6c88cc6f5c78767426320c774db4654b775e28721eb4e961e8d7c348c2d246156cb5cf21da8abc5cb0177a303eefd6c33312320507eea8a519c403fabf6c5e603d301f91fa476387a432532ca5bc459d920b970274e0acd671940fce7ba38c1cb009b659b1e34572f3784f67ffaa0f3415c5f63f605fc06b6d72407b2ec187c6372beb51dd5555faac3205ffda2ae26cff7b8fdf9995fa479ca9527e7c4dbb7ac8264346ab6c7d29d59131971b427a012ff22ced08e8eeb5dba43c67858cf0c30ba99aa228382c90c5a89f4849046d867a36167bd1404beed1e231096926678f5cf76be0e64abe75d1536c896609b3097f1857afa653e4a012c36e6d161db0b06ccf187576fb29dc0f5fab96c4ea8c78654726ec3d822b62b4d0cbdfc5977171fa44a88167e4579807c224921baa68b24dbe79e8a9f22eb846812ec57955ea9cbd075f903dac1d7dfc25e373434da9c77dba0072d094af64734f88d3ced802c3f6c1fb8e5fa98578ab4ae938ba73e4e17c523e85832d9e438f98c0c9da553163c84876aca8f86dcc1b2d8feec3434fc826ecf04ca2593e06ba4b734f708727c290068d620adb088b5439ef41bc810f0a0cb6b4d7496d1fc04047934d767cfe734db51682a57a4e192644bebd53be4793292d8b5caeb3a8734881ff26dd9d71eb038e4bfcecf2972ec0e04b58defe5e03ef08d60328832828e234913abb1193ab4a72e4dccdaac272e3342313fcee038ad9f250edd36daca24112deb2a809e1f34f95ea5fe49f1f4735aaf61f34db1f82e405806342d412d54907d93fed1615648aa081e6768e00a1489ecbaed605d43dd766da093e56b152a1f7934163bc9764e9b53c045569bf86502bb59e1bd622b8200f1c03df85321644229c04c66962448834b70073021a1a477c29b89fed57fbea7d8d4676cbb7bcce5da8c5f96a436417c8ec612f04269d05749f2513b8f599f21d4bf58cba4fed0b30644579688fb94dc5d31e8f47ca75732257144efd18717182b4b08e084be6beb97fdf670778d8e9e4d8a26005faaaa55f784cba7560848cc8698299e0cfc67632561b0f4c401d10e632d81417c112edb6f6fad341b521638cd25e74c1709e2d1fb953cd5b942fa511d0ea0c6b37866b7fa853d89f9efc9c1d71a3f057409081db31af2446fab3c1b6d31e65f5dd5d3f7d569f2ca2c73346a2ff2c6c00f2f60ac575156751c94ca5b26d198dae5a4a1e72436ecc10c517546f16a0702d7b1168672c139f4e03f79d26964061b9a7157a7da291d8e8e89ca558326c1c8c779455b2e24c6f7d3c167fe9a9c704103d478758cba9a64befeb11b786a18ebdd36df741fc519bde283935c9788b99485d54bb4232fb5649357ab53044f7239248b1682aa6aa7a2a255560f5bed946df2b3d2467e26b728135f5e676ba04e1fd7cb6316dabcc49523395c687f8fe1f4369f51822fe27593040292dce855b4fc158f4e9f8b9e203718b98f4079f1fc153247d9c6aa680b47fcdfd2dd60016df6ed822700794d22442915e4fbdd731555d20163499d2472a0d3b247abe45bb7848765de0e8d80d166b30855dfd010fa0321184821a8481b91983743d49189ac383815f1f3fc4498bc0502b7ddce92b695df1c5a2bed31efe1fd161ea940305ba1a4e332bca17c7b83f1ab8f0c5e975871d98968371d259c6c3de579f61d7a128df098c943f16560e041c6454c381ccaba8c804cdc5ba1e7f49510f78800fc6eb9685aa1093b6ebebd2076076315c4b082d9359a281543adc19a515916bb2bd37b2876ec03aab3892b47fd4ef54b447fb3c9690e44b19e5157fdc3bc0303e2f3626b9fdc10a47c79ec6a5517b4ca28b686c4cc9271f6a665935bf4d7264376e2e70ab100520d12fd54c53a52c72487ffa7ad06854cde759a9a774407f93cfd915ca06993fd1b030d830454cc534d5b8720e35458877d9f3e3ace6905261906b11a26e60f582ca2a95e9ea911b9fc87e443d23ddbc31cc19ae521ab141f82b092f506b788116c7ab1f9f03250a077a4107c1926942133b1c07041009c1fe7d4ee2ff85af9f36dc2e1c072bee57de67ee8b2763357815960f83ac3eb07fa3cfb78217a3a8fc4e3aae7d6999ec9cbb407a703eb0250c0a9d4e6895b6be56ac9773705bc0f83b4fab0d5df4bd379ecdd8fbbeebf40517bc640eaeb689c967fd516d5c76fd0f78e87a997b780164980f9c1469aff440e26810b523f5df2ac38d4b5fa9f69d20f95a87f031d36b21eedcb8bf3eb0c1b34f78297e01ad35be084f50d4e8fe3639c403eea6dba669b7ba90737fe7eeb34f37d53103f9fcfc625f741e85ee96da607b40813e6e6a648991364382840c2a311a84bf87f6ca607bd367562016a439fa080d7d79e7642886452cc2a701166da1770df18c035a95b529bb93d5d1d67c1cfaa9de804b76fce4ea7b0d7688da852cae0023647fc7a4088e09175fa43a178008b77489f0a2b5bfa75959767aa16f30dd69b48c45a1ff733879958e82f480ef4c81b284405239708d5047f5ac63c2c6aca4e20953a86f447b172a4e99605f535f4ceb6ca456e4ba3540ab52c4dc2e9a209fb5302ba805601a6cbe24f4645e577d3d9edc50da1c20212386bc815e87f87b366e1c19cd7001232aca7fef4a854b6d3c63000cea1b8f309ad1609fa27b750a2bec248252c4a600edd454081a4d7325c8cd5b24cce8700dbf880f2cd115cdee77bd9055e6c9f0eec388aa5088163f27345e1ab0a1e17378ffab4c750c201aa371e951a1f8b696c958ecc19258600842e0c5fb647109587e1e5a105313bda9199d1e4dfe2b4502ca8e53ad5554549cac17a2e5e049b344012c8881ad5d4c1cd766975db63a3d3cf180e50a89261e48d11bf509f9537de404076631d14905a23824a2569cc95561ba413c13bf6192e52f4b697d4d2bc15391b733616977396b548d1c557ef9af3ccb00e66c8f06b9e5bcc91a867581845d6fbc3e66707b60d0da62367b80ffc2f6f7152cad7dc9aaaacc0516a2feedfd3229fd4907ae4c0daf331a2fe0049030a46e22fbeb29cf3acb6558d5fa216dba28144f994f43a0ee1b88c7804c03e4e9db9a11707d78ebe1e646fcc0e1dc22ce56c5aba6066960bde3c4074e9d3d9ae4656d68b510b292f022a3d86fc27277a63c7a406bb93c6f87d924c7452e69a12e38c60d5134c4ae0aee156e1e74c9d0598df315ee375dc9b3545daa293eb588745e7dc78d0a9dbd47f53879fcdbfd976e68d794ed142165ebb8a2842e07cc7ce84e9108503351cbc1c5050643fb2e44365cde5337154962c2610891bf5bbefd3628d5ea9063187c6898e2de2bc7104aaa7cb7154517656e264b7d88f3749c0c5cd55c8b2a2f03f4d0794dd4eb0cc98f5ff7c15906786396156d9d0e06d2d36207248112da08ecfdd1e18df72f4947e258801aec414ca7b7147260f05682dca97a12fee9a94356c1a7bd48be075fc6575306ec26f1f2d2e8924fb5c622417e88dc10c9d4b1ab12b01d4f3a508e1fcca369616e784b4af9c81bc236e59ad30dbc42f2ab0c302ccfc9927c31b446a7636c5b073e5cf133ab8923faf50dd01c2b8c1d73cd74fcbbd0c3e356a8ea780561936b55e78d70ea12ab5d5666c15eb0a10a2f65b6ec98b893a07f57fb07bd8bfb426e8ea07c41efb9db4ff4c17b54304c694a569a43187cacb93f6bc50f0108493097053caa26d2b34b0bd6c0f4f8459429b6790b11fe2c083929d1521440ff58840495d0926044f44a106f715ba34a86c340f4770eb5862f5d0fcf0a857f715caec3318ebad54905159738a8b3812d91813c4d97bb5072a9d1ca374b52c345bfc8ba71eed22bd34439d4121571074f857327c71c73ac390ecf1033f90331a7a1db019fd57c43cc02affccbdf1b772103d5ea831987a67a72c0090aedd2f72393792d31c9cefaea48a524d832a3eeda7888deab5f3a7e33b86a6b0bc6d7cce2d7a9e03561183ef35b6c730f7097c785089efffde5aba92dd9ee972601e994a93f512d0d05f064ce835a5980d9c86ece6f9d2b04f1d53216304f9454b0b3aa19d1cd78253a148811bb75fd70f6be656ea56137ceaf5f28d4a4a6b23ee7361838d75576d02f64064ca450e011eb0ebd5350a4d900490a35f9d8b41ee79edf1dc9997c843c17248e5de28a19e6a5dc1ef6bb726f5161ae28889492690e604e00ea0b1961a53086c69152ea121d9ace3a727e0407933c4571f2b4cd7d5182dc7a16fea506650de92d00d6815e8a345b9a849eb66fb7344d4642d5c49270370590c899e190522ea6c032a8a522bc4d43a749957f7f318b902bb2e33df4836c5e921a80952c6fead5ee26f6b322cf833d1886ff912201cf1f62808ace740d9a6d2a3be0568553e1f2564820aeed170c759621e5fd2137ad5b3871924274dfc9af2ca7569da30228646bdcb12000","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
