<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e310b87fdb5d577a2d30b93ac4bb30747a92719d5d856109769c934421b18dff5d5103aba9cd4601a3397f1ec5dd73a711e48063106d9d656748bbaa81fe5cbf02fec2dca1877e37edece88387c2843f46f6de7826e606eb773eb24e779f3cacf0cc5d9283a6db253d741597cfc27b06b6a4bf188b92f724346834557b2cb48c7a2e473de8bf427c4a03f564e6419828909b42c45f08338b416beb8a03ff5e24e56720537c1be778b926d7d915ebe577329d63adc9af648a8f9c65f5cd9c3d6844eda66fa94e1df6a803119c48c1ccfd25904e8f026f1afb30f6b305d3dced73de23708f16ac4547dea134ff361966d544481db448b7d933d31bf3a792afffb9cd3b94805cb45e062f6e94f0a004cb706e5a06185f827c1eee3fd002af31d5202f506a120c3ddc7ebead42dec957236d0bcc7a48383250442931843dc6155bb1798b560b171cb9b90281f6a6aa91c24f3b5789dddc7c1b826c86592e2ffdcf661374f14da3738d9fe3c333458f1cbad15d8154b459a6e79c7c66aa914b901d52ce4e5a9918f58191aec59817a03ccaf865d6d75d2f11a4238df95b84ded08e5c615e02bc05599796054b59b10b039a7baff31c44db0b7a49a8625061be1babe421f82024d0e7ff8f585267e480ebeb0614f05657958961ccdee68f54865c2afb3fb575d5492f3e1e262b9f6114aff65e27052aa4c06201d06fb3d4c2a6c18c71206368d1d14b34cea85028306a18b7e9f12d7a88cc4d6620afe2ad6f3c0e97c014948c9889b852474bd24db4fcad489bcd8b4306528ed5713b1a7964f29aa8f5f332f18be85d04bbc730c706adeaf14419f9c056aa6af019c1f2ac4cc7d6bb42e42c9e9fe41333e7c83d081208e9ee52eb2ec16034591b5054278018890020bf7f966e156189b035335a58c81c0a7b04d301d70806cb7578703fdafcc5b236c2dd5cf98f571d2cf4d077f54185042cc3d2218a314d6c029349f6db6a652bf8c3fd9ebac2e914938d42fd3ea443e9fd09717b23347c9f146797e07db2631506a3a1cc23c870d0856a9483e54813523e933f27708cca6aff95b5515ae3dcb7fc78ae69ef82d8eaca19002144d4f783fc145793af596d3bf8667b58b649a0f9b49b05786977f10b04a27ae9a54d9af0e9c8d0f94c3bed7a43addc1fc60002d84fa3c60ece779b337c6f0f289736beb0b6acfcdd7ca513a8c9c851188afd7d3f46ac82505051eb0d1e0134386af79671e87a4a4cbe3057b21b21f5762e831020649d8eec676592a9bc4c26096160db8453c649007da22afe54acf5dbe27114635254c7a432329651769985db1f31a02b4f5d1505842117328f2a1821633848632deeea1cdec40c4c35fe7e3a7c56789dab0e3f3ca68d237236469969fb6fe33b478a6996f47debb934ddd3eafe726bfb97d776499f80f00f241e15056d33cc80ecca7bbef144b557c9902b31ca4584cf293d103546cc872b502f3d984588267f408f780f21db1e7f0abb95e5131501118307b8a1cf7fa9087b1fb423bf9470a027b7eaa7145b4e7f9a8086d2a0c05b1450edb33301cdea101cd0d000f68a5c2386628aa9f8a51f523677732294ab74cd0ea0b64cfbf3a4b458f3348d188b7af1d5a539aafb482a5f5d2969376fd698c20f728438a523584ed73e11980b45ecc652de799680d7979837952330871adcd92495e17b988f17bdee011498c70fe6f24697681e03437285e867c73c1f8bd5966cc1b5d1ddd0ccbfc2dd53c0b56b2f4386100e249247cd8d053594af442a26c1e4671f187a80c074ed4a6a49a087193851a9f1edc4f845e3b8096ef54d653551856ae355ed41807080cc19ffdada34e9354dfbb5012fd0aa796fd5642b54957d79b5efa07f1d12fd8303e48e70d28ab1ba80f507c34421b3b0586c34ed33f09be9489d3693ea766a105aa3e76701a6c59140574ba31214218fb7ddf9ba524917212b4dcbd5f939325979816d78b4d55e5f18fb1524fb03ce55b9ac398fa59a53d904dd8b5ac0aec3cd6a8ad171beeee8c315fcf29f59c385d63d164a9b6403bae9f3a78c11ba74fcce48ab9362773289b4c012f6b87a1a543b10f4358e93a39c0d27a98967a9829b31a8ea451cae5bf49027a13cb46674d5afd0e1ea59cc4a3273e9d7979f73f60bd529274cec30c7f74167aeaffbf21603b34e2c819666904515971c6e2732b2d07e49ef311b629a824013194bc581d10bae7db9799b0c30909a5520c09e04163e38559bcf8629a49821e7a94adcc437e5aad406c1a65e14b03c6ec94e58f8314009e2715b681fc8964dcc98a01673231d343e532d371735512764dbfdc9b1aea0edbb54c4f533b255cf752370469572d33d459a0aa422b6dd40a92e2c919b8ac45b974afa275f6b77746acad987d7f1b4428746707473c1969c0259dc72746e308942db4fe229b0655021a7a3510147fa0508ff470f91687b6b8932dbf25fb8f8714befe5d0ba587b2b422ceb49525d0220043308bb9344f55855d4e8f2599919a1fcccd343c3b9f0136d014188fb5770066f9f875cfd9a6e71dc39008a91a9d20cadbbcc496afe6239375a8fe6a98be72ca532e3234dbdb7fd79c48e62925ed967c3e2795c1776d884128382c54a0e273a65c5598d73d3b4865eb66d64a61c859c7096177abe17f3b7945da46f625755328ae16f17cfa252499cae8d0a154f754abd134bc2167227e7ed62a188ba9e9e3cab79fb1f28feecdc5e75e3195012abf1e6f8a6240d6eb76a8fabe5c803c0d479b01e3fb788e1bd4c1940159477644c7481060b12f72555d08c2be33dcf56102546b1b65854e288a97ddc8391312870b90360e5038f3f1a458f2af42bb77ab61e9b08cab2170f5d5fc7e014f760e04814b0d4c097f03abec43ab00c25621955cb396e1d57c03fac914bef5c088938bd5e3daa9f799bab7ce5037976515eb82f6d341acd877db78efd13d5ed38c65bf96ee407971dc02646c88b8cd60c86a85747b8d9a754b85d870fe76ae078c1597e37a46d93cdca447d8c3b2b3e3956897633c5abbb1334ea6acd6ca6b427295636ba1d35078f288a660db5e7049f7eab4d33baaeeb14db36d76619bb6eb18bc7e37e1809f95397afd52dc49470e960860b49432004e4292bb9da99717583510d874fa039c4d9d2e28611aa4bdf3627d73b60d21bfa18cb0f30afedb8945c699e940d5c16a2ca136fb381bf850ef661da6f09a87f1ac9925ca2df128f4ba9f19c2174bd040512b21c4eaca671c8ae489dfc22ec3af4daf9444d00e34128023792c7bd3f012d91657ca144f0302c7767e552adedf4b4c465f8df1dae9c2d0046e06470c72f4a10726c88f430d90286425d0aaebd1e097df5f8f223b0c16e6de511570d69569b634e3cfb3496f033869b3b85d7125f83d3b67c0313f1ad57158850a16deff1ae7fa49ca736c4a07c9a149afb321931d8de6210162dbc67610033766c1b56fedc0683259df5c0924b174580d09d8e8a03b5a98796b0507ee8dfe3db2e24483158c60d0cb78087b6b55d8c628bf28c336810f5d776f15e10ce5e1807faadda1d4ab5ce7e4f4d468604d9ccff8b1b4f560f2e6a5a7d18f79c263f9ba696010a34799b6c53cd1ff8b9b5af20394a00b509c34769b04fefc42af71ec9f4ce06f32b54bcfc49e317ebd02d534bd690958c2cbd6c136e7eef78f6e95375b7c6a012e0ad301816a039d9e79bdf95d4b041280f1b7862a98418bfc8d6342b1a07f0b70f3c8bc3bc755a80f914746e0a0ce105f6281bb552d7f2e5f77a1ce6f87f38a75b7d8d657d6cecd03e4c5e1e02c712e58277a59820d96faca42abdc8f143433cc717f8339eb01735aea3696b79bb205a45ad0349d29b60378bd2e4f5822f9bf023436f1cd9edcc2c1a17b50c75a437be3eb2ad0f6360ac54f36a92fc43f79fd9da239a9fec146c45bbf724974b6b0f759e53bfe0b3e0e802fc676fc3c0a88a36f413d2846f48a0125c29ff1f204e2128eb334c1f4b0e50bb86f8b8843b7cc4b56d154148bd25d9c93dee9057ad67e934af27def0a6fb427bc3454810eb7d3471f103324ef7369216cada9a81ef2192a07c326ffb839643577a1aa6a4a8e0ab42e0c1de34564de80b1426e6e8b1d2eb1ebb1afd2c16d90c4b34ae22f61e6998b4542a0d421b11e4d29cd7013fc103c998b21bc0b0fc92a28c09478ba0f7f86bbbbb14aecff623dceb2ae708d5a3f7e923656ad48603255484222222e7c36e2b8854fa35212c478584882997c3aad752ca0479ee1f826fa8e4ab49bce761dcad39104bef04451ea21d07feb8f396697a632780195a77f0c857931b6608ec435ddce65ac75f7d2efc173ce32c299f80c88ff3713a9fb6ee90ce4ebdf8d44f3ab290d9beb7e8515648bff7e42803c57eb71443f9d26c2206b2fafa9385eae202b35bb839fbc41b8feaf40881b6c76ba1093868c79ff7ab5274a0b6d464fde07949260dda11e53139bb28b50564584075e0d3f74019ff1e0a06444a78b78c459c320563380611a58272e6b077aea9230c1c1555102cb7ac610f39410421c7b29e7863515363603486d88c9b2ff1ee2ccf01daf874dcd53bac8f9225dbe78e33ff8e1bb1e75ea33481a5d2a2c306b353bc06beeb1403f32ac3a6fa9d222f146b9ce76ebb19ed89616474ea273480acda8ede38053caf250871f565b6c5cd5ce29ef1c5503bda0e1eba7af967b17b118032266ed381ec7bb2d215ab93d25957fa5fd1501f15b762687c6d2643b94659a8b2ec4d6acb00f434a2656debf8336a3aef40152cf0b65d0c9f545af6334aff7dc5ac7ea565d62d320d9d5557ec187e0fccd1bba473486d8b69e415e85ff009b91007c285d042cb5f9eb0c64b7f32f9482bf88f69a20a363a186a657947214f5ac7003e748c6c242e836017d952239c167540ff6d66541c9c3d5f4535f27c3c35fca138636586ae623d208ef11de63dec5e1b752c97aa6fbf36561f2cc7eaa89a18d5edfd3a3167b41c4b8776c1e029ec15b2f4a2468c00e0c504d5c43b70674c2acc3a99ff1a790e38b89f29b496bf85b5c020deaf8cff8c3535d1ac598593d684abfb4cce52d912715a25ab42459747fd1f94582024f0377406efd23773ea9337d28d284d98a49635fa5c862e87e71dfa04e144d2d02e28d6b98ab2e80c25e8299c8732246ed7a67b93b1c8b4732dc4d54893733a2f253bdb8dcc8f5ef3e42b1d70e9f09e86d415db5644952c57b7d57602beae7e1bd217e7eaaae415ea4d92300094cf894279dc028c6af9d5b8b6c38afd7cc4431d5310b717357ef33305014b61a634ded5e6f60efdcbbef1026e362cc2d87361ea59d15c7f15f5c9f0c54e562567edd27600d0b46d1d324d8ca4232f26992af5e819c6e15931c9550ee9a98905256b25b75bd115ee999c853eedc4a1d4db1de08b97a54b0701072895302e99e29ad12ecf2435f57f71507437f4123044c67728b3fb89a91b3213999a117c29e6960a0dfb230014ccbc5dca19796be65ff03a79e9ef271e0f7a61dbced73589bd5f4ad348d1ed515a9b540ecaa3da90961d62f894fd141188582c03a6f900be85a607a9ef77eb260db6575e6e8b3d32bc84d07c71934ad8101f5c38ac768ec17d4b24787a4053adff56f0f94aa6c91cf0e3140f7a9ffd559294f390d844b2e9bd2666709db671280cd661283b2f527554184eaf2ba2c3788ce63813e3552b809a1ce7730af3af0ed5c70f82d686b5fc4a57684b2b78631673e7c70795bf90e4833ad9ffb1510aa9139538f288054f487364d4690c88903a8b92898c2ce1f194c564718c7746edae533dce66028c35b6d48152d3a83482da391a473b0e43d277c195c992f96c39825299010e61f9ef3d776e2370eb748f7466bc20faf6e1a217bdefdbbccaf4ab6a426f679811703334009403b1d30842174f8edf221c84cacb471bf0665acf41a566596b4844bd9e9093126f52b9fcb3acfbf7c9075279d3a99fb2a6e617baed2b1f05f1eea757b5e6bd67960ed55046f997781597168b4fc3e0c4b50519e1f065ebeca471b233e8021e1d5d96f9297a20bf576f12361d45f5c484ba9dc0566886789fa9ca8162064f9bcdd867e72a634a366d33d11b6e9742b71e435ca88ed296059c3d22787de5befe507209123e2c67c3482f8e1b7e3462e94a4b018beb83d0e2b181c92e55e0dbb7432b42fe120720bdf33655d1502ccb9c9d46b3d50b7670e0cc498a08a901632b88e31ee2ed8d09be5b55ff50c879c017193a4ad81015a2e8880a37fe6e4862c83faa8a2f4f2b3843861abcad3554e991e0436bd14de14267883f18be43f887699bb024cb8b8f4118ccfcbbdd93a0e10e0aeff6f9515a82c98c7797d08d9af25b7dc2dfdaab59352801ed22547089c5362745b3e7b3a761f1f8b759a53d2ddb48552c474a341d35c7dc465d151cb53cf27567c72b18a0e9dc9f975d05ee8440c5d22a096ff9a1836e1c23d4ab014e10b06c970269ae8623cc640ac2ce6e7ee98da9b2a23ebf02243b96cb34fa867070b93ede925dbeb66a71d47b690d3e9d820432653467f4ffc1f3b71a725b7d6e474387327986a1d449d3e24d8947adb60385b509c8bc8be00e016e69a2ac7eb1feddfb269db8c966968ecdb8b65e9ac025c2498af9420214aaf03b085b9226f3477ea37d47b0addf8ea169e27634cff1a276ee1b5b0a9713ee1af5c91121f8a853fe14894be5b70e011c7703a2d2852faf6e6ef3c9f5adc17487d7e42a516214e5d75fb07375818fcb972b14439a7cca108626ce2f53f2b0b2c6a1e7bf0f7db6c31337bd5c3aa2776b71b1685d973ed8387191da4bf8d5982d5646cd81c523bcd1cdc469fd3a1d5219720e2641d1fe2aca2885157314a045eda6df79887f8f4dda80e8634b6dcfb3affb3cd63b22a4a34e21e19f28693b4298a02aa740003d2bd4b067467306fb9bf4c32f07fa1e6659cc7bc26f6a6eeedefed204bdbcb38eeafb1bc3a585227b3ea92fc1f4ff9d63b64d1fcee7ee52e8863c2aeb3675b5f69d94b516abed9189fae03739a45940b6930234dc54bf3eb07b0b3dda1ac8e02a4839d5e3ee71e78273708c56b19f88b141e0d0c59e7657a865886cda8ace9fb0e4b4af784429d786b0a9f7991eedd2a1abaab360030c4d8083f7f52bb80350702572e33ca0a5dbdc1edef39dfa14e5b81ff0a6dd6141f130438b80d8e6e1a553a79fa180ea6faba6f3c8fbf567b7dad1dd7606b14b797db0ba4c5767065d9958898936d60fb3662c4d77a52ead36bd2f498c6ba247f2b774e5d1034d353e6567c4637bb2f2a8ab65563c7335f30615952608c97c1d6c1c395b4a00309aa3bd52c38bda07589b3b226a9b2071de5355b6d3a49788f7529fca83e198701e1cc646c1455567af4b6fcba41c7adef2c7c4a05cd4479deb042820c30341e80d8f60157b0dbc3cf36c66c166a3c1fbfb8971008abb7dbad5307eedd3ddd0b9a81c3d8b0cd1dbc936720d3cfe8854ae6b0af6d4b05b448183c2769ca89766f2c7bbaaf963434a3676152f46c3e0f229d284f42106ead674a94d3508c1ddfdad7f9673c1dc63784df39f7b962dd7ea47006b3a291d228263d1b23c0dd33cc63bcc26aa70c9265d98a500868271b34f8dddad1f45c65b29a5f9a09ad5133c955716c34dd6db68b5416b86907b0b4c56c17860a1bae6be7b5e23a8e6206fcb350fa8a09c378ea27656d255aa7e3a695fe1810fe53bfc96fead205b3d4f62e7ff7f2b07906abd0a64ac1cd8ea4e961c7646c24b9c39530dd9ec316ed856f5e19705154461f759381d1cd0dd009a526c5ddb06a0888251f44c5b917e095446f4a98fad7976612ecbfeb0b6873b2255b8871b4d124be4542ae327354a314233e9c9cffdd80ff3244d8aef4f83862612f7505a7ebe17df8b7a2c2dc92145480d2ab19fddcf2953c393f9edb8ab27f515d42895c8e2c3d56b204a50db08b4dbe37af4bec6c312744c49f64386d61bde250611c23406492e7acd70b219b312f0fb37f8517f50f3a52a37e1a8a0a5fd101595d0a0b6ecd191f12f2c380f228e7349b9b3b5313a3a1c6cd2f7b8ac01daf2470339c86d5fd0f5e7361367d0716ea259e5d9fc916012222c3cc2b1259b8e322ee324c95aa95d58c9d5842901e3826cca339fe193c8908bc472c5df296f82d18f2df089f3e3ce5d22bb01a6018ed8905bda310635b48b27c908cc8c9db1579f6dc59480b1fdbd68a7d851b815f47975527845812fe532045c654017edd0d537d6ea91e1b42d0d538bbd6a7f921f1f2525fa26eebc67c736a10c0bc49b75b73042ed6186c6947f4bc61676316425bfe1e060b34d41627a7378bf796b2cc4e9a490ed6e42231c2803e3f6f138f1033f4d4f6001b4bbfbf346545f1a3f3e68715794270e406228482a6997d38675084886931cba0511a1af4eb26f792e76cfcbb5a10fa02b468b584367002400f113993ff076fca277a915cfab855a29d0cf3e25dd1f062d406cb18b4ae82302cc6e3f020200ac984e9f031fa911312a90f04955a57592dbfba1aeb328d13a6900c099f9f4bb2b194b6db82b868331c978a119148cd7d68d391df931c6c6c2f8e795c5063288e25fe9a81777433a51f1f13db9356a946de59220453c3319ba0a518b09fae9ab146d7078b92600bf9b7be60059e0b0c62df6b3d464dbee5e6c6276860050ffaa1ceaedc800f9203f6d34c0e26563f03a4d330207613e6d289b639ddb93f1197edd2f50982168a96077a94d614481768dd221c5685dca49f53fb2553a4a39ffbbec820a2db96742442ecf68e18dfe480a8c333ae5a8918c6e88d57a3e068fe8cea47a7fe49d86f61b83ff11c487ea2d9a9536e27730f8771eb40e7dcc9f4a6bff56a022a232bcfe33dc2121f7dcd88a1c5afbdc9ad4010793ba6be33b2eae8f19cbade85f119d0e39c6d1bc5f1c59af14d84274b96daa9aa377cda7d140ec2806c7e75f9da14a006f2b2276437e62a031f8ef076d3ae45699875f2b4ed34e09a649a9acdc2470af703106ed241a24480a89bba6ac5f26ed5be73535a695f7a2c11c2a58cc817cdc0ecba4aba4f521f71df8f7087d98dfb9caafe3ac6a662d4cc82019ff3779c67383c1cb2bb43e64756ba6dc4293b0974f1b62cb53d4489f92e18090981e49f7b44e991d9c44d2bce26a141642ea9715a36c3fae8d15d21d29926b2c3097c99d6da5880d020f674d00674ef40760c1c3404f7dc258ae723857d18ea100aa7b32d45628d942b4a3ed372b00a9e2a8932ad287b4c6a0a5e1dca02c08b64aef29462805e8e93a3f35a175a339c5b69370c24790c479cae247a89e27f57876e127734d178cc3fc5e87af2e53cd6ba71f2e9f0859075a7c4d35bcc74106c2bae9f57ddee083d966e3e9601ab999823fef995e67a891734e236b7fc6ede1cbdaf767b4a9b27925d3e818fa5a9b982413a07d73b09f1ae043c81fa82bfb3dd37a6993c37546d01c0ca46ec623a597ac76b6eaa07224be33ad8c1e16306698fd3235fe1f9813ff9c8f39a00d392d75952d26ecf93452c1137ae7bbad471530b4bd60b4356c57f613d6fbea99679e57bec3506b8ca9ca2949f8b2e3f538ad79bb28db3722af8d6a6f1098639006affb7c9a0b9c1d43c1a492e26f760d924eb9f0ac301ef940cbda38c17c03c361d5d708bfadb92ba4a50f943f9593170965507bc77e365be5c54de79a66c4effaa6f522f40646a0a92ca8ec9d93026a2ba819cb10ff79e048e5461940b5c282867103dce85d3c01761f44de0cc8cc18f4bf4f9404a68619812413a2e250dff3ded88a0d7c9c521b908d0856c4af82250e65d649e9975421f31eb83ab7af7112218fa6a5dded708a019549ceb0e53c7907c037da0eacb3c4a83cff344e4f719cb469c27ea2b1417cdb37d3bfbd1a00c6712c4aa7bfbbf050a5b2159bf786da4d7576bdce8828e3961eae48b67ed855079fd5c2b032a91167be1e37f82b156b23f16ba901af2c1becb5de15fc69f70e99c90da45d8e1ba176675be003d13a2c95686d95673e01d6e63e8c14989266786306be5e4042e13e7f43e51bfeb6009ecfbe77394894cd889a720ec06324eda490c7262406744e90c56d86cf6bb590ae3f5829ca18c9aefdf528dce297793f1d8d5f845b1b9c311448c2271b02d7027cf3e582b1b91176ffae4f724b3c8a483a8a59f45289ff6978810ac798101ad3f5db043c27523e8706f723dead0028c8396b495eae0dd95f17f25c9d2cbcd75bbce58803b6e4317feb5c6202b1e097c443b89a80f29fc33c1ef6818448ec5ab8dd9c37dbc9db6c614896757cb71aa31fe6fb8934cc8f12dd9593de101b46e9fbceafcfcbe31c1539e38ff4a704d89c4dc1b692de8188e1fe5e72619cec91ffe8c3c323c715310442f2f479d40a3cc40eb0111a426ee59d22c008705795a31733da27d6cfccebfe4a4ededf58dbbb9d8b4c6864ac723a28098af08fef5aa5cd0170263e7508c84b693dcb9d32ad43b36d3ca1d9ab9991b60a3cc438d1d3bcf48a5e844301b70cc07e8b35969b4a442b8f1d7aae4a37c9f81ad25c71f67c7887af15f668552e80ce74ccc9076f1c9db941f48270ff601d9f54ca64caf80cff2eb6b12e730450a07bcea1070bf8a8962da9adf6518e078c31c5c44b9618e2647ee18f81fd6be96fc32c29bc61a3c8b544eb3e792f210feaf7af39e8113e3964a6deeadaa8b0c4efe1d3517ca2e1412d7460912043765ac0a38c27dba765b96b37d520be6b4b1d0eb364c2fc0a5aa520bc3e47a5b0382ac16eff012c1272dbbb48067b5a0df76b4b1107ae3b4e4c2ef52598ebe0f174da78bafa083f594f850a321ffe72240ed0000083c4bc96890490f84e7ffc5e599b8cf820f54acf706dbd29f39d65bd037cbdbba161f7073672adaf9a2bdf4d741b8e27d33e4fd80e539171bac86dd5d020efc5c5937a73401af871af17c841bc7ef5aadb0840cee90849a8a68a0a9a4e565af00006a0245cc1f676c5a2ac2dbb778d95e3e8bd24b2dd797c8225f430076481629392f18819bb6aabf45a08f928fcf25ed6929ca307f599b91eb1e1f5b3b09e94a73d73c1363982f7aef91d795d26d17bce616ce0d23ce4988e54b46bb25c410021fb02bb02a4185a5183e7b4bf9faba7c77e1ce633684d7713126dd98733ffc8c8dcb77b93d7618bc0c4209e77752184ddeae4947d4d2addec18df6650facff6d9dae58411e0a086b4e53692f20849cc9b3e2275d1b8acdc47a3b355384d3165c1455c98294760d712b3d5fce8b4aaa0358b72552db4c6bc60558eddf215a20128ee35dbbbc221e064361ccb315285cfc240c43811ab66e394e3e6aba6f2aa0952852c0adf0f447a5bb6b45aee983235cfda1a90d67030d6d70304e13875017f99e2b163ad2d630edfa6ffec59b1998a02781813c88b4985414a5f59102bec3da90a8f86aac8aea0bc27a6bd639e7f9d9af3b2498a628c5745881af3e0d7549e221e26f931af36c7d0f570fa78d90022e14a0f79f9b7fe9a8b603e3ae3da854ac897c90daed697c47955aa77d24fdecbbcaee308bc4b5e12d3f2613bbf7943ff23104664f742a68785fd238dd4054530a6fae3eb8d7da4466d88168b2de769d67958e92a8c72180ffdfcfe163e4ceec78bb6c4db98ebe4f980cf8fea692edd814841462915bed3da3abef2a54f5a79df4c8d13444b875adb9553bcb96569bbc6dd6aed688b4b25eaeca2eb34dec6e4bcf9089120b9f736c154f95741f5dc94543e2302cb71c44ac3d45e51f2e56e2046853091806a1c97df0a23a81877d87ab5a98da8e86d5d3136f4444068feda25f630867b0ddfe8ea7fd62b75dc62ff24095e2a2a44d219f26cf1de974a0e0169634d981141b06e0dee90260a21237a3be7b733de41cc57d637366d1118717e700579154199b5ac36a5d532b70817a272027def49d459105cb33f7d6dd3f193cd8281b8a9809f0b028f56163e4dab50daf1f24c541809839913c910833579ca49c5778bb286b56e7e9fffb384ee06b47e01336b7021b0f39c15d53b5e9ff7841d651269fa411c56cf8a7514906da8aa7fec7e2151457883267b4de1447dbd59dbad6c0b983e41d8e70ad060ba3adfe50691a9a952d30616f7393b080525a237a3ec647202590abed97890df1f95d51b45c4fae6bb88ee8b700e747ce16fa72fd536d3c30bdc8ac550e17f96be68162c0050c4b70eb097155694fdb511626b04716c2ecc2fba00d7768ce4d756269a1f1c048a54facc6a695255bd875a16bd338d23f2ff3840cfe7e06e09a095447504a78d82759b4d134c1092f0204df97136ce319bf4d92a079a684b0ce5a3c73df21b98b98cec82a19cb5ec369d540f6c94e11f8ca8dbbcebed81f22fc87237cbe9549f00fbff634a2d91542883cd10bb99f983f5c025f5e7e817236de5f091d912f0694b670dba5d628305826cd48875f836ae963e59d558c3ce683ee3c13e98673c2cf89106e037f444acf6efe46dd34a3ba74f83c5167cf13082e4ed69c34470ff58dea95b952b1feeb7020c211a5be3aaf88520b25dc573fc8a92a0aac850a50290ec04d579c4062492b410cede04f20e75885cc76d2c11bfc451906edf0ac5c2e43279b5bb0463e061a5fa360852e94b3506bada1e65d1b974edcd9a456bf77acaefadbf30d66026d28c9f2f9191d450809e89d2b6b9be287287701c858517f998be73eab8eb63fd5a54877f13ca0bafea69eb2351cf5525ec1fefd620c52a76bc3ecfd0e1a2f41fb73b35fde1f83e9a52ddeaa9f22d5c126c90a40c73d2b421a0af81c1066bf212993ac3c8dbd5f9a89dd27bb0c91914c8b661105a03a2157c240e0b06b389861764ca3277ad4d55a48869890ddf1738f8bd49c7336ec7e362e478ebbee1424b1a7136aaf1f043edaae030c432698552e16307e997c639aece173ba9d634deb26e365c5cf6f58f8886528138b4e402a25a69ddcd7c81045c82dd85e1e5c73e603ef617f50c751aa320084ca16ee107c80e92bb29218bd572ed270d724b1ed9bda1f90428b274a3fa9e8dd7767457ebf00680e2b6dc3b35976b1dc3d1cb457d132f9e99aa96c93e5b38a511a7232465c32e11520d3924c34fbaaf2b4e1881e191e07fc71c5a659967711e79642e31f2c815e15bca96a0caa25e0f0901c8b2a334a51a006d9280acc9c2ca2ad8a3dce6f95112c7ad0387b15dc95871303a7dbeaa69a2b1123c58e7c127b7edc51d7bd7d90fbed604d8cc6b83f99a032c18fd4e35d4169284f55019794ddca6b5a6f6a57de996f704140a019e4be1e7e7ebf0865ee033a2fd6cbf6b89d8b585bc46f92db4748e2b91356431ef5489f9f0c6622b7573df9d0bc586ae1ac88d9893ea0379dbd4385a7c195fef6fe4e58e2ca29fd9d1225dae95feb2f50b932eaa0f5e3eafe2bf5ea85517e661050d4406c0df449f62c06756d23ce4e9f9a887cacee746cac23de85eddf20e3e89d168e141db344d7c873a7c5c82113679c9da0c036d3676158b0f640aad13b1435996d87d3e9d74985d5737deb115fe52c6e90daaeae21e2df0e1e417ddff29aab59ae2c467a050b5bafda179460e745c5cbb748429ee986b0e276214408cbc5aef249e95424f9675746e1ebf3ba42960f85aed5c0665a83db8a279b9b47d0d48314d335bec6d9b1d11e41d910b2aeefd75a5be015ddcf9701fa0b18490cfc0a3a0d07e8118da83f3e6b945628ead5dd382a79abab53c3b31d41bdb297ee16d4da12762fb6f7f5ac8ae1ad3abbc8f95a28ae72673911f187a3ce21971ebb20c5e66a9844740b22fa1e846ca350ae41cbb2890788b7f8f0ce9bd190c5fbb3e7fe7f29d3ff794b489ea151f5b87f2b5aba725f5d649f90b004ec5b8c9dd9a5ac53ed17b6037d88845a777ef66703c703622201b96b00b3094eb18c513072d8070b74737be62af6a3c1cabfb43215316cdead298f1ad7dd6fda1d57b233032079bdcbc931a3b6080335cc26e680036b5daf6e07ef8f4571d822841b960cc12940d01b251e6bd805a57f89dd40f1e89b1b63b8e8f8e173a60029632edfa9a41bc7a082e0498439ce6cb670fff15bfec12da9f72e9cd5d57a22769a36cfec4e143435dde317ff727bc20483058b378a31b3a59d609edb0c999f3b5a13030774c1182e4b722e70c145892f1cc2e43ee368b99e5451a0009aa30c89b80fe129973845a171f680671a274008fe2b56b0c06683f43baa8cbccbf81f1658cb610aed9f90db8584e76ab8e05aeecf442b394c978ccd34745dce4cd9604269ce020ca6cfc0219171fbc20b2ab71068e5ffe9a8351264fc220df79efbdb6eeea41cedac82c8bd3398f07c4b2c0888bc37d4e1b27948a5d1a88cbec75f52a35400a5bccca1e2ea5d8cd7da15346673348d2b4a92693df3d1073859dcc2ae2bdb043d01afaff6b12e8d8f1bb684e343e4b644b87623b1499f32accd289d43c050cb216a9c64c7895e20ea6f4f0e912e44a16a601490092ca96170ccf5ae6c983cbd3bf2ac847c75cb23cc981f4433015aafafa95254d2ea735a75bbbc5f74a708da9a0fc957efe7f3a54dc035e1c372304ad2660c3fee06b07398b630097b036ac482dfcca72306540bea3751490c2ce67683257d5d05d994b788f4149a04677c7ef1c570afa07edd3cf00a53a1895ac16e51c108e4f95f6de71eaae15d8abaa1c9c247e1dea942195160756f36bfa7da019cc03331d03773929f8470bdb25b577654c5d41fdf0549eaa84fc28e49274807fd9477599d198b2992f250ed425544e6a630d217e4867c5b22c059e7ea7938f222af2f170512ecc45de5daa973c2b6190b1f335eaa72b65ccf7103eabaef24cae3804e05007c22097156dd704082afc2cbd56d10e4fab46597f5f396a484431d9b18453fbe41540bacf1af5e14f95aaf4ce61e326719efff856e422f1aa0b420d65c7325e0818d664bdfa2f4c6e86bcf4e213d27ada7ab69d70e576ac06475418c20f54d83085b779d4d671e4cc0ccdad46f0b4816ac7d57ab5d188ac873956e1ec4b7b64e9e73b961ec4d49fb5c0158baacbf8f19263353f64de281488fbbc73420df614e245b876448fdddb3d7a6f80dd5e70847d01d695d3b3162a8265e570f757c1b06fe1c3d0d027e30e05d777cca3f13c7cc813a3a09d82f6702dbdba967e7481cd1631b2b3f7392fa8c44d48b4a36733b88c902e2cda64bceed40f7f6447cad55ba677673a04aadee2d0b6d54fffaf6c143ff831188bc7531f5b96b3bc768b5aef7079f66fd8348f455bacfd9d7c542aaa983a1723f26bd271973320941384d931d60f8a06b36cc85238e2d5ced14f83402ba9fb25190a919a54444ebb33670addbfa6f2d2f600b016518439d8b5eaf11d788220288fcac9295c9319516a3c7787600f8e92c4820c5c7c89d4240bcf806c5f83235bde05a4f38da21ce6ba6581852584859a4b964f691acfe0b434e7af48bacccbba7abf11b07a9fb30bb43aafbc014fe0d428cf104dd2493ee32acac7ad892452e7e2b82cc8d5ac7903b581ae3833a02af9ad3dcdcb7ceb0d71de481fddad05bfe013a95ebbc1edd924d79f316e5cb2214a0c1f033e885fdfb42b1cd64c5d4cdefcb1c930985248783b4552452a13cc6fc11a80acceef7d5101308e003e233f2331534d983632c0d6a84721b540c3f216c64f8eb015a8817fff9d35895c08480bc7ba8d91b24d487dbc1af68422e8f6fd69b6807ee74cc0e8f990b7c934c15a2b57da0507d229711a4fdad57b8d262e1d7d207f988a4b1ac8da95de647b3fdc50a7c005bf1bc397adf8b55d6c3ca01df15807f640ca61fc9ea7d98cef910d3a06537ed61c5df45bb523fb2d73cc587ea17c0c933ac817c9930c696ae07681a928115a9f825ec5c99f84d725d348810774b1bfe2df70569593980aa27b2710b999564f5a4f110d653afaac3c649fcf8f6196ecf58446d9b07344e00d3e05850605a7401fd6413f2d56dddd4629f451055c782a8a79fdc8c9536efdd8720186f813b19dd082553e8f6e97c58287a900ad9134d59f6e2c7e5dae4080a4c42854f8a2b6329f360f2388f35aa1eacbff512befe6a32b75da0a28f8211d609f5c2227d9efee95ab10d98a4b9fccdc3fd6c4a497adcadafc6f7cf76d505a36e061e62b727bca7b6f483c0fd200fb3334f71452fd14ddc125f2976f8468c2cc7dbb37c5fa4436c0476b8bd8f9c2113c9f670ee8106ba85174a278e564be74156e7fbf032579f465f0df562ebe87ffbc69ded50bdc1cdcf7de59006e6b1d97d3d32f1a778fa68fb276ac7e83e56fe4c558f3646cdf7f4bb8dc14a75ac530414f8373b5dfa8a39ed09cd12e74ad23f36135fa6374c71b7091832960ff6840fc447ea5def762b03b81c89529898817db289ff8bb51fe806b14a3400286b3c04edaf1095b95ffb9fdcff4bc42ce432b3364fca7339c2a9f2788324fa6cf10c75d3e27e7caa6732e29fd0fb2464b4e806b5e978a6bb3ba03da52e5f2545f7d69c52845ffa4c178a01fc09bd7705993687598eac5f1a0ee37e2ce9acfd5726933abebcfd9f042cab8f668a3ff3e7c45dc07097e676a939302b8277fd493684e2fe052889f9e23d986a05aae954e179b25822aa139b70a8e730d3288c74f60ad2294db6c6367bd8ccf878215b1a4c193ede93af361f9e650d5ec7b2f31a24dfad3c5573f081282509ced6bfe35b8518fa69b24a95fb3c2a097d8e59fd7484523a5db77bfd74ef7806d981041a557f2d2a8f822ecbcb1f75cfe9780c074304b26de4bf55436a15babc3b7fca462cd81cd95464e8065067b699cfbb43b6b7c9dcb906f21c2f061b5a90d6c92312edbb0b02d6ff0cc6228ad305b682df9e3c8e170d2803e8758ab8243e07decbec625bc378bb63f45f965d4624706279314ca6302f3f51691461c51c68d5ff324f21c4f1ab13bb1c5362012eed20faa23ee3dfa2236c63bff8dbdb2d0b1e3507f4ec381c08d9be0b86fdf98adc4706c8ffe0104945727f70d484d672d712c868ec99cb918648f468c9359911d507265b3dd3f75c3170668e65f8ec76a8aa857a26c1f16605ea6a8032c40c4791562a38c9e286deabe4632d20c4173854854fa1c8fa9a0efa90e1229624ce8516128470ea16cb4e1d5c6c20c884ee4aa8e7670499865bde7750f1792de0036d371a0e13b853344e14c7cd8eb7cade96f0111f7efdbdb4aa02083be601d3a928022120d6dc44170bd2fbef28071e9730b14a36590e3daeab21f577118533cb7496084a25fa1d7cedbf59bdd5ea9f91de060f307e1f38e833c25fad3168c83538620d71088647555c0252d60c20a81f8ef3b457415b760001019b3702ff84d5ad6","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
