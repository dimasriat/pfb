<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"736504c3ea52fa317b5c0dd621320b3bda10f55ec21c54e7752d811c0913a23260a130de366ecfdbe33e2c7e523ba4692769dfc56c92086fa488c0d9a2606ffe26b146f091a88d37ea8947d5434ddccc0b7d71a6e7413e140fe1fa50adf3f8c855c774df24b136df0a36a25f27bf0b7cc8c18895d1e357996c9035c983644d591543d236677a82dd9eb47e31422d30cbce7978ddaffa617f134527d59cc9f14be8960c3489fe38bd647c3e6b36897403aca6823fd94ebfdf4518a54d3686db5eff69778601e79701e04149a2cd9f59f4485a45ec98bb30d5c48a1fb530ed81e27b1b5882bd469de484166360bed7770a2abcdef3cf4ae592e0607c357126b313c634c5753e4c0afad73401a7c4ef67737d27bce59b22eaee6e9eeeb92149910890a35c8a153a2ffe522b787474f9a8bc8bf9a9c569dd2101d96118a8840a45e7de6c1654ba552ddf2bc116ae263bf9444aa0121c17dbea398d8b90fc0f0758effd1e9262fefd41d5bbcafde57661104fe52461bb0bd289bec1c0b840afdc9aee6b95bf0d0240ccaaddb3d26851c888e9d18c651c58959691a55743da592d795c4e2a4872042fda60329d9116ab37b54dde587051af1538d67375cdfafee7c43b6cb65952c8c1e4c495114be5b381964a711b4b10ecca7c2781abacc3cad0f3bfbca7eca4c98f1c34050086dab4c2b93274334f5aea73c532430bb39cf56c4556c9ccd301b6122fa75d394bda266a44f29d4fe0c3dcaf98a780827758458cc75fd7b012a01c5a16fd064641c25bbd310ad6f2a87cd40a0830c11c7972f52b1f5b7e0902f945f083ef8d431b534256aef538cc884acca3e51d217ab7a54de3b81c142f5b44ffba843a3df24af6b817ef0dee3bbe1a80a9b03322b99dfe3bd6949f515b4885994e188d1dc905eb334174cfa3b033430b4422f1c1d4468c19147671fa2c1cb5b561e5243cb4fd36d763c881766610002c32025d5ef5cba59e8b52d14098f2aad559b66b67f38beee0776e86b5663cd018cfbdcac332e6497b8aef3ca210c5176ddacc6cc94585b0cadd48e89c2462f7f89bcfb73615f60da298ddb8009d8b42c419bd4d25a75f121fc712a8a5c1461dd554c7d4a198ad072b61be46e83e709780a3dd330b418d1acebe6fe1c1f96d8c746b9fb84c1ecc9eba7f0baa85b309b92729cd8cbb009a0e4596053c3925cef010a8239cbfdda217877ec34bd4d0d99f8367fb8717e442dccbf91c7cf918bf6bd9601634d17db52efe220b76f1d718575cfa5b72afe7191e1fa467556b4bf7d278970f1d766c9f20cfea47844a463c1fe85161c93787fb3268088f6c815610e4dabc93554d2945f17d95c898f86681c31aeb3bc987b7d09e58a1159ac307b52c2683a820e74db841e31afbbc8dd414e6edd4533e96f7d6d8ced3429197ebb21ea7cb1749998ec7f21d219f44f73459b584ee4716306036a86a12c0f557d333cabde1b363edf7c6fa8304758755f0d98d8966004766507b98188e57624e30a60a616f259bb7ae563dd9f5ce94c6801d7c9f04b541dd250372a3977cb5c8befb0464362ac16810256ff0b80e67b5063f1273d7c2032bd90f3f1c6f978548c71b4669bfef94ea5e25f37724b0ef982988121adf63bff52797a79fe632446c803a531cadc12d08464f2ba3e16a8a35614131251a2b10b5de11e264873631fcee0c11d15702299028a2c9d7a0bddfd72c0955276f86da82b3839106dbf9ff894117a1c9a7d6e1e0e23621a978a135d0a2bf11642d452e81385062cd0cc6d16b1a58515ed056ef4cbd052c4f84f2e82969cc1986932d0be6e6ceb661700729b34d95abde30779104cd1002f356314b572d29ba29ef3859f3e271c46e418fdcd3c3f45ecd3114951a5d734dbf9b9cb4e60b8056b693dbd964172e9536e54731d1116c0456de563dbfe6ea90c478e7bef22ca0d8c3bd58ff07124f4336c0a60d2c71e4522dc031a1ff587e47cb8435c96b8cbee6a609c1ff6afd83166d147613326489da6dc444972e48e3a48315bebb85e40de4489936c91d4e2cb75c35d1546020fd8b1a128d7c8bbf1985c6d117d0758e1a81da01998538f8d1524564e76a68c95fac36ad19a8400367f9b0804d27198aaaaedd7302f05acd50e20b991f43589893b6b27e127f5c3327f270b4832e6589717c61ba68547e006d21b6b5d8ee08f92e8d3b4024d8fcc06fb5e86235b03ec141a3f259ff57a9778de8914a51f24d46e2415d047a607af6452d54d94f489898556175052ace424cd513af7ea90711069fc9e8d24e48cbfb383aeb33c79712a72dfcea6cb9a9de0937a34e1467cf1a82b06eb138293e256d40db7f7dee041aaa6a5fc5c0dbbe069bf8a18b99979b9efc9f6b7e0ed5c300ed4b954f861eaa946325dbe031888aa4fe7f3da02d2b0199048b3863e9155f8d03d65f609419c472b0ee12571de39a2e7eb4f62c6d65d2cf64b2366b01baf814d682fec8fc4cad6eadf24bbb907ea96ab24f00d2fefd345c0e93ff066e5a0ca7f60b094e517fa41d10ef52381c5e4e3a327907e15ccc0925a1b7f0c70a1bf56372e6341be7a77d5df1b9e14f39e78996e7c8b9896580ae315fe3c1b129b0977d3f870eddf1c26dce4b3fb29819aa3a6e9655f9b0ab2f425465bc6660d1b10e80c88d42a5e33e3683f845620f166ce53a0d43dcd900cd559cd2c7133bcd9a4fbf73663341ae29e866f56cf6f50f0d9b97dc36556afe67b885f347f0a30e578e756f6ef8071c072030af42864f08daaaff4b26859f8423ecaccbda7b3b81d1fcbf46597355248fac6ca84cf70684bc71dfe7ca37549f0c74624b6073bd9568f4cc17e03e847934d674ceb7eb66574f89855ecf9b0d963f217a5f9b77fa67b6f311c3edb9cf034c318b3fefc42f3ceb69a73d869d4874b568e086717fa656d82dee1911d539e88f46e4ba9414f8a1ae85aadb139a9f1c2762edf69932d7af9392bb846fe2ec36961aed4c56310bdc1ec0d6ce981fe0ac5577d9e9457862d2e098d09b705e5b9dac5820b2d204e5c9feab47c2092ab1c2a22164c1b45aa7de0ec73bac104a19625a2d15ad265de4c0780e6c3a4544adb870568f92189e487c295481528548029895d1dcdab50e850e27b27efa1d7031f2828c2a4677cd7150796f49a98aae8ea408e9c2b55fe00c09bf529dad5c33f8909e55d966c5bc13dac1d3a848654d50ffe079239ff6e2b7f669e89461259ac8b1d531c330158b10d1c9845e103c1ee45f5c87b4e865b7f089f25d481fcd1dcab058117519b817bcdb2752fff0ed48bd59d4921344abcc10f0372d8547138f0344be64fd2f85a39e3937f106499d83711aed85ac9bfbf271b2e8dab60ecf224a40348ee3f09a5b6106a093a5bc775b7caeccc554fd4477266b92d7f55574d78ff512e9a44c43e8fb8c131994511601c92db153dbe866e3457ddcb4aa42a488d9d53922bfe8c5e1539fc4eac3262471ebbd8cde2af546ad156b0419f1bdf9c15ef0374957107e49ce24b40f615fbc3705bb201c3551f4c5a712935ffbb32222c36e209a3af20abccbafd05a9c85033ea3b46bb5f69b8933d4c62884267a00e18180886859f1765890e02028ac7d55c736a9d66a8276c4fb90ecb5dfa72ca7660029e79e9aff6c64c24a9266897f2ee0178d88ee0a8854e197ea862ae3fe346afde9d0cdb357596bec2f22a576df7ad1b70646b7c6e86ba7ca58724b456729907dade4db80482af105f21c68b5066f12d593be15cc7e108cb0893cda0485f4ff67caa25c3d9668a45406a79da44e31b039d4a62b8533c788c6b5a8edae8cee41280761246ecd2a7b8bce7edd84988b2da40e56f929adb755579b3e4186a30b5fa2600263d631e1e5af9eaed9c0f8ca75c86e2663e7ed0c1651688ae11246507bbbb644eda9b65ea0f0b203c35419e6fa3c503f1d505eee90785edf000536a51ab7a73a9d535c1e3f2b3e8d8d11bd18de17d3b94622cb043ed4e0df8a86902aa5d69703655b4b9fd9c184f71eb83a0c1ca65c2796a279bb3368181f9e2c5e36ee61bfbf0fd9c3ba714882f2113615c3146b8a3f09355d3b1ff7271abb5e0aec94c964061e49726d6638126e80b5aaccdbe2e2513e789f7f72f29a402c3df792121f46e66aa60c2f6de1a6e932ed6f33f74e7071e5592cab37e6ccae9ab51e7bdedffc0044c731a3cab9442885625139ba99f642f3281a0417177182da444b3a6cd9adb2bd4e24349d0aa574f4323d9799146d03a9ee2005cf1c123a9f3ab630637a5cace4073d7317a04fcd26da4a74d9868827d11720e6ecb87e56c41c34f834d89af8dcc513cd66f4c4497d0e3640088f280dded2c1c302bf4c28a13110e1d3434e65af53da5d4f637b3bc902a4ec7f7168ae9c69f9e2626a1b0a051c60533ffa48ef450aa509f30608d0837a0c38347079401b7496fb1a9f39a7fae00c8feddd043e443f20829d625b61e54c76bf8a9532f59e6050212ab1d8792205739f0a18b29d9b453b50175b879d650e0ad739b01e6929e03b842cadef0d37460273b0c2fd1e4ba9c14a67a8c54c0850d39a111a1e4a0093f1c4f25e125b8475a5b35fea7cf8bd60208b483d989c6346ea94439702d6cde378b3850f63390472736e0ae68c65d4147e3290c68ea2ce3675dfc306f08b287d12db998bf7c5948933a97093128bacf073a955f60a3122b285301861ba34cdf5da2f29d86dccedefc9a93d061986a54351e76f82b643121c1c4d144c2ff949f3bdc2a480153e84eafc5dbdc703094690cd706dab0c20107757c1e8afc7eace55e29ca6ab79556c11ae0e2c2800cbcdab8e8c2fd6a83049381a74c345e6ba97a1b91fe0967509ec03361f5357b5ddab717a5f335dcf7f14de28089ee96adbd2a369f16ab9bf5ced13e11dfea5bf8817def8a944fc84983d929d5cd042bed2471a94757bc7f66d2814cf1a9c6876d2f261ea1c77a6b3e23b98c7fb5abd9f8711d989cd7b31a795c213a5c94bf20bc124ad657526868a9085bd9391c905a6ff5a274a459d6fd7aa86a44da9f57ab4632e0d31c91f86478f6574f8bdd2a850090e5386a4a0c074442fc14f252a9d5eadc2d224aebe07fc427209bcfd481893e82ea81ebe820d4bc1600c584833fe395e7eb4ee7e77c0fe469aa0f6bcc101a69a4d4670a7693c3012a8e5991711c87697b0527cf7605cb16c71ee71913a443a21394759de5a8343e5680dcce4c771cd00ac58f810d0b6731da713f40dedfa60f85f30480eaf9b770f11cd391b1db18823f251e7b7a79c8b6e96c85d9c41f350c04d299776c4cdde138444f45ffbc70171b9e45abe446cc0fc61ff3028911815556821cc72b8febabd9f8c0d7e0513355c8774349909b15a7253f255c01acc9f76785ad7d5b58e8f766d08caf4e6abe9475cb718de14f2ba1a5271288cc6a521f0d7c23913bb427359788daf7adaa69251d85dd9f285dd13b7edd3a8d6082f40553bf02fb1bed264544aa5c8cc5e51a07df3d2822fcd6e08e1b8e66376eab983a3a7eac52911c53fbd4fc684224dcb165cd063a4469d359758efd7f383ab3a7b396da278618915cd328f78e2d8380199bd54f7a330b4ce5eedd38bfa9ab4f6e2def706fead14591a591bb451b3133ef7e6a23c48a42289a7f8bbf2bb27e04d40007822757278e130aca8a6abdb023a90454b8e151b2b1337820b7c79e3d49cfb08065889a66c672437055b53727135455e48659bbef343228c91729afcb2664b6d65afa69658f82ba89cd77c85da583e8498895661ace66aee918c6684d56613459a940a6789c05c46f431a8211af8ac5ca70196dcc91738ad5529587c827da9956cde279f9bdb17f2b4bcbeaca91876f694b9ba3c8c17b490c921f541a30bf8fa8b8739a4d58bb3cbeb64fe6ff6920e33534a84a9e0c33b10a5b2b9c2acd1f511869c12b7c2b4d00715995e2909bf5f16be803a57b72cc6dce2e877d3d6d6df577984b2104b2f9a304d7cfd65d6531a65ada82458466268f0051bd8d92d0c13723bde9a4ce542e3d0d9bc64e77030f52fa911480bc005692e8934fc6d0a439b7c904752ee08a0dc08cac5eb1b40c998e649706ace7ffdf0d27959ccc69af4b6cc54800fc0a294eadcf3b5f6b2516fdb35ed45c432a91bf9eaa86fab14241a0bcb206f5cf38fcf995d41f9afc68b186e81f5c334b242d3f541050e5e2606470560de0e6155531b75c6e4df57a95d813a67b00940b523be5dbcac7c398d3591f81d333db967124e44612fbab75568ae36493f3d2247d523f0897bdb1a7dfdca9493f234d38f34dc32afe76994b576a36845936ce30f6794e12f35e3ca2781759c424562c72ee08157b0a3ae27a9e054f6f7bff1f33f4469ae3a1c0532ef193c9a0abe2362f0d6aabbedcb4311d8ebbcc479ccf47e62e704040b6bb79262c963ec7313632811c1f2fe001be1fe57c1d7bd083c3d6c5f8b4ddf99f52e81da46abe9adf4e16f82a25444786950cc70f0d9f0a31163e9409005284b6d14940468fca350bbbab70da020a1a7d436c71324926390a1e841c921f47567b2a4def63082fe9c4411a0d1b8a31bebdf5adf9768a5cf47aa04a17d55b57234169cafd9f70a0537ed9c45f8512958e3a4b4debb3aab5ba3eec7cfb9fa37799753caab5912e36fb6935ff6e09d3aa6d864a07757bffba0d1cba1bfb163d3d63240295a60801f5000a697670af40a1d07ddfb83afdcaacd54daa636ede8513725cd7e906034162b980c65e91b66ba3e7de4da23f3540fff14f016831abc3014763f2effb73ba89bf7bead0eb60003839db01373ba8ba92be6bbfe36c18620d4a6f97a5365082fc00510e3d6a3c4cdd01ef6495a7f031517879fd3606e1b225dfe4a61acea7676d067a6c25a68ae2bf4d51dc255347bd178edb84bc5269be1723213bae9ca9e34ed240be46bc93537e3581ea372a92051ae6bdbd826df91df2af6823588ea0a2ffb7cdf226645014caab699b4c5afdfb14af9dce33d3203b82bc11da646ebc2913d783b711b6fb950fc190439bd0d1472646db751a024ec945dd752d5be47841ea1c24a49a45da5b144d8ab3dc46d0c4d7705fe0d2f84b851e1175db5c5893e3944b554da81c566e15db4bbe605a485142e69de7b2588f96307cc7d66ff6bf8708e24e9b4e6450ffe95f4ce90dfde7683662f995f2dfb6a40253c6d9ccb2f4fef6240a6947c5598752440ad9f5a65446a05ce75ff260b366c2b48e239fa4463c3590d249324427a4a0200883960359840acbed3f80bd21de0c832f3c20c3a13251c5b96285ad31aef4a8703d834ec2b3e8455fa429f5a35cbc6c8b8bb2b93b158d7e7e42893f82740ac91b5368cce399069cb8953ff42750113d0546737e5c464861fdc7d1fe21d658a6ad72364075e5185b3db9b0be417e0c5b7396dd4b487a3753e2fa5f001963f051924301ca3f4e65153044c2d6db9bf47316c08c849803efb455ced4e364c412b8e67f586dc16837237a4ef5d0a6900d9ae599e67b082de68a9584e44353c38558b0d144b1f7e93855858909d2377d027451836cc308e80d532ec29bea0341b0fe9cc7b87c7a25df5759e9e363ff86dd3c7ce3125579a8af007874219cf37cde97bdca1ce2d2b4dc0f07a912820fbf1a0b12255ae615e5356863966317bcc3ba730027a5859f0e919fdf9e791ed69278c6607c1f31b826b203be4dd4358caa6e2d71c70edc5bca1eaf7061842bc158426af5310b317aa79a9dfe041628d1a9544c0ef24f1e129d4ec2c1d9752ab84e00b062a20056ed9b1c68847b20914d6bb9b5196cde78fa3596bcdc7f9a5e520c9effb1e53318ec5061a244ba73f3907d8bf3bb1c75ab4cce592688e46229287369fe0b09c0912dfdc554b162ad04a83a43306cc5d6ac3c996c7f97fbe1b8ca9e48188ad90488d5fe073393f3d297e52d7cbc7898c4401d039d5bbb8dcd3ba5e553624658ae7431a1f16394d0aa6afcd97e2206002056b1787ab78e7876cfbbe204829e7a7307100cd490c4ed75e3d8037a9cb859e15a6f744c85e6a26b7ab392735ee2ae0c637b72ed95a1bdd34732824db7fe1e231ad016844a32af85db3b9cdb7f5161c9d271fcda90a2cd542c0ff3f65fb93a4519c57cc72c64b6364838c3c8314da226ba195e431b4644047b5929732b4e2806119f70ed9d64b14284eb62df18dfd2e117e5013fbd4ce232f38fa770dcd24c93ba15faadc21af21eeb5956a60dc540fd51ac5743bfd96d4510e3cd8d44dab17eade8c501a2b2f259d77cc58a0ef3a2587242e9ff648d1fc48fde49dad2a9a091edeb29b33affcd491352fb68676af994f61fdbb3b2e20f4ddd91e4bcb5d159267faff41349c03ed60dcf0f4faf5a256200a387c8b1e6ecd27aa9e225ede7351c461e5448f68d091aeff0607e6a5a482ac676fb8d3cd4fd70356d12480c3d79b8b952b7a5a43f7e742767e653f6b46287de9ac345a1e157b04e8f24cacc23d1c7d59809e4351891bd89d1c47de04c4ffae5f60055771d13f060aac1f72058acd2a87a8cfe9648c2c35811728651b21c5d5a409d055b7275a866e898dcf50d5c3b9a169ab46fce5594fc0cbf3b1ee31d462a659eea90ea628e25e36b41627316ff1e00805c6e7c19f7def00ea054a82fe1d085dc81b153269b99761b7cbe9acda4f90487cd7b882c23a07cce7c8461930f263b3171c513edb0c8cd482a273e368d0a10ca08aa0ab0eba8a7619f596925bdb16bbb2e3f6a84840eacf817812f3189154f136f236a314b4b9cb020be21b39854c79f224b3d34171b0cb8d4d68c6b87769ff25ffb4e4ad78add9d153885f8a31414753d1af84bc3c2a7517e19920563beae52bee24db9aa2fde977305b74b93ff275b4adb3535ef7f3f8d3ee18f05ff85cd43d5c5370e4dcd132a82ddfe8aa032f56a21246f26cd417278084789256acb020a615ec43e9ff932d0ce1ce0629c98f70d4532ed0add926416ee40c951cc540baff7c69436b9ea59dd5b8d709d128b1df02ed9d32268b8ddd4d73451c096ea11b50dc8b79ee1a83c1fa83e4382ddd4bc2f6239956f317eb080efe734f83a1c20d40e7af1304564f7ed2883d19cff361cbdde42f9c9aaa72403427b46d739ba026d671e9eadfbfb7bf89b341e595a0dd8cb929af3c6c9afe163c4182bb5eb195586dc2a9081a85813ff9f6ecd79fc8db3292e91356efbeb8760b347f8030cb8dc1d03294ffba9b441a2c31c127afc47e8dba2b0454da8ffeee3642dc326387d6e2a9ac81f53cd21b8c5165b70f314752f52e10b0ade318e213e12cb46ff33f947fc98f300c8a7c7fe07dbf15d8a7448f1c79c784f259284338bcedfe96205b15d358ba38c01b5cb4d6f7799d56f40771553c7f22ba043683386819d018089b6eeb04e68cfe595988afcff92752ef9e2134398600d9631cfb0d80d180077fa4949b2b1556826115010713c347171d933f813b7cba7b63a18f65a4fd112f0e9eead8c00974b96bf218b9fcb75692e30c96bfbf0154b0105393afa1e2cd2dc498b7f0de9195df541254af97263b5c8916c93b6ea3f385a9affa9791871afcd185255e0f3989f33b102eee2c5ba4dbd5e340995616b57bcf237155f8bcd1a473b38ca3f564e35db12b43529890c3800f52c6b10f4b1172a224963ddaf0687648f736aa295a91d331800586971ebe6e38e9347d8ff8f1e9038559e79f8f9f0cc6b8cd1e2d1dbd7db4dc0f60cd5671df1ace99ce8a29fa55b0f6116dd8bceaaee96a3f8fabce5b66e623a30f693a45808d5c1f110770da32dd06304d5b5a7fc655d6e4e0ef09e6b37a7b0061023258e36eb2ac0eacca8c430fb767f1ae31a672018df3c6216405f5ec7d961f7f4a81fc30ecbfbb565080976cd7b59076203faf37c88b232e68e563d2c4e15e7ef76a3dfd0dcbd1445ff351fbadb4fbc105a1709d24e8afb33fc28e14541c0c58fdd76e937c0578ce3a063da78a5dca435d41a32afdc7eb76d7343d3b5a4dd6b81fd10d506a006c68ee6416b173df9544433b9863e723d6dbef9bbaf55c1e0070aa7237d12f9add3fe0c29e190a5100f2771dce2c0bc3c5f3810463dcca54aec9f9becf494b3d94130cd4a770e5c8bcd894db442492518656e631fefd2c6b4953b1314e6ad3e5bbd374a9172141aeed40f3af8dad5a8953914875fab87c696b284ce22cec7613a0569b004c2e6fb46ec6900e741d0c5f70a085f95a28ba71554229368f677c18518cac35cc4e556e20fdca5f19141495cef47dc1c5a793693995e934c254500341c2ed1f1f7b75b8a4bf41341fd5fad6102f65dc7b63a9dc62343eaf2b1b681f43987734efc3f1bca2816e19016a76d4c78e6a721b56be4353fb26536e354093d1a91b384a8f5ada4f877a67e6b04838b6a9ad3de99898fc05bd605a726e1780d1403ba2ee538ce4a29fa341265f256c804c65cb1c8b84791296c359ac1dd6751922cccb08db763675a92859a6bf6475e5b11f61298f6007b6e2f87ff1bcc7fab777faa7fc6a1491c057107eac38ddcc979ddf71200d0a4bc516e38050ab61f780856f9ffc725a563d484f6679021f47c01904aa865d3716700dfaf0d49db6076aa098eb7989f326f8c0efe06e6d1ff0667c06d93feaa482e2e144b20c897b7e2ff9dc768b5c5714e673cebbfff8074814e399c0f83349c85bee934ac03d4adc20649d901ebd3b1731b453bd448da20d78e415055d1f5e99e674756f0e89030da24c4bc482a0e8adf290e42ddac19c2ac053f6788e7fad799d874795ccd9e652f7d9f7c3cc6260200e95ea87a7bc423703140ce37f793257346a1072bc975f937c76abf32f13f80f6d718804e1b399676b3fcd9d2dc193e6e8b6926e7b302aca079def1c0a31337a93d221eebcf771ab4dddd8a666f66549f5a5cf0d140c849c9f0221e7340db551b47b6b4d5ba3e6816a9a67f83bbeda29c84b2a166bd7bce287de70d205ab18d5ebebac3bd8e09de060ae33ae06ddcc0da0415e6e431f0ad4c8a697f0e26e47e21ae9f637cd6ab0453b278f0f8c979558141c39a9c28d360c5669c72b49298cc442d0f6e78c0a964354e67403b5df2f29771a7c5f641abe38e44555f573551b1d335ceefc23bd1d4e0c0b65d83d832bc66988880b2ec099956391e7bd6160ebbf2befa232fbd95c0481bc47ff94330906b997c114aec5484a83d436353d45dc000311381e3ddb713d0bcc3ff7807b04a31814a5091796004b679b9c0f1f49850926bdd8d8dd96dd1481e93bff9224501d59ead172442a03c8a3d4566722d8c4c178194ead4d6586c9d9ba67fd8c62bd2a299a93a27bffc330f5dc4266449841d3a63af5aa614fa250f58a0437b5fb9d12d418dee1eb5ddb18ac9f59a8fb8259c758796c9cefdd71362622e3640a26dec0646fe2bfc879124158ecd1e3942f084ec9099bb200bde413397570ad4389bea3e5217733fe48ab52ad844858aaabd8aa7864f23e28849cad490bb6fd788898a878027c0e94f589b365231d75fe6686df4338eb4e00b45ccd5a10452840316b86aaed6080bdf190c9e42f7efd831fe27edcb6f900ce411edf0be005ac7eeda29f5cfbd37d027e5f0739ddab62083cb4c838f3c85275dec25a3fb9b1f5c9fb57af0846ea431457a5064cd81b75c413989e8f524e443a28db187a2fe95f728ff321b39cbb58bf5fa4eebf6c2949112baafff8f2fd3fab37525513561991de560a9b98cbabcd9a1701581acf1243b812739c7d16064ca61c1a15e7b782a490920c910291363999ef72821a1458fed5f545bd1870a8e6688202f6c267c07eafef768b6876d9165b290957a7c75b705c3c8af6058479aa5f9e71d54a59388ea252f07a2ce8ae92ff2b46c8ff370422d9f5f47b0f62b4b70b76e354dd28e2e1354ff87cab0bfea417fbe798c005635bd0812db8b2d52b0adeff90c5ed628b6ebfcb7bbd9996445ef7e78c88cf134d29bcb8c09bde0a525c267fc20e7b7716f5412c6dea4d9b7502eb9c73519017c829f994d5b56679e36fa8298b25a2c458be6acef01792b824a73e1877a836c4b96c6df168a73defc89dd471e91d9a58a12a2998f3f4ccad8df312031d68850a67c7b21c30f61b85ae1f5ce4bade5e7b88b63fe4ad16eed53b7a0b9a45132062ca720cdc1d007e230330dd17e32208a9308107886f579e35fca870b1b8e10a7347512b7be15462aab8ca7b35be1db9b07bf338caa5a7654d5e2bf9be0400354c60e9b6b3a290f4a96208f1768070e8fcf435f65451c44d6af55a2d42d150afeb8913ffff49312b6f6d9197550b22f58637b0fa71348f05e321b05d756320007f22ee5cd0a0fa2996f69e1a33937b69edc62b91da811d50f183e4a614a795cbbd66706931af767c6f7840d80be1dfebded4e4b840b6309ad578994faf220180a1400399e376c544b39f083e1aabb45dbe418986ed78e9158df5951a95eba8ba31dfd486b1c913b6851735cc551767dae56446dd38eaf2e5c2e25c6f2bd2390ddbf522ebff1ba75b5c093febf127817a4676bb9a681d6a910bdbda2cb81abb0c8cd386a0d0cb28b958dbc470576b0b52b6b67f745799d5740ab287b85cdb15d9d336cc6ee6b0fbd2d3529633da3748b5aa3b595a28d9d197759e742f76453a1a4fea18004ec2fde4e09e30ba601150d4e317801447cc8d93154d03fc181bb35003a778ce9be441b2ff19be3a08096e6cf89c6d1256e401912ff6c15c7e4262a15d1f73ae57b78489115693efd7de6c0305cc33b628d3d7a817fceefb8fa7e86d2d0f1114f9e3d7ebc0c0bad9c95a84ca3b93670c01dc6a805d42ff872157e1f021e890cc926da92d50c29440a5910801b807c048ebfa1c8d521a09c72096a2c5cdfb2862252e750da0ae372cab2cd78265d351a1c573a1b3e1c3cdc4e0a82637653ac3ff1a67e6621563a4b0be131d15980a67200ba8b7bf1065ac6aceba9109f40b58ade3e41f21a1a711501887080d7475f305e6366ddd2a57ee5a95c79f39fd08c520dca9226c0adcbe0263d510204148e95ba81797540b8572a137eacc1f8c0ec5968fa82d850feb43b4be9a5bb542de20e377851d69618dd9bc5752cfe20a23c3e2c8e0497f3325cd770d7c21250176d03d6c3b1be3d3cac0a0ed8c7c897f73df1413e3e897876587e2d460b2f360ea303e185dc3944b0e41b560fdfafe5b81bc92cf62dc858acc9ce593d597ad277be20b61611f822e1b154eba8b031821b905b5b0d9a0591af60cc5ace218fb0ab85acbba1d8cbf5a25cd3e0f40ba78a72f00c58b2f34c131c46d0b84a1337724a5d34ce075da57eda7f3c3fba602b3a5cbecfbb26e4f29c5fb936389b0903ae46b7d300382cbd5a27f9165e8b6dbac8d79aaac034ba9dee7a4255f1bcbf77364401eadde3a7c749873d09673e0aa9548762e1c535b82e96d6eaae2dbfae431a8b0caaa9e5b297494b14062eaeafb0ed047183e3471432a82f9f945ded609b3cf41d64f017dbc967040216d8bff175ad7a98b3220257324476c0a2b00eeb10b22da9843be0e464b22e3a9b01cdb8bbc94b7e2888e75240f088edfc29fbf46de5c74ff084a6c0eb26deca39a6bf87c13f233b55333b50807947d5cd128a24c0d464178b89a23c22868234e01ad2ae13c08faffcc4234ab116c9f6ae31ea9741f63c1fb9c1dad5fdf5ff85f909d38bd6ec3309aacdf8bb40a31ad81ecee3ff36c5724d542238aed5c65e68c3f56dd8c7debf82362016263742790786889ef6c7178eb6d84458e5955e8af2756e8c67e791759354c39a7b22698900d809924d589f743a1b7582e8e14e18f65fc248cfaedf8c1e310340066b043fbc5017b8b5640fbf65c313a3674a5f0fe6b0aa9aef2d442b0669d46b54d7b0b2f9ae1367b0b003f49128683c4f3a5ce829af1c90f81a15878fa2ab397e7275be3e422cb70dda17376874ec7df8f9298dd0c5f5998347ff0561c58c408e463e89d8b5c6f74a4de0e14d4ce702e1fa704882e81fd2d1af01c06bae5e108652ab69c0dcd9591c3fd185b38fcce5162738f3d4d940adb8345527a3957657565e1eaa0ae4b5e41d40c17d28c632429f3c26cf3f942ebc3568f9de079f7922b830b71e1a19f8852de49476ba163b12e9aec2b20140f1c207938a26052f6f02c8626b78719294c85a3013752769ff0d6b7d84401519dff6e47c70f074e39298506bd9251b8112aa86269bba0ed90791a56e829323c6713db32ef99b8ccad7c2b37ed13fb6e3da884496b4aa791d596b437262d8d28215e6b32714b91be94425bfda499cb361a884c16b5d24c7cc8fa1d929f5a9c9a7bb62a0831be90001745dc26694993ef0b301576cfe654d6dcdb73166ea9d36d3a1077bf4d1a2f0b12765113d9e4ae4bca38def17cd7432200ecd9ddcd010076d4f2c96226faf5b320a4c7a767f8f0a2ffe2c3a1726f4ee15cda1075a90f14717504d870b3d1d878ca4a2fd8b50abd7cacf36c5062b2a21c252e5ae88805a41947f5d16577626b8959e216f9442c172fc016c18d4afbb74df00026e6a5cdcc3fff10475012122afe7fdfa48b8f61f2757cc377647313736907005bc85d75b4127cd995836e1e004584832116298bc99c110f1bd59b7b3605b081dd2c96de921cbdff1d3ebd85dbeb755cc8ed4138948074f26967c143b4dc860b99e8e0b28744af1f8ba9a0e0fd93e64cb3832b8d1c168cab2f1548ee2d2c2b885d24abc191d655b1bbf3a880e1832c5bf702c431faabd31bb47c38a5910af601d9a97721efa5791880d8392cf333413257259e6119462f058e324102f3c0e4cebe44cb7a0ed0161f93061f493b08cd9c8e6f570117e074e9e449acda1fd97cfd5a664e496218ba99ff67f7383c4f81","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
