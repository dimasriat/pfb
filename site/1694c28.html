<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84bfbee015a9b0d7453d2712aa74f6b1678b686869e8d2622bb4610ca82a97c83841f52b1f0678ed9ec40d53dcb14bcbbef790766d77ce4966ce0ed99dd412d712be1f7061e17a49e2b93df90f09c28e1fb47046c30b2fad8a9ba72ee331a15e17aab499406c51bc712a0479f470a757879596dd872b90c3bd1477aa2d042679880363c14eff0401ef984595b3106ed8a1b6251b05b5cea16e64130434a2a9c71c22983299845427710fe1d97869163a36e9af36f42d761f005a6a963159493f5ffa659743f3eb6e553722aaf0b00f56533de92e20a9a3546302a12c5c40a9b27ce189b8d62ad31460bfbf0fdfaee5340e2aef49531fa51f4f9fd0ed55f8548cfb34dec426e5239fca3259d0b39c33f90393420fe57e274eab4f348dc29854c5003b9ce39e19b6d795b579f866d95a9ace690c29f74177d5afd4c175a4820cb15af4a4401ca94fde0b866351860685c627c15aa297f3726eb2dbf281de5f08ed6d07db2dee38ef94c2af3e2db994ce38df86c4c3d296c96ad7f5f1696f7c6e14501f9e353ab42b72782e1e802c38e45eced291a38799b07f523de353142db406c443e04d42ab6de02048bf170c675183348461095314e210bea3070708fe744ed44a36b4ee0658d9fac974610d1308e965f8120abdb1eccb82219615b31c5eda08edca1e4d69387cc64e60d768e4c02c9181c7968733620ffc59493d91230a0be910b3c75a3444d2e3d286752defba9d5af3d4b263d885edb4689e6776b2df8bc35bb75b84886ff608c0eb033fe7b687beb7e4ce85a4c0664c1b59d221e682c1ddb1d64cc0d21f86a71b4ba1a398b4f4cf9babca325ba37a90de810d1c05c6ba61c283fcec6b7f6e7e8664429330ae5436e6afa0381141efe9a6d3090b6c14857f75cb154f7b5c2309f902bacd483d3b7f833bc8f18b3f3339bd4d205d13aef55d9e12864d0a739331ae390c94c88c54b301543c5a5fe53028b7efc95521b1155ed5c2c7ee6a694222fc64f46e8623e678b62967c82c78cfdd610540c681e1f3dd30f54258163c93cf5107047473269d696c263ae2e2d3abe8445f9e10f1b914bf1fa79e3f18733f1f15e2d17ea210e95a6424756efb00c097d4bab5c6519676760e592c9e8b9e26b2b0ebbf6e40d4c341dc7f96a4eeebb135250021b458e476d235cc77b583dd9b6fe46d30bb89e2577edf1971d090d2024437df4723aab7198511cca7e711b4d8fba3909df7297be0f890811f79bf6fe1ba93cf0b40d500f047e2e0e444ce7c77b7d1f52e03290c324662cefdcce99a11ef8defe25c67ad5e7c1b3e3611a729c71ae3c8a3e92d2f099f134149cc7c5d9745017badbd69880cded12bdb6daf92a98dfc1cee8d3058e5f6aa84a5d64f99ce86965b188fc695a38e6c5971b93492a0bed764b1c943b4865b94253a565b07372341e8d661c7fc4023ce6c3e5b002672c7c723cdd183d394242c0220c8af49cc034960b043d510a7eb71a258c70312cdb0bcb4f716c84af593fcaebe7aad53ebd19a8e1c5cc2cfa6b9a5118a80a56b7bcd7e591fd85d5f9ded0d194282c9430965a786e3698707877ed303d59ea3092803b4da46b2c46130ceeababf9139033f5d02cef38a05df11fdd59d6af20d9d10a5b6c3528c1194adc0fb8df02ed965ce4aba7d3317cbac88304b987b3c7896a3b6407d3d24be892b72f22841d5adc5215006a98650f6bd2be8140823ba36a1bf39975f460c799267509ce8c65a98cf201febad3915e355d94c31c7e0e1d35976a82108713824b6032cb852fb7662c40f2f92212661f4652fa3024dc57cc8866b74afe4aac56b27ef99f49bcb2dad9c201851d4e80c2a6b48534ffba231776192d9154988e3d66db88e1265831cb47fc4836b0b59e86479a8074a5cf3420b96e24ed7a21a6f0aa636853b708860158dfbbf7f99932a8baccd10e3fd17a49b549a3fb76d11dad3a3a4e234597a34fc02b92b8210dca447b006de4d1a2928f18e7853efe922311aca6a08b18249631fca53b9dae38355fe24a640fd36b9f2dbfaf65c68e32349a5827ce249be828f08696dc7b1c933908c28542c78044d5c1360385ee2006e7d4d00955a27bdde1a0de099d59787359fdba1e8b37e551853e7e0f08285310f3d95f6a24778830e37ed6eddf758bd7b2c015a974e313788264fcbfea562e553a0cf3af117ee1934b90a538e0094e91c18e6d29f1523029edc08e10a3de73d89be2915f5e5844466802967522f3c42a94b51ca091720b935febf760b4df4d9ffecb6105ecb0a99eb08065a09781518b663305fec720a4280b584b18d40eb710acdb7f3fa167ef5736be76838633045dfd50e698175cbb74c0d5c1c74dc14fd63a6e9b05bdb93b0060cef46df725a475df42b36f6bafa001d462689fce0829183366f03ec32edef5274aa7577178adcf84cc5f2a9b5bce57bf1c31e853a51dfcd4df852e16b6bfd09f02090e1d91809963f1afad67635d15973a4f31c79e2b1da9b4228ec2526464da5a23246b40e2ac5dfd3b24206701f64459b887491e8adced8d5ec4f58f9fab3658de738f0e71f81b3fbe123bb24c36438d0a32e068bdecb6bb163a0a3e9edf91b86a9fc913792f7e418446c6db13b17a973171aa235e76644c104e543235d5e911fc667d40d91af6cc21c05f483ba7303847c5814a28c27e0cad2ffbd259a5515b7f5c9ea39a2564479e1f4d55d41d716cd23161a22097a405ae9bcf3564c11ca9cab48b82ef18145afe70bd78d72b71a26072f4bace8b0dd8ed7de45110854840588e18ce53328264d1e48d16a8bdc5bdec5cdec5f667402d00f03fe7bbc237e171daf777862b24874737632ee7538caba7eef9d65297a080ae2c29baf6454aeceda47933275f7b55598ca0fd6ca23c1216654c98484f83ae9d415cb14aadc5e500a399ca3e05c8e3facfef55101ccd25bacb5f9d0a0d9e8b6d37578e02c88bdf7bdbe56b8956492d50a80eab66cd6c94e0d9abb09e9444ecd1544fa76b227b8cbc801e5727395eccf7a23393a51799f498a11be07ef8b1cc3a1d955f32a003f77427f356809db66e5eb79d9e00043bf102ddbebc3667f15934671e138c03d298c01935c3cd53d729ed3e9428f23ac051d26f2a29747c5aaf94b2aae97dd2d0b64f5dceba6dbcf1dd452893f71345147d246eeca2f1797ef586b7d0fad2710776830f74718495de3affcb3465589cda88bf11b5faabbc357cfd89e40029517a9c30a5700462a5230b2c9b5ab0c45a20bb586ea99fce929d29cfa21920a4e4ad0097ad85d655e8bfa965a9ccd047587152c5b18cd5ae6acf80f6e59d7a831143615c9420824a5e3be274a233062be411edfa878b7c90980878b53886bfb9c685ed7cdc61644fad8f15e4af9e20a66be8ff128dbe6768ffdfa0293d11d72b7869e3fb506b70d8eeb9c2880359d5bf2ab8d058c0b7e93914de9e040d93676b3c24e1e11a59634a3bdf498e757534b5c8a482c4ce4a6c70e12fa60ce6156df4971467d103e984fca7db60a0e36a62676b388208bda9192936abb487462d9bec42430588bd40540b25c8874d5895b758bccec05455319ba1cee468b654cfc0a50f58e8878bb126e8333d55a193727ae2b8bba69c6d213643e148c30161d27038cb74d6372e7e4687ac0196dc96deb5d0e8d76b1eafa0b4b176b324cbbf82c5f722e51df65146eb692f69e3647dbd60fcc582597bf909b7053e8519a4f5b582acfe7ca90d44050c7de5563b406720200d189c9e31ecbe0ef6bad7b693da2bed35a202262587090da01fb0f4e60a7d0ce3ec9ebd494d4c626b862787cc516e35d97e335b208dd228c513ad45b1c3bb0b1f30e2ee37a51be5217fc4fe696d8e88df748740af8a00b3f2735167f54ea6794da3f42d4a63ef6d08fe18a8ebf95d8f260954771bab56dd384aaaf37885f362c6af0d39acab2bdf0b00edfdb26b7910214456b6609cc415b8b9864b944ee65ef024ae2c160b595d08565c8564883757175fe1b63e72a8c595766ab942385d2cfc17524da5d7551feebe0d36d58f18633ea980099650497ed7b366d6bb9ca989a2d7a10f3f634bb9dfdc3b079b2e2ce77492fbca3fa5c03eeca813e974c1541b947019d9d1c64def4d80c19d9fdeb66273aebef70f292ca7768a79a827ae8ed63fed79626c9df42fe9a931e5156853c0fef4aa1e07f95c849b17917e9cd344e9bb3717b73b6bfb7cde217f45f86f6668b2a5a5e59e129dcbfab1ef5f49eeb443bc2f5054b8a7c6e8cbb91493935efbdd03c907ee8514c96477778c2d0aa9b8e73efae650a83aa2c6d44d2a39df07ddab36e7a47dd6146abf2c7e46d16a8f10f1310194bd68c20110587149efebc743e2f6a97b6455ca69ded5c7e99990f65af4a9d79e7c40909dc621a1eb300fe9b1241ec909286e3ad82f8611d410a473fe8d3bb332b8d741e9b085a1e5184f08cf87332d7de804ad396995a26fcb8411a7abedb28fe708f92d8c3c3c5ff3addc658911ac721d7ccfad662b3715575008782e257710a7c8806e4b6cc6c5d98e9c74673a0045a6243c70fa39f9a7668a8e3116166446eba80e7e767be0284e40c0aa85250a78c907174df7d21d414ec04dfd0f69e1468bb09e60478a00213fc6f6684d520c34774348d816bf14c822f7d423e4961202492229110d065c01e9e450492d7c7ec6ada3c3dd042a19618d355850542daeb4ed5d0d80bc3055ecbf4f1f1ca39cd4a9ab9d109eff86b1bfbda1a2b26fa1e043614228bc6dbd2d50862263849823abc43127bf5b55f50568e8be58f287f2943f189aae5ba8b8b600796428ce691012c3b35608dbc5861c5b15b2777e50288a11c5ac2cf9051a1bc0043ed7d6785dbbf4edbff049782fb3ffea4b0dff53ad2231280fd25ffd520614fcfe1f9de88349d378f7aecb3c9db97cbe6000d422099e3c23f765d44eac6f3d5630aa422e5b920f115effb050a0071619ad63f6a650a095d83846e6369133b5cdc079d5da403a5740a6991c2981d8d0fe86bec0ea5f856ae4e0afd343c10aeeccab8cd1abb09b589917fe6d54a3dc83f3eba6be9202251831a697cd274330e55d950267a6aafe173b0db0afb262ad908886eec48c0040f8228acf7529b123c8583d2c8338ca330e83f8176d373f430274aa4e935f3d2b0091940470c9cca9c0a57102556a5f10c41952f38c8fc8525f2a3ecb9b69bd13f9900703734bf3212b7966ea54a414554673d843a8f18d8e7798c82b0f3b2bc4a0ee44a8fc9bf62f6cf9d6d510a20417f219f9518cc926014b2fa897bf99217f7b18fc81f476a541722cdbd77c781c6464aa7cee5dd62749fa9cce6bfcdebc94696cf9fe0f784a500f698d922a3be25fe5ebdb9787617aba64f1dd2bc232b8c25dc4156c834272707d944fd40011efc42cecd6dfc30c7fc07752a36c3c3f0b4e7415db8074d51936488eb11782b5e58b14ddaf353578a2a04296b9485244b79e716ebe70421aa65c19a8b8324d0b82d8132b9d33f89088409cf9ce9f53f2accfeee5ea46d9d4c58eb3f791e014059be591d0264fdab88a70c4787f6b3643d961337704ea5298e64befcad092994fb812163628664a8df247a321bc3917f9524bd2e84e14202bfe7f683765af20f35b72816972e86202ef2d418be087e0fe153500c9de76e3a2e57970bd0f3d6c28c0d278363b423d131850e7a45b9c171e731d77cd36496cc4d0a0de91b98c1243d5e94677309538c76d32d9d1665f96623f3b577faf9fd1eeabfbb5c21f52efd9eaaad76638a334f10df7a9e1890b1a27500818101f95ecc928ba71309d1f098bb8682aa317cff171471c7c1378684be5e24a239cbcbf9ed22c977b2517f975b63d75897f66f53c49dab926e3aa8eb4682f5fff0df30ad5bb671084073b71ab11499d69595f5ac67cc3d8266560f291b07a93e18092bb848536b97ddead7be9fdc509b7612e1a2571c33d5a81ea3b7c76640c43a76b4abadc4e0b576a82cdbd3a2bea187c094833c1be093912f7f8b1e21c4aa74e42de038a7a6e5438473817514c0c5b5cebd4743956a6b8453ce41e99ed2b6b7c420e26b4b866f1389769815c98e11142115f585f48332062137cf78f1962aacd92c0a4773fa654474b396cb12c31f273109aee275a70c4e0135b7d6a75b2e6d6dc5c7bbfed32a5de0f46419e5ff4822c375579c3b5d6d862ff2a05b195515d180cdf59a74c396e773f34a79440262590f78a542cfee26576a2d23c66c78c976fa1a09262140d2e0a1f19872cfe4e1f16480ee8692b45a31cab90aab204886b0aed759667f87746c9fbeba74375eec1616d0658a4ffcee0e5b5c62202d27fdbfdb6d5a0b5528a6f8e0646be579a7ffc68519cddfb5d8ce1b3fc3a78368cf9ad6041b8f12e749c6c318c2e0ad76009438c81c7c66e7dd78725c4b83ce7a6b8239ffcc14b7e39b4cbd6cd07e52f8516447567734cdd849e51cc21b37a117940d3e57a7d5a7da34b8969c98b82c9071d72d01e21cbb7414e1336dafb4d0defcb9706be12cb4045a44486345104021859b460adc425d81ac011177f48b9401d06f5aebce4b0bebc204543be0f9b40fca27c4280f7eeb215d1d7aa9e5e6d83124292774e2923aa85100d6c3b8a66da9cb40008a3f40b2a54d48d38bfea03499abd895b54651739a01a6b32201259a9d31c8b89ae215babe6bd146251f7231dc8ee9a61cd317342be362834417716a86847ecb3b9fd467f291ad0d14d7245f73cc710cead8c2049c2d37078cbeb0be667fdf67aa498b0ed8b15233f71466b00fed04e852315cb25d9c6e32f7ee30c880e820b9586bd96db94bb5fe47785d33d8327ef4d790afd7e482bd8475507b6a552d537f43d53faef888f65632e03bbd5ddb652bac9ff06616f4dd6469f0fb607facec44204fbd8b880039167d9ee0e56d07256fa0e6e3fcdf919d0fb1c82c38f5b927dd884e281b757308cfb1a79fc0a435f988e4125d2232b718b1121a7c1aee2ad42f222c0f6a66b8c61a6029713a5d10788c53cf29e19df834b92141fd991ceaa924463036cdbd762031de9ddf87332860956b7b48d4de995fa7591e00079c2aff781d735550ddd88d51ab88ba083cfa78b00e54fb8ba90f68dd2a99b4674dfa901627dee85f14a387fc36660a972fd89f77d06d6b4676608e308aae33169e258f9b474d28731229ac889aa833359805744eeb2f78c418d44436920f6c8e0c018cb627216d1765b6c08d61e2c3c1883863d9d939661b6395a8d4162c41dd7a1d48e2a4f21ca5195e85b00406a6cb901a6a1d8a6e380bebf62562a6ab99ddb5ad39bf86b7f8571a3b6da64ee5cd99b93eb6636062b8c6ba8ac73e1e4b46f75da4c9f41e5427396732c4b028b762f77e70f5670beece0b0c0a9ddbde4f31b54481c8daffc1e6bc3f7329946654d3f5ec20497cd43cb4143e4fb68ee7e39f1804b9685c1ac21b0c15efb129d6fad9c46ba5b959a732c14ddacf558fcea16f31bd3fae44bd7016616c294856eeff40a71c57f31b5301798bf2e0db8334c69778f1f50935e66a7821fd5383630a3bc7cdaa23c70e608814b6da9b8449f5dc290bd3a0ce692ca76d158311582a80034828a120a1abdfcc32876f25c9fb9dfddcf5537c5b524fb1fe9d1b69c6b1979d4da5c07fcad0e5f638b551de44a6a5d0fdad5e35b4990d69f5e6599ec4fa2486c73424e108a84a0a1c3f6d2014341318d4a763f6079ca32fb8c7f334488a945f7aae56a7066b74e9aa4fa1abcb9c1e0f903d4e3979ae4388c749028cfb3767e9fa8aadcf8dc97361bb68b886cbff44e918299a465391970402ffb66e7b1b32389eaa6c3989793a0a852eae0e746f9dcb5735c80055823e67a4bf33a188a42c1e155e52a14137790cdac1b1dc6b36f34e4de01d64a19be110f7a04846a213c40273d093437975b2ab5e8dc74467b44f01e25c83b32b92bc4ac058fa568a8b91e24b76e3cc89e2c52d268c57afc1074f2b2b59a438a60e700d0abb1acea132e42170aa3e224a850e05aead2db2530f36aff4d037702c0fbe8226e2af9212e094f2c2cbd8e7904058e8128a2139845c036aec978fafc4de40841f1fb14e67904d2520c2fe9e01d2c8939b642b3e4407bd80f85cfef9188f2ae62472835d53ee4a6d1d266b2197ff9eaf024a64ccd2f93a8780aa37812c7bd435b727589815598c75ee05d1007441a778d20b99abacb478faa5d595e15c9138c6b0f148b2372fa2d6151cf39b29c7276632281266a2f59a824bc973286514e76aef7a7f6a919cbcf8bc95fda69b8c96f15edb2b3d60a44eed0c330e6134fb541ef165db8c2c79853b00f63610bf5a0c37299d38041c9fc61a1970d4d10810a4ec1402aa8911fda658f5d3c3b96c124c6730651a627f75bcac3c866c1640dc1e5aae5864c5ebe80e532a29fc19c81e559063f74b1059e5b9beb0f3ef4d9f1d37cba7b0b2f22d6a667add2bdde7cabfedc96dd9d16e94384d60a2dc1cad68a506f4f4942eead7a4ed6601ff2c02d96b2fd4e6f9b793203da1d4d4afdccc300e946ade92bcbcb4f4e62e075537b9b657cf7957eed3ee352e4d09fccff3360000a47788e87d5efe60f064afec7fcc0fe8be6cb4c09b5ea16e47ca4c47fc40a2cf9a086653f43187c97b905a6e67ce2ab04cc7f018eaa709078346f928c5a810f429e29f1035f04dbdaab7db114d278c6909eb325cdd8017fbfbd1fb73e2754ee20ff89d522ee0064d020118c8a34fe5626949d68c378432dc1d1af1ca0e5f50ca501d633ae80e930efd931f45c025348541f4952bc903b4b4dd5f6cbbc0090f5ea4a68f2ef7bbc8712f1cefc6111133520ede35f8e30f016aebdac74e3b2924301a12e4f53e701ff677b35a54bdf2c5176a7bd9de5b93442e91a284c81633856493570c738681a6d3a0c13cca2feefa198e08f748b9cdb18eaf80533c999313973f8c2917ea360c858ce8fe1fae00dcbe9bc24cb51227dba57bd9934c36772ce7a870734e077ecdc99766a6e5bd0c43057bca0a616bde66c0acb2d723a72d63cf5fe1938b8358e6d1f0b25d79d5f91d17b7f86c7c7cf1df24f11ee8f86168aa1ed28f193950b28696a1d506874577277937495f31d2c77a0911fe796c7ff7095d8c8d9f1c169cc86afe0d7e7cad95463b8230198f292df28b407ba1d81531edd60b905bca8b86d85aab2c3f048a5efea52e51e940b56bf0b4e476cd1360cb771dece90b0945ed21329870a5b8ffb0d23e9f438abba6316c0054b02ae75b76056f750231d0867d0d927a98fce153a27287ee06f6c5518683dd1ed531ea10539d497a4dbedf4a35fb1ad541ba97e2633b9a9afd1d877ca21efd7ca86cfdf3f33ba9094758befa7d2be66bfe33bb247d8f4bbce78cf89f1f55455d5c0c76248fc3a2a35e4f7368b252f9d7688437aad32d8609bb06944eecbc4c7ea35a70efa72999b3f83a62d4f10cef8cd0c52ce60dc335b80e136855ac8580aa3c166066f92ce3f2a5b4bc989a1272f43ee4b3a9683a00074665d5385e82311665e73efb8f3c62c1cb5be3e0830ebdfe3549ebc1f8642910d0a8628465ef55efebc59313a687272a815e7c8bd14da98c6c1587110440843005c54cb86bae625535f1b1e8b59a9868aa82964d6051fb96fa4695ff71f86aa551d6ba4a17cf9ca9dfed40bb12b0889c7eed8ddc08a2d564b17a999a027eb966cf4e0156ada1637d5590102f750f1a0b2e642d707475e7ee703693a2d6547eb0d72abbcfcc10d726120fe3d2421f3f34e5ca03836a982523b6b6af23ac34cb03d2b1857ba668449aa103b910d09e37269e26d8078c98ca9cdfbf3dd274398a32345d228be7ca3366d688d36758a785ee6092209fa3cc7c4e9cf98a4e0007747fe27ab2df85008c8bf6bd21c838184a2a897e1ae680e4d0d9950e616c1279429d6e79910a61511a55d54b2c6b8348f67617705ac98ca43d1f2ab24df0cfd05dbc8197aa78ab2332873cd10d18078f8f56277b7b5111bfbfb94ef8aa6c46563aa2c6d53d6bd97a7fa0f2ec7c064b636122f6b5a5741b1875b62f439fd4fa9cfea3a349a6aebe8dc5ee6208c23cc1115f352abeb558c28bebfa470e001088a8f2438df56961b57fd872f2e78ea8ba197d29f41e5abf68944f3b6492e21b4efba670ea9610746fb9fbd8a41e5b91f757b3e78a124f2ff5c5b122bcf5ee2f7aa04b19a18e65505ba5520a8f000102f2777ca49a612e2c72a8959bd033ab049394dc4cbb3bbdcdd4eb623a84037fa1d2969516e4586cf1b9106d53254e02c30e6255b80bcefb96911c9911e6df1c8056e29ac744e76e5081d3cf0e0fdfde3ef1c5e0f0a5f3bc18ab9d79989ea9544ce450b117ba3efdc8f96a0ca75d2e5844914df5a50596e272024a7b08fe07cb6def81af8d794c664aa2bde395c0827d890a10cb7eefdc98eeef3786a74cf95e53dfb431b3c05de551911c88ccc1c1174b5eb685552cc3dc5b460b2806304be0ab3754679a7cc0a6a6645a522958298b9e958d85c8cfe0c94ff934106eb1608668e54110368827d7f4f8f41c0438703060ebdf8064b841f0dcc24e8275faf257c9abd7ca44bf47513a8bc6870d0d96bb48eff62b17fd85e966c796cf48b2ba1eaf60152134b8ad35d743b4715aa8db3abb33a4279ef0f7553e64e63d736acb24ebb6694bb6dc2961ad8891b9e57d54efdca2bbe248215e82cafe0ef27bc6cbdb3959b65d9b7802d477f25eb79b197a213763ddde1ea4c855bc57abb0f6f861d60f911aa9dc27a316486ad7b49a5578d2c4007de604a340db6ff8e0769c1938388dfdd0131732f4865e8a6efb8e69a4bf9d884a2fda838700e9b8300e94f0fa09d0b14f4e69c5c6c196c55539a3c9e243e6dc76afe5f52ea7e8e79535fe0c7fd5469ca400f9a56fc46babfb86bdde6a7ddc7cf6aa10f1b3189497ef60b1cb5ca59d05ef76d021145d425fc274560827a4db3957918bcb719cffbbdda3209370c1f9f1783b02ffca7f7d06ef27ffb063e5e375b0b8193f874ab514e4b81b1f9c6ae2590d0f53d914fe5ec604ac95090066ce22ec5ab48b085b95b878067e74f9685db48dc9756a40d78ba87bc20e33887f394111d153c7f2d78688c632515d323f0839d6f1a4e082b809ad27690da21e64c77ffb126d098fcbf9cc214f1e44bab63019809e13d65a3839e6d9435dacc2cd25d9ceeda77a0626890486d3899a04824e780de8690524dc2af0d0bf65460a9347e99119e7a4c2100815bce1fe94cb5c8e3f8d545cd10685858301d8c93b69c5941f4cc18b28b568146af93512ffcf13b824d86ee309f838f50b327a72a2234a663773c5e09dc2d733f3047b0d8caf275ee6d5f8f184eb256b94104014af0cd19c89ebd9f14138720409c9adc1747d09e8fcfadb378784214e5ecf02107568638043a6f0e91ea1fb663e7770b8ad8622bb76ce0d64b6940be3904f7dbe23a959f822c1985f1cb7e707ad704c72d9b6cfe1017a6d25c4e576a408b90f416c8efe4eef759d071b458cb72fc031cd0b36de7821c6ed8b2622a0d89952507557999dd60601b37c217f090f1facadf5471552ac414f72bc82e6e37fe0c37df5e38aced30093ec6ed29e1702eb35b0d41f1da4dbb64947f5dd60d06118415ce3bfd79405e4bc308df2da69bdda98b5e0f7c629914a4509f217652ba913eb9188db19bd8aa08479434ffe51b77fc9e66e8bb5d150f4a89879abeb18f004d32c86fa4894f9d228d6f64586298e37938f34cca5d83b37cd65caa5655fd4fb3ff09de0575491a82c66733cd6dc1f79810c4570da21f01e3da7585e5f5c5d5a016421d5c5b9d7e440b2eb4373a44c423a5688a8e258dc95c5df5cb30c85a225cff65715ab09ddb574cab36176ad5920d585b8114d79bc35863ba5f91778280f2fd8d20c5a6bb1c902663d76ff639f94c870fc7fbe20104d797474811ab143ceb1131bc782c743e51905e5968cbd89fcbab55f8ffe786705c41624ddd350ac880f3bce90e855fbacf773b52121f66686fb63b5a264634792656386df721b872731498cd0d169158910431c61a96b43d3162070a5330ae85f51b82bf174edd221f9feeb64598e8575eee6a276720af272f75e2b34b4da946a09a1497497027afb2cab106e75f846577c963724da5fd540fa942ffe9b090c9f79f1fe8f04db274ef5d2349cf605405a4453009a71b2fae52accfb907dfc31615bf87f41fa4da2e84116710231a07ceb9a5d50af7598d15798c79f80caedc425ce00b452094e5186ea915bf4b194d28a0c90a241894e10b3a9cd1c68f64e8731adce3e837fbe6b2efb60082af7bd4a92dd481af2f4d34299deffc9500f0ca3b913ca0105f2bfbaf5acd17d2707a903b4b52f82d7cd77e96757e9cae4853f76020954e04a62c2f416e499945af0ef1f793e559882f4adf2f81147ab33d2da3a98cd757f98f8319fccb18e6dfdb3e2b4b5152720f40327449d733b28522465c62f00ba5305f9e2c8fbf4f3db43d00277e3c1a310ca53e653c2273a1b0869d7f33c55e3558d9c7d3c3feb8e5379cbf1f8c5307da06698097ea42ffa145a4ef6880b632c2e427862c586ed5771a067b962eca057c64b22824a83bda7dd107f9efbe82f229ca77714d9ba9ed91ae25d432d4bb79b298854bbf2827b1cb8fdab51782b3df5c1b1ee75bbe47991c42727438adc43de52cbe9e6166745d6790f8b7b1dd41c9abd73676a4081495301642f52fe6170fa026bda00ad608b00d9e92e6e204ae499a848a8ab8a162ca957c5d28cb8ea905a8d2fdaeb7a5a4bfa7087f91eee88e8ec397e2cb9dc416f316d448579c798a302a9d4bf9ce9c3a9e6301cecf7bfc17f940c6c30a22950f41b0807c4307652481155c65c3e4dadcb1ed489ed2cac7f68547128ccd61777ced3623f76a47d1bc04ce48c9b3496f24ebda3c4453c0d240fd88a36833034b5902aebad32a6d2f02e84b65fc2cedbfb53f1c8f34c2e4fab19fd1041af2db29f216f7266736b04a16e63be507450880383d44d94757583704c76a5671a4b42bb0c85b6dd93fb06ff6c30d91ea4afea2c866d9acafdb330d157a18b4038eae800c97404a052dccf718225bee0810a0e061d565b8e68d533f1a4736fa1175fcab4b735c74607ef0e159d6b77706a7094d0a1e1c8d39017159c3b34052ae320e36c080d1e7510943a5fd7a566efe988ce9b94ac47fcb7ed7f960b311102d50804274cce35e2f11527710908f99b64006d65d313a9044ea1ce4c382dd878b7b53ff73c661280842d52ed08b2315d15648691a92ce97372a00c823e96032d6421e72aff195c0ff11e65bfeeec4ae724b420991a98d5bf94bd489fcb2450ca396abdedcc6bae6697bee3c04177108cf525cdf6c95fdcbcff35acccda7977b03b439bf7486eacda0e24e046d0cd33d129a113663425c20f044d97c67e272525f9515313fef8f3e84d01ac1c2354c0e9e13e42995f56700978a4c22fac42bbc5380cac92a920b5496cfd87c8b4c8e10f0ed914ccf0facd2d5839fd2e0c5f474bd6c28985da24593c64f50c686703603d866e35c34d496cc4e170cd5ec5b671c9c59f36454ad4aecf4d2e3b7d932c76db1d0417845f0343be2393cf8f17f80f7477d7d7a712888fc4111afd74da4f522c249394c1291385f3e4c860138ddeee7909e93eb49b71d5789a6cb247c42f4bff16e8b85aaf841ba48cd675690f8b6f353d314815a575ca604f2a2c61168a1c25d359e3b1d3698b4899728431f152bb3e07fa6030fbfb6231a2b147f74f001f33fb1800574136d5a618c1ae08a9277a3043291331ea8763e50b47b4f8831fd85997c30160a0fd3d7e98f639fc47297e907f6e8b23341ec52fdaacafd9589d5c044a506a3fe7ef3263ed1157632a9206b436174369bc1c2748afed862c4fe4601ad2b4f3f513cc7ecf5d83f6e8493cd81927467b9b7fc6c89a15d305ff19684b83c7d1b14dd25488762f1bdfeb409c1bc479463c69ee31d1215da5e787eea9137fa0186b1e378db6127cfa1ffdb3bea9eba0b9fdf08c4ff9072c3d4979b1024b23171269e72d2d60b5204ceed72b6850eb7eb07bbc8bb7d680f9007a99c9b60787220d84dfbb536c1502d68fd89bee22a34652b5f705281754f99db6fdaa69ccf50c4a48a48cf39cc2e9edf51c843e4d0a39cc7b09853bd8fd7eb1c37740aede31080624e0993be402019f48c1bbf59e587da453a20d015994f0f2951a80840e99c03ee4099a12f55471a2467de7c5df11988279791193442804eb387007caa089f7dd97a34a81d17cd004ac6f734f103da7987887cc5de9465f876c08060c548edf316e4d95d76c5eb3aedb44a94a92a3856c36ce7a0183bfcebd81483abfca1feda00eb0d1d74cf3308cfdd07b28ae75d6f16869dc7f120036cc4777c89b4eb2911f5e31d71f9fb74d4db9dfe1bfddedaf14257a87a4271919a257a6081f0cd6bcc9b2f846ad3982e3773da156a3b297e7a74bdf66a1fe42df2a6303673a85669989af567348a7f77c05af167d49e91ffa615ef9f91c3bc3b8f6342a44145e6828d93c6ae2116bd1c19a03bf0ba7a4238a1082d202558c79eff91f7f78b7426a8a03182cf77d28d888145a8ff6163346d6d2776a70764219cb30248b955cada6ef346babad1a5a92ed43248292fec3241b98b70776feca4eb6b7ba3826b7cffb5b4792135fd766e6ee32e8adb7b2a5bd7e1054237d3434ffa7a1e4fffbd11ede9b23cd83f304e26299b2fe89ca13506a30ca3fa34954f795b402d4ddd522bb8c80418d19846812acdf79993218366e2e92914a2a94da68a6cca7d7d4cea797a1b9d7f08f1a3729215b485299553067ace4ce10563971ea15ce26c15c0b615e9486d392d9f7e3f7f5e093ec39ebcecdb1e8ccb4ffd95547d1522b7919094f6af417b0ee18b981c5647a31fe5de163b3e88bf8f6c899614335696d92b666be4bf385c59bc5ff0c8b38d838cdc17878f9a04e499e21dd8a2f3b6304b26104dae831b636a621541192bf50d15d66e34cf71b66d0db3ec2fa1deebb16f1aebc15fdf95e64f28915bad30ada1303695928f76d4cffc2a32fb18b0136d1393397c4104c0726271611ff1727be68cda2e46ef6a3a0a48cf4d609e83f0234aec564d702861d9986e1dab4ec3a5b1c1813db104fa21879af4501154b3c16fc241d7a77e8c104644e97e1757238a693ef8aedbeafb362045bb7c8afc2d4e9439ad7c3e0f7d1c94dcfb855686a9d8b9fcca969c19b5f9d9821b82e3cc0b79ac836f2825971cf3fcdb241874e248d2b984cb53eccb0c9817c7b047df0eca940c2d4c3dbc788c87c0e6a5d71ccf9f8ae4ca426b65fbffb87d4c9525c29f05421f1a81e185c2243d04aeb5eeb9360b0e368eeaf5f7f310773e7d5d81b5985846d4d12e2b8e80ca2962240a35c3dcbc33506a6e617a32e82baf3d3a839366b8494275abd45d7e4b65b702409aa10749decd188fab73b517732a22e420e9ff217f33099c9adb52bd050be850395aa3d3f7da0b8356384185ed7d6cb38238f2b9bb7cc838122266969af934ecd405e694f4a4eb65092bb2fb323e9b061bf442cc9d7f162624a42dae7111218236cef261f7b4ff1ecad36a4f4123344a5ab03d2f6bdb65860c16a2417ea750274c3ccce78c03567b4892b72d09a6a558ecdccba036de3fd8ea971ae72b193a0140f94bd203a99ba288c9d8d4a0628fbf808fd4174d67977873728ea4e691d5057529dfd5f004950c9a76976bae9313d1604cf6607ab35fd7f8b027e13ce73a3a7d706ded4dc626f7b449934e7962772fe9177043b161f1ddc01928ac279a7f4c4cffae900a0eab4ef2742b24b3fbb7482b521261593acb0b80f5199ec7d8c77c6fb1fce67cfe8c2574b588edcf865f8d274c2aad79afa1ce328ead337edae1e232e5764ddc4cab0c3c28744e797136557dee675ded39b1ec7067e4989a0eed5dccd4782b4a36224837e0481de788dc6e67c03c1f5e8800090c40a6b67db0fb537b2c9c9d987891192b9f86f2aa114887d6b37d164dd86c35fa4321e6082254135eab02ae53f8b6802364f8e81abcbc43f60dcf62f0ae7d073fcb7e021dcc8b5610501f0d16817cf9f85cfd2058598863325ab47b3b5f059bcd48c499fbec4f9df8294d39a96a8c7cd021909c3105efa131bc25286cb6b79a26f32648fd02d597eef6acd043338d92c1773ea92e7ec612037674582d98faf293f618ca37d0894bcd89fc20d6cf4d75089e514958ec79cef703d20de74094c253f32b3b185da737b71ebed4054dd925c3cf1b835c6dd9680f6cf32ff0c34f4838f0dc07e7d958882e84c7b965921a97c1ded912ae907d3bda0fd5683fa93a677886f7631afa9258e8e540a4a9fb3ede43acca60608cf0e69eed4310efc801de6d838ffb851c87a41876f782718368a416188842bc9553817b08cb7a5425cf4ddcb65ad0c9767a28919bb8b4ca8bd033218a0dc13f102b1ddf0a26bfcbe7f46f6d9fc6c849ecef3e92281c46f1df35de0a523147e63adab0b40070459cd151d75b04a7d33a01d797a0fea1c55cbec926af124fdff2a109e6972a0d573de1448d8b3bb556d96db9020f2b5c49b79f4b87705b864ea5f51ac7ed1822e82a6724f320443cfc2cc3766d7865a7163c2b464dbad344dab445bb74e7e7741171f8a623e6c48177c4629018dbbb1ae57b80b2b82911a2051fca904c2df1ec4deddcd3b848b2a6bed76cd5113f50e523fbbc10834ba24370a860aac9b4c881b62d211b911b850367b9f5c366a267771e04f12b249b892676a427c79f2ca10c9d014366550c520a13c19df2dc5997caedef7873577be745dd7c488865734f25bbf3b5572a48251f3af8596e19fac925d0fdd066b831b1f00b7f48fa3bbdc9065ef4e73c4a3cf1e131267c5e233a82ae83ca25573bcf2b95aaadc57f241a2509ed8b4d33c8c629b2a55625e5a1336c86de048c39e1130cd01bbba38c5d24904aee0af3be234506019e029b88e2992ab93ef28d39dfb32eff490ed1a1b644c70a44b5d1243426b475be751d742a0a3a52ad2f76df30a82742ad60f01466e4c57164686e264469a28eabbe052bc9842d36797c8d5060ee9b53af9fcd1377d1f4668cd3799f912f7bdd663ca8c4da1719fe996ee069e1efe7de1eeee87066542dfca1d63b8918f16216308ace4744349dc28431aacbdadf3f01ebc3cdad9a7af2037307abc94c736f69a6a6ff346639268da4084269d04105255c30b8a4ba564d258cc2b87a07c5e8d8c0965e287661b56dd61729152cdf097dffb79745d7e55ec19926358cf6e68406d4e201b528d3239e7b617618e39afd91d9863f908c39a55b5b8d7703b38ac704d07030fed5f5bf3109de2ff4c360f9a25708f91aaabea8dd889ecb45f0e5c5701d51c11588610f93d601f6f960a0b834aefc19875ee4a163725667a09260bfffdfcd3e1f2cf829b316627fdf4411a15adbfc5762a5b0f24e2d878772bd14ffbc60212e73a450f1924dc605c77359959fda8b8fde444e4b75360dabdd6ad1a9eda8ed86760649c04a5baf28048b694015b02c7d5c47ca1b9f9d10b99709a01fec3016db5a55dd0fc5bdf12e3f2d609a2f2d1b81185b3f0e6d24dbb2277f25f2def0abae7c8ab45de1f49a6","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
