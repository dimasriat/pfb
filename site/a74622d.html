<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cdb4c209e5cda42164d01b4bf5ee51c01f3b9fd0f34ce52a6eefbb515213ce3e109e974bbde1ad659ba943a67a0030eed4ab85539ff675540d7ccf8a9f9ba22dcdd37e9393bdb82833161a0bf722158b3a189c2b0971078fcbbdf450ecdaff7295a8c036d23788c4a3cda4a960da7c6e12282dca435f8350d5af0a68afa418da35b637b3eccf6dea42e63f4a0f0e143ae48abf7f8f5dfe22ee5d3ce7a67a455a5dc080c7b0125931bffcb25acf59ab1e3bf8f054390d365c8bf0456ee1fe42e6458ccda4623ee10eaa6f0097472bc656f5e15603963f6a4c092872d15bd2a9a91cce8c2b6e39747df26d48d78c6e36c7eed7127b7f669e4f254b52b78e96fe3b6f13af5241aa4803f72e006efa3df5c2056dd312c2d91022801c32160c685c173e502067ce71f82542098adb49374b5e8abb3af45185933ce31ce7189466db20bd43203fab576943daf165e496598d4a6ea68e87250849b588a01a31e98eb331ef58c9f9b074ebfa7e5767640fd9d8cff6039d9cf377641cf3bc213b3cabb1e9f42ec27090ab30c8565d753c310e46b508bf4bbb5ceb87d8be2ccc4c467deea0f33d4b168dddbfba54ffee2c18396fc2d6d2e7f5409386625ec43f5efe4b001c226872f6b4a9c99f3814afbf4da0f0de80e33b4bbbac8d6f34d0ad0885f76675a5d5269f93cb02c4c475b322a9f7674f1c317c9ffe2597befc3006a8d2162fecff8e8003236ae4d12265743a61dd382354166bae232d28540e02202b732137bd44601e46474cb3c8da9b5ab32c9963007dd321d045467a63cf141907f607a57037d45d894e335ac0d9588493af8159fd6b3c3e1b45cb306e5bd7d582ec13eb90ffde23a0a636636535072a48ac209515e6405adbca69c9908975a415c644a3e9b2f50d83e0e5d084b37eca87991147dca9134fc46a1876fa649965970413f99605bab3dc5aff45086213e4a962edac6bfb76a57bc8b68d024f7eec7cb5dfbe7d69af14e4839a4bb4263359648caab02497bbde7c6948d1437efbd1d48ea6d770361a3aac3b576d1a3c8bb317482e80f6cba3d03fb3dcba147314e5b723d9378ae8f2280aa0e8d54de73b9c54f20994fed498bcabb8272e1c7c4b5b4f1bb62bdd8730b6e7c8583914834c6d66051485b9465f5d008dca3ab9e4058f7764e6f21a51c12cdc424726402453a043b4b0d9ef950d279110f2b4800f6800a00b29f306db4ac7fd5fffe96af9f07485844b8a315e88ca35dd3e2daafd7b86a59b880a42240a6eec2eac4a0f4a5aee7efcda8b5056aac68d56a6bec0dd69fb027af4b55079568e82e99eb22dd0447c6e101d824c192335d379f20eadc5226943fe5bf8c1b6805fe56777448e6014b9f7c86def49f76b9f4bd5f23ebdce776281239393058b2e3ba3de82ae4096c499a59c56123e8e7a2dfe166ce6173b8a3e1549641aa80d4e37ac45b159ec4d0ba54c1a07b3657ac982b0771fa98c2e5a81009ac6d282271ac17aac713dd0211591225b0387efbfbfa53fb9d7b4414c6228f8aafbc0b3657f1ce8e4e8d065f3bcf7af474bff0ac7a50676605a82642fbbd1ba4985345fee5cbbaa9643d75ca517a20f87f27c17c543adfb85fc13a847a3f91c87b910761f732e1fbc164c2ef95220e80b3fdd05c0403d93014323a2540cc155e4cf1033cd5c4e8b05b70477eff12f2c6b9a59acf589d4f105efb130d96b78d678aefe34a3c1fca408e49aca19a1f150c7f130dc6252377cb9a7cefac13379b51395dbcf351a94672eb3ae50dde084c63122b337005cea3a8e09ffeb6f7d3a9035bb1d36368e8b6ecee48064bcdcd20504f8dd99d487431bb79636d42b21ee7b85f40c4bd122629b12705aa18aa60367bf77c6f1ccecfe05162fa09ed3f385f19b2c7b97c8d24e6e7d8a96d73dd4e864cb4db83eb05d4a9498a86ebe78266ac7e85edbff213173d38a478cd6fb86f41d5a81503dd57c6e45929ed75523a1ab87e6424ead547748afde06910e1182379840545362bb16c9cae09fea5d831fdfd7ae159848844472b148ad00aeed5a848c317e5eda1323f8198de33c827d373e5c5007f37acef292059406a1227c9b5a8926d23d80910dd44c19d50e9689275282bb929547cadf9a138cace8c9781af056a2eed799319427355b10494e7b09435d871e7b8ef387e663ac92f7477e6fc657591170e02fee50014382c161a66557ecf9da39691b2380e7ec1c77bad641611d83e7be113755ca002603aafe1e316f589bd1b05465929a23ab19905681b0978c68af1ccc8af5229bef2384420411b8e25413ee7b70c806596ee2a35e9acadfc3eb90fa37d815eb479e0559a0f6b7228d766240323491d8b570f63695e8548891af7653062a99c24acd930bdd331848d59dc3f29599f7aa6b7e3ab506683b6e9017897491dc996ac4ab65f9e05c99d6f8d8b0582180013c2762e4df2744b92d8313a184c6a755f5f1f6bc7e8cd52d33b8e4be95761a98c969f1407bdbe1c1fe3319685e5a92cd479000d28d876c06f0dac3e62a2e94000aefef30c19accc5c91d588c21df7c7b08a2de38782d824ff2bf0ba007ad709e06cc11e87b15c073f280e336a490b670ca15ccb7783623909ddc8560dbd713193e93f9bdadde4adde5cb22143980ad738adad926a22125d56e1ae5993c2612d456f25cad78d1a2e1a1624d7097180653e039784517622c1c4ad423e1c53cc7ddc16a73483809858cfc8d78304a8c86071bfe7643d8bb3c2679de206776f66f470e0329c19f746f753ab37ae0ec204432c8d0dd911b7bfd0ab89cf357aeebc9acb588039713adb0230660689a18818815a649b491b30050774162e1ff51ebad0c9d0822d091ecb6de589c5afbd83c33ff79e5d8349191c91b345fa6ca3c3d05506e7dbc3bff9c6c469225b16ae7a5a9fadc50d65997f71aa86d643c6bdc6fad40f1dc12ca3a0dd26e85aea3fdb7842f950ea8c1ec0d8563dc8a63705e6d404d2d5120a0480569d2edd31614d540d46415599fc1c40acfe7249228c5a994a2d0c0adc527d9005506d341c9941b68d30e8eacbf7436c837cc91406451ac8820f69f4a97daf1e1bc9177d9402866b3634d37030e019bf2243b91a7e9018c3c0a405a38547b10110e83a47a35d125ae59d402db22f55ca49e813f57867333c70297487460f0a271cba2b929aceeab57313389bf7e5e3ab1de87ebf13eef2a73950f0574d1da0506198dba1c70bfe685f3735a7d3295bdec7040aa3f87de22f8185038440b960ab0dc0fa72e73e7382d0da1f50f505a7c0d73ebfdefd34cf89c5feea76cee3403bad97abae89e478140ebb5e3291fd337531c6204fb4db5ee16a73b24a223d06ffc8ae8105fbdf24a39e0a69562a3880be4300e4970228286f41f7b069df75f2d5bec85cb711f3199a729ae17ca34f2555829e5b3161c3ffc098af834e81b5706a348a35a764bb6e54110c7667241d84984f2d79865b2312a12ba13ded60a5010a8dae05c1f732e0a9f077c19c2bce381e89cc83e43d1ba0138e2bb5f75762ed3e40ec76f3c7e3b1fb647396a1dbe699714aa1ef81dbce6eb03a27dde99ff784045952c1bad557476ad0a99364e82e2c71b88a0132e80183c29ae468fa387d9715fbe28c2b627985dc1625bf7480dbebabfcd858bccd922796f7bc980d5ee340e88cd5ef481a2b16fff956eaee0105f11a94ed030ff95a8b0e608059004f094d98ce1d5f4d8f18dc33adc229c5da7dc16fb578037c230eba126f5b328f4f27f48e4e8072baf8f92417d6db2aef2be717e38c2ee349c0d231951ff8977ee9e8fa368e085cd31b16f63fd890cbe160c75ab8df644f4e5a66b1007bf3ec204e9ebf1f7bc1f452d2f2f303c6d04e2ea7683dfa26ad956e1c15a14a299da196a8c55a58a590ef8332de3ce708d5d0f15e2d2cb433c9c261247a0c1219e2ff255173e27a62b88bcfd2f6a628f53763baa3067d18f12d2c2aa14e80535aad81c51d97761362a91f63f452b0bf32240b3bb299300effcf55fa168dfa764ee2da899ba496bfdfaefefb2267ce9bff890e5fecb30ce1071f8e6f8caddf871f22b753730b36e6ae2bddfc7dbb5b0af3712df78816840a8e9eef3347c6c0154d642cfc085f95b21d056b844bc3845261540835e496b760a091b89cd530665fb7c926eadc31ec36632ec3bd7676eb863fa1376ed52b4ad2aaf415fe9be4849d05b2f2bbdd712ab0ceb87fc97f4f896d0cdfccffb6c5becc87005f1ddac7e834247ae357afaec124632abbbc1fce35151a135665bd05100cb0f7506942a6504ada54df312be325209fd7ef380b35d062171d7ef705c23006393c7bfadb1aa3026a90878c4fdd1daf4df62f75126d148db57df966ad0065e76dce0a2a26a79b98d18d0cb842d027112b63e1377c5ad5f11917d6611e53d8f50631fff731b061a5d5702ca6e30c4154f59ac0bc28006a54090d518b2ab75889c47368d6975fe651d6b16efb0cf2f3f9a9b2b0bbd675b38b7880044d2a5cf0c0a1f5e10ce8bb426b73ba8105370a132efe62938762ee2555d2a532a297035bea91dc5d5fcc099ec50ad2e38a758743a1190fb0ad8da691e4e0ff58bbff7e367f0a09aa98f5adc2c263e2d110a37a973eca274b3eefc1c605709e54d56f59a192d6842f59ef27a3f3900baf868ccd73fb46823f3741213929a008c657813ed850a208d1d46d20bf4bdb884c947d2f65d3c51f5cba571cf65b7aaf1ee39a165185cb0ff862a1f764cd3677550d5203d0734e22e160280f721a3abe4cc7d30ce7734d4eab43f0a7440c9c5fbdc68bc520b1f162eb3c76598a64e7f244daefcb3aff0831dffe3e3602bd75a057ed5d9b339b878bb521c5f2352ac5fb627b35536975c5510f4387c0faf2fbb98087d09b24fe2296d1e36d1e9775a890d7a20300d45982df9795e926021cb0d09a7cddb4bdb2396ae6e8b3d22f7781c8d03bce05c821e8ef27fe232c05473219e55fddde8cd5f4e2f95ad31b9eb7c56dc9c418177877f3f96d25af3f91d782d0d94026d7e9f02b771935da7b2e2f61f53fdfa08a999f344630c49f05c93fd79fb35a2c95e924a613b4edc2e6c0bf12e61b875d1e40a4d2578548199e75659434923c61dccab2017dcc981f9865a5866cbae3c5ca06fed5f99865df140e2f05ea093517a11321b1b3419f12cfdfb28dc80e7650ae09a08092b16054f431bbb417809930542200d1590d0e12e2f2463b881c08554050eb2c36148d9c3102f1d845cea74a9774328b556c49ce5ee683401f6b6f210fb0a33d1408056cd85267d8ebe3e87c901ceda471750a1d73e7b78cbbb4af769a824c30a3db98b6bdf05a8543bc7c3c51b1387d550799548c6c94f67dcd8a3939661650fe8b28fc467bc06e337daa3c3034cc2a36da4081388c61f0c29b4f3e865fe696734f1bdd00073201357aadfc71036a470703c00cc404d125497129e7eb9852ca4acdcbd7f23390bd37cc4f222daf7f055ddb4229aa3b4f7b2b81340bd0a0fcefc27449a838141f0ee7b15e26a3a932ad7c790d0161461ee3e4e03235d5a6588631d26c4877d55f0a3aaaaba7f5766fe59e2dfd936becd91e41033cfada45244f16a7e980d7552cf2596fb36356e4e9688097e1df0c6a9f61d827f5505784faa5a0c332c3b84bbbf38c2b03394635dc3008e0514d28c9fdc4b0796289081fc00e606ffd50629fc9e3841d73cea9ca9e8c12e8f4881ff933bc9ca3bf0bf24f2e51a743431a5019a27e2d1ab114115876228e389ccc1e905313f39e00d35c6d54150c39c16c223dc1fefd7a6c9da99d23c01fe5b51694a545a5b7ab6d443e58773d9eba163ce579e0019cac8e5635baa1a1d60baa3e142dd5492137d1bb27bed3139b7f7e8b78903cea0512881b6d9144a3bd4a1733d4fcc03b118e6d861ab87fa44f0459eab97634c1e09c89a348d13451d8ffd72bf7e87f3798def45dbeb5f1ae65d6bb81a75b6b697c0514323ee9d954c29e7a4a60f14517b6f82d5f4724c19b4023ceb9e865220794bcf43537ddbfb5dd724bf3b88906c1d3a21ac5f9da5baa77778915b613a769138b7014852752b87de3151d0ff1cd8abbb081290ef566c92f81fd14263cb5cae9eec6185cfe3298a1026e09e18c4e58cf522c7694ef51ec9f513216ed5a2397b6f62d7e5dafff78bb08b3496e899d1349ba2c66bd20fd9967e7b2f49bc0c62e6a9a43a07837ffd32de8de26ff09531dc6c4bd39ff969ccde00e67d7525a39e1e6dae23cbf0a89d21b8859db35e0d6e9b29fdbebc5f852e549f5936f8c6cc2fd78e172b7b6b8065aad4749ac9762e725722e5673a200b84de151be7fddd41cebca33d156c9014ee3eebf453f33aa5db0ef4336a33a50ba78f3519e194e87ed73db88fa95441572646926aeb37536c5a2753449bb99b72f85a403d2368222aa6dcbc3e20457c97a8343b52fb8417359c5c082414a3ad1755b6ccf814c3f0bcbb362580b080e1e47c4af8b9da6f53c19ea0fa36f22705ae4b8d688907b8fc5897b56658450635f6e91cb1edb6eb7a08970036b2cd4cd1f1b6ad51245f25848709c0a66db94877827356058bb94996426f089c83634713da8eef9558e404755227caa57fc81af30f60adb6a075229b7c7f426073d4d79d2e54bba9de3bb76d6e071c2fc29867b8ad4644eba985d719428a8c0531610a249411c5d300ead890f8fa06bf48d6b7f917a033d2d816f0481b4030d7ef61ae27c6149d87e88cbb76872dfeee4b15b20f1afe16f6e5bda0d5b7b250eca774a5dabc4706361f3f16fd293741fa898722d4228f5ad92445a99367b021ac825466a63167a14c9ce56c174c284b2b9ba0bc267e5231908ef244c3bab830459e3313cfe2e69a248079cad09f481dcfbe4c02acb3f315e3d9d4f888dabd6aa4bc407e79f1b7102da0d90ae31f16a6f5bb6a930d2e1196750024ef920a4b1c99f57119ce4f66911d29bdd9bc78574ce5f51ed13fbed80f6777e55e2e184be9cab2a11559254ef833709f2581c73617d3580fc05676d28f3ef5b8ed0cac89e8ed5e381928a2aeb7f3055e8a683f47ffbac798da34a3b97d5c1dad824c142cd01c5a8a3c27a593ac24504bd44e0ae1be932f854c148feb4d48ff5e47c4297f8bd48afa1a9d607994f0e5103f3cd72f4e0cb0812d2611593830177c0cb040c4a8c8cc794ba94935dade02df4e02c422180544228d083d7ab11e694d8ee1391ed37ec11cd790019ed2d0c68aab4709c3cb601af2bb95243553674d51b8e2c3d6391bb611e447d81869cf88d74c3c78f99b185a276acc36d2c74cc502684ab862be1f8b77cbbf93ad18f5ae92fb2971716af93545ec3671f571765f64308e54df5056bac75ddaebfc28593ba10a553371c161a144803383a662a123f60dd2a56e200e2d9412c61ac6c02a71226ea0594b046fe48a5a5559a6f29260b17538a5c6d3af84d19438a8f8c6f5420196994f99793f765b4ce3facef3aa858c72d8c452c3ca10c0b596129cad67fff9d80dc372bf4b28a21870f6d6ab8e33986a36e25ffac733e9a1b563bc41d2034b0137151e79cf801f54f935bf8b6ff811ef59abb07e9e75d7a3faab4d4892f43c467d372f2042b6f35c9781345568b51c07c4424c435e7fd7123b628db5e43067772ae8ce5de29edff0fc672e4ef86bb85777b0e5f3895bd83562734887d9ca114d2f3f3b0b6cd0e50439f51309cd983d258d78bc2f77a332d7a563a39140390bbf87d6817f4fa17e8017518d04095d3dc4da120f33f1103369765e1ee79cb066534e2428db42f1f2bb07d90824526adedf2c6a956441ee0f66b120760c56315a9c91cbe9cd44829ce3ff813ca092c10b54ce4266daab4fa5dd242c6fd29a0a9b9df2f1f1e701df81cff3979892bcafdc865eda025a447d7134825c16c8090897f72f293a96421eedc5a4b71a43c9d02d72883a0eae56b85f632b77b5eae5669ca83de2f0b36a9dfbf0f00250b9e9d20228fc8e663112960e3790e309d29c6f69c48236c6ad51cef7b8b79fa9bd43857bd63b68d15aa4678f2185fa38132118958bf55456d60590bf925b862a97b2db0bc73e655217c9ad3604b8d29970bb94d8ffb44af5efe59d57ff15c25205ab60f76857a688430126e624a0c75595ed6361bf2bd03698b80def732c3fc432ded122dec8253df31f4595a1dce1fea552cc5652f229b915f57d5f02a11f8703b2237f99f1a7c507bdd6ba593212ab07afbe5afd3104a716e07434ad8849c4e4a20b8b7d43e7982f3bf466d8b97348ae0e8cf5774df811467328c2460092304efa946bfcc8d17bdb9704a9af3b8555b2a341a4d28966810623657419aa28d89e6dec256c4a7f8231b97ef1d4645ee1a50d2ac051a72bb9319ae309b1630de5b8c315d05513c38ef416be92587c60332fba71f5c4ecb8677188279b2ba01468d94cd9edab613fe4d38fba06c5595860b812ef4ca660434fec7cede59b6e40250d0c3ea9ab262e5147e83c620067395fe36931671d5c2f3b551efb8e0fc181c48db5668ef1da718d9a9ec110286b9224b89c40f486838afd5d4b862c7cf809fd570d7290a926247d4b5b40021c480f3ade2e465f4c7dbcb92af91b0882e55102e5c3b895bdb343d62b34e45643b8a14dbe98f933fc11bd077720b124a45c5c78759e56ff7f2b5eec867920f21515b14bfcd68b11696a0f9e339acca633ad0c29cfc73be9d05087faf1ef593a2c2769a19ba383cb81e1b74d4456a24961b108d84f6d338567c928e2945b59cce6e1416d1b16f1e51372e91d2f7c512568242501eb20d02b67e69b7fbea5f905b3c3c62c922a6b226f1761e4e5434ff8c8dcfcf6ff7ba85ca8894c0cee2999121ca685108ac2e2c7bd72b5148500f714e23a2efe1a0f9dcdcdfbbd62e2ca5cd4e999a72a215b3e26b87737c6f666f7b8e9e63f94eb493938f96550d5765114cf1956e1d11a02ad7c88f62e37c24ab588bc16f30aa6af8e3afa8d7a4b931e561f30cabb630c1c3442b7f1a5f16cd8a56414c13e963d3817c5ee0f28a2d681f34be08069859fad784bd0a1d0b97d82155aaa83870fd9ac291d0483bcd8e885b1668dccba5978728685904746daef33e5805f4b26ed6c2439b3b34b7fb7249562dd02d518319c391fb1332523828cbd49767d25f29b7c8b9e9a9a655f606fcab12e14ff1ec9657b4c96106b5d418922d117560f00014fb8d9fb2dada2d5e440c75eb3c766807aad439992fe987dc2ecf60b3b9cc7017d6ccfaa22bf900c1f62da1acf25a0f909dcfd48861f9ffd4eca2c6fe1f160c6fe947dd7bf9e2d1af5cfe82d09bce2c73498fbc11edef5af17ac9edfa5448c6134b94ef62fe33d732192836b76965a1bda43229a27ecf60012b90429b73f929e5c330ee07b2ac6c145718200533b486955b9d348a0ede957eddfabb1cb9cfb371c5c5b0afae5c0ea97e79c1d5488639bb5c52fefa556fbe93cb99c5fc3c5893486f962b0b881d31e02ecee662e2e5cccafdb9f79463afce9fda5127551349f8a32a5aef4d6cf0eea3b013841b2ccff60fbaea3226f4c50df42277dfeb63e208dcd56e6aa363cb2bc3b9c5494cf1e9a239f7cc6634a795efe84f7f4269f10e0a7d8f60b086c8adfadf537dce509360fec24341e16b38f63e4807712d4bcac4ff47af71d4287b198a98419b937c5841e4831bfd83799103370627f37fcd16d31b0d31a864a7589c0a6094d13961fb18c0aff88d60408f9be3c347c41411f8230821779f8c8198d4f2694025cd6aa9ebf938026f355f7a5829c31960d739a8b292f9856c1586009c40b441b0b64c5a5e3fde2de815e04f893d1884f9a294852e8e1830c52b3bb997bd7449de7b57cba99e2960984d214b6caa3041bf15164e7749ad353925f6b9e3af40152aa6e8e9bbfc02a8ff0e736da29c29c3e367476ac66858fa1b0e7be447fd6937d5bb6f5e3c9da46c28b17a48783e4a1f6d09d0540757265d0272794320c2c5b3d5e518363320d3638b0e519e9731068dc4abc2e65a2d702435f6349eb0db7e862fba3d7898d1b00868ab79e835a0d7b185d612e3342535e0d28e6f8d96b29465b371015965e686fbdea732f481a3e9684866fa677f2360ec2bedfb353578165caea9bc28fe00049c8337a228c6cf1e540578ad762d79e690efe43c44a386d6661edb77345ccbf9c5160f748d6991277562af4a781a9cab2dfb31104385d9ee79998ba5a50cf64504973f3bb2a2b43d82aa0bca694e81d97f576d75ff3aeb31f22f7a17facf37b7fa8a0d19b344cb78ea0b8952e77d9c84c5b2095901df16e61226bb5b7584ce51355a440fe43d2f9c870c96fd1be2ceae150c1e8eda5694bdd7032a197f71e03357dca86cc47507494c28c77a894c0ac8ecd42c9550267732c92d2f6dd9f255fec81673ed944055e81c6b278f4d00f9787cd8ec5866b90a68fcd094539f311d63c7dc83bfb27285d08bd322219e539ec9a62eeba9e0a891fdd2ab82d0e8ec3e19ee0844cf73bbd8a5a44f8cc8e3fa1a7de80e79e8f291b652f76bb70b9e903112d55261cda28e392d71759f3257d0fb14fff0a078d7bff88da5613d5a64067986a2fb5b7b39e5ba06e5dea1a682008ae90124268aae337c57affe75a3ee781c4e7ce5b20930b882d928826f1d59a6c3ab78fa8ed6d826f3421dbef5b28b9bab071b9048d1701766fad9b806929f98fbf9c1780116e11b0836fdb00c70fc355190d0611ca331bb421f6483e3a37383983478a624acdf4f47dac620ca197918fc8e3b4a261c47f2f7acfb8c00be5f522d1c70039893540b2f53644a1872c91bf05c669d86e6d19d751e3f774e9bc0e1c70896d92033b198e2e9176e928eb7808c9a9a5d22abf6eff6f3dc3c44622c3f5abd2c3fe374c8861f2990ae7cb7608562b157a4a5d4b354a16ad4bf78c4920ebc89b6c38e43d26e6e4ce9b0319470e9fc83ec8cda43a9cdb13fbd8631587fe5c88e1621e779d411992a509aa4d55c7f81f20a971a74929bec81e8db3364d70299e48f5247da4c6560c96e18c5a5d593c32fd68536a2f4f14d2ed97bdfcf86af92bf4ca9ab36a03c563103b4097212025741e008445c970f83a8aaecaf69fa32d7ca85e51b5c05743c5cfeaf2ab7cbdc56b1198f6767f45b70d5e8dabfecb2097a63bee7b2d0317bd8035c55b63a40f2ea8cd3e9950c2f5ad370e2043877d86764b8bed193e5add05871b5ae6e2baced77d5fc5facb32e5d3edaaea8961ea2945dbff95ba373bc659d6692334d47f8336f5220f509f2d7ccffb934562123538805f5fa536b5412cae4e25588f8c5e0177f727bc976cb721ea2b07df3c9c06dacddd4b86e871f7e92b1a7a44741f6a17f125ff2aaf46fbc85e9dcdc70c127f164c740d4e091e02bdc1cafa2af6ae1cbcba7c94821a91ccf1a0986dfec072acb55ff9f95f94ea271ea77779a7be2c79155d1c3aaf4660538952c5d3c2d4dfb8cd469ae24c04d343b4edd141645103b470445fb71443322402f3b649eabf7af9704a072fc1c7de3c18fd08ac4b35fbe44ba26d09b29df36e00490574e3d21afaadcdeab14c14713ce226de37bd4d34f51c4f8e53e61bb447a1f31df6bc6f7e8a5208a8ec8a5870e8ecb5ca1b27cbe0b68f7a94e4ce069242952050808b94225732ecb4f26449178faeb8cceb1376c970d4cdf4a352d0c3b11ae9c7692be79bb005f1d4ecba630d39ce012f82ea15d8f26cf2c4c3bc6eb80db315ef72ffcd1b8787d299831381f10ca6a59c7dbc76cc31963cacc6fe59d7fb9e1d60ec29bffaaa553eae3c7df5a46516b23fd8e15b0cc0f567f77139ff0821e971907e718da9d3616b70663f3da08a799bc956a5b210ed83def9adc56ffb0e468e10ec8f59ed610ce6d3fc4f7d897c5bfc58190d74c2b3b75b212e49a2be1566ab0e6013119ba27fde5766ba41ef2485865d1fcead22d7b4fdce619b8c55655482dea6f657bebc2850ba1d8d270e36937051f63c2be49b6b9a803f0a472b3be0db4240d52d086a06918d74c9bf16bc6e66fd4dde859679f1e83b55037f73274eba600eaa5179ca9cca1a912dfd39392034dbbbd8a7cca8b481ddca7e981e82b92f580d062ded9f73f91ce00b81995e875a40b3f2bfd13911fe590bc9b3800a8878e37985bec4129c48549bb7284db222d7828c0d711c786a35aebb512c23453979e1a02e7fc6c3aa9a758375712571469143afb9f20e058fefbf0cf77ddcbd2e5b8f577a2b62369ef1c79ce2a2281d87c0f0e3650333bfa8c078d982c6778f4b9d7b9e2f5b62c28a9376a8ae50f021d03b0f88a748774783fbd0109cfb49c5fa7f7d6465cfb1da5841a97b3004c4167a23b10b4b2cd975da9f5d5443047291508d57de473144b51e2b9b92ffd771527da292ced61aeaea4300c45fb8a7ca9b5cc1b409803e31e1c14a9e43479c33f13fb38765c52f8c823be96af0fc27336f9597c586f90bb0898771b3f61d60fed19480623347db07c8858469e1a5c37f78c155b9a528405812794e210eb355a20a9e0dde7d1b82ddcc866900f22b4a712a9103c80a287899f594772b43514680997b13aaa2afbe9f2e2753a2ef3ea7849f950920f2cedec4abf0ee9eef4ba3845a0fb3b114b7d7db8db4515a07ac913788b12d9e1b4cfb769baac696e8cc338bdd4ec31e4e1f2806f8352e80f64f997d3c8b05c8f192a6faa4eb39acf8b5dbea3a213372df26fea41cc6fbe307f56db2522644a135dd0a1627403b9c760b525185f2184acd2a28f6328c14360f3c592d666438df7a0e2f5ea62b9bd49b42b3108169d0178ca8a11ac9e3c4ecff816d280664abbecf613430d2837ff4b7eddca60a6134e04cd6aa0948c814fc8bd3fd59b52fd71a387940d07be724f7a3324a12c12e8bf3863a130ae48690b8f0f24d29d08afe01b2b9fbe73a53c9001eb0f3604135e092c00929c0d87ec55b9baa06f6e38b2bc94bd4f62bd755ca7f1ae79c1f75d235ed14458b91368d48f865da26f720d6c191b367a6cabc993aecbaa5a3b2aeb03a9e00039ff78a826f9fd0d8061e479d7a8643bb63990697d912dd993c61069532a1cb4f716c187bcd85ee8cdc20a7b0d359f6f46cc9b3a5c432e1eebdc20f803718432567b9963c81a4c96fc192294314eb696bfcd87f704f02e2e568558579d61726f188fa59c24db5484962ec620f884f17947c30976253ef87e79a30b529ac703bf4733970d96d17615ced39472d60033b5386e51cb1c2ea2881f7445c217963ea92c5f1b527c342ef81d63f8b087bc299fecbba5841c7e7d1a8742943d30ac0ae5916a476b00ece39fabf9f42aa1b9d1c44e23f67e50f225ef86d0537ff6a052feb1ac8d32273afd3205f160f1e2f3144cd6d95d25bde2ab58ced48848748d73e01494428a4a6a9f8aadf5c8c5dc9d76bcb96912c985cb989529de715e54d038a6a25dedf76fa80b861f61e564a9bff7df4c7b10132dec7e319c45423a259c20eb360e435f0a705d37c32cba7cd6238b7c1bf2e50901eba3a846c0ef71b0a599c5c40346c4e681d6b051e57e91285b9d54c781b2ff6c5b6188f4f546ebee84b39365f4978f0b1fcb63a689eede4048abb399069a92ed83388fe1f77f0d908cbf6d49752f574e22b1ad988a6a6919cf3940b236dd0cf92e881ec0573cd33883bc4823748faccfe7c4057fcf0e8573b4f7759e5833f9de1953e349c823b5165b2287998d75ac28d2323ae43a042ec393771ca3bf7c90e7147309a388a3c021bb2c85ea5277ee19e5bd86765cac6b2cd7e7058ea80491cb15e57d470a8789ed23b38f62a0f3f84adb698bbfacdd4efa761eafae927dd7f2f5a727b69bc566c62f361c3087e8c1d1ebcbfa451ada2a82ce4bfb36bffa0a9efd9c2b91c39a1c5181d49da104b83e590b78d32cc7546f6c71cde08f75cb94ffc1b3abd3cbe9e5ac18d4eec6952dc22b12176c8a2dbc57de242e49e0b05137ce8fe4fa35b60c85f0abbdee2f24f8e04078377d7b66f6e13208347290a114c11457b14489182bb19bbaf842f5af414e99f9ea3b6b5965ad632554d8120d01a6b753c9cc7216c7e75197124f24c5d45438e86905437f3e443ddb7520545873ade2a7f81dbff3aa2cc5ad30b903a57040c2d9983e908cfe43b9d030e5e895c396e2a4734bca45a20db0696b5b4a7f8e502adf29b25bb242e4efd70ee44e18199a03a5dfd7b1044f72f37461bbf274f934d4c2a045225ecb7d481f17b6ec1c0f4f06c5cec16f0083c59937ad23a72d44e48cc7bf64e29c3578f4305ab4e80f168f9d1a275bddb862743187fffd52248069a3f9a8af0f0357ab2f3aa3615edf4d5c75267c1dc84d3c7bf9f4ade6705e22429b2b525a6244163a8b8ac28a34d89e6b0cc6f9e3308e12b28814804e8bcba3169e72fc65a2eea807e545e0b779a3524771006ce0784e5b0710c2a34849b7ce0dc43032f5267f62d86569f9500d556ecc23a7b89d525d56ca5e84bb8383c5cea07d2ad33afc8860a4e62cdbfd9caad504d6315dadc4f9a40f4e14bae7beda43412d728ff501f59e4f2ffacf05090319f87d8fde497d64e3deffac917785b10e1926d49293bd101e35a08925568ef104722c27eb34308b5e1ea9e18ba9ca8b890398a524cf4fe6cdad8ffb94fa4aac5f37452dad3b4b288a09a08ca8ef57e4967cdfc707dc9c995d633ac82e594d9819d889e02b06da4147d04819b34af96abfe62a3c048b6f44210c6640973bbb645ee21e13777ee91f017c4e2d58f95962bbe465b0daab89f9e4121829093e8f0588f775d4bb985adb5cab118f6700bf8ad6d931c33d5b31250ed86f82d1120ec0f06678b5244e48cf32b906a862a047fa5ab43fdc24bf675715d40706af37a89eac6480a7e6667d433bf659f893c8f603e82553c2ca2f5319bed02464c8a93693d2ffa0eb621034304273955092a7b5379525337980903615f19f04c0701ace8f23f72957ca303b1d23e61e0dcb995a524a3aa3a24e86cfe89a51537b93c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
