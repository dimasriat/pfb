<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27f39a9e9b2d2883aec5f0c28f2359c8ddea2260294b7dc6eacc5e460dc4542a7d02aa166a96eb51999e8242fa9f1b46b45832227a371a19affb096e9c651a097796a119e408d6f201bd332b78c34d9e528ddbe3508eb7f2ec0c2cb73c2b4cc8604d3ea7da0d359540060a348fef7c4f37281fb960676ae48fa556543f02fb7750e49e687f9e4fa260768cfbe49c0f0e265526ba36125fe8cedc3c2b3b7fa0d2ede548305c8ece5898c61d3e95027e18f87d4a0543a891dac6817335824cf6d66db7adf4ef1bb2e05deb52e365970138fbbda2c54f5c012b5d652cd03a9aeacceab524de1f4e37589a62230c27042c10e91d851455b2fb725beb5f755d283eb1debd51079a879c3f7ad0b48b4119970860760f52567c4fc0985e3b53e950ad1de0e3c0d2aed125ca4b2ef8acde1c1ba98b3ebfac322fd11ba253d9ee49df0de3ae27ed063428280b39ec21194e834195073fe5bd0c7aa7d6b0fe1941c5fa3e986983d8a531d60a51dd76e35b6cad73ff6f2f3ecff8af32191f14f4dd3573309252aa8b6f51a97737a8d05f3876aa204f2368b8bd1e4721f0231c71ebd3937f0de943894ad096fd05f806ee1c4c588eb6f0926f625073dd5145762ea765d57abe5286516f3b8e84373287e49c9929c70a78b044827024c4d32bf3174527367d5935aeae99f9b1af22148997b377ee878b7bc50bb7abc761825ae7ab58fe60fc9c7a1af7ac2da032760911eb25428c71be20b0b7f265a48eb3ead276b31d34edabc0566c2447313f246f5475a5dabda79f4801e890a80a47d52f04da1573df7b795cbecd56b3c192c4607208c6013f4c6bdd57cf58014a8e5adf13b8fe698519784fb25f41483bd45c14718ce74857db1f5d17ddf0a0c4f914cafe10ac8dc1f7f230e06d53f2c94c377521c7e2bb2fa306c55980d7fe5b97dfbd13d850b6ee3a2d8bd851ff757afa97b927d296840a93a1e45fb66ade9044c85fe5f5350882316201fc86c553f894ba74a7004beac0f2f1a8a74d63fbc84fadf3f24f8ee2b0bcd2d7dd4601733e967ce8e81b977902e719b8ad67c7b8c56ce4f6d6108a5e29dce3b954b1c3f123ef2982643cb29e8177c8c1bdf8a54195e5113f478d6e9b91b5283a12b8c48f2979065ec0c7d760b3679a1eb5d87bed48cf7ceae9be7c96c13c5a0d2afef9e1f5940a86077ff2de9bef430a1a9611f7c4324cf3d149bdb91a687259c17a4e137f80305cd88b5c7d0a9511968ef361d82cac46cbf7045983e4dbaf9eebb6f8a347a09e6cc17e10fc9305add015420356ac2111a8979f5a78e5a68664c5a5dc8951dac9ca5a7994b1a4e816f1a131879f1e7539a585976706c10a3835e1357d6c7531f5c4d5c45470673757a477c25a6c0206c208c1acafd6a883b0784f9cc6efa625ac86641b94fe6537b05030d2583f150862d189dc538946847753c783921c59d5e046b5a50e2e30fad20a583718a8212668db341737a8accda2a075442846bd2d87853e2600955c75a25beb407a27575b132bf3b8526c0a6b7659769824d24b5247c5eb9aa510f3d79ae57e3c9f2a6a04989eed3497ca301f51772052c41ecfc0a938f152622ef51a108221cb2a05f35e1d69b76127671d966c00dcdaa66565acfaffcf1ca24968123ae2a65f169063f81f851a66c3aa25806737b073261f95b1ba9a1079b59a4ff17f3991b698a79ec7ab99c0bd07c5ed3b130c30a5535db2e43f6387032dd1b9b55f2e686af0419bfa2dd44a04e7fdbe73fe085711fc0a3a29cd415dd4584217846d0b347472f0bc6901ef2ee883ce7fb8548a09f41245a30de95323de5d456aa7524ff1893c90a32fe33e3eed93fd3268fd6ef675df2c3431dbc6882b59b1e03fa5ec25384525eee407d02b771a8d2a4cf916828527130fa05e21f36f43165b867f321d14c57ac42631b378e20c6e6d5a3c914be1f0329f199e4d59c52397224fa4443f6bb6b1ebf80d2358bf10077f6abd804288254b91ab86ffffb2800deee98c3069c921a02c22469a9a26d0ec0b4b226edb1cbc52e104307f1fe010e672f31a4eaf3f1bda72d90503beddce6fc239774378aef19ef26ca457e5db45dccda30b42e6fd9f693a9076880f43995e4bfc5fc6856c48e51fa6064d23ff1a8ee6a998b3832d831ba07a20723f41d254541e8e724986b73a3aee6b2191d8489ad29962d86f6b63da7e711c766be519459299b2b42504ce112d4b7c3d1844d230c8a2f6f69ed9a3318573b80e1a8d641332af95a62682be0e0efbcd25fd3abd1366723a98fc6f1505528c090f108120b6c3379a1b939996ad6767e8700676b3ef54b532f62c3706067e989ec6a3cd6c24901092f1da452892a35f9183922ab7386883e25ed950775996de7d4d013e4930740e27f07b2ebbfe989c20fdb0119b61c75d55e4ab2ab2431e8b49b7fe85e29a72ea1c48e1030b28a4e7279c9baf44168ac8ad17acad49d42dc736ac8373902cf077d12a8a474f98487f024e15c9d2929c4a527d380baac7bc3e7f23f55992ecfd45d3795f0505c2e34d5cad4eb64cad19e5d73034fe79fb3207bb8ad8454d738a10abf738f18136ff3d32da99d83872c7d254fe3e8dfee1accfd2e1fe83be014488e8c8daa976e229608626648834569a63ea946e88f9f64658304da735a4a772287e140dd6f0c74e8a018a7c3d7c3b4a7c3478260b5a0912817243ca15512e1b1a2c0067756a5275614e362bb748d87145c0b15a1bc4d41c42a56f58e7611b654dfcc55d86d413bd94509d7f273352a238decb650d3738831180fdd1ce9b45faa9d13ceafc742f12744142d13de40302bbd61d5e59cd4850310c3609500a1360f020eba93ca5e513e4a6b26862ebdb539d8e5060f52a0a67625fdb3577a1e3209caecca38b88f19ca2501d5f12f7a881d024ebae7586c6e4fb3319082d4c6379b8d630a017745752b29d6b7e2182733d750fb972a5a43fca386060f2b92da5d06ba83bf2d2cbe87bbbaccfd5930af2489887f7e8df97b0edf3036430f8052937f0c2dc1fc498a6116f9db528405301112747b98fa558c065a9cb4b6cd10bb8c62a0a3cb29584f9ff3edcc508ccdfc37aecc60e7dbb04894bdd160b3a6e45a5d8f8bdf21a626bc0993ceb75a9d8bb308d3b750225a5643c80cd04521744621bed87782e45d5b0ecd879b8ee90405673a45c3daf4f4396b651f71cc2944eee964d29f33b3253374712491868e7ba68162294eb35c2dff30764ff52ce036e02c2cf0b725648af919121de837685451f59c494235ef85fe6c55c883e1fe92df6013736edc916704c5edd2caa36088df41d8d1ce2e772b29738767551cbd6f6c58a6960bcaaddc6cababe68a0c0a5d0d92ea405e99a29a2b887d38893d39a344ec4fb7557d80bc46e828b72a9bec7397730a9c70dc11e97ffa0a6fa4de3ac85a89e5951b527f8231a2b827e104aba88a43c9e09162ec78518cb8256bb92c3c211c4676ac414ff7654927e44f6152c0f031cf5af27a541ae4b190e40c0a782166f50bdc9a4aa621e786f1c2a791d792d99e6b58b15b0b2f3f48e514c3af115476af731d1027a3bef5229c5ab023e487f3d26521e028adeef7122a3c63cdebaeaa7bec54250394b7e429a2d0dc7ba3c2a0ce70de99602b933f530ae44e2f3d7437e060cc97b00d1b7a52baf777c636c92605a172cc4cf1a06e06ed7911ab24695496eaddce8202c198cfe1dc6b9bbf0fb15ebb5c2b8a5996db2960f909a95dd2c2efd2abdf0e473e6d831a254f2c0003728844e7380b0409a0c4e4e0fbe525b8f59423d87df4d022cee907e2fd29031856161f918d1f8b6d91f0a2951a3441989ae9fceb79b1a8023e0f79c29fb5546fee6f6a17ac720ee2bb5afc750b7422e6753372fae1abb3916b7f6e14d6f383094d961623fcbeecc035a170e63a8348756744b7c1fcceaeadc173bb91aad3b4cd1b2020b88c76861ce58c4443c624b1b55e57f0b003049cb4a42d69e0c1232570af91f1dbe63d003e46631d5e8091c0d8d22862761d0766a5d7ab2a67f275a38ddacde17fb0aa4c26f31ad0440ae04d2cf5fa195603fd7d43ef486b94b89a5cd119d4a383f93ea2c8c039496f5e8938a68e43b2214c89f7c62bc4f8828c8413c39813c0e46eff315addcb7e56f670194658058c786c095784168b3d1094caf64d2f0a9bd8fb4fcb9501d21d8fa1c11e13a7d7a2ba663a6018ff2b166967fc80fad8961019af33317c0c5c6b5d6f64a78c6dc032f2efb789eb90f316e873c04f8a3aa700eb228720fd1adea6b7569b9c1c30349c74fb24f99a95365321984476c0492ec9248fe4987c02af9652967e65d7bda2d1bf0a74b30b112feb1e0c2ce5ee72f6de7f59fb3893ca402fc061b076278daf21f172421bfbef858472cbe903b01f7d94611b602c5c97d031de9107d1d189275d464716fc3f978efd26ae17c3092f9bdaff9dc0c466e1f0834cb2126b31106aeabb055df6b9f56aec42843e6bbb23bb32997cb5f0bac2f26c3ded643f507d07351616f1738d0ea6e9d5b68d7c7820a975aa8ab0cbb70aa92a6e20002dd3b88f5cd7011523ce5d5fd72a8fd27b5fb29f04567bdbcf2ce60394d9f04c00ae9b471c256e8d4dcb9bf9ba71a548caeddd8c438382def1534d7be598f3b426dc6a243a590288c80b6f94ad6c6007ed2b44af5e231e387bc263d432db086e79f66cb3a111a3b3bb932e8fbd7ee81993b46f26c192643e00c31d9ea393d76b79b6936df95191dadc1835ac71c625dfb7833d007643971624d0c6e8d15e7e6c016d3c23b862e65161432ebf97da2da03aaacd164ff8c2e8a8fba468047e2aa2141eca2b13a097dc829df580ea836dc99f566a0d6ed95bc933353a79dcfd7e362f3f6e660363039b2462177ed2b56713d1ff251fb8cae58a67fd4588c28d8d3ba7571c81f7b98071c84eafb4bea280ee62aa3ef1e96384ed7a4736b44405ee9281bfbe43b290b033ab918dfe107cc71ffbdeb8ec46c9d9e724d115f8febf90852445a9042b156f10c2024636384b61a3f515ad9d3aa3d59ed962191159a37f38e93ecadaa7b67d410e3232eed469d0b388f8d9c2a965d6fba10f82b1f2ba7b19c18eccb4b4bbda8180b379a6b1401c66d647e8c67c1930ec189b40b9934339e09f828679ca4234fa984d7262e8b2bd1b66a42a2b77bad8e915771a6ae5ac4e4bcdc6ba9b406917ff9e54814a05e8b5780fe33aed33f2ba490773217bf837ad59c978071e4c58a44081056edca36143caeb12e03b05cc6d63b7275db0c00d7881eceed1482058a8f8409278771e4584b3b77dee77122806042ad58ee4e5e151e364e52c16b36d11de87cdabd254e13b4cd4444ab37eba419556d5ea3e96cceb480e492ddf1d06aa3fcb6e5fbdae2836aa67cef04b34ed4e4a5caf65bbf8d6eba0d56151e7491ec6dc0dc7c4189bf1cdee225b210f9392016c93f6614162e34fe07a4d245802a328d3ef99b9f7f04c97856d43f63cb0acaea60000d003f0b621f0a329a33874b7aeec9957f4432ed101fcf9ef03b955eaa7c8e5a56ba9d7faa135d7720bca714841302e45c2a0174dac18f6ddb4def71f64479eb632996f5cb3ce903f203e914b5ed57a51a0757579b1b33fd3ee8eec69fae4082d06f7c887a6139b523b69e9db7f23078f48cbcc9abd295a89748c64b0e79d53559b0b0a17f628b82e509e6f3c9d4843dbbdd5a39dab0124338a6421e799f29e9438100e0c19e3ca32ca3ffde1d278426c38078f3474e836df0dcb80f2806169b394ef84ed68983552e0e606cb6efe4ffe5427cc844cf9e92e33a2c27c41b6da99921304839259da9cad090508aa5ec305fcb981d6b919fe7b959753d67080811f12090626568d4883d93c960872b3b0b9bf20bc19aaa5b980a41a701391bdf0ec2abd220bb26fe80d1356010709752c7fbb43a7dfa051a4764c47644308b81a1bbea906da342071e2fe9d9b497133c96490d668616cb5a54ab293e9a61580d9954609408a9a6c725191370711fba955d1c0f33148bf317526f1ea7e3a1cb915a64ea536b39e0a0721077590d07703500462b73300062c3d668af3e7de174313784248cdc6df22d82c841e9851def1660096bc05558addd7fa278a5131b609c2e6063138a9aa4356bab70c7d4e3a67b07d952bc0689fa4688b155dd9efcb28bdc21da1f0daa1ee530e6d68ca0a3c27a4305836341cf397c8348c693cb85adc16cf35cabaf2c6634c0bac5e825a1726430485b3029f185d653b5847dc8cb617437661d40fc1b24d359d1f41ac12b46e1d5d44684b3717221bb87bcd3d4333f0ab76dea23f244d277db6ed923dc9cf5f0270bc31630b968ea043f3a19c7331ddf24bc93349ef00f24d0c150753a3b3b8dee48267c3f33dcd77ee81da44ca2bb75004edc0fcdd5beacb723ae06f254fea0e546a8796d124cc5b6bbaf0fa823cc119f7cbd2a0092acf5964579bdec9de9299a18d1d631f3ed0441d159dce10e764bc03c821dfebf62e47f6dbffd58d74d197a7e3362ab91a1834847ee0f42d31223ada3ce7445dcfa1b2e70f3b8b2469088a67509b216833242249bd24d0fc14915615fd645b6daeb63c876a63e8c4fe2b000e8094af14416a43c797eae47754abeefe03556e856e3921c61f1869ff9988a8a36700e4648e655253672e9d6b93f22ce8627ec7ff5612245df9201711eff1e0bc87c54b6e0e8eb50b0ae1cf1bd49a12657ba5433d25a43048cbe2f2f77a6b5aa24b9851ae4fffe64a129f462c168331f57a829b06a8468483c6fe1931cb10c9228f88b4d48785d3e78652850f9a5df343d74b160b2ad7b03233c3367271c20a2a01f5fc05dfc5dfe86b836707e7b7eca93dc76201944854f05a7dcbd9f5d19d420b0e74a975de2ad6984a59b5a051aef815880407640d5811bcda477bc0f5b660bfece82b019314d5f10b6b058b22975afe03d5587600206a1b9d1329425d738a60566aebfa5129ccb9f72c02ae34c11f390dc4d9b856441d711b40beab4e664443e40987589c77cc016b9a5bba21903b8798497c074bcd78d1b02597b646e831b20d47f322d78c5606ec3774c3c53ed44be343f61e6290e9b20cd57cd64fef9b048b17adbfddd2e30cbc586e4741ee76d8d01fc4cb46b88a0c03db09338f3b5d79e48ad2b0209dec56d7ce9d8583b23cfafe023f22bc85e60bb126fdac8246233506f37d60ca2037582cbeac5750fd05b663da13c901ea9dae0cb8067117aa35088e69280f951aa833ea46202757d7b60008fc3c4e36d81fcebdedbb67b3eecf72a12908feaab6a6766b9ed0d2dd06390fb63e6f4dab2058d6fc025c8d295da580e6142fb23fef01103dddc266b3049465874e5fba4348d5c76e2bc796f17d1309e18b2a26d5e2419433211faefad4144044a8972f6b0ec6a9ad6938d93b8bfb0dd217d7799d2dd7e1f73e35462cc40612fac4416c079af172d0addf8f36d5f51501b0e2baf15d4287347e90c779dc51622603d1f07aabde28f8cc55812a1edab27976320c94d5fabd7760af013ca27da91d107adb084297520112af28e3e6329e75b3aea08a157166a0b00f114a75c06b6f0c5746bd6fd1250505983f5dc5e951cec703f89b416feb3b4f29eb697d0e80bee8a4abe3895647d3149e75b452ac852b5d1459855b7dbec6d5ff174a3c738b1df1c90110d4c1fa7f6ca13fde8bd4880a637b6fa21192560ead7911c0403af693b87ef4a143dc38e98ffbde304610f64ec1ca6867e299ccff736e4831edc5dd4db48f463b9f0ba349c224b2ff5da65b1935fd9e247a4d2daca44394d9a8c7299951eead703a1b46cf6a48270fa9386c806c9d049270e1ba8595cecf3873c7f57cdceb757f14a6be1c57250b84cec23e1b17f67003155016549c2abb39ee1a288cba16e5b105bc3ca0fcb140dd114078cfccdd882bb390a2f58a47bd9b2630aaecff7ab6fa096171b50355fc9ed9906c6614aea63b283ef7f93f55a5daf60a0208bdf754695f1a550f5910bb4860b7589f183032d100ff9aae62f28878e307c9b585583ab71fb41328c0c070acf4569df3cf08d875297cd05f3c135a5beb99db2c3e56ec4e7cea85081281b91bc2a26d521a2c7100f9a5de24afcf7f3524c88b7cd98d3bd14070abf44155b818f7f9c5bf6171a3a64da6818cbce70a4c68b2296c77b24af450547782f716441283007aa3b29aab53296daf066cb87a08cc83dedda2e49b070b92737ef0d4cbfe6a28eec39d59e260b8af7c86467e329500bff1d4babb7893a115696c4e21fa8733becf2425f813a8b445aa9d75b763f5acb1da7401ec4656f3fdca360a619057e584065442e7535cdd6d14d88370e8bda1fb8f121856611697ea3f5b20b2198f4df02414938aa8cd381e7b2d7c7e690be133d0eaa9e1607e228d335d687cfede899a6f955e34a5afb247aa953744ef7fdf3eb454fbeac6533b7facaf71bc430932a89a9edaaf184e8d65dacb21ebe3c06dbc6e2eaac5258d10b39394c1e85bf9d26984c3c056bd8768d70968aedd55bd5efc428199678bebdf347b2d77e78426f02368a9bed663045b41382292d38424a36db13d82360e71a22a93aa35ececd7465f7e0092341eb50faf259b63ac80daa48fa61f51718790eacdc7d1df76725b1bd9f210f97665cc9cc780993d7b1bce5c8807b0ccd4d71de930af63195b75153af0a16925bebe0f05aa3df39b2cad68ba4e1dd7e0d5a37d66f4983cd2d6fda18b6c19427761af6340787d5dba40ccf2d71260a05b69af699494cd47a6e55cfb76af43cb2583d8335cf2856f111377ebfff8c338fc50b452afe0d5c42b93d96cf3fc2cc99022c88e83bd0686d1e1972e9b1037cf492aa373088325c58ffd6babf603551f032d3a04ef8ab79fd6f16dfcfe80334022676d578e233048e46da45527b9c1e71822c73abeb096ca3e9a926afaa5bcf62efbca7269d45dac581e4e8cb2a28be448a416b51c98c2a8f5982cbd967526d95a5afeffdf7c94cc5a368262509d1d02a2d1c5e44b0b6056d6561b3295e7e931111b6974d9fa1e83c7d08fb6e744a78ccd76d1efc79e424355c438ea2b227bfd0a02eb42fa5e047e7aedb623c817e0280d0d73f5c79b6c0d6f57b6e016a8d79c46e574efdbe7c6c752d0a72179fe0dda49605f76656e8ea473fe03cd66ad20acb5ee01194a2d13705fbcf8b476928a811bfe13675da0dabf32c803fddf02207d9b2ae7894d2d3c7ec5f9b85b2bc28f8e9698cb11786211cf0ef69b5e7c605ccae7ed047241b3da36cdc92be03871dc25b0ce54abfdcca1ff49d803c98d660691d253eae8a248d6b40ccefd87de424cf71037f91b11dac22a33db4899aae43e5939863d5a1459b8c3603a7e5ef60b8c2a37d26fdae826408355516715643c2719c5a7409299c9cd75f9be30f2086d7c30b6a3588d8f9fd31af0c34a6761069f4785db5db459076fc0be14a376f04a2e5c434047f4c8a9981d7895979eb9a0591abc66610dbee96770c86f69017281d42745c45f9e1ad1ea3c575f589f54e39afb59b45b9c3ffa947b7765ddcfb53c27bbfa5043b0e784430eaeaa4cbffcc12dacad2bf8cb68b81f87bc152c736fdc3e6b1be1be86d6afdb375b9d6332dc66bca0a39b68f3614c0c15ec9b7b3abe476811cc47c7842a3e38614f7b795c3fe58c8aca08989f8f2a959e9030f5bba09ae76064a30e93e6e0c64f2ea6cc4a344e349eb2af47f615ba8555d55efe2572f6584ac675d39232f18f5fbb84b38d257ae71190a90abc18a49696abcb10ebfa3040624666ccfc0b3e509ae30ab4cf82ef923fadc4b11331632e88289057d46dfe2997a142fcc7dd44d61b2abc4bbcf9eb34bf89d55d1cd7c792f32c8115f3951cc5058e35032e1cdff1f42343b9ad04aa7e7986da87ca093fc47af4a22c1eae93499e5e794b67b2c601d3c1594bfd0703b91e060b9b32722cd9b0280e36c3d9f4cb63be3ed89ad04179c737a0baa822ff420d64c1aec673099b593f3e707d5d4a95c1235eda7adf70506cd8eb8237d9af63ff626f1bfc17b4387592db2e7f7259dc2192b25eb6139e6fb455a9168776534c8efd6ae9a4376cd3eb73e519dc7639345dc12777d038daa471d42674eaa532a32b115932de601438eeb57707ab0c8583bdd85a6454e38a25795316eb66a1231551c76b6cf6eaddf7e3b2fdc8a7ae6927d3eb6de33e6997f064f6ccb59a34d273356a490ce7816c1f27826521bb1391131e479e44e3bce40f131f054bbfcdf79e0164bdb583c9ae2b1608fa9904196e2827ecba7985c5e13ddad4e5de3e3e7dbfcabfe83c697c4f8f6d0bf7ac751549ac64aeca9f7ddbf5fc25cd1ba1c0d2f1bd203a67be0165ab8ec8f4c41464b3fb866ff2813646e898872fb32865183433ad502dc82423cacda3e04bd28f3d16e06107227330a76b8237136fe798916395aeaa6eff17e39f9cdadffd2a154454fd9a88e6b9564d743bc6e57d8dd3090d10c8f45c29428b18d3a2ba22dce40d44f1e22d9ffd43db7c60e33af86c029148b593a27d00bac91e98154b18a0100bb8c1b234ce8be0adf8d5c350204c66d438fa4ac467ac691b88f18148e4b981fb3e28720046084fc09d6f95693ddaff62039dd0009a058255d06119445d9cd9e0284ba7a4f24e07efa903026eabd88509a17336d86a5e7ae1422271c4c6e031f918eb4c7bf36925708274d9f508d692403ef7a098beb0af9a6a1fc3b706e02a020d9e0589800ba481b3bec84aabb44baa69903eb805ea978ea897433770cf2d6a057675875c224a48aeacbf00d35a7f844d4fb22216a459c07ecf1a2030840aa0c0ed41e0bd2cd7f75cacd85c46c07ec2af0093e7b0495055a62ecb40d3364718c1c0d65924316ee7a119b965732d949d46004d294a8d9c98e3ce9cb2a7c37cc71d525a2d8d8464694a0e686cc3e05e5e36f9bc08a86dd48584b55868cb9d980a69d7d7574dde963b1bf6ae7e3a10661c91f59c50af7d2e774cbc67c9fa56c9efae9fb8fe71bb99120f9a6380acc9f988a1454f861582cd18c0669ccbe6dee99cf043fa742dfdd994026f0ac142d02918757b30ee5135432941558ab2b337772028e5b02498758be84b0f1376edf11636237ad550c320b5390eec7019ca0dd8ba41ed0b2903660a0dc23d279e9231214d10a7103a6fcdf9ef4e6f2b636aecf3f543a58cd42152ae276459a5492980ee1a05c9dfb560d93f1ef1ced3dbe70df6162f3b8d787a197acb2629c328e074e65ef4b258b39ce3daaee524ccc6ed437721cac7d34bc97afecb99c13ef7326c04fcd849b3659c2a24add8d5e72775916896f9022eb7e46520070df17b03d0fb66f9f78f873f37fcfc7e305f32c9c0c9c8d775466ee4b9a588ddeacb7cc9869eab1edc67a0e70422a18391eb359e4b5dcbc6dad9f4c203fec7c0c006f5534938bbbd2a9b9b47e90e6a22600a1a9fa0d5a255c67a313707f3bb3ff9b6f6bbe112d11a2932bd08fb0252f866278fdcabb683b97312e064bdff1c952221e4e45979944f2d39f205694eab33627a0dce74660b7404a786aba6f27c0bb77dcf3a64119f20ace3bf935379d10a70237aea55ee2f41a6a4c385b0d5b3b67a7cc08dcceed966e2bc871340993c70e1f601078661653030ddcad52a20f4327d31fa3419d3c560fe3da143affabf8f6cbdc9eac34bad209d438f203a0695db9b2f7e87a9d6bdeb30683f61c44a8ce87867ad8b211f1f79fc01c1ce8aa1db777f3f69eca7142002efd35f6d1f2a2f9d468d05258a1ed68b4eada1088671f6f44dfd0df1aa124d80d8c0d35cec27e6a1d07e87346b3409734fe3cc23f84bb50bde2beff1c6cd6b7fb72a62bc24d98d36adbd09a4cf57de4c9b3f1235bae4da0c68f24d60417dcb9a97dfd65c42f2ea407cbcda507e660c776bcd849e74674e90fa535edc4d9ff894b72a5372413b8316ba593f2208ad5f47452dd6f3dff03f763efe4a25acc64178b4747d49dab107eaa96464dfcbf8c7d503d50fd90629b050cc25346a57d2f69adad694c9b666c05dc3966ef241793f4cc58e4a3a0bc6a5454bb8ad7bac90564b13537389b79a74a50e9f1a988702dc24b28d644ed34d7e95afb0356c7d654a072f54897b73a8b8fff4aef8c483eee606f1abb8a1cc61c1ebaf22f5dd74eba6af3e653c4412fa72654d2d5ecdd862ce1d6b88e6991fb5be562aae4b3c351e3591772895a0f9371c4925096e7c80f52b2cb436e8d403a19fa3edf3a938db3a09fbdc5511cc5fe3bcbb65c1c35869ebb5e589b95f6bd3946c03dae7c3909411862cbad2835045e922f264349d7f8a52d855c685dca4ec73643febd50319e70ce8778b449ed8721321daea338432e344e22797bcda99dcad1276936244de68b6752410a2b3e427d6f077f838492fecc3dab20ff996a101bad596e49ec4b68381f1d92b40408f1cd82dd0e45074968b4debac85120b47b2250df001f7602b35e21b88e317f70d1d6bea73c98db2639027e01778bbd79cb0cb813b82fc9071327534976467487c7192c8942ec93446d0d176024df998730d4513d9f72c58fa56a7d967ea91183b010e80d1e82c109d2d0cc2f71f61ad25dd0400eff9511ecb456331305d6afca749b6c4aae559c6f4ec10248ce80831bf15035d82f7930878d214b27616d7c8d596fd6452db00d53552d3b08dccb950a1f1d1af8f2032c8873a021e543f21b332f57be5e005459264ec4b3acaec49e75a9ce65db861b78e84567b01d97e940b78fb2ae6f1f8250f4bfa64a362a13ebf9e4b082070c8eeb31ba88b39ee428bf81c18a538de109587b2e7fbcfa9cbcc3f553cd9fd7039453e0c1a4609aa35326b58b85072d4c57fb000a75e9de1d8a553f12f6f56e27fa160b4563d05fb54c94fc5b3b1ca84bc1fc22049cec7c92b907cd23d459283211c4a9f972290ea84c655655366d4b345aa6a59b1bc8d5d9a7ac2a61e70eb03c5f749e450dd2390cbddecce04acb49a030bb6887e8dad84da7b55034f5d0cc64518fe216b973a3584f199d701c71273ca0783eb095fbe115fd9ee457619cf697efbdd52e2659b6156f31a078a4b5575eff6b68bcd534575fb9f2d6a68fbb9b6b25cbf6128be08a279727b18ea92d8de87edfc21a603c399f54aa5a9458547a67ecd05287b80bc804247e5dd1c54967e4726b33d24f873f347c9531c63dee3733ee62fdd078db8945c9b9a02035d88f2e13ca5f256b7b854f12fdfb207c155fc0df59703c5e8ae33835744c10227d0b6a611b9a57a4917b56fc57b551145fda744ffcc79df177e24f234ed330205a448ce9522a27d328a8f3c49b8ede5a9b21de26ba1559cc891034ffcb5e409dc35dcedc95a13dc5c27364cd40a597862eaf0ff332dc4c0c01c03516a9b5e0c0395186cd501b90aabbed28a2927a749228ee9c9cf1cb54532cb7881281810e56016f71d6e1f8a9346877db6a2a0ecd6d37b62b52894789ec9d0dee17e3081764f10cb6e957cb4db354ca244573308b34a31622143b73f3baee0814194bbde88268dd9574efe054355ce067a7cd4558140f9915231a3731169083b4cd330a6a8d3c1bdbee0a21d993374e818ada30a0c948c954f9d04af1f5149c2ad9896ebbc9f20a03059955a227aa7c37627af6f53fe31298f649ecb1483b3df6c3ef16b4c5a7c79c30c70c00a99732f43546097a38b04a06650d95bfe7546160109cdc830cdfa8cbf9f5987cc83e0c96d419c3ac9ae655ba8ba8dba0975c2a2a17a9a669ad1082e41a7dd259a375b78edf78eafc434c64e7fc2f7b7b29d47efb5890abf7774b294b421dccbcecc5ea9dac053c28e89aa9def2222166fbc77e6920acad8ec6fbe8ba34071f10ee2335f0f6bea359b77d0a61b46ad28dba7e23342b96c0f02edddac34a205b7050b1e1f0c8daf5ca8dd41e00f66c8779b3d240aefc92280e34544bbbac74c0c9e7bf76d3a51e1d853b7bdfad67691fa784457440f59d0fcbcd48fcf29e42ac913cf98498c0a8ddb87b15a4ff6acb54fe4a6e1b87ee118cb25db8e74a9de71b3b59d984fcd2b54d1c47f457aa7c29d7c67997c51314800880658bb5f331df80dececd25997375c5d783cc7f71dfdf1ea4ae5620e861f176c78ed62a0878b9e058317185c0ec42872329f09a7c2cdda6e9d0195768ed16787f26f7f66a1b18c94e3954a0acefef5d42b551d0be07dc01955ba4c722ecae5ee8961c965c7681ed595348a3caa360441884eaed1095f1e68ed87625056b54e82a96edacd8d82633b21b1b337456a02dd5084cce1a7f0502dc8c696bb9fbcd77472b1a09d9826a72a055df7a9682dda4390550036795a97c18bba329a5fcbadc7e64f6e8e5b83ebfc60608afb005647ab28911fb9c77921bc815a2a9d4f4ef9a0392be0d9f12c239863db7bde7926c3f9ee842475b279fe87e57f44a8857d4357d9270abf64843509d96b2b1a90b104e01245d5913554e2295d09d2ac12420b50e54291a938695d6fde8fa9686f65f10597feda9c5a8b8c0f5a74033c6967e09ff74c6090fd0463d980f3865bde4920b698b9fd502b816329f7dcc780ce5a1711be428e6c3597cb2ca315b04ac80ddec14dc662242cb8d725130e2b60cd2d45956dbf0eb145f43d635a1f2c0ff10f8ae47307391f5a9e036f92b986ccf07e7e6378bf8188fdf466545c38c96036398a415047729a8aa42a6695371a3ea5f5f0813937e6a49af96fac68be61208f6754ff7648b44bc204b462f66a5ed62cb638bcd8efa81aabc9fe7f9eacc9e5c1bc5cdcbc6c579e4d5dfd4ff4c7c8ddbd1037f91db9fe373cb7a9ee6147ac503b89196663777b269c46b9f15fd5eb1fdb62f99f7f3bdf34b515fb037776e9362ca8bb833d601b21a1d14158432b6c8d9ae5be7366c873ff0fb32c536f7543bc7e4795870dc70d9d2b9e79cb26b1b8eebeab666db30a9add2cb3e12990f9e753c1f4bbea902d0bb09dfec4942ae4aeb59407ad4ce25a94be60fc021b16ac69ae59a59cdf0735eeff26cc69c4655dd6691c2012a84465a88090558b59da369bb55357e6ebd05483b01f55f4ff131d4af53982e5f181074de712f576b9393042ab69e8c20c5e138aefb37abdd001ba2925a646f1d84ec0203eaed86826b9b78e31edb8eae843e7d4844150e0fc93603a05b33beb93f88d4769f358e53a9d6c9a69e80b3948c491a501926808d1779bb984750c910b4cfff08f836f65948a3e79f97cbbe873f395c78b8470c742c1aae6a061424c2009b5afce89652238408a232b1c4c2929ed87bf1837f71579c409ed873512606bea08e4383a82efc791bde084c756dcf966e0bc9d8be5b7299ec2bee152f5b4344be63a57d42d8c265b5f8a392e8c07c0a6fd7a92585e87c5facf103815f0e94c6fb4ef33eb6a122463c053ff86938e78069b33291c1ce050597e42d2958ec02602a091ba5320f2338451791c3f29250d144a2da88a1bc2423467d45273046c27b55f24f72db6bbf756d664726afae4eab83c5ae0c26c4a432bbcc05ed045812005b9ff9b7d2925ee7b64dbd1f4fd1b4014df25c8ce7d276cb272dccc07b999880ab05d85835615f3c979c5d9d28c54bca86a81f6c7fe1492da234fa51fcd77ad7982b9465c46882a7485720eae51122a5b2fe39aaff3817db05cce07a3670316e8ccc43b4dc95bee289454419c110bd8f18749704fcfae7fc35fbf0adaec092c54b5cbcc7eb9fcd5546ca661d79e09b94f2c3acd49d1875e2e9b057623a71c6a94703b826864e611f1d14fdae9a254696aefe946b346a24839343cf0dcedfacee0e07f6420531ef78a3c39d7aa79f8c2ac46c2ea4fd842ec52491e86caaa091d6574e822171ddb7ece4cc8eeab1588b822cacccde094a75acca28bcabd1bd7bce0c95fb7a2aea5a45f6d2cb1cb67e5236ba3175b4bc9c54d88093a196bacfcd622b1c31e8e6d2ba02ee38f47aff82c38116a10d7df04cc3d434394332d0c04c681dbda7c311dcd25f56a02efc82fd8386d42dee6315bcb42c6167da2298006460daac5f8ac2e1f4a8cb1a60d34073b6991842063c6ca6fb8f5e9cd7650d53e7006074b733f81546573f2897d7c667d8810d33ce7142aa2045d840e19a5bfcea317e8ebc4ea2d24f38f51e895132b99b427cc46ee781deeda99d56650670620e415a08fe72c944c4ecb56f52918f09ca953501430a9c2f938a732ae05cead9287634be7fc4cc64257e8bed96429fe525ff7a0bf68784e98611ec4b009898f313aa75a07b33f2d3ffda86f1f0838b95f8fc32d8f6635d1eb7f2d9ace3d5de50d6db8067dce703e976cbded1d007e8230608c0c0aedfe1caaa48988c4a738ae6624d3624cf93eb6ad6777c02d21ad5f3fef51534ed79de7511d92255d99ec14430ca269e74d4c794cd816208da539311009e108ff14dc813d69b21fe58c4d3b679179727c6eea1b557b4e160b6c37282e2639a2d66a47b0cb248046f9c3965cf3d3fd6a213d7379e8266030333c61e67bf6641087991ecdf63ca01fc76ad527a9ea055a21e9aaa270747f3ccbc0231d8c5825b74391595d113e9ecb9bc532e4678f3b9ac9b000f7a13fd0dfe801d1c33617c6a2ff8fd1579f51c98a64d56b9bd2f34237edde9dca65cd73eaa47b9f383fd7436adc0ccdbdea0ab4a3833f28c872578328396feeab3e0ef28610925931106499d6e0cb3c42cb13b68909035acde2a0d35e14f68ce85275fa941d6f74430d1dc4b5cc152d656a3126c7feb42221f03cb2dfa7f22a4bbd1c937f6b8eeb7f0a61a63ad74d8b718c7639e1d24b3f4c60ec29b4f7011851138f6d1d665b3c15ce3db0da6e5554bbab5e903bbd563b8e96db24765878cb245b3fb0e95802dc0be2714c41f132a0330c930adebe1c322052bbc57c92e712b191d04f8081e500bc34eef4b0317129b10c996cfeaf4d65dbaa475beeb0ae65adf46772db930ebcf7a6aab6f9920b9e82ce3b13d3d5d6e5e8899295ab038f7f1343199b5ab600030a0634118d1dc7a0a9965ed6d2e36d6e58cb288b8889f57572e709e8e9ad4b6ca8990937cd42e9cc1f42e4762afa26bba5f3d21d4db8969f9ec4583f44cac67337301f9b9f1a93504bb1acf44306322d189691aaacf3be90357f79f505ebf008574489750703700adb3cd9f2b838de9c3b5f6636f1da0ceb96a12f313fe6013e0f32a5cfbef9fcea9594db404a03e0394ac684dc739bada6c74cdf44fc572d8bdea61c1f4bca3ab7c2a5ea8455b765a3f7e8fdca645886ccef0c3becbfcef27d93abcec86d965e542654b9057314dc20f8ffa7761299d98e55f86e89d3613092a1eb33d269c682491d0a44ef10febe81cbc4c49fff0e3b3aa186659fcc87b1ba479d482ea09b98cef6c7199db7c61f31cb644cad068dc09ccac8e2534182fe9754fe0e02763ae057f0ef372f8f6e75e4bda2fae06daf4eacc9d28bf795f2759d9f83883fc809c0cc7bb501733a045b628f2a948298e0ebef4b4bc8e347ffeef982ee2dd18e81767a4cf3a7f3e9443169865059ced1708fce52491c9f29ee9a19555a3009d88db7a9eae4a1d9ce7b932ec1c0628fb190d4963d142d24fa1ba7e2faf22aa0d165281b47966c5e42caec556606155fa76e83dbcee84950cf78b203ecc538f8454804ad39d25df4f16228372d2d26dee07b43669604c90474685e58d09d5f55aba86677222d35298af9731e02c9e594fd8188c9571d269f5d85e25f06e658a58826b8071254b8a4defd03d760ec5bf75c460715143a8a1e989344f132c5a7a5d83bd0ccd7b4be9ce9e8f8ba333a32f5015f982b21f72a3c4bc991bc4706139df5953746f8de8ac5b1e2b539906e0f3d35829a4c30f920c8ee4bcc95bf6bbf51e0d1a8685f2af84dd0f4cd3b478dedeb4b01096178bb69d0f4436a43d451e100e903e9e1ff7cd1b01a0a05bb08f7b2b62011f5d38a1dfa605103c4f7e125a6cd64ab4894c76b70d69043fe8cdf62592706e792957f7708618c79d0a7641a2715faa617146aef541ab5eb26d229b1a9191a7b85d7c946e934616f9889c909ea5b62c06915ddee8057143d57b80c4b58efe2ea35f47f6a9699d3a1658ffd0d4e382a44f85cf30f29c0e27c0f73e7775ae44e47663fb38c4aa37bc0819db9affafb8ce54eea60326461c78bb0eae3c1711af1545e76866e8d3e72097c5476fcde8d1a917ae573a2aa65d316ad82fc35979c2e658668ad11fe03d3ada67ae5f42ef830792fc43433650c1c86cbc9ac36ac2f3449501a4e12064cff72f7e94ecacbb9479958080dedd6cf623f3fe8095600d97b4aab89245b0433c949dd6e6a5085fc3e07c378490bbaf8575afd3922f448a92f5a8298d55b4a775a9d83c14e1f17a82ef787d3b040755bb5f7c438f64ce8ce0d342f09488197e16601fadaf141b9708cebe763ca2d0070cfb0c75f06d2ab74992788013bcdeefd039c3","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
