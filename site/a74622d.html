<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f52a592805ce10bd263872bcc9c0011233c93971251846fbfd9d37d6db9f75de8178b51529dc01d7b5d11ab92830abae3b0bc795f11f851a1d4c2d7a85d04f5cc0d945f911ca4e0068f3218edb0e928e4e484ecec5344f9a0948eb1611e27b7c4ca5dd013d12203ebb9d131bc0a058a77d9d0cd601c0fa6a95b8c2979f70c34dc2ffed285aaedab4af23b2caa9c49e06220f2ff1df9e6b73774f88972e46970bed4640a9352329f922f78b41c5f6066388bbd504aca522fc57a1db183b519c07c41705dbe283585dce61b514f9370ca9e240a44c3e9a9fe56407985587495bf3b4f5a1b230dd504913787ac9e4ceeec423c7ecb71c5b1e03f86367b8e93ab3ef8b24b8ee56fa2b55562869e922b090f5f169ec65d821e357db1ab85a3c36c62e767d7b854b5330e36e76b07a2e0f79aacb5f89ac72d53280fd40c94d20cc3f46a97f02d4e01aef9775af3b6c92c22bf6209fb91f7eb3e56442c6784400e557b6cd09068667273060753d511c52bb7c4aee95eaa91de971eaa262c99380436c880b162fb6933d737c192b25ac9b6b2b0a1224cccc7e86d6b2548448836f38cb0b2f8611ee1b091b097a66c78465914f515ba7dac87bafe8a78d8c62eebf1a9af5c386812755e5d28e25856e841a8acb7d39b0fce6e0d5a451a1682d153b6678798de33555358fcad0642ccb7598d87fc13d4b15b27a411ccbeb56742d2e7ab4492ef203adfa8bed57236c1ebfd0e249dd74ef25e6dc03f1277b175c372ce1b300b365f1b3e8bf968704c1648b29a8b2145fceab954bbbe21e6cf3c78d6d04aa4002a734c7d99477e1d0468b6acfa6cc32ac3b2ff50e34ad50feb7fb3097bbe132b8806aa70556ffd9f5e6ebdc215244dbb75089d4a293ebb266aa78f88d0e913eca201089f0941ddf3af217d6aa0bc2404eedbfe74c673ba7c32ded09f81d62750e1f5ae1e4cdc27a03ea26514b97971757be9ab08a53c288c481225b3b11f739b3d42807c76761b771d44ca977eedb5b576e75bfe3c626a428bfec3d522f6632f6d816bf69e23602a4bf7c845482a5178950e08c8e1596e31165d423b9f3a3e0baaaa09f57b4d6260e80e0ecffeb81a7d83c03980e064822a2e35b999d51f601c90365472045379b0ddf87686071a1e068ca9dd8f5b5bfaf3812da92538e461ccdaabea0d854e24db7f16200b28936d2b9c8d3a942ca2962de9c070742481e51bf990c991085bf5fb44ee689d9a10abdac6ba0487d567d5708ddaf0f9c078d651b8f018c74780df818cbde43ff9563f8d996b548edcece25d9aae92be4b8dafadcfb8d17c4850221d9dc8f836a7c53fb64ef3fac1e5207966772fcfa48c057e4d0742af2059102882a6d4405f50878ff08235e7f58d38f9276e3272a56494e7449ed1ab290a2869c409180d044df8d95d2012ff8c4e16e5788a77395f695f4a6359c9ceeed93a2a277c17eb3eb1ec02849b28593b2b9ef4ddbbcc50daeb5030efc8ababeb91cc7e71803b18fb99a6413c7b8ca43546b3eaabb34875778397eb3141af3a4f0b58d29814cab6a7263d0ebaed6f06feea80013828ec54893289e47b6d4d5da09c8f2afc57e6072c88d2a4955695b0e8abddda20ba8472882cda171708bd1a183959acd4e7edaf930604c6d1224927d5d8c2911f4626d1929ab4c8ecc3f11a0778e1971fff401bcd24b851f7c3836e94f12560269991380c0f5137361d8c00b1e500c3b2c010c89341e1808ff870334424be0cc89e9548e81bc899185e52963a43ebda66e9b9a5b0df6ecdb7f2a4286e710c121242d5b16f10d49ef4e795c22744968c9a4fa927e542cc5fd4a2aac6253bd30df03967ba8e3f983f0c217c09db4fb5f98aeb86b1491366f3ec662979146b40ff756213cdade473cd58f71ea8b80f0f52f9472f48d1e84c87a1d6279efed85b5b217be076f0c7edeb0311f9aaf0847cf88549d1badd58c5f23f4c42ad339e2961f2459635024f3ecbf224481833aa7c88d5429dde619111180ed320c45bec7bfb57f88b9e5407292dc085cab0da84b46e61caf71e6b421811b59de65b7ade96cc77858c87c948bf149888f2b4b93806df851be32847c7fd73aabff89ebed6c20e9241202b9550a5861a9f7ac3fae5db32ff8d715c1b3edbc087c8575c715a2422bd01022078bf48b61bd75db7c64b1a1e5d8a10c0966becf5b406d4bc30d43c8efaa4ac6b6c65c1c56ebdf880f00cfc7cc4546783b3f484bdc50d0a7f0a7ab57938ccbfaf7569532518907a21d40d6ba766492b258c11cbe8832ba826239c5543defe31dac00db3d73311883e66b3788813a3f1a311a232a2b22c5c8d8040abe647b2ecbdcfc6c77218932de87bfb380959e866aff840ffe10a3ae19b69e34319396393927dedf2d42ad80c73b0dd6070724261d8b5b94446d0637bc9225636e2f9c1b031ae69718e4c7c2468e2251c5fee1a3d0e079503112f7d7e404aec41efef8c6707c17ad8a7b2d0b521033658b7be07c35cc9afaddb0d0a68376abdb22337905ece6fdf6dd413a0215e5eec03d5365db30f7135e4868ce338b7d5a5219c901f30a8a2274fa694a8b740bf5f1e804253280abf4cd7e96f7b03697e1456296b9debe689b7efbe199a2972f93ffada51367aa0d9425f89c88f5dabcb18b518d2508237cd9ff178b715750d325975085a0e58a461266a2a0386bc91c209723c042f5e15c9974d882b5d18ed3635763248914a20e2682e023f1fa75a17866f658197cb1be7ea12063f6e47ec2c8ca30159002c957b3e5385c78ce2de2331997a9b000bed902d4de9e4e5ce034ab7c5f5b8a71e2d47d10fcfd527370b5a8b7b4f9d6e6f6adb28b4cc2fb7c4f4c1cfca45dfbdc5055dc1224a1b3c872824b20f0075939865f0d3c96f1a6ae7cf9c694f4e8ec13182eabf1facd21ec57a8c3472e500f1c2b160ead37b47d4ff7d1c7e714396032de64912a216f2fddf59458fa7f6b62de2278ffc2321395d0677a047c9ecfda73e007d97b543654cf00be86bfe6910afb99329eeb11832ab868cb8df1919d610939d8ec1cb7177c4cb94a851b3eca1923ea9d1abb018ca24d40df8449a1fb2f8c679083f9fad1042c085519d3db6d6a6e639156cbf723ae9390a9478c137e979816417b103bcfe08f74fd6a74d2f4c7db3da34b59a0b21db7e06e93d09d2174e2658c0fcc654570e488b501a519360bf1ae1862c56c10038977f90279b6285fbd07b445557e9aef44d2340dc2619af2bbc66b8fb6687492c7a1c2f9c558e6950448cf176857b7294c00008999a25e6a0be0662381f31e7505fe027bb7f8f3b9124e368c3da5487a903032df2d1e0ed72623ad037422f53d190970ebe90b5265e8756f5e13c45a6883d6bf800119bab01574824153effc2a3f7c1036d41bcec1fce2a4630580c8b640b8cb0707dddb9cca6838ca373cd97c7d96091e1dda1c716f87fabb1515ad3018618f6933754cba291fd3f4cd42eee49f2f2f43f78abbaf4197ae57a8ff0177e496614bcd725328265a3e564830aaddf0fea7746c3f66d7f8cb36c88f1c5224ec621a2f2994441e01dc374b608aafc738f9f4a57d8f0b4dd4ae499ba102d0c5df1b8bce10c754b1269f73d59c1aee15fb3a5b5cf0ad9cfab970cd65a08abf7b43f3b8fca5579e22cbf21b3752f17de847c59fc81a0adc2c31a16605df1e523ae1fcb35fb16174062b5065b160183db1b5b8a2fae3b29451fa8751d4b256d4a4ece58427668537177a056f4c381487de8e77febf6913db119bada1723c25d792424f09deadad444b3d1583671c0e85cb09cd1eea73adb82091c2ebfe978ef938e3db3ebedc099396b59bc1d6ef0c68649fa8ea0026d3fd02155ec781e10f7f370bdf84a0a889d47e3a336bfbc28c96cec2dd548780765bbd8cd4a1565598393a10ca0c812ef3dd11ef2252d07df29a352a4a69d4174bb0967aebc8f5fd41d629c3bc4dfa53d71b8bd9b028b69de057abbb9da0e04f72333abdd25161a227dcd34e06f4ad8817ba01759925035fc3056bc0f7bbfd620c9f73ae45be4c6f18ddcbe123ebf8ce640136bd86db2d09954b0139926bdb7d301d6681e61956b375ad677a9108cd3da87b4fda8c250a7697d0102a3d83fecc2242fcbda1fbcdaf4b365a93c569eefdd6c37679d44a7b7d9f33c1a6e5c26398b6f4ae9449e06d891a5b8d2671e46850283c479a6640ee560b525bcc5eec5a2ba6db057ab1a6c6c03935ec4c28209a8afaf6ab02e0d42ac4ee7523e22863a76bf1d22404b53d95e052f2989bc90420232e3b4fe6af86e8c2aee3be98486f91d904c5a9a60b8c3a758d42b1e4a0a4ebb6dbe790c507671e247f209821d2be9bb2b4477c7ed58b38f5c92c17817ab5ae68cc038e29078bd9884b67b7dd609ec844094090187383d2ed160d36f956caf5f35da4406f5b3baf378bb3ad732ad2de363d29fb7f2dd052b9ccd17d58185f8e3f5f82c3cddb1e4acf2d4909774ef0cd74f1422f7e816b841a1f80014f6b40430499dedb514617e3b7a1487f6e36cdeddd7091454df48e30e8c01256d8229d0432ccf2967ca06a10f0191819f099f65f16968a4ffdaae5b286ffd192c92272c7c318801c33d3a98b5b65c99a07e9848978a4064b7613412d5d034321cedda1b2a68ac6a1acce2ce6e5d6cc1c3fa523f553478c0142965f1e68261389d3d9b5363e2a1eb2776357677546b65b98def7586589b8c582d71a1d489df80531d3a75882369c84365c2bcfc74aac6e5d0cf889a97f1091bda11655a8338b56771b99d8001d4c7ab40a821d8b1a588b5ca6dbaa1c97853d8bed56b14b0bef828a67679015d1926ff17d45af4fcea331033eec3b29c8e16584d1a4c80c9f4ff53c80ce057052dba041b2eaa5156436e55cf2ba0804190c6d52854fede7438947a073134f22c3a310fb10b51b98d38a5fc0d8f358fbeccc487a7de9964457e055dd3d27d4b1aaeccaa8557bd8ebe897d0ea5108b1a49844ed66da0da91cf4e84198cf27ee58bcb4ee54c027cffeecc7498455c27d67c012950bb77cb3dd2f1e9b525e1d8a378344b7612ddb3a6c079da0f4dd677197676b97c752e438b9caa38497036577151703ab37e0b60c9b1b1bd05b56faaba18f1c7190df43b2b56957930a8e452d0fcabc9c84501a77e0623e24581196ee0a9b7971df34a071e3f28ff1518ff9b663a5675e1bf496412454136bf49d47a3350c1a42672c8acc467635c294cfd9afee856c0c2af03fb3036f39dfaefeffb23a9def7b06ef525bd3ae96e9d845a80cf7fce1535131c700131bf81a696aab0e82f4f9e713ecc9e7d2b5f58c039ae185e970e69a5a5e91fe8d3ed91229d18d87ca5cc365aebbdb74bc9509c468ba2ea5a82632b8f17f0d79560a9e245716f13019019f3d6f1c028383e60f4a1d2e5430391be69cdecef8434d897225547fa78d38de9428ce3c9163ed1f27753a510c77d0f9dbd621e08ca1511e633b868948300b676c6c9051eeb9ee64a35e3ef066b45abb37e31c738ae2159bf7702c1a4eb8ef530bf78edb871def3011dfe335959c80af8373cf9ccc7a5f6060728fe816829dce821c368a4cefc546e71de596da0446d0ae0543862f24348e0046078e5970beac010669ac822dfab81f9a4db093c7b3c23613625f9d59e7a16ab83f47c7c25a52280ba5a7e763352b52aa61056fc5e4c8b53b54e5469700dc7a2764ae8d9bc99a13cbe668d75a5532cac30cd6124ccc5fc278b617e1219a4ac6f85e321340afc1f427bd476ff6959fc44d823798cfa14a7244f2e4010a2c92dbd2da4cefbb1f7b0dc8297fc835e02a4e7a5eeee9e1c1c49ec7e91afca3bdf9c840fa8e7a37bab76d9a8096e8e91b1452ee4743293aeced6f02a36112a68f1cf125116c29ca17f6f34836a5705bed9ecf381d6fd051ace3fecbfede2ec636ad9cb3a428e51342b8525499293abec1f1c696679f8950f86bc3034cf1ad10e9af4ce012f04ef1fd997b3ba5ed26fbe3a61f80fbeaf7b4f78438bc095e5d3dd1808978621cd523e9a4266f8cd4133d80c9578623925c048c62c57bf6fddeba6fc3ee7374cb23e27dacfcd0ea1f08dd7695178a311726483c172ed3388c7e9471a2820dd013faa2979f9a39c62e7b46981e72f9a71c529716add2f0733d096f14a73a056147e8d75f18b0f1767c6897a870e2fa3ac6edaea76ecb36fddde08c8293f0cb4c8ed5cd30eaf6318e8217830e4815dfd425987cb79994202d82c9a368d54753573250c0d0e0601f9e0ce08ede8efd08f4da0a454177730e59af665a27c7d2e4c7e2d64c74622a17a52a654b1ad5d293269e80cb75276a881be07ace9b9cf1ceac2e724f2b57e971a55b77eec57dd33bd8f9831e851351f64c3619f196bf289458d8735f821cf29bbc61568ca95fd025740b3e1a3e85429343875dfed51aa671ac732c3aee5028c2044a899354e1c427ec7afa4286ed7afcf26d55daf0e28a7ade1aad8f343b1c2b6ddb4a08f8d59f7ef446cbcc5851c1eb1c75ad32e98d130df25ef12c9512acd7e2f44d8c1ba3bcca766f3008b5de8ce0e9cb63e8b33f89bcf4715ffa952e6eb2c06372887866ee34450dbf14ad44988e79694a8b0cccb09f084fe4c1f814173e054eb7fc804d655fff39cd23d90db35ac746b4f0abee32d2422f7c7ea1f029a341e0744b3fcb556e7bf0ba22f1162c9573bbbcd766ae04cb5204a856fd77e7330de2982eb3991220075830985c6602db438f67b870fbe37c7185621e90fef9d96f907a1e654904bd7461361798747fe2f6672e838a6b7ad91983d03e7972a61b1d48209583000cf0ad785d18faa43d9bb77c920cbbe8aa9150893ff5baaa6631f32c4197762bf8de07b9b25deff59600156f611f1d87f5e7423cca6bfb54d83612d14291d3634f86a57e6fd4a3c5719bba30cc0d53b82e3a5bb18db0bed55ee70c520a3914b134bbd58e01b2c2dfa7abfcabddd0356d02d7dd87e37be65b230e9979c4e434817b58fb3dcc1135c0d78a29b4a180c3d56b16670274321dd026cf5d4f851ae92669875cc4ba41ffd4ebb33858b725a94481cb2ef5fe2546f76a563e1b527b258a763f9aa3296b3ad7b012bfe1886221952c565812b80fd4a25d1c01f1884bf87d6c3ab833181fc0bbdbed8217655ccd2303aea283d5d43ead9b46c64d81deb14e8eb01c0d3e7f6e78cc40c734d8cb8ce801b707693248375fc2e48897112acf01c813591270c943451be335de9451d377e87310c5be7c98a8e1b7ef1015aa308b727a4b622366e5d13d0217933ca4d4118980fa2f7df42c9b417d1b48dec21f7a35697e850fa4e10143d9f1fac7594ffdbb54bd81d717f40be19adf935afad2878ef66d7a189d276b3db32dd6d6a83882251a8c3dd53d2e2b2d2dfa5a003296193b43f7f8b4d845fcc839d872962bde273f611a7d14ebc29b308d575d614cc81591051e5a902bf777a9e5fa249b399338ae0f5ed0febfb26d157515a5306d655d74dcf0529f4b16de361bfd0ec7e177011ffb337b9fd00119cd8c78a51aa5dee27e0e8d5414c6ac693c3561744218e3a066df63b5ae93032cd69579e18568ea5f650be8d8d2cea4f1edb3e30ee8e1c1ddcc6f46b00aec17146d63a0a0b88841f6c654fff5c6725b7a09959a61b1d238686a8aea8f3f3871bcf65fdddec13a9c1e6c776d2c3a484235ef2e0cc52c549f0428fac10ffc7f413c39c646ae8a96d5fc4bdd4fdc1d2a314c4ee24690677d9f40718f8dc98b953be11b85372e6b064444adc70ab27e5d0e82e48a3f29311fbf5b710862d943d2e012f1173987f1dce35312d4ea815174de9a9447a8db98f1367dbd67e6849d8318eb65c8a5a57652c4f71f71c12a4f1fe8dbd4a9bfaef145f70f3260af8293a080d0a112e8744a626d054ba1186bed88c25ae2007c7877dcc7d810f11d08a7aae589214c46e2251e0547da0462d780de64e51c471eeb0ebf5dbc5a424c261aa87fa433ff471d7af97439dfd859b7d22d620dfa6e5f3ccd58afe9feadb334e663389a5a33f9e5596a0a96e0e8cca114e1c1baae43fd5b2f3c323fc2202effde71fd8fba3413bf925f7a7b6aed276f24a865de6dcc712eeeab42205ce470cfb0ccffdff014fa9a9e8b7812bd0b830e37ddcabaca7bbc4b0ce5dc3feb557597833beb90920b09c6ae7cbf9939246582509115ce74c33f52f5775ccbdeb78e6d60e486638d80fdc6854291ac86494d15ba66451caf78757b182ebad4e756268ce04f8ec9be4eb7942d33dce6733be90335a2ddd6403500e8fbc51ea7ae10881c2f7ce3deedf3c7c2cce96b9674d528e00beffaf98cc5c34ec8ff8a956ee44a9372964d9db9bc4c64d31c21113430d74116948bda7db9729786a954e48c523b1b8dcb80a53ba38db596503708df38148f6fadc018d135170aa755fa474e82c6105b34dec674ca7d6f93c2a253fd2c6e462f8a6c6a0f03903155d5ccfbe788c6a5b133de1a464854b0dea3c5356ac363569f710276d52771934b14c026fe9452e0fab371f69c31a7cfe16c180ebc10de0d0422fc0a6ec7446b903dc34232f8cd49f4639c04b54a0017adeba58671972399f3e52f37dcbac93019bcfb2d729d01b9f7e2f4918ffaf65001ad4e6294d91afe0f1c8f5feff25348a4f9a2588c259c60b065cad43130fd299860b4470c67daed03161857074997d79854102c3240a86b3943f87cb39b5b16a9e1ffc57f8b4680a6337c14c1db72ade9c762b409e26598c0badaad21c7833fa8ab861839a91dc37ba7a795c7d2d62b6a03ec601ae9898cf6a7cf896654f4b99dfe5b25f30fc82da8ee517ac8ccc1d1d2349fa84ab7a5da7f18b4a4d0e85df3431b0c28b8e93390cbec717f9c8c9429cea6b2a18d294053f5335fff247d0758a1532b22ceb537be48202a0b1f945aff5e1c2a048463e8d0aeb0b36c76f00f4655cff3e51f0a731a61f3813ad74f1e1fed68df1949c76e0ff69af628fad1a72e73cb825a475a9d8de0e2b0fa3a2ad221e5c33d645648ad0aee63017c64ffe12599faecf116360016b97e5b45108fe8e9c8241fecb322208902535522af17a2cec55db5c796609b9a14482ccb1712fd32608eafc02e661084aa5adf98bf0db8b825cfa1bd8320dd15a8dfe6196e323650bcd45f3de3e17ea55f1e6d35f23e1bf75ae683f863736b09ffa9480d994de9f216318d35e0f828a4a01bae66238c8206ccd81f370b6ff9977d59900262002898b9194bab12c6fd5a30823f46b0a5db2ae1ad7cb2dcd2e164dfc15df0ce551878901518ea08c824bef87cb151b2fcf623dcf4b68dde2c79f2d8a13e742378b71a4854a8355352360d6b419be842c8a07a91886f1303d522c9c04f9b2ad586d62e915ca2c7264677745c1004faab3298023d2f17090851c2b909e9bce58e63a1c95710eddd52be5a5d6e4fc2618b0d0edc3b3df40939ca34e377ad421ca15f9d850d69234073f4e2fd844ef8fdac76639ce3e35b2e9a4e42d49bcfb942cba22983ac4c6abb2deb171461f0608f145018fde8b3a8d085c32573ba3eb9562680d5592eff613c10639db0221818ba9b148eb3754341aea59e5735c4c6dda33a08c4199ad78e98ee6a35530a5c3793c4b9fb6961d618b19b8c103a7b2748c8143ecdd7e617d9304a3705fd9415bc0cdefe18d3307c2359b9324a913e2f8f7a806e366400e0947eaf7b44a6a43b096dffb318684a751d9f72818ade329d2676ca7f4ddab354bf1e145e199c694df02b5f1e1d45fe89e185e286e84b964c87ae11242b10cc71ed03bb192c34903e388e0e4423d8062e040d734839f229af865ba32ea26b4fd107dc6e4946907b0801f159eca6e375a7711f81de484514542aa2a13cd5a488e09e5e9a67b12a87399af1998d661d55da4c290c27c87ccc9fa99b62cd9f36ff542c2ce6d1fe58268656895ba4e5419bc9cda3228a3560e562cd55f2474f8dca88d42e65fae5a494f10e28a88f9d11ab062dc62201ea97422616f30d9947bf2c14c359077cb222a64bb573714bc12bc22bea94af09130947e808379ea3f8272a1c2ced58c852133662f1222692a0749b664279d4c08048baa92263efda6885ce9d69fb9a2ba64ef35d3ac1ef01407637315c88e89efcd85d435f0581613999cc5c6b5e070d7ccd9e4ee9113f3f6758ddff6f920ff25a82b37fcdf109b7210e08ceeb702bd472085a06455880c4480006d9a44596481567ccd7b12eb5ed914c1314c7655087fbe715e4995d872a250f38aea3a439cff214b6a1b273f28d428faff01b3c58510f1673570a0ce9ab07d60f8ffe99bc34bb75b4438f62969b8ea71b2f311d68247e74cc3f3fc3086ebec393824889487d497d87e3d4fbe34e8e697d2e75858ed00c72d18e40e60b63e1ed9a68da6e36379b223631594e2494bf95d398e6692c880121c715ba347cec5135ed6157ed08950b28a8d099543544e3da34053bca35413a920eb3c58253ea66dbb332b8cda1cb8710d17a197b6e7d068a5485a477bb018f1420c4db56990340fc305533ee68a4f3721adc1fa0e1818da7c83a75f1e7c8606cf33a2b591a2c405767378b31841ebec50a80a075fc6db7d1a1b4bb20d2e4d2dedac8b5ab9ffefc0c80da03030c18c36658e996e7f08a71c669e86dc486ea7fb17e027bd2790e5682a41662b02d05ac4962e9f3f5b6c19b907f3ec42e6229670c2098036529af05ab64d22082de90d01f41f617ff31094490394655c46278c3d555bd174a31a415f080044c008868200d5b81783532cc30f6b11f0bc7d34564e48ff496ee9d8b11540a7989bc89c0b98b1dd3bd306e18898b888ce88f6274696ebce2039b7765febf7d61d0b588ec95ac50c57b7bece576be44194afac39bb7f925d04d76ebc790c60e7ccf849e001c99bb37e093a84ba62a5ecbaeeed946824a95a8ed7969dd7a8c57c8059e9a38b00e505fe17a24b01e31dccfb2b4a1043de0049b7053c0f40be7dc974d4b4777835e7500dab59b07c74cc2647904dc8b891e671319ca996ce083b5b0bc135da480dd6b3879f188da10b20a12baaeac692e7f643965b615335711a93bfa1aeffd70888fbd732a4b787e39117322a69dc4be19814cfb37d869253c8690d199afb3f2fc39df885edb875988ca1465e394b0b15b68f0269f5fda5ffaab36ac1158d546007276db0b50ed8161b4e7b27a7e2afb14b04f11ddc262008e1520284c5da7bda0c2587c88961181c40714cf68e1e3efe8d4d4becbc7d9344677910bb1d11e31d093e7cf02f38d9b341fc9f4d0301903068567f52add93a80ea900f7eaa9a2984084a93901afbf4ee2204cd56280f8a13944c2994e3103023cac08c639621248e1001891141f0afde6150d6e27cfe98c46090e08d9d7f564d25e3398792191be2b0f67078f98fa1a5711049e4acde571802c53098777324b9aaad241f828da3908b75380b617a82d35d7e3f851812438c0d64c1eabdf83b4da6bbd1bce1d7e708ac2283bd90a1a543914b9015a5a6c80ca82e35144ba31bd2012ee6dda6d7458c771ee1da4894116b4572d95a81608eb52faac28c702b4806339a9dcdb93f1fd7dac6dd81b440453006d7db9b40f32c2da68e97cca62c9057dac558d7f3e0a3f860f4aa007c6ccafe64578002bd56364d02cff702e2c3441e60815d54d2a2002bc6b2adc00fe35a582f5de2bcbf32cf60333bca181bf344f8a2d971b16b9f89861b0fd52e14dc05d035778785acef47e3619b6127869e98011489de342ff20d9aaf03585e397f56852acc287070e5641e2b5e1e06fe98cd30d98be08c8792785263474536acfa55ace6893f1370f7e6ffde6c87871d06b2fe537b80f52c991a40b594238965441ebcf92097e91804d6670b4c18aca357827241ff0f3a88b56d9400fbaa1210deb7e2f42aa5fe6aebbef90bebeffc3e95f48302ff02387ad2b7f7cf79a7e4c46ee32bec94783517c3d1179ced6d6019705a439f52edb58a0c3633daf1858ec9e1233ec2455f1861a83d68e57f55911ff87fd50fb24a57f927beb18ddace74cc067c2cfe5c186a5d03bf5c5cf865b8a43a3fb1a3311c7c172072085a60d13c26a8a2137fabd799f2110fbeabf67195b3d8e8a5493ab5ae60ec521207058f7790f05bc9e3fc3599093b10353bd1840c8d4865994d469af9cb7570a3ae9c15e4001d35b75839317e30b784fd25644bd7b2a2a7ccce466c4708e6566bdbd8e75d39c0bffe0b014e62eaf68f887e9d5e6a66cd1362101102bc75b5ed64f4f7f21e5f03de4c61b16769de2f714abe37dd72dba526c07131d88b9108e4f2d45b00365ce3233e86307256f8db3b093d538a7775acba38a4ef13578bcadeeab3f907cf305d7b62df114ef5e05d9979bc5bfa7236077288f7fd6e5906b5dc91b37840ce03cdc6b7d520de4a9cd10d49ffdddd427f0e7586f4d8a09e8156e6e5e6f5f365e5dd71bba71a06107d9a882f93fecc615f3f98a0301dafd0db85cfda99311e4ba15b65861696f1857de8d7046df421cdf2dbb80b7791aedf9f3ed428493727e3d3e56619f76b458527e08128145b6ffd813e96929af9cd96f74cc19b3d00cdb579c5c40720c7b263a5d0ee70be9c71c356b9751d7eb424733a2c78b196fbd1f06ad4a811c399eff92008541849a571f52b492c9a28b4167e9fda548fa3d9f298e99884f134070985cb1140d502687aa43943f46c95a4fbf892839da1c4b21bd6649a16b26a67dba18755343bf75b05f263c515958015bad16c766e4aa5a456afda86d34d7e8d5d95cfd8e008772507cf99f68587e33410c3fbf16d274b8e853e572b0b965742ca44e8ee8194ae35662d8804f443dee153596bd826a8851a58f9a0331aa7a5cc665e97d80cb991ee9e3a1c5964bf398a18d847d41e8472017c43d1bfa3a85ca1fc29020c392fd8d6dfb7cd71005841160611945451f609355297bf9d8f35acc453c3680b7928921e7ae09d1d7899177b81172d6954b25ca0abdc57322d4299c52e973209bbd9c268d5dd808780c16bbc99c3f2c1788e698a0c3be63ecf845edeadb79413e747d5b1d4b1041ba3f182c5cb53ae0257ba9dc4ea080c2991a8bcedd9aadd7a15b944cf15c09067aad75ee2410b0772d388d50d2b752c3181956e2c296fad3981fef6d60ba68a7a1372844294289324b43136c9e5824245cbdafcbce6051d48875882aa07adab18bb27a1995198019a9fd9ffb06c3708df9823ca543f7ac039a004c15365be6436a433be66be981c7a12e90f5d57b48ac1a96d639e30e5f36925000daec9b89591924d01be33edab44e59b6fb5c7197e2190f552bae359b0fbdb0533890fae900626e0a86248ebdf55ed46b3ce012a0f0fc14ec203f8a30cf54fe4f327b533b6d712b5e06180e530bc0aba2518d68f713d917f4c5b935cf6e9eda4efa3b9f696895728c67d9f6ccd8cb87903267709632fb3a9800cc12aa54db8320b9f1a44533f7ca820fdfb695494e79f879c9aa411c92880f1ef6aa961fe2ae20a1dd100334e0e191484b1fb797cf1c3cb46c4aba0b5203f208bc7076e9378d6b4b0bdf57983e54c422b09d026189b3c9952061ff2b76f742bb5a2bc0e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
