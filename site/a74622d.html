<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b1e8f5604a151edb2f52ace6de2371713066c0c6e76574181966b39e911d2b6532caa340963515ec9b68a62ce2ff0302d512e65408dc2c73ffeb93a4ca8b3f1097eb809552d6bf99c69b4f018532234a75c359dff9d715873d7309b92425ff0ba6125bb6f5e493dbfa1edbacf63bc6d8738d599d3fe6a68cfe994e460be4833fcb83ce52aecc6ecf913abcf486b586bd23ee7f32533315d8801d667fd030dcb4d5141698098ad85380e9be6c65b350cd1dc34a6117692686bea29df4c9812bf9c5466f8c4716a54139639dd6b0b44fb138da501e17826f1d99c5a8feb618e073743b5252913193b5c4d7470af9c324d27c2734597815bd3a783004a9adb3e46fe91651b1d5212e65633ce27cffa5bf791a93810815110d4670ae42516a9d25539f0ed9299fe9b1ced22227173309cb6205fbf083fb1ee454c46237662b4db98856b801728eb5849f8bf1bea8a2925ec2a0258e9941d69c544ddb791d5656ee5af71d7aac157820dd337246ff6a17b4b3485bfee8933fcc8ec5f44176f74073d9efd9627d32e33ed5901a0f732c0d237145b4b5e7f6cd6342605ee05cd302fc3b3168f75f373f8c83d32e0ab47f3686478d25c184bf606065222ef64963a6f0561bee7c21e1aac2518ee00fd8920c6ba5d82cffa8c6361efed3a963fb0241d5c1eb58e8debe7ea28c6a04aa08aefbcde228c03859fe878471aeec76a95ce3fc931e4af0cca7b48ce840c2a7e9b5810022d780fe8cb27920619acb90f16f7e1bcc8f4c1e49c2076f01d650e8f19a6607eedfc794fa1fdc52669220c327c806a4ea9b40231d1d9204a394b745bd25160b44f035d66086c1f8ce2b64a489924c4f394f92a0d4e07b11dd236975f4b8fe9c65169c95511e6b8a4dbb0f50ec6314fc335f03961b0522a1b1a5f63233e29ce07b879f4350c99081002fdb95b897e657c4e3c17e45c69d4a12ebf22e650ac50fd08329a385b95652175b357302f2baa515febcc5fa0e5e4ae6ad6ae0a056f663076fb4118a2262e464e920672b8f004111372cf5cc30fe59305977660e02209794ebd59a3d439d238d71a0340cfc47af6e8aa292666c3ee84afa18ec2aa8131727c70e1996453a6947312ad9fedd617b7a18e792ac532bd781ef284f89533b0cd7d16efb52f762e5050e4db6b490ea09516261cdca7694abbc2a482e64d10cf295fbfdb34dbbda0b6d3624f970a02de7c2202a2db271890434ccbafa60d3375772dc4d65c718afc6feca45f82120a0e240741a0037ba5c7d423cc20ff5ffda4d2fcd5961b60ace657656d78ea0d38e4100671b5b81b515c903d40e61797c94b3b50a676fae10ceffd4998052b2e1baa9c499e90574a6f863e6c9934f8bcbe09b4b207cf351a6942124d5e5876757f6b05296f7ab3e21e1e4f479ac9038f57ed0617871c705b30da8f3b4c1bf8b30ab000acc33d007e8c62687568bf33f325b5664c11426a0562706a2428b16d89fe3a8db6cf6cc4ce6ffcc674b07930a52b93239e2ee4b30152bbfc11f759a07c5a7360f2f494bd81f37a6d9536868a8de257a83a1066ccdd2f20981276c8c999538dad6e11be51ad96054691e4caabee072df942578bfcbc603db64023d6cb2a80007a9a41d669129af499d61dd627906b840cb4749fec8eedb02fd73c27835fa51b6f12f0aea932cec119b42910dd71cde0451f93e0a76f4eae47be8ef0016216f97820645f2d7c2df2dc76db428a5994528b7f3a26f617130fee247ca3352b5dc8967abf21064ccb1271397514c7437389759d32a26452b14f04723421c8b2e5ef46d275fa526ac1085dcad04a7929e7503bf24cb3703dac469591fae73d331b5ebe553f3852706896e5d8f0f28cd521cd454d8a14521ed24129d574c8785ccecd53750eec023255f2369655a5ee4f3fa02ec218af23f62e9e599050f7129d903f438227019213225b29df75b55308dec107efddf949975849e4711983e41a27ebb141f81688638bca6badbb043142b577547521f6208d234d2119787d23f9c7fed6f4b339a4ea2f3771b34da9c45737cfa736c08213c304dc386e0336bed3508b31da533b99c4c7d5794588b6dd228aa1e21b3cb7c35b7770c0a68351581449472d4860b89dd235abe6da02ccc166adc46abcaeb4c7785bb615b6564b8f29e82b773444055454bcd4c8e11e716281ec8c26c914409d26e827cbf53d4387cf86a5469bcea8de9b072538ce22dd9bec42e596d6762ddad6673c076f374ed4a2cd77675f73ac5b488d5458055b120727f57538b0013974c0609efd9a3cd6b0945c8172444a3fa6d86a425880c79813ca043f1a144fe00354eea899c891f4fc9ac2e7e28a58420b14a8f94ab9e3c91052c4623c609d5772f67b80220277a9e86a9384f8592fc0ebf6accbf814bd4db1ef70380d1c7797d3716c6ed1749c56f8ae53f6f38ae0ac316a3fbb0619192564951488a18d3d5c5a05a4c06608d8540274e83a3b5b606e118b96d5fcf756d0b0fe35195b49269bfae21ba0b2fa87f8dcbb720aa1cbfad1b2f9ac16724832a7664a717226077a25da16a44076ac6106ac4674020d8e252ab3ed11f81b8cc053fe92f541c7c7c5ba31c899ca28cccb319a4191f7385eab07471de3eeff495b0b6308efdb1561113c3e51a6ef82d34fceba9e4a1c5fc78c679acd449ddbfd48e6337ac01dc489e099aa06d6c3628df80743c1dbebd2dd1afa3ad4782b39782bd9cd7f70ad81fd87fd12bf5cbeaef487578cd4addea42f42135472ee5dc528cc75d9cec926718139b60d155d4222866d7f94e1696906c447e4421c6180cefcecef581ece647b1244ed175f6ddbcb3c2e08cc03bef9fd1d882db57b3115919723679ceaba6eedf315aee072d1b62a894a121987e65cf9aed6241858086e5daf2af322572ce5b17210fef236ff2904fe04d046bdb7c18e459e6fdb894d27fb5cd64c166b6942c54760037432c5dc29cb1649d814610c379f5428a96a987ed18d1aa4f792e54c1de0fd37bf6617090fff4385711b79457bd587fde89ecc6feea422cf170c051afda9f695c95a766a85334e21f4301d2f1ab0d72352d4ad74c44ae895e0b4c1718efc7a5398ac8f02f93df0d05d7ae8929c6ce60b8691eff2a70d49cbb3ca61cc408fd76cb3b99dcd764447503989df475ca3490af512386cceb0abc644af0a28b0d99b7c95ab1c39ffb1daacf177df99f535f24300b9127b6a3159f554fd8a061e81dac5f7a62eafa8773e20b6b438b06ff3496b3d458dc18c1d2ec8cf9990a4a00f125b0e3a5c478a668256b9f3172b9b95bcff2eb2d6d558b24ed40f9015670fae24ce5cb4961413ae3ea8c0163a73e3870bbdb00a049b2f1f369d356e81a1ac3f3b5428a231958c55eb71b35cb5fe2b7ea2efe0436857935fd7e45acd86bfd736ebc907a1f15110c62cf42f5843aae107d19be7aa81895f0ed1ba0afffbf7135b697ec30f9849b62492fe3711ea55243259eaa15079e10a453cd03012e721b1894e075b9d86de58ae057c1f8122e5db180444d780ccf6dae787dea0e1f23e12159e9f721cf284be35b4807e2786900d86c28b81d71b646c62ddf74e981a1b4898af83d125563508673dfe5b66fb9873399592f168f9288b91dc24c7f63e72915492216921dc2f41e853bdfbbc395e57f33e282523b2e4345fff3f8f20bd10ea226a3a123ef448bca68d50e62d36033951426e766b531356d1f5711ef8121e9904016b2ccbf120c0ceb81ca96cda0f1c4df5441e8174243ba6a94dd568cfbf3a0e81af05f893e4ff3e1f80157537f6a2eec2f69587789bb1236f5c2538cb7ef7f12065e505d2e189da7800ccbf8112ffcc7bf12fa23509ce6b1033e173aeea32cd9e399623af5221e187a7d59093d398bea26be334616ff8a89e364aa29f674964760e19f075d50401f6ed5fa876bcd7b085131ed0b8b528d2a59685e57e96a16bda085e50aea80fb7d54486f757358bfaee12671672c1df9a820295d99a139c81193dc18cc145ef365de1f7a8d6eeb28831e16cc3f07b8cc566970e5b77905cce41c26a794b7185e981e144ac17df6363a79540d11b54464b9d2e6a7b4ac512893c49efc10990c9b7a9400ae46ffb041b95c366105f92bf4abf1a5c212f810b748f1124a6ba9abd60e5736d4735fe6fb412c63812b8b924cbb0e00a3cc0c262b9e62c2d10a6086c0a5edc65305198084d16072ae75aaa7a5653265943c5dd391a44570e7fd28d6ca46b4771858629910f283e497eff85847fe988587eb9738f247ff7079aa5e9c5590f636e9726b2c1dbc64cc37d4b978ad8f987d34e643992411f2cd60b563a172b7c66afd4442063dbfc5a18087bc624b45c181b015e38fa6008630db22a3b28c19e8a8738c48d276e7d0d8734097e636eace057f2962a33706646ecc11eda3f08f69e4eb2b9934155114173aa5d97ca86a59619b7f42d4503a599b4f14a8de38a24043008c1403a331df869476cde828be4f60afa0f01bcfba87d1be8171f81a3dab29e01a2b25a89e680d1127f3c569a485505ef7a6b05551f05d5a33ae0d09c6731a6771c23e9f99a10c5946ad64edbd47238a697eaa734698cbfac66d0da8331deee4d5b34bda9d0b4eef341eb797b1337dda0a33a7a4f32ff74fa820d7c6646da8a05b337906f2093d7c7fe1132bd2bbfc25650b9a142539a3ca0be48912c48a070aa083cbeef2f93fd940ddd1f51405384a8007bcd5808790f6d1095f9a8b8bc342b75ca761fbea2006650b91342e99a7d4dae768d3066983a8f5822e654188446f16ade88bcd1ab40b900d5730b3a538953c0d2c13c3ed8e6b78423a480f12758b44faf5fc24589217a2992b34d032873feefaefbdc396845c10efff5eaad8811a3ae2de268672934da2aed0d3d2edfbe31b959bb596e0bbc88c7c66e6ce5ee144e8367aecfb439c6034154ce7d24c9a72b8300112c1987e018aa2f3e942d746339631ec000e4319c98345d515c06af0866325e3e286dc6d37f267b0454a89bddf0673f28d58769a05d8c446643c168f8f8a91a0a19eaa7ce9b6571e22078218700f4ce790305e032c7920debee6a229c1ddaebb19621ffc6f20002128746d3a4bb8fe85c4bd9b3c5ece39320ae5fd737c99e8453c580d85e1ca70d869b653fb75220be2719ac39a6f5665a9facd7b3b12f1296932d6167bc198e45a4c6b4f8b47048d5b28e05d15d989851e139a674a344438add023cf19897d73b24147810180d5f9986d6c2b60f1428203fe0733ee1254397ddd1e96a2841b3e5ee8816dc2c343d677159e06d74c92d119b898d998bec4585e945edde3cf87168b0b24e22c8d7c864a54f4aaa6b08f07900efbea14289a2b83fcd096df6604d7564e36e41ccf27f940109129965a8be2b1c9e703879d93c5afdcf7a1da9f85701a837b695823e45ede95eac0e5d5366df400ce5918cf7f8705d729f09eaf7b975243b7a41f0b9bbdde5c92fef401bdb373d5529563061b4b1c2b26d426ed7942fe4a8d33386b4d07b83c9e2cf30aae3e7a708bfcba2f44dcef40454d5e6ba54a5d5b0dceadbb91b940c1174e0357367a44000f4922c5d654ad6b2af60bbf55c476653a5d44421168509887685c75abe9780e2677574c0f7d1aab1a7d3d1455bb835a5a597241aa8946f2a05e4c2a50a26bfb6458af4d31e5211dc204e44ff9ef3782817ba2fbae25b099f4263e4fb8e4dceaaa6cb302c1ea056005e21129545de12453514e8bd064404f0cc503f2cb6d1931ff7b5b8918770377c25cb9957728cf3894f0ce2a05204deeb2c8305bdd9b90f590d95e563edfdf32fb5510f26fd5c40d000ada588625b68a54c8c8dcd7c8910dc6979f80ae5e4ae5526de33eaab4a2fbac125e7e53f83d36a7404bed43a934dac070eb4ea051e20aaf3acd7a74c9c43efec008dafd8998e8940bbe24eca51b7f825cc6a494b4a1cbdb7e54da9f2cd7e78441282e4597d860ab459ca2142dd7db17cb210ca244950cb6d09be8b15ed2adaf480975499adcbefce63ea43be80125ce727256b334b56c44e6e410a97c638dcb1af9994d0ce2eca547571b0b0cbe0d4d34690822c618028d6123d85c02bf2042ff4aa3967e2cb8a175634b44cb318516f3ee3353f5a7a4f7fe88a3544311d7a1252b0451184a45fd095e5e894fa0dfc83c582ee0781e736eb88af96639e04c3b954e0575d3010b508ca9409edaaf7c79dd43f9ab5d80a3ae788e0af92927570bc22e86b241e34b2360f0fbdd1203dce98d5a65f40277a31af623759ffaf793e2eaf92b5abfc0adc08d05e3091865d884b226f20db2babefe97e67c0a21f0c2a98304e84c9834f8d7adc9e67589bf8882695f5e5b25eb6075a889336e6c14922ce687c280f468d9a76847ac9adc16873b07a635cd58e3b67645fb72a3a7d4394f65d9fd6b384bff32193f935acbf6311cc42ae8d805435432b8ab2f472402b43d72b94ca85e5d92417a08ff4c6b6e824ff29aa797b8df117b357f93fe61fed8292a059c932083741ba1de330207d7b2e678d5df79f6a3394c2af63ed7e5639d79d5124708cc6362c8fa838c170c2a8bdb8980ebe856c1a7a7dbdab10027d50be82306396b12cd026566be8a18d604c68c912cd4eba1653c91309e4f2320ed85d6f5860a3c994b7e03735400ad05b05aec881c3e7bbcd2e3552c8743cb25b585410ac358ee3455ffae3dc92205f21fd198a3979e5848f10f1edb504dbb0e7091ac342658c619fca18868cd11f2dbbf24ea6d6f8a3a0715e782e9afb1637e159c968d3e0e2568d8863b68f7655044d1185fda193cfde919077849971d0cb42daff09ce17b4e504d7bc042be0c5991a0f0728b337c230d2ebd3e72ffdff3bca534f36d6aa5a6acd0be7da6be9189046cf7308d12d9954732c9f115360afdf227d571bb013704ed5d72be51fa3663fac3a090b35252380de716f0008b8f4137231cf1b1dc8d62be20a253446e9b05765593cec825e2fca61a85583a8a0d3bf75d5cf67b194d84dd0b01ccc5fe7ef22e1e478534f6b3f390579a5b619392f291257013952099f3e04c1a78a9e0f944fc2423a94886ca1dba5aefd1e302426aaf63434d935ffe694af966f485c5fa4e784f3b5d3a4d1caa5698bae92e6c2330b1d16d9c56ca2c8cb244893ed9470bca734f21a21acbe9b0270bc18c7c1b0774bde9b6d4cf9635cbcd0c87359a2d238ee99fbc0e3ceff8a18cac05c4f133461720d9c5ca5bf90c2d398a16af64804cbd7a7106a14dfe7fa81e5062eda52ea33e72b9b14c304b5c64b96d13976ab9b677499ba43172f7f6693430a356686614f7a65afbb53d37daedbed18495cc0f516c909a275f2cb1955d893df548f736891144bac0f61ce24ca05c08f4f54b4ade7820c176668358d0b64942dc88e1932fed664fdaf74976e83e6ee51edd3ac5eba67547e400372412d88eaa34ab3fa049c1105890a38848872d305257f864756480563e6cdd5c2f5ea36f0ff0296308358f6ae8023b4b704bd1e84323a1a974dfc5b8acd2169ae1a46be22c9d8d214da3558bd74f42633677509694dd91d3fddff84971b448e7d7daca869f088dfbfbf7d12aef190871eb28fc66fdf7e37a412eff1786c82bfe7c8e3deca9603db618087f307dded82ba6536310b81f64cbbe1feb979336de93dddec204d3ba31657281db659040c6c44f1066454835d4e5857d3dde1ee8d4e6960febff99c93c0f8e3a78df8596e6470e6286db7541d86c18ffd49ecee7856d79a546a299332dfa706f06c3e59e82f11482927e10da1713ac7b1ba8a3ed9e325358333d0b2a37027cbc60ab66bcc3c116e93732644c91e1d5ed3d78433a56622f06de090c866d885fd1b2f99cf6b7fd781efad452217dc7b0c28c064f08a682eaf874c2c5131b3eb43338bb5bea5bf26922b166a4c1c32a4cb7f3131b9fb6e153ec350f749ff6858e17c3f7b51add5f99b1c055c361afeb85665901a9a93f14c234ba760a8b2ca4c337e41aca6a4f27523f821a4877ddac0e5c1974b45248631e71a430601669c371d09c5b99cf0e145aae464f14a4d6a5ba749c7db087267e102bd147875fc1917a21fdcdbde9872315dd8a3a42edf9a3ecea1beb8a040f7ad7db583381e3406a3139fe7fc1e5a487e8b1603f0f145bb764467fdbbffdb438c6e413eb74bd4e2c5845d789f58595a888701bbbe1d064c708173608bd90a2f25dd729226680c7b38b9407465bb002d9620c8f0a29be38b6ad97a4d2eb7a202a908b29a39bfd0092dc17db7332cc105ce4b850914347b205ca102781014420b1550c2f1bfe1db339ed1cd2c479a3bb3fd9619b759452f5cc6bdacb8b6d287bfe4a5a2cc1ed9ba0d6ccce81559014e9bf9a4d689e57d4aed8a55294920eb8b9da4bac158e0db007ae69af91264b57df954444057ae74c1a5b2d88d6771964fbf8834751058b4a4d96ee67700664a62063d1a1047b033ad78716f8bff2910dd4299b16689c75192301f8cb7d0d37717c11ea6d7529b362a88d2aa128b09eed376de0821c0e01a5c246e02def4c4f70c0928ce666d03a9d928c8d15c7cb7c66c9b8dc70c54750a5dd07e94d5007ff83ff47bfacfc9e876ca30e6777b23aa2c3187748f5ede243a355e1494f0fd5a64fff29fd905e0ffa0d9e5745f2113c0cb207199dce58eedcd3f3b88dd0f5bbfa721f879bd8c154a7d33a436c7fee9f3523734eaf0c81204b035f60aae11ae9bd2b33fdb2f7bff141f3a76b6b7d473f71ff6b3cd58783f6ee83be5d43d31daec620051f0d9317aa5096c65197accb63433f411ca2365cf50c3776c38284e1932e36abe457ce767d1021a729f16ba07380a10d208d494e19cb042dd2f52c487db53a2cc90383d2a5519b8ac025529446f42d98e362b0fb430722d82a346e5e6f2aa03dbe874436223a7f5493102e47dc9172a76fc47a1c2060ca7863613dea8d772cf6622389690153b0037fc892b4e7e58208283a16d0ddc700d8bc42401d0f6a8712a4e95856a41c1d75da31d0ed19a3aefd0c1b6078396ab871309cf91372c8c494c8a2392cbe9fa1039ad10571f988d011a9c9ea24e329093cf02d88bb75a5eed1050d4b43318844f290f697cc0ee4d657219c5ad23cb11e9982938feddbc774c0f5f633c4ccff4ab0d4da25ab739f2d6fae2c27d9b833c6c43c1ce184438a579f1645cddafcf89cbbc4ce40a983e0a28bd80d110c4eea557bbcee84269345cd8a632ab0f23ce4ce0af66838b777c5ed3471040d43bea46266aae0942c9a256ad9f212dd30bc88fed22387ec9399f2cb92fd9448f9a25cb700d0b3ae66cf213bb155d5986df3e9624df3c15f465d682a8685969e35ff76ac2c59fbcae21fdb4a26c523ea6f2fbe0c67f7308bc8c401265666506c422eea3fdc2f5f9e70a99158856fb04ea3e4ec146161e9feb12da5fcad9897191c618feaa7962eb360c9de8df7a1251989a098e97f8d6fc830d41b32103d84a942c1ebc0124ba4f5cb060ab6b80d8a9584ac6bdea4dbf1c00b9951948e53b80b485834262e723358d2dba373acf2ba0044ed273cfa4ff937cde9c6834e9d2ae833421eba548dc44a84b3514337270809b3984b0d29b6b7f549a0bdda74eac3b3319cb84f13d71cc23d9979e2c9699e41f2fe0eb945f91d276f97ad6adb31061babc16fedffb85f8da1002c65127146bf05c323cfadb2ac244c6b387c1100c04c607540000f8a29a7446ff49c52566b2e1ddb197141d80b23d9426a626c2396e34a75e7d937261fbf8becc204627d2d2b0ebb7dc096ad1713219a857d95b3292450f6db1c01fd34530409cd4b3e810938160167afe7376464f27931ffad05d5b25951e92ad27cf9a5961e64957cd6f7b8c7bb97f329f1864bfd88d6eedb40f049dbd190a17644bc23ba00162fc5ca343980f44778ce0f403944a576c3b3785875a2aef2140304ba05215a104806db9672f1f388e0eafdbafdcd2bd4895f3901fce11cc305afe4dba9ad415d0083873fb64af78b719e733c69de333349c01f52ef1e421949ceb716e09e3632955b41ec4137b62dcc24c7eaee689538ffb9b8429b89c0cdf42ccfe3f509ee6ee7a20ab89468d66addf9e7b7f2b0f17e1163630cdc1e63e5d3c0648eaaf2ddfaf0cd5503f0244e5e6832f8d1bd2b232890a7792bba2fbb445c7470ee9c43e270192469264bd3a7e4295a755b6055efb6bf8d6d00e866be17178d4ffdb8bac1ee1da829ec1fa68e67da63641f8841b5cd3056ca586def505532f8a0396b4866dc720216efafc1179dea7248fe0bc4ede23e548b389d3806a010f66eb04921ff4274d039573dae8feaab1edb1be51058bf090352e7b07bd13c6a954687044fdfc89d543686565660f1adfc69b6acb90b9b68786b25492af62a0c3318ac72eed141eee1cb40fcc95d19c2a915876c68a53659a9b78f9df68162ffe0cffb403a1c4cbe78aa8f2ea57cddb88997dcfcc22da9df6638b38d0691df6ac3463c0cadd1ff54844e901724013b503742b525ec55720f3b735cb2fd11c180eae2ca1e4fde02b0cc22fb2f0165026f30df17a038fd2989c7e536d15343ea0fce8ad746070fcd990d248bf0770eddd862c8e845f302d6c3e7a7671cffd1e1085e692c838c1eed1aeb8636e1058968e1bf5a9c44f51bd95f7ab93b56546589988a127259cc6dbf1c028a50b912efd562aed51b977211d3953e90d4b790de04d6f2b50edff8aa60323f510acc82181f122100617f27e40655633299376864e8419406f06b84f2051dd8f5bcf3b34198d2334eed0fdb8b17a944150714733190c28480799bc014610f321c26d07c726a64fe2677be76dedc2125f81c59a6f7b30b39e8657b28c84901c98c9d9739f3b44cc345fdd687ec0c59bbadf79db66eea724ac85c5b97e3d54dbd0183908bd88a9b391a892934124897fde8a9833695c1e9bfcee024779444b9e98cab72921c4eb8458f0398fa7aae83a413ba6e486fc8454e42306b674890b0236f7c097cec7a2782b57d7cb6d3cd889a34f434afd9b59a1b5e6c7d5dc6f98dd0deffc9dc55f70d3e1fb83d39d8d2c358d7b8bec88fb30b9af3d4c21403109a29819408e0b7c612de22dec17fc5bf366c8795886b150ef2f76f36ed7c60d0d8a689ec5dd45ff8b6df933fb45611cf3bb0f13235e9954ffefa432b49648564fcb408d5fd3cab34a0acf9ce036f4a1cfb87ba87c5d0d5b3fce4db016511720b59f52eaccd1bf68bcf79c134c34d54a6cdf8000393a69fa2bd589c527aa162520c5aaaf2c08e7055dc5dfe2960bf41ff510e1ddd273166bccc1223c90cb320ff46c0dfa3c95c597ce65b087c199b9fc57c3a1a0136ce3a81e4f1a2bba0d57911becbad9b7d4edd2b58848387c429ee51d4563df6c1514828672cb54160342a594626dd8654027c225c9fc959999f95253266a403418751941f43aa3116494df6a0e7104b7c3182c88b52a6158959efaa12c85402816cce6f60f842a494b5f58e56d1dc41bb76a2cca0216e59036efc0bde80f477b2bd9bbcfd747e1d120571458e1018e7558dfd6d5194e04a52cdf95cabe27f30d4a5ad873ff2f907976ee55f39ddd14c457ff45fdd0a028452da415923de264a35801032e6cbfe16bdfdd4a30af82cca59aed906448fd134b2fb13e0623142bd9d47a250e8ffda02b9ee780fa95ab49cded3bd5bbd9232b955ca09a69dc2c77b55c36b55af88029e4500f969a0cd537fe8cc62e0ca763400aea41816cfa1338862d490cb484441fcc2674b2a24ada10c142a9dbb54759597616813d866a5afa3f880748abde77fd44765dace4e8b6733b5afaf52386f4a535ab877f9373003c1df12dd10f33ef5aca0588ac2cf8021e20618918069aa05db50c23d9d23437a9d533aae864c8de84599da4f6895efb594ffa942e1ca2a25c8cadea0f120d70664ee5901d2a9767ecb376e30b5d377e0b1b4f4274f3c70c4d0b8d2fc6f1672a984ed641efbc6ba7d79567c41427358e8405c3c50d85f30a33a5bba330536c5d39d31cd931109c735d6f1d9607f8048234b19fcc9e3526529b27adf2f0439ed6c3a711682203b77c0d9cf3ad8ccb493c7a0dc16dabf6c3e4248d2c9a0fc89c1e0bef57f88632295e1c7f664c3f9ad454e56b24d7e86c7772cc331457904adc7a8ff65e5da76a9120843937c06319a7bd5e54ff4f2055ddd9c380e80f1763dd27c58456811f35f97905bb268d47f7bd980392e01bc9ecf8079ca4a300983ff8a7831f3fab0646def27ab386fcd9201d8d2d9b61068d0e525cb968cd47bcb53b1c869ed55d38e11c38e8cfb1db6d575eb8e24ee635cb13da61a43cdb21ca372c2542ea2e0b1344b593c446684fcd07e7b96556132ca9803b31f9e2c5e6be1ad631d527057867f6dda9da59f296d73cdd99405733acf05136a224dff7205512d5b2ff6251d172b2477fb06b40cdcc9373e2b4a59e95e2b7a059f422053dda66fd2449135ffacb8c3d343b17ac0aad499556c6e1436d332aa621823b842c1b18667149b5d44f68a91c95f0a7b79057a148af0823291596fa943afe8f995975e617ff0a1f3df563c3f872340e22348b4b0e60cd79638d4524bc03674223829ea5e3fdd24eb5af9fe3bfaa2611e85181ddca247bce7aa1acafb71c295e9e8f1c7cbc08dbeb50c4696c7eaf7745d5f1d4b877aa5fe466225fc213380b6252bdb063822987e3fd31c58e175ff7c49641e03ac6c2a38c4e069fb4ec5099ec10d22938b61681a9733838b0e38a213857af30d014fdd9a37b040be64da4fe2e7f50b1be07966da2a635afc6bef824654a04e76e1cf1c18646ad44786626ec84ca463913b0dd0cce68242c8940082388cb81aaa76856565b2df8ae81a5a0da413c3fdfa5be2e9207f9851632b35d0d054246e742ec3dc6ad883b7396536cc4e6aa870089fa3e5d35b38b87f7d1f35bac205c32ba95ef01cc65ef4a623a0c0e1d40e323bbbe5850abc2b64d148f5371172e1e94307e53aaca28c29a5b6e455c5782eddd4927d1b416c69f71cbd80b2d38961ad7b489c06ebf13a904de551fb5611b267f772fa05c569edf01a9ac8b6fab4f8ce0cca78aec310e3e770af0753928f29a3291d59a2eae36925fac97a4004ec01603ca5ad8630db8076da8bb95d1b0c2af9afd7b659a30511a7132f3050948fc020e7acc8ad4f462e6afc7a1ffd2c916f8c0ed0e227a0d15d8210cd52ffe3bc6c9484448b5c0ec09043740d486b6aa52cece317dd456ab7df3bc050fe937ec4f68208f8ddcc1769498dd91b2a633071d74c512dfd9114077dbc8c92e3b95f266ac6910f99455474010b242ed3e267f612bec74a887d5ac2bc38aa4b84e0a155f6b42315ff55ff7b276606dfe645e5d75ab3f3d96f393a4aaf37a1ff4e4a2bc593bfbde1fa8de4dce6ce2ccb252f6297219279852943a0071174427c4765624403601aabc378040825554d10243855219076a0f9e0f442efeaaa94bdafe825af398ac787a1943ea4aa773c305f4f65ff2a641389d74ab61b98390859145806dd691bbf5bcf01fc64933be27f899d15e577411e845454bd7070624a2b8f80edf6cefb8a8b0a2252b85cc28146b91038c8057bedb8882c72f09a597d38e1a1f23396fc66b5e521b7c776f97525c06b84db05671ab59ccdbbee9752b594087dc9dceabfdadb9ba0c567644fb4570b09fdaec50c2ca698eb35db87e2086ec7e81c3b31a0a5a2621515953820194132e5e6bc265eb182fa590b9ed34dae092da6631d61928d8f8af2ee47517b0fecf9c899073050c20b9c7d935ad57635073e4f7c746dae00d671c211a2b3650c6641eced02483838dd70c907fe1ed654d36f88e21da01b72bc41a4cdb3619181641513829e08e970e6baa844aede67a16db8a7c548247b2630608c663ba8904eb4441c5cfc91c0414610911fa8287f41c1a7d86192bda607a3d20c8bd67bcafe6acc2043d1ff41bd01ee0241b4a14ffff586122819b6265f9a57101b6a8c90448150142f4e273b52076a3e9cff4ff68e96c10930e28404a15bb0d570a77d098a88226c3fb6519e619dc92df49c994ed808204ad8bdf91e9244de3f139423a0af8962ddf74f6461ca9f15b31a816ac3ad968535bf4fdda3280dddb45c362f2dc28f20b211256a32c24ed7271e971114bb77c0b4e59341348127a01c0c3aa33d7ce072e721697fdfeb5da2950b66b8e269c84ade2f5ff73db593b27ba44a32ccf574ce8fc65e60d1f63aca9a68872e8abff4e61b674dd9d25cb09b4745ca9142adbd7833ed5e1d13b0ce9a643d7de9d1eb9fbacc56affe6e24161d0a212fed85ad4825c44c9873fd35f084bd9f3d1d04001ee5100e7809de22dc9cb9add44fa5a5df3ad9b4d16b3e9db7fafccf273248b8985728a6bc75cc809889d6cbab30298254120932fc26a64af57f66e3a8a0334a296342b07c22aeee09cdc12765ca2dcccf673ea1a0cab1fcdbb174ccbca59b9fe3b89388684ce605985a4f384e72dacf2f5b14527a05f3fea9716b64e1a27a7d6c1dd3ecfe7d04a9fde4534f5ad21eabf77ad718580037341874055e2c7687861cb0b8395bd9c1284cf1e4509496aff07607027a01e1262b00ec355083333c15d98ae2667092af23e46e304f754739591af854ade8a06867f826c035325bea488b484381440ec0a9f3a9809bcba5b9df18f6f8bd8eda852df37ffbce9bfd4aa0a7289d9a329354ae42d477adef52554900a1495bdde565a9e2936a299dc0a79efbbc9dc5c89ead62ebb5a519931766c05e1f8abc54761b5da6358fcee25d065656b327490a1374d246eaa9df7662d6da45645f86e7a7874cf46e103b1fdd833ced79cccc13d1fbad631c256892f0ae700c981d7f969340482e61a1d22521bfd732c72cfc23e575eaa06cfefd14562e16f0900e570297004250e8cb776ae9ced3f32649489977cef94931ae6de0bc10ef35b7be9c0aaaabea915db2498b586c18736ac5941ae37e6a9ecbc9e2f14e7688c29ec7328fba53e46b79db989bbd26397adc98293782905193186be947bf5e03d8d70aa3d83a8822a2a1d0eed9d6c3a62fc4c4ba98ddc1819edcb05a08a852bea6a95072c66e39b6eb157658a43acda23700123f4e2ac805fe19a5416c988fd0090d4131cd34146631cfc7009b0ecdc5e21ad2f7c58a348da8b3a4f77de00d0f3e4cabd48a37afe7ee95692d8bad66a34028d070fedab83d25704c913eca582ce8a1abfd5b66ac1853bff3390cf841728807ced6afe8ceea22421d89982b13a3d8bb7d38eb596ea753814e3c9f639c20d3681f9180451e50206076119b61c514e873a5d203f4efaccb4429f27e1418afe8b27ad49ad8fa7b5760805a9f06a98b2037c9f39f0fbb09b5b46b7fd02c2df941748fc79e076a14857764ee89bd4ab1ce038a8c5bc7d0eb77621507dd314aa6febf96ab3d3199bb2b85b03f0399a9d9a20a7d38da1780d9794e2949ab62ac472d9f2dde968f5d0faae2009e9214f040f49c9e1bae1e93d06dce005f687d2a2fc3230ba7e14f41c6f3dc7e97c2a170ec26d9c867a38d97c9986600764a4e8129042feae1a0200c85b39fc326c10947124d3deff2027604fe43c7e3b92c711eea9adad48fe029d4f49f5356cdd4d02c0778c673f1f3f41ef149241905a609a7ffd2e52da6603bdf7a066c28c0f4509f0a0dc5f6eb03600cfea1108ff6fa909d9fb82bb7cfdf1c6333977f9725b29fef7c11a6f7867d909064289988f815fabbff7e702055db82d47cab7705a6a42f2c9bbc565019f8eb1bdd9e2f544b36e1ff7560f79d902e31c4efabc1068c80cfecf8be5cd2368c332aaf2c30261e4d73b01f039357a2e56466b4f5afa3179f9c3eabba3aa72eecdf1c60e7f94ef3cf2c08b2130a78cb471ee74b565fafe5e008457a3165a2409a114e58ac7aec4365313f6ba8b79fa46b62c1940c015b3680147f963058bad06b8fa091b9c6796d339a9a75788ceb50cf157236b9475f1e0a63f1307745126bce41d7ed56468927797c1771876690386567c0158b67fe71c0d13d944001b162e3e51ad6f0fee4319db6da622b272aa5b449e9efda6b66f0f3762101def6b7bf773c0d56449ed959c745239290b1d4b3ebd02e87c8ca2439db03379a6a4f081ac84bd57561763eb80b59091027b9e0cbee21ca91e657fead36d284b51af209c0cf8792d3c185abe6c7f5acf2ca7855b176a64e081497f2bfba1939ad9cfe843b9ce62cfc1a6749963018b37576400f3c4b1140f631c23da0aabb55232e642894d2de287c699d1d6561f49c0b972d8da4339394fc27d2b1d06164de057fc71f1c454255ee28b4aad46c67e28934ed423724c088b8916d415476f48cac2e38ae6de5f3d7a8bf5104e9e1dc04b4a9b959aaff5b3d81e31b2bc288f793b13018e32f65ac966d100154efafa79db107bcd7707a8353a3b74f3aa9df1d5896b2865a1091ff70db2bcc20b8e69f00c2a2bcbea3e7ee9d6d4ea6055c0f5816a3a6bb37ac8383f1dc562d7da5b3e1b3cc202a99df0a3eb06721d3693aab8694ac96f9bb4623c0b6cb4f080e14102c360dd877323e2b0273b022aa5f0a782054b52ee0788fc53b1ed26b6a9ad0c226930fbea37b1052249011c24f77dc306def95ccd5da3c0f5d1cd241b27b54d839cce4ea5abd0ca67b769c24c6c41828888f4c2386bc41274c6868c8dde699c39480159834512cde171667a20483849c5eb6dbf455c2416bca7b8d4d32a44f45b2520f57fad7e0712732363cdf84ff4b2417810b6a5f813aed926e412086adef81981bffab045c0a20d619996c5b16c86cac92ec34155a041fd8b9c3b3d6640e5126096d9e860675aa2255b1d2681c1d0043b006b2d543e19c46b1cd8b1ade6abfb810140d456266192c73c7c4d274a07fa49d712d24f30f964e760e7609252aa1a8cef0c5f51d70325385ada1d441c6565618ce2cf6d907b2c4acd61237c24c9bc56d156dc6845a9bd219ebc80fdd9196f9c558ef26b503f13b49f79b2852ec27e15040fe629002036facb658297f2ac1580a4acac0d1aad472ba00888cb7bb6b76ad30d423b5955ccc7ec835a7c5efdcad703a461a9e5de6fd094c90c3909feb96a39ed28a7ff72955513decfb3ab10b5a9fe2678be0b7b1e45dee08b14bc6198572d26b0ef4afb94790051968c2b642928694431721fc76fada25a36dd3ad9ec8f48eeb3176bc0d2439b0a783e65c0ea380937f285c4d0a60e069a92b8d0dfcf006e90b6f3820bba37cd0363f557d83fd51c5dbaaa62e00f2329080a4e8808cda1044dd804b514eea838a5e3e75ed61d017e67b7963ccb45ad235b82c24f7c572627b7f63087af1145bf2e56d8a0002e67198dee6b1522e4f008f83945f374a936d8fc4d59430e0b5f4c244da79ec318c0ece949337c2c57133a2f9884fcdf87cd77ead2c9c466e6ee80b8b1d853d537bd60a11bcd5f126aef6e115b0af3d131c437e25db9e5e0eb8c4358618a058c354434f2e83e317a6c83f490c72e0bef97cc8ca087f458249a15dbd02c76e9bb25b94867a782f4c3e831d2eb82c0d60208cfe043b3fbb97b84de36d0bef44bbf6c318aa1b570885faa51506940782e526e850cdb886b7ab7eecc75211275caa114408d4fed74d12a045e87b5fa0d991367ad74c512b1e25724eaf785c5be3d7f4655e4b227477bcdc69e17bb7b07e3a21b9cb620652d370abfed215e2e721d778a49ffdf4e020c77ca97c77361a1bbec75034d4732eda4905aebec9f188e286270f4e291cdc502ee806c0ce61072b7051443d0c95380fb4a7a5826d8b40d1dd2ea6030b64701334590af2d1a84049f3dcf095bcc892da6a2bd002d543084df16e4530d97a6b38322f9c592780990395829a9e5f047ca252ffa031dde3bb0904f6c8fa457e109a9f51cb42ecb555f98960a58280c34a54d394259272661dd076ef76f5cc630990a46d29611ee6af24f290b25b2e09e6b99c8449c1ed0d953d8a9bec6507b42f87be217cea919c2a80ae36ac41c55edefa580903cb109db2d5648b8408e5a53ec269f6ca257a01b8fdf192a6deb40bf3aaf5ffb9e8a78d3a2005ed7550abee33c84a68a870463da2720b65efffd120d72f3ab7efce9c7fab228d7252ae1f25fa6509af2b89ea6eb0fce7680622a66f63178508b6da74afaa3b7dc0a50a9e2eb4eaf8727889042896dcfac8b13d536a53189bd9404092a14949e9dcedd72ec396adb8a20edfbf6580fd1b560afda05a69f0768fc6aaa76bdd96d58f22670d1e45ca746b3e7f42a6e3f68c7238c70a1fc0fcf98430cd14303d2a71ae0c195e9f788467ad498e9c23b11581a7500cc10a92fa4f71309cc95409b7a423f241a440924f9c1968cbd7a9f17509e3b5a16c8f0c5bb70bdafab6a45f288f6ed771e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
