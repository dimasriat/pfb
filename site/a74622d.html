<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d588dae3bcc9c4907fa9ee772e66c04e35a1ca42138a5e217433bf02abd65bc11eefcf54ab86d8bdd606bdb2e5a4e8860d2902f1b519ecb8b73b1d41d9f5c77bfa66c8de63bb501d75815d4a71c7edbdb662b00e66a13c795392e97bc7df077c9487ed803007b8b8bdb3e303c8e8bf648cbdeab423d8530e2e7db9960794d163ff4aea86d5780160462b53eca5a261ff83a402bee291ff722ff61bf0ff75f907434754e0590dd08f41f54cc92dbcf36df14b651e3e31eebfdac5d17a4a783d70ffb76122a31848d703c9d1d4c5962bc2b3df1aaebf318c7de3149ad8d4d6f76da1a9723c354547aa60fb27b1c20863a2e14024bd100b8c993efffe1d85d419f51cf7c7baaa7e9dbe6335b293e47ab99db01e77207ceef2a6e5d02f685fcc1e254673dbcc73f229a406bd0c07c22df99628f681a80daa9dff9dd6516e02994d9eaf15b351165e50cda1b0c9f29f964f30eb856623ef8ac3e24d2d9109ef6b681fb4bfc37bf709129d984569f2c3352e9bffd7740ebb8dd13055556298610282506590f7b6a62358c9b835a67542a3d16e171227f3f272d8d64e56f16624e066f143f5c15e34308ed72afeb7b59e9c1bbbf72967d540b0f1c94a5902f21158373e8659de10a2aefa524eb0e2405354df9fa362f266a72ad9d482a7ad053408a224f840d7039fa4d44b42403c4fb1b21c0ce7b9055d27638ceda5c90318dbee470cde54aa4e9e617871a08c3a1fb37937fc2a52af7d1d6527c266b6b250a9c08baa0d8a24d5d1ef87ab962a5a4c6244f00431442397da3fc9806a70506c3b206ecaef2f2e7f2780bd550fc78c68c884de3caa59bbf5cd74f56c40b00f49d030d303489eb7829c51638f4bdf6ad997cbbcf2a8c778178ef82e19272a57a753b685dafea65c5ef67a084f9cbe087fa4b3d485e59ec57875b86432a64f512d9e48210f45b98f8ab0bb6fe8024f6b11ba70a8ab41a66642cfb75e3e5ed305a3697de087830c552345e2131298a01336813aa0df714a57df7d519dfa3ab38e08e624d7b1f486727e103143ee461b8e141513cfc13bb910e3dfd37996486e5d8aaf76aa07f3bb260438fe56143dc843540d5d17e99ec53e17486aa58e27f33d86c0a1063b61d3f304efca39f822787ee0d027f9b3a3a416693c8d8800de719d90709543c14362369a4e9ebccb874f17ebbeb28911ba48fadb9b9d27b44ec95de444b252b3df102e91065a119504b24aacd0feea8f7eafc277559c9a0ae2b2f9d2cfa6f4fc001b49ca721b43ec67fd1eab93c8c675b6c5462aebe521777fd05ee261fa72b5b7e985726d218339aa856f2ab5d0f8e7eaf0862b1f8669ce2ab24015ef4b96f9d5452c75c50631d78dfe0ec652807c9ef929998cac73f89d4aec2ccb0efcb1dd467d83082b7c3ce7e31f630d1de9b942e4847d043c2202f4439fd38f0a762729de0ec0dfc530cd0ed0a4f247475a89f0521ee559067e68be4b62d25475b7a30a429d3c61f918f7c6e2534d8449413e698b4c8935099721ca90fd92798d4ce99569c504aec94571ad8e8f2ce41a3681d4b9e6a928f23e17a0bafd44c559ca10f0f7cb6fc9b5d6fcf7edcbbd1128860589a1f90a59a930f528267785f3d4390a3df2f6f69ef29b8526a1776324ced5575252103cf4a892ad59aabb199b34167af7bafa6a3797d8e175f418650cf7a35880c1d52e5ed9be395a6b0b271fdd417a914bd9def75ad947769572f085b17efcc88307bf1e0f5f6264f4facb5016d8035e4f5dd28ad8614b153a96c727304cad49ef7f47bad68f77143b0812c6d56b60d79eb72aa50d94a80c916190f6dcc46a026821dbaddcc08096608148afd66f546567cd7a2d8b8f56b6704857694457cfe0f05e61ffb6b413c8698b4bfa3d563a85107b1ac63936a8d1efd3d3c3e99bf70b78b7e47d9e35b9142316e03f92d6b409b0623c8f34519eca4377777bb60ce8c7c77d218e26591058d9f635c0e40b293ef59ada881b82ebb0442205c7b04a63f06d50f93c9596620a44c30d4fda04397f14e68ead89e9d1221dcb012b4cbf8ec605c0984fc292158d7a415677fb5a681d6fddc01493d61931e5783d3313c67397de503c5d17a84354a61d183a779d1113d468e2874619e2a6baf4d1bf38e27bc3fd7de50e4d6aceecfa026df9fa2f0b48db41468cf836c6bb9e7494070b8846f2be9c6bd157861d448439c222460e8423e86aabb72187738937769b07b36fb24601b40b029d4e09bb2a9ee4d621fd406251507af542ee5e5a75afbcb6c7a84e838ff797620fb3959ab7b255bb5123b2f8ea82a8d1aad3c466fb975a4c5788b5524ac06748b68f05122508dc00cd165661ea75a3e9cbfa026a814caf858554c6ac9b9378449faf3c157589686326b63e6cbcee421399c8aaf8eeb0542c5b6ea7f94799685b5f9261b71b5679813adc1fe7bd4b9740f2b7b4935733a8678c523443aa83fd31faf7d0462d857fcb3ca26c35232e7e9b252df2cc15ea3430986f90a63a561fa46d9b845ca6a2ea6b997bb3dd9f462db7864f56b89eb08616a3c0cf9b39bda5fd38d5fca8026981f0135e0521fc4aa8e792ddbecffa698f083b3581892dd402f34f195efbb8c6860932d851b40003d991b5e5ed4c34506209d9ed8c8d6e4c7d9826d7554ac9937a6edc29cd9271f5cab5e094273962067e6003d9c1d8dcede75e2336f9f3e949f9f46f13c59334df777c2a76efade69f2b3aeefd721333d465737561748009e4b4a509af03eada0877778f7b21004b9daaad63be37612ebc4c6da7e172e28f241e7871224a7ce64a1d9fd5c414506ac161d7178000221cdee3881ac71c9d69e890966969084e9ff8e13d8d3bf818ce79f805daabcb40ca46ab376d337408336a7088275925b6dd7a91c5133853086f2d7fca48917e28f533d3de4deee60c79159e2bd3d09d5a8e8c936a96c1f0df096140026a5519bb8959e6cc91c5cd6399909158c2dfe8faec888e6439ec4b1cff6d5e3dd62c5fdc5b731a7d4bf00ec0403912d02a242d661545ec8750bb5213f5fc267e001fee5b48f0af44e0415bd06560ef4cf53de6ea9fe80e45f4eea2666938555781798b09e6d7bc8ef7cb2d9e164842596538a2ddc83a4a7a6748bf4d78d1267b777b8ad0e02bc89739622823e4e2ce182eef8849ccfdf2f473a63d596ca9925d7f356ab7483877f2739c846931771d032508e86a9d4c354844315f30e9a7478e0f6c4fb06d7f22a3c4116c4ab7ed7fc9da833c7839701eac4fb277faa7504f179a027e3276f3bb397dc73d2df1a6ceb8060a074a33af1d120e6c1a775da2fe9a9189a632dc119d1e1c728f33081345bd0e777893f1e132bdb058b9544e092c620d8394f5bf4a352f91fca82fdcbb30b30f4a836f31323a224e63b93ca18380ed416922f701d6a2403aa3e0c4102097a0cdbc20b2e78b3d06c25ffb94068d47aa861852e57940ff48d1194a45139b223d0da4283c41deff69a8386d5dd670d898e5e5210a3ca0406eb18f9a94533ff8862f01534881572719fdc8389b4d829fdde974b9cf7e2e426e1368ecaa1765fa393e73777533c9374e22d512bd41a4b7c9e17617497f9dabd50d238287fd02a3d190ab28286df10a78bde017fc22820bcd0f97706053157548db68abe8efea7aada31f69d4c840c8dcfbe96fef13a598b84cac9a96e36680aad06401796ca4f4d042ac3c615feb1018ffc9813c90edb183c0d40ae376e7f1b5f0df076414823145d8fb79983598271f614f4c9046d271079b08ab8aaaa2019cfa5ccf503a0d086d8466f8c55c3dbb829634238985e1416b42c74770f3b7df6c79f3b8db514208ef7ed16d4754c9a1fc2d003911588e7ffaeac0ec6b2705260c9d3e4ef225211cf4917c421cf53be147cccc85e2dbd51de7f7f8699724a48cd2ad6c874be133db619a92fea2f990aecee15293b5489553e37fb1fe5395dd3f2ed72c4c78e907d3c15b22558d4efe97f417ac30c2022438d3620bc14b0f81daea6873e83dbe40ba1b832aa7239502076a73728c6ce721bc6690e22ae4c24fb6f6cb83144e32fda15a38ff042ef5939bca6b6c7c5f371666ddb2af6e05d4c74e50cdbf5fd9799e792ee8c4da59b39281d11957593f974883bc5b3b5468067ea2c4d66e49037c59f4a07665076703a21405a294b82c37f298353b5b95533123128643667eedd4f17dd9b36e60142ae1006e9a4aed99680fc8b85397a69362ed1dae5cf848fe2c8ba682fcbc5d8ecbf4f6a00360183eb4bca05c3d2edac326e589075b040dd50a6908c0b45cde93ae3537b4e0d8e6415d4cbe7afee4eba9c2770d560dc3c3a99a180c99e09f7548deece5d49606e698e666b1f36e2cd1af228f0e1d5fdd08e646cd89616fc3f67301f221b891508081f41a3b7c899f26737b1aa38aebd114a34c50d9278369b92c78e2ec97aab65582754cbd43d95b2668abfb79e7f777cff1a5e0e9ba114fa873b713a96bf94ab62a556e61edf88a80f0a263b56ace712ba64bcc197d42bdc4ffbecb10518ef29b87d31ab057ba1e6690f90d74b3e39fccfd7cf7e8d86d4f532862296e25a05f7400a18578ab58c2c681c73689fb4143f0cda8a80431589cf08cdd6631d83e7556a8489e11ebbb5965ad47321ec9171cd63fc75f58bf597526e76e45eb4048575f09fc409fc845030cd060e7cb257a512444a34b13d8fa871fc335eb3e5cd78bab24fa1982cc04606e3b60123e214e5f939dc24a3d614dbb17366955ef421c8cdfd946149c3767004527480b5157e80010005f8524e489e9879db1c200d3fb39be617d35ac3799f40826e772e0e4fb0b13cc428cef44d0c36eeacb20c24579a016325f057ea1dae88b61ddaa458765fcd7d6e805e2881d04023106e990d5468c1e90b91972f41712b5dc159a777ef01b1b8739031789eacb551c8f8cbef384da2349802f74b5eceab9a7f2a3981f8c058a2afa33835b5ddc525806f1b0314adaef5421f51a9a72589667f0d102c092163bb3e7e3fed3405d57cd4717c773144a72f322e2c35a3c973fce21cd836732bbfbc2c412398fddcf68c35a743b50ed31408b10d0cc84a3393cc4966d45ad7a28ba6633623cc4de0ea537db9d100d44a33cfab7154a22add8a71cc351bf8d30ee2152b99aa91f117d2ad4eea31bd0cf8a99669ba2afce01a0e880ea75d94c12176ca340659faaad78a7a6adc74076d396ae94490d3ac8bb3e2ded8ca04f08f6a1595ba05259ef7acd964be43aed187d6810ee75bcfd1b390e5bb1b89bdd6f9f9c0ff65cc6b7c55f68ba27d0d968f2f3691998f3e85cdda4a44d5c3ca6e98128952f15fdf1c0f3b5a48a32a2a7a4d31166eed1e7a90cd069aed0ba0b1090eaf0f0419ef25e31c3b60d40363720560ca7a00f9802f1e73c636947bd8a0b69763ccec2e15e7b924685b17785afd16cb79fd58c6230392a7c2dfa61968a12ea9ca8d9ffaffac514c827c74dab6b4a3f80876dd3d98d3286d29d402ecff40298f6c86da3eb4b18114d1fe41794841940e7f403ceb57274182e1df84f5da843898813ad0d2387e9c71d6ec8a929cacdfff96879f1a97006efb09baabcbde04cce3ecf387c8086dd8e5e9f253392d56f4bc12d3394872da4536a4520212a0a024f181c0a70d75a562a723be952095494ebb559d80028bbf7e891e1ea017fc68b2e0be2d434757cb4315f8fef2fd80631f2bb3ffdd8c0d3280c207e3d701d4fa09c10d53f986882283485177fb29e69e6de56829e8117757f0c61657b9d63c152712ac5bbaecef371c0cd696baec11dde90b9cf5600c5fd8a2a79d02ecab219f310d2a24cb016bbe819841ea9faa515abb9d83f9217f1ab3134ed76582b90893128c5501680e2ae3f285a14092f79dbb60b61e525d707220396ddec4b00211037de43446ab23c6de1b8e00457064ea7a2bb9af17e0c1741deba106b28432ea5b4c653f6068cec091096869804a65d6ce8f7f20602aa01f0af9e977016f228aefd019b471225a999b8c6a32217abece641a68f64b318becf6f566d7acfc17793636d99fb9044ae8f679730ce8e6b551c220038f8fcb76ed63990d3ddf85e0a1e19344729313cbbf8727ecc6e796f989d841fd5be06e64cd5831cd4cec3f48d0c124dfa0807c29f17c5f00e9dcea39f05facf60bca74c992b69184c84dab75ecfbe830621d0e2d703b71908d84412c46eea1097f8f18143a311e9c49392a1a0fd0b0bf247e4a937d794a0f2d639e24ba904e067e3f00edbf670615b6a5a5af018bcf85188da8215f66f298ab96237e1b4e4c1d1ac97d13626afec642e7ec8d66fd2f19b61729b9c55fcc57af49305a1a96e1a989fb5a889f216d8cbedade50b40e4b0ef5277719d682369228bda85f92be9cd21b3755f1077ce41f7182bf0c481c0a96fb1e3cf67ae64787035d9f4df10afb38ae259aa686278a658b04e0a8e9281643094a0cff646ae908ab03038cfc1627b832385fba01f964f84e85ad8a4c6013359be12e4c52dd6b3bfa0052c81dc8ea21f37440e68bfa262ecc3f7abe136c7f83c9fe0737f4a20e41244570cd6fba6c0cda5dfd2984063377bf14d2212d81d449d7eadfd437c1779d6344bb2c7df2fe6796f3a9a6198a6d9f8d511f36564eaf4c6924c43975bdad64622093898f57c12c67d92c2aed428703206bfee5500dfa6f412ec02c26800c34d6c984f2506163895f269b0326c407819b77491beae8509a604f5de2ae0c91c48c7565e0a1feab1891622d2d289f563c746091eb01a2fca811f804868cee3f035650d7bceb1e6a8e68b14683f26d1d6c83c8c914c80f2337d82e0d73ff9d0baec678c04ab26783cac3b99fda4e0f01a678099a3d3877a6d76215ec348bd0b9d64e635384c436cc961c6d189322ef2fefe45b910c1325a131a7ac83e06f501e01b8ae5d861c3ecb1c529e1a9ca4314aec27c1a85114e4e7365bbbfd378d49b35e0578088114e917b99430c2540a9ac2fbb5557ea084e942e352e21a924719417e153d7fea9eece6f102075820c32db37a0e858d2d2416c5fb91997394b86f68407130682e36a2941c0e37fcf6a28ec6dcb5c41a1d105ba5bdb3caeda54a8b36a70584c105fd4507260481946add199dadcb48f99ab22c616f27dd87c3e7dd0c295c15396794025a40f201d108abc8e67b2f84f61f987271478bb0594a0fad48cc10558e131a3e178ee55f49e05afc8f54344311fae98751c7bf7471eba7b5808a22642e7be5112be496c5070b756001bc66e464fdfa9072d25b25fc063f0bf4fb7274cb9419b12007e2a5a8e65c56ec7c16009ac13c6b5b60901ce9e627df9717b54f121b26ab4567fa1567dedc3f07b5ad2f91f46bb5ef0419c62dfeda46abd8bd98b2e0b623b63f57f5ccfdb62ed82a3db0818521b9fe982bf93979471e6b38f119fbbcc66d459b94620d33603b741a48197b2461eed6a0bbc298b5814228fee87432b95de6b299b59ace9e213f7f24a0f06c3ec859dfddfff21b2ba1225df5a82eec6f4ec5122100a0dc899471111f2ea015355c94c4d91de60774d7abe0753e535776b8be623f8740e96f1ec384506020b98ca2b619efd4eb78c295c7e02950ecd2a1ea69f2f4db9624357119a06ed405ed83d3005752fb689ea8b78a4baa3f7ec73a145e60418a174962a4ec8d93d3b21a9eb1d427472180621e86263e798c1f6c23384a1d304c773120004efeedb317906b5c32597cff6d69ebfd442241a7415c78c6366be052bb79da0c0a9f15608d48e7139583137ca2ad2c8729e2257b0792bfa215da5eb1a3b2a2b6da8a699226f5543c9e4af24ee7e4f5c5044602c9bb88c58089813a6da89b9d790f9f96a53f34389fbc6ec1684908cff1c0accff101803316f5c39c5355753aa661159b8f62a94dbddf523ad72547f99505d1f287cc6d55ba4e5fbd5fff071c9d2a8d3af504b045e78378b80071501b896017277e5dae6f76286a4faa94270b21c66a3a9a865f57440a9078a098b33d75335d5a11ab39b1f2457b1ec87c43c1795a2dc821238a91de549d95f0886abdf30ecad029773e226be8acd91351d3a6442fd677c5fbaf21b8c7a83a395cb0f960f1686068fd1a733f7eda90d0eb944279eed078462d99e7ca840a671d870ebac933ec4f9067b5b823da41ddbdba7af6d82f5a12b496f96de1e1c8a975076bf5adab63265560f42ba2d882e2a1b4871e3d58b5feb2f5f4b58f64ca97d3718d878a5d15c692af8e4e16a660e9b86ddc2c1818c289c7c64dad672f7b700540e6ce34bae7ed5fe870fde59bf6f0136b545b8401f887cd4da5c45b37e1572903370de6861440a3ea0a26a22b2759195f70ac54be0d11648d8e32b427f46ed7bb1c392159fb8291dd5d7b30333417f3838c156d7327d409e98af6cc12e0a70cdc31efc771cecc3f3ed886498f4f41ba6bc5c2635699775e96882f235df09f1eaeb8596f02c305125d37aef100ac012cbe7e045f5e472f3a5a3d38285b2bdbcd73b5430486a78636e35b3a1b82997bf96671e811dbad27f72b80330e7e87504e9d2c56ac1256fc94b4c56a99606a7364b5e040ad4984016e03432090df444fb11d662059acc0e1ceba8fd75169b1a4919bfb9353e7f743baf5ce9dd40dea4b17d7a1864bd52885569c46798f0d9fbd27d2a6c7a9576397b9c8e48f347010a88b6c6e63e48f1e4d9fd9d6124c3aae8fb7efb8608e1c842e18b94b778a056a68256f5e3dc60f5f9df6de1f8d11e9211c3cddaa9da8bc51322b210dd6526cf098797c00c2d16e406b80b6ce34e4cbe5ea14e96014f32e3e92fb20fe842a26468b18e7a43d50cb3146ba402d8d0bb662c2277060644b179177943283a5421c8d044708eb2454a1b771f62e7172a87df8271e9b7b4dbb7c7ea23f05d9bda12eecc17adc7b73f974d1461a085169d3c016746e12bd9bd33a43c3450774a7f3e96b9aaad976ab87bed2ac6ad2859469630ee8815bb78d5fb65ccd14358076be478a02ae52fda587d8cf3b7a649b95ce36da260f20b500e91595a554a28ab3273a85e95fa1ea94bb5bd98bd0f2ea88d1380eccd436076d7a908aaf3a14c33909e9582c0c3a0cbc19e9b5b4464904f9fe15f67033db7109b7abd7ebf710cbb6380a71a52c6dabe92f3c416266e18bca3b4031bacbbfd772060173d88429adede4c95ced71a000687320f9b9a90dcf54130eeb6757bfef83237fc06949f934ec56cb9e589f30c2584a7e57a0df7fa80eea763f634f0d408214dc95a09cd3971e79784fa3812917f6571e3f9c32c9e7df43368df1db7a4886b13946eb94e10e49e79e4f95cb4e580eb832ef9189aed9e1d65531127cbea5e8478a7d5c3272b43c16bfe93eeb45a760330236ae8828c5289629f7c4a54e30f6cd2bee08a5a9c295aff939b0b91a604bb3a684efe09710c0eaa6191c664017ee42806af1fe7000486b9d21752138830aa7359d86265d0a5a3c3c7cff319f75566f411220eed0be7a5eafc0a26410dde15f30630cbfe44e4d902830c0242ec310330f7d5dcf9af7c635b71d28922c2b4f277bdeec460c69042166464f679397e7f7477e61e1881d73c7e7d38d80f9e2f28d6c129810a5a31f4c822e872309d96ceb1b3bb440173af83028b833270ee227eeeaf835552fd0b2bc815a873d99505a44c28895b8017edbd98e20f663130b0f08bd7d52ad128098425bd0fc9961e44aa5d31153be8cd7b740326867bf86d14906fd135056b1ce35b15192ba0f218e627a555aaf553d81e7be17279153076bb082ee84070570fd7afc68ec6ad52a20d55a0d6f95497d66fb32f731677d60550c897bdbbb5dee2e977225b979ca9411feb30bd085af2a226a690c8e41ee9d69690088eb1c78c0aae83bd571b68b93b8281ace6806995ecde6dda9da4d1577505fd2a329e2fb2dc6c3b9e38b16bdaca39944fe7968076bc890b63defab0bacc7894ac6bdf572cc94239a69d7bb51c472e41664ee7ea73ebd7a661e742a99354464a67ad5e01fb7e37e21eeef32bea4050f22b41ed2ed60bcf58c8c01e404c7f1c6dedaeb9e730937d4f18a942802adff5f71440c185515cb4ceae15a4173b8376ef6a06c362bfb669711da20946a80dddfd30398354748608a1c1fc449d5644c9040690d2e94498e8970e0fb3020b17471275529a9bafcf39cc6d79c10ffc00079c04b32290bf27e71126ecce5d406538c1874800546060d025793dc8d02ae2c9a920ee41d8a624882bd28d9a747803331426109de0170bc7f6e7f27b0c2dd4bab502ea7a4f94fda10e8cccb0b36ede3fe35d35f6b6efe0ecd638244055b423d68efd718c5737f4c6ebb576b1a0a11def8c241521eb9ef95f29e1b7c36b56aae015420e56e3c0add6d2aeb3b00c5b63773169aba5de2da3297071e09a76fc5052275bfc7a44b594705f9259c1f7067285fec00b5f29d2382842bc3ee2c9328ed83820c3d74c66ee609d541cc1c3997047f23b39e3c48eb5db459194dd35a0233825752f6f6bb5e8485aec65b74e0293e351812e6f2b248070f0307372ee39ea392eb8cc35a317071682f778b83447032c5927e411c36168491d7dae85d495ebce76cca51ac359eefcaee54a29c8615bb7bf2baff8d3f03d292416f9590bf2a6e77d19fe2653e1456b537f16166f79a46cd6f9dd64d493a3a184dabc25c40ec68ff92aaf900907c7a5cfb0ce4ee2293db6ceb9aea8acec53a1601e716ba5e38111c8cf446f2f031a4c11347234d4649311df5c4bfafe23108f1973da05c7c1a46e6dab7a672f8eff5616cec0812829e560163b729878595bb1068b3054ab1360d1a26db128a140b9f8d87ae89f920dd869711af09ddaf41e5b88a27eb32b71e90d0fc63ad8a2a1ac883aff5ed01918fb683107060e3ebccf956a482dc3e5cd166bbe4bfbf137c46b12ff5588212a571f5f6f890eb62285c7104f7d9f56f6f5c051a02c82bae220af3c177c96a31ddaa3319c3dcc89570e6fe2a0bb36469a1d2d3229fc16e44d7dce9f309f8d5d82a78bee1f7ccfd8d142448b7255db5b825c528d28fbc509a57ebf1371cc9d04f6ff99a9dc0d39d3beb66ffd25e71f39316e72a0caa41799b350891903524e367d2581e60c0f73920719fe60085edbce84ce6af5fd2c2124fd2f0a77dec9ae752127341f50ce6fa55e0b950b07bb06a6ff502e2814fbdb7a0645aebe23ff385e27883f5ba9d864c5bd4514c99059314e6548562e48db99cb1efe03aa084e80f8aacdab36167ef0a1960ce1c79cfd3300336319dfb60792753af8be48478ed11b2f95cda2c8f616c9dd7aedc0dcd8eee87877920adad454e4f8396efcabc89fdfc53b7cf5259899ffa81c660f8f3125bd90517668f5cf972ce36210bf7a633d2aaae731d6a99b4623094bccb7fcaf289473b7de7f8ad106f30603cf88c56e599ca33ecc48d3d49b3f19b72c6d822e2b1e5fac131e88838b05bf9d8208f1ad8e5fa1c535b0a1c94a05eebe4c66d05a626735704d733ccb0c8818101106c2c3cbf3a62f6734671e08ff10b3e1968ffb271f009df2811c2509335caeab8a70e7fc38385f191dc5e8cc275972b77d8dcd0b8c970de9e310ebfa717171287434686be51cc9b9e89cb83685027f5b0f44fa798056668057f2ce4df50456f7c846d41c058e41298dc9f8b5566efc72bd1ab1c8997971f64a7b21a6384c73c171b559ca89bb8374cbd674cf244e83f1e2f75e98880626042962ccb492a9bc46dd2de5809dbce16bd378b8a51e1d56b6ef527006f8710a47d44401b6409522c552304aae5d031933f21a7c4e9c11adcca5e03dd0361dbc028e9ff22b44df093e5ade066dc01d68561a46bce7d7be80e92b87806c5c608fb8ae6b2dfa610352f33f78d3659baa004b244db0ac96fc16eaeb893da9514d162ffce8647fc952f0ead081353b0328930f7d92a92eb430a8be99e8f9b0a95a610b2a28cdc07c3a1dca5249764bd22071d67f051dd774d3203f72d6de9d8f2172f94bd3e4599adbc7d042a3f546e816b39d6f7b4643d8a82b34af7cbcb8d8cdff31a5c4cb31b9456c02e2d166a9c0caabd30c246016a5c43437e4e8aabb2afe0aef72ce68a8b862635f4f2150de289ec2f12c7344acbae7421eecadbdb72ad8b7c4d114db95c5c4f3a1cd9764da197eb86bfe1cfbe516d8d0169d529b396808133d35dd910b4105fbda6772050f0a25ae7218102465492cbfa903b177124bd596b7c0691c23291dd5969cd435cb079a34d6a1bb1556735f3dca5343ce8da662f7b5161e307353817bc66e05ed6d1bfd770b4b8ae446336a1b8e3c84068742f4c30730b544fecfbfb21c1814596f716cb5beba25d82689390cefd56cd86ac990e6d99a66c842f487f11c066c1f18a7c24f6d507959554635456ae9d06161093ed62e16dfde3c93dfe5bdf8cb941ce292b125b5b9964d7e4580569ac0590c289f16afb04631b77425068c63e73363c8b08ae81667ac41549b434d67574c9851614b7f19299e391da2f4fbee8e2dd7e449c0b2239d9b645a2c15ccf3dbfe688521e31e695297f24a26d097957e4891361ec88fcfab15db9809c69d1a8ff511f3bbf18071f39b2818673a82c3c50f1a6eed8be3f4cf75c3591ad87553ad175e688c1edccda2f58766c8ac14ee259c7f080ecf8413f5a5303e49ecda6ec73e9dd7c4dfb8c15ec40be5441bb050832e3d633f56e2a82effb2994156a62b7355db5c435d66f2e499dd2eab7860f767b508c8b3691c5fe51ed7d457f7c0b9c89f7587eb95c77b2d33386dcd61ded710993dcab2985ec1d2158ce51ce81cecccd1df06ad898dded9b95b5f010b4ecda520950a1e7d0fab7cf7e2dfffc205decbed96e87cd80886246826bf1c5dde8dde91eaebcfeff04b94c25b009578690a0bdbbca73546c29d48aba452c325efc95130626e21fcb1ce0e3e5f33d42d56ca7beb866c31717c2be67b7e10b227fe77bb60a6e83dfb0054bfb828d2140d2b8fec92d25c7692f7753a9d89e63e63d786046017f3f0f7011816b5f16029b1000edcfea7aaaffdfdccfc5c6edfc6062f4423953252d294b76c0820f17270c01e3015b6aaa370d30c3403953cf5320a36c010c6d7cc86f25ce750f3dc046fe555b089f8ee11210d4ceaba5949564f93af8b6a2d0372f871fb1a054180e761f5a50d44d61b3209d9477da9f3db0d7d8b52b9759f0974f5f2a727c941c658488b6ab8ae6d8e8a07f2e1ead39ce160cd9794d87f554a67056a232f6ee3ff2069505120f95a0910eb48c466aae586a4f9b4c130fe8904785ec9b36146917d27616b15124fd0c5ad8fed80ddcb3ac82e926f7c796e495d5212753563e3410c04a804cda3f015215ed5e2e8a7e63625ce3ac0ef7ef93a6f3977d00c586f48700d0b07f1077e4e859cc5ffba4899de864fa7fe1b85c66a0ecd040d982025e2aa8c7a83b99eff00b0d2f8894b05fc72c8c978f7f985e64fc75eab5ff2259f4921822efb2869ba5760fe505e3f1134bb426673706642cb26591193a1bc07bdf51ec75c887e4fd12fdd18f67089a022c7e81b42b9a7430bcaaae3343fa55dd8c3830d44e3a967f548186089aa14e146133d84012e47ef2","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
