<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5cd648ab0edf9a9f88ff8e5029fe8063047ba6d3e7b9d822d7b93dca1dd356967e4f95f7ca10313d33eb9321d2136950934e2acf37f59cd235ec7494a8a4e525247b6a87052587dc6299145c7b9fac398bdba984e9c11bb14e4d9d427d7405bbe05fc7dc3ea59d49e3c904644981e3b9cc149af1ac85a5685f0ca3fedf24253d0c5759e5cafa2e501493fb84e2e6741776b87995019efc725f413c7aad0c432cf467fc77831290a783c6b8ce45aa3dacce1d6ab53287b7da59e07407a33423408b2d45363d15e66541160b55ea00bf09df658c0bd6841b61851b4f045a765e2622a6a59cd510de6f38f9c156d8aabbad50daabdf847c2c4124ea3746a5a45e0323c289caafc9b28d3ab00ccc2e54ff43e0dda8818a0d01fce9d0e89367edca2ee82692c9d0e7833a7bdb9e772787a26127cf802cb0ae6ff5afebc4e225f57cc7cd0c82f42215828de9b1e88841b069915c0091cd27ec0bf48275e8a4ae7a0d51a5e65c22a8f8019f407770a36ea0595fc88bdf85e5acbf989e93e079f8ffd0793a9cfe7440a02863dfce0cf0c406b78fc6ad9ee937e872d9e8e97886f56693a1734bde263da2fb9e41e61b61a8681c14b180c5847caaeb0efb3d0450c18ad742bf27459e1b796e09e2adb0aa1c97e90ad57982ad5f487c9b1117cb00e379908a760a031753c98325fce7725063370fa79754f22e940306e45a6988928e64fa3c92ad84cab8a0756f7c3820a4427d07bc3cbc6648bfd412235b42881b281109f04fd908ccd3e1a5c5d45e190237c4328379912fcfac9e282585bbc95c1800038d0d63eab63e0024a0a4cd79cdf4d5a169c6fff1268ce2af38344a3cc5cd336e07e3d2f9af3fc3abf7374d855900a89ae0d219aad806e3fb3d38aff5ade22e8f101caa852d70d070b1dfe9a7d71de0e980c7dc54610f0308518dc0c5ab910497afb7b9056a69931dd38bcbd76a1b163b127a1507385b0a4dfee974e06b71ff7c32dc63e7d9a0593cfe4fd4a463627c04b32c09a0a68ebbda369fc7204afa4ea42ce5849668ac98e7666f16f43efeaddcbe45e98c2351c8679adc6202ca7e121746ece2aaa63a864e18dc64ccca40ddbe4ce65f433b3a86ddc704efa6e1ecbb38a7aec2e39e5703eb7301e32fac1986627d9910d2eb4c67d47fc5c09ab6fe0ba42b9d6c6c1c0f3c364cbdc6bac509ffd5be5a3df2967fce35329c97bd7b0dde14e81712256c179c92c27430419a124223e04f18db96d793a0bde6afdf79812af7ace7b98c504e12c489b16baf13d442ea3452e46429d75bec87d2744fd8cf13923aeabae66e750b456bef3c4d543d24186865057b68c60c489e27c11b0d6340cee3ef28a5581345ce6ce0eb20d755c2b0543f4c478ca312d7dc3bcca5495676c000242fc4c844093e23236a21cbdd8ba02b6084c4b29387bafc9ce68958ca79801b811fe996d8c5c23e1a9ab20f250979aa67adf3ee53faf023aa1a66823894dc2b07cefc2e84781f4f5448f9ef9f0faec2a49728f24da26d46ad171a985022610080ec623076b41f2d3dfcb0c21dd56e153895ec8bfd41a098d40dbc60f92f2762664677f055a1d2ea986147058ab2611ef54b8647d118d356b556b19b2f41e967fefc0fd8297e36dae17695584acd58b471c9dda5f641e31a0449779f838798d64407d107598995187fdd2e1b6a8e1e4d6a1824a43d8eab0e9444f580ea3253b3ca591f96c2d1a5eaf5b7f29658971410e86a36bb678f0168057e0d592a486c6c1edb8472689bf4c07c3ff17d594b6835b5430be098de71a48732851388d3ef71b50f6bad4c4b600411c133ceaa26082aaa3d1467e7d3bce72726ada7946bee9856eabd1234afca9333f505596fade134c69617dfce5d3dcf4b3982e8dfd6b31d36ffee2d5669aa60ea0ce0ea01fe4ea9bd84bb817fe9adba65f653a516916672484ee5b539d18449b7030122abe4295076aa505165ac5be86b3fb4ba57c0817fa5da2633cbc02a4865febba4d3b004486ed2db38f3d71c3bac801777c91c3e1375677794a5d5cc7acf14f4613e52e1ce4be620c87b47fc5d19be5732c1742710d04c97625fb97bfbef71473e0fd4a85f6b41abb80320480ea6394806dd289d2961af796b43624ade5246e8ba57ecf6e95fb27cdfa0e74703a0641bfc266dbcc6f9f2c78256f99d06080c6f6858acbde9236e90bca4f86e980bf84ddfad63d4fba322298dd892a6f7853c8c3cb20b098ac54b15cd08cd7498abe6e682f28d25515527954342c30722018258c187fe7f0d3b58e0cde076dbf71302a8ecbd47dda34058eeca35141e64c335beb9578915d8a0470b43276f9c23331a48c3379521cf0bb65646074fc3c65339a161613a0b1fc23d536f4581a0f69fd8ffbada3a4963ed4ffe0dee217ef01bbd6f1fd04f0312dbac1f32d846edb0e0c759940d72fedca4b3b3b8093e900cad0530a0a2aa6a2de68a374ababd4cba695dc4b03e95d1466922cedff61ec55a62c8088936ec7b72f13e412677f2f93f3f44d693120df898500bdf06fcb07bf8f33da19d5ed95b6ccd796754f24551143fb8734d6d911ea0109bf6eb11d37776f0e18bffdf29d1b96b9d14da646cc2058886aef1093d3fa17be03f9518d83d69392fca3e99afa9ad2ae35c5da55f1a84bec9a2ed833bdc96baf639681abe90cdcf73d2d0d971c3518c61ec47cae179ffe6ab4639c116436ccfb3869f38ca1b5b7e4790c73ac405275f54f7054d2480bcb8b79ccbe508966ba9d763cd2dc3b039463cc7a72f272c93ea98570b347349698653e9842ec36158e70cd940c3577d01e7ebddd725affe38b56329641309c88cec940b6b3f5e16948ef61ce0222a26d7095355c0169d242f6a1a5383db41f80a0f8a6f3962e08c283b86ee2fdcfb5d74925c6638087b0764352dfd91167f8746acf69885060920849b19500dabae6fd0412c40906aa5bb4a3472679e56718d001faac7fdd8ca8d1c7c6da58e8814fc2580e06e304d7421c2780f8d33d8798121b1e223d4372d7dfca5b907cf1360e6e891359cecb3a539c93291fb669e3bfb35c8b4335fee3a8fb6fca42569766388f4e21f8f937c15d6f03255818af314b427aac80149d1c98fbab276f1ec62b5c7137ace5e358b4c29b223ac31dae6e50db3c05aef4a71f55af1c98c08e63265598d5fa4ad71d310a8501d7549db04d846be07fd3a34e903a0b1f7c7d887be2272e1ef0d70d751009c1a2bfe417126fc0643fe22e1ba29e5402c06a91fbe9801149aa56d535bfbb866608cea85af895ed7ec1cf7cceb651cd9bb6c10b6d53e655f7b2789ca81ec701bc1c4d918b753d8a1ea46b0fa6baf6f2e6f023d39a7e3a91c91d89f7aa4df055e618be2f908063e31327ee066604395676fd1dc5ec563fae1578292ffcbdfa9bd3afa53f6b28c2c6530c4fd1533af3a122592c48c6659c56ce8197f7852bd29588578e3a1c321bb76bba308209e3c5b8c129f767786de90ff3ea64dfb9446daef954f26f422b7d6020b102065b4ff5a692c27f9c02cf525b138ea81308300d9d50283e71c2449f13041285179ba277a2b941bf9bd8442515426e5a3ff1b2982244699f258d1a5e02f53d8ec8fdec27bc6307aa3f423b3a0710c24a0f8ab73d48a68b7385ad537c1073c23f0549156c66b3eb75674b8e7ce75e8be778f93cdee2f045947b3bf4add30c10ca5bd316472d3f38769d620fa5ccfb594482810a76ac343f5478833f854f27077ee0844b4b8e24cbee1d98946bdb74e7da0218cbcc291d7f30a31248cd3defe4e8823f7f7b034a87c18d1544b794b67822a3da46281e62af437557e58f512f7204e94878f77cd4e8424843fa557d31973c68c2bc1fc901766a466d2c13131e9e2161f685d0326eb652fb243e82acd0f72be5e6abdd3b6a624af7e3515efe9d34cdfb6d1074b2de83ebc1b5828d356e79d81ff9be8df2dc837e2688ea0a7348ffa0d0efa860c6164199bf09a87c511d3563addae05e8ebd0638af87bce0df2afdb10015465a0db11805a738536e3603bfa5006fa7f4cd35aef3c1e0b82a4edd834cdc0916580c48204bf514f72ac15c738ee2d1cf5201d9125cb1d24dc8daf1610dcfa0a800703c357b96d95d0c725e58c51f1e525d57980a76dc7d7c1e5ceb1146d1304db9648efc2dea52f7b76ffe903b4e09cd54bcaced031fd75deee22a34c67f39c35ebfc9534c19ceabf16dfa70ffe816efbac69f219b591f37581f18b3a74c8f316e0dac94f0aa8df3848c0537a3bf0257f0c3ff37110f8d903b891fccf26c7c54cede9b38663c4cc7a198e500bc79640023f1423dc65c187df4785e7b3d7c5160ce37647668d39315a90a3b66f7238710bb09895b8c1467588c6c924f91371fb705c8800c9e417d7e80b32a8bb869390f420a4a905be10107b5f970b0686af966c59bb0f40f9a7f90f5bebed240f1715bb9fbfab638f5d0713567f1909c076c825945fdfbffc5561d681aface598a2fd38efcd648c2797a06c3b12e37cbbf7b14e4419749b00ca431cce7b46fa87dc72ee2b5a4aaab547acbf74ef2733fe547b9eb200b7dea927dc7060f6f3fbf4ecdf0219b2cce34d7495f83b7180449cbb2525af3cbfc355077ff463a31fd0d4d6a44ea5ba05fdf7a8b290b0317919447eecbe8428b0859a694fcf9f30e5922c96f8d6cdaaaec28b90c0c9cd331a68c5d0cd52ca7e1e066cf6c61fe1a406c44417b47eab6cb2fc4cb94302e821d53ef447eabff4524ce3b774297a130883d446e1f9505f1df00ed154e19b47cdb29558244b44c642ba4ed8782cefa9c709a4eee9b889608062ec7ea1eb06b0fd6612f801c6a673334a0b37225fe1d1bec0f4b9ee094613c2b7a49da9123947e401c12390c3fbdf7fc54f93b3ba99f4a778a253cde754a5b4523e73a18b79252e322a81815497558dc1672de518a77e85ffa1bef8878788d27ffa001f45c892099342f329303aad82352f229e1ba91eca24647059c8765b9e497f69dba94db226205bab03b242523d0fe1654946b9e5e97d16033b8ad4820f62b2124766bd5eb9dc97e8ee11c2c8bad2e9d60fa021290f4fef361716d4416b0f3cc3399b73dab721e91217b807f3f48c02e44dd67cbbc3e5213d82999a2c9e391e5acbf2dea27d2b0ed97f1f2a390e9ca67a8779abda9b0b8b564cb47c4360ad7c1282fd94fa080af4bd661477cb214c1acbda4b95ef468963f57663f0064accea0c5056ba23b77d1fe4f8d798d851f747b0ee858962c039c01a324f7a0f12b82950cd47f7289406acf5d9e84743227bfae2b903337dcfa532ece319e432d2021504f851d68fe5587b80e668bec94db75c2f68820b31ab6affddb75e8e9a48d80729a5d55789693e8c621084ddbd5c62085244361d1fe64b87c38a55f17f049d5ba04c707a84dff16b73ea0532f3df6cd75fc98e8cd9cad183dd40aa221e236e1a85b256bb368de675029b4ace52a42a2f3fc137f300ccd7e6d834e39399b138ac7fddcc4ebf93d64fb609448f6f4aecb8ae346acaf3f1120e6ab58859eca3ed3258a70769eb6f540a4e204574d6f022f253766ce92f6ec808a7048676c34ddee83e00c2824c2da8caddcb8fece058edeb9d08150ff3f9d1c4c09dab5e12fb85804d96975b554e3e8eb369558f3c8613c8d49752f0f5d7ee2ee8a36740679231cd1a2d27285444e2091e626e0f5e85c6b6360aefa7259b06b072b8508963b3a99892f1f908c63f03efc86ea785571e19ef215b6ad40dd5908abd9364807031ea631423c6ffffd5228ac50a74988eecc370392664cb37ddb82b36abe33158d914527ed2326852efb953f185404c443ee485886d4c447794b13443acc0914b0338351a6554468d62a7eccae5679c0ecb5e7e454a6c7cac42be424863ae079fc53532d1e091e57b9a2ae16bb36437681316a547c26db2a31ca7a2b410415b5b5a69c315ffaaf1a7a7991d637a784bd34ccb14f18f53680b0bcd54d9821e3793318f29932c1c733ab9c339ac37e1e6a0408e16ca3630f4042afcc2e5af6f00da6ad67653dffa229f28f94ac1dce6f63f3d59fc9ba386a8ef6bf236286e9a7fe3a07af5264d781a7593cd44958d44f3ac41f0460964901a5cbdf0871597dc45281ed26de759e54a6e378d2ebd391fc2459c01215aae792e706f3d160b7d2ae4f46086d33584af1d21574b40b70613b73ec370751b0ea978018304163f3e72a7d1f018a766d3fbd8257bed65e2c76abfad07a2ca1fe10804e86ee8f07c4d0b51624f965872c07cecb5f555d0c00d1eec956d883533333ddd34b3dc1ece4052c427cc2135a5c914faeb56bc43126080dddae634aa20524909e997a181406be7d68265b6193457821f339d67bb51727e8f200f772bd97e055bbcd290729afa1661a17d40657209792611f50add13e89d408a88e0b448248dd51844bd56be337bddc3722401ee30ff1e46e0710b369b2bc0930fe1931717c72aa244647fd3478b33b00a7342f4e2dc6200c1f605ba14ed0020ccd273e853c41de37b77a0e93ae776547edfeb12519be3513689b5d6f0fe6df9ae8c783971293816cd2c48ea57232cce21306d2cf83a1f9b589a5f05e5a2ea74c549879ba13525c51017a782a0d4a9fc0259c456a381dcf2c251f61f27bc55fa3c7f9afdc4ad8cdc72036a98565aa7050d6bef72f5ce58ddef05be9fab7952c7f60e623924d3b7256d970069bc1a633ff5fa197381f2e9df804b470ad4d2d65146a22db4ef0d4d35719653afd2c059e9192333b96016c4292ba0069a617b4a1497f83769c79235dafd86e67eba3c1b557c30a5e4df04bbdfe02bfdb01d7afd12469ba302f40370276d2022583d229ee2e6d3e91e77d1cb876600d00fa3fb03a15f3464af0759e0519bacbcb48e06d5b011a209d8d3acc73b06d14354d379c369123526c5e9f5dfea14cb8fd50b98a57066f466b449b32023ca7d8d6bfe7af6a51bde6bc2f6dd9ab0ab9708bc4df6b300046c5e0769a69c0e0789d6b187110b5267607778753db995b9030e0cb503c3b173b56b305d0cb9de3aa3c351b5ad79c9a226f5c191b761602bbae354ddb2b57e42a73a14fb19662f367fc1e3c775f5a347a8e7ba45c880e5745714493222a58ad98f95231b98157475b4bf8dbf7b278327f34defc615214dd8e75548f537d26f0148768539c1a19aefb4b2ea01c770418c1debb97ce3feabb5f36d9a069e2a85deaf6e37b5aeafbe79dae4dfdd9f03167f2f6bfb8708a1c8b3c8ff2049eb9b37b773e3d76e6332db8fbed3fbea16fe7bbeaadf95483b8e2b14e6608cd69507200c2c42231c8d6cac1b7be294608910d29cc2c15d3c5b054c9db5ae8fc89aec8d063fb5b50ab378a1ed6a79e80e9f48a2af5e379f26e24b8e8e795056ac07808b1244dc627288c7941eb79132fb8d3aa897dcce12ff457310b999ec4a813e23d42f1be4eced8546cc7f1d2f60788d7b7dc179557068fb96ffe35e7663487757eb6c10cd5e251d39cd22a774685e7ed4b22f16c9d85fd10092fe2ead68bbad95b75b74488b1277f24d711936239800106e27568fba254c5f3208d204c5a6bc9c5c526ec2ad9c6f190df93e5a80aacae6ce58bee8ed23e3c0d9e469148f2ff56e1a6230f0e967a0e152282ae724a64211950800494af4e186da638c50d4bf6a2e3efcc94c449ddc9d7849d873352651ec90c356f5ba760b41053f16bf49ab80b223cbdbd47b1641ec465578c350f9d6da76652add2e8c91137e4e5d0a5b99628ee855e7511f3868aba5929e154b200e8f07a0a9acfeb92f131c74852b52b2da229529678168d47dc48c919510cc61cf3cbdf36fca00039d3e921759e3bc36872991b81fa77a25631f99b6ff203da2f0043340fa9c397b96bde4a859da9818276d9d3b773172b7df2f25830bfab16372686ff3b9fefab851d1ebd8c1c1c7dde589b031cd0d23d5e3d536d33a80f087255234366f2ed5a783bd699d1c790ccc74aac1b37d1d48a2bc4d2bac128151e86ab5f51fa3acc01130bd01f2cb70d4b81a966705673365613879980dab2f5fe0db71ced3d8281f1a0c8b5fd1616765148f1a7ffb35278af793edcd58801bc8314910fa833f5b43aa1111d0c25fd1d5ac897d27a0dc5d9e8de3723489bbb2374d80b46ef7609262d50d172ba8dbc378850b0c3ebcdca5ddb6743d182865f26316657ef27bfeb80f9fa4c8031d5b5a9da039b41871e5fe9cdf06e319992b9616fb3079bc92b266645fc661b030d5491b0709b444e9e846469555e0332f75c0da91d5b557e116a386c519159e1d999eba83f7f2306c52ede752cb19af7a46037799769ac14fb4db8a45647882c03b7daa868e69f00270e206af845cb5478601f965a6fd518323f7ddfb2425ed4743e4ce90d6b44000cd2cd6f1981c7e2e0a1cbd1e4567cfb92550b63f813366d35e4edeb12af26a7ae2ab8ab71a35ac791698d955e117d43208506f71d0e444e9263719b53ca23454316be72172af5bc4b79d578e1c3a8886b61d59bc1c40bd71b94a00ca24df07385d0bb3c90ce0021e1cf8b84c96962af34e212d3d5abe3615c2c4dada35df331a57b9ebeddad5e10cde212d5c0615e03075859701595ef5a6c5ff939091856e730f2ec93f24f4ad643cc7d2ee5f036c3de278f13dbf9bc293e1477ec0c989a5f5a1f33056e480a4ea40d728f559c67a28f6bf3f629a6a169dd6dad863d2c1750c76c3dd9f1cc0822f431da87c6f1b8651efbee1e78fcf2af5e7f15f64e50185509738ce950af43c82bd6fc8d72dd37d375fd49ab48bb5a66815a33dab1f0a26c4f0e4d2a77c8b36e598a86a4f589047f86999cb7afe17803ded6bb0ae372f5d8bb5e54641d0416c86302eac464c0fef8e7ed466f68d091de5aeccfcf9d6698aac42ee1caa9c946ab3986dad564b8916c05d70ff81d7c614f754191eda0e1a403141cf049e14eee023b8b870fc4bb5a5c869907c0132ad746bef8891d3d31551cfe8d0a94aedad900c7b104cfe45b4a9a8edb18b61e59991c9a5aaf2921f570ec236a3f8bee8adda44d2c460bb70ac39ad021d52385bcae50b3afb608744aad27f33269df227a372276dbecb68dabf51219cc1c885af364ae1f94eb6b8c0ae1f48dd98ce205e29ee2c68666ae3f7c3e18f8f9dbcb280af668d6158052799ea94fc4adb1538cf68785f61ba574835650d34169a9976bd15fb3b446cb5f3089729bb164bcaa8f2d3da39e9ced255ac8030c2e9aadc1b67083b64e66191c100cd799d322247aac2d801a1a4a45bf8879680be24158bbba8a85a9c521c233daf23bd07a02d08706ab300ef300565722bb21c51fec981c49e9fee0a407d4eb70f847559148fca1bb02a3df0f88d557f6d85f88c6237200346e50ff2d29d588ffa77bc80da3d115e476bbceb51c6eb45f2288085c3eeb1539e8c998022f24529f39acdaa83176b0114569c1c84da903d9074d8d1815e655ecd7703c27ce2673da3c0ce782cfa02fe86c7df0bcf159ae4e7f01c0d43a7ad59107e0a18c235ac6c0b55309024f10bf83fa76171c70d68a05bf482aae589b2ab5581b342bc23e3a1cf8a4349202d96b7a44fd6f733a4ec5d62a7f37568a8e9f3965fa81dd9fc373cf923e16520f21b141072829699d0b3ce8d55b07a456d0c6a52bee6a321b6cb3f1ff99397de0a9f75d73baf7021d24f292ac9b49f71d140bb280dd1039560762a268093248cb7531e7ce0f329d355487b9ec690211f25ea7a1184acbead80f2a54f9054d4041ffe869a30cc4c09a6f3c4e638ec976386881a03443cf5d4047d6504d4c10d3c850ea910c6122e292164d56856fb475251d89b91912cb072821f15a75e4b66648aac3108e44ff8df90dd017c7d3eb716fcd2dbef70670933299b57ff1785a8c1ab50bb56e942cfde00884ec63b3bb6d77a10207c283653dcdc583a6cb4161f914f0ba89cf33a588c12003c968597816fe043a697f5c757e7e3297279713c459f5b797eb00b3877455863e87a1245da2e0fdfb8d7f62137d6915ba796ee1951b1fb91dff8cc27a8ea49875db26b92d50d0241ba2e67050be77f3b3779a629db4c953a8761576c1960ceb8013951bae8ef1c54b5a7395740ffa85c14d8f65a64b7a4abe96e774fe98b50f0db67586cd26099040c6783b08c5700b88553170b360ee5e5e644dc1c3927082790c46b7446df8ebd2ab1db38a19ef155cedb31851074fdaf598f3c65e4894b4caa01beeda40653e23b10ca22b88ab607bae6714f5ffed5bfe63e912e4353944414c0152ded088eeb7d1d4c09ba4d3885948a5b4d858701de985d24528ef10de0d22395ca066b79a4e9d5c9c8e91c576f885967e3daee5b394577ec1eb309cc9abc6180a8e1b04eb870d0a4c222d57db3b55ccbe5bd5e7644f22fe564c7bc3ff9eea6614410f32dc23a3ebd2d0580a74dd03e0bc2800a811ec5a3a4af8482274c5751556879cc760c0f25383fe2b69857a6e11052358aa170fe752d02c24a6ad4b7cfa242a6f46b10261f81bd080ab3c98507a076da5e2a27200a00c33913941905ba158460a12e2024d6ed5885693008b57a15b6769717ed915285d522fce85db2e71660c8b9000ad431456206499422769580a123ae0c1b7588ff04e04f620642766c65e45241e25f1ff21e1cbd6ed31b0d6e218e58f342f16fda12e3766f3e257441c9e665256c02ba728d95c3e17210f0ac59a607fc1498f70a74871338ceb0f5876a8cbf38dae10ca0888da16c5b0e7a165067bfaacb2fe2080c4beecf921c76d46dd9f7d1d3c01eebbd4e09671d4353b1f922146136dd68bfdccb336bbd9d58f9159451cbe258d445c519e89a3aa4138cc4e826a58b1b64c5e11a6e3ce0847e4f6dacb84282b207f854bed6aa116f32a615287520e1f28da09dd28340f0e7023e6a52d47e6ce34de1ef0b4bf339199e80ef8976b7932098b67dfcb5975eb3bd93292cd456edde5550fd058dc536aa33cae4a2aab31e74830ba4e2472379d5e9cf43c59bb56c1f25af034deb78cda26da9e50d791f0e0bdbdd3145a5286db7d988e7ac731018c5bce596e5269e4c4921499ff57f4059b65c9ccf7e528ace3a88af42cc2e92e4525fdec98045e5004e82037c1a89cea6827c620ed1ceee88f301516d2437ed4edeaf33c90c96d8b2330f414d8cf0cc4454dd35a6086e18692a24a3d709377b98c08af978739ffcf53bbe65d98163e9c4c2855b082d71a449ceb8f8f5b9befdf9b8449ec3506573d9a34cdb810c7ee12dafe6f2fbe8fe7f4256438fa1bb5f5825385f9e5b864a8f7cd57e27285ef8459d15d8c08ba988ae5ca4b59da99c769bd52e3b455e6439c08222864fe39044823f5f46722e664fe53e1277931ef7a8d6d63f2bcd31b8676eb689783e940debe4004a825cfe83af507e186f83000a0a959fd4558dcdc7d571003ee62109223a0de89e7f4ba2c314b39f36403f1911cba36afb9e4f3efad1fff574cdd4c12c91b007eb15b0fe5ce6916e1bcd6a26c535a856f3b64a2257dda7552cacc90a4f6e9534b5c9629ccb260788a98a84ff5b6e1475856e1e23a700dce26159ae05955304a143bd92c228a896a5e3a991eefba400b2e4eb4496821b9a81a807386d1eebab90712bc4a92e5dbd71a5f46ef67aee187721d191d62c2b3edaff8d1edc11df27baf7698dfba5a88e3b1e2801174c54db0ba619c822960320f1f6a982da7e5ddd3cf5e2e559f26655b96a06f06fe02effcd12324f9c8292d523d2209e0b93278975d48db9f2d48cad80413b471817b5250794b012acf73f1a4db705f2a880c967dfde177202a1419f1ce9984b204c81f259208c40f5b3b74b7fa046273a95f3be03f95ebdd66314e608fd8a0dd8ca73a686750e05cecd77efa48d8c16cd82aa02332f82b923beca659a12dcb3173bdeef8392785bed6b2af54669b9ac617068023b0ba899b6725bb5797548d0f41f3f1ec4d59e5eb27177899e85433d9d43a1e01b7904140b3fa57870270c22a90bf2c067765919e266d58b7afc5c34f8802238d11f2ff451df7e0c5060e78c0ee61f27c682e4c80078bc85bbb93a2cbbf91fb4236e08f8928cfcd245f00a22a44d13e63bbc01610561e7a4ff2da04569f0cbce56db288561434d13e657901154c9db6f170b9d070e18e2a6a6c541373cb9f778603304c19fc5c31b48f2dfebe3dfe4b8cbb8ac79fd5a1a0a74383695d92b0f49c31eff5445d100fc0ed7c0882f2144adc4cbbd45921b325e8c9c372c5f5cce52c73c2267a9a5ffc632dcbd2c23ce92c6416a8fe231e833c4e937e3fae7f1df0213d201c9191a74e14d5bab1a2b268a73746b6d34445f42be58d7735f5afb3bf59a8fa25bd36971c263890add900325484e183096d3815724ef57f0ef6acf49efc7ae081f85e6b9d83bb1ef0247e021b5e97984582782899954c69e23716eea8ec171b38b30e05fcea55baf6c6e6e6e4e82e258a22d57a8a58c591408d53861994f05d6a16f9cde0eb58e09c67f5aa8f547c604c60e01aeb33dca897d4914d777a848ebcdcd34b29145d423e701369887a3053566de765b944fbe711fdc1bd0ca355519b50efb5fdc0fcb596ad10e5ce08ad5dfb4bd786e8951214c6e6e2ebbe588e6cd8e66650696d424fecca1705de99b9a90fc8fdcb3481306065126d93153dd4f781b490bd266d0f2d95cc901a4ff259e1e4c1d78993a8cb6a05e80b1865e3338d6b4743b4107e5e94a2b97a46eeb04cdf7fe05e7c2d112020de497d5658ca6226b3ce545b2c94f83ee65b2b82a0400e7ae6f8cbbcec06ee0218144dc5d497e44313aab142e00727160ae2788600471004ac14308d4e166be089acfddec4d49d6ccdd482e4994de2dc7f2171f95508d0aa58805ec854c0ee6d02e4f1755447a0104c9073fbe6d3a10b6413976826b7f87485e60815b74573862495f862a96c38c011984935b75cf9f79e627f9c5e580835525fd3f87301525f5090d39ebdfc44675a90ab4931e9c5b8e3fbcc78cc9c15bad324f1a1fa651c92f83162a3c8fa28671372e0ac7cee7d53e281ba8e5e261a2267d0eb0dc6e440a225c62f5fb9e31c527be4d7520dfd214c7895fadc7096a3065f7d4832c1e259bf0397a81ff1db6ff3153a78a67b55a9a93eb7c4c16ed819cedb61db846582716e20c98f179eb97ecd3d40d04c01d7433fd63f2d10e3864ee6fe7d2bc0497d8094e7f2925a0c9cbf05a8fe9e877a04e1708dd8c81cc72a8f6fca60d98dd1e73bbe706f044f4211e3460f393cf1c43a8f49e269c4c200b4b979d5271ca9aeb01ce72fa1a4319e12376772e259443d255c715b21f1ee92e93b9f1b1b2d8703a02631c8ed62f298b82fe1960d7880c6d1a7e4a9663894dfda61fc7c5b0e46499531cd7e3e6c1755440eb9c0159c91fbe88b83017da785d5ec7563c81cf4d38978f5cf6b64573851a1d03b7b1eccc2408ca1f0a4385eee8afb9df31736625cded8421b6ad0855f1c55fbdeaf169664d4f4edb79afd04ddd324f67ebfe9b7979318ccd0e28322edfb517398b0400c070b94572d8f089134b157d0d096f67aaa6d172860b07dbdaf9f40fb5dedf434c03f8011eb925947d4bd4cd6a503d45dfc9cbad33f081e6f6b4e33596831475f77449fed88803f63fcb59431d4a027477825a08b4b76d290b881547b2e2b11252d04695e8a71eb8ad5025329a1f0fc8a3e7d0868d35bc6748f75e18109f4ced315e805359215bfbb6f7b5bfc8dbb65fccee49524417e7ea2a47621684089d1115f97a46e30ebb7ef585d17391ce1d6181ca4fa8e2297bda1888efd762d6f8d0908d4a52ac366cb3a0925314c5d913d0f949187d1300cec498e5b741cb50beb7b92185f7f2f21a11a424964891fa35d38570da103a5ad6a5ee9f5617970eed3a740ad19119cb0c72f13377576c6313385f44f833f0bf1f35c6a9c75316a7eda88835b108359519f5cc22ab0b775bc3701339aed5487b9e51c0ee7190bc778170b9858ebcd88d044d4601b0e8c552267b928dc2d882bbfd35f364609a3d0b7be40640d38b54dfb90e4654ad42faf96cd2ab5826df41eeaa57ae67942529494e026c6ae0ed087313be1387ed2747cfa59f70f82d3e4b32378630e45129af2dd881f8b26890ccce41b791b36b6977797551ed02a2cdf492fffba76934becc8936a6542c3a5fd153de25cdac33ce1b513b519ef97243b0e8d664c89930e7d29192bd5ee372e19a02e5ce458c09ab812f21723290c7f8515c946885b9c9bac0cefe519bda0f7b502d21a0e64f07de852193d7b03360dd0c5cb7a619e84639247a6f84c269908486b3a5769d9dae4db63e6d04ee40c8a4c3da23c0942bc9fd7ad1a3654e7f6ac9787637f195c9cec504e3ee33056472bc3d134c7472674bd9f42b4a4b0fea403ad2c43206bbff08bef829fe8b6a4c16e39f1fe6b0f6ac51b22f559ee6a3514c97d2299c43d2abdef3f08d3c7f7ed5d595ec88e48c9bbcc0d0f7f9484a7000eb7b5f6b401a839e27a3aced6eacdea6e3e329e62deaf825ef10f569a6846efc81c993bd622d9159217240ebfb69a2a65b37771dd97ddd34c095ef85424115065df0a6afdc25dbb65b0e6c9d2cb7f39b4cadf2917591baa125739c0e9c72c7903fcd0e907e97c6485ea2de577a6feb914f72b91798c5f87a9b1a6d85b435190a71277d53189528d21e6f7b95832e1e4df5bafbc37c78a22f440b7f9319e1164c067786e8cc1de7f6e310a56882fdd54e1508cc16dc9f4e2dd8e40d9ee304e0669cc334a1879d7d8ad9872bd403a1cf85cc7db242324df5721400413f3fd059c50e22d7c23d55700eba040862f5accdd84ca0e6df89cbb8c1994cdf704e4316eb15f2b1ef27941264af4d43c63c24f918877fca2be26d11550ded448f7e983e6d4f5fd10ce835dd813817801450906eb455d603636b9ddd263cef755632ae9d0a07f66c5e03ef9681950e55ab8d08b0b2b31caeaff2b0b047cc3f3b892990500119ebb2ce49b8238841531f1a21b892adfe5fbf1ad392580840b7545cd36ac16204530e4b431a5c4bd14add1929530d1a687390efff313b370f98b0db6fdee9308ee89e503e4164a6b323322c229bf6cbff5bc3b24384219ba4cca4d98fd22f24fc133ab9ae789977515da357026382f810688cd883153d8d2004b82f16a93c5c52b7346cd510d74a6331f490d93c9a1f2978e7b8b225bdce0eea9b6b039ca5fb9fac92a69bbad3896ababd526811350c6c6a9d8f1a362bdd0619b4db56059d59f9141a054e5889a185a59f932f9e71c4525cb1256cc5527c9652859ee3661d60329cf3670ccc2227a4b7966baf09f3d86db34e4c53f457dcc4b1461c0a579c1e6e4334e94cdfc800c9f19a12f4992fd07e79d9f8b59dce7d42cb9075fd78096102bf7ac562d269b2481e4d824909ab510145833dc42ef50b7e0b9edb0873f42a029393144ec82bbd9d3ff5fd2a3e3f5a9de26e99d226ed0ddd1a048be34e21ffbf58c15e1ac142de60a3e9352c97f31d33e6b89571053789c2e583cb3baf9518a11780b47c57b5612989ab36e58adbd082b1b993e521c37bab749d6722c5b8d405f2d96205d2095364efea19f34d248a0df460a52a4af06a03988e0fd44af0c3f01698558844a47d5067f3590643540c095c3b799d9212675c82c7c8587c69584368f2b79ce15f34633cbcf6f6c80cb9945276c4bc896a79f369efed738a125bf0b8218541671e04b49814bfec03ccc23f8b3e9c6343fa332ea8b627dc0f2bfd2a87b771c5e9613ca0ffd1da37fe20c35f4fd0b1c70fbf8a693825c98ee71555170ee830a41b200f8cf3be5b0b94e53d7d26a07a6d8f46e6eae763c42692a98dbff3fa046f55c8b82f3b3297db3ba22893bd19d7c8c7bfe47fc5e2fe09aded32367aba1018634c741d01331d6ddfe981bd8e2ee10d9b99b667394e26713108ba06b54150a0a3bd9b26b0180d9fb62dc2a50b6e5f8d1b00952297469fdfede0b657c967ef90ead029903b81fd049ea728c3cffc01dc04cc1cadf92d91dbb8d7a44c22d2e563f00d21b24e172bb00f8a5ff166fd2275e93feb071ca06ab58992da0ec0d6e7d1c8e3910fec3a2d8a218868ec91f80cda8511c126d81db2ed0228b6d6d4351b12811aa6741eb60c4172cbf48428a1a7b72c6a20fe61ad4833ad539670761a9447ad8158d7d2898435fee7a2ee3486f011c2191c4fd0db520fc3fe03d78a0a1ca19ea8bef2d64f7ae49c4086cbb73bd1bbff0c496d4c618ae418909573875a74c976d00128b2b1585c81b7e9eb2a6f1bd0b673e349e2c706579e36d2bcbfc4a64bff3d55717071a9f7dbb767ee6033826e62fc7e56b9d2cfba48b40e9d0c9db4efd0a2d54336405ff92cd4c51499d14f1c74f4be6e997cf61ffa0b3a0a3aa1fcbe1a7d39f843425a4a3e94927c4ba30f5d267085d1a0186b7ccf219cc4182b721bb5e3c097aafaf4465d54879abb125847007405ccf46392f7036f0db2e36bff70704a5fdd12e716ba8a46da9a01f72c63c3f8beeefe45593ac5670fe9be472133297f75b89d0884bf8e400785fef272b1fa241b735b9406199146e54de2f39c4108abcf0da9eeaa235085b355d877b21cc66aa17db55c91ae67e60485b78b3394eb6ad4e02ff7b5bd5bafe164da7a40f7399a80fe43b945dec8484f34b9b6c26643254e38da6a8e2e86ac0afe8bcd5d8960a4a048b41b1f04e18d65ee2496c490ebccb80520dc812234c2e29d77cc5fbf260064de53f55259396f89e9b416e0344c1c0e1f4b9d5b97b59690cc31cfda0111ab6f3e5c2bdb65b2709c2dddb33fe0ed314376415554c09ce75ebe9b7ded8a83e82579b3e08dcf79e31e50270fd216e3c7c86eadfddd8836ff0a73806afccec7eacbb6206351eb7944bf00d3ab058c990922bad77afce167ed68b0aa8dd28b81b1e70a9bd31d270aa4a9159e4e32af9dab9b367b6993e94f311721c605af4783f1577b05a050867d502b51297a8edd784cf0dfc3c711bf386a61b7c85a2e65f17636cde09b2087fef4c25d74be0d3655b3c8a7467dca6a660618e36dfe65df495c67743b84e996021d03e03817071786d0101aa19249017ebb06daa8e33bfca5a6acf09fcfe0d9657d60d54f20385942c9dfe5f170ce9f2ae66211b723d8f789d65154cf9ced28b1dbb7765f19463635ef0528962d52046cdb77fd26b998b1d7dcc59b5da379c78afca6cd1170710db7855fbb8d30b7d8566786428858f1eb2b7fd25c251aa8c175c408df8069fe029c5e9ed7d95c4ec9767f8b5eed7ec72bee85bfabdc9de686d4946ab569b34f35969f8af8d902eea263a3d694f72f453f541bf1658da9031947d7a1413cea3ee03e0f6b645bfcb15a1c523345c85650022047dd11b3594482d69a471f94579bf01b703ae6e8b2bf95696afcbbfdca792b36b9317e1e8d7b541394cac7f49c566434a6d884ca58a65548792cfe5562333fbcf7cf691b14c79c8a5bbd09178d00cfb8fafa13c859c29de59a3668ec6ee5a998d2826ff0bba7b564f6dd7a8bf7eec3f223b897632bcf7a82f8953b4b87b837b0150953554e744b41ad0cf794d143f7af5f524157d3530b467612e8cb7b1e90a7fd8a41d24435e8c634387eb0abeb8d49451593ad163626c3efe9a7c5b4301ffaa5347d4e2e8494bd2eefae4cd75ddaeffaf9d86fe894fb1361630a3b1ab9904c742b32579dd21903ae8110f58bbbe293a7c7c61ce021af8223abd1b89135bf8491e7129ce933b7e3efe0192a2d03203871fcf40db262ba58ac58954a6017b9be932b8465150693805464f0ee2aa08089b3ae","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
