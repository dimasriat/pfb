<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b4689721cc38f9942616bb0d5fd8860e3badbd623e0cb426c919c56ac25891c3221051ade79bb354dcaa24a473a37086e5a1d6b2bc7dceb63284a68b2340a5bbf4fc7a0ecf48041739ebc7661c7709887935b0ec93b5d6a24a7720ecb79c2103bc5a198241ff73c661ca11ca0f282ec98821d2b038c78076cc3c66dbd2d4c0b6b69fbbcdcf3e399403fa74a5aae0b374066eb4dc9fef1fc7f70cda2f474b974cf89a672fb7b027cb8a155e359149640b7053bb6da06f93b1507990642c7b5693a142bcafbbbea5376185ed1d1f6225b3a1e7c4cf6bfc79e49a6714fa1b196c2bb1b932b19c4527f27d4839cdbf1b7580e95c3608e95fb303eb7e3e0b6c3c8b8acd92288069d6aee7c04b84e5274503bf4fec0a874dce0a0e1f709468904d61f1929dacdc2d8a1724380f5c01abdd52ea5f507e10e1b4c3e2bdbfa529b70826e442aaea16914c1bdf7ee3680cd1c7038972439a5393eb2564c41b695da3e3c4db384a4671157673eabbed36ba28a980a5f713bbff6f4480c5698dc490e788bc13729914298b0b62d50b53e5a6440f0acf5d6a918cc5d2a0ccf72e23d472870dee0da4f61bc79dedcfff313f6207e29948b8906c0ea9182898143f166dd925aeb6e593e0be9d8b25f2c8a05885ecd08aa19ad8bec479253804a27c308e981e6c4b2b3824d8ce775505529b6e177d3a64a8f104b53f7fb13d5bb442270975125a58a2b6ae1a653e5e5a378e8411ddb4b2dedb14e38c983ca36e16015c69386f4ad5c52663d2cf4259a061e9efbc3aed94cd5d31ff95451cdad5fac0c5a89be5798dfdeb3d36d01078287afa7fe43ad72c4cf217b5638fe986a0609ef8319079cb11a9a9b7daf348b9cbc7d7ceca4b10d83a52e094906cc4b935ac133c2cb439897ac64ab58d72acc0e699281269130aac24c95c1930fa75c0c7035e20b1f4de2b42d147e8159fceb8ec3658ddcbdd15ff99bc6daf12fa981b0219f42290a37d314db6a20ec4566f0a7d6f743234c701187b0d3763979dce8e1091bc40e859c9adde43fcf85663ae1c0cb515ec00b824595331a4cc363b532c33b27cd2ecff562e752a05dc43559b5093b003f71b2341b18b8e31614bc6a2ca9f41deac840c3fb22eaa95d53f7b0d7bb2d7817037aaa4850a4e07532d6ada3acfb7db8bdb39d5e89e22ffb5e7a113f430a953ba374d39a2643e038e3d5307bae48a2a8106257db27ac9d89b141797adeff2028d49de62820846018b1a0fcf9919822e79fb245545ed4e8fa669cc8fcde4280a00848b860cd42a01a6e9b163cd602a1394a882919b3b77585a404669fc4451db19b8c534b4b13d72f2e7f97af3e4a0d7929bc9320bcff3a004e42fb5d84abceb6f5e9f0460194f09dac81124039d0bf6f500c2d4398b1403e8df9ab8b04382f77266e22612577f7d60e4db18bd55659788cef70e34fe89e5aa30b9a4419415d4eae6c6ddce12d17f04cb2805b417afd675f78cdde42950257c9f022388ca5f019323d753703be7afea8d3528b4c9b1ac66ed70cef4373cbc318abbc2037071d9afdbee5c334889199ded3ca020e678766998081aff32c612590c80404cb0cce007bc90219b1065488a245359900a99baf12180e7fab4914f71f1e6488dda1c9e33ba13cfce86c326dbb0a71ba48ac39f588402559a82b19d0575b6122b2660daa419d2a4f0aea9b099cb6e8f20e60eb6b39437f81d02643de827bf3cb80d53c78a6da103a077c7737ad29e2498c9cf4bf33eff2f48c48c76d0893e334b7edd6574d706314a0bff85a22b2b69ce5dea232bf01dd461169250c35822ae60ab5b75aae783920dceb5d4eadaccdbd9a938d5956d22d52bea5c132e7197fd36f783f0ffa5ed989ef4ad040b65a265876fbcd67d50875295ac49f6d5abbf06aa4ccfbc188389760d47339f20072874a7c0f4ddec19064b41fe9ff2eca9d23f7b02f46d12c332c4fe14e2b8e1c98ede9bf23075768c0d66ee1ffef5a2933a101756b4b7781753b0186cf384c32ebdcddad6e5ad45b59d33fb4476dd896ed591b2235c67730ed0ea0682459d5d1b19f2a0da979f2688258dc673c38e88e613f0939b9b4699a0905a7f9bfbcb22e49dcf5a718bcac61c52ad10227df54c790706928eaf67b8d86d24ceeef494a6ca1f93b4a92d7c7a67477dce38fd522cb7201cfc0772799103a18d4cdead39dbd3e48162cf7717841131172aece53adf66972b04724ebc63bb7f830698a4888ffeff836d8a96ce740ccbd5a5738d5052bbd0484bf2e89a39ce54ec75ff5ad71e7ea1a35314e2697071e403a8f3667662d8f26e5caab642362d45c06e20a415b3f9351dc7be05eee1d081e613207130d5e5e1027629bdb08f27c52339ff707f1e6e4d9d51bd26f9c0c826ec063f7d35e7f381aec8ec2584089c634a0bd7f85d52b5fa1bcefb35c3b197650bae7d2c4bc47706f16983a5b40a2a66af328e4e65fccae6e787e7f3ce45dbc4088531c6da57494df7edd4c56514fd8e7b35a020a8b3f3193683345ad2a980b32df81cd014414849fdfa6248f228064d98b8158fed49425249cfe55c307d3ad85a5e46411220867c8f015bb0ad12d2f3068306816a91811a031f38840c097ccc8fc30f057c465bea7e06ab38b6980880f9f4c4e24db39f4729eaa0dcb1374a3f945a28ff0aa4eab26d29e3f607caa5e4420b10c0e8462a5b230702ab69ebbc384eab2f2fb5eb9abd4e7532f604f3d55b00aa7e067634bd6c759216ed8f6c74cc37fef18717c186ad3fc97f0f873b1ea7e5bba7b956bc3de274e7d64300d581ea6055533be1e7a24ab3e1a72b835dd929218a1601e76fc54315e919c5916b5ff24032cdb6b5b9851d04b1138d86df9b9eae56955b31dee6ce430537c4b8270939394c6dfe3ec033201f8ad1495b9a37726138e841cfe4960780a681b134c20bd697a856df1d32e4c534a046ce5227cf358d1d1b3c6a8d29c188f536ff8c41ce807c389376cfbe3125332bda2228bc791ffc171ca175b00c6c35eb1a9f2284b71fd4cb2f88ef479185b09e142f9d209ef82d7966188b4ff25306c97b1034acaa574a484fce8ce667f9b116f31c7b4fbff4bc4d08d5f14f058ff6d68dddf256906c3930b08907b9d83375c19347ec1cda8386565c8499ee168a16b581a066b7dfc3fada6e4ffd8292ee9806486b3b2dd8fdcddc6d45306db60a551e5f978c3ffad0c58e999af288c8bbfa1d6730a3bae2464115e710b5e5880fd86d0901b8313291bf1836fa5302bc8456c47f82a28949f97a24ef6fd8563fede0c94071aa94b2bf8143c4eaa610f7e0ba5855faff43437b2c288d85bd4c639af49e8c7638902adc0798f49c1e3f6a4313118c18fc845bf524a4f002018d87c80c98edb81aac4cb3ae4641d65141d508eeb7f13b901fe7cc02385b84929d2dd916e192b3ee1f38d10e0d5bb818ea6ff2614b7ceb27f632600852a9a7b470653bb2834bdd68473be0ab3372ff433fa2f74799fc6e29433059d495581a565d3ab05b863b1c22d5e822d1df710b0f90691b5b14607b74a435cd92b6a2c80d0287e2044c331c170a90475ac80b41b9968c1c7329506688bcec0892ea4ff962092e0bb4ac8843f3b884501be62df832d4cb228393de622f6f32e537ab80b28ec863c9bc4ce7e46953d5e48dd471a40577c0f4dd05891aea177c64c6df8c6b59564ec031e9a369c5b727e0ba9618edb5081bc249723a4721648a7897e3bad590a7c7e06e972249be26f910e542e389d68c5fe7220ffb85d2fcd964e3a66ae725248f3ce90e88f9db4f8758d2cee26c5c7479d16e7d1c5b6bb915ec30c3d83b7687c4c0369bfb83e307453c746ecaf0eae1c47925bbbd24a66050010cf4762292a18c39ff4cf175b8c23ba14e320c0a83d79057f6d9497f997745fb77f2268a2645bbb3b8b54ae15bff6942979793d485572c35bb324a6433f965ec71fddf6c88805985566ea083ac686ab6081a5d1f84484006462542ceb4961aa5cc02080d672478a7233db9ed1fb03732c22d9f78cb044923f4f7db02530e7b8bf019dc1cec1ea80b57def8ab57191dca47db8a18a9aa2af7bec0e45aa9ffd208afa7021478b0fa1f1fd2944e9e9a8388306cc3c1a558afde254fdb00fcce708940173aae93c9de6f0312f879ce4bf00d9012e3cb0ee3b19fb884d715629966bbfe8a8d47db6ca7cd8cbeb557c7f11c206926a8199ab54a80493644370caaa6dd9d1b59ea021fa1d6ee7056f7ca1857b732eaa79385e54516776fb9d7497cad45383d5533fc4621c5b1f3b176015549ce9fbde593212d2b43b144d10ddf29ed0a94ab101ea1f96298966fddd621ff0d8c3bce890ec0628779d6626c41c72fd9c829ac5d7d7aac7b83eceade750ba0215b53b2a70f91e58c271c5f32e70796b76b29fb06390006e49567f912519cdb43ceada9e7504387ec351e78d5b5f8d695fdfeab1ee0cfd5f118fd031a4f18808be12dfc600a4d8fdc4dcac42d90ad7835be5697354b13071bb4bc5620b1f437895ee828e5b273cf0caa897d26bd9e878e26c968f98989344bfdd3334a7b764e1d43393a36ea86152332fc17d2cb4d72a1a7169e81599a64148dc31fa8d6d473709b6acf429b8b4096145526a721a59983bf0b10475eac32e0af409dae4e93d316e6b29ff2589632b77d225e344862f4c27ca7e2a5d94dcfc4be758894974670c1d2cbe806a4b8ca3cf78082d7f088adabdbc2684e37e0cb1ef0195859e97fdb822cb5ef12f28a7cd248316a7e5af2f8b59443af52b802209d6a103bcf4e02147681753e81d3ca4dfaf356e2c6e4ac3b763ad53094b5282ea14bc0a2b4a8a403a80da8d97d8776ab8609201ee37e832df33c5ce7070ce13422d8ff5c0580f9421c9192618228b66ab188a3b6a82bdcaa715408624af0437d5291f015bce511396107439a58e65f1f95724e3b1cc356058e26c868bd7438bf908ccd4e6b369e7b9ced2e936e61899f6cf323d57c7b478fb4168f5b0badebcf42fca653e3cc33380d881ebca60d2e0f996e1feb9bdb015bee757f9f8234edaf44e9f3ec5a8790195a5027c0ad69dd2099a08b2cc9aea0e11d7a4c498cdffd97724412114c4ac4c0dbcb8426b5154beeb36a94118458c7d1280ba028eb6e0458a62c39b52fc295fdd5db02df5bca9015b67cee6cc6b94aa0907734fa54118232206b7b0eb8565a07ecedd59126b109ad3f699de9186e6e87f134b7f52ae61ee41f936b09eb8c306fdc926643fe3c68802967fedb4f3b7461b1b9ef65cb508454a95f3112889d426e0736e8f5968b747fbee5b2d3507f949858792c76e90a8907ae3ff5725185a202fa6299c2d46817e4ed81e9d5baee5364a232a0456abe8408c7c847c35227e751692e7572bc080b55e6962fedf546fe7fd8fb1543e0f1e2c851b3799ec82b609b90dc74d203f210818e10693330a33a19c961468e194456391b02afe53f406636eb085ba4e8944d96ea747ffce0495e55337b94179b09937000a27671815c1668f453556caae8889a2e2daf04c9c5c67658fe97a36540d43f5d10c49e2b590d1bedd7e250c52a0a3851a71f11881392f63374afcc6a807e3b6d8af269f6e6ee02edd98fb7f686cce0acce89f88362f661e7141b7c62f3e6857b7b7b3c07d104ff7cf5e6aafb4baf2f7352c6c2c224391bad5ec920c554beed1385380eb3fd24c5c53b3ae54c90c2eb5d56a982066296854d9ecb3a3b8f0099c59d159aff12661686cb98d1f61c6a46b9ab84fecbbe90e3343b1fb26eb6835a68d224713279e5ce2f195586572ed68f23271ee86b90647dc4a9071239286ed6641a1819f28a43fd31a665e18756215f283775e8d556ca0c94d6186888fb02483b95d4a5aa3d63fabf8e97d2428130b4c5f33ffcbff303be9b2e39406ca97a9a004eb86e9d40f1c554bc9f00e7e4865f9c12e64e6f794ca1cb5a0dcf375046b739df3e76ab99dcd517d3aaf3796d0d561a651ecff783d586fcb340b7eae0a28fe782002c9fe70d009015c8619bf409bf7566fb75b0f8be356998990c10221174b3611e0c41182d7f87c2191f42c78cbd07911861aa2ac7a75e1a9c235e437c4591701055ee74b2e4d724da822f3375b29ac8ee7c63e279bb1ac3ac03d55130d1b274bb42c2ac17c2e851fc6c3cbeb42ff5675c2b3db6f6a550c76669657e10c42ce5cc728ca7187db84e522a65ee97c640f1cc9e12236476274fa8721662bcb184c7b7ab0aef016724f6c18e6cc2da75cde9431a34c4b11db16cf80c0b831d15689028fd468d03a0ca571b2f6f9645827b4c00ef0084c37de254e4ae4b0a59e457965982121d6661873bab2d33f5b79915bd84708c6f4fa5c39835481266cbf64b698cc86f551938ee3cdc7ee04c4a68e99248dd1098f2344e30bc4ff32df33cd46ce25cdf3c6327321c53cc8f7368c7e8b5930e7f87a34808a4c906ae04af7a48e66b4f9789b9b625683e96c386f7bc10e8611a23d25e924cb8113620b7426840660392ce877d8150193e53e41d2045ebd02b0b1a2ef26810343438b2e67303dffb52cfb6276b4d9b73daab423a863f5f3946853706b3b96e9bec77601122485ff83a2d2728cb1f17189c1652d5c3096d49fe937777a3c54cd394f714f6b73f3af139cca40970e06d26ba21f2d760039c1430a934853a64a686c53bd3ce70fd3209a567f5821d750c1858902a087202f05aa4db6b84126d937687fe61e6671e70fef831bdaf44d8eed0050ce6ac42deb785cdefcc704b6216dbd9751b63c117034718d1d1d64da980ef77638d16bcccbdb4fc8b79fe1cb650d8055ef8f35cb3d1356e2cb369415a330eff9550a2f3b4a000f378c1a822c80a88a3437194ed091905f6461ec2324802a37a37a493f8f88b0ca71d149a14d95a444752a70b89fd025887b34c63d4a59e799fb507f27a7824a2f7f6a49aad13c90cb41556bfa28c6d8479f6d16bf3b834139e21b6ce9f09e0015e8424c039d99c56dd71b541c1995c136981899ae9f785e48c22508a0e78a32e40072db1a39e8f17adebe45266bcd75d045b9a0461b9d2c9c327cfea40c7d029c2169a3e5e08384d294843e28295f0bf4947556257f2220e0691603cdd2e40da496e0842d69b7e1b8c2032a102b47736ac699b993180e49d5032014f329d2b8ee70c9344667231cd7ac5d4937c3792c2f04e5059e6da58b17500b477ba7a5c8038640ddb5e8a91ac34233f1edd029aa07450676eb6fd2f1985158f41428ac40bf4d06ac56191347dd90bf22f8e48a8552b4cb1aa0838a12ff13d7cbfd1bee30a67fa49ee15343076964125ec890195ce6a5f28beade1dc75b5facb96573e8890bbefa9cdaf698485de1a99d3e02e85edd861e21500c86a597b00936a44a36becc8946178444564a4f3381cbe83acf44a886631597840687914536d9b6afc59d881269e86acb74afd58f04234075d4b030b0021ca760e8d30aa6c7877a6f260dd9e7fe526cf31592b3c7af7bfe82b1be940e7e2bb39c8a92d59bf45ee142fc5dbf5ffc50b09603360d0e787e3e0ceb26efbc7dabf151383ef948167ff717056ea7e8f43e509167c344d6c7f3a0c1329c5ae948d4025f78733bfa1c5a0e2e54b01d4c10ce41eae19823f4bf33843a9247bcdc9de9588b843a680c8555c49f068a2681db4dd2c43482f4a5e1518a95150fda58e1b720029775551800be9746de154d4a113575e3db8f0c7293e8b3424edfbb9cea3b50272881d892f40ff0d58afd579732db62ba2823dc58891e37058501174b4c37181dc313f6545963326476c3236ca1aa572d9d938f5df787a81e54e3e97cfada26788c2b3b125f0bb5ef0b841d17dd087aab5025e44a09a862b797e407166167da1ac6caee35bce2f001f9e883a302293689e529acad147f67bb644956b1a16270fa0af03cb65c0d0b08f2879188392fb6b641e5d99f81ed6de459fcc7c087f1b48e75dea0c3a7579364e4815c86f2666a17fc02ba06bbb365567883f7c149ee98dfc6c6679b25405856c4b4c2406ceeb97c089b3ff12b67410f7e9c2f0db78b3aec12690c8e7f125360c059a2b987ba3fa6c6b59a59ace99d6384a760ab96790dab0be9d39b1c9ebb6f772f2cbcd50580ef920085e945ae67aed32ae680730b035459ef72b99cd2acfe5d79e947bade175671bfe1e7a486815707938860bf3f431e3ec6171ae12024358c290e3865510bd365ba082b2425e679d8e80b36928e7157f44023126f189ece16f867ac7cc5e93ef57e66bd0a343b9078e2929b080d4b77e402765ece6db41c9ac030f0ee3120fe9d209b8059a2c33ffde5b9747e4c6cd301d37786948179d157d1f3187cd43cf9666d5532c7921eeb086479e19f7502160a9063da472f8a511f30a458d3a0613852e184aded8be0a36ca0086faf3c159596d57c45a256b026e87e8fb57012167df53f98c18942f9805e451dccade8923c04a7157c22b168fdc6d05b323db2f77a9de90706c994b60d44552d8e896c8c5795e2f8481d622ea62d9166e51e312358811585f7f5b67241ee81cdfbd2816bcdab721e2cb56222095d9f7746c8e19a94e49ee83d0e2b6d7229b597100efab3a9e88d285ecafd9ae32c532fb607c11d99ae66e70ea4a53517d19d365c46b8baba34a35bcfb5e663700443a5c0da2c93dfed8eb030e179cbce9c457d1757f6fe89f909caaccc98bc4f2ffe22c357629cb8ba92c5d80196ac5048e35a6757970220d461958d6f64486af831442bb3889c119b08fe7164df085f2a11ffaf39f71dba83133ed50d79201f3540b04bb8df7477a608914a1e6edc92e776131f3e1eaf6b018a203141a8b82054bd21a3db9ff135fd0dc3bff8c0297ea15e31cb61a2fa1cdb01b4ee2f4c7d4f185e6203a83a84ee7ac8f3d847de076ac11d0da387e974681307303c8a1dc35f22243d5a217d88cb9f8b653357f4a7b44c62ca97cfb53271958b8317151f608ee3d5ecdb75f0a0725bf0419e4a8aab1d369173a2511bee4ba54d714ef60ac221918fd99ba9a27544755ea45f781432f23a279b28450663c9dad820f475d19b8c0b4d89777e43a1152ebd1583923ee45e4110671b39e0c3a625ca6562b2d68fa205a9cb1302ce26fcaaa985f02836ab148dea775c2c49ed4fb37ddf45b7a14277b4c66a3ed7c8fbd92d0885cfbd96c109d69e189f2bb5fcf64296c84801a27a8a3c9da4f960de54acbdbb2a5dfd366f8e7521671ab6132beb3bd20a8102fc5c8a780b5bd3e0aa6795f069f5ccd8de8cb66451b37bbe9e17a00478348b2d4fe93f92f602b84b4c56700766cb33a0cba80532782808ce9a7dffdb11b82cec6722d230d38feb994e410716b2eebb43c3723106a16af07b32792a2d549e6f4714d59c8794363fe8e26575ac2c0bf4bb5194caa750cb337bc7cb6dac5a253d9b97f8ea8633b25ab0b64295c11300d52c96f546f07db1a2cb13fa2f3412fc8cfb33816547d21ffd3da717545cea7f4ca87bcebc8766f1e36d2b6b208984455ebbf6a45d9574c4e9b81a0c92ba072320f7ab9e7e4202cab425d5fbc20bf8949b0908b86d02a05663dbe0a872c202b835eeb5fd66b7c2f0a8e8d21dd296713383379db4da9563e73872488aa30f90fe68597cf96d4abee9de09d9c7180236beb8404a22c9787aeb6cdc4152b00ee5f6fc8ca7e231e54c477a0095fe5f5e939406adc6fdeba816ddd48e971aa026eabf2614dbb60456a24501af27edab319a1042f860440c21670359f7732d9bc5abf976b092776e7eb7c90d9af44f404d5aced22a71890fd688e809200d02a864dd324f054c0f02a0f4336afe1e06c7940f179eafead6cdfe89cc804f0f2a97a090b4de8cd65b803cdf69f43538cccba8b76e237afdc553a771503869b147579dbd38fe32cf20d8e754562b6045c9ed568dda69ca0bda5509cf0d3250239fd411f5e613b72f975b91d7fd163263b2d649ad9b06266d43c16b0ead871b219efda6cd11a55ddec900a581b397b3ba399232bc5d0b23d09b0881269f14c25ee33e4e914241de5068e21a1bc017548a48844af20c7306e76f2a8c0408c063259802f94c033060e56a7853548a848ee6b4b3814448ec26c346a0b272d7549cbfa13ccee5954daa29e1c87b2273819c78805660432d7565f60f980c593c961d6c0ae70e84a20375a1d6b8c73aff71ba73f1ec7c4f60f6b95705ea0aef1e914cd5c53ddeae327fa8552b3ce3e6b29937b020b2fe7ff7556cfcc68f640449c677c5f643a7755ef78c7b2069c9b263a63c4f6eac2cac1e220ca44f669d90b1df7007defb1c71ed5925577f9e1ea6eeffcf88c2b9c5ec22af31fec239412b4e79b73f0422d59b15ce7cf8a42245c0a042ff26b14d2379a6168eb33af916070c51d68c36ef9e711c381217432425be43d99788b866f1a2c3572ac7b6cc77b4be97f0fa5c4adee331cdd94a3b0f397336334c7399d7a1c7257690f2ae9b808a5baf904c650844fbba22694a915473e3dbbf56a3ee8f125e35a4c4d57203eb5263b4c5c0f40c963b1e34b7db59bcddb2edc6a070698e9a43deadf24798e6d48e1df00b371c030755edbdd2433f1b7ca0c8de4195043532da7cc46733c1ea0f7656147aa323acfeeea8de3d86fa4685914449c1686e118afdee77c798445d76d649d2a9c1101361d053c1e5aabe20d64f71f2f5642236d1b1f9eeb4e2aaf865c3f74d4808d3be8d904cc762d5c640a3610e47e6543ecbea31a3138caed05570257b8f070217d68340f9cefcb61bbc648feeab6a37e0e1bf182d5ed330af8d458513b770647464b05186ab5a5af4b47e571b66b1ec5f68b2791cb849bcc23faed6ec90cf8c6e248e5f5c3bfcb79972c0893410134a970bb4d8a11db2f32841e05a7aae7e894d1ac8a2581b2b6506fa442c9bd6714892ac514e967478d4c75f59f4af6732cd57afa2c79f7c17067fb0fae29f2da58072b02549fa10b3adadfc0ae50712a2b532d0046e900adaa899d75c949b8114716794cebe86c105037be314cefad856fcd9604baf2ef7ed435aaba71738fd8e5c3ffbeda0f55d6eea8b3400e47a80fbcc06b8f2b621857b16264b04a5aa889143b1428baa217b3200a964ee215a7b0b057ab2b37abbbf5d66a3d1ba81afb37a2978f17393db6fb736c72c75262e21da85f6f325df05883750582139383319e753f36b27a30821ae7e5cec47a00e284921fd4206e360f7f7de1f9e4a46fd18fee74b33bf50fa6e9c3003d28ee966560d2426163560304e3ca4b867969a4a2b582100ceb137d2581eae75547e99febbcb909c5f21cd6f5827d55748cd4976b514798f45cd8346f107ad59af325701e38140b0935232c5592b547a908ec2408d2fccae52fd68d257231ec5d715ebc0443c9b4a0b2d9a5383c366d8c1811ef6eeb9a194096c4f9156b1e59767dfe4da3b904ab3b22ff4aecdd5a1d44a7f77b81c2d220698fe6dbe79d74dc4efec5715d3d0466f0d8606cd71ad7c6b8949ae9119f114af05d7c8a9876880e2202b2d98e8eae4009a4af9b6f15b3b9fef4ac2de619e5fa4fb28d527a05b44a079c01bfc87422dcda42eebc175d7a434c5e2f9e75337890533725de6f6d67b19d85c55f1c8654ecbc3f3d297ebc2e1f42bfbebce822683809f75fd4f10c28edb7710dee36132b2069306107e03f719308c3e937f5c57c2e7dc47cdbf50a4591d155c9372cb214799978f873ae15e6dcda8a7be8fc75e69c7caf8f1df151de98968baeb8d17747c0d1049533993ecf6886b8d0bd4ff2df2178e7c7fe580bb82d56653958347fe7fce6aaea0b90bb49d8ab59b2beb44871640f8503ac68fa9beb36017a666c92707c4a58c68a51ebb6a4022879d3fa019a9d8c8ddfb39fcfa2d021db850802b30e20e5ebd695e4519f51dab1839953018d6b398961bfd526ae46e317366c78a56a25ca253cd4c55429a5104e3cf030dc583850e1ad79118db0d5b13bea16cb1a35c2771bc66af4e4100b288c3a449aafb173c0bbdae73828a5f582d89d42a6cfe2225787a85e5d1f3548e41f59970c752cc5786062d789d5e741787a3f4693d7810cad3e9d918df3c0d2a756d963ad0d03c1b7151b630700d72587a252f9b088f7bbab25f485b5007f7a0a94ff7db6f77b27f927c1fe023eb372c60059b716af4a7aed2681e16db9e13a3f4b2497d25f14fad26b4382c2238435ecfe08e1a4005710e0a0da179b6948fcde48bf95a4e3ef5fdc52b0512a45581b5ceedd85fdb8516aee1c395dbc81d0bec8d85d1d8a32a63c9e667d49eadd6a1d8ea5ebe6f18f9da54161cf9a4fecce4308d20ea7110dec47cd658f557d2e9760e4927654285a55457089971f738396f9fe60fbcb9d38eb5a40b4eb0d774ff0a529249baae3db12ff6dd4d4833e66b88a7145f2fd7911ae0067cede9ae989036b0e66f67b495688fa3712ae10722ca3815b023596225bec62c00e1ad4477d301817f0c7c85f6c08d3a966f84450c7a8ab9a748b56ee02ccb66aedb2c30b4d2ccafe59a76efd67e618be1dfccdd4a628461e8f5a0473c7fcd3cc235da2481504e1ed07d02bb99e878f7ac8a244d9f1fea0ce2d164180a7a0bde23c2f264e3d4e26600e2b43b81475d589a24d21d56c18b3311ea886c9ace4655101ff96da8444bcaebd2749c66bc1e348f4f80fcf35cf5927e67e30b15ec77db9ff3493e1b94eebfbad63a854ec784e5a92197700c50a5217427e3dbc84b9ef73af2c96478c5c047204694a3a9804ca507d39f8f94c40482e46fec4aa64b949446e0afdfce9d161010742883d2a77936906622a79cafedf88de368a77acce9f026d88a4ba94bfb0712d1695dc7894cb1dda1c2b780404158ba56cd7acb8d6bd3f437077e1eb7df9cf66241d9de2aeb28e2ac42da2a126ea8f75183caba713309494b4deb2202c3d89bf18ddfb39b5b84fb8da6a7e4eee3a1f2a2efdfc3f23491f28ef65f428b724ffe747207de4752b2aa3d2e00666df56ff8bb3c58b74007be73d6c5ce643b54373ba3e80871bf1bfa394d049bedfea241333671b7fd210c6f8efc1e715f2e49421dc0d446153a9f7a729f73bbc77f63714aa5a8e3c1540b8c84272912b5921fdfbfab5c5552432a68c68cbcf458aba6cca8fc4ec3f0473733336368e5ba8f012c15575748f5d34e317db6846262ea06bd933d0a39a48a35f46af6db6036d3285fadb29bad660e651ca570ef71b1925a6b1bb431269ce1d61e2090014f237d13b0ba5f6b75bdaa5f17090dfa3bb0da2872bb33a53859db7046fab6edadb41d26e2e513b6eb15c5ad70c4da86c7bd156d8c0595823f2c372189736da94ce11f298823307e4feca5b4742fee67db20ebc634f78c3c78017799fe161d2d2f81e140a122bf43e10e0a7c27409ca7da252d22b9c8bbb28f1dbb6c2baf36b60305a4399ee4174dbadc5d13d35d22fc8f379a7b192c3aaa515227cdd062e7140a1af23f7750f7399e7afd05f2cbea48027a42c509da02419dbf33becb37a6a7e0163217e08e526eb897ccc2bb4460a46a16a07c9c36233d906a4d049e236be14a88f9484be7bd7be9ba9400fcc9af0476cd3fba610c11aba090407b87fe1d439ae7ee27f320174ff71b38c585b5ca1092e032cfb56e1c4c19f6afd84f2815a547b1efe4126fd956f1a4e50ea4e2a22a84cdaf3529c4bdff4fb449b26374ecfc97355f31f294bcec8e4600027c4cb62f6e61beed8c90adc21bf38b51c98bd704d18d572882648d25448eac7c60cbecb6ea469640dfb2aea42bfbc0964d508b4aa6564cd1f45a1783ba77c2726570f466c837ce81d304a50e90498cd4f9b24c724587d98f96741561caa31443f25b033230b00010309c910cba9f4b26612fcf2a822c95d28784e8f8183a6f784d1e453b5cc2d83aec1d42d83f70bb7ba9d8d83d8cf7d524cae393d6c26ce9bbaa0f15f679d60f1a46a15744c9e818220028a68861425614ada836e7c5d29852fe0f7663d3aaf2ed42c85a0e1bd91706fb136155e98e85808334d17a16d05f0dcf46ed4a01031a94e10d3992501f32c2da81b9ff068371bdd035b9661079adbcad2f167525479fbd2b94e432b5d75c7da5f76a184bc6de00833f502e2cfedc577c9451e0c0b0a29a595a816ab22c6c912d65699248b62b976fc59f98a963e85193ac1486dc1351b23ba555c10697abe1bf975276d6af927f037cd5faa795d5f142dc3a8aa63fce1e8c7f493f9ae6988c79cdc210ef99695a935bb3b22527ed7a3037616dd3405ad584c007667c3d2deeb6d6301c6ba0da7efdd87e09289f1d158bf42206c88ad08417e3734441c471f11c319f04776dcb77ecafa403ccbb05116acf4447331548c92958a38d5b0776b118d81ed5c6bb2ded3c339b460eb72e79c64407254b0bab6881af9fbe448720e592015717ae5457bd954c7589adcfd520f191ada1d1383da99006571242139213861ce70606505ff3c77db9997b92bac24dedbb7a9dc2c727f31870e9e84e876b2c983fa3bb5865e92f00f70949e205bed073b6eea6d9f3ffa00361a159bfa0f3d592c717c972f663071ae7f0fdfd8351ad656fa031401c3bc69af338137839d74a5c1492230be8f5dd1c6c1cf27bdb21ab77faa9365a617ce45c228576d3f9e7f7c567d963485d64ee5c55b7283742d777e3130ac5b09b5590a19f70641ebe818af42f8cb51630f97a323d728c71d78110e2870b427ec53853a0d65f9b0012cb76f86175cda1ce68d8c10ce2c22c7dfe279466b369b605a177d1243c265a0552fcd227a41cbd3c91d4c7022ee5e396f2c66376c1f6bb55d33de01c6775809eefa8a11fb0192731498fede3ef90e8e3b2733f18955b3fbea2fea5d017d94419c45fb6de0608d7c607ffa829d091964335e11ddcc5cf90d35ece1240484df8aa86b3c1986a0188fa61490b089b88d4b487e907f66ee12d3940867b296711c127a04483f62df245a3b9c18bbb10112193c779d753a088b72264543a4637a6c15ca65f33529d2cfd0f41918f438129f30625d0c000335018fa6fe0197bddbcc02a9dda0b3c573b5b733ff140757f2af011498a48bdfe6aa7698867d2409d14a28c9cd398f3a1648f5d3619a337d6870a5aec1333d351f63db2753543ee6d92d5485b1a50b82ad25506702b2c02a1334fb06452d3312ea82f2cd839fdf3391b6147e3789c866dc0c79907e763c80b83c0558446916133e9f8ce10227cfa78035fdb20729d594dba600726448ad8bb8ff1fc192c30a1f8593a6d14c1ddf297d988dd58a0045499fb7fad5dfa3d89e26d3a05e0b5b177a3500162a9563652b1e772625d3327fd2b06a15b87452b60186bd69eba2158b887567735a9d8913c5d1f0d97413579161c8976be62252d5fa910c5ae6e22cd465a0d10e47e1d436251d0a0758ae012b403efde0e084d55b6025d8a7add39f0b0a94c717c1c84aa824df5e83b943fb13b34254a03864b60fa2ee4ea06cdce1b147da0d0b04ad61f57022aed7d29f7a278c43a64f53b5abd673c4aac5411f9055aae92653a653e59626aa8cb7a3b1f856b45e3d4e7b6e8e171c264cf81ce05b5a39aa5ef5e2c9d80ae94e9c7dd001c7f376165b61297a10c9b12e12b38ade2e9eab025558bbb1a690bcd4f9741a8719b265fff710f9cf7053cfbe86c4de4e4980b9ae18f3d65494b9fffe27ea48460f87ce4a573527e0641722379820fb15253805f2613b3205cb6d2a266432dcd72ad500ba4d3f0f97460b0d580719de3a470789f1e3b18794d8b3b5bce5539b3bf452274aa1f78fcf23bf2894642b765fc7c13026dd708e93601678270f589dd273106cdbf1f75f65423b40f2940e15b211516b17ca070da0af5869394714e418b4ee2c612c2181a878ccf45594278dd2c83ecce191ead2442f0d9db6f27e852278d3ef737ef2699a8a6a05be90d7529eabd48f1bd0939f09aadb42fa0ba4e22a65fd3396b2fb96a6ef0941806db29113e0368fd963501c48bc191aa3aad49833270b11329be76c86a182954d46b21e4a3de502c6c9070d9abe4e474da7ea845b7bdbfeae5d16d993794dc10ec61b120e7c7b3f98b9e3f02f9893177bf8b4ec73a238ffd3701a2b4dfbfb75f3cf8911aa46002ff23200872862275ea7fd6fde31dd452d3dcfb1cf67344ea9db49d7604176ab096a199583a23b8629d4f0e3e2eeed71e2494aaf475e2a051f590f738ea641f980cc88b43924162ace290fe47cfbca8a5d1847b3cb0d1f02a9b18cc333c1d1082e2e4fa1c68b96a5c8c6ac9bcf0ade49fa19d198921de995f59163b5dd6321e775cd69465a50b4621ad4c8acee7425ec380f9da022c6c4280e6d0820b9c03ecc5a20a345f60537abb0083a497f58a79eb8655f83490572b42f42c48ce06cc5a550736023cbfd8c90f735d68f903ca7640285130e874d30ba69f1b3fc86217d6f8ca6b0d25371cc37debe2ae283df4be397bf17d18a8bf82537ba0d6c1e57fb3ca9c4bc3543eaf1f5b8e0ab1e73a2350c18c42cf4df9bf33dc32b5906fea2f52acb5781250099585702ff227639c7c5a7d79dd01d10594c573a62bcf64562c9b5c65a324fd1df7456d6da021daee268f77e5a8fd8f85543f1134037df04c49130dd86a39e0e48e0f127d4deba25b12db48e0d146d99e47c274ab444bca326c250edfbcb26cb540ec7a5cf11c0daf5e0f5aca215f9b93748fa798b9a416278b3acdfb16ca538bc1321e8fb7eb379d9992d8ede489bffdad02786389544b5d80f3b08c9b854ac624eb97d4c5bf2a42b343188e0f691c27d9c6872c0408458c353ec6a430ea1811970117eef9cdc9cc422b191587ff1b2653c55f588f77906fffb9b5b956a9b182a84c47016acc73662c3bf56b0ce1934357b9e1586f629a9bfeb2dda244f23d08fc5cd119310e31ca2e4e3fb7e146bb2add187b458a03eec25f7b7a8354fd8d1d4f466e203af93936a3fe9f6f44122041f951f4fb6098bf1bac3b22039d209afa4a17a87bae52125fcec2d2a1076cd893fcd5b05d67518dba869890f816e1a453f15bec8e7872ced13f190d684ea56fe0a9af9ee8a8138ccf1249f06cbb7cca1ec4efa57ca0152faa300f81b3c551c8a1e573345299e2a6466fb28c0ff2e0b6e4e4ef0661db54cf4e699fa676c550b8b0f4ec4a881bac1a1474f7b2f4a3221082a5f8b55c033851aaab696c6af06309c46e1f2ef1364b1937c4652ac98ba14e4143829eb5de6a5f64bd6ae1aa63c6291626453943fbe2a629b131ab446362a338f7c87add404106bc9efa5c36de58e000c0af0d7d3c3c54ba67d189d58ebd661617ca06b81c0c950d1d78a6ef59e050e6f98a820a797f946e43a9f64299a66bf5d456a2a6b3ef678a11788b0b7b4460d630ad4e75ac19226789c604d76708a8ff08a44997d94bb8e40d07abcc1d78f8b3eee63c3b04a1b7344b58893cf7937913c41288243c96c2b32aa67fb88a2b3286d0b075398eb998c0f36e108ea8ded933a696755b3b79b8b3ea87656a34808acaef378a46c361ae3ade7b96700a19518ddd61e12259e51d08a3d6e2cb6994a8b86771e4c159af69bad4b596ed005815dbd65c3fc0378d88e3230d8c4e6db88f4e80ef624e3c765883ec15ba7cfbe4d05374bf05cfa4c080b1ca0dadd7968da4a4fec62b1b1570b0544dd6fe44ad5592e8eedf15819709d986443d14291d5f605060a5589e879fffca0162ee6ab7d78479d9ba9f942d897cb8335bfc5b7c854e31303d53da1d6b6a6dca62864837cd36e89cfb32d6e2c18702de069da55eeff427c6e24bc90be6cb1105786f3593d6d6209f71d40ea9989bff13d69eb6d9cc3f132e76ac5d10c6c3c890adbb98ab743626ece560a6e2cdfb03ae2e572b3dcd6de40974201358cb8c8fe6c2d1dc8553a656cf7210f4a7cf9a24c6eab1fcfea4ea544c5dac3bb04f06f94f2a7cb3301cb492779d49f5c71813bc8e407fcc776ac7f8664863855bc818dc22145e089d7ef6d26fc50c9f1f00f29e36ee3013ef6dbccd1155bb2418d50fb5e7478a285d67e3fe41c33566e1cc7582ca0566c6503ebfb0a48969ef8d3e2b9ada4b27eed84fdc5cae931d1f0bdf2f3e8942f3c27aa8e778984fdbe583f067e7115e2730f769515bf911521335764282a80cc034628087bbf77f814ce6ee89fc80ce1570d994d54cbd96c3f07b89d8bb1b559f83cc2f4defe3c4032c3112b5ceba6d7b9399071dc65eaeecba3cd7307b4b504e2b0db1efd65f069a6bb8e770cc971e640ada459dfcac1ddf455f3e8947ecf8ccd79575770517805c2d700b532296e40e3d6639ea0439625260f7c2a94cf79b75988816bbbae4559f2622123603dea509eddab32e488e60ea093d7c7f03bbdda5897d9f7af20be812b282c154f1bc368cabfba92228159d460f7ba1bcc2071ca24f1fcef4","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
