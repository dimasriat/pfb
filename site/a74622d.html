<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa2bfc8e641ab4c6f47b25b671f491878f721aee7bb5c518a1b6ab0a653b890f87d997d331517422062d2232a6ce7f12acf92b0c1fe190586b4038ad9020da45d95235dbcff40d491cf6a90b15c6c432f9ce5a7682afc65a3b8d6101c112530e2a0214497e0e1b6854ea4e8d2e55250cd70a06e8f3cbf26ed5a28d46e037c0d28b0da83a44b2bec8fd7e769ba228ea46cabafa4eb7d53366ea0e80e0d1ea6f7af672fcc33b07f6ea27b341e8221b2e2751dd89a086a4cf4e6c0c0f81dcdc8c79789bce17df954003e91ff601290cab77002f15b700aa6ef82e2a258737d11bc73a2bd62acd84456d23c96bac808d0e9eddc01f1b259f5007f76b3faf0b425481ad47f62482f697435ea5c839edc1d26180b969302efba9dfd87b4e15676b5ed91fb8d4d9d34364dfcc32addaf1c4fe5fe34715818fbb3ec7a7f79bedbe80fea41e67b5e122cf66919447d5ca2cc0352ab4b18f6cd8bf4eaea3c1f7ab609858d8bc05231e64fad6b6889e137980310e36dc69ec9fd0a0559795afd6b9a05de1ca0e8724aadaeb26bcc5bc26fdf82b92f592c690cf826beb24d1bbb476c6c7141061ead0d887f4044b057c4d456ade0e1d668b5ff11fd76644f9e2d80c5b26479877c11101e56327dafcac3bdf5bdd3e3cfd3f5d370fe0884efc70c9f10e4e92d92d43495d709d39fe7b8684ac7b16a52d1ac58508df6bf5a00704e494caeb77a68060dc000c8f03fb871de9e25cf5716a554d8fbf175f5e78f19f310e75410776d74ba128d49cd3e2c52715dbeb358879fcb4cf556b23335ef839fef7ef95276c96af73e98789bbcdf9101ec330d7f98d7fc92e52405a8c038227ab62716ccdc274ac5ac856d831556df537e9b977bbb3933ebe17013cb804437b79d8de720b30e3cf780766c9ad743b47c22f6a3b9a6e26dd231f1344916ffc551f67e86d8e26dc8f7fb1d69d7b64a8e98d2cc64704de808fa0c023847d9b7e4cbdf6bae93fa3905418524614f9d2db90e13ddbdd8b5efdecb00fb7f055ff794739d4c1f8195894ae22cdfdf6af62d9ff8a14ee497db764b8869a1dc80ae00348fb7c0de882925a21d3e11b6c5400f3d6f34ec1d15bc87c4decd8c45a3cd7200767b1ffe5672803f18bd1ba2ac5000eeb644e75cfade121d6ea452f1241eac84ab7e8dcf235c29494eb478b809625a402630b7ddc809f35e8820e4b3177b1d6c6a5088d8157da9dc82f4de2d7133dadf4e7f292074caa4a3c0ddd9a9045589c92fad119ea885fcb58e1db5265da85c6fd41a534fa4395356b28e2a4bf7864e695a93b82e0c0dc60475dfc604b8aec5fe2bba183b0b9377de608f5cc58894014e02c9e71446a01fcea6b8bcc17586d0c6a0bec04bf039d4394458ef015cd23f331254ef71aff0eed7bd7ce84da0f61d27014f53d7f6897cb53b327a47a5865932d983c60cb52cb55ac8c9e9d58327108dc9f775041f385b86682d2e31d163cc63ec294f2e9e5eec65fde4f22cfb60eb3f59878f3d8e22173b76901ef422c5551c384fdd9828c5f5de7ae3123d583fac5bed15630e4ac88581d148804d52279d43371569ab56c7edd7ecd301d82dcdad456b9fdad6d094b5bb91b10b7d496778f4a9892c03977bef1f57c7456a32116b874dd4169e10dcd1120736d5f20c2b8e59de6ab9091ced9f8104d58c37349bc775fe262a1946728fc09ed3013223a3afa0e014def064fb8d658b2eff3c12bee2ceb2e2156cf67dc19070b5082a72046f11cf39723996b3ccfe5eb1fa1e2c5a4661fa38c01061fddf1deb74029f21ae28323255f31dc4095e953ce2cef4500fa3dca8496a936c123a67834159ed32a8aa1e5d3baf538e7d7b351c08ac6533972318971aeb6ddb139aae00a7167d2dab33e451c11b698d676995b540944768816d7af11049ffff525a5f2435b5aef62d57ea352f9dff02015d45593b9259db662ae27841f05db5a7c5252376b908555042d5201ccde6b8abedaa486f8dbcd983ece49a5583449660eadb2e3e3a87f66d0074f99ad5cdd39674c41505f6ae5d5892f65e47316c71faa88a3179608f4d4c1e33e4112dc680e93e515fde925e3f0fea19f6ba749a32072bf3fdfd4f2cc10e44b8a8a226241506b6cbee1d3140b8ff2b16df31fb7fbb035ccfbccdb5f40344a013fc329f12dddc0d270f935e0f8e2df6d98ccd963c8b7ee786f283c174b66e6571950c39d68ba18cd223bb4a503c8e1685326faa208d7806cd314c0c3eb56158946baa9af4a30aaf8eb498df54adec573c818d40a77e59335b21ef7967e0e0e3ab560dbeab286be053823efc03075ca2625599b181b6113b3e0fce997b1c7ce5c24f6888066212efb8e4b7e88e97c2bbe7e10abd5093f4e52a1c8d5ceb61b61e69fbb5c681f1db8252d6aa892f26f22dcd5dcc628c167d04232f2ae8a27decbefabd06dc6ce9f84ca70edc08aa9250048ddaedaa358a7388ce0d8539514e7a91b71e99946a138171445fac293d7b19fd76790a44b9f3a1b965517096f1cbbecdee91dcca017e7f4045c635578eb64a60994cfe25cdaa8dc3ba71b59ccf686a634671381287b6a6a8576c474de4d06ef3783df7f3f4fa5169103129ab54a41371fb447f04d325d3a8be8c61086aae2f7b196d51426bd936f02732f8559ba850c6f8dfa8e341418f97f6d0c777dd9218e1d92d85a9c9f22bccf0678220ebb6d2470bf1331952a0b8214e9650b20930064c3e98733ea7e1218056328f14a404064e7e74f5a42fe87ce71f71cb714051e15e2d2eff7f0b175f1cb2d4edfc241b41a4c713b993fad13ca1d50f2cfcbc151979cf0aa6162b78081393ad0aa1c2f53ce4b26616af146bd2fff713271c2c128703718fe2b934d872840373b338a1eadfe98611e418dcd856dc28bc26d2775e3a8228e5f15fc15e16f941cf0d3128ced9d2ad1078ce246bb6fa7bb72184a015d3b07d36996933d615ec4775a2dab4bf19294a13fc6abc18d41fb05c5ec2afae20e100ec5d94ed77dd624faafc299152d13dec7062000a41e351b28f15b01db796e5bfd3f08b9f48e3e05ed9e10b258526ac32a1ba7385f58f57aa1eb605f3eafec37392c13aa4cec2623e6a040d1fe18e5f781102406570e316ab0efd7bfb47db407ddf0ef56a1b1e96e99d92b99acdabaa404c27ed6db0358c92172cc64c9988ee5e0baa841ef8e15126b6311ca42a5a955221fde98c811ff2b654f92e5f2286b843f07586cc9bc4a2050cbde83c7be56a2562d1410d74980f0bb6b633ad0f1aa6356d6a1e2675e9ba4395b2b09af02f302e64eed8ff07b9a0ab47dd6c6d254afcfc2b4318eb19d90d8e96bd81fe708c3dd48392b68df528f811e7a8ba6912fa3efb0d5292f80021e2dec5564c6f72c0f814d238bf79964d9b03607e917c7c9d1a1f885e33aa0d1d50adb913c7953eb5889a59d588de277a698c2e8e2f64fccf6e758c0cfb75cd3d1eaf6c7f31822f28ce41f259b8f74d4ed2add4b1ab8594d5174ef8b5eac3af3c489983a38f647d51b9e39c830b8d45140729f9e837a10bbd3277c75e0cf2ede5fb6c39d3d388f153cdca1fbfc3391daa6ec833b034ff481a028135741705ad359c89a48c93013a24fdd35e2ff84fd9fee95b00fcb2a3621907f9c5c65b07e1997d4acd4639508dad372d956ad34bacbb84cb4df45e5aaba1c7926bcd579a6618b6018c76fb25d843fab509e51f953018c89f97bdb912bcc6d18be6136af9be4c077985aa4c8599a12799ce52a257e2e4f75c3e7ebab3cd588612b3b67897f4c772689312d522f4e53917581ff9e8648729eb4882c4d2c87f76cf5b12686c303c9dafc71ee946af5c6cc3de5fe99d4d8a69b7cd6d0291b85d841073e2f4640d8aaf874029439b9e11d43dadb26a4d2ea268b48acbb61e5c9797836ac37bfa80131c7818dae25938b066853cdd5723fa392be73f0916f5497d20af8d08cd68cd05eb0f9d18117e0ce6d8bfb9051d067c5b97f91ab2eefdfd9201e3be7222d8068b9c7c5a8c4d4c7ce0fec4efde361fe809f6ae175b16e08f82d0d72b428eddfdb459001e5028b6cbf03f3ce39b507ad2be59af67e34b3e63832d718d3e7fb885bf973e1c5ce410eff822a9a6bfebf26435aead71fb80c85600f9667a91228ecef1e1941ad7804e2ef4766a39add7df39ddb036d89a2fb9742af2a2aa6379e06d68fdc0bc6481c1aa2ee48cbb280c74644bf0773d6cbb2c798c32537897249bc4cc26c1ddc8aa8b65fcc2a0ee2c0e6bf6db55649cdb69974f2ecaaf6cf21867e26e906826f4dc90d7ffdeade1e1a7ab864bb940271c70ea414799651a4c3af83e4c6bad829864ce57a654ddc446bce786ce09964a48df3fca8f648119610cf96f89572cf2b823389b0f3fefe7c014dc45f34bae9fefe054f4c5dd116b8187edd86ba9cfd4795f2a5d737685e9f9c8cc7157f208a47d8322eb6db888d6202237aecbdea2eb20bbff032bcd83f0242423160670ed7435b3caabd6e7369eeb39bfeab7305e3363305456a8d79af7c7103c9e52ecb666aeb486672d2dd2d5376e352a6ea2953b29e5d78808f325034429721db7bab7aa23f8fca53d860f22d4c90f24b555c9cb066ed1644608e7702138053b9cc98b94cb162ffc5be185490fd255232b4217940cd6c79d4abe805798f7f978629b056edb160d2f7d380d20d0189a8821629bca87d48ed972e46cf357c5629c8f03cd55df72590b352e7f9ad06ff70764f5d7b5dbdcd7f1d2d5e54e332b7999ee969cfa69bccd167ab9b323a741ef53165f42b0ab48ce335d3d9e4642f2ade606fcda08206ac88c68f022dc5c77e4507917fa41f81481defc1ec430d1aac52968528f3b809dc19fcad6792b7a32c4bc3ce2680bf0850d0b8846e0582486d39524f311e9608360cd427a2abfa77bfe0563207e9f32c87ddddee57d5905305e7684b7fc915b9809e0281c1c28784c0166651cf6893774fc0c8356b8c786e39feab131d4ac730eb84bc6cd60082367feb89fb8f23b0ce007e7b76dc22580815fbb6c8a3822551aaee5cf5999accc1527e47f4e448f741e9b37b91479a5688cbc0849b8ef577d46ff0787ef96a1bbd4169ef4ad57513ade67eb324efaa6e36b9936e7dff895f6c1a515f5e4358a6e4f64cb0fb2a3adc67e14544e944b581b561debab2b3e7bd6a70ee86a01cbe6a1325020dd31f1eb76f866c4dfc3925ef986e71107ce9e9e805421aa3ac9e2d593436b8ba4b446af8caa73076c84a161cb9ffd3d21c964bce7169eed8dca3a43faea1d61170459ae79e4d93ab60d729ada0f701748559b54e8dd8c97635b175a0f65cabfe3d67cf540bd43d018a11c5d60526df0231cbd5d4fb9aa580686bc159034f0e90d40a824f11554aa5d3cc846151123e7076587d5adb6bf79761f8fbf08a8c4fe686800c4616186905cf7929bec8f3faf0760b277fbfbec70d4c3894da7283c6a4b631641633ecf6e0bef4620c6273f067f20205ad841cbea92ee41fbf0d47453dedd7089cb7d2e938fb7d8015c2c3c8d7d9efb44d4f4d90f7ca9495ca507509a19be39e2461f06219e3ad78e6bfcad1cbe3c37850c2729b8ecaf9ba70946f01139e8a85575aecf0582cf32df6db9567b70cf79aecf0a30feb7867bc9309a5b1d924ac757d9e77711a9f9ca8997f06955af5a6af8093723242bb9043526a1108f211319c09300ad9a92210c0ac1c4a4b890cec683695600f5bb1725176c2c9ff49e2c14f609a0476642fa10862d6f9c503be73eed2506e8c781c2b6697e96acf1edc235ef18e2fba5c7ce93fe420e1e6702f3af2b934967ea8d4396dbcba8cb43157664d674a2ef717483d62fa007afaed6500e1bb047406f3b33d0c864082e8eef03371d3b157ee73ef66687c72b4581769c41c146ec5cb58c52c5903e100d8e0a2bf6426a08a4ea3350ba88573154e7850e19473d5e29ef8df9db8f33b5c3fa5024dcadc16f093c14ebd31baa40c2f307ac63af115e4f9fb9e4f863de76915fcca57bd01e6c98676c7d9d035d062f859a4a19b5550a8b89e4caa7dca654df3d7ba1a07dc56bd1799cabc26b7b1b3637a8ea821535162d89b9a317c8ab4af6a5dae1b041dbdd5860e85d16eb23186aa1858392bed71dffc171e358393790c58cc78ced0e9c9912f047f1b92a51d4437877e7d61df51c09e0fd80e83440ffabe1767336f555af1d73cc8a4b24ac3ab279e7c353d905d52d36ed046c9fbab3c49ba68d8a2bfb8164a2b8fb9da58e944d38aea4b98aa0d4167f14d495303630c4ee24eefc78dbf8350641a81f96cd4c4d1c2a40f08daa5533cf62268992823b381c6dd4b793d926fd7b10644665ca1efe1ce5a8f9aa33bf120d11e50291ba888578effe8414c86dca89aacdbde0a8b7e7f52f56c7b30649fae9dca4f8fcca96e74fb429e6a4cad3e98973f32aff4026c3cf6ed33c4750e87769c2e08337603a9d517308737823d11e95f6fc98883edc65446c6673bbdd8b0de6b4cfe5b4ed13e065e5612b1fa0e356d827f9814f3a4d2bfcf623b6cee3b80d25f7117727e05a80b90df9c2f7debe8966716cd241c73bbdf4b7db6b18cfe0d1f84e4a8bf27b77568dd3938a6e230d19325534d42afcd6ef99a5e80c55b87762a35ef662e2d5dbd5d4afe3d300ea8262a029fe7b088d70698c79afaca269c04df8c90e20ba5f0060304342ba722ddb950ff6727a25c64b41b929859898ff543ef2cbc76856976b0ed8bc6e59f70e8d64b51b5dda30a124f31fe8e5f18dc43efc4687e505f6c703666431ca30234f556f0a914b28d27bfc173f74fc6d458136c7298c538f7c9ca72a7f9b8730c1629816dd1ff9abf19dcf6ce8e50a9ccf5a6c1bc354500ed817cd8e70f6909fa12a37241a91974fcddd7c8f421d4d171fa1d31c5eef36059ebcc5ceee260133735d96af2004950311368a089ae7f47adcf9b40727a10590ae936a86e87bdf1ac746c60764effbdf85e7d3cba516982f0236439249bd636bfc6d85233940cae599889e0de9c0c40ac94c7b84ff5d9961830e7c6d2998a0876d8b947afe1d0ac30112c1c3ee1625399b4c5a7524640c6faf37c518d50957ae25d81a012215f4a9c71bc5a8d612dfefe1610a1da15834ec744d91e1461aeef4057115adcfe8f040867626baf3882a583415f4edb9ed8dba452c235dfc93534710109f6c05ce3fffbfc138cf108a049e8b6971320f62441758339a7d865cf1d5415c39173c689e2640db2ff472bbad44524c78313be48f5273dc545dcccdf7cc2d8fbbe43de8d19ea8f9bea90b856db711dcb458c08607a6db6f54799236e4f110db2ee11e2a95a3e248aa26d313c8c20250d13b3370205b8123df4c948dd5bd795f87fb1f5750bf26b940966b4587a379125958fc416477a26e8da6b31779faaebfc8d8998fbd183bc3cd7bb2edca1ce34dadb5807c59dc6dc406b6ed514469d6945ca22a429055dcd2ab2e1bd4eccb651927aab0b0ef816a1d80264b2c592724897ab48f5bdc05b398a3e500593a9d599e9287b6bd9495787f405574d767e714553563dc1df8d9015fc64d27833d30473ebda05300868ef392abfdd2352e636ba553d50d3a18a5375f24b4cad195467940d4cffa9fc2e067fef981ef4355d2c67555c365945501bb870cfdb3a404aace4b2b6b2df070a5f362659d5cba8e70a2649858b52937c9f4d74d24f6863b93e708bb52a7199bec55838014125df79730a3165a3a73a24eb29b897a7bde4c82c16b827bb29bf705ca7884c4a3f913341c81c25744993b63e7b5ccb179c17f9bfacd3fdf56ceed1af0f3ebeca292a484563e2d450fb57faa0491a552c5b8ed2630381b7c19ace853ead03174e20f61f1427258998deca393e03a3225d2906056db241f52475e3a1c3ce97905b5fd7150895246d8137c70ece96631a8769082a96f0f25aa55bf910bab2fc7937b188fd37ec4bd5db76d900f4f5e59b7f36331ebc0e3d167047b819a80aab2b9ec888ae77136abbe9f8d66538d9dc9b28a3b9c443039a1913e540d56da6bed65e0358491ca33b6ff445ce29548f37487a58ca7190aa2849c6621b2ad641eaca28e3e907802f172d57b05aac915603dc893a948403be4f9c796f606a49711179029c201eb83dbf8e0259574063bf062c76c33053df55c3ee2b986d62a1a9a648b8df6a406cdc26bf8505c5c6980f822edb1c393ed4ec2ae39851d4755d573b1e731817c3f29abf986792600186c5143a07664e74c3996bde57f3e0d9cb8587da5aeaaececc3226c6096ac397bd0117242bd8e368ac08fb6f7fd2a57fc0fb08212f7b8ea55108cdbf9550798261e9420e9b612945dd5ca039c38ec1de093a5a53c7198c0f6266651dcc9c3debc0cac4c381aec0e61c2fe6611a17b92c0e2efc8becfff1547de1d56a8b648d55d06662ae6d83137ebe907d92c73cc84918907b39808016ed11073532e2c66e1b17221499871ade04edf615885daea21189ae6a3e1896d88fb0ba119ef83477af841a66b34d18453cbbd4b2279e3a8ded8c1fbe35b49a9e13d4e2dc450db47bc6342a3b4de3035727d0b3136469b2746a255e7d4330d81ef596552b5264c067219259e1ae2b00b023ea81245378eabcdba6ac02519db06dcaa5bdcaf60ef2c3d567c7bc47bbfc251dce89aa30722ded9f7f6e0faf36f68a3df035a9091dee9c8edbf18a830ffb0b3385deae3029d0539a79f68038d1c15937d8342447404311d7850bea62af4dd549a7b944c63b07635f15df883bb364d80b38932d58bd41abcfa53e392485e89245a3d9f8b32681632ff13663f6eb69a54450be0a3b152557b953db91c780191b397b951372bee6d7d5a063e7d77f369167d3244cea9f2119798bf60652b8520fa87db07522c49c52dbd209f0e3b487da8f412e0820a28dc90fe8b2924ecde52b36ada4cb9f31e3c592a6e2d8d02761187a6ba0214dfa3edaf14781a2b1b154908854a4bf8ef0a297050a232bae2e707c683a7e07f3b9c7b68132546674151109d8d6e6b32b679360f9e3ce1c0e4d1473f665a6564ef0618a3ab2cafb0894d39ac31db17ed2ecea94178da62c31f866a652571a5c83530e8a29a6fb00617d4a176d63306f6f97b4ba0c21778d92ababf85ce564f351b471951779c2a4b6d06e125ead5ace45e57fc090f7e6898d238ad8da0321e28254c4a9c37390a30ca4bf63253424b578f8b36ab69b665c7e954939f85cf6ec221aea7a39d30a810ff98303897b3bdda166bf1c9de57123bd6370763c9af20a0228ad5b5a6cb73be6235a72f793661575b2a18de777cce9512119e672a319e0e67052ed053ff3bfc29ffd7f13c4a303910ccb4201cee34549496cdbece6c6e05ee5dad18adbb7ae24c8268c9bdb333dcf8dcc8268ce03a27f4d0e8aecce27ce823b351c84cd03ba560c21cbd0378a22ebd19793e050ad8012d93a894d25870020efb4747ca04b692a7f58b326f04b1849a2878ecabd5d5a28997fefd998dc45214c8fe93344e32a887fb8cfde0164713a2c967a25a164dd489b81af5b172dbddd1245c6beb91d23be4545781f218ffdc6e6d258a0587db94a2822dd00684a09b873ba7bb318464fb93369d2df47ce05425f6333e472b27321a69b1372a4a520955ea72f7c9e524b050e2ac52ec348624f50a503bffdd0c6a464d14c08987567733dc9fac7d90376932658349cd5f5810e701f15ea9b344ff371d64f281d666f937fa598c43ded7f514db8cf4e180a119585784f8ac76b35b2a65cb01e3b2eed6b3ca7ca573fe982d8c2cfc90d1d5d19bfa51e5eb958e0ba417fc4ce7a74eedee19f5440a7a5dd2f07dde1b21a319e86afa46c47f7fa54ee7c26c67523dba13a99564b3fe1105be83614144f6e059de322e5052c25ddb15d6f42f0263167edfe72a8423ed3eb4594a028a69724c4fa08a4d92faac64fd0b3de9605cef614912d910207bfd8954e305ee0862d97e456f46db0309827ade4334ffdd3890341c68907a56907480b13560536435cc01c2ce6336492054968c09aed5c0ec11e68e8154c8074a2e3a627475c00669919f721f038f9a5c085865eed4b9df5465f3e6551c36d93ff2a856520fa9e2e7a8e84e090da162c237365f25dbcc40fcdb467111218b20355db2ff8d2e0a0a6d9a3a639ef01a4b8852fc761608331d2eaf3b1856fb3e4d2e842e730c8150f4037a9159c8a604fd824afad94b6a2781b042e7abc56902d3c438f6eb587a9e65b5b941a68dbc71c0afccd541004542dfc8a99759468d17ca2d0e5010f8cf77f29504628b33e9d9253db1d5abc1e6fa1dbf5942cc63b37ab0b30b42fb052c779331fc9a591167d07dd8ee9d0c8f51b685746db57c0726afa34df5a509c071d424d25d37c8d992b857696af04bf667ce89dabfecdb8136df0ce053e0685fe2fa5044e6eb61726f4a8aa14f8e526c8b93f263a7d624b49e60f92eab5a6a617a98ddcb2189804dfba682fa87b0cc4e7f5aff0b4d218b0e73eeafbbef51c7106c40c82691ed664ae7adb010990d469723330cb81f4ffc9ee51e6f5583cf1525bdbccc3eac3f7e8ddc9f2243ab9dc8a786ffc9da870735f79c82544195abf97610a83c3dd1d3e80a8a5d3da0e5e293ab314cceda1746d5b02726ecfb1bb4bbe44fc1a58110702f1589b0dcf31f703185422577cc79bf3dff79aca167ecab46cdd3dc50346bf3a0d3f290dc0d9d9d0dccd1a9395336c806378f13f7a217fccad216282d73c2fa84a75d628895a82bec24ff0b05e4113931e27036892d94470130213d63550c5c9569a3f68ce2ed6702227582ef4b07b34a469153f4b458386e95e4f68d662378e2916179bdb2875424ef27f5a8e436f26778fbe6d59026ceab288e159daa71eabf200dfe7c8027f2ab43daf05e4edad78871a0e6b3e17de4559e85824850d7f838b4aef9e53f0416fb465fb0a4ba9bbc7f0242e243e5269c332a03afbdf4cecca6e27f8eafd44207a7b4731fd3efe69b2bbfcf339c98a352cfab85ffeef66451741b552d6ba70546964b08a794f3d817fb83b91d17c244c518b8abc4a07d629eac378a8353eae3b01615472f148aed3e45f0a11c525521e68ee90e8dd5146f5d50b92ea29d8d4e9715d595a01ffd46d66d904f86e63243c9397596df3760dc51ebc9da398bcc2462ac2fef2d2f3ea55ceea819c8eb4baf74814694a9c09ac07be97ca7a7f597cd7199b45e7d6cd1648bf3caf14c47d11fc5e6b5c5a75b61f7e974077e417bdb22d0dae0dca1890b3e4435d411af52e994f933214ec7a580d56cfeba79db0fdaa7af4d7c3bcf9f4f18222683d7e9cdd040a1f9a27da21c076fbd450169c6d48c585ec871567a80a643886ee3671437a6a95a33ed224dc94c7da1007d1f38152beaa5038f6770cb4fae92d94c4e74ab82142a92329621f94cfe1b21e0882898f9f9ec52faac709f924fe499b1eff1b465460bff9ce48ef0af922169a9a5ffd533be34b7677975e09b59e5011da81a16691fb3a728fb8a5ac43ea3ef6513cfaea6d3d9319f24fe6cce8211b48889a99e43d121ea008e0ff4dab5df146446665addd2bb399acf572603e44ab99753301790f81d32e6969bf4f0ad2eb77795703febf91b93526e479bb83dd0efa0c69f5c4a1626ada4fc3bb89da28bef04511b361da0fd9dc99496fc8d93895aff6c42fbe1d7877ee9e1c6b55ad954faa3ae0a32c52a91df9bfb3a2b649714002cf836bc24d537ffa2df1932a593eb2b51fd293b0fc5d9b63f43f1538976756a64acacdf296fd2bd718fd0a7f5c37e4c19a142385ab48407c3df91a9d81243fda7710f35169a08cacf52fc65de16d31b48921a73e26f716a9c13e345876d2a6fe962ab56885464af5b69c3f92d46d1baca2cc544a746882dfc2aae6d0c7e25d75c57ac10c286914ffa1ca543b4834265c8e9a7eb5ac7f828db0e92e2924c61a48e325d3ba76596b14acce2988bdbb7d4f397a1fd3aa3ab67fe3f65aaf55fce7eda2292b82f065781ae3fcbc9d6bbd8b66c1befc850827256a24f9470bb8e2773581007885285c766dc3e46a2d82c9d0151f329ed21450da019b7851b419fe8dcd06f5de161c59e9561311b3243456e147d1725f1503604cfccf6f2ee07774a29cab358eae7f441de8884941aeaf925c8d483565e639939cb2cd0d31c6ec5e093b44508f3e1defc9ffdc0d38c4234c190da45a75abb63992016f55239317b28ed930bf253b724f4409763963109ea028e1d71e8913d30da9b9f4a8e51f1430087e15cd11502f036e294b07503f43b9214233723e0a9a5879753b0581154abb96166dad7a5bd69b94bc56261b0d2129971ba303bcee8c7b068a5298ed1e5399ad493ab2e26d3b4a6780f9f64941019a12e8f7b8295fe91c52b537755108a2068d4a1e6bc6d4a828a8b120c76aca6161747c37bd7f2779cdd628a33a1eeec5c5e63220171d3510ebccd46fe5a77922ca88122f0727964812ee6e35767db69892b14e30209278ce64a2d3b012f56f51bf4496b3ef8d9c69f80d482171a9f1731dfd659d5763ed49248c5488a55851e6ec96b4d97315d7495fc08b133885f2f4226e8adab9daeb25bda7075477133567623c55c4601e673c0f4cc39f3a3547b888e5618c6583d67f916375895b79c35b9a017f57f8ba28df2e370429b4e4c8fd4ad1894a5dc53f5321b07be1558b14c412ba116f7346d86dc0fba283b34707e5a5f0529ca15081febf9e8ca0880670de3200f6a6d1d6852c6f770fee9dff90c0d2e1f5284077990279fe228478c573b184b22c6d49dfcef137597455dace29d20649a91355df7ddc1158a82d3945b052d8c61528c0524e2208e6da51ea4fcc66589466f0d52a95b43c5c81c5e8c92de26b0ca0da1e11eaf4c8fa3c9886661a37df209c689f3a39e7bbfc2b23371dded4d66b06857f2f32ea0c6d3ce03604d6e653b27ae3627521c880eefc87a9663a7da34d386d8c8a147b3560e92709ce688e5654ebd2db36a20916b84295e0b2317bc2960691bab5f271c99b4a91806e1839e0c79c7c07cd8bb37b4d56c9342510102bec504936c572dc920f6dcaa5f284c0683c5748c908a194852a25e4d51d8ad2c86348e79c0f4b705f8efc52d9a790d6e199819319a47df3a7ad6c34f8be55056fd4eacc6ed3972bfd4bb5bc0b5195223a9ada9d3e4ae6c81c722e2944edda937a6996e9e6564e9376b8d1ff3becf3bd89d373b693daf63c6331fbe499f447f07db9ef8af1da3fe7514dbb56160f6707390faa0ec9d1d2b8e2242d98e86817279a268408d41e3c476735dd0c6f71f5884e9f3cdbad2081438dfc3a23ece84db6aa4107743a8dfba6802d2c02c0d0511c499f5405e0389fd456fd82b373b6c534e8629f6f4c8718bd2f54be575f8dd00386e998a02cce13f5d113df4f22e883c9531541b4412f16d3e89212690f2fc91b6c26f17a1a57adf363a7d1255157d8f7e81fe4facf0d3be5e38f210ed44166c973259e6b6b3bb66900faeff73efb83676150de810c4df4c75529187ed93d22e1f622b8d50087cd0706f1dae30c36887b44b7f0b4404c20da79d3faa25c40ed106d8a72a06a05662b212638fe2e3aa921b17377d6ba28a06e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
