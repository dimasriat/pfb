<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5fc69c37684f53b0653b13c13aed740b52f8ac1b75534746e7d055e84996dd118879800e9960dfe478b844739b7061300aecb9a51e3b871cabdda830f217960ed2d2bc9626ee1658ce410b77e5a531a0ec3b0b307ceb09986b4da2513598e163ddf34a3557e0027dc9a6f47d39535be83a9c97c428203b7e46835a2fea3aa1dff8802c950575d61b159afbb9d04352850cf2aa68f630d19f22d4b759292e7313759669739d839e370f07a1b2977c85e9c6e4ed7c6c41a08c8d3cb0cb4306474d62f0d6dc10df40cbe99b8affebc4683ad77ad61a9e4766ab0a1ea93424fac8da0231397b2d69c80848204a03ab297152e0bf8a5582dd1c867c82b541c37501d82f7d33a62249413eba1374033e77ee6bd72fceda59496fc50775c47d83af8f0b16de476c1fc3f324a6d3fcb1eab9bc25fd6a91b663e9ad08b0913f6321413e790f4716b6f65429a72d726e076d5c6bef89d3b62758d7b6c6cd66f6a584ed14119aa19a28a4aed0eed73dcf7fe0514608a5b5f9d45d8edbe1c2648e91eaff16f574347d90cf68d57ac860919e39705876780b1bcb4d74e9a2096bcb0aeb0bd9332fd92881bcb51e76d6da95ff1243c33e55f97a5769c654ba08445d6c6cdd3bcd603fe8f3607e06a430b975a93d67082a472ae6c89354ed21cddb2ec0908f0f2165c07f87a9311b88978a1665bb34062bc30ee5cd9fca4222ec573a721fa53e99a516f4250190731e0a75021fe5d3e56e6c1d3585b80c8e9f1b08e6fe67abb8a15fae99a2e73a5aa8af8932941f05d4edbc373b1b63df44cd8dfeee03e093dc07f1b210b1ddc81f2d20bf849b932d8d272ca3fab2d60610598243797e8f298dff94cbbe175d81c332e18bf1a610eaa489605f813ff68ace6025e9c61e144c79d0a7207519309e966267c89f0885eeef57ab0ffa8303e2c4151b819e4c8b8e6960e018e7919bef1d6909cea29dfdb85ed9b0f31a936c5865044fa09354c4390ab8e2e9a82f6095bf06207dc77cc31655008889bbddf15617abbf7ebc43a3c92a990a53c975724fd3b0ca3f3d141ae663a9e19bc7ac511995681bebbd3a3b0db8f4454c8fea19346fc3d5fc1e8fd50e27c4795f4d6d9cdb8c827523021f2864b3065ce9729dbd315bf450f05155d1e4ba7483ef6bf8dbe2e3d1af8e50f86cf816ff2449f8431641d7168d088b7637ce1d33914a9d384696c5232e71e2f4333849f6758fa7e6d92ac71b7b62406942373225fc7cb9bb8fa177b1ddb1e769144e0d00e322880df49678390db22544621cc4e8e7b97fe129fbff0c353162963c13610536bd13a70fe616ee1081f190ad444c540fc97d9ace68143041451115c937faccaac14019f89e5e8739edbdf63da5b02328c27b83969f1a0f8921e9f1f04f8d05d92049226838063b5bbd5b33890fe5f8129d019a0d5e539730e4964f6cdbe63b77a60316375d96d5d755209a295a7c441e8bf98be30989713d942031bb1d642b35cdc2e2da8d2fbc61e0753cd043c8b7af884d5a134791caf0c45f991fb75717d5f6a4d76c8883be08e79347c10f8c20f44ec47e6424f58467eda6ba313a5a8a66b09c5340dd956b9e31cc0e116b36477fd2e288f30f12c786dc0f1e98283c74a40be6d983a062891f251056d690b3a7a24e152a411b096516759640c5d0ef1c4f4af83f13b18816d6bd6cd947bd10af6c8845098501931749152830866336aea7001e2fdd598e7e0fa94668d43bc07749233a48d43bdbcf31ebd848baa805b797a09071641cad6ec44f2737124d77b73ebf015934790ea71676566c7d33ce741792321e4a8a83dca54885c7e5fe184bf55ec4b9f57425693b822c41745ef454f3e5c76f007e111a8586bc547ef0ec04921ea3f878c1bc24b0a6fbd1d1d2294f88bc78f42bf6622dcd763e2bb38cbe5b1a8e5b2dc28d46eb0e0f4a74ecdd69f052f2278dff9eca467faa5b3436e9a046ffcd7993ca8842872ccababf3a9a457bb87b1d4c74d7cbc7cc067e436753b240c5a8549e492ceb3ff965465420a96430ac049872cd114fa06787058c17235e36ad65898165640e3b6d8b4ac26440daf038793d467618de1cbb7766411379cbe03efc7d555b7cc8a177e66ecfc8edd150ed8f603afa6c890a1730b30deed5b5098fbd301fd7f7a672423ad6746e341effa8aaa9343a95b36a3ad88902956a7a52e991068c5c53511c811c35e84993fe51cf343e138832aa6f9dbfa614d7faf1656e20c373ea5fa7603750b77013c717fa1905b9ae8fce95bd43f531146c52ae22e1e3839d963e023786f2257369de158e75cbe2bbdacbd6e4e7532125cc18e295717138a17258f22f25f6df28ad95f3382fcfd4592cff8633fdc5135bea1e249a1bb272affe452e756df5b44743805353e80ebeb2b0ef80cceb1fd26dc49e98ff0f3bca7b70237167ff29c6b4d0ef24854bd1cc7827d21ef16c630ef76ea488a9ab58bc3fe427b1f3411cf5fc5ae64e3a839f7fa78d03df7d936c6148c8555c7f4e0a79f5cee4957fad18c94e5015c3e2fd0f127b61dbc3c0b312cf0b6b454b1427c35d2793ffa8e7eaf7c016611dc3e5fa774197eb02dd79ef8cbedfa0016461f334a0dc1e08968bf9974b6f428a5509a4ab4bf4bfb92d44fe1e951597e568f55448f479947a270ee1ec8577b5515f849b09629fdd8cc40ac3628d93824b10ba4e323d98273f1a07050109288d6629e840ed78e76ff2da69de6cca0d4ff3dc80f4d3d9ecdb8151720ea6ef7c7f1ee32899e6d558b64c1a2f2b36e30fb5e872de14ca3596c1e753adefd56c430f9264681be808f243d1a3b424a727a1b4ca1214a1760a04fd9b6ac7ee089fbd569c496e5867f5e342ab29f8457a758bd73518622b0131aba710bf1fc0741a2f8eb0fd7e24f849f81ad893f4d3ecf4f0f09bf3b0a897d105c2b77c4b68f8bf364b662a6e0c55af231fc6c1fa4f13fa2ef8fedefbb615f69ec037d2188d7dcc028510cfd015b431191a235117bc232361e8970d4940e93b6fe9f48ff0c6949c1cb95dd19129574168fddaf97ff1fc499cafe0c7b9c4b50883b754f093811188d292aa2b90e2e36aee3a23940acfc706393ba01314955944e5411a6424cec7cd66cada8fafe393991b0506c0696b16e1bc4dc9c5a7ba57e10b80f9354c3f797c12d6260c96464f63927477a6105ba96c4ad82a346e48a165ab6b3b8b3849d9b3024fe0b2b3dbbf32265b8440d6b8cedf93b184150266ba519ca410cd90479d1c461eb681edc8949729c40666b9c896bfc54910763a42fc127e3c38c2b689714055aeac7a99e68ecfeb66caa2d358ee0820129cfbd4ba50fb03f2dcfb55a3db6dab76e8369f3d7e129d1ee5318e37f886591aaeb78f711d95c7aace2d4d66c0e0ac49892e2797123dbc184f3f03783a5ee3357db297eb848aa2b5785632dc41468646be53fb36834ad15809083af234aca2b5fb2e2c8f7667a7ad78d35c5f922f0ae63bef39960ac77209a5d8e914782b1b291419519383debc95597b5e4dc5bfa7b83ecc48a9a973385e040d37b741c6671f382ed2d920696f2d2b6055de5f313ae9eb92e51ca18442e57db0f765a8858dcaf4d3978010f39061d8ff0a52086046ec5c685c1a1c3a61e3fbf818b622e8a341e99986bf621ca5d7b4213ff1a347f4fc99624e640f6cac563d03e487f31018703361e16170b43e72e0e880231485ce525cd2d9c097cf20d277c29bc85295a1130d1cdcdf686499ae8223817226ef48d051b7056a16ebcae02e9988e8d62064fc73d927c11512e0831a40517771171531957c63157078fab87ed3a7d68d043f3af1848bb8d45cdf6e6b8e22deadbad1f881844e4f449603d751e0cd936a4c61a60df76740eda494377d115dac72ee65e06ab5881319de432ac2679daa45b67e5c02150b6dde2a5c9c7f8c38f116c9076a11aace89555654f6dbd4daad56b5e1b2a5f535247e6f2b46b8255d211285fddeb290f635c8b23ea064264043065adef6e2be76c7b2816406ff35b4f4ef98b21542958a18470a271970d5335bfb259a658ef3149c41fdc7a54b15fd7e4066a688d6ab03c5dd724297243122b01650609a563fedf625bbbe9dafee3c1971e226959f6939a1b25baa42c18f241bdd6689ec8b5b175df4e7ff0552848b577f4881736a311223c62232b1681b7aa0e3d502a64f17fd6442b4494b3576b3dab6ca23c91e3e4aaaed71f17d4b1eb031984c036b7deb9676648dc5d4b9ab75a2374b64d6142b25a2c87f27283bcfaa083488e64c1151f8121425d172a9854179781a95fa8a7b1e161e5bd2c9e235c2722e2ce0ba335eb16482ef319e10a8fe6bb0b033609b02e7456b47850de13bc1c29ec544a2fa479ed0f3c9043938e0d9329d4912d00d5691bfd79b8785545444b3e338716e418e169c100307a155a4f82a604a9d17bfff4b7026c0940430ea5ff231771beff194d923b498b7e53f923dcd94a38321ef17274b3a48e423e1879d198dbeb031c9bac02d76d383446aef8d7b25bb83e9882be096b3b47e3158fa8fc367f0f1b5c57f25fa81d8921893d3796a07f56022556072bf9961219b64735514fe4c76557617d6d8fd0839482742259eeded07f4f7b5ece26dbcc610a143b724d82823c0e6e10b530ba7a217716408a267e2b5f6228707a23f1c522d3781e2d648fa9513319ce83aadf75e8ca80fb48bfc4fa36e9387023626912b94dbef46421143626923318b10bd7e53a5bb515333cf59f2465b9420ef92ca23481257c4671a37c05f933e2c7cec4a91ad81fd18ce88d451cd08812bfaa20ce822c9784814c6250a19357e51758d013dca8652910761c902c8869b96f7578e01c3e174de96e2b383f46690f9dcfd6187572068568db9f999b7a5497ceb15da40aacf1eb1e1b8c9b5783a73b05ef7efd6a3ec1dc2259c36eda3693ccf58b19036199445f1e57d106acf47cd44e40906a2f4d9ce84f5381e95608ed70b2464b4bd8b34573eb6ec5adfd17c47429951e03da29ccecba6798c1c1c5b355db83c8967a0818b7d4fabb8c0c145fdccb164a1afbf9677d8f5d654cd542adc1c59af1101a3e6edf6acbbeb2f2338c4f7bac10927cb2e906d04d98016ec2aa5baa89c4a3a708686330c459a123c2694f446ee5390c1d9b460adfcade94a29927f5f8e26ad670cc3362e9e1e1d82aadb2d7eb5ef7af814c55cb6c008a5664f85a4f2440106c9d05ca01c56d623cb119bf93c1f79e39ca04028737687b1bb67a70a606a78c5ef68158379ea5556e1b33164bb6b58b16630fb2c2d6719960784c545490a310f9f0aa52ae455b36798deee366204102d26edde81b4266fa6d100dca44f13db86a65fb1f407f516279c9cedbb384fec11e5a4b74a34d9a507eb709e9947c3af33e1b29311ae8a0c9f34df82b208e374a8530d7b37f435800c599519bd6582ed1b4c1197dbc6d28d575795c8b313aae5a95b9e5124d39af47f9048e6597ae9b685479a8952586b7bbecb4061420b705ab36c06c4ac75c60d1997659581d07a53564550ea757b2b4fefd7e063870b49945aeea435dba2997178852a66ebfefd53c8fd9be67dbe359439f156df3ce9ecc075daf9cb07b4264522fa3b638e6583d9a7390cff8ee1de1afe75e3a37bfaf81bb3cf2fa162fa8e2af817c81e9607117c1dabd9f9d53de128dc0681976d6350b2e5a8a0eafffbeb990b0f93777fb4317a913e5aea26e0eee022104bfe1c4c838d7a7d941b33f186f3bcd1677e90100ff5d6a36b0d16f0f207b4dcc76224b28cdf007f6c333a9f9a367e7f609326477df9fcfdcd687a77226448dc0405b190d2c5fbb444e8ac2137c52612222ef425a655fbcf8c957993a8290cfa554a96938295f3d89d64ea8aae3fc9047ea3b96eea1cd8c6f8da71cea3a3a9ace122006f7bb0c38fcb29e89af09c8d9ff0642b20bf65ba4fc8ed1a315d8a8f85c69eb3a412337d024cefbf3a0053388a476781c09a06ad76e0f92961b3fa70d8793d4eee3e02f4c299ca040b1551016531f04bd0c0f95d90f9f7139cb9299b008f2b71afc8a6151e7f88db674e9c32d31c93c37e8a191f4558928a792fead4ee7051848409ad5ca7e51f363d30197afb4f3ce5590134e3c3a0dfac2a07041f1df7e0e80a2d1f108d2d8154876437af17e30a9dae5099909f391524da69268e0801ddd7ef4a3dbf8ff8766ad41a23e51bd558d8954cea48665fc492c513d70730984b1cf76d895821b1010b2fdf2fd34653b47c67df8e76df0cef38f1009cfd2496082fc5a05d5935bf11a917e7dd2f8e285044124ccd74e1c67251c50eb973b738de9f9b9fcd52cd5237e1b7b5b80ca376054a99b99f2feaa6e6fb4cf8d5764f48114741be64e1e15fdb33b5566f2b0a5c3c3b1be8f5bdbd074341ddad57f06aadc4817ead6312622cecbcb5a863820694324272fe99131897f5f4471219396ef09df86eb76809e5dedb2735110a83b21ca6f4c42320d12668ba77563d9af12c585778fe6f5b10218211aa7f42a0d0fc3b58f96a0a2beab757e091d4fea72af8fad69ca4194f18d00557608b3e979a346c00af178198fd481069c922ba450ecad8808f6ca0e3a6e775237867e8fe66892a5c6dfbb64013d53eb25dba0581068624a3d49145cff48fd5214ef67c329295d176a972dbe6e342d167f71bce783c60427bb6dc42841cde9a259de8a4d5848dc56c5c3ccdf53ecaaf195f5560c0b3c46d733aea72c5c7430a0b7a000e4afd26fddbfa77de11bb8dcabcbcab8947fe173c5cd445e62f914c2fcd00648c929af0d9f28e4898dfb4e9b4cf330479687160c05cd57445720e477d672088b11d5b67fc2173ac634dfabc81621164a652130c2cd491eea74776f21e02c916bbee9d22860e0989df65ece050b3085b4598a9492c259b5e1d5cb3905bde710067cd84fc36023f9842020e9e63efedd9d728a547da132e77653c6ec2abbc3c44d117fcbee76af213ee5dd2c8f609d6b984e221cf99f4c97c1c65aabb7b63858758c809b8dee3bf17a173ebb50ad221ec36f95119db045e4b0dfc429f411069f2035d472a15dd400e045c6501bd9edc7c08c4f6be4d2361ba13a5e120c159728c48eae4e98df524c3d40ad9b890dc4f9a4a6fa7f629a1021affac56f45c24b9a0f2c227b101d1a3609c6e7db19103d85a66caebffaa48e821395e91c8963d5195048d0ebbd6354c9a78227ed6a38032e976130992c625653f288b51c89e072b7ace5137ad8b864479f187bd71e2be8bceae21ec941cfa89bbd75b4c75cd2db4dd95267c62c067e1b7f6b81718b88599ff457d16703724bdc95b5c97e5d9416d6a13771c8614bfabe12a32f37f669bf6a559c0fffeecfd7a924e9b582d1450e98ff3032a4312f306afbd2f1f3b0c1f7373601c97b09256112455552126a4a2a69235b5e642f2db70596ca9168c86a284804ab4b691a457c7a3f82515c9cda2225e0d03155f0c01f01ca240f2b38cd5d2157c2051705204b719ffb2a9ca301ff2541deb2ae61d2565e93b9faa9c37b76cb763de02090bfaaac2d3ee0dc194f6267532dad7a8ca7abe593e524b9fc366d41bdf1b24515495da5f97d2302e50fb56534dbb6612b5649084d382c4b1a7028de6e75178b51a161581c4c0596e51905600842c5b13b3a078a0ee594aba764cbaccfd6fce2443147a85999623ec4d8f656473c67dd8bd28f9a4526952700aa027370d441bc6651cb5a264b859db97bb6996f2b36e056e3646dbde1d15059088c32d69a1e0af6c29ba8c07c284b9998fa73f0adfe31a246243105d28b7e08eee1eb58306505efba23b80fa99a2dd6c33126cfd1eb4e9f4771d4c42ae800b41e26c790abbf8cfee5de9438298d200ad0804a72348bfc976ddd7b84e64ae4e3afff864e5f945a2bea90fd18f47579f3d636b078f1be606fe9909a39645eef17b06ed4dca30dd1833d93fcc30c8f846d32fc14ba3dcf32eea4dfa04025cec897f2be37766eb1b39258667d9c72cba6a59c8c6a6adfa784fca8b0fac5882b680836cf0803775983fea2129258ccbf9f5c35c13b000e71e9a92255228a44f06b47d96bc9f033fe10d99493c1ee3b49774343685a7bfcd6501583c6a0c73766bc30a72dea72bf5a00c7c8bb06bec3068d6776a8f010e88f3c97f299cc0d6e380a08d5d642c0aae4fa1d4089e72699031e007a1bc833b377b4ba59b51404c3d5ab8274f331ad972a440e0baeaec2e4c1a23f620d0d477c696f86130ce842e0c44906cfe36e524b5afb1a4d5a3d196823de8c8cfff741217e4bf6197200cb142b43af79f98d3bc70669be0a0d21ad8db306f1a35b83bf7ac72f8274ee6245700ac788e13a76d99bf6065c04ac427d9dc8717d181113a6d6e6fae88a0feec4175a91262ff011f768c92bfffd8006ef58e722ac6fcfb8bcefe3e11da8ed7fa7f81b71b110204897ce91bae430c8d34949bafcc2596eed87061b2ed3cf4d54c8830a1405e6776c995dc88ef6a1a4e181ed5950539c61072a595d68d8376cec27f49aa56247208952a3b46415ebadc307d8309b0b9324b3d769244f43e5b57827abb28a4163fbf5e52d919add03883e4ae5fff6a4b72d8b3f3cc3c0f81429eb0da465146662c485efe05c506fa3b86ccba401f0efb604b488f64cf84a9025422fabd470bf0769d1a96abcd950543e5c37a9711f6453f79d34e7cc0c8270d457a78bde566e01c6215f01e6c3d58531d6345181de504fdac7694f3fdb8a27f396fa3ec119869bcaaf6bb56ad591713850867cacb2248148e61e323bbf66bfa07fa6f135ca4a745c72d1acfc77bc7cf994b41d60c693965c018ac7ed5d43d045a555bcd157c48a9291a103c63af0877a44c629eb74515140c2c28f76e2fe4456d4b1fc5fbb9c099ea477d5648fee62f889c0548ed453b3498cd2ff7f5337cb4cffc2200715be6572afee9cfd4b270db59755a2a1c5b4553cff44bfec8cef2fbeae09dfd74e49a414fda39192891222f52379ed17fb8946071da89dfafd6d9b94cb77f38c4bf8de8de316d095df848b81c863c536c4a08129c32616697f78c2d7d3b639bfbdf9d250809e4742c432090dbe3b941fa9511ed48c99d3963757b12034ada176ac9a8a13f27bed556c598fcb4d4ceb71ae97851204d62569f04e3939467826f4a09ea5fa971442aad4ee1658216f23766d65926eef1d7cb697c13a7bf29c91d03971394c590da187fdac7dc5cc3760a2976cfc86c0c59cbca4c59497c68c07c9364e995997593eaeb41626cf6a205c1a33dab530fe9769c89f42d75be11be012cc91ae60329010a80b6022b056e86c78cf7897bd80ed885e001103313ce10849908c7b8e6b557c2691b9502c0b02249b4e27a68605f32f623f8553ea589cb5bc8a2b2284d3bf675a7dc185bdaa1d46b0aa92fc3d96d3f441a6313220efd4c9869c8885c7bb16ed51a7396cb17de840166fa725833a0c10712611061c9bf4f2f5773b68ca2ecd5bd7d211a10089290b608c24e1e868802970b0e4a00d3f364c14abc3b3834ea767a8f39b9c227f075de1b2e558c2d34d96152dc6df5d6442e0fd5b05a4ba1595cbbe55db7471da2c47085cfcebd79ea1b6462a2337e7462482225235db5257836d5e4fdd5ff53f9f9496af23702a0addcca7a8ebca23a512155c10a23ee5172cfdbd91b8110c701de2cf7e2371e7f9eca9a73b05b7cac9065e7bbfa6393ac2a24d7547089df93a24c995cb5ea54fa3812c6d53297216c6613a7c59867c8c0e73231eb1134c3e273693ab07bbc642156554c14a08cfbd9dd84ecf84ee882cf8f00845e8a7ba9abce37d0cb7182eb49f2dd5c53301b57756663f4e255ed99c3f5f3e9907bfbddcf49c926520dddbca75bb76c13932341b707aa3d450ffd6453e8f577e7fece5f90d7a7e83d24eee110677e5f8d92abcd96bb869080f655ae13dffb62cba8333c279f138d686797b88a29b8a2f7980a96235e6721db4c53188c4783af818f1c05770c274b90da797bf0dbca4639f8790a1655fa3460fda2263a990fa38e9735c563c50a7246d967158182c4f3617d70ae704a7a8e233e6c021cbdfb417a2b24ef5e9b7a36e1696c29fd2216925a693128f8feaa28177b02b8d5079b22a04c7dd75d79d02996bebac3ae579af7584f472cb3eb122142399470143ed3fdd7f3cb4ca9f27596527f9f7597901609c26157573f3d6c32f4b06836ca46b3e751057049afac36238fd9aac255048d2db2eaccf9ab82b9687c3c42730b48b2f18b3d25da196db71fc3c1fd85c01c6202e92a9815e2b1a23355fa52f9a66da25a01efc9febd79a64af9c1596837090e5999dbd08a92b085444041d0ad741112c1b4f9814b92e66d41177e3c79462204b7efc2ee31bb0ec16780f69209a716869cf46e29dbbfc24ec949d652f66b8e5399ec78e0e403f7cdd9357e8ed979793ccbc29e6f9cd3b698b3d3c0305bdc5d5b057f85769bc88ed2e607056f85ed94a3c5a1f54e48b746fae53f57a9fe9cb1f417bd5776bf0d5d7359a4a5e0cc30601c072c863be644b8e690557aa794c748d6482f7359d96ac7a68477235c2939bbfda366523ac2dea7897c25e52411beb8664b6a4708f2504e5055d69b8f91cad0ebf60064d41986b3e8b2841b4801351e6bd2ac14e58708f027a72415a777b139c20068004ce6390da7330fdec0bc8bf18dd0e4741b0017e734f17576752738c1cb7535cf3711e694e6399e9c157546d1a583474e1cbd6d5dbc60d3077cf9993e312de2dd683a0b421a1a8346828a8ef134d2a47dc8294408d43d48c36988a220cee29ed27d1fa896603208427597fe81b23d15ef0e884d2973a052cc24f54f3c5624653aff1595d9f78eddf8d590f68460ed196413a18a238bd2cfa363f62ffb19b084ab69833ec275b881cbe7f6096e929e7ab5d5c61c51a61e63c37d087753d96c9d0dc21ddac2dee0d7c158b1af0fdff02ae77b59f272ad5a536df3911c6b894d81d9a4ad2d2f89379b3ad77bd417a6ee8774b5a24cedb8b6c34f2b7b4d560c76220375f3c6bb03380d435a53c9eeb97cb16e40a7c84a676b2b78329f8e97e0a0aa167ef631c4d84def3e18edfa90f94a3c229ba96d6a0c8cd5c893a90bc0cec2c0202dc12b210da301583cb2d2044b3dc0d5bf5f81dee7174e4906b76e9e99781e387592f4e5cf107b4748e3b773a5015c38200781b54c57cc31d346adf314f474b05a00f212ad8bdf27e40e3c927c91a3f44b6e08a793f5a021a5ea168dca42b8beb321a87448b9bf0b0df0aebd0fe58e0a680b3657a26fd62d668ccf292e1bbea8d62d9b2b87764da0a54de06571a7659e4bc363263491bc21290931dfda83b21a6506acac70bf96fe197effd0263e13fed82517c67ded890492f60741c56bd314ff2994dc0685515e3491aed6ee6b72c37eed9aa120ff9d7dd23528aa9d0a770bfb9a262b9c46c84892a86bc5c21d21d5be65f4d54edd66ee38b92479ef8b9c75c35bc0787d75fc3136abfeb2fe95d9ad413678dc68ffe44794b85d6e853d3b77402faf3ffe0838d7d20aa48f375b7e8f293cf8461e67a2320d9e47a981a29ab00681995e94ffa9cfbfb1311ec0bee3423fbb88d153979b10756c900739567903e680285bd122e7e63e7e01525bbcd8a322f9d3baa0414c4f51caf8b8f8ecd62656e792050f1ca69f12b63cd9ba4c4a782746a07fdf52655a152f43fba9fa9b9a57b73a351918cfaee8929b062be8e058b77cb69565437393b1ac2c497e12515251a265312c64623690b45accd030c0517e4b96d7f07c82f41a3e3dbb8007ae68669107504946e46c0786618fe5990c1333222017ad7de564e1b456acfdde79dfc711519c9792849f7c0344ba9ff974212d2636e973764786f9b4919d2fd83e6b3e1b6c6b3fe1dc29f2b51b7ca7e3fefbe1594ac14c94f8bce5505045f3dcabd615248b8dafe653e4f9b1d3fe5ed193c4d4fc1c928cb26453903d0b90032190c17e3125cda9dd240197ebbd6e980a9a6bfd7afc69fb14b2feeab4999dde03d7eea1142786e9ffc0112eef32ba4669c6784ac8ff9f2ee38046cb92c387782c0e47e9a045b4f5b16e8f86006e6ddcfdbce0dbf234da83ad44328fccac6c1b8a3e1ee8b23ec604f34752bc73a4dca2bb20e95b6d9357be83f698ed00312e04f6fc0ef96e63cd8bafcbe3f365747a786a0d9caafcc6c55bb663e2aa009b34f142f1db83e0eab533b6dcf211c966908e43579abb45ace6d351dab223572d8495219ad190b692c76ac6bc13cc8cde4d924346f74d3209bd14910ddaa47eda96c19d8d68b1971f5c59524aaa3a38cbcd42831a8cae9f335233767811ddbbb6ab59d00e2c7fda592a002365a7b13c40d2c69830625950575d357e7427a61db6be3885b18eb7e25b7988737945f55cf0c424aad536d1cf014cbd5aabc64d38c1a9f952d865eec70da6e7b40f008326dade121cbbf98ea51edc9b033e9b5b490de3aaf4a2a3b91cdfac0c54e1c0567d3c7235fa09535249484b92021efa267eb88c189ec61454146f5a68877309098934fb656f4871beebf4e8dbfb0c1df280a21ed2cdd5063fbc95bee5a4edac905b3dbdf90eaa02bf69623f73b974665ae9926b52ddff8946ed36d1b17f3553aa12c984d7e533ab301d6b6de1e48652e9dcff0010781762af8f9007b983797d9fbe027599c165cd58e7c42ff1d375534927e3eaba3340e426e6adf7e1149054e6a78590e59d05b56136cf7855ae010e88d7c4884294d264724734415b4caefb27df1be25e176c85d98f04e8e2f442b0958ac11b57e1adb16683995057257f6c0168b37039f209e96a4582dc1aaf4d43ee6eea0b6bccb455624ea3c4e789dfeeabc22dcb3db1761edff48b3f2889a7409e8956a2c52e19998a2925ad8f06cbd7fa3ab4e83b06707b5096a3e9149b7683317ab181a89b16476cd84838c939cd920a38ff582b1ebf14156890c70185d8992ffe61358e0f9d674470b051cffef509d1b85f5c29416ffcc999ea0b5a668029bdf1d88b87d7d0a656933eb43e1e42fabb3241923ebadc3461c580d02f9dc528d2739835f53ab402bbf96022adf671ef2e96660de544940f99bf195a739b7033951c3cd8420c22de53d6295a7c30aa6de4925cf19f2dd3fd62baaa607a2c489d29cfb6df32aa5e176843fcd2f1a5631ede5dce3f953167d2e47b8fc896a2f533787ae806bcd26f2bf8c706a727d31bcfd9c7c68142b75e03cf0214d174e3e634b9ddbc16c3163eebdd53e52c97908d70491e5856d76ef9fb0b416168857bd60cd2e4ced3b51628a620ea5f5a158c574a37833b641f5fd540ff7d852e78696a2495a039502df98b7eb5c041c58bfc06b31e393ef55ffad590d24c0d1d6ea25bee0c1b8325ecf6b7e75e52789d2ba9600c5882ef1777afcf96473b45f06bda4cfdcc8deeeba8c6b6a05807c4a6524cdd2f6f04f72e803d0900378a754eeb27478ab65a7d55cde72b624b708b8482ca3f1732d0e0855f03d3c70854ca585bf5c409f2ca6137ee96b9854671a96cd96cfd13eb616afd9d810605a58b7217f6a9f169265e55d5a321cb355a0aeda4bc95d288d2c7ca82c77ad045ae537be2752390bb72e38b1855c44581616a142621c5e24debf6259a6a8028b07939b5211776022cbe3667d091e3251cd9a12e24bd295ad1c5d19af8444461605c1bd7515a4c38d1be0b83dd2d73df218efe09ac32f1daf117e441ce361444cba241c4e92ed723ae2d8b651c6a6b25c43a28d15ca9a23e3133b162d0e6743de4dd4766485db953bf28e24a80fe56fc989460da37eab6923c11ebb35b5bb96b97ab7c832a41b23f074bd0fd984de4709abf5e90acdea84e9e93b025f15349550c5f52ae8b3d3d26cf75bfb54521825aebd3583b56afa64ecdd7a171917a634703edbbf0f55cc7e5d1d3836b1b58b87978a4760f11242badbea7d6aabe3537fe2d29793450bde2096cf13d07d5ccd840f54d0f9608f8106e5db972f68575c987c4951f9b4d0d7c5b2cc82c093fd18c0df44d44b5b5b7c9b7fddf87128af6d10c4d990a29fe2945efd9cebbea283c0396e3ad97337fd5b57e55039aa8853baf7e12e5093ff14ed9f7f061888dafce912971868dfc242ad242923ef1e6076354745d4d5e7b6a27107ecbde89e8cea15a4de783d67fb95c3e863951e5bcdd2e4d57fa3c93e8754d7d962fdfbbda1f452b007327ad750815ca243c0859a9c2fa4d2f5313e5138fb8b685fb71068d911ce290056dfdb7361a0e9c09b25b97dfeab35f65f288c58110304ceea46d104330e8df3d4c260074ecbb8980b1489dd929f3997f3eb5c32324a51015a737e7e0e7adb15182dd70a90573b783a4b73e3ab56afed9d99cf22f2a8a93a89fd435219962c4220b9f5532167e068b9c8a8184bbc2f71ed53039295ecc970314a6e92c7b9b99cc5d0abbdad24cd3240faf7598fa1ba8eb049c693a98d08816342213da045a434a7ac7f0c7de031ff6a1c080c4460b8eb84e8434bb2422891a23a8d871b935cfe0ce0d7e0e53b734b2555402b155066d36da8b5c7666fa76181e34c89f24d0f13681d9cfe6d72c6201485bffec21baf6451fce041eee9fb908580e2dc88dc2eae7dde4f1a30f657d2915a87a2d2390c3a341bd5d341b42623eedb3ac7086e5abc2d11e7bb9b02f26abe12a3d6761d38847a5066d2b7142b550ae10de2398cf672765ade9c3057d663efcc420ff979f5884b54176c5f799106daba66ce48f85830c71b1e736bb9e3159d6317a027d7a799a5e796334e975035c1390ec63dbfe0afbd74d9884cbbc9bed040f15bb63a7c82ef5b5708e47cb1b581868363edf44aa4623689a607f93b42dffb39e6591e33db8deb42de9280c40722500a85f18b8a01dbee5864f805c6618ccbeb5ba755ce9a258eef21645f674eabf761e875ad06e4a74fc96d0f9c11be68cf717b96aa3e0dd93f32ffec7bb89d4ff8626839910bd7c205d7c88bdbeab58e2e7751bde73a2b3ca863fedcc7c0b5f67a074ffbfc8509e1a9f02b38f10d2390e28f7303f1609b99771552bff91bf40b826ca4b585994e056f1d79107c2ea702835dbe862694786ab0b749897869142b3d6f975a7eee9fad7b980a1b7b62f076ce7cf937bc0770989cb19dc91f7e0ba2dac4062a368e72c1c2af9de9f21c9544d39b03f89bca298e798bb1d73279dda323927c802317df0231b160ab1d0785446c6d8793de80793681fec1341c887ea0630cc0a67c8561d667a8a92bb2fe14ebaf98d57174d9c47bf48db0eda11954028d4f124c75dd03d53c17278290ac8a067c4e276b3822c98e106468b11e69f5e1889e8c7ca83bea776839b919a9b4f7e2cbadd9c6a47d34598456541f8d7b06d6e33606c307ab507c2129fde22530055053af24091522c06ead7ff27b6d38416d6328d192b702b6f697c58ba00d367d97b1a0667065fe015aea8cb51e8c97e4b0d27f1251d6f8b15ad504071533eb6733a16dd3686c34e70317e1ce383d5e9b1fa558d0f6c1edd344826c5d14be6ef638a267bb700f524d2d5526e2d49ca44956c39b0313c257181e5307c795d105cef8dc908c043b105fe5c58b38101f754c02a32ee38c05b0aadde523c05cab159577559d31803fca29ab5aa29d3d05ca73ba407be5f1aae43229a35edba487c3c39bd0e7681a6bbb0faa1fadf8803221000a8b78da71b390bd6b6321cbd072993a2534c28912bc0e51ae155ada61049ad420a850a28bce7faf6347f2e869911408eeb1ddbf4ab8d07fb71b29b8954fd6a99329be3347b7c0a2d35d362a1277660d7074e791b0a3f1e676080cdeaf8a17a8e329bfb3853e0e9baecec76953256c6ef2e87944ca876eb4ee01e46dbc202dccd3a8f308be4a3409da40d55250730a6b1acf53666e52c61ddf65cd04b6d9eff57f922823c3f54959e69a2baf6c42c53290884e8b85fe24c4babeea1b74a744967d2f49c6b8b28565862101ef0eba62457ae9e217b395a48a6ce26705ff6d4ed39a995fa74baf2d799e25c2d6d378ca401f51dc5038fcee605bdfefdb819fec80d1d03f3b8b11b0479d3f3e013086a0b7431de04889ea60982793e2b3ff6db2e6b4a0bb28d7353a2fa39ddb275e35093cee01494b9239d1ed437375d2710d8f7139948f7d4e581c7e1d231879142eb345cf4bad36a722b467744fbb6240a4056b018de0469051adaffd8cfcdaefdc5a087fb4552f2564ac085b2c25904807d98193405935a27e29d0e31db14b477d9b478d8e382ad6df0eca0bdc95acc0860e0d9407fdfcfa6a9989883650063a3a884d8d257142133bf193b6ddc41174600db205d00a086fc8ceabb5a77b37e036200afeda76878de3bb0fce8116b47d3f132afff817cd94d5a7a58b2927c4fddda8ee1be9400eb6a4304ddc7eeda821f6cfa01813255bf5c832397e0a74fd2db0f2013930234917b49286fb70a0e994eebe6b558e8823a4a33fd3ff6fad03af6e7277a2c1944d9eca5bddd99651add735d48a96c15b36279e2c57451cd662e9d39b57dc864cb66c1ea4796f452b9c980be77dfa1eb6c4281f28271f6cac1553aefabdaecf77b3f55c43ac2113e69fea2aa5e9f98fe0486e7461feb56ce3a97f955bdb1a8f1348fc40e966ea70e4cc01c78c2fab7208061ad2dd8b7e2307d7007aee1428f70d040e068907245ce154aa4d44777a80a6adca6efbfba03816afe6c38fe1f0e8110c17ba1d60a90f1dfe2a55675c4050b8c290a7fd2363d82a7aeb8a00d62be6f0aa4d0c92def62704b6750e8e1f9aafe0e84aeffcce2bf9a7267ae54cbeb3ea76ecc996963c03df572032af7119f776c64466998b5393f392774e5b6feaf094edad3b1db26745d6534022da0a72cb138e42c4bdb25340c97e13ecca41c756d0a21e3337f146e865361d694c087f2206843c769af89a401eebfb47e18d29af9eb4c6a78996d832f0a3844da8dc48aff5f9dceaa5e13f7668e9a7edaa101d5847d732d802bc2e9b025eb7986fa3307babf621944b653cfedcf7e6ebfc00b7717c50f943b13d9f750c74df880a2b512dcd9edca83f53cb7389c988b91e46389547f1ef6074f30bd67a02d79418e3360f53e628d4c7fe73fb8fa105a031286b048ebbaf6d6b4173a6b1268da9722e35c4479380dd0d87b2a318ace2a77fff0fbb5dbb8e4044bd5de2670d81fd4ad08934c7e6b9ecdf9cd9aca5d44b46adc5addc001006c8be9610ea5470f54ce8a96675b030bba9b733bc68a2587e9f91402de8a3d4768a2f545831947fc267e761f829b869e5d10029d7a49e9e4eed5fa2856a5ff11b63a3c4f2123c22ed3ec333ed72f7a64a6cd0a5c1f8931de81295aff5df9386020ba2eecea6e0c950b919d61671796e2ef57cc1544cfae1428430e2e875804630516dc64d3fa847c6486f518beee3b273b93bafe1a34d89dd8b0bb44066e5a2d8dfd849646a5bbba9fdb732a2f70792584cff7e3334cb6b2ebd2959f4de453f42edc47cc48dd7d10734534946f9dddbbc9c4e55def09d17942f4546e1fb12451dac77c5786f66b2cf7837ddb843a3fa0169ff11e4bb61adf1011efecec60897d79def77c860b46b6ec54534477654128abd61636c19c77bbcd549e24f0b5bbf8a18f1c99c56465b8f587d5b9b739f33d03f9f9d27213b39bbde02f800424d9e573fba8aa5bd440c2fffd9fe51f3cdbfff6003b0ab4882212d5b437b6c007a8ef31eb10c0a8bbe6c148b556a8771ab062cc623dd11c0eb5251da8ace632d7c2e62c3cda7fb4e68cfd6a30f30b6dec12d6fa8865843133d98d1357df46b50e80c48a4f4222ba28fefc3fd262d1e984e4f15da5bf367e131abe36ba4d521c42be12349c8e09335abb41f2b1d9d9276dbdef8211a7f1501a45f7cdb61ed30cebb0fc85fece3937f8c1fee832602eb81f07f3dcb9e3e3190d28cc896dc8d6ceed8c9367b5c35b3c52637ae4da9f9738279d9dca24547266b22084d7e5b58bac9eec7c4fbb3aa68230c11c89952187c31673024f43e46635710583efb51e2c96697ae9e9f3ce15955ed43eb73488b630f0401b138e4be650c9deae21b661a159eaeaa8d07ccff031e69a7ab76ff5fecaf2d0e2c2e52709b61b74be7a4cd4da10160326f9b8676b0176f7f14348196eade3957b67ee784cada84718eaf7108f00aea5ed5a7b6c5c1ff404985cb297342aaf0816cd5574ed1b550757f1bc08355a782071415b30a24a8941ff8c4f5ec49b19411b5ce9cf5746a47c96013235d9e77617599d2987e498898d18c96d432286b6e5790c40b97c18b97475168b78ad18d7e4f427708aba647dddb8d3dc011302064058dc13ffdf68fefff80cf4fd79a5d3aa90ccdb2ea67559c96c29d34505d8ed691f188a494f9122b72ff7c31da972b4f565026e76488857b610","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
