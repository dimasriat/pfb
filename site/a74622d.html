<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b7b79c8dfd4af13dc9eae6b869804e1ff141762921ef155e7693da9cd6dc6fc4d5831a626bc23a0ac06c6ae76abab59a9ed6641dd82eb4c7ff736d41446f49172e7225433672d9973d1afe16fa90e74ec8dd9add92cd106d8461acb766dc16759dfd118927b15e60208f5dc73c6577954c1af1eab20d206ff67f3dd34fc9bf530beb2c857d7826ae905592c22765149fadb536a3b9503d17f38dbd1accbaf1630137a3b5f853d78076daf7c43112c59afbfd8e4445e42e54e1819defa65179872e4655689d39627c2b70f84081f0d590fe3f60ec0b7bf567a324d3df046fc01f2f544c8d55d467fcff73feedb14eb7a9de8ea796877171f3d890c140dafd39ec41c29b515bed1bb14ad1051af7d073ff6ca333246ef2adf2260d78e5f45b23a24a91f2719bcdf7c928d80056199784bd67d87cb1679fa204a3800fce45a8ea88d97d2130ed9b565839f734b4c196d02f3b2cf2615339a9243a8466ef570317b1ed602424edbe00d16db435920acdf3817a43ec8cb8c0b9b66651aa6a007d93c469c864824043fe652cba924190e80bb7029929013a20a22e2845b4aa84f2ac926361914c5dafeccc49d66591f3f27c8a78c37a46688a3db71e0df175e2e1e9a84a7692a58df16cd58eb7771361f4fc4f9b10f83553811ead0a19673b0a7227e8fefd336ef301e10ce9fe1faa22c528c785dde9556cb29d2bad52f68d13e3b5b7e58b1d1dd4159f5732d9a30b49334916de4e50cc061f4ceb0d203e0fe12ac8de370a3f156ee7c0a826a956cac0fbf3ef3db074687e0e0893a28e97a71e3dadb46b938830729c4f673a96ea21fe717aaed3bd8b7e3f336ac3b9e973846e30066b28c28ed5be49e4e7cb56360cac3611301b719ea7000d0bed1bb0c2272b02a1bbc941184ba226c1d9512a2c12c93afc1aa2df99947c05776e6342417c9fdcd851d5e8fed02fd7e5d9e146135cb8aa2b42f1438671f4fbd8792c9ff7fd04f4ae561f6dc12bc7b34aa6275ab8f9e79013048264c4d2e49c4916db1093c6a7ac59258af6346486e3cb2649289133fc6956e7168e170afaec15130229f1180131e11889e2d678734a3ee44d0b8d8fe3bb9118b02f48f02dd8490952c4e9644075228c75e4e7c231eb5115a8f7fa9a69eac916d88fe77b73c3f8db37880383d0e8f081d15b2cb55edefed9eac37b64491a9fe6a96aadac30cf5834e8f3c2fbbee928fdd32cfa250d7676d0d0091843920782506db70dbc37f73ea2595f00e050d7aa1ceea1f8b57c4376c73a80c26b5157efa380ab6927d57f9123277aaa6f788314beef69a40a759b81819000e621ee36d2de4981aae5db9c12705b664d0fd9b4a6aaf378ca5ee8de3fcaf8570908635d305d53dd8ed31dd6109bc39d5e2844fe7ca8fd9439b951304e54d632075cb050d27d7496ca5dd796bc7bef4a5620f28bf285db3fb0885548b5c2c41ab02d224fd613933cf07b8b6c630e1baae099ad14d5e27ccc09e113560c36b11964d4728ca0e2baa8fcae88e6f55b843122cc6e2c63c499d87ed28f5c91551207b417406a930f866ab19f6c2f81dd481bef0538ae128eba12e3f75e51428d0a48040e086b4c0ed6d329166cb9f81d835a41946eb4d155b3a2dc531dcb548e7cae69f907f8ae557372854882d0fc7ac4694aacec3830bf31b541ecc937e4b7dcc409bc6f975c12d3a921817a20f3a53e6b1572be50a8a6fd8c96d3fb6f3e69289820b10cf1856b5dea85b4fdd0fae220cfe660bbeb4241949b1657d4f49d063c400bced64b419f16897f70fbd800b56f88a4830bbf19f98b3cadb528c7f13f3c2ffa0b2b1039f9ecc33fe7ac5e34eb8d4afb593c40394c25557a515ec57750ec87c0790c9545705b18a0d5c2fb1a022b3dfbfa9a6d6211d4994503fff926153f0b776d4377ed897c4b3f5a6c65d7ef55c23a1475a42fd80e8bb38a56d0a20a735f76b7ba6d744e83d7ad9caa93bd5e86fed59fe50e637582ddc67b510c633df4424ea781e20a2462277a46aee0d504e2054323cf506d38b37aff4fc094a89bb6b2c66a136b6846c29580d8cc1dc8e607e26ab8ff7b1970c14e73a596360d40d37bed2f416f90315dd2281915e944a4ced191dac491632b2e9c1e7ac613024f42bae3037a1cf288bbc86f2771a0cedb70a46975c9061c158cca7c49a7a2124e99cb25d024697e9b8ce68ce54effb7fae10a0724a394ac7be24270a96131e17948cf4857f2c9f360adba2adf171d23384c5b428c44837d99375d09475cef99f28d0990ba50a015d48f3022b4a45c6c0dbdf6162f4006e939b479c40eab8d670ee6a622abff78885f62119f4b1da0125ccb2d394f331ac35507a47319221c5c87972ac0dc49f33eaab4c369d36a110f12bdf1ef09f73fdcabf5f7b487239a692a5ea03c575c9e955bec77d7861d9e453801bc8d427a93c2783739ab042eb498229a39621ac6c01e1643edb64fbdc16742a06fbad51afe59b69255ece9f0f9628a007ce57e106e8babc1b835194330c4da863a5499baab8b60bc298112dd72b820bbebebb9fd4e6c6f25e692da61b45adfb27629f44066ac9b63f4d5dc7ad325ac051ce3164774341bd1950ab5a3ced84d59846e0e00c58f7be2dc40d79396b75ecd0c757317fa61db996f9e6893fb4d53d89e00f3bd31f849f4a693f58bfdbdbc5414ee5a0bab2f2a9256edd405d80196b9d0fcf3e78be87592b2003a3632e34530cedd501c2f9c9458c89c6d3333a806b869866f11404fc9be6c347d5b5f79697eb6dd2a75a7e191b7eaa9f5ee86bdce89e3ad55d58fee8e4f69ca147ebed29487ef1e98b114018bfba402325cac5a38721db011a260a0a9113f68b48fd975d991eaf0d6c905c8a10c7623fdb001868072af63e1a27bc365fbd8f33e37461ad65453b455fdd49c6cfe01be1d54d8455ea94d38bd6f180d8723af7ba9fa22065c91e959b2923b1a028f298d5f636c95f1dbd51386e16c2eef775ab91831af137f9ad04356f0096aa719665dd00740325b14c9d7032b573f6ca55b7e8e841a1a660adb6b7163979888e3a45aff5691db40e909f377696226b4751315935d8a066007feaddcb880b12f822e6755f1842039aabf99cbcb8879c0ef3bf0c394e669848a7bad23d34e2af08ee070274dd6b47dc8702861f08f3ae5122238b7046ca135b4c23c39c9fe4f5d998d12d47b7275081f460f89ad0f1704f9ad9976a7bb63917409fd4ff8cbbf17786d22499091bf660283778368aa2c668b5201c929157c512a69b04cdf538b1c8ae2cf142b394c0914acc8b7f4871f8534a333755b2da18d6ab54f06196f7b467ffa426c871ed994eacaba7fc04926661fa7fddd8332b82e8d65648ecf0093c6de58e898568f9b3afa00b572349bb66f7fe38404c2d1c376bf94eaa3badd75bd3264f8cfeb9d7b7711786aadda48985ea85e0dea7e825548bbd6c4fe95acc231a72f449e19767d522108f90d3ded8f7d1f0256dfbf5b44512c202febf20100b24d9eceb82de9490997b79d8fec901828b0a46de392d251b92fe9b9a1d1a579fc947ccb886992c03d05895a10b7556dc318e96258a56dc33e345681901fd11ddf8a2993e0435c95abacd856187f037b7d20584c7ff1563b7e5268a09021f8a6f49403deed9a5b5e75cd278a6667a146d561b2aabace30d71abda03e118076c1a267241b0c6f6d6e7fbb85ae00230e56b27331145655e14e6b502aedc7ab725ce01e3d91956cf790f64c0f7000f7e21368ddab202b03bff5665a82cd17362ff6caf8bac40faffb6c61b54975fdf376b9af68c6e83690046070a6d2673d55141fa746d6edc8173a926ff6418840c6331d79869e0971b1753daa6517c8f67a2eb4eedc5a1e5aa7b6d50c92d83861edbf24b9a875df7f3c6f28b0f05710e1ac9198707d64e36f7d7a407ab64245570e67076b8fa931eab3c52d4eace89a08b913ff03c30ceebba7ae1563aa8fa7380bbc948b93611953d8dc7176ced8672d9ee4e2146a7969f38a0316e42e0e6e1958044cf0b13c4620d93e069a17b7b165d4e547de05fd1a0ca2137b45aaa132feba6f5215b5f56d2f78e6f93f42ed314897a009b806d8380f1a61b8bcc98e54839ada6785f3c9cbc9a94086411f4e6f56d1c6dd8509486cc9f13fb9a8a111b9e04f13acc609c3602cb37c1ac9dcb0848a8f0df7c4e8aaadd440a1bf80b008018322a00756c696cd75760a3e0c17df9604c13aa51370f8d30296fa9fee3b6bbafb9c0656279381d9f87929c082fb9f67f029d668b5f303b7eb94f07c412d4f05c187bb894cb0de441e4dec7974d7f17e7056d175e1d683601ab62ac2c7b2174cd46d043d0664d7fe0fe7d6fb69fc4acc7d5d529031614809a43df78f46b3e50de6ec5e1e837532b5116e0c5e8b11f0a24c0d76d9e51cdadd95bbc4c47c33ea07746b61ded42515f67441762a4263567a01e1642d620fa1bec9dbf9418a7cbfd4e7adc40245cce0810e802207d7e97643b135eaaf95865dd54e95061ae1d02b0d039e6d116199d69fe521c8ce75b72a523ef04e82508580dbfeaf678aa732f65afc9fe9153edd41ae35c128ae5e0f38baf6fa0b6f8f4f0ec397ea94bb0cde477532c4312a2941122320a7782f4dc63df2de58b64fc9dbdf206f5e640f4336006eaa9189742d62975a929305574177fc1d3a78f11c734aec3de5700dc59b4f707ee7b3687fa40525b4103ee3e7fa7ceebae821e5ed911a0f255de60903ae17ae901d569e2c739c23f16997db13eeb85e88a32ba611890f1775ceb630c76a5f4993656bf267a2d02f017e4d8ce5d1c31d5346f9cbb293b4a6db30f52da769ac525e8ef168c5a04d98d6fcc1c56d39add04c7f515260936ca4d271f5a06ef603dc30a1604c8e295728eb2552a65fbab1298a51b5539cf4c0678d067e158736d07734a40af84241c5b538175f4417d5965d6f01694064abb072751b5c523c964c28460792b567eae2747c0eb23543a16dc6f65cec7e2fb91bc53036aa4cd9b183c14f0b531a0e2e1552ec66944f27c8718db14d7663d63f46f94488b72f622d755f040d8e470040059c13beee7b35246d28eb2cde16a5ef75467fe8dae3842fb642dadee36db545f5babe44e0296897c32f543798f2f9c4e07a0dd8b6fa7933056df459c6d5a708ec5b29579d691be0f89875ce772f2c58a98abe205008e6f773181631e118b6c61168a9d7179a7a37aceec71f5fb1f8343a9e206ce0ba94243f9dbc9f124d666cb13be53b80c060a100e3094cfd0272857712f470b89092bb8fc24a7707201078125f884bb30e8f4ea386f423127e38247deeae4e784bcde7a6a4d44799dc72fa65bb1f213a83695a5b198bacd6ca01be05201e893b5ebcccf52b50b7cf29920c5d289d3ea6d45663a63e072caac6f68007605c49af12d946537ec51120390334dc54ac6a65d763a35b551b7f8ee8c335c1a03531b0aa7ce9ea8a93dadb96c8516e099948f55b06be4f42a6768afdf065a06349767199931b718aff433da114bd2c96671f7c7b178464d63b1a04cc6b559a88fec461f111b71bfdf3e61ba7156293acbaa2208455341f6790e34ff2ebe8faa7e1a45d5f17af08635a53aaf83f25f416e785b8c00537d62c5286e86ddd17ea2d781bf060f35bc6d97cfa1664a32b7da0ef9213cfec2875fc2f0ba79b5a6cb255910c30bd064738ae5aff8f3c7a41738628715bbc3c860221bcf71feedf6452dc1d2a2881837fb628d6e371c91052afe9c822a4a15027a45fb6d34de42516d2d5e17d5fac37c4c94af3b9fac514f4526b6ac467bccd776903fd774c873ea9f5589b1ccbcd8e8bf36f5334c2dc55abf7bf46d6ccf25e481d67e4901d17553912123666e7e205e18c808e3eb526948ad325a59775ab9cb2f232099400c440b224de2ba0f9531a4ff07eae2879615a0a5c2428a893d65c8155bc86ea60e4d8fe65ea380aca15cdc4a6ccde557abc1d0774305476511054883913e7d175f7ab4900cc4f2da71fc9c52bf68a01de5175d736ef97574e83b27eeb6b85f6da2399b34f6cb3a2ddb55af61d39eb33bc85d5676b71e3eda7b9fa2702a3c9f69b776ec67bd1a428b359a1785b30552c2daf901872bb1adeda382e1727a6dfcecd38d8254cf71798cff91a8e0a4e77f7c2f2698b1c8cec97ee9ba871e39fbf8dda9dcc4c1407a3d93c89a2046ee864d95e59c78ffc8a5ece238c3a512a816eb4b5ac8b4a6687d0fd88b83753f7e5d06b3ca2178ef648ec6befdd191fb08b275437f1aef0c98755cd0f133d14facf3afa12037791f63186ce07d7062569f17304a161d3386cf41dda41111d1376478f368373a039b28615821e4b40d9eaf810268b70a64dbca5bd47404c91c222a8bcdc37c82a9ff3e4a3bb9a3b78eb5ed8497042e5a4fb0b16fff3ba52e7e24d9880be9ec9974536637e42eecc7a46b5c4c87d763d598033d4492b7ea16dcff379f5bf849e9e19a0f14a10b2365e6c4101b9dd665bf09cb09c7febf90bc41a03caff40922b3bb9dd97f6fd1e92d3e190254060b6008548518eca14b28374e9efb4d6a354d7f9dc9f1b18c69340106def728025571383a87ee2d477598399855764fff154a11546b66431142e4f9169732e9c2ecbd4d4f25b289f3ad9da9ab95509ae6a5f655da42dd581181e7da2c461d474f8c28f0963f5f326b84b2ec6ab6b6c042a3d060a64be74c3789e5f88b8fe7fabbd569399524894cf8e3d9483dd0117ba89c754b09d5d98f51a29b8d3ca84495df24af47b8267838dd9fc566df65bf06bcd8054a6acc537962d8eb67e24c6f31f1ea86e2a402656950abdf65839fde77338dd279cfbeaa92b19b036dfa5ac3ad0d12fb798c1ec01324fa800d1664caaf39db792d8b709adbbf7d5f329ba5ffa2f89d8570d529a621aad14f6b33401a5759a6baa755c1fd7eef8a21bf4b1f9bd5ae8280ea858c6e3c52989daa7d81cfafe0c6305c8078c3c911f8fadb83439b36acb04dfc52b79c89e3edc6efda0064abd1140479ea03f09988def4ecabe29e28f0926c5048d1cb3477684ae26c09df7c93cb4ec61c0008caf737eb4191706837bcb553217b23ac76727ab72a224157631d15fac0bef82699324d9b70eccf2d21dc24cbe94802d12b00c89fb9a14dfa7b427cb417de96ed022f76f5255f4f5b70112ceb15722295b027fb782a3040d82e95c90a63585a641a81214736cb8df678e35bdde7811e0da8228f06ac9de108f4975369ea2616a8695c2e9e57e632d491a71dfee27ee8319bed77428be784d38be73e18e67ddfbd5fb4b6a78672a4a0813a4ace74874c193b23fed48c417ba87930dbae2a1e14d32ba088f47a7b8fb3c54b942ac0ab77c98abffa6ad473bb6f833ad7871adbf5570cc81599546a9ac8da191101ebfcc28073c1127bc14e98e0f05d0ba662d817b07492b18bc63bbedc8dc492f8d2a73dc9f7b65c957ea8569eb9e5d799023e04e22bf78a1b47125446c966c65a74a55902a3cb3dcab9f1769acde17397ae623804667308b0ff53127d6b02ff5628fdbfc819523d21157a7fd00d705d201efd69e24452cc5d8b7cacbba8204fde5061365d1d420bb9f4157546fb3b32e239885ead314be8f1e57b881e80ae3fd9cb6b252beb7d65037de4a837fc2ad2cd4962c66c9885be906ea477d44c6ac00f9b34f400808457a65f7f41c04578be19d0e7731025ac8abacc75082e99155bcbddf3c5dac1c9a6d10dad7194c2d24cdbf3e25790150142e69a33d77237822515da9594653673d88cb02c96ae792ad7f9509d24ce93d6f250c7f2d1b46cc8c9fd24e321a87c07b1b0926a33b88f92a8be8d2b6392d28de3481f8268a5e473980bb002aed2c50c4030f4a2f8505016e5cfabece73d289f22f51369d1f74d0817b5880ef6f0afeba22fe34c253e3bcc84e84871f9fd6e98aedc6aa65f9fcdc53d3711850964c9312ae24da9933042d5c124fb94acc66f9835dfe5d43eafce30c0f102a8bc7afa3ed493c2fd318dc039ff0e299f2d11ef4418978e0f944f655175d54758b70af5165eeba7d3ad9369c8f16275e0b8f8ae63624cbe084d63c49972748123eed535c06fe8b701ae8ad91e7dd7892a7d2e84ae929a2c6f6e3b191458b49f59ad4f50d4340d27eeae8aba61dcb251d9ad342d4ccf1cbbb295d8bdc42de56ee38983f10805d99fd7fd1a510acbf781e4a49ea10a5719f6b52105a7f534f4197cb3c265cd59a20c58308c6023977b5d87d74bc78a4234a89ae39d5fac4896ac16df192b09bc3b2aa7745c50fed41a2c3cdda98e2d3240694f37dddbed5440dbf289da25c49d0cd942c643b73f12d28442305f2536c6bec9f0ffefe5ceaa9ca62bac669e2dfd7fab886a0ef2b82dca9ce4f19acd0c0c382966b174ac147c2f0f1d532821c599cde3f7a71d88c9895e44df6a74a906abd3cf10fbb007b758d0de8aabb6310b7e1aa4c774287e3ec38c6e0b5fdc9ece59873c6d5faac1afa53ef088adfb061c070094830b33b9ae4ee96a56b8ec0177e55717ccf7a6470dfe570a4220d959e6305488ec3f02314b26020b583747995f818b82e1a599656d84d4116bbac0bb2d4cf5171f1f9e922d270005d23288c0b8a1fcf1cef8be62624099c20047b7abb2a6e4778c35fb3ff0c1c8dec9640e35cda006f67076621115faae03511c520e5cc5faf2a5ce3d568f54473a0633b55539926c513877e3d4c081d89b9d46208f5f42dd32cccc422a5b9d913ac2a98df28f9218a2733d5603b5b6fa0383c32c2681781fb188245ba9a9ee7a95ae904f9d7c0db906d87df40ae3cd0e822e61c584b3b5897aa72842319e1959373c3ecff7eb619723ef32294914973a5b9850df0f799336dcb5db4712407d8efff38e48b3fee99748ce4176e47b035c2abcb703a4fa01e59ec0d2172839d8df3d8055870671df10b4eb7daad929a20e06fde9315616ea4cc2200310d3a67ada106ee847b90de10690a1dee685102f8c1f7cd8e0c6b9def6feb97d19d4afc8fce4c180e8ab613b6a4291c9a087c09204c80309b65f69b5c4092599a8ef0968d51d4658071a6aa93edb3893aec175705ee5825d0e2dce6ffde01a5ce82b68afa7c8904edb2014e623e3db508ac10377da6b16b64316084c25bc4dbb633c89d3a2de87daea69f38ed004701c612bec9e3c0dcbdac824d6916f01a79a30e786fdc6ee6fec38aed91f530756dbc690e95ff4f80897f512601dada7895bc9c106f2622e342d671d1245626783924ffe1b0d3213d27f0009bbc897646562e3dec981070446687539ac093c7cd11d8a05c57dab257f17f7530e62fa69cd6143001ce32043af60d8b91b29c83379d0bf949f306da352cb577780082d3cc0107134e69df96e0c82614f6ab1058e2559738f2ae75ba6e22fdb1edbbbf30496b225429caa45119d307653224d8c7501bd9fef4c535a7651b6eddf234d9815969e7c57ce12d9928c7a8ef1d81b15342611e9867d4d7575758e84c65e6248b2a6347cc8f6ee509fb3fada0ea9bba8788fe7b220d1f0a86f71e68c1e3fb46641bc51f6701c5fd808cbddbc5d1c3d02e2473d5163dbff600c8fd1842d8fdbede6496075f2a841dc1f168d86838ea8471f6ffef541e2310ad3bf69ffebbcb282b7da6fe88fbf648000a2171b325e36928c34ea035824707124161cf8f82c25a1c4e97abc9965cbcb5fdbc12390f3a27c47ffaab962d95dcea18a442a362bed5ce14774a913290f3d94c7744c0997d43ba9e1119d8274501f9e557fe7056b841c45742a1503ed779e1e509a81bdc4a471383e13ce363e7240e1e06b53e93d63936b480ae522c09a5edfdfa1c0404ce2fa564f191be72e0926dd12cebccba796b4abd9a6eb1b79b24ec18945d7749f2723287eeb20994147c4f3477b9c0f983a321d636f9b592ea1b4e9e0023c1dc81460ac59b306b021bc6634fdecbb4543ced8690ee1a45b5f31e84faa42afb5b268833ca0aa509760e8525d6dda90734db2a66fc020a040e77267542bf9ca502703c150e7c59a007f3d8f58a5b181f836f92fdfbbfc155bb64a38ae19731273efb73482df7bb8b5db3b9003c4d0edecc9e7af287833fec049250c4d1533a1443fefc1e7a9a9d9f78dc6d33dc3ffaa8211d7902eb17568839a1a5c69787717cf74d00aa65ba8937a43e006b9f95e31959d045e8f09f0a94695596d48addb0bea8a08843df9e461ee39f99b628583dc5ce224c3d711479a7ced434401e9593bfe8a7029472c0a7ba8aabf94b2ddffaea4a34821113454e492206d4eb7dadc8c55f6137a6b85e45acd6c40b4468c71a074ee3ba313ec6d771de7648b56eb61d88de3cd226adeba4485901e4493cd86ede15ff37c6ed9a10f750208ddc99b698196fa9527f7f821aedfc8e535ed07ed28069517d86e71f10b9b7d213e12fa72bc952b30d4d224dc43b91b28d6268892d757a8ff875c38ce0b6b029b3dbd834ccde8190c23d89409ea49775e17caa16383df23d515ceb0c5ddbb221a29079f7bfd74035bc84037ac8abd576e3d2f3a0e4a2556e0893b444885fef661427775928b0939d0a389a434181384566740612daa33fce66d75f0b28e6ce46982dbf1c70a699f7e07da7048fcbc8326bc18469f36c379012f456a67eedecd1a49ec9363e7a70996803f49219d0dfb1dbad2bb937b860161150816beece75faa436258c2a6b70e1a797c319eaaeb1ab5ddabb95b01c55e2d87aff47e535a8a9c444903e3268f9915dacd630f44d59b604db15f8dd730f540e8009fef32f6f9ff1e5f241801f544294c560f386062fbc0f80203b5278b60cd3c6699a4ad10554dffc46e4870ea6380f4bbf8e2a66a2cf8f57946aa358a91b8240bf016e9ff2cb18a2eaa79dff5b015bd812fe54429d39f57f18147a66a2874a5d3ef51a383ad29d63cf10c64caabde7d28239a0b7ce5afbd64d18e2a804ee2c2aae4c08da29655c88b7629130b8951208b79b57f109e4dc238e1ab5fc52495816d391a1999e84091f4136465ea4202d224def8c8f40815fbcd316665517e271eee373074988588e51f29b9d578f6e8db322e343501341dd957137208bb2419ffdea0b72fd681acd35f607d4191e1cdb36ab453d569b3161474d3fb6fe9aa9ee70b0e1c771c1fe8352cf1177ddec06f7f4969cc101dd0577267d95ae7765000118dce1a0a00aedf33a2b7044ce02795854957e0815fc7bd2d70c8b18871d180608feca1a99988b714c512728da594785e1552d0560d99501c00a13839ddd4801140d1cb4877cb4eec7973af45d2c7f861a8310174ec9d8f72bf4d4a6b005fcb2dd6cce54a39eaadac3c99878af61ff13d5a802d47c0865bdbbe2868fbce44c6ee1e057ce5a54f21733132a9fd3195f30052432fcc8bf011d75f0bab8dad7495dd8cfc1cdd5fe673b670daf774b62145ea6ac96f90b6d274f017ca04b6fab67f443a33f8688f302415f89fdac6ee5f44d69ff7f7dd492b2dffd09274bf237e517ebd542cfa307cdd05d8bf67e49147d5b7f95fda5c1ba56341f60d88ea1e604913edbc81ba2ac54bc7b15c33efe8d3daa1db30f8b99b042fb5bae23b665157af91c859f1f24b48b34141188fad46a8db11a242e1475d8dacf9b5b504b936f74b63ea55ff2022d39323ed1aeea90a1f93c3ed87c500f1c5ef8e2d4827ce4821454cfdba3e46fe51eec96777aac5ed0f9ed374ecccec68b51f7a5379967c3df525a44e557eac4819f7a18843473ec5f9419f5ebff9baedf279cf670b1e7b162f217aaa1fb5a5c6d2bef7aa18ff145fcc848d3171dccd5ddc6f5d3155d31a129766e6f17231433e424b230d543768cef3659d137a09a733d67dce77b2fd89ba74289187151abfe13d72e6013041c7e925639fbb929d12fc3b97f5c829aa9c31f669a98e28ed2d9d7e401438dc068ba8739a62616af96c031dd9266fadf5f270c7212c9cc2d78f3457cdfdae793c641f9d5656767d5ecf7a3c1633222a5fc1c98c46747555dad2cbd216df434433a4ba02b5d063790aa5961b1b5a5061e5493fa494bf280bd44975ef4371d25b9492fd8ade936179022f0605282c28201511b72e0a097f1b5b2dc82b01d1db1d0ec25acc28429e8ab1e8328b2524857c0b585cc608f386fb7a194d97151cce462db5e5a4374afda9dd6e594f88d3779eab3d141afad0ac72491dc5243ed5921848eb6dc02a8f41c3526bb193a6b683a7d6b9d3bc2778853e8fc0dc2f3fba67d85d38ddd4202a2e501a69c4d84efdf96ef12980d2838a4a678bf346ba00d201326d6519e1d1c24ce489412c1b880b1b7298d251e0733bb3a7c16dc048fbfff11e62c41849da8cc579079228d1b4ebd78e13c8c60dca06302f78285edd35997b963c01e249463454ca881c065c6cc0621265d1f40d6970a9904ad317d3de2b1327545276673b189c285da7b832cfbc766530be6b811cb3d66c795ab99bcf7eb71d130e381ce44b79b01fd9f5a523e52143ea731a96b6ff20d1bdf81d5c0145bee1e2a77890d19c76f1e8ede6ba42234c4d61dc1dd7914684b12de1c81555d54b439a31b620ce17c7b74df17b39a0db364c553c5c623b90d7b2532e30610ef14fa9209976715022f25499c68ff25ee036aaef42fb5cbc7f8b9e1533589c124a6f605216d46ef3f0fee76293b15e4b1aee32ac04ea0c91b680bdf09e8552960a145c848dacc24ea4652f4fb2ac248a7895e6af455fe97687c04d4e4e2ffe1685a5630336a557d499768f3278cbdcc473c97d80f238cfabd7ba6c2866f7082b116342405067fa70a5b6cb6cce1b880433d539856221636cfcd6ef321712f0b10d82d668c2b604f2b5940c51446a367b854a5b35d9267f8ecbea5c6dc2c5ca518d23bd2bb4b0f6ee126c918643547096c0ac2501e250824580779b20f91e4693942ca1b05df97b0e97dc1029168fb1651d3376909f29204be078417924445f13ffb2414d2c7166ea627c9453ab60187f2118001ac1254c81de7e4cf9ed553f5eb22d092539cccabe8033802df9c5da760ad26c7ca83facdec68a280d9f482e5c9220069d9725b9371648255ee1ac21ce994eda7da98f033c5ebf38639cec35b99f8af265de0ed1368039c43554b6fa7b32cecaed74ce4951118c53a6e47f876220f13f73aebe7643f19ab7ada5c6b91bc6129fe39341ae596cce2fe5eeb3157674530731ed6111dd085e1f28b2d62f5be7b3813e38eb5e5ab874736269a96c53d89eafff9538514ff7a4b32cbea40d420fece690bd4de0afd82f06b2ea050e47aac198253ad72e5e6dc7d555187f9bdbc7866a926205e35d9ae3367e443e0610239dddd5ada9fcfc2243fa0e36533cf1740115591ea02dc0bb5d120327a730206ff9d05f4922667b4ddc11565742e5d80729bd998bc2c79fa4c3aa50c46b272301bfef719bfee8a6293593abb76de683d1610b5cc150b330c2921937d49c372433bad0d2f73addac8a49271f9a4d2bc1c30f89ee34f2f23c579ba6507b1c9b9bdeb69757eea21fc892e747b5c2edab570d37ac4744ac284cff26444921270d7a3a2401cec18cfa711d5811747d3a945fe3e5dad2743fca1b501e68f3f04fc480e812841577f3a35d02012f4374d16635b8dc340d8f1a907b2f535b8fe55eda41626c3d1be5199bef5e9b876623dded8b30241fb39e13b063de5fc0e0e7073f0ee8a93d626e6bd6d42bf61519d49532785213fcf27b48797fcfa02d8906cef7a1aa6d66a4a430faa57333c5ed8c68940eb90ce322d1876ee6a45534c6ca405b020d93737528a4b46b4e394194529fac9a05975a522a8105b0c95cda85c3a3b5cd0d84dfe0f12edf0612fbf1d487b10a5d7be0e6fa197e5391e136a271632fb5bb9a0751968e8642c40ea29fbbb58f4b26c9988b6e9d20fccbf04ddc72058d8f86e0592e476ac34f4a5c10ef72e323660aad0a53fc66a24106c2575d92633d38d2a6583d4caca000470922143f3f42a26ea10ff56d04514325825643b9a631263c7f6442074e8f2b39863f95ce69cf112907febca04009af86a49368e739d847ad261a4bcb736a6bda4ada51f22eb88ce47926e4a10497417517dab5d4a6686179fd93cf33289e16066d1f2ff8e5f947cbf000176dbfa40f8da891c15fab85b9d541db4d50c94c9ac56db3ed6caa28645d1f808f6686a97327299894db753024cd3d8f234733a641d14ddc441a36d80178a954b23133f3f2a71ff5e82c417d16e85b1474b203c415217ac0c971992190e725020864520b977f5157e8317428edf892c5a500a74e684474f8502667744dd2017544d73b46f25506f6bfeff52732ca03243a3202bbb05653bbd87812d13685ecbe960d29fdb7dd85c0ec3666df17c448695966007ed44dc62ae643429f473176ce56719291b572eab1e96e4ecd522c8ca185cacfe2719810b7cc20f17aa6cbe1362edf733f4ef0ecaba32ef6b5869360bcefaaad2c80d30e1bfc74997cc5fe24a28a9748e39a8338ac6b2445259b5247af57b9b6baa997112115777b2138982342e19f37bfb0396e890cab0eac273036a1c4ff75eb478c407f364df9e1841bb315ae76b55905681c1a20532ffd61de8491ccbe6525faf40058fa1979b3dfb295522fee0ffd4361411ecffbf85b405937837b167ab9d6faf5c617df9487af03da9b06ee2a081af0c9cd01076e05a438d2cf7fa4adfc7ffb912b334a25ce5df383cae1ae5cb891a7af3b42e555262756cc8337f164c689b5d6da2af4a4ab1cf5a41ab3b3a71415c1ad6777783ad6bdbe5038343cb4fb431c3a71db1de6cf6e87895eb7d52b2c89895c3cf051d960609cf78e984db36fe5ac393d3f58209d8744785bd1bed24d8b0014b743d7307fd17c8fe8fe112ed140ba423af370351d4a8e2a39aa90522377fcebd2ad6c29d87bcfe71f2c78b773513a867374b79b9cdd8b0fbca342cbb6573c9b334dc16a56e33bda4b9d6a63f7ad53604b343ea4460e5df6594d2dc6a303cf673f78e2a1f94fba743f18","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
