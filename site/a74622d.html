<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b41a1d8fc9bfe91798f35f898444d40d958560e5f2c72806d219e4a199c52a5288a508e03555804a1930a50e004b7bfbd2448be7be1b2e511cbeb8141d40aeec97c131b3e8c6f8ea858d2295f9de9502cb25d483e8bdb798ce2e97a0a03a93c054249ae316ea386f9fd5c4ed2c6eaa3c1b07e9b189c64dc9feb3e7676f53f3b007c3399e3c97daa1efc97d9ca45c8c61a30d43360520164b99d2ef47cea3cce75c351313adc02bc3a53a6d6298287c6e9dad68250c8f11f6a8cd2d4664ac0488988b3faa53ddec5ef94487aaf619a1da2240850fe8d5f9fd81b0e5316356f9dfc6833a1cc5418da2e656df409e03070250b83f75d4dea1461d5f917b889c2b92e668fe6b1c9ea700cab23893945102643c606b2df1f1402310a179cdd5df9facfd7e3e8252d9a025f3c2f72552dd7e6512c153bda4bfee6e1e0e23e12eed78539a8cc2acdffa3ac8d9b9b65f5ec350e54047f94f008a399f00e447bf3ef4fa0c2b1cf4cc722abb1ae05b8f9f54ead955d02bac01738d559e527c8d9b6d5c2e8b7e1b1a0e60b61683fc4c820d1bed7a45e926a16bda347b400ab6b293492f22f19c22ccf1ab297e0f93f1ef61d462f677593fed0b442cf69f93a64fa7739dc88fcd97f958342078a6cc9c0ddb7c74491860433c6419cd107eeb94fbd5a8d7c0eb53cf6ac417f2f890012c40f362428076b18f4bd4aaa6b12d4fe981c52b5c6660a448eb80600390d708d2ed13d755df90d95c08e5ba20459a893197b31ffa8ff5b600589ebb32c893fd46280e471d72da30bc2c24c54de2c655cb58d57bf758956910f8ec607978d556084b1a70c51e74434af1c7c4764da5a4bfb874e0ce421249e7b66fe79e43f251318e81cde835eb5bf4060cf5237efc4b4b6654e96eff73c676ccd09f24cdcd11c9ed147e53d2ea33e93dd72e3da923bb62b575a8ce939e3d109a203ffd3be96f9025d84b39a16c0a19a69e6244b14f639b69ec6335699ee74663cb16ebd549db93aecd564809dd1a7ebec9914becf5f4ca446a3a086bafb2e635ebb814e733dba9ce42e30e99d2c06ff174c7fb5065a2bf95354fc8ceccd0bcd771b34653c87b3f1ab8f67e216d593d1088e51c549f3035078b6e9332e48d000c1349bf449d96ca4dca5dafcb21d138ae2c360dfaaf1b87174ae8c2453745ec2c7cf49f94b6f16fb9c63d9ad88f2a3f7f0ba1d5aa14c2ce32131de1a7f33c0c420fe46b1f77fffe3f262d9e0ee9c95a11af058aa0352c546cc506286b0d7d4476cb9a6fb133cb2de04a7c7abce9cc927432abb1271041b8604ce7a7353f87f229c609271ede502c7ac5ee043ae9cf2501b1546f6bd364ddfee636f01c3306f457f4f5cb76d540894054e66644a9d99c871b53441bb997e5c7984f5f512ca3e6415af51d9f1ca120f08c38d35957bb9e7f339b7b4f6ed86f751266b4a21823ed4354d4822edfbaa64232bab35b65f36c31de8a32e97367b22455f53a4aef7b555557ad7905fc1a8f7aec619b7548c11ec48598d571f0c6e68d3dad3743dee603cb10a06ca3c4a326bceecb84daca7d8a2ab6542cabffb0d2dfabbdb122210a40b978b6163012720624d00c472a180d9910626479f40f99e0bb8fa4e9e96236e94088904ee77c0edb8dbe1ee4e38e6c063c28af164684429d8eb2b894440e7e5829febb39f3679b6ce4ad7f8a32c5079096c4b35250414809a33e0395644f9d70632efa0f3810057a5195c29e0bf9ff708cc98fc24f661361a5bc8fd67638cada65f111fb77412b99c67a7550f2cdba3a9d8f18b1ba6eff46e981972a5307b36aafee20ac867864a2d4f8412355503c2dc5dd0c0a56b4ce8721734e05cb0783e8d624a603a5af94ecb68d1e761e953f38e550a885b50dcf22f5d85f20e8143630c5094b940c3582d62a58734301ca687a0e3a14b52a1a3390d078a282c9bf92ea9f92e562cd24aa2c900c84d181c3b5cb659ec41b50f28b6f4f712cd5be78fde48af543a990f73f04e694ec60d04de6cfeed6e01ed25a87a891866e60dc144bf1022a653898887b74676292461657108f67370b8ae889b3742365ae15e85031c76aa2c53670bb0c7e3a4636d051634ef81bca0abb1fa5cabd3e11224038686438f4cd93bfb65f88ca9364ea6b25d1db3495eb14341c731b9a51fa6dd1c2878787f5ca456bc1a7917b0b256329414fd0a082483dde0f0c904210f6c59069bda8972feb6b52b84274aef811c060042bc464fbc9f330d459229f906b46d1ed75bd70ad523a2c6cffe214b2cd12fff62f42a9f0debe3c7c01da029339f3364e93c73dd69173508c50da5db12de4eac99cf75f89305edfea6b11ee4e1dd63812397b1f7bc3c6a0eb05acd3c0ce180499c3b0d8ed80104ea480f2d1ceeda2a031fbb68dc31494b765ec395f0264c2a30d4793e342857b975f307c238faa8924415251512c35dae2272771b085f646453440c7ce551fe21f8a1976b7a8e377576d285732c846b57dd1d3f727d384c3ec1795a5c77bba5172c844cd357f52437e728f21a426d57b3836275c1397f3dec28dca6e4449a0ff6f927c1f2d16ff476b8a3568bf587a5a695443ab13c25daaa6787304f9a5c0bc4918c32fe1ba7811f85a14ab062bedb2b98caba8897e3ed0394a82d0158a8b8c5e03481d1750eb7656e07676b65547f5e4fa5f080eacd9cfdcc7c88e7de806601f1057e374574c9f5e98f638cc4dc95dc7a8894d17bfa09f830d5f6f565a5094f17cd5339e3a5deb0e70b3b87794710c53a40074c64f1ff1595233940b7017264d51c97ddd928959ebcf92dfa0b9892a99b5c255d6a824d1bf1cc6669e2359731b114ff3bdd8734e3d0a40f7663617df2c54c6c6d49301094dab5f2b10850781e5bfc1b6b00c75b6c215bc1b5aed3df0585a0cb5900c1629ceca656a4df867b1ef68469bca8c0827638a1c524112c8995f62eb9b4a02164c9fc874a96a5de8dc8f98cd61880e246f1809c18ea158d2440e278cee2b0e539f08c252b9f76a1163b8c7d0ed93a6ed72534c2919b353cdd294c2a245e46d146cce8a4ece84dad7f1acfeb2f739927d92d78f7ce50ecf449375abeece675e183fc9891f4f71ccd364e7184bc66cc70a7b2792be301c1a2c5b6a120c770bc813ff3dda635f4165e1e8651baf275d0a7f5c3448d535a10b678ec55d8cbed88548565f8ee463f0e73eafdf66f9e48451445d99aabafdb8b1a8c4978b6b7b5d56889d7b65047eb2e2ed10b8ed8706e9bdd2196d9f8f4770c92a909d3ad87a99cf4e1f6e1065392129c4b11aa88bd0233bc2e46283256164b3e091a13fa9fdf57e6c297ee9761717d29bf07da605db3f6e920e990a80a87eed61391f8c730b432ca6ab2a3a7602902d8b6ce52b5f9b179fd2d6456181be3e41f35091d107e6df20cc65eecc5c811c4c917641ebbcd4f8b233e6109e8348501a77279a5c095f4cbb95101df15050e056fe1400207ea3ab77bba196dd748a3e742c4e4b4aa5454487c22755de26f5b506437f7feda542fb87754b1c32cec8be79b6adc863dec39252dc7f2be5a785c2f01969149858ceebb820604afa6530b1380bde6b82a4e2865ca672a30529260b9583ca8d56f2c409ef9f49d030e0358f7f0147c33d14332cbdcb2f2990c494955d905dfae5ae49fd67a567fa318b7aca4c16234d7fd0b8b83889b69795fd2dd3689898c1812ef0d2f04a53002b5915a78495f8692abb3f957bd92d602078fc9eee1ad179dfd78e009fc7cdbfa03ed04db65f709a51cedc8fba50d51e7599e09e1aa538f02322152c611ca600b2fc7b18d19d15af906af01d1eb96c56e6c56c2efe6bc130ee67b11b64dc8272491d006cabb0c898888a4a4b3bf2c97b71584ee6747fac5b605a808b282a3c55c6ce8236bf65872d7aa410f83ccab0a6a856a95f7b604f2ba15ff561e8a50ba955c8b35e05af5fe28cf2329248ba2cb7969b5e64de9b671d57ea5ec5afb0c89eae8399f68a4fe903829696ba64690f5ce1416af1f9cd4865decb6d927aa2219b2940e337f8897a8a026b690126a2b6f5ba2b115cbdf9ee8e9d8f20d65ae94b77be3f0d2fd1f8ff7885cd08f3327efa4dbb9074393ea474d7e630cf00d3ca87f72ba8a4aa30ff186d616933a2c8139cc217af4a240b1ed59d326c711c93c63d71c5b6bea049036b283837395de53771f496aa0081d1eb32681c68bda10067a1e719a3c62d9630c37dbba7df5fd67db5274204809948ec14098682667547749cd3cebb349e9243c8baf3ff1b2f51e5d70822a07285a5846b3b3b87e9b1e632cf86ccc437fb4a7edb463e1b3c0aa171be4bcd68ae79ea1654691ddb88a9a88b6671c51edf15a6b4b7e97ceedd7a7efb47de564ea9bb28048a578e005aca7bc8d2a7d372095bc5f537d55a78db3867cd444519e7725c492d9cdc87b613673690f61fc8415a8b056f6b2bdcad915108513c6e58fbde65c57a34528f17ab02e16980b93e2d60a9ad23ce6ae6505c2375ab7fdf7c2fd2422c631bad396ec1e791b2098a55c78502cf012d81ba65693c447ca24750896d3642238f166f6f0250c4a98a9cc070b69163abd1fc75dade47ce230efa95dbfc488b64139a33633a989427745628e8c66a8979ac27d564031f5256ea0392da8500bf2acf9a6eaf7601e746e6215cb291e82ecfd11971200580cc01030116b776b28111bcd672c8e78858a477d6053a1133e4f1fae268ec2d0a9498ed6de5f306c2d5e1f17d6a3e780218a0b3c1c16178471e0bd064523e4f62291aa0a95cc7e7ff030a28977268d19f9dbc65ac1619066900bbc4e1b5be8c59fe5d21dffb417b3065bb29a7dacb2915224b613e8ba3cc637faaba12dde95e8f88312893924b27e282c8cd8eef1ab066a89b38bafe1d957e1b98d77c81075a0f0259417676c2b520cbc6b98273e5a832e1ba0473a9d90bccaf57c17d2fbb2ad84bdd6b179374c6512cfd792d87c0d4eef784c4de447a2cc3687a3dfa3c7628502e2ea36239eebdde7a1b954f00c4a3376af6857c461679d986144df68891d841be07f180f6fb5b975b976d890580a05e892e9c6a7a77536e46c9c9959752d4e9f4bb91fead66b310f62769ac02f60922735c2578a2ff4abd7cd803ab2e419eb19cf00a63df3318b3d315fe59f9407aa2cb93af1294c3e24620beefa024602f0f6ccaa519093551cea3b33233324feda2556ae9c0a50481a0b429ddcbee24a32d2f46185f8419a5bc582cb327bfe5e46cdaa7755a52e7cfa0b7332e701512768b3bf49137ad15fce07ea4fee83ea50feeed41e25f40474e466a32118b6f1c10610bfa4d1b18eac43e92de741ed937233b04593ba03cde755674c0e58e4646c4f36c862aafb1cdb5d5c8b8e901d6049b6df430ee430142bc490b351b1fa0017dd02bb491392e1f16fe5afc238a2237680308feb757cb1d3bbd5ba6093e7473b5f9ed23ac3b6d39d42548551bfb39ef81b932fe4c32aa7fb655f08c8a4dd57c7593d3eec6202d275be9b59de5335529527377888bafebaa261bb6fd3761635d3af4c2548459e5246003810259d459c4dde0d4dd7bcbee9c1b291b6a136be295d51b75f323b08c9b0c259d1c76a554e2e3fed741c4ab88b52ce9fabf2d76e6edb5e8814b2935984fc5b8c8360aad20763b7a11852577d9edee31922f8fff8bbf7d331ad79cdd30bf6874b9c4b09700bcc15b51b36398724b30180df79ddceb0a353458c9d13bb30468a3b71bd4b590b734cbd8793d9e16e4bf43ec79bc77fb2b58aa335d4c1cc740c1feaefe56d4a6aea2b8e47178f53d8cd02ce9d921fbb07a74a6a61af4548b664661df5e8a8d489908667b44e2d174dbf9e197cac28166fd1af164988ff334c99704525ec19ca38e684afa2a8fba4aeaf45b5b81467d1b28f5373cdfaf5a1c679f1cfba0e64e59b68bb8c36b874bf78893ae6522b9774f92c868953b517add9874d238fa81a55cab761cefeb56974e2fea4ef2cc5ed96fc2de6b9ce632e9c5fac6cdbb394879175c59f71bcdb913cf70627268b7640ac63d9a8f3d9bfcb9f20fe3000c37e1ad0bf8d9ec99da22dd034afe9943e6d50dfa07087e2f5ad3f395627b58223d904f2ba48ad927e59e522956b810956fb5988603adf7b7df7e9fc941500699ec8975979c9e71dd3a15d8a4e076188c70c6b5978000b270ab89f1e9bdd476db7dfeb67a349f93c065427cb2c9eb865ae0b4fca479f9ee4cd1f8b4f5f01b452f5be87115ee82537a9a24affc95bb2297f4bc52ac3376ce658cb2e2de3c76b369fd566016390385018107d7770e08fab37966e0b1e78107a50ae0dbba16008c49b0e4d323297b7a48514ef7f70fb207a462b6c61cf59cacad4836b7ad85dbbeb05d4e67183ba629d1c9df32f24ffc944162a2eafbd4f4b8bcaf65226dd95497c17c884928688bd464ee2f632b9da6a9cb63ad3929ae51fbf746f2fe0fcc60e1d9b286fd4a739a14a186c4ac5c83f78fac509e6c363b0b9a3a726322d83a7c3a1c255a895eb25f679e27a1eaca2f48fad82b896a2a4d66dc34ff9ab60ead96362f70a7ea0adcf4df680c84669a750ee2dec053b26d45d6219896b0517a5c48cfa1943a3556774e461b5ee1fb40cee2217ed8e0b5c564d617a24087c9e35d2ce12667fddfadf981f02b22a9d75dc83dc29442706b62db8251335a0bf6ef283a3cde204e1051e21c91c7a83a4991dacecc0d55ea4443da22d730b3f8630434ff59b08ecb1b6f976b3a491ca6f63f4df80cae39378b406d3031d8d912db939732023524c4f7d5b779c09689a5cb8c24944fd37dbc533d278a988eafc6326ee7da25b1ee107200e19f5a3a23b377534da647032f0e15607507ab74bfb7faa6bbaaf077935aee6dc3bb315b62853376572950f89288c8579f3fa61f297ce793b5d77d976bba04d3dbc81a66d13e1bb0ddbceda46df045fd2b4665420169db0ea4542b7ef1a55ad7e6bb36cdee26f25667853d8603250469ce693eb02977a231c12f503e15b8cbf496cb952437e6b47cbc76a39c26bdd0e6d00bfb88f8ca8f0e9a4bc102b803cce0e4c42849039701fd86693b63b4402d2e6df715092fbe395f02abe2f39c8fa60e93c0b084b9b9dabfa034585f382e095b49215572550e459faf8ca41477c80021be2f0ffba320509948db452a9f6534f46412b1d55241931a4f9e0d9135584c1c0e6b07908c1b66ec925b31e6d15ce398ed9dd5ba7c2cb1b6ac7476c4a47fcd95f648a56a4a25fb4185b3243cb9ac741f43495d66e1b168b6eff38ed1096d9e1afaeeafede92c1614649f6c470827139829a131c25099c2722f2510045b7782aad93464b04dd75f033ef4586c8dad97b15da97903b356e1c60384e37551793eec8584b18b610bac9cbf9e330441377ae0638ca433803f25c9658061329075e870ae12487ea2ef8089158433bb326020de5f06795f0522ca781c120d9579423691e5937396a6860d841a32ec1b7bb358458ba46f9e86394c2db142d5bc01595b6df9cd15693b7615d8822ab6608e735db03e7ecb9beca6f0fade5a428fc48d3d712945fa56c90112eaadac6b957f4855eb3e28131a44065ca9cfb985d43fd8a8f111efe5200c41ee55bf5fd4d1669f863182290bec945b67944e7c2db12d84024dacc6bce902e802a8bebfc4c851bd546d818f127cea2dac6dd576c975e7337a06a1d5a370b16de031e4a7ebf12d8235f367118dd07fd133e0ae11255e76a3af9b95174df44df19b4341ba5527b4f7c1db76b7d95709b3eb8de6393220640e0d5f9ffb9b4b090c4a4eee54dabf339c7f11a41e3173029e4c43e8a12549c94b5930d24827a7e4deff5d58187a2999f0afec568e8c124858e8f339cceb3a5408e9778842030eeb64293a6d068ef05acacdadb253ecc1c6bbefecb5afea5352041eec8c6465d6d12dfee7a29328b569f5f5199d485e18934b27027100f6b2800cce9591a7e9bfb9be0574c21559ee45cff27b696be5763b1e759ee9306510eee2875d40df482c64a315e8915e93dd7045e58dad1a3a07651f20f4200460501f8eb9522cbe30af6b80f7b4b5691a653061fd8506759e5254bdda21679017863c8fe14429109889c2974fc3ddf74fd0272400128b9e14bf6f02c1b1ff9bf3cbc632f4d65b30479b165a17ed67c19db1d85dc67974d48328380d661ac8565be4d8ebc9a294aae9c6aa67e3a50bb31af3bc081a17b3e80883a60c834fc2bda2a01bf81211385d31f4cd15352768de7ada2ef7c93cf706ec0d620d20cdaf109171ab3be7b14d4b933ea891a3fa9bab827637ea41e7e65d2a4b47867fe8f52eb39333ef70518d66d2aa2ca620f3f3ea8f92cfe246e946181528148cd7ea5e84728d4a377e4703b851fb8384a939ea9b5b559e9c085533ba82dc2d5b450747a0c69ab07672458ab799fe4142d1362e04265141970f192c63b5546a5949498e22ffdeda1db1ba8cc297b4309ecf253d5a12c4a80e831cceda47837cd54554d203637b9b2d8725a13cb6277c9d9a0af91fe79d9aabc0afcabd8a6364ad6e7cf2303ae5b4458e6baace7489e0ca7da2e29488bbd8468dd190848107a8ac00f9ba0ebd6e27a3c1d070cc3db0192d3320531a17b438222865ebb977b64a6f92677694e6dd8917367bb225c228f5e26306b5e2527839a9d4dca36e399fb75e2b12dd43675cfb6fecfba9261adb2131e7a1c551e652e87901374137ff025bec68f822b3908097177a7594ea7085b4d875dab9e81c60ee691dc3b95ab3f38f7f1039ab6e7afd2262ef9ed9c54ef5ba6b38b309538e80ce5123e7a62575cb81e9dd36310c0f11255dc84cb3c7830c2f32f8fd773c010c488f9662cb97c902916863afebeb23c885ebe295ee80856e459b6957f6468369ac0a1f0d16b348424a69960b3b4691142bae4036827c67959b5a52c71c253968c455c1ebd69a002881490444f00834e9b7808b46599d32c5c04776ae72ad016a1b98cdb76f62b58481e9f3966784a39b752ba32a97408d3c0949c8c0be6545b08f83fb20fe6a5c3a527964c0deac0e4a940c3d56950cf6fa092662e50b4337a96a5404cbc37f892646766fc25d7e710a598453fd416f42ac5f8c58cea1c99e932b7f9beddfe814dc9a7952fa5533dcecb328bd9d55f91ec764422ba0de939836cae6a63a2249ff73d4308cf3d76cafd1c2b6250b04cf5a3dd1d9464621f94602cf230665a30f529ffb0c9d767cc570b58242b5316093afc394c4e0918b99dfb0df1e9299103711d05cb9b1463dd9bd627031e82c214e2bd3009a24f8d91b5cfaf917d94bbe5ba583f387f987f772e47646fd436fedb08c161a97c25194181b53528775f7a44f3ae11a99cf6848258ef3291540f6e233659510f23bf4c925ff96933abfec1e5413a903d0b676615f6de9216da1c8edc132d0a8d2f34d1bbf14cf9dc4e5b8bdc2796209c8cfee500a5c468037ead4563c912f8bd9f75ea6d8d5dfc72c6c1a56f695342fc660e9aca35ebdeedda002fd09c023097e09adc71c0c66a071a400576f7f27b43271e5257cbce07455aa24c6f2eb0e5cb53b0529d4a890c5071e7ddfc3a72fcf3729d11ce84526154c3f294cb62a353d9a3a725b6f7e7c5e3e4f059ff6c4fb7e3f6f76ae5b38a98adae775f14b4e330bd0cfc31c016351c7ab2f95607bdd4db8f77ea482aef6599fff84b5df613a7f778a396eab7f8a6efea7623cb981d7415b0f29df98c57bccda4d20bafb114b5071b177608fd5b9bc1388ac39c486b37edc39511bded3d2744e555864d2a283c5ceec6dfff6f0d3b5375a6dc1c7eee39801c6feff2103d281a859f6c693e93d7ef5e6658a4b7589ab828c788c39a4fd886401d5fe7b47df11c65620c036ba7ea5401e546f24ddfc19d619d4a300d7b377c8d0b27d18db914ff259651cd2efdcd6cfe0ef49243e4a0a77086978a55e807c513c85d43e088208bd62c3ae0705fcc55039c5a5717322ba0a1a5275a964d172176ee6853c2b33519b2482d1c44554c2879c8d2ffb4f0134de3ef398c9723375f09b45616f268817481f2c100dc74d830723dc425c5a136cc5a8ad269be40146efe32016aadbdb039ee319df0c3c8b25df3c38cfa58e8d55e63c2735aff1b5ad0c4667a585c0425ade39a191d6e9471fe72e9df51042ab3f2b85e28e91d1409d18c934e82540019aad4afa27733f7ee61b3f3a4879ba5c7576f7c9154eea1a6d34cc2b8819b4c44561312283d42eb9ad076952c22861c7326ecef5efe33242611f4f35fe680ce768a719bb533db9d84af6c255c2dfcbda08e74d33eea6491ce737d5872b49cee48c3d90dbfb47d4aaaadec9add297a47bc83fd8551c758937d9e10e8fab358a22b496fbd0a24de59b50c229219ad3b77c40f40f716d8703478371b6f59c34396891b1342e7c42ca181012a162e8b33ddecaefe3526bb899b2f4e0817ede9e0baa7f37cdceea24f2bfcdb789c27ce536f18f2d643eeb6c9d3f88eadcb711cbc410ba47476f73a67b3ab37aa919daea2cdc1fab6347de72716acda9c6e2c9f8b09bba51766353ce40f6f9e35af0d4bb9aa4b79208d9607b227b5d182f3a710b5918038f760e70f9435fba62b68a3a7a972ca036dcbb00b3260598dab212d0bb6c769be87cd3f9e043655f8dee0b16d17cadc0f3e2641d24ab0a4f682d7716bfb35dde07073a10f404f6dac1d9fb3b1d49ac9f71f6a7d0006b1ff82046edbe5f0f8bd1ac81142f212f2d12159e177a4e0b64a2aab4bd96fd7bde9b6871c7c65fe78dc7c39bf009bc8e89aef4846473c36d5eb874acb580fe3a7fbf78956148afba75ade0026b2e581d1955c576bc469d065e2b1fdf853537d88ae182c26048930b1db27da778308dd76a9f0aa73901d564da492ee5ba8c0adf95499f5698bd2859b15d9e9c324eef1b98a679c52f88259b10c25adbe0deb55fa1bef2f0d0ef449c10c4027b135cdd702c89181d0f200ee9c7d715c8112747bd6829d4d124d61c0e5d3a7fb45fc6d57fa4ab6adfe98b2eb933e3f52981d06a488c54314c632540046d06a78f6482bed76628a1859145c32457623a63b0ae1d845e8bd67af9d86e71b703aa481b8329ba82f6b84ed3c0c3821d810caea8ed1bb7d6a5c63e9ba0c3a371b6a24d04f1bad0cbf0e78f815f9bdfaac7a70a38c297c0944a3420ae4d54ff82689aad4aae451a9a13863fe6026e251340dcb607ae6baf52784d9e37b6b3e0424afe5a0da1c9cf4e524d4b0247c54f3abfd8f46fcc35a7e7ae56f4a56751a7ba401fce4d4e107f47dbf84fb2f3944fba3b442287e1fa5c7ffc880b0e57b153d08eb2ee6c067f2551f87be573184c3ab94e5b99b297e7ef3a9d76bbcb501b34374f656f8c3e28fbb8aaebf64bc2d04da10aaccac9562896e52f687741df028b5dc3986dd130009aecfffa441e297261a5cd7ade2a14f042dfa8810388ef4db0c539d94899df0b11ffb1979cb3df9deac96bdb47223fa33e89b18b793ffc0ef8bd11ca1d0604fea4fb3871696d30dd65abfdec21893727812a34457cbda6ac668a2bd2ac1ae791e27c57857398b251b319b1c0478c96f469f415a2d8123eb89d452071b8d81ee032a95c717d57908167d4ca83675b189fa6672ff2c7159342e2d4f084848b64363123c265073eb7a37b6af0fb71b693dd87def0876b803b043b926d569bdd1f7715e02a6cf292d3cdaf528127e431b487ab140da1eba259fcdc96758385e4730c49140ab8053d0067bb44a1e2709676293af46c707849b4d0fbcddbd3a609e6b83c35598e6729856bb346f6b69360fa6951cdb6638a1e9906797ab66dfe7b1eb664f032b445574176b3e10da58dfe065cdfe2b6dd09914ab1489b07d58039e8e66f6561d5ba52648b8cd10323bedadff5a37cc26c606ba26bd6f676dd2d0f7e01cb98fd15b1901bfdec7db3a7df2b853393bfeabba78ec30e8e0d93db9ccddd196412025b4f0100b6079c56417741103b055153705df663ec3d04065439fedfdc6aed067d8e3831e57cd1a57eb4ea48074576d50ce83a0d30890173f25dfc69888df4979bda83c5cfd6f483d9a675d9beaddccae51c2f145c18d54f17a054ba9cfbb91947856d35e278ccde4f93fd3489797899c98069e47a4fff05e9321cb99f07e7014ad6eccdc370f43c820fdbe24359005bf1ad63f31588c7a185bc2e769b9918c57e7fec8496482ff5028b1774199d9fcbec50a823fd60690f9314bf5a4c35c19acb5654800d8bd2449d3f859d188d152dfb300886b43f98c30bc022a6b33e555b72568861c5f5f9d35bfde20ad1a4e80efd920f8de038f6c01909e5b6384f24bcff3e2f077db5de853294c57a57c007ff56e9924e0b0831002f927071e8b4fec5284d4bc38ad45fc282f73676b2a91f5ba27c2a2e69512956836cf3d954f0312b579062d26ba90d7ca7b5918d1a6d00a9fd4bd0e3b53da92e56efe6e53bb2f9fa266cb5848bd74a7a0196b6aa8ec61eb29f244c84690a4bab772a6eb1801639d4656d3112ea620035dd370a0ac78f08c385f36941050be55b05d644793b0b512f627333f9df4f78c069af3d6831e9d56ae8e2da43823114a49e45457fa8fbc7ff0f0efce36eaed94852d1139a1f97f548d2530751dce45871eb1df380db19cc80534c7d0dafd60053a78c36c1c7256f474fbc987cac2d8149233c70b2df5679cf64e893efb1eb4d1d60a41c124428a338beb78989c37a88e87da61e0ac4c2303ce58191c2aacf355017d241cb0c46ba93ee7cb7436056a5f1e47997a8a24a34f9473d83bc235a66de9d2451327585cff4c90d897c02372f8475f9d214a240691622017edf76e334d4ec897d23e145acd8489eb628efa5c09146ccc41379d940d270f6c848fb70dc3f3eaae801411a8835a5d10c4446fcaf546f456114acfc97c9e2cd1341256ed58736d8b3aa688493fd269c9714adb2268fc71f82ba5c87e2a1418bc01365097ed7f169a65b33ae050e1a261fe3db5f4036dd778ca229277a47c2800b1302bc5c4600b9ed42c95d44b51c7cede250d742426e9ef0f745cc4aa890986795ab878d899342bfacf88de8799133743eb33fb0658d730eb561d1c70fdc044fdaa8ffcf3570adc59212e3f313c522905bb7be3cab3834e5adfc4654ff322d68572e5fb59106051cb711dae1482427e7811520e94572c0db423a507350e3dae6390366168979c126d0770c628cfe71f8432736349e2ba559647744425b81c7bef1252aeca0ea9858cb70d1710829b764ce65a0485a9cad4866a304649f423270e591a4dcd6bd9aeac801dc4cb9edc9d56b26fb5c9b72fd6d71669028c1432bdb8a301f232527a4ccb0732183b3153e2290a89ab05e3deacd9fb8ef4b4d80f6a641a9074fdabfd6265e88776e16d3d0e0a716f5bce69aaf2be7a94186a52997b9efc5b8459b99fbcff311839067aaab09f3e9b6f955e842ca1c891c86373ccfed5dd9a2ee831facbd90ae6e6da056c84e6d8e531b46784c637f74ced6a647dfb0432ddd03945e3a72fd468531db568905423841251e9266f34de438622627c1391b5d8692f6b0dd345292ded2d7ea392e52b139b51cc9e7e07f01207536a0b72cbd48","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
