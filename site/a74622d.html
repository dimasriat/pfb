<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ec632962a76d5758d44a85957fb29b45ac514adfd398d7c2e2762f706d13cda610284ee7de99730f6199a518aaf6f6d99cc1a740db548b2480c9bf021054246cfc99b1da069ec987672f85bf608a8bf8d4cdb387071f20a03d0da76ac30477a964d773466e23d8367fc92e1e388086a4ea2d403d361e970000d36e3ae0ed163a5ea9c57123d70583553632d5f485eb7e3e9969837c8e92430e7fb9921da0258fe4cbec383a59b14bbd700b641f244f75025750886dc57de39cfe9650d3295c67991ceb605979525c359068030d17489a954c9d5a9eb8771c3b5047a19ef40ce76c761d731993fe1aaa4d311586ea78b162cc4f3492c1b694bee893c2cc774bc626d99e0404bc1fcbaa00d3aae03b1b983d4df6908b4800dc63feb5b58b47da30fc5d6dcff68e49cd4e4dbf4b56987091c97d5ccb9c26359ce44a99e906645a9737e4cb6b52db161465ffa87b22ef76c59913064daf2501ac0dc663637add712198a905ef22c8eeea56ad07b78af46dd247107dd339745546615d23a9ff65917b94eb1f0c8b406b45d4c8c3955732c208c595559307844cf2e5ba85292bbd1c8aa08caab72898ca913fe9723fe4296b71fa4cd14edcf3efe9ef82ee995561554fc1f30ae379fdcf742c58692f6b057e2c0b5f29c41f68f51108d13515aff77f78b653505bc961c48fcf30a192666872903b65a5fbb13d33f4248b1aadb3b6164303d5033aefdfc02200717267cc3776da223dc50fcaf1ddc64e98a05fee904b261d6201bb42aa74c328ecec2984fa5d0e67c030606d8c4d23e78ecdccdf6d9d5a31dc443012d433d595e90b29cfc3df9d2daa735ab6127311e8aa3a2b68cbcc11d78722e8ec34ce3d3f1d71b481427aadcbb4309462c515b224f2259d842934057819ab15320eb11bb03d9987588262fee3d8fa78c2c69fd44d50bc0b27a86e63e645862572bb0b7c845a5092941bb26da8de63ff71b3d75780ecb5501d0b190b074344f9d06fcdc7419ce97203ff3e954eab230ea03b680c0cd4f0391214fa77f38cc780199112e080b535d763e5daa90d03e9b1f42e8d89ea793245a51989d27306e4f16017b06a2e1d2769816783c5b95d7e10053e2b9c06ef627200c7b0ea3db9734bcf1f4d2576fd0650e1b0bc2e6b12438527bf36da92031e967859bbfa6ff9dafb4f18a50116035d7cc5a13f3786194ed76cf1e91e3ea64854ba4be17e5a0d73f196f1d27caad657202c8e007437a1f4adb4baedccb2403b1286be6457931ab9adfdff0969b0569a5b7caf77200c0c78ba054bf402b85c69f9dc175fbb66e956826f6aad14130377d572faefbad7b16ace78d0ab68ee42ba2c1a03de40d98fd0d2a0f795bc1458dbea272067735a760b27d86daf7a7db73e12aed91a8fc80b47444d185b5bde917a76ec5c67f758a5078d7af7cd34c554069d899c6c883c2b48312630e6eb026fe52471f4de2d082bb0b2fec671bbc7d4867ba31adda7da71cff048180211b339d6e3ef1520be4658ba2e14d96953e59a3bf4672d6e45fc4a686684cfa73151430a3b757d413bb751926e35f124e6970822311c17277e19112f2341b4509395a18b1fd9d3b01f90fe34e4fd932bded185154bc5e7d1e8291cef5cb850e1f4056bdffce87b714914e72e183aac11998d64b376b214dbe3e98309409dbf218f8f2a339c5c5235811cf48a32f2f231068e065784f295ea7fbfe15095a5d399f6e3ec1b106e5ae57850fb2f7b4f5a51df78454ce2efd28b88ab627f7be54e84c7a46f89b80e496b511663fd851f86a4d4ec22ed35b8e970e1bc3b8609655d281a87df5f3b50308639c9a1d1343927f012f2424c32eb0181da14a6e3873a97e0b31f1e9313140714aa5099e838002cfcb33fb9af9401f5ad6a707151483fc99a7b3dada268f30cd5aecd0fee70fb288dfaa7ef3f22c861d3e24c48fb8d663e0067ea37166b9d99acb749c41a13ebd0e9904eac80623b14e12c6a1fb941ac45a84248fe36bc4552c36f0806757230cf52afeccd884ee284b7afffe872fc4739eeb8fe359863b16e81412702fc8018d33377d53e7d2105d77e1a42358eb373b4b345004c8e711a74da2ed87abb9af4527a3d43d59c0eac02ea6a6ea2b444f2b134c25ca13d7bf45c39b179d75d1a10caec13aebe1b6daf1497a5c1a092d1bd336594d2d26bc18f7b64791626a3ae43ab63b1544f026460e852479a5954ad12b7a55b1b8b9ccdc181b1513bb9fa868f2ed226ae001b75b791db57d5c25a81bdbef7e3e3c1f93752c2f765cedd10f072cc698e2fdace51430b65fc89cfb7460682b1a31d4eebf4995daecad0b116ae92d9770548cae59a498112fda6bb027a29acdd204897dceaf15afac6632f30bcfcbba8a08388329ca354cdadf0d2e3dc07fd08295b3781727f69f71c024abc00bf4f9088981bcbcaa88765670da4b77804bd88d87c8dfa87246ac1e902fbe7bc580e443058f72104997fc020a5834b899306c57f65c1fa3e94ced2bc490b073f74bba52260b95bba0409ea2727fcfbdc5bc9a96f4e3dfec890163887690aaa57b87e7474077b3047a7256a76fcf6daf4b179e61ab0360646fe7212b02a84f11c44d1844762592734fdbe414af51ce36469b06adb11280f512f63e96685f368bf1ed6c84613fe03edcac8aa77bfa188ef9071cd4f4344961b0635b6fbbf86092e7a077cd423b8d3e3a15cc758779c9780e39eeca7b768efe2f05da4365bdbf3c79773dd28ce85ea51aa6661e41931c332ba21ab0ef41f835a1431b6a091d119127ac5dc2c3df95ade56f3fc553c0eaeb7149048356e2960f61eecfdc5f71594ecff6a70bf75f2d2b8b67bb659c9a5a535af6bd74486a59eb82c418946d78c4b290567fc485ad3ac87cd05a71f73b4ec5c1f90ea8618dcb56bddec33c701522ccb67e32b5f9954f35db45ee2493a3eb408e5a6c9be5a92072aff85d2701988201650866822418fdaa7890422eb6ca354dfc7d203f4cd8782541c0a28702ff6058816d90775593e678a0057b57a6c96748f3b57c6157e94213ce83e6e87d97ebc73538eda6b15bbb685cd83db5121e43d6514ab1b8b43ff71b4fa5eb7090284fb7d8b3334cb4f3ed1fc8fc4e904eabb989892d37c7e02ca75b566b40a67f7c76e5b97cebd3d94c366ac2d1e45984765b91d64e9a5886affacb96b4193ccbb88c4322cefcf15841c499f598b827add7d0a7ac047e47f21d30efa8b3276830799adedc7f4760768756343e292cd213dd8c042df8a907bc2829f2be7d1bd365e300ff1fdd438f0efc9af137f53f133fca0e83612fde73016e9145418519a8f7c0f37361844cb6b157cda3a31c9edcc15313c0c0920daf41588458662da825012970d9901f6b2e5a2753287439adc7b6203ce671af0e2473d7a793fe9c409c0e7853b883ea6e172c099b29f0cc6b0939925b0813d95b1ab4f14b0c808cea5d94729d1d3f1171d3cfba728e532c8ba8fa5dda71cb6349a7f4815b6918f152b16dd12c7e5dea12f9b13bdce8d2977a51f9bb40550a8ccfc697045443d720322cab3f45c2fa8f2d78105316ba70831383d0957b89ad0c5b066e6f740b021a563833e6564bc788d0b5a000dbe3496ab126966b5bf2944fc8ca644010d17ea596a7a10ec35e610a55f97fa5b688fcbfb20ec0f9171488c61bb6cf3a17c658ee3ba29bb256923c72cee9d9f7e135ae6d739df4aafc881cd1844e712a4745c42b0171f6c775fa24eb333ec2e4e210e96f66b2ddb395568ff2fbf89ddf70d4d36d15c1e9d2890d12e789e74046cdc2dc1140fb3afa6ad8f82cf3a07a2d2329d346ccf3374aba06800a0644ebeb6b409c9b4d37c7312e0bc6ab414304ecac710f7a53922e8c717333ce8399cdac2fec86814f92e6789980fd1a1419c533092771f272b4d0833ffb4951ff2a4f76d34c0b67a50c6bd61b37e81dff002cf42fce134918f8f26b485251e7621b5b161cd3b8ebd6123a51bbccafa534a2ac30be2b764359f94d58f175fe30cd5108239c9838cdb146a6246cff98a304ccbfabbb0324930873cfb840653dde3509a4a6be4a5e18449c89bbd1dcebacb338c2fc5fd3a1805deab3b543f0dc1efb0b75a2cd98f534b80cd18580ffb84dbe4cf50c6f1157c1c401d4c34eb3ff71a9d56a07e3dda1ae8a01a044e82f7a362aaab4c31c24eb8a97530000f9b943ad6fbb45d619329c9ae8fcd833c451730acb67b6682464bc4a5c8c3a3a89fe2d6d64aae4931855db52c0bf9eca1144c4d8e775dc68cb780b13bb97fad348425c0889adf907976b767e0f40aa8b41ab71e4124b863fae0c387e073b753f66209cc08a88d58d7b9342efdaf4dfe5df56ded265441d666e4500384393cec4b64e2d648a09fa994fc60171d73675da90335787af5734990dadb503869ed3c33e631bc7d30edb59d71c1ff20799008a5d3fef86b98294623110dbd8d70db5b518c92cf2618133b6271b31bb462b63810c094f8b2eb2c81ab0144ce50019d04aff89e2354952c43718cc3e8180fc3bef2449967cb18d63b7548ffd9cc15d5ee290b24741b9ce086490a6321e66421762dbc121a6e83a0bc43c1eb6cf196ce97e548edc16d68a3ee21549e76c40df54f37523e800169d0127d382af81380392ee849cd58e88537f7b1a10bdb7ab246e204e305d4552a64138fb451fdecc06aeb4af924afb3711155bf4fb6a270e8ebc8a6c1ae5fd8ee459c143bf7862e94309cea131fa5b4e11c877b49b65aa793ea3edf07bee0a33b58c4c8d90c39abfc49a3b2f9d244c704737b8b32febe0cd0fabb3c4c8ff94a65ee6aaf0370193508c15de52c3ec4378b28614b293cab648adbe458f7d0e98e2e170be3ef0873314808f6e48d9eedf2b735d1dbf39b531a3efd8d3bdbb8bc962242d724a526236e0513e5425fc05720d916c5ca98fd281baf9293c0c8777bc834373b1725c59d0c13daedd71e4e16e304e9311177d93cec587d53503519f0fc805a0f87e4b785a5222b12ca87cbb7ce10fb1c3a802f5813735da340aed1fd930c2f95517c369d27cd88feb744ef7f119857b433cb27dc85ff2fa847e5b727147a9771d058314ea81c69d0fbb4d374f31a070d07be9d8103a9b36f2a20acac7146f17873e3986f656916d2c75cedee08420a01ada951002cdbb3e28d4b78ba71e8f847eb7e792960bb7d482c99474615ebfb0acf27e3d836397126a86c51c182310edd7f2d67956749502b91aec466afb05c3c0b1a69b645bc5e96a8cccc478e4ad365a60d53b2d58a06ed6d3eeb55dd829537e2d9937899a3493163a7b1cef077dfb4d38790825d963d6231759d43f5ccde460075c5f67c298e7acc625b3bd24afb419ee5f49ce927ba354e6710f1d0e7e764ef974f885cb8a10c95c81d3db6948d502866820e7d1fc6c60aeb7f3512143155f11ea781996a9b423a595dd36e6caee352142b19609650f53926942343eae04e1da51b1c1d090d6a77f2da9f8b9e5d474713ff348aa35ab7070f620aa2ac76feb8d0436a617d0ead171c29cf9e9157da7aa7b818e6d1cf2c9fc101fb7e5a6103c6243a00de29bd954037ff411bc7f1a57c89bc2586f5a696610678dbd0587bd8344728d33efbf0841dbab7e4fafb747531e767bf2cb2dc5de1e3b9203c52e76f3876f479a8ed4a8b34201518b5dd9dedc38dc571f513b607eef34a4b3b45e404d03844cadeeb286882d1f674d83730ad25e891172c869fe19f9eae6f4efcecccb5ac5bb1a32ba767eb3f1b758828b3e94b1db1f5f19dfcafe0d7a2d232d944459d248556d9145f24b76f3a8ed1e8051993e5e71754319980a51515f8abf95711eb9bd50cfda6867c55e166ee2c7d39f2acead6e80aea873de4eeb52c3c36ccb4a6d5056cefd7052c4eeac138ebd55e113e62c9ec489400baa7ef330e360121f0a43f6f5830df43c652b551cd23c199105a4f1a5aff0c1709c5c435367ecec6e930637a2503d1998081c37e9645762fe09c2aa213f8f29963aad30905dd4875471531fd4812ff8c08d7beb04ee09140b8332d68716a0625cffe131079f36a5de1057dfa9094414c660f10ff2a73433bd9e2fde48bc7fc6d125a681222857db83bc59bfb4a5ef81d7c41aac44658c0fddc940b48d44f8e24146440e96555e302269867cccdc99fbae4cae282ef20cb602389bc00ac6209d7261719f9a05f84378f47852de84474b4381f30c401a4f5ffef50bdc68dabd1d45a947f294daf188d658c40c082f5ae74110d2ec5d2db4e9dfbc8e094daedb66df12ec497d2f64bd118d2ed2441bcafd541765afd6583ee426c0309b6d72cb8c8a433bb3127356c0826f05d33934b7c37c10de8f8f0e9798bde44814e8f60598448970b54dd8d0f9729abb0a373f7480b1b70e1ad6b2162e6a3609f8fa46740c4ad20a5c63aec60291f252f76e2fc1118d8afbffd8ed30adbcb5900e52bb57b16c596825c2d76bbac27be8f0abd5253e2df48a5a3a6cb15569e7d80b2783cd8ead82089dc747c057b277909eb4172868c8992401eb6fcc0f485be25e92f7f469e335d2d6de387f50a33ac6ee2140616112e623cd12659b317df7afe6bbd32179f5f0a35e1ebade131ded4d2e116bcacb2d3b101c810bed5daeca7a16458cc2fb0ea2b270b931e1ee5c7d79ddf6b4eec88a2b5c556213efc28aa45ad5eb4fef31d1a9465a836532e3b6ab950671131f27d66dd175dd2c820f788bf99578e9b376e8d1cae032373f7e485692673d5d6729b6e437b27a4ad992203fc728291bcb95a10baf77c341d8288754b7d55532b838103386f51a8a41c1270bc25cba84bc3505df010097f2e4f04da3d6a29e335462f42ad4c70ffa25697c9a66c86cf5ad5877a2ece34f67a77c93f9481ed07e48ce873d103c751ac49098ecec0818b646350c102f0490602912f1f368d70721c0d56f75f92a495f005848cfb25d7cf31d5a95c8f4dba483d619fe7bd03ee027351846464aea8b28d263017d649d862d31c67406071f7208e3cd81bfe84005c784802c4d4caefd37d8bc0d86666271bf399210149c25374ff634b1384cb43c3574447713bb3558b6950304c349a3c7e51d6dd0b426a22a050e9fe8665d112ae5dd21172dc256e1a93d2def63fa9c4c3024155346df114ca586eaf88e3e6e06aea2b9a5e74ad6f5e0ebc68248c82c412e0e58e0f3c1caeef089d0a30607dd4b949113a15811998fd8de2d19b536fd3672da246c6051c02a260082b5132a652053ebf0796d9c7e6d282644c8f8f51f4e83403a194627f50e6c109be4cae7c9c142b26c37294348a419118e49ea07469ff31dd34db1c63f5478ef88b5dec47b6a4d945ed6d1ee419e2d1ad2d25582cb2d6ebf97d9e9e46ffa473896a407e05d5b438c66ca52c58fdc6b0a597dfef3678c82212e42a7b5220410b95be19345ccd7094c6e0a69b7fc855aafe74ad855b061c018d8bbc67b50cb76ab199d79d639acd908686f936af65352e0e41040a45c4c21d58258b1b79b056966b0edec6894ad3cd8bdda8ff709deb3adc4169b61670555e6edd14e4f7c17387d3dd10301fd1b4fc23484d65c3fceae54247cce7828f30df4d6958e01ae82e1c189d164ff11670d4be2946963df16264b531d930a1ac0173780374d4ee1732ab253685ad2196926d0b591df21f2322a7d5f06f6a82976fc08a59bc204b891b3f22e32096b01382dddecd75943fc4882348ef61a5a82d6bee61bafb8141d610800e5ed8fe541913b4bd23765857d163c46d76c836b870c29fbe9dfb7f8d065f0fbe27dad844de24259aaab4e43327aff4476a8d83f71127fbd4ed9627760b9f14ea38c994aa395f152e56bc36c9c38c159d35c6c91126b3c7070f244907199ab369646a1678ba16f00331976f726965845ec660d5a1fe2a54126505f00239d0767b3604b33e0f6190139ec6d2ec937f31a026936f7abfae4b1c2fc4d8d6110908b955596fce85ca65a4a309d33f57b31fccfd699b0f750a3f3cdbdceb83e9228793095a54bf419dcfc71941b0b2aa0bc8e8c96b9107d8a25744ada40b7405a005fced94db446e3943c2ea8a3cdd41673d901f7c75e18b511aacbf857bdd5772dbc0a3401e2502438123a9f89914f0b6f9173bcca69a62331902c8cdedf47c6739a3ee98012054cabecae7cb319762b0152220b500987db011a7bd09b0090bd93ac6d556dcedf429c83dd19e29ca22d71230abb8fca55f8cc0ff78f65e5fdf68f5b732958bdc5faa57195052c15a7c56f12ac9b5b6801d83471de31963f8a72df6fb83f4ec8d6881f6784954e56ae6ac5f7beaecbd95c2adb394f52995cde08485e41f9faa4ea6ff9584336138ee17791b8d5048931c91582ff082d979db99a1950e681d85de87e722cee50d235559cb1b8a6377f29c070907981c449d48f10b6e0f66ca14a8d55555c9f947734ce8b4b596e6313320456467d46f11b66ba260c2ab7890e1d3d22c41c3ee9a2e1201c45f064330341567544760709ab78766eb7b4b10ccf6378fcf3eb317a606d43e0a8300d1918b84bfdf03e96d300484cc942c9c7a4ff6f67993b0997d215384793ccd50bed12f8b013638384a237fd1d47a9085e166c5e9c20ff2e7e2818c5bd6311a1d5f32c066a3870481e5dacf92059fe7e5ac9161ad99f143dc32fecc5a21ebb9c155bd7006d157c0d1d962e566ef8da7196c7bdf7e7bfd74382fc5b8ee20db5eb4cb10964f8021e115b672c61bd910902c774960cf384642fa621e3cd39a4df600782371626d742ceac84dd0f99ed872873ea400e59576bac34b22643f725c7d3c3a5272d550125ff286217eecb92d75fa351db5b64a2af4d09c828debd89f92923b10e3f7f268524e159808544c6f10dc716046d05f7600eb46c5fb344f178250b7afdfd50bf746063996711acb678fd86b4860d93c394c22be0934db31911b3e473bb4e6e2a7a5a05fdc7d83c2c6379925a46b8187f288867ff3f9ca9df9af09571275fc5164c2fe4c1ab5fc6420c0ef1c49e300d0fb76c7f304a2b390fb3bcae8186b3f04254b45138fff93af196d283d57b2a3a97a9a695938137af5f614f5c90b885c99f6d8a9a906638466a4e70d002562925550b4531ae25ca093ad24eee86193c4a0b43268210eef40696f392e6aa366c2c6544f876f8bb9a0e7c510b9e7063a49c450fccf6ba2dc6cb5cd9b8fd6fcf188a9dc894cfd651f99af972c23ed081468abd04d4ff928270edc35ed27aadaabd3c2846da819a79c5751f908e9aba90a61271edebf0fe9644ec41610d6d2f36c3087fb3e854826ab1b24306e9c2bb41fc35a5fca64d96416d186cdfac326d80587323e354a4f31edbd8ed48e185300a9886d1f6b1ad99f3d269ff38536e22e4ed950169bbd6e65587e0752387e2214e81d287421f084f4dad97add279a77d9fe68141e135771e2c4c7368b1e1754e5cb9c919d643f4da61fcb6165dea8bf6c841bb408ac4dcb3fc903b36d64843011c08fa9175365a0d96694ddc9312767aed8c666a019ddc1f11956c1d95574d5938865a843b4b36e41fa1c630be9c4388c3b215222872f46c16a099e82f2ec7d4c12692fc37ebca2c5c5d81368fefe6db9544d1236272e7a8a5a6b506826904818a959ccd1f426b89946a4affe5cee93c1e17e20382a4f2f35d32083c8df5ab86d95e96551fde0954d3aa1a6a7c8efbec38acc763a7e7a63d6363e79483568475a92c42d06b376302214025ad9614835ac1f45f03f2173131abecb29f5beead6e69c6d025d5a1c610eb5e2bb59ce75bb2209aaf91a7259f4474da77f7c33292e248df86dcf225f046b227d0dcf93495c6bb7b2317058200e6aafbc9a144509b2a0404a4e1d1e6cd09d92e95501df310b0af45063cc786fe04a93d92dbaf9784680a5037dabd6ff40b24c024a366663a81bf5960ec73b63028ec95f6ccf53f4c22eacb7dbf457a428f3389fcb91d5e1c01a3500b2fd8edc6a900cbca0bd274880e3519522e68beea3c49d432bb4629d614287a81900153debf0a61ee0806035331a21734b4596867a8de29ab6bfe1dd532c165420b460408c5151ff5484605e4782921e44faa78df4268b94d0be034cfb5b714e2f6ae3da2a9228ce61befb0695477e9c1e77d1d2253d97e4d6fe4820bd952c646dc64c0691ed53069c52420dfaad62a5fcc2307f17e22f81c75a26115f67770998d66545174a712453bf62735a8fffa05a3de41ace17d64c45ac272e818b7d6e46a71eb6ace949da4ab51b488ffe3c9d77f117366db7937ddecc033b68a7489d37d611b740223731e3b60db8bc885bfde8cf1757694a98e0dad283192b2184d839c6b4b499432e4838773d3db6a7dd200075213b80d7d2ed4559c0bea1fdbbb2889ffdfd54511891f61c898cefe3a82f1be3f5d3100edbc0583ecea4b675af039bab8632894f64e87ba73ccb17103f18ec3ce6cf41aec45ce7ce51f043b6dbdc80553b8a4c6841d2e1974c9846ab4e08205e03582dd1b857174290a131f08101ed4be4c143abc6d35111446123316f99795075b39a3d39e6786cf4fb4c998745eedc7153d973d9fa71dab62d7c088b577a218beeb7db27ed7631eae2d8cc93f518906533489e106599e7b752332b6ba524530656ca1b6ce111c8dd3c536559f85e7c2623df935388b16e90347dbbec0f3e2ff074f5f799ae710183d4bd1a9d11aed8043fb7c583da2a119009d5088daba20283e5266374a8b3ae9978e392fe411dfe7294bbd46a5f0e5530b893ea878c2eac688232f53c03fc984e843117bdc2bcdfde46c26f886b84d612a13bf8023049896f1f943d7386893efb4c3b5c4b6df943f15fe955f188147d6e8989ffd3852ff0f34c6ef139850d912c0b52ee2e3db4ed1d9e62d486ba7f5e4379512d1e059d4d444689a7d5d4a5f8cc8069d3248baa58189393470b67f64e1a38949828033232d1cc1f1eec349252cd7f7ec793751da3d3bdf01dc9a61c11d51da7cdaf5c068a4bafc755d1217338017c383fbc64f36e5e44779ac94a02e4e52fde56eeeb4279ec56cf973cf527eeec8129803dbb998135d5e44cf3da8d55f57fbcc33b10d1e41a741ada8447585bb41c9e6dc68f20d2b637bb940603d8ab99887a22c91cb7931930adee644d3fc29ce20495db741c7646d84c1777ae4c8e7883983b413fe323115a3a106dc7a2f83eb26430ca71f288ed4a45fd85a60014c032da10ba9ff5f7ef66511cb10ec25e3c0505e4c5a1d781c09144297bdc97320644b235acaba0ba62217607f2036b037b3ca75cd3f70c298920b0de02b92e9eeb6a47fc86efd7034398a2ef9aa947a390facacf8cfb85729cbc532c3f8ea748190ab960db266e88629b1934d4e4e0757b7c44a03619ead4fff40c6eddd53d36596d40026c221918d52875731b2d23d8fdaef8f473ea64670315037763d18be254fbbe7eb98cada99623aa9d6c35d6e40417f6f358f963b4647e0b2c94a737e5ac8aec9df70bb6f32ba90de659697c6199c71f7dcf2b7ec52217552f3211eddfcae8f78ad83031b133846e8210297890224702fc127b51ab962d97c6583a307c3e30afc18553c9c1506fe2251617d25aed704ec2cf70f94ce7cdfed2f3cd48c70b19eecff73d0ee80a733585bf4cce679bc714521657ae5342bf7cf053cdffa0c99c73bf40719eb96b2a3516b8fccd1d965c13f04e615c8c33c9bfcc1096e0f06295a7ad4f948857943d421a8e529f0938665eaa6bafd8d2971129dbeb75c5a234e26ee9b12cbeb40ac96a91a93a38a011ad82a61635de06c04546bbd865bc48f34fa75880a58184d0baa48958663c948e06e0e7c949f3614c55d564f9ea4bdf6a76bed7c55d5ad204eea6efb3c641aab264028aae5850bca981fedc66cb068387602d1063719ac7bbefde7359838c0ecb4f17373ab6ce43298879fcb571f3c8b57c8305367f24a9014e0b0d57d204a371f6f1b4e32c83dd96cbef154492740e90a3e2cbdd8e62e79d12fddbc0690cfa8e22113f98ea0e80c017aafc3bf1ca7c1efdeed63a5c38cfa8a827f5336b792106841f48f298b726fef8395381c3c17246ce37fdfe8484ea30a7fd441db612c5be11617def9f8ce31a4b5bf1d014580e7fbe3f6ad490e65467e791571e64525209b368ff970d1c93d8bec0487542a3b71bae99b8c4a9d5d05af953f41d3291df546e80b57348688461dbaf6613b0acdf4833bc853a282d399056aca35664258d430643e58c004ff1bd17eb2ffc74d7f0aea4ee934dd3af3a6a126280cdc7273eff00793b943295a63b47c590f0d4428e8cfe55106d6defb196de775282cb7e9136de673309a8ee577d1bfc6d09fd2f045ea0311f7ac1ccbe1d48a86b3f4861d07c8e8fc1a7170703d7a18f7ee1ffebe18bd7a63394156cfe99fe963108db6e9fdc19a79819550a62851c1c737f34b15e8f03d17cbe8f4dbd4f9069ad1fc2da6701c03437267a262d00e7199f80f31aa4f7918fda695d51f89dcff9e2326f80b1997e6dfeb2cbb57a6225148eab97a230d3660f50fbecaa1608fdd95db288ba39112f62bc41aac25f93fbd08b4d0a1c194b70fd28e84992c9364491e60c1985784359da6741a67b57c63fe29ada0b7ba96bf997d5bd4f02e5ea3649b805e941f9ed38e8133d3f858e432e9f6ad1784ccf5c872016faab36b15c8a862d51d5606aabe78d787b32c57fd9684f2da7278d612a9f76623dc92e470716d580af1d77e6c6735ce8456acb98b92cd580f4beefba230c3c297045b0081873bd6f2f634a2c3d7b304b87201916d4e759583230f0ee3bd23a48972e99ed1eedd522d52252624f1c137d2aa04d1d640859ea96be5de63306f76bebc3a1012afa834f94654dbba93d04113a1ba08b97b24135a3e37fb78f2290589151006c046c4e80dc202bb6a136a8816179e055c306f14da201c630c78637e3f1ac50d1a2aa4764a7b05facc1fdf5c5a60107c5d6d8e6809f8dc052a84e3b58e8b951ef35926539decf556d77b3d01dbd54a74d751cc6f4c2a6971d17aee9960d4c460da0055a1aff4cc698737049be6eea51c21000fcd38a6da462718267a058fd59452fac58ba84ab04bdfa664bb60de9e61099a3df2de753c8cf7ff96300950f0ade15d2d898936cf05c99fe7a4d1182ca70de96d5b59f0b6a6b3692f5143a7b03b858788c0ce66703ccc96f170b08dd0298da2b2c79dfd6ea0fd64db47814f62a8367d5ace01f45cb86ed939e134e27a88e1ec76a18a0c44ebb9ba57ca5ac1688657065aa27bb9d5db32b879a600ac3df7e61e53ae5ee65db832e8b1ab51a217e8750a741557e5a02408b6b0e30a14a7494b7e04b7c62a1b6c104975cb35ad322065244bde096fe7867ab641e5e65b6cab4a17ebc6b6303e9da5ee3d97bd9b393e702753315b72b0aea7224e5f6bb08e7af48f205c2b40d98a01f89c1c73932983f78b47513f8e14e35a86364528d61f3361dca01a2d24ac75090d2ea196ec8c7c4e502b41af5c7da6f383bb3b1113c50fe84b470ac92947d034bcd3bf6e1c761918a2649396b91f2b2f12cff469da0139290b9f60db1d43efa189b37c91fd64611998bf05f5cff0e059fb1d58d2af748275e451f9220e0a04ec4a506fab7601d5bd5506445b0d36c80998858d1e27eee58649af4aa7a81e7e878565b8767eb82fe1923bead8f999e92e6728495c496a4c6218e161e6b0cc826a0867e604bbc26a587aced1887ec8bd27ccb531e4c05b900f0ed19d9f3dc4a4c2d0825d220ae3c0a376dddd2b298075c9d96c5a22c7285cdc1c08d68dd15067c47c57a2703943534f64eef2526885b0541eb7619424efe87f2fcdc61f5d0abcb141145b855914f7658f85c69d09d1cd6f926f19cdd659a373cee94735bb7fe343fa4d5b2f15dcbd63785fadb0665bab57b76d214e16c53ff07b8b54ef49d14ff581ebf060caae6b36191673d6dc5c38de1274426bb608789b9752766d2bb1b478e6ab5177a1f05b45bb2bd122399aeedbc9a777f6c9060bf837df90986bdf44fa55b91f0e20588a4c793af3ffdca07bdd102bab6675ede7421d41e6d4227cea03e9d62f621c6e514949a18db2a8bfb495cd7ea4de307f068f8a8acc56e2e069560b17116ad5ffff44dc9531d21475da051d2a588a9187c794f2091f990329a1bc4221d2ff90198b5fd9fe32e24fb47da168ff242488cdfb1f6b742c69f007094f2a6dcbcf1b279efa8f5194f0babc07e7982982682392a3bb7057172d789b602a362ad6a2ed1f2cc66339d6cbfcedaa4aa9b2823d2050ef853b6e038dacf55f187a50aa7524dbb55e53438f45e2c184a13535a92a024654cc55c9e216be41155aa25f8bc4cfd9e1edd7f63e047ab5ffa19ba6d43062b505b38171ce23ce41285180b2f51f322e627b0c23746f7880589fa5162e06952bad549e2506eb8fb01ad77e252f6620cd8915859ede166c6f66b66ec8bf2f2a2915c18beb6d58d5e5d4be829e46d4b5eeed2fcd07c92ccc238e9c803e67015e86b372af83f858b03169ad15f4239fe69b79c7a879bdbce4100ea1672bb05f6c651f0a7046f06dc7ce350fcb10765434a054e6f80fb22f45dfea4cf6d8c6d302f52a4ad8306ed5dd6dee73e04d6c4e613f3cf8a282cd4184c9706c84613cec52c0029e8191613b3c35c09550dd47602a4074a484776762d877b978b2da22f9ecb6bfe5bbf4fbcde83bac7a63e96f49ae1366fb78d57dc9305709ecf32c81b7c237f210ac354bf05a92016b0e6848b43b3d2945e7c4be544148567aabdbee6386d6c2015bcdec1e8887363a033d3b03828ae77ad83abcf5311aa0b9a63b56dea832116439a9a0bcef509260f43ef4627786885f211a08f452e6cca6f7b0e2598a56ad9f75bd0bba71c6cd1becca4be2a788f9639fc68367d7c1692e72b6bd82a2bd4b405f1b975c728ffc6101b56cdb9eb6ee93031af3d7b23dfcdc2a85960e6206395c2006d7f2ac45cfb1d3e353501cfd99ab5f6bd3178a2eb93429a9c65135586a7dd2db532cd335acc26628bb26a7c2fbfb6b42ea741451053f3e4d2c49ecd69e03492009c1a95ecb7ea45956424b58ac5200c42fce74e3d21f7fb620cbef4a640c1f805d401ece9f52274763db90313d29dd265fd4c88560102570537f6d68c85b60103607fe5a6f0653c8a7656340b530a72e8fda6817ff088c3f702b5ac0e6e08a0581ab3388750982a058b29515d5d2716c22eadee9bf7c25900a6a7271f9dcc7d212f1e8af2b51dd43c0b1ebd1f9b6db2a539387a0d11dd6f0430db5d2afd145a97e8ce3a7ed542fad335998cd47087745ffc84b5dda52a07bc8d3f94bf02f5f4bd047204ae112c8fa5cce8ca7280c417fe89fd87ae62fb12531ddaba1a17db984038237ac41d189d8efe72b4c68f256e51f7f7a108df47ddf0fe5c040ddcc80a9d1adfeb41d4745751928115e42075c9eb5c4e4b5b37b941b8e787fd9e1ba23b3e71a593332ef12a5c2227d68434909ddcb961a5b2beb7f354cfdf0045ed8fc265b23929aa7fae9969bf1877beb418425b7b91ecece601d935353df48ab025641bd27657ef1b0f3b471ededc5dedb5429fab68d5df58fff2010450ea16b3a482bc1324c14149ab6a9c7851b2025fdbe0e6cf16c76c8b26e2be9f1243a8ea2d9142df8671cae0df4aa4d5cedc252734402c247457f102661198421ea01ce12d5517934f989eebfc992a5c3fd359c13674f49677127d990ad5303ac7fd50883a3b6b29abcc0e91bb76c0a6b300b9a9bc32efa1b4d6ec321502f4f2cfb099465b57a1f33909aad0c1cea970cefed4eddabdaa2a2ab795f5149c91375ad075ff4c62a30d47da8f04d969888d57547b93a469023da57e42b4e5153720b11538dd2ed1f306529d7b44a22ae9bb80c4871fe00b8d45146528f2d70ede18e30261dd4e9852b737cb342b0150d476dbb03e596cc0d1a8e12206efd267db82a99ee5458672af0ab785f0d8c2338b6a3e733ebef4d5309fe54e74bea8ee99f4674fc9b010329bc4ddf21c8ca82268eb87ae493df5192828d0c493454e9b0eea0ee2428cfd29ec4bff29ece17cdd652f6568a326adeed00cb4626731cfa5b57f84acdf268eb25ba22f95d1e15963f71e82b49f831f0bf542d01f9934b742f7262824529d732fe3434d1be2ad3a69dc2ffdbd7d86bdc88194c7e684e61e37093fec77590bf3bdce7a74a238bd4ad15aed834d370c73b65ad5ec239fccf446e985de1e7a9a441fb8f23a574601f2844d1318b9eed6ec6ea504d8f9cae77220e80ef1ba89d140df8bb121aa2224ed4809462bb7fd5a19608dc671667a871e4b189cd06be4fe9197f6dc73cdf74a70a0f01afc4797f25cd8177405744fd788061a0d87f50baeb763d486ac443b1e6d619308592d7602ab1f283bce673cf86661faa3c942c41a42c1f75e03edab9f1ef01f77c7d439edbcee30eb73a80d5b43cc854f6764fca27b466eafe10361567f5aeca925e351a03a588bc49fc673fc9195c7b6c32f783b4ac8ecdfc63e9a02b601e5b1d5443fef4d7ba7b64dba8b06ff66cf4f0e970e7a35720d3532493f673ad07f63d5bf93bae460be67f7f2c9bf3fa0eb7294509473d0971f748ed20b92f189ff346413f16dd00fad557689c03fc3b03e8e088ee4388a6a5bb4c09f9b967af937f37dcea06a947a596225649a20d2b8e1fcd7b1833078ed9b998de573e0f1ba3c76958f1a240abc1fb9e64ee8e6d07c7100b04f38084c0694c1e08e1ebeb7fe75708c260becee04701504099239d1a72f232a55020d8470c74697e2fbb7bcafe5058daca1cce7086b8904e2b551eca788852cae7d82d55518310dbeab58a1ba3c864dadbb8d7f5cbe0be0b3d7e92c19838d258515276e85fe0b717d8f8af0956bd9f6db81e2e7789d8276f52a8217fcbb5292151406a404045b5dc654b3f22c2229627862fae9b8ed069bc192f17950bb221da6d59e2ad1418d9205b16a4e1b2e5bb4da0d74d1fd5e50428378ea9d7f7cf46fed48e87306342e740c1653c0b6bf8c4f08dd000059adac8d361e368e91f1c154049cbd41ee584bb7746cdfbf1b0a1adfbcec8b22e4c7ae26c2dddcd031f512b2976906203b320d2a0c0b4bec38b4cbabc59617f3ac52009285f6fb417adb0b23c7102828f502dddb9fc871593a09637021dc03ae5fad04f44ea8962a76d1b5185cc4c23804a520f0dbea8fe5fdb04abc06d4f4ebd9a11d684e2525655ceb8c3d91f8c6a99aaaf3e217d223608f138574287de8ec206452d07955afe32d8a85285d9138c03d77bad6d189091006119893a900b5aa8cc33efefd378d2b576a81f197d26131029cb4b3228ac536de9ff8d825cc04419668adb3f1a94d6abcc2304a358d6c178ad1a91d89fc2fbfb52c1218704632941e3ea5b89d2ff6227b7483a3c5da4ab5d00d3beb49a9f531d29c09871e98d7f85d33986a36e53ac167c3260194130c77464cbc886d78d146d5313316fbe0bbf96a0f8095f80f19ded3cf3779a61d0afab258a12da6832e0e8c88aa5114447a4fa98961011cd1265391172593255a1d249f0fdc1732cbaad387654ff169d9f7f78baff4551c6841fd51df47e23a3d795575e8538f880650aec409ee10de035b3de1082c3385761c0ce587ba8270b40d20e580298f90a371fdc220e8d8f5e5dc712915cb7d3cc6978a898d03818f150bddd9dea1300c5f3d22d74926fbdf1371e8e3f1d033fc116e1ab94e41d24337f218ae5d100ceb47b2b8c6e0ff5adb03d648f2c85b145cfa9aecebaa5ae7ff10c9fc58f1d2b6acf63a172017955780c28747299289e6181785546497603ec4cf03d4c4d4470e3e21dd1f1de7a6d3284ab5495254ac77452692fbdb4336edd890966eac9296fffd7d2128cf6d48cf3606baaeb127ab268d80639f5eea4dc98d65ae8d98fe893ebc958fa8e24c86819ddfda4d6882a799e806c483cf6d4007ad4afe5a0dece25cfbc751516347dba499bcf731d70d80dddb413f8d1fe8023c9dcf1f5287d7b639a41d669029495b38574b43ff7ddc98d43adaa0e36d1277840be4312b02511aaa16d4520ff857a6c7dcc42e1e631ffa441c11e635e28da8edfba57af2aff4bc1f19095713084bb28aa147ee4bfc4afa3131e187b363de3bb9bb7d71fc2b906da2aa04bc26c796454820be80a1a020194ad078def1651f7cc0a2bab00f6a47e0f2a9ae3c39b864ed9db516fc4475d5058514c10a90acc24e56051c3aa88c0df385be709fd8b48bc9b885d1e8ecf21ba3f723e250fe776cf3767441cff5131ccbdce43cb04948c82445d00b3140a89d75bf0fecb80e90b7f26abf1f030a38f3eb8c358a7cd1b4abd33fb945b7f54dd3e89ed06b7d64aeeb6b6670ad61f37488389451664a74a98cf81b17a32fc2b4c426aff0957849f5f7d84de62101824aaf8729d313a17f5ff01b8b860dcd26c80b9ea99a865db07f6b677fad047f91b91","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
