<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9d0c803f640b7c4931677ad7c5e1102b4e0e5666ec06819cc61088233b29237edbb004ec3612fe4f0a2464d158f0bc167f9187c00c4352d286ddc18b1f44cdccad28e5057d666c3ed92659876c05b1273e8421db4a02f5a82edb508e14fcb421a5bf89bb21dbac71783f6c2b4358ed2c8efce7bc5dc6ba38acc1758628aa26944a105bbbab2f34e1494cf1c8c370fd8fa27446abbb82f730f987c63e0e696fb91f3d2ee01489fb936e5a09b9114b8b6c711c0c7703ab96887a9279f58bb9893b3ece2bf15beaac80f8d8894c7d4ea58a92bf3f06f505539ab4ebbad1ba91f3e1ba910e6029a04fa58025e2c095f1f943e360372d81e60beb4e3e28cff234f1f153a1fc728a896e6736d4298edd74ffbc4b5f4ff43c90403ac338cf7b6886aa48a94f3b4f948ff0ad072aaf4be7318b57c2b340eda09f3a6cda60ce8d64104d307512bfb6dae761d567de2b18aa297a9859f7ec799f66c345044e8bf4aa4644fff12948b9bf3107402f156a7978661dc48cf4c972269d5b0d6767e0ec57f82636e81c579b6ba9e53484f9f09c330cb322c652514d9383fa08f1d8e79de25c1632e738e969b87f7d9685b796d99b0551504df4ae4340cabab907c873657c23daf5cf61908d1e2a9348fd68d0b79b47f549812d016f96930e645518939e501344b6d1e114da20af6c1f0456cbc08d38d8e42f400ae6cb959d953f3bba9e4137bb573c1c491fbe835856fc29313e8c60ed4fe4fbef4e724766962f4271c001c0688db23821a52e74675873cb4ae87503013f8ecd6688cbcd38d1d81caedaa7c644916c0039ccb0fb57c44c784871e89f28257bc89a9f7730463a75a390e91c28562f5cecebb6ab6c6922238f5f24ee62ceddaaa9e4515a7a3247bfdbe89ee9159bc70bd28f21d6742dd0c0f79c0b754339454601d9184b96f8fbfe9f163e6103baabc4add3b07c65a4245e11d4b990db86759908a305f0daf21a0a140fc8d5be047679f4aef96fff17f07d923ec1a89b93bb59a55c4fc9c60f8c6254b4b21834c7571bfef37c94dadb044034847adc60060e053004f6fdb0001c036aac0ae6430a44fa800710445eaefb1378b77c103b861b5b056aab7c24fd26cc06921e213d5bfd1b41ad4b02955dee2b507edb9ab0758cd6bdcf5b3ab69021295bc3a2350a15d7d762e833d3ae29cfcc211ae079bb3ce1b881d3f041aa24eab30c5686151148d97aee378babeb5c58ee53db5280c2574d74de1834d45376c4f807f46f1e1bb58d80ab9faf827765cfb89f2db551114825fdbd26f5e0792626da54c6d6e27ac942a480cc26510ed789acc5b0d90aad479d5ceb5a63a4b5ab94e84c157c7914f35d4e17db1b759b1fe42817a76730cc60ba5bcf64d2193e306f971731236bd288cf7e0c0efeb082f5ad9cb4708051aa9da1cd6222a0d702f46f8b49a7b385eda4f59bb7e49312a96345f52cafbc858b83ad219df083fd17b814cf61ca4e7693c090bb36701ad3037405c849795210567b62ba7e48b6d849ebdaaa1f6a449689b9fea13f45bebeb858f083a9836b10f2ae4bfc442b1541248b6f1255c866940be52ed759513452b2b9ddf066c42668a168b2610c284074444ea58341c31ef1fdac15f760ae8bced680f8750070bfe35d91be65bf53dc75024e76effaae78b7e00bdc7807894c1e6de821cb89511ebe4720d001e766ada7bd52aec6e302e88c1cf3a8fbcb847d18dc0efa1638e20d4f5d27e3ad860529e8c4f15fd261c0578de14a51f7203b1d08dc067a05ccb270aa38b2c0fd2fe5be2f132732ea4be2cfe355420b5270d7c0b3dce5b7f81570c38cd0222e18cc44e81017f4257662fd89eff687845e792d244fe09c22fe7d195754cba63bb94de31acfb764b6c049925175bdb688ae42c9f5b61eb96354e3f3119230a5455b94ea0311d34ba2c5e951d9bb9b764d3f08c399c210a1bf6e88611e9e6d140424dca6bb60c66de434a641da950d34863bd02b5b13433564156f3958076631b8716c11106d6bee59b06a58e1a2393d1d10a50b389b7ebc756eea77934d077e28d88949910d4326b1ee85fa2a538be4853005240256c332ecc4de132946180b3b0d817496ce31c22d0b172d4df95260233f71d6e4111595030b74a98bda297a5868aac297901acbc6511fd2aac79c8aeccd6623dd8d6ef555a9657a295bf814fd11a6c70fb110dc57b499a6defb7203261ae330343c1a892db5ace48f5fba925c229366a83020786038d838340382ed232f77054134d8a149e62cb34d166845996fe2959b7bc19d31e9bb071591c9cd449edd715dd5f98d7a966c0c9ab991d09a95e70aecd4d7edd2cbfe3c4605ffbfd0070f088cb80e83e95eb55fc14bfc3ca2beb30f5d17528dc4a402143507a4624c9b819a35f6869069e1d93f46744f3af4d650b8b8331793370b7f6a956471b18d5ad95aec352b5b92683ec98e19525dd8635d2e1adc46e54a90804d217848ac0a26a6b7594bc5ccf4cbe95a8230e44c480ead2ec892f77964fcfe829db6b4f6dfe2f8ee98e93db2aa840e6930e0fa73eb86e8c0fa8ec40ddec0a636091af3c220d06dae54c6e826bcba55628a609df49c5aac35a8eeef760564817927273b74fe74041dc4eac7a36829451368a9c33709c9510d12625e0a33fcdc8e1208cf86559a6539dc06298d7afa9473624b61710f0e7c90df388b1389d8133e3c3465071221906957a3c32ee3f84697b27c9f45d49d3bcbd10b0b202df43357dde3e900214a5147fd8f3bb4632f13f2a5020aee0aec368a3b9040b0d32956eb96550134c5c23fbc0d2fdea264af03afeba326257d216337af14af7b2ac285466cc33022879d29e1e46097087f10dc655842f4f719cb567593fced8fcf2656818f1868860967ade627b3aa7bedf39dc6a90c2a771e2562ebfd5c3388c0ff46875834297cdcf3a47470098fbf2dbdf0f8d4dda96773e971e2f20a42e325b0aed0bfd01f2bee28249e89524b10dc25d890e0a77dbdba045b82d89e0646a8f2334fc13aee20fef947bfc584ec302d1a49f1ddea63e348e4ed90534683a1bfe94debd1dd1c53792a9e1b995baa80fca682832855b3fd91f22a4d366d0cf95309aac9fdae1bbb77fbf5b8e7883bce519b58ea5957bf6d99cded821bd1d44ed61d65b19e9c6017ab23d60cd62d42e49a0c86cc5f2140cf4c7449402af06a5db9be4b5b68b1e7cfdf449642b8ed092960094ff1dc140b5115ec9a8702af58aa61137e3a1d8620e6cba114b024cb1e73c5287a427b31d7a48760084ecc06cc65acc365c686a28153aac4d56f5df027821c1327f25cd75d3b9ee326d71d89c557aa11dca62f2c1b251ce7fae2b8a410af712d204c5d162f5381bcdb8f3a7bb99debf97925658aa8bcfc1344d5f1dcdaee5d8ef6ad21acb92c6e07978fc89a1fe2bb8214a23b508e9c07c4e9010d1826f8a5ce3d34ed0915a0f0794c338043c239775f2f41920500a954daec99c92fe63ad456f5151f256c420972daf20a093ab0a2a165226599327d78cf800325dacae2f563a4cb7b3f62259b5962c95d7f4b9925607be3e9e793fc6c28db7918336a37dcbea46c9beafdd93de97a15c6b337a51d565a55b34920c25e6ded90a85d05b4fb1453bc6dd8ce08f3c86cd0e135a61713a7025060d9a2af8609f8295d97b7a31b96f00ba90f6abeb6ade8c0a15ef68f000edf108d7ef6fccd0e93f77243a86955c46c11413f55cb8bbe002195da8ace3821e8ec1ca7acbace0f06d74979eb9b2e1de96954e87cb2427de9150ff4e87e0ed173ed477be663b6347722e9923a24bc72b20b3d97e9133d351bfd8838dbc94f98103db273f6e53a56cede1d6f461a03524a81309dee8591cbc276675c6f8eec5b44e7a9622ccea70062312f3ca59401ab6d2cc29fcba0db8a5ab958b6fe62f0b9aedebaacbcc7edce29d6967ab12d93212976d31c8b91f20ba304618522dd6a479ac9b458ac0c24fcf21eba58416167574bd5fdbebd5e35d09579ac20e150077cd8e2618648db2305e5e1720090e765b624fbf697e9c1d9f3ac789f1cd7e8406a342b35a62e7952cdf6ae739fedc4924353bbd099362003c75cd85fb9156adfa88a91065a8366d86bc988d9ed5398f434f18d02e278d44235950800951f1dd84cfc7fa60948acf7de2bd11775b4ed710e8bbf0ab459d5c6ca85d9cb5e0d4f340f6c56fb3fb9e958993f89baaa261ee8f20e5534f304777bb60c43ab2d1e0c44570b64439fd52b0912a784a4f7b4f67e33b412075bd50ccf59e3ccea869b85387c58aef48d05f078916a24e606eaab375dd4f668a93111df60dba76b9cc8bb9492b0d0d81ee0e0514e6076143e3e92b9ca45353b75965c8efa77a6c152e1cc591bad3b348ffb95b8192ff2950bfc474f7330d97d56372aa9cc27886570d0ee668dbae6f203697cb8eaa9d91a44801b8b0c8ff2846cd52584481b175847e7111d3af47bc55a5344a3d7a42f41d10ef070d07dd2a2932ae29c05c799ac13ecbc532bb53a6561d1bccaf504138518f2f5a8da09155a614a5e065c2a769e9e61f30d5094c63da629d06b74679bb8a75cdf5bfaa6388809bc4a599567c424792c3ea758bf9e379105220bc7fea92d4d1353b3255bcb54a03abff7ed217dc6f1303fc076b36b8320837752b57fd5fac4e8890caf8752ff97c64d06b232c15fd06381328b6557a35b9a83fd799808d639f8aa5c24a9884ed6b7968ad48d362d3f610435f0856cd82216a2deb01e174ad722ba1c06546238447e2c7ec9376b75d85193f7813d644e03dfe38e86090828c4988b83d44a3206b7929cbfd4a441bc919befc46e1a7b3fc588dcacc42171ae4be7733d8ead51079ea28fbb588f93e66556d20adbc475def8b06b1718fe773dbd5557557d75ce5b4e49ead24065ea19adf40dbdffa70524932702aa7ac1ae51ec500ba1bef44db2df9a5654071f95c62f51d83d56f78bb6d2d2ebb6d601d68e680fe27dc7dcf7714bba9da49d01f9194e8ac756c320056e86be15744a4943a18a445845c1fd861ea71eb61b8f1868d80a6423915ffe459794354762efbaed6468b335d91ba63dfdc4d674602dd541d57fe7ca376b4948f88e1d9758c48d9505f64062bee859733936697e4db0a4134293399b6129e552deb8acba80691e3306e4e67b772a7e360d08bf079aa7ae49d3d2449d1dff94d72aa677e25a1a6baaaf417e81bbf6248f29b7ab06a862a9051d3f81a29fe1533f9d38f0624b92544b9253b62e45cedd04ca81263babf8cb79285e6d94fc0118449173d8779f78d4329235e532464e5a0ec9d8a26e0b7c792b721688d10b4e0b1bdb89ca0cc2da65c24323aa3d8075f7aaa2a32ca198c5bcfde04cdad999b3cb91149a4c682672a1883556a0e8c917fcf29ec9246d655dc7dc626474c7ddc25e7cbc249d5b12a25db80c8b1830c4db073ba66f08e2592dbbd37a41552721a6c635af716ec67bcde678da09a2887b42fa8b4cc9612f5cb49247a5f54f4b1d6b8b78c60adb66c52230f59026ce3e69f86d1a006b153e9d3ff67789588f6ab21940361deab335f13965367d1ba8a1e9c2fd8714ff42d71365218bca3fdf2e23e1ac96ab5d498dc63a2c95ba8df34dd1d601984c6a94c0ec46c49b311da49eeecd163298e48ed57ca72a88554254bd8fe983d3eba1b56227a7144cf8e04d8f85721fe6b795ae55ab77d8999cad013f6c80a6079d87807bc4622d99f276d20a137b8cfa12072a55acf456f4bafb1085db29b20de60a181e1e41acaae5dc04e53910dc2d789d647b5729ff2c05f1567c9bb48016ac45f0896c308859f8443f7b635ef6483631fc6835a1c6a30d4c6aeeb06e428b354af8c64c64b8ad748aca03188a8a4f7cc800c9370e9e952d2583f9c37a06e8f0e862bb43175e752e1622b987230014a6049a344b6fdc0d948451d2611bbab5594817383f58c4411953025a31503cc7976c1da77c57f8d21d5679ad49628199e80b22df149ebf8e44dd0fbfdb312a7b596ed44f676d8a96ea48171ab9c94b49a648b3305eefbbf1a889c3c35e7675bc29e5bd1873a57d25cd4464cb0f8b88085805fcb355f6bf0c0225815263d2d8d1b1ecc3a7d52f72f61e8110853758aa7dcc3a82421e720c32559bd29dcf2375a8ae94b75df830c3800b0eeec67dc9f5eff150a65c837901c27ea25bdee68c239bbf771ca76be30f8407627b4f65b7e0dbf65f5ef1e55383a03ff2cb5a74936e9313fa82f02fa64b060a2751a430d26972bd63ccaaf8240538ad906e689568845371a33caa9311a623e123f3e301d37ab43dd63ddd3c3557b1e17aae935911c177676653b0fbbe7d0356fad7db154979e91cb53a3c18b6fa69439be96224732ca3ef5422f5669129acba82a385aa105bee7aacf7cde6962853dbe8de9757373f8840a03729283a37a87510abdc94296a01e4b2e8192a3402e341bcbb19b30c21e28592b5c6dccbf6b003c504ba56e1e8434cdaebc42d23378e313cbd33aad5f0cb93747bcd56792a292f43e850883dc2e394f7b362090f22639138ba36f5abb910efa854fc2d1c60ca79871da9bf7588efd04edbcede8f3fcb13ed549a70c334f4c7b445b3b0a7d5a63eed7c09c119ca4385cd9f3b47482a43b2e501fa05ab149e5e024e7126b202034bb71d84ae5d2f79fa4d2888fa06bb38f54e17a278a82af8c9f52fc6ca49a103262560c0b3df807fd591283d7e9cf216a3ddf884d4c20b584e3cf3d246bf11927de2fede092023132fb3b635af9e1bd2e4317531a05de03b2e2bd214f83f47f84b9b3a9c2744dca70b2bad0a470e6f3d207d5f24aad1477838e8ef365b41a4a2f64e7edd9b36b70487eb9d57db77c6eac5c7ba3db983ddfa8466fc2ba699f939a31adb963d4c2d68ffa2f6617213b681a7a9e7015ffb9d6a01bfe3c76ecd72d089b7182ffcb7f72923cb822e5590c2acf46d4395408b396adcb6968e5c3eac0d57bfc6cd2d2796d9fde65335cbc179f88930daa2c1386c2657cab2824ebbb18119bcbad407b848586703abf9fb632d51e97bd708c265b63da4cbac67348906cde70be2857af7ca993d5a530130d8a1e0a6df2b54429aa9d84115be5fdda1b80c1e300503131317e9a91e8316b6b7703b27fddcc541222cb12462e29aee277991d6dcc212c3d1d21d0b636694dc74f9910a1203c428d2afa8340d75e0e3fa64b546e3155c97f01003ad2d9442757fab7395bb0aa28481a3b0eb5bee0ffb81c7ddd8553a85e5ff1fd1a563f0171a58d8252ebf191a202648ef5ec3022ff518d2097f2e971898962a47a4f18dcc2aa07a3d8bc5e9664d5a2b7cc0a41de6363de522b02f7afd1286f8abd9a3ab5f38828dd64c57ed38e4cde8cb99e0deabf477f82ac90e10b476c92964cc54502206019da3303ab2330e5a83fd4084f68dace8c0040f9a3a3b2419379fffabffc5aab2618f0916aee24db5bac3cdab099324666c8e8f5da434daa751070dd02a3a5a70aa239bc26303fe164e163210668fb20910eb23120e9221a25b2ee973fc77e2c0d2bcd40b8fd15f20566047aee98271f8601d9c9d2fd8ece9d73eab5379fb1aa2f8963ff0bf1eed926f08f4e3dd441ddfd5a883142051c74e5bb432de940d5e7646db8948945cffae8e34e1fc9174dfdc82633193ed9d6df3bab175168dcab093d28fb6f07f429cadd9929588a495d0e97b6c3211e30ec27c49225d3ead7e636270d03315f269370193d4a476c765565cfd571dc408db81618f0de6ad8c2aebf65a3fc700a2ba9cc2a0711f7456c85820e221b25ca1e0efbfdc9659c3886756f9b06d358784eedb6586573aba7d916e7f07fc61ccf2b8380037275b76f20c96dfe5e7527c96171af79dc16749c93073d66ac2e31d2c39571ce4e2ccd9a0f3b8831a8124d7060f849bff6623f489b8f85c39730dbefffc53460df8609160c7f19997da8ef4d695bdbc6a54a2a0f8885c6595821b764c0fa1cf97a166b8204176ede055adb920b3da39ee59eae49af3863ec3f38ab37aa69435a910d9fd75d612f13bd265ffb9dc2a702e57a41d71fd54a9fdfeaffda2da518002a4017efd2abf81de1173d9cf3245eecfbbf94285774466945a1354575a70b7f6949f0f9e3b59fc66e313a22933aa986fa1daec476b048326f986d368efa82c9b9fa659a7b637ca553f581ea27a932e059b259038529c8ff7878726c3b86ee94120a5122c5f69b169f9a54a3f430c424d203321b83ca36f35f722c4b831cfe6a909069b44bb1cb37dbd232f7b150cda61ecd798abe62623a0a0a76cc9a3f2cfd06efcf05cdc1874c433bed466d57b6a22225aa0563a53dc6f3e3485fd4133f0ba285096b47e789a0c40b16da0b8bed0db760409febdd3f7be3a3d4e55ac5c29ee0077f84fffce7cabd78d850be3aec69c059205145e350186784959fa6627526f2e7aa6e7d9389dcb8b862be44d1745f545c26f04fa36858121666c5b1f832a0bfccff2477d1a2c4236ca8ee5c59d9de27d67cd9fc02d0c4182266141ecb085a7dbf383e38bf0c94ebfbc8706d6ab8da33eeeee45849507bc52d37e03615c3f50c25ce334b1065e53f1c2c80e5ede2f85845598fd51a2a25f2b40580450a3aa33e73b784e1b3c44b8977470ef46bb5cbc94f00cf581339d54051c3b09029274584f8ea1ff875b89e44d0b1759365c0ad9b95db1f02cc77556c43b67e60ca42c7ae02be35cd58570ab9034c9b5e78acb80dae0110b2efa28b5ebaed5cf2701c79cd11d0319b6af401eb0faeba03db1949adcbbbe7e2d9f786eed9918e9db6d9cb8200794d8d74879b92733d2c40db3537469edf7a3fa2caa4685eb617f082b1881b04ec64e669ee99361df693a8141144caf40bc5af8758685b6b647f32f4e7db3ad3173033eaf041fffc0f098492821989f2372e42586cd5841d36e0303223d4bd679f9270e95ff83c005edb5b1f3a87178f0631f789ab8f6ae0ace02ddec207103ba68fd70b1e2df0cd5a02e1ea7a009815f950d102113f52952bf4bb6129b45b04c097ffcd18710a097968e5443e982d529782dc2ab8c49d113b899db4bae8d7e62978796b22cd6ac1ce84d6f7a99bc89c8c4f4379504f12c9d48bc9ef63e34c5bffd90886184e22e344d9aff83a96ed83c32a67c0e4366059b5efbf11c67373f9cc671720991f283bfbcc35207510a70f4f700ead13936d51b3746053ecbc245623203024900cd33828cd58c0f35f23f2f1f8f6f163441feb30cf8076062956d52b1682628681011efe306c94d5ea1329aabbe80748ff1a225989fe921879523ca16e2552f7468f65fec3b45ea277e66100b5a01fd351604a4a2e19d9463f08d1ce506b8d8e4bf9432c5df86e17a469490f74772a11df20c63954e21bafb0ad18e83b0b7c2c056dee715a2ab3a130d0a20cb98056be559a9b7e4d55ca98ee950181af4d04104c00582da24998c1c4ba6f1f44bb06f45310f750ccc53fbb7978b57ad85ac9a7e2788b3e618258b4b6b0a082d8570b3429065a15a24681668f3fadd694a96d3c671e642613ab2b0a0034aabfc42095fe68368e58cc946c1e745e4638e5ff511d8223cf30f506f5406200e6e72de28b53fec0072e0359af14c4ba4b7fb20d9cb0334c685f2b3f4de321fa53d09cef38eb9482ea36b571f487cb2948cc7731ed88e3ab6c3088fc875ea3cc829d504b6a1ae5e2cca0578140009c9927381e6d08f4269541e9ba7fe9d455561ab31ff3f11dddc95873a0e01abe415b15995a84a0115cf19fb9b1948d1c46b57bc27df0cf4c859456487ac0feac02f3adb4f69be72b9719278eceb54bb3c6c55e1045de71b45a668ea480edc052891e59a95c8d498a511f8ae37d782edf1549196607d8db12240d4bcb7cd29406e32c480f7eb85bf7460744c3ba741ad3af10163a83dc53417a9b0625197e90af13b926f52134aa8d4ff80828c9940acc74de05dcf3c253a9190f6794abba513963675a6f90e092cf798650cce4fb93e2e18e8bf15ade9704e7fd563ada0b8f8e5b73ec61651952532ceca8d1a00bcfc541ce01f984d649b8de1de6592c4552ecca27ed3ca9041be20ab83e222250183eac89bd5d639de6e7d17fb84bba61d35eb643fd085d12aaf2f9cbf01c9e744eb6da93bdb60d41607cc06330c4fb4d9e9d46a00d3bb46c7f394cecd56a5a74e86307d90648c84a7bcd32883cc4c25ea27d94b005ca934341607042158941a2a2c947bfa584bc88a72cab3949472f84eace5a1206dace39835ba2b2afc57c3dc267875f25c3e93f4857e48d6bcddaa97040300d55ff7e3bbe87f544b48863ab3d27e73f95de28cb8839789d9802945da7747332814ba53d1b1299ce5e0ff4b74b2e36ced0c7f494e7d01ee1eed2ce8e6764f571531f520df4cccf3e44566e4821554ec321a2fabfc2dfdd74c59c5dabb5f0c6feffca6d27495c2ddf0d6329e1bb0fc0d9617085dcb2fb3fa23e8dfac38a009c6d2b08d08cae789c2c203946a1e8d8835ff81f7c19f108c70e6f635408df41565b1e651083ea0b7a8258558e021c9c8a26786152fa7a3babba7f3a7622e9a0854e10f5caaa01033ec994b81bba80cd933e07194e1abb61c8d5e27a92fa75cda0fe9b8f13c4a206baf99e9e79ba0750e46bcfb0f8f827d521e8b8b7f114fe0ddd21968c16ced3e0a1cacd3c49fb44be882dbe8589d5df757f1985295aff73757975750f6b2eefa890ca13d0fbc36665fab0e1efaf8d58d102cce464e717ad88a1fb1fb3d06c0cdc862574af54b58798e1a8366479b55c5dc98b7635058bee3ec73ef7d5f9aaa0af57ce81c76cf58682d59315fd530e6a07869c1e209ecc7ac03c7a31fa12ab1b7cb6a101820cc53314b8e5e21d40811a5938fd5b8a257aa67802eeb84f1e61d6f5e62c904cf01c02e21d9b56c5e78894d559fbf64b8d125975fe17839bef93456eaa7c786eb9e0b883166046e006dee274e1a028cbe8a079b59d2df0ac12a47699ae53389a21d600aea7b3f9c764f45a7489765d0e42999a13718705295c1eb53c81afb83327ebe50c7521a026fb18a8e111073a925bb8273db72bce2702c3e273d98c17026950afbec960306ac679451c4edbab0c36f68fa3ddde8c9ac0942975d1cdb9746a7eae2ea610d40367537e8a46e65f458558d66cdcb165a3f80acd6d3f9d2c6c2568c07de723dcaf9e661e8d96a41df3cf071e8fc02a30f96ddd0481ff68f77c16bda7707d115687103e0c5b868eb4a09ccc86007fdb6639a660e113ee226ed18f7f7f9130f41537861822b8e123011c5f8d134da4f319578dead9e3b2ecde08e28bab748fb276565e8b7b61a15bc560ae182d9483a59121d85b1fdea0a899b5c3d4fac6a35e1e953569029fc82f0509639dc20b8d4da2187ff7005d5e11323d8eb004ed302cecc2669142a554dd5fbe9e77906ddd0248301d510eb9b7d65bf7a9be9a38d2af567054d896cf9eedbdb44ce369a9407a33c7ec2497e87a70597e12d610df153192155f0504356f76c73982e04ecc9d2d230880687e621db977631f66ec1ad615789b6bcf8064d62e01b8789012b88239b57cd618010596fa1b7799163fd411ad5fc384998ff039c7f0a23790e89abbd7edba1c6a9cb169f08012ee548a1ee61127ba3c99505e8390f3981230d7ec02c246b4a921a4deb23d0dc7fa49828ea4fe21a577264c86dd85b1ad4d44652e23d87bcef04265b6118f4101b8fdb9ca3016bfe3421bcddbf2f75fb65f6615f26ec95331474194a26a6bb5188cff0b890ccec0e8de495ced868301577a84cca6eb841a8b6454ccfd5ba643d66f7525548b7255d6ed8ced12866a56aeea7af90176cb38b83105fd09ca327956d40f9cc119ce9f6c8ae26d6d0b93ef71a293180b38ac05235f83dfb65faba46c428253478c25b5ba811263acc1cc20c4419e5cfbcfc7be27e4ada92ca208afccd30e6edaa2e2a3e221975310e3b08f32c11e9104a99d0dd3a163c693b071133209a4b42374905411a90cba42df5404451278a30d2392ead25780afc76690480dece3a78dbf5b6dc1a9784c8632e05e5141371f62221fb5d2fda6cb06f854d81fed56936bce91439ad4526783d58c288f56a9d12442ab627df2065fa03c3d914fef2e57716731a67cd09525041e5e9fd68f2e0fc0ccb08de5111f0d0cc57558a08297ea13fb12ff7af6b544bd5b67e771f82a29a9b94c39e0ad920b696401dfee5d47f30be0686c521e0838670a0238fe39a68fb5f102cd7be8a135689b75083a66801f9595d41181f2a6eba3251641aa911e744c4744c89daf5537fa6e664548c7a403873af4e17ba19bd09e60e0c5320ee40e037532fc4997ab90c134bf066b2fdd1f423661cdfae5acc668c32d5c95be2d53f000dd72901735cf1ca7e9d91de19412c784d6b9345616c2940d3f7455616bd3404525144535eae73c3aa9f727a34d63089697a05597455cc76cb73d49a80c682156ce11b86be422e4b9e2328c26df0ed0b5fbc8ce12695d8789ce1232598ab25e290bea4acda4b87355b32f147248cab6af9f691fd54c9df8b13555963d7126d2702e2bbccf89a9f784d72fb68aadc0a35856109ba3132e359d51eccca854351bf1f9357697abd4b5623ab6b6c523f0c0ba11d39c669bb3a31b7813e71537843311820bfae03cab512fa32f18a96b9e29e283cc5e8bf13c7262150b3ed42de3dbd1f2c8fe9f10a6adb815301cb70317b87fc337f07f6e544c0f2adda38aa6fcd2999d17e7fe8d4cb169ffcf3e169a635ad48123307bc0d5e989915a8aecce79f6fdea3e6bd2c2429a9eeca2bf5bf45e02abc6164c2c423b3c5bd68f306db8291a460ffe3da395205edae50c8eef726dc224830dbbbc6f36ad04c0b6cf81db8419f401a9d6c2a6605692e26348ab38d4a7f967e0e9ab361e9d6ba2f1eec5f7c0e91c6839b464a4ad7557455c178d305112dac74c35cd00d498a84a0561867a777be73a4bc0f5059079344b2f475a0a7db331ef726b6bb52dd76ab4354284a7dc4920dea334d2926976d018028f22f5a7784fe5dbe2e8057384dbcd609a612b6de28dd2305af75ef9942f3aa927ede11f488d3aec3478e83477ae5b1113a582baa5c4e5c816c41ce6602fd6ed72b7fdc2bf0155019947bc30d2e0cff63e59fd68d92589589e576cec51b4db5ecd2c3082865e4d7d49fbc076b820d6bcf0a4a77521e6984cfeb862dea435477125be10a0da998246e050ddde0293df0135112fef987cf23ca095c4912aa37a7b2f902efa298b50658d9333ef03ed0f5481b3c85702c661d809ecf80049dd23b08470402bf3a90fe04d7bda92095937f5253ba37dc89c4b4376725e734d46f385c180c202b49c0e838b4507703cba53fe8c2e764804798c9cac36cf2ca13f1790a2dd012eb4238b9bf7c0a19be1532177d71aa5a77b7985177eaf607815066eb3f5a0fc8a59e00874640e03c7380fc2f553572ba51025f93e41ff90d356557bc5697b3829c4e86ec7611b7a1f94bee682ea6142d2bc14114bf244077561a8c3dda5b61451053f86049329e37113e8bc272e04d7671935e58dfec6550ff76d2347bdc09abb32e001b1961bd3d4","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
