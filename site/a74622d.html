<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8de7e1a19defba8beabb5007bd89fc46a33992c80f8867ab66c9fc742825944051c7dd3a720320b57c53cfa1c49e04fb398594b8c46724a889f6f403d6cde301c443dd1039306eef2773c65a0100e9d719e8cd63ae99f85bc035effff20f0a759ef1e0efa162cf0115ca2702ab053257276182cf12aff632dd5e77ce32449cf48358529351e0720e2b85d021ed152030c131ba8e52d819c8fb3e6b7de68b8b3951c89eddb3f5d28a7e06065c1ddc70cad39da570dd0378fca3a9e1cf1da6884b30b0bfabbdc348cd0da4bda98763a6fdb47e8ec18989600fd48717fafcaa3605186a46d349b9801572bc86367a42d28c296a1b687c7a607e149f3b54411faf6ea40e71fa47c7d29ba91e68cdcbd95b2750bc832a5ed52c6be722fdca5ee546fc0072d9692ae61bdc12c9bb06fab2566a256c5d832929b0e1498bc054b4f495a974c780ec1bfa31e7cb29d3149c18e059812164893d8065750d6b6ebeb3bda5e20cb5f27fb006a001e40a1cdd45658246fa753516771ec5203c16ff52057e95ae417e4060ace80de0e54a1f5e31b8808671dd9032bdc71d317eaf75dcefb1ff9dba7b17549a8cb54163bbe29de2c010167010c8cbefe19bd7f34e211416e85958dceda5ca4f108bdf499c9ff5c7dd1f0572371f2c2b165b2454473f077ecca916bcc2177021c67ddead85c56ede9827ab270079ec84914b77416e30886e6548d01be8022b98afc72b7c18150188e26e746ee80fe2158be55ce7faea7e44ade2cc70117604c34b689a4d9272c55c4a896d518ed24ffeee125798a54e9978aa545f264df99b46985583342c61f61659c822b9f89aea8dab0fd5d0d0446edc6e42b8919237e339dc8ab5bdc0f26600adeb1268f7839260a23491b2eb4d49efdd556904d98627d9f2a57a374561cf18c8d02b2e43a4948ae42dd746580ebc6545113305a4c75044faa8bbcf6c976a97fe9d89428da066f56c1632ae3a6ec07b7c9c02c0e8f0f3e1c98567cb7e0479dcc7c6089878c23752c93f06c314ed41c0fa7ba367d09b1f461f58aa68a4eb2cee53726036016bb2f81d5df4a8441caf0e94fc835caafcd812262ab4505266d3bd87a1e03cf067e65f4e391bc4609c905e398ba893397fb2d2be03c2a9e70169bd48c00a4edd0f6e73ab48d720df7895606ffe3a2717d64b24f384ecad0941e5e9c226ed82a1387b7178e9585344e82129f9375472e0f2b9d0f5eed630c01faa4b5a42c91273cc3baea2e4e2b48297cf2bec4f13e0ea0877c109484835bbb89ad9e90d7566856dbaeb759772d3f82190ac5b3a85fffc641a593b90b9bf41b28505aa4181f7e09f743360b668e6a0f6e186242920789b0626381c9d47220ee9fba3b6f6a051d3208e05c56bb48407af3b4fa360a89915bfe83c8ad557fb6bef4d510a583c59b4e9fe74fdac09b2ee07fc0f78543771091041d3af57a2573419a62102803a09e206d93000cf5f4dc611fdf01e025b614861ddb9158f5fcc344592c8502149c708bebc7cf161463e67fb5d13321f4afbae07d2f03f802a5af63ce0960294e6753b9ca2a4e8401caf5aec7b570188120caf6fa9e7e8ce04764721c008593b77b1da5b5e3dba20e5f873ebff022c9d5da2798f3619602c6f3968b370a38bdc9aa4d081c4227f3bcace91783ff103861fbc6a292429c9ab1d65b90e8975670c2deeed0f37ebbe76cb56dbb38ffd0361c67b7efda50acda92a1517f1f5c414482e4b0fc7263ef6d18339ddfbbc76c7de8119fedb8383a74e23d0798c20a153033a33e89dd6908699cfcd2a4e754cd46e774512c3818f7c80b9768548cedf6bd9690542224060e6b13c0507220c7e755c59d1ac8337c59f523d8d1cac31fece04626bcfe2c33cbf91342e1b4b7569fad1c602a067604538fd972a7fb645748de2bb8da0077e24b4771c5677bcaf35fc7a55d7155f3627c65505a18e7ec86203742bd637c33ec4a559fdf97372bf60c4aa1af286acdc4c059c5e894373b3e82283ea9025dc0c29e788b5cd10a743c8151a922aee816f0e2fa8fbbaea8aea26851a6bb6a9a767548288c06cce9f5f4402d0f8ff0d6288c903f1f7f975eadad9aa38dab5eaf2b44316c4673ea2bc28e162cb6a9bbc7069108b9bab8b8b229243c37a08ada15d27143c252d3c2c7eb453b9a7ea1cceaa5ab4804a396cad7380a237a2119f6b59c13ead8f12662a4d81ae9de6daa8848fd36bcf7d2ca9c14f8362a9ad764a4edcb63de8e7c2eb4097c75125ccb6cd9d5bfe1e225ba7efacaa0f9dc3946d7966b2ba3d0060450c9835e2064ec850813cf4180350a8ad24b64b212887e57dff402c9464f5bd74b1046e38f458533da81057216b886f823d920295d44d899b5a819a0641ff14c89d4eeec0d0b3e4b840c5a9bd97e5cc82efeb59a3c23080a200e45050d6f1aa0a91064034e9a68fbd0a629177de7aba3fd58a7b622d940ffe2f1837f580a2fbb2d4e1c4ac88eafaca1c6825f65cd40fc433f1a4c74e0bbdd9351d279279dbc3623c2b99dba00d4e7a6b139ec66b0865bd815645cf32db849610f095e56a174826bf70180052c3f849e5c508044de30b1db18e68f73d56e24257f39d8a2cd9c5587904ed4d57f23c34e833cc7e294a481bb700fa2a0f5925613fd6016054747387ed6275a48c3da96d4ea0f9e84a2daedf6843e608925f35dd73c8e0c8d542b3a819fccb383043e9b7ec205f893a2233dbbad4e573e68b9d32c24e956142fcb0398246a9958bd222259f6b0c55c588c537913c35d13efb6e78c59af57f370010ccb995bef80f14732ab3f94fc33dce1e6a7289fa538f6c8b114e99913ea33135eb35f59ff443648a314fd3bf6d2fc34c4eb2a0e8b06b11c74863e1697d576ce149502f15efc8444fffd40c5d43e6c3bdd8d580f54ddde9f0d8b76639f0f160e614f3c40fe9c8d67d3ffbfbe9f77da2c5c9d475927513385e0fe4b28778c7952711582b92a72aa5f37e6bfa18caf440c84378c4e0b1465b606cb9c1fe736792e126224ae3805d0c733fcd7360d20bb39db58108e6e8dcde90f39140d177936650addbb79a6b99fde5c2e676012819fdc4b630d0d65f913d41e3b34ce8cdc596bc72787a3c97af187689dfe93eb1ede7aa033841da419984422871151b63a72c87f07fbb1baf1d5e32720d8275a1db3f7066c4cb0f79f5dcb9d7c553844a9cd4601f1a437d51e86e490ee02f5e58acfc93930c0c0b24a99f3db451ff149a50acf31b320e47d82988d9a312c1e9a8d150d8a7600bfabaefc60ec5221a3209ab774cd145e7c33cb75363f641b83a1c7b23eb2a9b70557a0bb25b1389f555f1cf1ffdc3e5133073c3692e8e7383b1cf3c20253cba352a5bacd877dd17cf10a282d5ea5e777522b0e0744cb5e52a149d336e2eb31f4367cccbec19e69b6a9325bdc89cc7e1cd9bbbce252b18393e8e5893da631e4064cd2d84e1b547f6847484c20b4701a5fc92e348a9c6335a63345da44ae90966fb46451f67122989d6fc73e88b85e7bf1fa0b933eb3150313e63969f436a5a72bda89018038e52c3e416c1ee69090d9c8cc22fb166e38302ff7d861f6e0c31cd0acd8ba3b27c7a69d0673db66a292c5f783837e946a3a666d8297bd5c1732b64b0856ba0bbdac7f9ac0e783f4d10e15566207ddd990bf479743ac4da7116eb2bb6a8618d472a9f8a4f2d677e35e8d4fb4f29df8eef485463059b3c8f815d1e8b456cdbe9874710168a1e23ead739061748d8a89b8f34698859998f30ea743d0143d2f4b2e21d2dcdd7392622c360c3f5856e3b1c6bb69d9e5680b14187ab91a146c1a38ac5337465c5af7e95334c12101a5a90346ee0687232c496ebe976fd7654114a16c0ca062eaf0805b4f84c1f041981e1d5e5ed359fa0a69345af3381c2062104c82417b302981712c6d99348fb33ba0d59fbaf08a3f07443e675c85878a061c36b5b2226babb93383b6a8fc14189e302cf49f8d10c2228162f3afbef641858e3d8b054aee6c82ce1bf64e72ac9b90a07be1e0bfd9b1d497477b64a526ab68a3a79f24ad70f54c7731ac7a0f7449488d970c149453d61203079f153a230c71008b3f2d3b013ea5e1bdf5691a7e7ac3dea5dc44a2ae312069681ef085957c3e37b2383a99b3854b0a096baeac788430a609491ee2e01eeca66a8d7bb0833a9beb2ee56af39453434797de302f3d13582d307939bdade5cd4bbabe79753d309c7185b54e41021212ae0f096b876c81ae5fdcb1b0b33aa9c1e950491049ef7e75a192ec9cf4f22a8073b7470bf9d22d8f73a0ad7ae4e29a79782f5496d139d6d38576cf7ae4363422492c7249dc2f314a8392438c3a737a3a60d1b5dffb2caf79461cf76c30754ffa5fae471b6d9c42174011186270b10d5405448a782fddb84418e1d0fdecb8d17e092aff66e20bc96e289a61eede16b27710010047244ba951a68adc2cd94cdfad6cb1fedf02a871d7d8cb4ad47a88350569ec02a7a2225e273f53e203a575fbe294d7dfe51a79fd51b53cc0f7101788f977e011f7ed7cea55ea1accad70d195c1fd794e1699632cb14c57d92dbdb9d024c703ecd62296be8dede8e91654b80d84785c150a95a15d04ffe9669eac7ac9d520cb09f364684407578618c107ca6d8f27495058845fc7cc1b28963e6dc463c4c2603ae656d0fb9203e9886b373100484581a29831bd0cedf2aab40822305f69f51d5d34664d46b47521ba71b311598eb3d117eb74b7b10872333df211d4ccc4b2cfe9d5a9fc759568c400a704ab1d37300f2298f896320e13934a8d8b46dc2cc806821773fce644c1c43ddaef60b60c0a1ebfb111db6b74e4e43c5f3e0980be8ebe8f6dc2d97bb6b0824cc0e97eab6b93ee54acf142fc9ffdad5e66995d45f9b77aeb0230b4f16d1d72696d84e082511bdaf360c1a15e7575a435184de6dabb996faa27a0db10c57d538a190712750202e27d5741a39ce815cec4d6e7f724e32624143d2f414d6fb98852facfa2aed38ce40452e5f6c1e5dde3bb1325af8a2ce4049ad2a4a0b4b7f817f1359f93590b2cb345a8bea0785e1486a688cee8a3ca5099fb497b19a211513d14c6e37be1fb3e9345fedc1e5052b3aed4eb95f7bafec12dbe06e4ec0424b4b5a9b2cfa9e18f9384ae9032d0da9775287048717378cee2fefa6ce1a402c4f214771d68d1a1667d990b9ba2ddc5fbf07c10d20bb2fdc78e3c31aac7bf270a23493c4db6e8c31550183384934c3b89a4c24d7a447eb834298007cbca1fbd2029536f8c2ef1e06eae261e5dd4eaa504ce026d90769e61101f7775d62f562a85e75150e1f01f13b19b7a32819b4535756736af254f480b6ce050fdf0e2c347b4f8905af21387cf4cf079216650564008002b4b7e9d14276ca43516b8e5f86289644227b2306032cda1bd12604b30f65f2ee2bbb1c25985b1487b0e0e8157e4c442790e3f5a3c3064941969b7dce2ef7f31bbc371482fab42110cdc34840e96052f271139f258b67f5e92ed176f61149376301c6eee24f1caef626fcc3e7412fe1d5d1e59e3d24e0ee93d52a1a34f0a6d2da9ed1b08152d8e120504e58feeaea3d2fd02c51b2bafffde3098926c5da4b4a6acbebe478be5302e012a4630b0586a5b4903b962bac28bc7f6b5af5b1b3a38a1d5df161b02598c56478dd248486b9a74f39e9fb4d0c0200920be7eb404ab3c41dc2ac56d3c9e0985e55f38a81e947a09382c0161123ae5b51dc4ab416b0d27a7a13fff53d21c22437ba4bb070ca77cc7e2966b6454743d34f11fa724b80c64df076dc8f4c6706464230e151e8f4ea812ee057aa249d4c09aab6100b8a561d85430d4cc0b0b3aabe2ecf0eec5652fe79f0823ce95556cc467e233bc39fde78631433e1058735dbbf5dd8b7318113bea2ba229369b1cc3b4514a6dd0a72a20e8a77056619d02332edcb6142ad0d01ccb90c8f9ee43b573cd71c08951557c2b602656acca3807e64172cf7f21b0b53d3f2512cf65e5e6c3167bdb8939a48a6c3004bf87bb40cfe7475392a6c18b0d487ffbc5932d6b29bab93bc9271acbcff450d59c4f9eb101bc6fc06244160ac03977cb6abe437de1115e3da2bf7a0cc7be91318487d30580ee23fb387564e2de86586e6daf7d68e7639624f84ae74949b5616edd467b863dfd76eaf2d806299d0e01106866e0bab5247c438d43f977973c96f15faa9615f6989ddf8993f34279e013358e36d1a6b75267c327363e578f43b7385a2820a8b56a6814cba05d6457f562592a2e5d6be2ab43176cd71e305e44a49df79aa736f7c9f4c3f2190f6efd7af7a856308d1194dec69bd6fda9c0834741445467cf3de9af8a3ce1d5c3d051e3d085270d51379aa321783cb1d5c4afdfbb193dc7b21e1580fe4f60cdc457e5ba47584434fae6dddf928646e8f00a825b1184f6b6d77784386e2d2653ed34c4b07ec35d3319b39ee81bd3fc34dfa3e1871e898733053a24f691ce5b65d259de0cb278dd1e53c77ed85d1be10dff581754990446ad25a6cabb9aac1ff884fa1aff2feaf663a12cf85e73e0d18684dad82c4bb1886915ccf6fa8bef0d475618393b6ed9eb3f4d341a4c4b02bc469fd0dd4d992624855185749bdfc14381349e21978fd087d36ec367c598c35341b3073e39588adade675a12ab14d4d473ae1d26f8950fa3c7c5184d351a29564f7935eab69561da2d43111e9d1465b42d5a25a1f5c5aee8bfaffeea3e68224068f34450a64b130d9e413b172bbfd9834f0c3d62544a46800f979d969dba9ff96ca5c595e5c53aea07c733e70278677f83a4f7ef0a2b91d6877d21ec9e02bb4cd5af32cf39627904b639ac28378e103fad2411824e92c4ff7ac91e0d051179a8e6123067775c38eb69dc0b43938b2ed6b274ce294b930ec10ba38d2072c2640cfcfe8a7896eada862d04fc96835419553a0314a40800f8c0054605408f3240fc7657048e4c33f37ccb439e71902039fdb1438bb9b3f1344b612eb3f872c894c28debb6b50a4b8534dae450f7dc03609115b93930536213eae360e27d55125da02ef360ac44585e8bb6cb19d7cdf6fd85fa6fb0df3bb5ca994661da5caa732d91fb070f48de061450345920cac244beed8ef14707739d68fb5911509eb7c2342a46a460c6df3fb7234895a78881ae503ff8164e040522d765fcbb45b7a1aa21e6cc2faeb084f58a2314e47cbf757786b18e570177ed5f699c7b11fbf0c52f06f67bb5a0ade0b85b87ca986d2016f20054caec63c1cff957c6354bf92bdc842d3bd38ee8011e44b40afaae560b71d4f36b0224369d0a555a0185f6057a26bc705f02d972f24c1f500c780088122df6adc9a00782660b61c20ad1d170f2821fa50a6ebaf6eb5d354caf3dfb4a762811e149479fb1f21b331328b1f1d3352dfa73db0bbd73bab93ee7d9a62115556df821507d20014c80badec2840e4614f20bae99ea305767720a2fcdc60dce1f71abbef5644a42a0facd6a45fe5f9d0c82a6e1a3bed466d4c83bd4d8d89999a3472d4063ee421e2c8af04ededeb138c16dc4a71ca006dc0d4ac79c722cd32d2f4e90f699b0a1383159daffe3651dc5c133d1a17af2ab5d2532bee3056b5a693d8c62bc92711fb88abc5618b5044146ce00144aa4c5f790760376fb5fe594c343a6016713e09a4036769a7abe29f637db748d5c359a6d484d58f3cacd24950bed752d856cd8d1c59dc29b84bf23184f968b1143d1f8482076a33918d2f01b1dc58fab42007f4d4606e5aada35da7470a16aa4e596008d9aa3073b0749f02adc18931675065f8ad2935d4595044fcfea6c727571b74d456b037e504e4437beee6f54f1d585ee2c554d824c3004afb487797a704a5131893f54c279c45b183bd328acb1df6d6d9f7c023ba84b17f27005d78fa423184430af0025f8b0a9c6033b9e01dfc63384e2e234cf9ee52a584044d5512db7b6171c457f724489d61b65b4d2af7795b642160d94c80467659c619a85d5cbfa3ca07a5e79846dd1b600f6fda4e0f6a6f474ed8777be2e5ca5dda28004001ebee6696cafc3f5a4bd7695393301dad87c038ca39a2cd598e25647a47f5aca511f81b6890f9bb36bb0443e6cb37a0e937d481aaddd0cda76a5499c9e77408673591df32a9cb0fa093ab8d4e2c1a08942c01c3476b3bcea71235da18e9b8d3754fa59ef0cf0c86a5c49701715e72d9f97b880d58b7eca3284847c1540d762307d9303307532b1fc601efeb8ed10bb8da46dca51e45764abb3181d494050bcb217f012ce5e3d9dcf7f3ef473823bdd31f754ec4fa8c94ba9b11b7e5927d55069e0111e55aa2f2c525fa9176c2ad894e7b6a68ef2a3c9b4abae6075f39acc10f4c13da8675abb452399168572176530e4737bdb2ca44467558f163e19e09a1b378f96afe8c19fb8bab42cf3fe986eeeccfbb219d556886913a370610bdb5c44696302d9b272ae7571d346397d82764eefb8e5cc1d5bd1ea4fd3e2a1f08e0cc505ebe736cb1094e5ef58016a8e68b25c81d90268e98bba34d72852b231229842dfa09d9e74f6081a2ca8e771ae79021f4e5729aa66a92ad84ab07786cae916ab94f6bc233a7b44062a563b2cd981720380a3cc9b895d071db4bf6a62d6c1d01dde269ae32703271eb343ddf97737274fd77833f5b078990bb3440af7e7edfb6eb09b4fec62a8f656153e220472b028a15bec33ca8af14106744caf55d84f6381adb32d059a954266aebbee91071945547f089346ab9468676232d1b7b7faa7250c650d8e4a39083d1d8b929bb13456456ec9fa444449c8ccc4932746d118f8d23c0e893c6c9069e0d81cc118502a26b42a792868c8f3b4d9202d1a3706e4842fbebfde4accf495ffd56abc98c5f581b325b6c97cd0cc24127e01a8f1a3eaf6d0b34731d2dc0f72b34a024f85af48609e12fba139ec82646797b2f9dc2eb65b81ec3581f211d63c0d9642cf799cdff5f2f0973e95c67ac5cca7e0083644dfd6670f9c66c61293b2e0dbbfc4092572b84777e76487d952fba6f802e898ea8b574f704f14e7507cf537320dacad00645ca515ec600d8babdd51c11700afd30c4ffe5cdee89e9adbbc7b09f563ccb67cac00dd71a4faf314be04d0470595d70997dce2fd8b3ef9b3acd23650d6157de205cb23763738c94645f9409e1c6512182d5e5743a66121382d9ecb4a0fd58f5797426a01452ea6b90e13d6f268e4a85880488e4c39fe9dbb90bd56656f59bc22258273f8601e1cce93017876d9b2ddc599de5373d815545305acd109f30a24d6e91510611a3212d053001fe82d60509f96ff3c9cdceffed3e43f1496c13ff30b5b646b6010c1d876f0c4cc00907bf3fcba1002cb36e6be7f9686c050fe8b2ecd1f5db38083ad83e417161b39aa4466a00aa6c32279ce4552a112041e72fdc981c4814c83c0f90403fe2217d6c916fded4035788c0162df06ec81059de183c420a617a1cedd87c7430ddb2deb1796f3a71bdd2fbcddfdeb69a66d2c3e906c37f2f430c8143df1fe707991f59799de06cd32bf7e5487a267f0af6a88d65a14fe03da17993ddbe4762cca4fa07f6f25261dff75fd84398baa038406c83f26cd66f51cce158d944696b1f80bd5aae4e592479d447cd8119e1568e075e1de58315d6313b35356a521e8ca84fea4132e38e97ec93a5c8b11a7e6e236a0fcb947fd9ac3def15196dc392db30b792b6777f92fec6a418e414dc4b5eca7c0f366c91ed93312743ab6bfcde1a3531570dcf479b2a7bec4f5f8d021d5b41a9dce171c49e1b570c74666c1232e2e0b4b1545aa64f94e111fa38e58501d88e202b84e1afec45774ddc2e991984e4a0af204f95c2f0cc9ed3abab829c15b6b7a0086bdee3905cb669cee23674678c0d382a6c0f75cb820fd7e362a801e2dec289327a51f47a97812869cc13504b41545c1876120e8ca62a256b904c113e0ceb51c87d123fc533fcbc2a508cbcf517308982c07a773ff2b260788e58876a09b212c7a7ade025d678a162b719402fb12c4bb07edd1c93976dc48f01adbfeba5078201b12cf38b48cb99af8e951aa91d0e91a557bdcb3ae71d0fc3c3c5d5175ca3fbd70bf1a010273d4748cc29c7551274ff3364ee3fc5a339710aa5a7430f49efbb9afdd04efc8d95827300258a998b80de109cbc4818d2992a5e983902165debdd25705623ef95cacca17cf258f554f432bfd32483afd322f7b951646066d5406ff3a11007ab61649cf3b86c2b59c9ed89fa61c28636d7ef10a03e8487b2a6d81c99a05016cafce3cd15f5c182de264dd626b5c7fae97aa3d3a33b9069e982884e4eb52efa8c39ed5a86be498f7efb87da2373ee3df196818914cd313606b9c61ad9ff620b2603aa005e5d2b91671c4d7e2d4dda69877800dd6b603a5b8f50881edb5243a57e7df4ad758668c20047fb9c8aad965f3a468ce7f5b6b35cfed3e740c06628835e3be7b02ce7a4d6ee2757a79df2ed58bebaae9d9e6a9fc7901c40c52d2e91afc8c30c9e26a9e5ba79a9a3e9db2876c58b313e9bf8cd3b62a47673d7493c8574c7f6183748fc9b094a5cccf29cbbef8cdd4991d82bd9429ec2aed45972343dd4456ca027412fb897d9acf2eae15a7ed35323360cee34673c78a4d7f2c2101baa41caed1027b3ef0c1aa9dfbf6be18af47167d51ae8048a628ff9d13e7933cef76dec6c30b76b91e6dbb3f11bbbf7df57e2292238f90a2a73f8b38e05305c9696693d897bc2aecf6a6569f874b53cf2f841b4322c5f9d1b5520869d7b3a8df38ec2adac4d61b0bc6c5b0e6e386e2ed82e92f4e97062392f73f9072ae97f66163373ff5f133d214e5f69e59622bbc2c19d159d3c43f3682887ba6d45793581b54d2ac6b92ac1764863a72be7700989712657a03cbca4699887e3d04ba356e5c4985fe4935680538c38acf741a45d34ce59082736ea03e7c5883f6534ddfff507ef4cc00d6b8541d735c5b217096019ccdc8a1f089393cfec3b10f5506c7de991bedff3c582f10cfc94523a38e9f5b827bb091c19976a940e2aaba126b3703f9ea99cc451175b28543ea3a943b7d5929c9f14e969c75f30807ea28c45146b263c3abe7a3ff3a56b6cf53fd9140e85d5e0c67e147ced40e5cb3026d1c2fd7a7611d0f869aa15b5f7329b5c7b52d363dbbd9974103c98ecfa2f4bad026d4f8febaafad8ee02410da749f0648a25a4a843f67f657fab94d3dd40e2e99bbe476c8e4aac1aa1bbcf1eea78c99b9cd426d68f92e3692381fd2fa025c4a17d1403d8fdf8ee4b7d1c61ad0b972a84c6ea92b887317c5ae0dd800c5b6b6a3a8276330c7f1f1514852ee9bb0e316d43384bcb06f5b1483f9d3e914e762d9781f8a38ce46a70b296890d57e7a2799238701fe47d7994ccb65acee016af1fd4b2d58e61f45108eb1a215945edb19b72844eff7f68e517cb1149967801d4666346227422a9c1730a97186cf8ea04ec7f72de428a1f843cadeafc0b0756745f76f7d612b8e223234461c1deead80dfdf4b9f53fbfe26d4fee6a308f6440b25a4daab0e4a0681d2ed71dc304ee9b1b52ffd5d73eb00e142a981515af69514e9c50ed7b5cd6c8291c02cf0a7a510e8a9d331ff7218743d1e4347deaa54b59e29cef4f078ccfc464b5357ab7b0eedcdd7ea10bdbabc70d32d57923c2f0917bd1b0221ec145cf3704dba00e1137882e584c487f397451ae425143351f58568258df26377dc6d6f03dcab209be435b7dae52adce5d8cfe62708b6aa499a48f184af2e1ca05e6c6525ca4653522cd0a27610eff39517ef5eaa1d6d5385e4f52d1f80d813692c3da04bde583ba766e07f552225f50bc19fe730ae27285070670b24734bcb64e82faff3cb4366dd942224f6a3c2e93062282fc69118989b873546c3b6ad0c5ae0c879ed619bdf6c1e3d32e8c676856869e5b78020d43c73ae738ebca16531f7e7ec9550e8933830548fa97ae551e015a167d1e034972a1d5cacf89a59648abfb376fe91524bf25e8a981d1e197bf79a52c6a0cce4dc1f74718dfd01fc17da9de4f5b8544ac015444fc611bc3984ccfd5761a5fcb3899ec185a888890cad7ebdf4054fe6ad84772482589235a8deb1c49f6e7f3ef26ce82af8714efb380d7fcaa654b26270ce30128074bdb9c3fd4b91d59531f36f33cea600e31e98b96a40141941380173d5845fa744d8724d5bf8ef5686aabc1ff1518171b4429bdf16ef0fb68d35f5dddea7fd5f8c1c97e6ed41caaf136de3e27c92db2f6bf81ef180e3ff754bd087f237c79f9f55803d47703f5b1188ca3008580c23c7f7386e96759c39ca398ef379e6cef54aa433be7a9403516babea9cd5259a41bf15dbd72ccbea81f26715a6087b588d3051e6798178cd420ae1dbf4d579844c9fbd65353f9efccd9f2b806e98efcec34e13f06ada609c411f049af29827420912f1c171323f9cd2c1564ed0cf4f304837ed9e208c8ea81bee8c921d25c9d4c9fd3bcfcaa0fc9efc4ee36acc4e31508cde1a1e30e1f29a628ef61ad92fe8d513e481de815e4dc15e6612d5a4a3d37b0dcd94c880e1257cf3ea13789eaa5e02020553e808bcf0c044b93e0614abce9febc4b110f6fa469b41c67ee966b51a9cf3414435808203af35c130192c9c9249966004594b64242bbabf35efa407d4fdfc5f6aa11c1c7ba2a0dee12f4db916500b142b3792625392a2ea89150653764af0343d990d53e3eb5f0a52223974f31f52301aecb5906c07540326f1f93ee5bd198339f2a84a31259d532aab1ed8bc75a3110075b57e902b7501a705c7dc32889cb523a9950115fafa9137f488144d58863fe11a1027b556d35d3d156478f596ecb12fe02782440049bc2cf4a2baf10e75b574ee917ed2d950a91a2f5fec2d3da9f5ec13daf9558d70ef44945e2ea3e4d7ffb24fbc6f8a9d670726adf42940163c754e8fcaa01da538317729a93b54da46535a9123fabda3a11924f12ed611964cf7300e6ea8cfdfd4fd1271fd73140bc5b96b880b626b8ecb81faccb5c1ade13114e2e23249bb03ce627d66cc2ce4f961d1ca079033a32645dad76b14835698e7a6fe721ae84a6b86f558801925c3a6f38d52d3233f86a86c1c5235903684115430fe7cbe2fa1fc0755965c1e6ad48f15c694eea2faaaf9cdff5e5fe146ddaf4c37471d8ee6dd37cb9120b77426b01051fb483dd94f743c6111573747c26167b9da2295a19873de30574576caa405aca5dce6b09fb5cc21f1e42f191d2630968a585faa63603b30b845c86dc7fe0870f44471bc0b9f5bc1c61e2488026949543751278f2366235462be3422bd7d1719d56c479cc5e3f38ab606635c7ca3561aec49dc2a2f8ab98f216d2fbf9db8ff31acbc5cc7d628eac07205a081305a4b04753d453b6ec02b5b69dc95f68cb4d1feaf2f46204c1409caf0a06f6ed1b9bd54225b622a43dc65d6088a95a72a80e68ec0d4268835104e92091afc287add6c9bf724607cf0688e4dcf3f7572aac292d7982b7eb7bdd77f76130f115b6ceb72cc258347cdee5e1d7a2f2fa89981570426170c195138c1ffee0766c6e0d52b01450f95f41ad84f83d9dcef1a5a2b8cc0edde3e45d6033129a4fb5d42092f95277fc7a33aeaeacda829cd747089eb981f2eb523d1f44699875c84dd23b17e106977e3376b6fbe9ba3748d1146eeadb0659f7e3c2e8e553c21be2a7e461977c780018c7c4eb9c3931834f9192b724c7f1dc186eba7c45cccad63ba3c0a40ccc423383ba8ec9b3e78ca297839ffa010ef164e4de3ab93ef17a2e3dd2c2020a928b80d9b232238a886ad479b063af179e527824868707102866e500fa9233008745a2c699aa7c8f38a75c6524b2a0fd75d9c20cef40398c4a511663dc6f259bfb68497addf93b94337867be79ec717ee974fea69a1e00a3e62f430face05f1a0f316ea040ea67f1a6c1bcd976c90155d89fe472738597aa7a7723d0ec5edb2d4f0cd636f9aadf7d63b421b9123adb157bf7fa03121e65c67d15d1552964fc115cf09989596c8788f7505e04c52be3e1ce63873140f20d67be195327c13054c91ac4946665f7ac15d94f5407f8786635a5aea59de8b2ede9b63e27b95a3e3973ccdcdff8c2f416d92640e616cc49d8b2aa1a22039d28dbaf8da58133a0289477973316b3e7fdddee2189f4bb6f327771bef12ab93862c6d336ce64a97a5ae7c3dd278c2662bd117d61b5d533a60dca608e4710f7efbcbeb6ade6f98c14575b7fe7869b3845573287dd2b237a7b5ae543903decdc4c8785433f17ce118ffc384b5cd7a2b45c74f4cf8c1437a97ba583bc7786721cc04d741a298ae70c54aa6ef537288e28cb2f0bb4eeb73bddbe2667e26dfc311110aeb078a17bc2c97517f64c6242ed726c14614ac211148c959053997b4e4c853b566835910caffdf8efeb5963135443a9223b7cff9eaf17ca575f80be6654c11b8b5a62b552348b0c74239f9f79bdb839c7c72b088d76f06d92af57b0e91dcbc0d7b34c4fae3d28e21abbfa7e5653321abbcacad0666e34a17f7ed4287bc18ba862364bf8e1c2a0cba59a78f58d7f2f7c63c693744a51f4977a670ece878d0a2d74e09b4d623314b4e088576f6b4ae9c3a5250571f4dc399a98e779226450be8ca655e9368d551ba68f842398e69ea50c2209a7fd8c98a0066615022f7894fe9efc05b7564415f852c1fed621362b8d352576d3b2c7c2320832c3b00558f86b87410078565611285be4adcf3a1f7207d3893fc2d919a451118a1001a65d64943c168a913f74f05fbe4f7d12d5d8adbff1dcae5825935be8ede8705e84c5f7329a2db62eb9e5afdb7fbf202d00b275948a5fc4367cd98f786872a964299817c9ec5dcb54812580f35d277e29b2d156abe4ea8f1e4d5d142885f141b384074df9ba9b865572ceb2702d31d6de786d06aec06cb50a00895180fedb79daf3f5918df1ccae0b7c9da6b5de90b7f2b73beb6765e598220d4cca68d388549dcd1e115e86246127c111210f03b1dd372be147c32b6883a82e6ce0fe8b8903966c9b51ff5e5010ea702f8dfb3fc812471ba3df7573957631de4efd0f239efa3d01da15db908b61fc30a6ba4c60c1ede9b7e677a570af255d0146f208635e43a2aaca0365643923ef6dd504c41a9fc08b3a66cd1f9035ab020aacdf38d583a2ab639127b8d4778f5d45abc3cd1eab9185aa18f4a4f838c5483758cd8c2372790707d984552fda637902d5ab793e648b53a80e286b7a4d95f13578db63be4b6a455cd5e7192ff5ba38f16d0f7c310b42f032840b81b55fb84cd13e3c2548f5a06d5a097c575db2139b83f0d7af793ba3bc127a74bde3e025f512975a9ca5917f074835df16c31da6f78f31d76caaf42ee5a86401c5fb523ef1daacc14d54feb6a95ef28014d680fe10be5944e52211bc5d7e26a3b89f8eebc3bc66236dbe957f08ead616ce36e4d1818099d1d4f69fcde83f999b5e787d6de7a98d0474bf23039a7ae5b8f275099fe2ff03476760edec088538d0c8da68444b750c7dcc7979cea2aee1eedb9b011fab79fb9e4b4b7743ab04311d0ac3fae4df220602b9d5b156dbe025a5aacf8ab8287015674c8796beb73c73264bdc34f5fb1d46bb828844195785d58e45356fe09b3dfd2930bfa8c4f73192d6f072fa54913cab96760ee5a27405f3155cc3bf7e84c9c149a6d51c1ddc00b002332e00c750097e73594d423efb26ae953da435410f0adb46001180ff5bce9d8f249bb6322a59c53bf4abd856c95182eb9fca31804b527f70e024aa85a4d3da31495f64074c993cd512c91a9544ae9271cb726a1ff4373ab1df5c8add9224a5815a67084efd09033312e388ed4c3695b85bc1ff482ef3f07c9b35f161f1507b975677a32c3ff4f1ca23276386f51b97e2c05cf92bd48b8e12d59dc531ea7d0e867095add5e35c9d4dc52324de0db5abdf423789ef2accc23d63eadc302f4dad2c26a2ebe374ac368b88d4293521e6f8aa5bb440e53716d8e77cc413f86e7289a62a02378629f869e74a1f936d5fa2557ab1ed9c207ca0eb321d504ee32d5390933ccc74dafc8383fc4d30f279d1941d8e2519fffae1633aa8e0ccaf930a75180e4ec2760fed7823c005162f6890ee62d182441d052ebbb0cf48a4d9c10aacdc085ce92db998f4b4b3db266460aeb80f9e25839c728db064fdc35dfc72dd8abd0e14b6ac5e5f7c8b90a139a1216f00f2940a4c41538574f1c54be4e8efe44ed9cf9db06e0e5f44cb99f1ac0e3c1b872d3edd303b7fef966d4587ef235b30c6d6cd1fabdfdfc658f550f83d8340f07490941fa3eebd3e43adbcb76cbdf0e94d4ed89ca93d7668a8353617d7c8fb667f10d5deb9e944d7e763cb99c857e86a7f84a5bbe8722a8e93999c4e3c0ddf60c5f2c3e62be9db429c1d8e4a3200afa7d8df25b03854617a7a329b9009ecbe1eb6b44de6cf15dd41cdca6981665ce534c6da4d0fa24601419374fd68a0e688c99cdedebc09643b24841f710c1812a632859f8559520c6c7037c4e9b7ab1ca2dc87ba32535a7d29f72204a4cb91c5305b60d32864d7746c80bbecb3a7ac540aa7d3ca3336d081e48da81e323037bef419c6274a2915157cc7ba971f8bfcce0390dd439c344aed19d8cbd7fba6328e3b5c313d53d33536c9f2a82f23faecf28c685837d923fd27a62d50b12c1db1a4abe6433f568bcf55805e63ccb590de6022cd406a2d6bcab247003b713d7738bf5851c60f51fc8aff31c061c46a9193e3f7683e3b0772b0cb05f5c14d7ae988bff23fd9d97029e167dce4cc23a8a44b4eedc6cfe688ad9f885e6416cdb1093c4e449aa33d14678b554ee6fff534bc9dcf0e1297b2460ba75559ffa9b1394c105ff35aeeedaff62c9010b52459885900e92cf67d97b5ab3f59d76aa06a306d5f00a1fb4ef5014d3ab2dc1a603acfc2399ce3e3499698360f3a98d1a41dae5bb5c597bdcd451d3f2cb7845d2af98983fa58f02486c8bd4f8e5f099af696b0e124f554dc8e4741f5d7bf20dd74d83a3d6859dab18b32823fb234e542368162faffdbb8bd582625a2c04c2c1337e72a4087677fa9b17eb3c66be99f4ea1cb60edcf58f4f5a4afa595227b0da4fde58838269c3e4e0d99725e36f1967541c78cd3e58af1994df8bf8d714749817029ac660b30fa8dd0ec87762292c917ad5d5b0276307ada314236adb0df7712137e943d072bcb25b84430108c63e5afdd0a0d1cbc998c8efd0adaece7bc09aad6a5d663eb5d1d88e33b20ff8cddeb20240b398cb116d47ba0fda85d81c0b3fd3ba00f5ca9ad3d22dce844eea26fa37a207855d7ddcc6ecd8decc8f63dfc22578cdcf536225c2251556361d3c2d0172be98ab40cd1063a59a79a0ee0500a4a5a67ca46458d422f639d4d6d8943857a20ac9fb84daabfc57e2ecda9c6fe396830e4bedea0b3b8c2181580480b697ea5c34c87878eb90805e589d822c75cd49f34ea97ca87c687403cd8a07feb27093d9ae8f2a4260842da6be4843ab1140a1cfb5405dd945b6bf934278a9a5f223ef38f29a37eef73c3d645603ec43e985c3db76cffb9a8301cc0e9de1542bcf8abe736dd4ac45cf67fb0e321e4c938a4c130f818a4b1489c13a2f31baf84fb107307fa2251ba26f9a989dc439570eb0f57168da355f3f195b38513fde8d64cd788e0cbc5459fd4b5895a1159b8a575e44d8db96ed02bcab8220979b5c7560722d79ace88c762b5013954adb8721c69b45b655f4fd894429ab2b9468fba573b0b03128be2e2b2eb59149aa6918777eb82f03bacc7769b4bed13977176e96e6f1ecbce42d802311a0999c772253bcdef6f02b038a1e659d57f4c5a4b6722405d758ffea8c800ca269aeea2d39c3e0efcdd3bea84ce8a7858cc7e82d7021045de8ec07eaabeab8055e7200b730f72dee0a63acc97b85b0e9a64a960a096baaba2e9d3b53c3b55a9882bf76ad253bcb7365e6a4d07a991e8515b867bb02d7c0a3c774bb6625358ef9e830b51d5279993573c481fe3e69f66092258f714effe1213106afa43b1eb53fd455287df1bff1a49a99af6958232817d6ed6b8917a587b05067938597c56a898c1d770fa3faffeab016b83565d9976cf57cf5ebd9ff20d56c117b16c5a4987c3bc0a8e609a1d658823025489c057682f089d10fd5e756145db3873229f872fe237d4910fe81d07d50edcc075fb3c8a457ef2e5d9b2abb1b899b19bdd3556437717456fc654814d0061c30392718db3c83e5d3f798e2eeae7e690e390972458d023fd14d61821ee918ba77f48eb2a103015020b1f0290cdb92ec35ad2a098e4f69add2c205ebd81b26b02f7e9ae304e397cad4d07f67455768eb818d5e195a988f474e62037225a7b3dc19c10c2e758c30fbbc3d4ca57d35edc781","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
