<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8032a4102bcf7958e55366945ab80e24cc6d72ccf3654dd9afbe92f74cd8cce7f8c669be0eefbd2b6e58d8ae63ba21b05dae4064d13b72ab55050f0ec5558fbca1d0ed72c29e5a01bf8268431f38f2dc64fdec0aaaad371a877614e40a7171b0d3b661f033965905e059405ff62c1dd881e83685305146eb4e1b170399703a6f3f8ccc81fb304eb6723d370ca65f9a3410460058bc81a2e71e592be608faf558857eb3017fa51516c7aba1cfb546b86c0277c28a8b86ff5f1ce1faecd2796a6b2e2e5abf2d85e1fcfa2d34f2594af9613bbecc42222530e6044b3e2e3ee80851f595eabfab4aedbd216e0dbd04766c3ba319c620197a3f22547afe2fda55d2d99898ad117e3224edc238b890c90c806185214d5902244c3e2916c136d2d37370fce49e2f92f7827a22e91ca007d1af14d0ea4da305aa72463dde5d08dc2b196d58885fb2181ffed0c8ff9ce6aaaee22629f5f94e493b1b48fea11f5636b727fbc97cff0a6dd48f8a29762353f081ce54d1013fd1891f381df1a95c02238b6918c8e25f3d263acc0560cd076bf50a0ebee4ecfb0b22d003ec5dc25d1c6c251e9f03d34961fffae3dd041089e48f3db46079aac2c3ee9c6f1828935964da4794493d093f3c222d4579f04bfa56a03803be6ac9380e388dec9717b5d5687392fdd1b8d35f482607f50193e3766fc5c6aff4de3008af3de0be99a2ac256a0e122051f5b96688a8c99569cbfd0c4ea62ace2c3aef34cc391f614b061c48d783462462600a57eef0725659e0eb96e9dd76d9295a70efc6c93f70ab30c540bc404eb4d238491aaddf18ee8ecc80225532574e50c6d7a87e00edc37d23442fde3cac35cf2f38598a80d1a731b7cd5b43dc568f7f2ca6365c683cacea4efc6ff6d943fbdbe788ef52a48cb9a9fd8f90667075db1230a833ae776000bb985acc0c6ab46132ba0ab08c3d926baecafcb8c3cf317b18231451f423b6035d421580486ca34ad3f37462f278976e41126093694014a562c3f52bc94e3392d3bca6a4810a4b715314ffc6b8c75b8d8b7ff9409181d454d3ed93eab0aea59ff5d80e3fb4eed05d30ac3948d10937f50297532a7ba9e62c2fd6cf497bef6f29f1a002a8ef6b89a6de61febc838a2e35ca97491f0bc302159fb6684ca327975c26229242f56c7b1522b37441ba9d0383d31fb02251956863156ce7eab8bb31d714b6a18f100d629089372635be34dc27970012cac704115f5daded569329510f1702266741656e1b8d460a8730d9cce0164d7287cf96048f91d8de7a45e5f5ce923852cda84c2f0940035b2709726f90b77e58643626113e4306ccda52fc20ccd8d2d0b501fa8d10b3c3380c44df459dcb3595c7ff967602ae2d5c77741124d7584e4b575e691d98ee2198038c2e49f4e738dc18659e878f050320b7a86a81d9af3e241fcf3e8708fe1d2d710d45ad39ce76d76ab2983068a8fcc2921e2df485b24e2a9332d3f78efe26cfc83c68fd6fc8f9cc72e36ff050a28a7901962ebbb0893d1f2dc69fdb1f629e72e0efd3bdda4936595c485b7d8eaab8e01c7f8bfa52298bc4005e4cc23d3051f03b87719424ad59bbe2085110b9f7290741b18c57294adfa674e758c2a67eff1fa541fea661ba5898fd2f00bf4474921f6e3576ca8ae284f09435b746bd456179dfbfe76cea859e47163b43c7b63d8e3db1c276eb3e53fd6d6dae1c25d1a39cb4eec6b5aeeac675a07d436fa230ad8bdd9c1b1d71f11780afb7a2544b053c969d0deef0d6f21aea1b670df5cf8fbba1a6e9bc0f43294d5ffc88b9fdc7cb8dcfec3dc4edc47ce79acbf2f0b75c93aaaf60a50f4d74a50ea43907bf00f3f4ee49c55b651eccc45f855c0c0f36a737a08f8314efdaaf0d8db853d2d27f14ccbffa66af955e5dd40ac95089855cf9f694f645e14eb973f9655a6d83f7fdc7ec1a676517c6c9b93cb3e8a0c83b59002664aa9d92c425766a22c3d71491ac8478490622ac94cbeea7156841aabab35706ede15bcb2dc92c43e88412d77a211468751c17ea28f7b486eafcb22b1debfe662d10d9551782b2acc1163f378c7af0802d9396da31408146bdba8b80261bb4b6354ccf011a03dacb4984131be421f91231ac63a8a00ce5313464cebd62ef949fc6ab4056a85caa0a7bd5af4ce8c32c6cd6b9e6c178dc685858d32e2fce421c2e56a121adfe747a0b13d0b8796ef3993ca8d8979f7eb3bb431c1508923eb854da10afcefee3e3e7518630011a22ff0a2faa79f964238a29c75a908ac863c34ea37a8006d99fc1ac567f067a72a0f030e95593eff06ec98c027e96027bf7b39560bac21339327920dfb5dae61260621dbb77d93b9c6b61701698ec58e0f4c3a6473e5f09cb467a2c0cf07361120c0f9b057a5bad52c6a7e6e9b1711571e4a55bc4ac133d59441909c67c6a51c4d19dc90343a5c07d032d12dcb02b261a6834203abf64bef6d148f980a3a07b680d1bc4a749af8fba5a30bbc1fc65e5c8af98ae8bcdf93c9e845bbf92ddfbbb35d92bb11cb8d69a2e5daf9ff6d20c3bf48c58b797f856e11c4e3568379a7c34d2bde27aa75358fd19e581ebfa8d2ac3138fb1e09937df61103c13bfd28685ff3427a146d57d22d0d3df0cbfc3d897c289612b3ae1ec51d7ead8955ed0c1785dc07af8542838d9c0400cc1f874ae364bf1231e124e2f4859a4200d2ee0c4f3c3a913d48ef3e50720352200e0fb9ecdb74ee25d7cc1ac20cf3a0e0443473cef32be222bc9c501eb97ff6dda42f08372d7eb3ec3af7b18cf2043eaa428587ad62ab54d4000afcf622ab3bdf1cc6f87be334ba35d1d278a434d02214bfcd65b21b7739858baa6f9e18023f58e5ab59c3f9b9958c39867f7213c6f025caab886617b63a40f3831ce919d2504a4f25ffcec692c9d7ca2dad43605a3d8a62a82a6ddd04e816b98dedfff2ebe8bd3e10fe4aaa70b543259396f781f2281f7f1e93fc93f0f463c4a334fac58d89e0f85ccac6e4d75c03fdd82aea7993162e1fbe60c4fbc86197cfcf432961e399211da824521f3dd488e11e43210893d4a0708e66d293cdd27daa014c12f73946509500dc6c4c920728eabafeac665d3f02e43d763822e0dc12a9cde1b922de9bfcdd722867ca5d6d0bd39bc454d80232253088d80f5733c2ec782e8f0a3a7bb9888dfe8b03e7c4ca46b971b2e7f7c6aea4b06e4a83903471c513e4965f77b3beb15aac7c14aeccb5ef2ffbfdb46ac459afe12fd011e0eb969439142ac89c9f51a9a92aa5d07df85cc675b644dde28f9ed671fdd7192bbb6dfb0de8ca0c24643256fc275e7baf39f03866fdb7abb3380a15badbfdc587ee8906a38c497486a285c6c236974c50bd887d3adc6f4317733df0063d9d9552400332c65a9630cfc176f8bd39a0608880582b0ffbd78d50a50eb9df48bd90c17ef9cf0a9516e685dbc23b6a4bc82b7704738daf7080d01578078c18f36b4decc7e75d29651e9a25a2783dc6e1c505792c17de428b79954d0355340329bf65c73d5dc021215ebef6e8a9a6f3cbc4f4e99ec184d96ddd6a9578ed35fec2b2b8b3342c87f19cbf3cc405510ce2ac073195cdbf6094e9e74862b5b960788fb4a04237e623686250fb2b741dc1912f6cd8204180845ee183d7c75911354a6c3af830bc3565df247d906fbc46a4b8da33bb602469be7df4125c489dd9dc2d0795dbad8110e43476bfdbac663a0477ff4c94f11c62e1fc877f1608150da2998bac5f00584078ed1c3d6099c68738714e190bed2fa8cb1e93af1071eb187b2d72d463e523a0f3bc8353f90c41879884ffd38a1e51394c417d5a688a2c28588fa62ef48bccf27912167d6a7095b58fca7725879aafbc79cd8ec9b4bae7e7d64a1f889303aeec0611754d61eddbae460e0fcc429c0afc60547f8dd9173a1efea2829b6faed18909fc2ddd97f1d169c78231dba1cbb653843c425a440c3f06fcd86f0b8fc4d0e11c48c8145b6efa76ee67b0797ff58d502782f223eb71b97e6ede94be20e209d8aff3eb88b10e308a63a028d6f4583583f257c5b20665f53dbd4a05c92ae55f0d32da8f7cb33d30e46f7307222af5dac2ccacaefe9af0cacecfdbca80df3298e8616958156e336fae153b9dc4e3f5ffeeb5bb2270d1578fd59da48e2b51e8aef7db7ace2d450ef468b87b736658ea0c6dc0576fdbb835df3e905f155fbc24653d88a67957207f9188eb5201f6986026f0aaebda7887d6a4b895768e2f827322111cb3475326e76a2d56e044a4f202cdabe412ef1603bca93313f872e592cefc492dcf765fe569b05f5122dd798955193ba37b446fa4151a9b538c2feabeb924255e2111623f7e92569f929fc6a5d284080146080bad8e6df7e83a1f98d8e8b43a16913e9b2d821ab8279dda1391ff9fb5c4a044340ffb47999922dbb9b92b1c2fc5da7a69348d94d29f1a1999f26b9e71bb60c1360dc03b9a0f18bb1a039a43e08a0f3df4d644c95d80c6b0b77d9e28b2ed9ecf5efc40d636e622c1acff26e8c4a36ae9fc0d2ecce4d3d6948a3cf9f979c9cdd9a1492eb0310aa76a2486c52da20da2467cf3f236e2bc5b812f1cedd8d9bb1d1907fb452504509470e679d775758374d947e18f814d51b94a7ad7b5ed7fa72f0ab9d4aba1f305cad31f32aa92b5330a6ea2589a6c0c9cf67c2064f90beaba4801861b0f92468958af7fdf12d9f0d26ad6a362e8329f7b7d1296c763af87704a87f9c040d1ccbd7bebd74de79699d49e8e3215c5f91738e9d2c66613cb2ad932e38be4140c196367e6effc032c0d2952e736afe6ecd26bb7ebe498fc0bd3cc62bc39885f45ecd938dfa85a01104729726aa06f158a76195ad2b322b831b313232b7cc2e5dc3b41f244318e6cf97ca000aa126a6411a698305e632475ea64376920344d1d2d064efef6735f1497a4d9f3a1a8765056a47eaaf86b714fa9c3dbf76e5d2c04cca6a3a0fc1b27d72e422786a7be1702a268bdaddbc4b1b4ebaff64fb3229a7e2769ddf6e6e42b2dacbe3a2566f096c9e7e6e1cc9c743657a33c9b9affce59c3ecdc9a656f9ce7666f4df18c68dcad79978eb1b05aabb95e7d235588846be7b3f3fbb7d7020337e3578b732040b4503bc9b08c237dd9da0c9bf7aad4b321d9d8a933b0f685c073cb4be83e8bde5909e21b44c7793d38e509c4331c708b840f4f14285a4858b1f1b82b8c3a203bd8f86bbdddbafe8805c1204f5df4f1a1ef0680f99b2666e66bbce1fedc227ffd58fc07d5a098fac7ac0f19651def5768204e53b152f40d1aee530d1fa01c49ea42a166350d9923401f44ba634a624acad826c220ef4dd9577e807d3e2bb78b284fa31563c1c819a8ab026f14c5daf869282784288a09116ad28cbbc9e670dac72ee179e7304f2edd92ce237fb22fc9d56098d486a121f8b4107c184e7f6d6d3eaf9f27c20dd308cf78965fad96b68544b0e999f10a1212e3ba82b5734275e040844776b5a154d2fec7c6e9112fb342715d69c7e0bf816e2fca921ead730680384452ede967975adefaefef39cdc9f45bfb36cc763a252a3c3610f3e289306752e03c48d53f64a760127f7764e16b8be2c395234ad0dfa9b830f60944f65def2abc750b9861de7082cee966afa74259351a7cb3925ad7508bac9441bb6c54ff24616c56c8f601fef87ad34d693eb15efbab29e421e4b57c146727b348247adcb0ea45e97106c701a530eb2810c0de8a9af0a44d092a939c5e75bb7da65f2f801d3bc6f3037e5f89810ac755aae0ee255c8b63090408e970f4730b8ab4073087b2df28935d9dd0cd43717282c06fc42a5de02f98ba5627dd7a5d6403747ffc117e1c58f89a29919179e0b26d297ec972ab2908ece00749fb5a79d4e1b28725b7cd351b43a133619dda550ba1e3c1cf81807d9fc319b2c35d378efea4737a2588436c9908fd149874e810e47db72b3bedbe13f85a80d263a3667b35f80bc19069adf0724423248131d1a0db7a9d6d97951e8d58be92a7046f0a5588326a37451d4d40d89e3ffcd4dfb89b03c72cfe2334ffc3b8f2fe63a2cee4e615be6785c554a2546adece7f2081cb1729d5b8b1811d4dce52a1c0f45cb7f634692147f1af796c4c7bfe0d5a985f82b46cf6693b30e1f11769ffde66c9cdc123f6221f5a5347e9ef83407834b290f39b4b544f3386530307c43b8e977b2fda7e69d4cabc13fb668b7e5d2415b2a00fe20da795104450bcbc9c391a1fd743dfdfc8ec13979c274dac4dac0cf361fcceaa22e975785eb0e5052c76b0f9a460008d450d7ea54cf39cf0385fab84bed7a925c74816d6000bb6cb330f4ad0cbf396cd116ec43679a326411c59a49123af1d6b9c98968d5b4d6313b77de1f3c15eda3c8e9d081d20b60f4ca2da9d14fcdf222c6fb3a6ca8776a79e1508a459eb55fede0a64e34f8a00acff74f47ea5b7e4497408e1dac864819dde4d06c1581a67240a3279b3e74dc09b5a2240ae3bc5f8c34dd6788d9234ccc695ba94b8f8c8c77412edba90a7311f8b4e7e36cc7b8629730f0bb0c4183025a241168236afd64a235d77ca217db09b05c1605d433be1f6480b299618e505223a8ba8c8f9fcc79c8407bdde2d08fc62fa9a9cf5c3e06e63b211e3e760c05b280af9d074ce1ecc49462dac79820b749d71632f786e07e5df97ba38151cf3b8de778de9ed402491bd4f97e874bcd0b01548a870e056329020ca8220e2bb0f384993bbc46ce572819c29226bf5f7157d4476ecc43e279c8ed5cd378939a2f017a0ea0ad5b6443f215855b226e54724e62bc7b903afae215c46feb8d93f0aa3724528f5a7c323f7846bb4498f49931b130f4c61d3bbe5d21ddbd082ef9b4c97225937c96171505211cdddf607b2a3a0730213dd273c00cecd746f311fc0cc03e4eb023b4d99aac792517103edcfa164004086643c5fe754f8b1d9653e6f311d4d0fca537f8d842372ec2edc8619b2f2d9ebfc295c28b76c7496f907a9be000c30f640465f6097d29d334a8d28e3ceb320f682b0ea8b5dff034b59f233db66fdb1aec6011e007ec167c4fc940f4d5253b0e2bfd2d27d5d656a9e5cafe494fab90b6cfc1b147938e3a2ee63b4d94903685726ed4b4684a1fd110732065c0a4386b6975057a6cf177a3b91c0d23acef179a2025ac80ecc0b2d5c0c8ee0a90ab2648488562923b80575a744757f8f915996bdd73830d1050b0d7b0eeb3b3ed40d5cb222a93b81911beaabd8f0269426d0ff9bcca211ca9c4d3409fd02e1cc654483fea0565800973419b39ca99e52656b3812cd8d924706d1375b55fa387af146db67ea5b539f6883eca93bb8b0cdeafe4b9c8d3b45d307cd07021aa5e6bf7d571b02ac71c35a6ff8991312db454bf88027acf9c003941bb20f299cb8ae12242a0f79ecb76a2d4142a3823282ee1c7d8daec1172b353b4f3aec322f3d014e499f9cb5f25c00ea956319d1eb54a36915c7a98256ee97aff2dab34f8166dc6dc8dd1ffa62cd9acf10c091fd33617cec03fa547ce356363001e5d2aa85085d43ed0bd308c84ea0d02caaaad3e9457017b983da83ddf3327bf642e7eafbb6ac3900bd1f2ac6f00d4d0b35a556380aee5cf77f9caae41bc27ffc741010b79115bb0d0e358b7c40060605a38ada22b01d66e6242ca549daa66efd3072d17d654777506ff5f493110f55fb8eb884e3eb26e9bc76b099a783e0902f1c17d547a8bc27551b5af91909403f9f783d48b37d14bdd5fb0f92dca20f4f3cffab33813edddf8cc568502f00333e7700f85574482a5d4aac89d6470516d78869b3bb23dc5bd1b7caca9baa5a3e7b1b8cbfc6f8e813a3ef90b5c495408d09dc01d08fc2d66a4ae01d4dee2ee9e86f31a7dd050b6186ae3e9967e102ff5b353211e6568ab008d9c08061b9a39bb7e036cdd43c574be71ce270936aee8193ea38e0c031d612e001839ea27ecc1fd3e83ea9966eea59432ec35e5ca1f1f4532207818fa650048f146e1da691d18a6f2d992611d508e7a729eb66c69a2a9cd2b364ac484bf7cd9dab26d37e0f3009e68bbe66546a23395524d5ccaa42488ebee65309f17c3308fa91ccdd3d3b27eeed5efbb363ab54216f48c2781bd2827325e99e7a000fbd2de3aad950e86bdf353d5e695793391be65c51fa28e6e1f389fb24f75927a8960439672c2d23067bbd5306a7d9a63abba207bd2a83753b2ff9f0ad1077316b449dc2d33dd68c25d4a6295c0e724e089e19d215ca768e4e5e80c79357b17bfa93ce141d482884992558f5389c8d6ef2f5083b80603e943c47384c930829a3654dc7e0bb2b21249e9dc4c45eb4d6c8a49dd5c11c4a2fd3cb06a9973826ca843c03f6808700f886c69b83a496273695a2f97c283c90f3e276f6fca4c45598d6ea395ef1f44cd8a36b18355dfd2474f2c3e1c26fa1cdf07b233a65e4f59e4fd78cf3ca7c29a34154c00c1a3f6819dfabf5affe5484902fe9d553ce5fdc16334b0ea0029d5677bf7ee60da24a0efb3936144c7889c4981e16473e20a31bfb606062ae18f86e0db57549636078b1f888d1cefe75eaa41c7923d668bd45d7d6e8397c63b03824e63f2a2641580307779cb0c5d05c3b92384bec47524463e66ab4ef3762adf0be9c9da264613fc672cdce6ad87377fe700571055edd58ceabc26e8da6fbd40e28959c37f00e91f38f8676ec8b93dabe576edc11413c4211c6f6b89ae84744fbf1eaaaea0c3e9ff7b6af3e6e6a1ca094ae21123a8bc7892181b10ee1b5f623dcaa80f393bd1f828072f11b8032db3ecb0d7d9501172952131a5d31738a0f59abb1c6bb17a7df4a132da6671d9bebe244f54917fca794a553a0dc9673f6f234ea207ff1c378cc14de1b8bc7071e947df34cb800bae23a3119a9ca65653b496294344aea80906894bd7da75bc64185585891799fcf739ad5cbd25d451e1f181b442d639a2de6d32123e20b4c676ee4a18c0942ec974505f7599663cbd8c4e47017b85ea859f48f2a1c35402a7d3ac31204bd7595ef465fb0182ec1336234cd53c55baa18c9d2e1c2450eefc4fad2e89a45a85fff378c9d783b73b0eb03e86c4070b37b282afaa23b0c163cf0cb997be06c9e36a52e6d7732bee056b17b409db18cea6331b7c2faca5a26d30fb80521770122ec8c4a37a23d8eba48e9a80472165fe579343483a7369be2b0733e8b4a80b5f35d759f01939efa62e51ccbbb00ad1fdf6430cfd2c161b01303b8610185213019f116d72ee988164af7f9b2c3207a844fabfc03eec06220438f137495233938ae9002ce60e67efef3ac474dc4229c41a72b798b36fef6286f7d2b6ff71d89336129d41a4e5cbb864e431a84e68795844e70e7487f999e090f95837a5a173dc247a14760dd40819b4334e65fcbac007db2cdd993d6b2cc916d7914233bed2f118564adf8e6030de2ecb0d4be0267e3f815110278505a02a87c06ca39632f2820150edf66a9d02bbc348c032ec27057aa0e0378b0ef80d3faafea593d3ba4e22dd6896c7a87e8d31e1e4b984d609853f7e322bd676c6360aefa86b161bcb378260e59f8417e975bcba924f612cbae7341b8b884c00d9addebd3623a7ece895aec98a4a0786e4b8351ed9cedadf65e13f884647a9e95dfffad9ab94ca6021cbf282c6f44a68682b63f02bc3d8c0b522cec2d6ac50216070f61271a1e83214217d8401c96b5ea89fc68283deb718d669d719b2a5d9055c78b2ef7b1062f2c26f122ed7c8809b9493f2696beaa2b3a5e032a968abe5bd12142416e802e2ec7c92e59900ecda51b9fa175d66eff26158b301c94ed800a696659f327e4270d83a2796126d170e64d1c21b35df224712f4425020d9cb07a9603f3cca3943e9dfce84777fbf10ea431bd7d21b53f113fcb5361f1b5239258330e698ba97bec2e7ebe7581df3691e00152c244794b6fbee4c50cd9a50ca2fb9678ad7f57940ebd53d5d789d00610239b735e011e434a372e300d15d0f267d3d2247cb25e82941c14eb443844b18db629e728fd9607e8e29744d3cc04d10a84147fe5733b14e7e8ff5ef6257ec4e8e898a0b77e076db744220ee6f8efcd44411e0f6fffbc58dd9aa964dc1a898b5a071d7c37c501bd7005140c8d7ad870081012d677ad7ae0e4ffeeda8a0385947b0a2ca9ad6b9516af6ded3c821ce2b820fda14b7fdf6759f3c878257a76e60e3dd82447e15b1ccda4f027e5b872fd585d36e8d3c0258636d8523d129056f317a2ea5ed98ebe0e7f675b657eaa980b9cd3462f43279d23eb161fd8ac85b669f3e252160d410007f5777e685c3cd217b0535d369865b1280ad3b04024f74b3fdc96d4ad72994eea588747cdbbc019fe428db9c2261293343efac272e6832a26c83b0cdd633153f4365160bac4b90a7579bb6595bf64ff745c7a88b21cee5e3f888ec68a96374543acdb7ec43920e02f833f20167ce0d10c83a09672fa6c95e86a255054b4fedef6d8b3c596af409eb6cdf0e75462ecff3ecf73ccda851afee89fd20b9cfe103bab9f0f0810f0cfe832508d7340e645c0608a6d6f3a9351b92ec18fceb8a08064ea2bd08108ae6b4f65d675aa6431efbf600e982fb48d18bd82fb56de0e6be266aac027c882785c56ea307122cbf258b9605ea482a0f62991f85a2aa31c1f7a67a88b39375cdeea71c560d6d27fb8298622b9b3a7d7d5d460b70cc2e1e77511c05ecb5aba7d96e026e5f6a7c09724ef11b3fffa801ea78adfb8d0eb6f3d910e123791242daa07fbbcad73e251d9c53046bba5da0b28821748482315c684996d549646e7ab6f41ec31efc5d60729d616eb7f08e291e20f2ae8b0884eff9b33b15f241eee2715a73f07c7b7976750c19964175f64109c5e8a4b3d19c7f0966998045b6718c971c4fdb252cbc647575c36ad13e7a7756738cec3a1a1b0bb9797b89a131df65bccb3a05186f67eda02ad949a5c78ba3e324f789599698109f7b7df2ca5e698ad9b540a37c3bfc8360ef222439fd81faeb519e697ca1946518b83d473ab713c063280142175607d7e4b24077e6f7a6cabf7d238f14bda0feb413fb64d66d55d6399ffe1e0df39be3ff229940f27a778e6d2232a30ab1fb5688fa8db3e0404f559f8bea13b565add3da851c6899e822f263d422b305d34d81a8f7c9586d799520234a0274fd12200da6a148f1e4b9cbcb1e6c90162b69199340fb095b70b5d0641b6a55edae40e3bd0243dab09842e531e42b24cc42cde02d257cfd8a54064b9e59d403016b2309504e6faa17076adbeb7c65d6aabaa0433cfe19159da2a40dd4c30b80ad08f55194a870a1cec7f9dcaaebc708108c2c9b5f26796f05982c7408133d38113807196fd9190b76efb5d709a277a7ff88ecc69bb3ce9575d022add6cdd24fcd6f592a68be33d75f698c687a15541b3365b3b77fc09fa5c2af7d9bea71f469d6e153c3242de48fbf033fe51ed2b817227abc4734591acf42e6a4da2e25eb5a4d6a1c21239dcfc6a99afe41f70967ca016d8963d8063a2eab5bcafc1bae2d76357e47631a877889e888e102de8d161127aa71ece10a62db14b09a31b1856c616c0f8508a96797ab496a08586f154188b4aa57e3f96f442cba09f62006e8fc699957c74a85e9e8dd91b6a52d19a2d65f8616264faf9b77c4b44ca5f5bbec2beb067f76bef636295e575a9eb8277fdc4b75d9fe7e155a34c71697be3508a8e5008d17ee4968cbfc308b1e032ce962d06732540f0478da08f92727250c2ff29088c96a81ea659b27a25b38386ae9f4aa0870d61293ed87be02f74134f0850efb134cd19cd845a84b7293029c6d9b6a91680a6dde76674bbb70517caed9a740298d2b06525782e4cfe0e2325413df2d196de00245f01451c93f48922b200963b511d6eaa48ce2eaf4efcaa3467e04b24271e64f8379c8e8fd5fe1c48022fc1a68fc498dffdfdda7dfeddabfe8a53646fbc5998e90574abf2328b4c73aa9ed3d7e3f9dafc59d53fe21b8a0a8a150bc8d65db770834f95e873c42447d81286b630e0ca129f8684ca6c94d93228c9f8ae5a4bf8abb38b27e1add0bcac2f06ae9bcc983aa55b4ab804ee721325feb1c9cc51be6d9d806a915ab215272dd93144709ece02dcb4c9d882c3a07c57978b1e600ce8f110eb05858372b5f0915657127abfeb7ef41a3226b4d369185a8dff5c00423cb805fbf2022aaf469cc70cf6a600ddb471a6faee17f30ca41baadefe8bb8549f7cfc4f99aea125ee10f643b34e9bbbc3f5e68bf174cb89db923ad668309c8e7ed5726ddf3f8aa12f4002ef95dd988f774a0e52fbd36cb13f920c2961c6078fa2c8d11697ad351569dece47545924ea4f24d23a66017f7bfb7e5110a19ec2bba101c8799c1180cdca61379d3319d38e174810494a4df4bb101197cd7f2215bc49fae28efd99da55047e864bcaaecd2ec20ca0cbf5cd7bc33a6966696020253047c6dc9a6331ec10b1088e8941a9d4ed7bb75c89827debb215a3dcc49d8405eb7570b6d46099836b0eb19edb5291cf82232c844efa56a7a3fe9c5bc44e9ded4bbefd31b102fe54b4da5f5fa61f68fc55deeaabef4767508f1db34054a0980248867e21686196683d13aae069cb903ab435169ed25b0673fbeee2d758a15fcf5b541f7350f2e1815c7062acbb71fdabab729c31c7cc36b6a7a98a38f9ceebbed5751b58883bef80b17e5667d1946d8d2e4a8ccd53177a11aced687c9a57d4fefc02e93bf093d051f9848f420d1caa35a0ced91c5e5d9ebdf23e1c43704ff9a00088f50a81485a47fff1cb4e8d7d32a17985e09f3fcecbcd015294f585125ca84c53c47b94ed963168c0427a74f00c5544296eb32c3cfea75ccd5d608bd6a29ff5029a1de42280b46e32ad17dec678fd91f04df840c6ddedfab08f903a294a7a63a01483a1ea182589c9e75ce55eeb3055cebd527ec842d56c453f1e06349b3e20cdfa883b4d57d16fa64a41759a4ff981cea9e8e81eb89fb6ea6ea70790919006e5f2356edd4b28bcbfc2bd929d22b6979bd96ce4e281e03e47d30115ff382da6b140381850eaa377712a216e16bc428990153dacf0a231f5ffa774118c7d800b627a85389ba88f8ab1238926c608dbff2eaa9fe03dacdcf6d8bf8062346307922091e6e3b8df4f6d8b6d6bdd220db5986a4b7125a29f40dbdf05c9dd25b17376f59dbf5459145e1e29a2d7e14d219bacff338089adb4c35cc2398f55bde4c776e3eddb7de60ecc0124d2cecc8e86c93980ef790f88086e418ed3b1b60a37df166e880c474753b837f3f6495cf99154b2609ce4189eba8923421a1c38b7445b167a5a8daa8dafaeef735293ee00e6823a699432e49586a902e3808942fa178adb112f4e0648796c9fe8af83bd223d40bd4def03a8df2b0b5c26d69daedb206429b4fa4d21e8c58b53733c1d9a765df144bad496adf7f9dc81a3a8037542f291e1c7469f8ad0af9256820af08396f529e4b92535edcadfbd3d389ce0dc16f5c52dced2633e19d39fe48b1b56c4627a0ce1f344c8cbf6c7971888c06ff55d90414ee261cd7884c82760a986fdee9a3a092479fbc89d4fbdf8aa348ca50939b2b58bc096fc5c68379a5e5413af9e9fbf22a05c06fc77e3d3acaea403fac961f0211af81d1ecfa95a351b67697032c19a7574c578d033b8d79d566337228ecc998152e2a2119392d8997060833b2505a6385c76d392c2dfdba5883a9087879b176d6f5a9d8776b2e67b1a4a34711599e0b266ab5187ad0e353464cdaf94670d964d988beddf5d397063b665a0b12c6a6c366b260d1167b1d30080e5e5626538f78aab1bba965b52ffc239ea11c5f71b502881131ab1dc103a5b590f5c66d38b0e75f568728a5cd462c029532cdac9a5a707595b178fa5d1c7192e9c1c5963d95a376fe1362ba37d90c6afff0826e1e22fd93a104811bc379cafdadd96766263e98fe1a251e9aa86665c363170899ee0b29b44d7b669dbf891ca0b6adc4fc5e14c507fd7a60de59cdf9bd6c0b3ae72e35d6fac3e5b8c5c76fb87b0255b23561b62cb98c428f00740994f5ea193bb9d1bdad71c9af286d669801aa3bfdcd2100a5e8ff9f289b34abdd955e4c114d6556858dcd6981d4b28bfb5b4240ff5a4b09a0979cc1bcaa56ab874b8fce344b2e45f621dc0e0577ddd0ef9487145afdaa7c38d7957879c3e89c8c28ae9372ba50dbf784b4f5b53693f51716e1d53030364af658fd9ac404eadbfb27c1797612a859f3fe6a2f7ba33a9329ac16973eb349053e8ff7351dbb3e35d50488dc23e1118b4ed7fec3a271496b47614acf2f47622479dd0f048af94922cf449bea9f0350bac86e7cdb64d8a9d921482c31e182bfa2e65b492b8ce6e21413e00a2fac505b55369811ef7beb61b846f412378d8bc70d1bd74414e7a218b0ce50f38bb5468b8a9bae580645df4d5665d2dfdd017ee80c09521c94ae2b07d024adee9d621c63f465eec73fbadc6740cea779a29d973027ff2b3fd6ffcd302f03625b03b8f212433ad42388e172ae1f1933dd09c218f694b20eb0a4b771fff32f7282c71fc2ee520af1b546a4225f446230f951a63e865ade0d75e34624ebaac1588cba91420f89351cda8856bcfbc4d970bcc8935b7f229c2959782fa7e8d1da7d91097952eb8ee1b71e0d036ce1427993d20a5c18825429e48475055c4b410b61242214f6196e15a94b9576e41dfdb93ba0012cb0c5f3a8b2808a343971aba524afd4bd36d52e1c3485d2375155788e13ab8812655042a660966cf228b83c4e493118f80d3749de96e5c5b3879591fdd21147ec0ae1e0ab8b14dd1065d096db18f93a2eca4ce4fd5d234cce6aee90865b2b36d50c14bd105f76ac095d294869268f33cb07f475c63831b8d309f349d9271e65010f38e756306b6f96ce30a3a2d0947b823936a8c3da8828a9a8ac06a68caf706044677303e4fa150182412c1febefb31b1f33b7b7288e6768a4cfbd0746caddf6eb52350a49fb663e61b6d238f6bf8a5a580273dd7e8161f7e085f7a3d07099bf387f769763eaf88438e0a8bf00995ba4cb8bf99e6c7e662e792f6000185fd9bed6e5e854919f80c3f786b69b8087801e07144b4d4d8b7552c893a793e42ce216a63d8eab798906ddb247cb6c473356ebd91a8e9005181585e27c09c95fdd0df43f2380660fa792b6268cc5ac1011806282a2f68bb4800840b83d0824f6723083892d805823b7d05d591733901d9aaf24bb5a2cdc3b39bd759760ea2c539ec9152363408188ae0098b8022fe80db220f5016f5ed31f2bf45046e09d0c29b2026466ced7dfd059e452675d05c1c9c5bedbbd8de877278bcc2166043ae4a493e9b93e235898d4f387dee9e6c47924f0988cbce6998968db93c4100476a6653b8de854134b49b85f6c8d730bcbe0fbb84057ef948805761b19859d78c29694d1ac81bc8cddbfb66e219536ecf4d7faf7f9fd90db0f09ba871941e2ca0720a31421b57fbdc60c5630cca959048a492b6179a08767b4a20633a592f61adaa1c8b6a57d5a4b2a676905c8af11469fa4f83c42ca442ca101c54924384c0d205a0bc360d04555c0544850cde770d1960ffbe36d61fa661d9bca3bf7ae2d059ef973b92536dba6f8c5f83306c355c5184ce2216246730f505848a748cb31379eb3eab5c08ed26f410d32fbd26108cc44a776ca67342ca8aca8e7d2fb5c2268ea6ffe61d185e3c1f07ec0bb32ef54898cdcb7e04a689bce1348b1d0ca12017b2382f0a629fdfbaaf806e0fa07fb5b2b927c322da3a2f6579ac76240528c1d84bc7385fc73c04ef0b753404fc8e32ed48c56a6ba8d7c7f5e2d968c2d6afce9f0a7070317116b7e47f69e583bc88fa26beda4f9286ec20dddb510867e263f1c203033efb883f14dbc500023868c4ef0dcfd9de2f27a1a2d370f98a055d5007c3fc20458f45f5a2dde15b27b48aada624c6c3a4b93fbd07fd23687f5069dd4062e1bc1b470d8f9cd5b2d940e01244d4c333c7750fe17bddbadbc66a817fe16244b21f2a164909c2b5b74a23183df645dc634abf023461b238ac60061bc138da7f3ace60e76b8e82bd9d610d53ac139d71e7ea409d4f726821d4b5676812e3a78d09d9e4d530a99fdb587d87fe1fa30966592af5f285f68afe3a521bd4a4a75c08f1fc214861735da9307d82663e997db0e786c7f516e7567e1c41c19aef11682398a67232740362a7e36e83c75291926f38c2b1e9b7157b9fdd836a9026954625b4e4dcf0bc908fae06defd2d330f4da3e57d2debbc44eaae808fc0daa1e67ebc8d51386129324c2a6de05a33cf8dda438c69f07b040aaaa31e5f7a24aee41360d12037e9d987b59b850ea0174187471ee96e5bb7ea15b8df697bb7f6c3afa05ef0a3f75e96999b9b327231fe4eca3b7a10d7a46b6ebf9c9303e5538ea38d55f9f9c09d335a462890fd8e4e665f2025aed8e464e8c115bbd6e57dc36bb749037b7eebff7c062592a5aa3c91f0ea0da4089a26367e0c52c0ebed496d6ff0ba9e1c401fd5e42427f42bee734f623b298c6cd79b4345bca9c2b57b36276c6fd33931b4c8621f5be55d82d032930b9cfa5fdf920de6839ee3ced7e35a966cbdff5cc14081df7e2ca447860839452f4c72b5cefd782ccfdb36c36749b9d5203a8499d9ab4326cf2675ff979d83645da90cabd34cb96e6d0a6933da8cf1435a5dbd248a2a1e3633fbfeb1cd72a407483e0193b467001e071cb67b17afd0eba97f4d1cb395d441827431191cf48936362eed483c52bdb2bd856b21fe5793203a2763672a8ec83b5a99e9a40fce0ac8bb68bfbb0c7fddf00fc72fc2adfd9273fd8e52a03fcaeba667d82a7aa11352d43f689a4ef71f66976acfd9afe6b0320408ef950786b2f13935f0f34053a730b2191d0100d6ad665aaf42b66fa6cebae02a8bd29908eb14321dddcf718f6b91db32850eef2c385acd2876556dfd4f2c03be05ee5d44a0ca58d250b9e6b343b90aa4b20b3c9f8a857c43d143739a6b95601f0290005ceb33c81318e494bb46ad11828d4b6e92bd25681361625a6a12eea87c0f93effe30264b6922a302e4c3e591e35002d7d56ea1d53f2c1f74fbb40a995b52439f2f4b715dccaa36c8873fb0b2a494da32149f9a67374d05b98b93f262f861c17102717f05c1cfc3eae9da887c9f10a026f9540f58d816ca6da2891d1aed0f9686c4c34bf169c65ad52b2a147c8f6399e76e4208918ec7f884da8535b2dac2092e5d037d185bb9891ec65a1aa133d976f940be1a3f6159834c1c21be6ffb1afd07b1997540241e8b04774e183cc909fa1dec7b6442a3b0d35039bdf487d5c8fc7922c9a156e810ae552657c8f85e7f7b2cdf74f5f75ffd6c6d7c7ec3fda38b2339ea0856331ca67c00d27e0db83b52e39616eb76d564005be96a033d4881ca039e05157224ae17d1030d61342c6119bcd53b34ddd50d990c3c7340f25f32bf8b9ce314a9014889fbffae8ffeeeaa046239f69acda55f50103af5097e00c7d4280068eb8b8a7758d75a28c2bfc37e88ed033756dc13e3ae0d7e8b9cbe50031cff4ce60b9f6e660ec2de89f3cb1f341212f17bee43c7de9093e69212c3593bb22c73bfad73e2a80935a50148e25756188ebaf6f05d55643a49578a9e7514cd5f16a6d21660a8edc587cb92bc38f54df802668de08fe0632b6c033884d3c25395bf8230dbe8f82de31ff26e716be03fd2e57c84dd67845899fef6940d239bb0daf620a2738de5052d88f11153ab998687e657c234c9df841cc0daf14d739973dba4b13238b9bfa12fd4d0c829b53936de9f2c72ada790316da4dd8c288b7ba66f236f9195a90eca32c3e21c2ef1af4c12c0c59cf33b9fb30bec15670495ff90bb4b456971d3ae270d22df14e07e0bb86e7e257cf63e1ce9a5f4c8225089e996ca69554fb732d16041de2732501e0bd8efa6527295892eb9bfa6c0d9fc8f4f7da617f5931793cc6feaf1bb5558da46dad420810faad6b692bc15bc410cacf22b7c69842ceb07b0f2eefb35b268ceef4e1af83171f4c00722b2017f0c17b61929318a3ca8036902ceaa22c73894e7af82a2f039b91622e45f9e0d7bf9800dbf9b549032b7901d662bbf6bf5c0c2badff03da0f052ab40db25a474b4d61e429d4f21f869b9a84a7d99d6420d273636f332e66f7cf0036afea1d58696d492528e8f4a11d87b3c1e3ee1e61f578fa46ab0515140993eb33cd796588257bf0cdde22b5590f9dc8863d2c2d09c693d8e69c5e795491d6a0e3f6c77e36dd7a2b882d4f176f173c9cb0d542427878d88310b9b24fafbfcea329798874388fad9a3448f94f17ff55c9ae84960bcc0296164845f900a48da38b9944bd4c43b0dae64c7e4d43bdc5ea0ff24b341ce5a554ed2bf96cd0d6531ed4dd4837d291b641d825701fefd6e29b23694770a1647a4c5e94642c13f3b51209941a797bcd0acb91","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
