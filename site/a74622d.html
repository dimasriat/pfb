<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36e9cfbcb7257755b4f557d244638b7474bc52bb5423420d5cece8aaf2785f1864f44810e009d6f7762297e2171b07865b1a809106d2bf8c5627420f0ed03ea1d3e2094de48c0b2b53cf694b31c4b339590c006b147c65460bd47eb3bda5eda1bfde3f52ae731a75b673c684c821539a6e79c1845ab29ce653ca3741b3a5100e6e2ede402a7c754cfab38ce3de5d632d466cb379a6f69d98f22457d903471cbac68887421533c15e846a465df2390a4a3d65a24563cf411be33067b6b13ee0fb69eb901c86a0642781722cd38d86648e272b6de09d0b859e5c35a9697ac50906c1501f72c4bf2c62c66f5416150922c3fdd302138849b1eb41e04d3847f7dc5c16580370325550bd448a439bf566d2e0b01b1acfb8efa7f6a0b4159b2c41ba8c46ca5eca40f4a53ea1febdc7e8c07c2375bb84befe01f61611f308c57f97088fffc91def3f268ffd4e7cb43340b57910a12818a355bb4c60d1f2c789758242081ba1e9a1c456c772335823d5c83ac6a3dec724dbeb2600082d448846b6c5679fdc61f7225799b56bdc14130bf22d4bd73c43bb0aae9eae7c24237e74826d69355d2553eceb845686fbbba1206591e598899071520beb79618e1ddbb67d0479630b04b475c58f58985a02b2c240f2b15fb433d68d02b83b45d6d471431bd29398a3acf2ad4dd6d572005ae0815c32303c17b3e057ced22d55786ba61d07cb4dba3370dbd64d39f7e803d799e91e580265042158df1dacebd2d5b5e176d692c44f16806ffe3cdef6456ffdfa2043af3605415d5c412524cdc00e495017e1798216db09231b7e7e05bc64ed2e6f475f799ef47193b63ab8f24f97f5fa442c4bb5cc979b8aed85a336c419ff38225790c8e7f894e3d71794cd5fc865d330139b606b79d5275d5a8f5e8b40f618b78c5c80fbce8114b126a032c5cce92006c094f6f4984cfc87127ac0915b22bb5ba3d282678ecb1405234992a9c8140ad8e9a3783f10402180ace8fc590eca9d8a56f7675483b3c662d126f6d99e78f5b2c1940fd84dcde36262fe30195dc935705cc211068e5aa925ae6f6c290ac0c5c83d45d8443ffaca79a430f5133255b18c881bdeaca13aedbb49801a50def8d715fbcba81776e7ce9e619811bef821d09dfeae37e911c097c7a76c4ecb8a34dda75274bd7cedebdebace3de2df966cfb9e23513ea27ab05e41648bc082a59fe74743ca89e1d5e069e4be3d2ecb59b099ae4ddc999c05e6b8d5555f3f080b602332b9876e7040051eb73f764596d974f9e7c689fdcf78fc7fa7d940f5ad766aea73ac90830b62d36613d4efd33d1ca4010751b499845f225dad6b949b5d8230959c199fe5626dc329718f5f949a314e24ee6a89866cb0e58566dd6ee75a154386630e57742179ed684b7a58a0872609988cfb99608e1df4d2fb3216f3f171e6390dfa01fbb42dd26a37402151d5b50255e9894b396006793f59bf77212fda91ad6309e61a4c93e0fe607073539118346e192d575d82f9e5d211250a2315b43187c5ba8f2f6b74a69276ca4832e50e254f916f5b8eca5cacae5ed5076e1beb6817de69e1d4826d445e6dab593740fc2f775ff3b02ca85882fb149a21395199abf53239d726019183ebdc61513b7afd21f8b0413128a08785c41cf7d33700f766ebdb235b84506f6950be2e7da2e6df0b091e904562c970972c53419e7927f693bb01617e429a92b945a89d6449f40413e1779241a5b1539ebd6de109771183d093656d7ee8971d11701b9a5ec16fa173ea4689696f00fa9bd5e84b3f23a3735d8d2a70a6c55477d20efe66692db9ba843c8daef0faa41ef880f8e95d1e0b50ef9f7b6eb1fd572763b8715b9e5218282416621034c6932ae2ec3ef460c210c6ea24654468b3b58f05eae9a1fbb171c3bd026a039b31d446d410bc6411bedc873595fdca3a014caa0b727703299dbb077a6867af17aef7da6ab3098c0a2688066a3dae0362f2d2add853472fdf8634e611c6a6215651f5fcfcb3a98c8214978bb85e7e84d82fd7b5a00ba63cb34db6f51e258231a5614a82c20ad535b2053f3e2f48d78941f8450019dd8048490c05379396c833a657ef137275a26d42fb957c23c841cc8ca33ee89207b4fed9291c075ebe87ba5ef098a9179f8855735b4511c04b3df11597636a4c6d6e4b9d41662e6e77122dec68187ad34d196b4e15374bc146a75031cf08f2368ab1bca29c994e0ec39ca2218d55ce2c97dee2b24d6bb21b0fc3a9a64935d3b35fea279a3cc3b35efa3032138a63b5987f7b791bfc69f4f29bb4bc66c9e48cded359ab557b6ab3ea4f970dd69f31823fe36b4888b989f32f5d786e10987049cda460a50f49774a2884d9511030520cfa68f77dc531d2b88fcaecc32828059fb42063d1a1afe7fd3fce4d129b82f2d0a290706b50eef25926f862f44613ae8bfc02700468a55d945e81f50727e3b3d5c1e8209b5a1e1e8e5c9151f873db91a56218d3d1bd3fe5a767a9ddb3190f9f41afc0fd9b3c2fc67f082d7f9f4b34d444808354cb2c31cc2bc5675e1f4002be8f765a7b9359de78a05c8f3c1864a568bcdc12fdb708591f7fa5c747d10a452c74a170c7f338ddaa67356a20d1a3d7003ba0a094191b6bc114f2dbf2c85df52dbc02afbe231689e20d7f3371b1e37074a456decf159cced0a0015171bd1cb64cedd79d929910da51fe36b22bfae90843dbe8b5d8b28901f7ec128ae450d3e3782434401dd048d43bbebbf610facc2952b435449dbf8e912904cab432e26fe7bc9948133569ea79f95c4daeb8f0ed11729d00c905a5fb95ec4fbde01967221dc40dc1c903b53b44e9afd67f47d814dad27e3d73f674578f234b33913f21c4a6bcb1afeadeddd58742dc23f6eef5b56e91d0062efb0c2cd5b8e9f830a1c95934ce74531da1cc7bf7e988a395372411f9ccc27d9ff1d064e330ab73eea1d0e465b8dd325cd1594f84e3e57dda06e867b1deb9ab9fa00202ba6fd91256c7d42c2e868db2b96d84f41aecee7ef24c26da0f34af80523ba63c3f967552da1089d938e133b8e33d88574e6c0236f9a2644c289f9541defcc64786e9edc62266beb705688897988103263525d579df6016e0cc86e9ccb4c23b078b83ae7a28028e1d00ab17927b936f5542ee8fbd0f04d7edc46e85d101d735d73821b944dff9dd9b7f10d34561968a8276dd5cc97c7ddb35a4dccaf24c40a65f3e0217997c5eaa65105390d7eb7d1c0755f9e81458f977e03e4d5e6c78bb9c190d17936ce7f33236712de8812b4576e10200d8c9229f6a89c20cbc1e59b07bb946e483939ecf8c5dbd495a7a4346318625df6fb13771c7b9bd8a805ea8cac4184e990529aa14d9b7d621109d0249b6a03422cbf92db2ba0d200e733017c6f64039cd48d423458fb704bc1f9cbb9a6e6b6bf6b5c2323b8db127dbbdff1bdfaa1c37f9b1a6f9ce6e5943c60842ae9ffdaf47e40db0d44dda2032155a305b4d5c51c8cba67e488de53866a6e85b795df5478eed7016bbfa18d8fa87fa9b631b3551f966e77dcb4b06849a90e4404f28c46eec3c148b84a118b6aa6ba6f5a61735ca57baa9f0a5c3fc0b97a9cafd8e5203d21ec46f6a389286e3dd1a4402f891aa70e630831cf1482db808a4568c09edad2d63d0436791f54b0165621599adddc7b616e617f1810b582d54ce0d415c0056df91e5d0b20891e70d63436f6138f224d3d27e8a77589c380a535122dddbab7cba240bbbd266be7d2c68278a9210f528fb54260624f7c689b8a28659703f9b99b0da33be5a2ab5671b867b59ddc2e419ee658942dc07169905f1bc23ddbff4f013267ff112d0fe0e21817cff9842145dccec22359c542e2158c257e3a4a7fcb6944a657d5e85371e167b5ac1ae5a010989fc982858cbbea0b314b86b9ef74bb90c5e580b6bcd7990508d88a89e338b1a50689409452f1cc0b50891d704aa57c88d198cbbea6e130a07f559b9374282e0a60ae75ee70b15d7b8b40edad08e4d0f83377c5ed28e33d2e78ad027df1c923a5e33b2ed121ce234a1f44c5237013c54ab8dc0cdbd8f09a50a56272e7c00205bf186194cac19df78f16c1056080a040e36c9071255f15aeaeb19450b422fcf1bb8d9a165ce9a7c704e79bf6bd15334ca1d462be9f52efc54881697f757933980fb2b4995b026766023125ca52f5e0ab982b30a99db072ef6138aa9953619646c33c7d826a7dd0cea42e1a90bc0760f1849d7fb8ecb9f5d75ebc7cc7698b21257c0c2aa9ed2feb362856b951210464480bd4dce7825f21b8bd46118cc95cfaf32f1edaf307665864828665ed85b6088f935db6568e79807cb17ba783c0dec8032f17517a36d33442cbf46f75f94c5042b3cdac099294620d9819089ed1dd7bf839aed8dd0b50348125c698e90114964601015f74838723bc545adbd2c5eb1c2d0ed7d32c4b98a2235cfa9d405a3cb7df543c5b1c3c874a2ee4c97a342414c142d3e2046b5be54103fb55dc3c73b8e664806bedef0e0c1541e3924d741ee4bdd26ae90fd19c4673a9f984b7d0491cde49658cd7c1533e66fb06249169c2ea362a6478eb3b3934c1729d8e60fca7568547db87c7756c49664e047ab813a990fd8a2b4c7e6dd5c240df2efdd58a2dc639122777b5ccadc3fc63032a52a8c2561b35593df194de68c5a4316aa34aaae9eef562de8623e5a1e53d1bcd6e940522456c256c0ed2b864ffaf98ee07528ebc84e95c714731bdb03c1fdfb124a139be1c96b460b0ed7291f416199a37d3d82a311233c586dd0233fc764ee058a9d6797c71f868d8786e6b080cdbfb39c88995a2d1f28f276474ef7e1337d24d9ee4060b7151a711440d9cd99c5fba44dfa09167d9c9f19b2d710878a8c09a1c2479a8693515c2aa400680bec694a8c376b0e1c27d34cda6723495fab8f6f21c5aea1ff14713b741b92f2880018c0d290e7c8bb9659e576aa1ba98b7532c037fa0dcacfc8f01df828acb9345fdcb7b4cd0321e8d09d95c979b6de5bcf02b7a3e7cbc98bff243cd4a6ebb0726ec07ec9ec33e46133229fb0adb3d6a088c576e0a3cae7118a1ba563d573a64fff038c950c5766d03835e41ee10af8c939f585883a7714204285e697e19b6835ab81c824c299ed65bbeba2255018cfde219bfcf6d47010cf3deb3a8c14f4e172adaa2138021c3b6ba4c60bfce980abf164d3a336bb81542e787b3aee1f511e7e3695719e8f2e23e8c4a16bf148916610c6775d6c43b6084ded7184c8ea98b3909659ad9893562b8be4d97aca65f9d9def5f2e8e6fd092aa79fdc7891e1bc8f64368d54fdbce95b1d8f80f470441a09ca878e00e1a9b63f05e6b225f702a68c38ff838bece75e0614b812c80798f0562b2f43dd746c2de574a04e702462ee028a9080d078d0543df7a0b0cc76ac930711d6d9ef3126aebf860ba53923dc08fda7db156911bd20713d8fe5132defb1fa01783037e88ebd19d92ef1faab7440dcfb5a32d200672467fbda6994fdef66c59b2c947d5867272b0df7c788e207c6a2313a80fb80151f63891179daacb1dc9e3e7df42ca77bf75ce43cd44e28fa7ff619d7053881b24198f025813508d44ead400d4d7df4c8f0bcf5b2ef16595035297f86d1007fd94a29b561bef049e6e7d439f91d9b4cea4cc74689407f1a733f831c717b4b93f961c1b5b027aa25942a3391b8352aacc991635d3675c5989b0c4977f63bd58dd003353df7ef795e7aa16bb77f7ee9f1331787df71dc89def0f22867d3c897d0f26e284ddf565b898190f43b6ad3f93f133c191772b595a1bd2b6c0b59c20eba9c48b0c25a37d75e8574625e01ec1428372484c2e36195fe055af977c3c0f5c90d33a818f584c414625d072832204c573eb5d973b8086327ec104827c0aed82471dc6530d469def81d428f1432e3ecd62e2355ec6d48eb6e4182d15af4c595879fd1a5cf9e3ec3d848a138c20978fc7930e7181343c58b325f0426bc9ec4637d32d15c3ff909d2cdf0e99fa7373213ca9566e2968a60d8d76af7c03dbdf63cf024ed37267791575c56d87fef3f66b3af8c150cc3755410ab4425cff4b378663e95642ec6baaee9ba263ee0b9f59e7672c295280680b9489814a667a9cf41e17007d0d58bead49d6f463a085ef884b28ad6230e4ea983996ad921539e6fd83392baa511c866dde468d550913881d7d180b813658d809421784493bcbcb393326d5a26a0bd89cd0f63a98148f47abb9c9dc5e10032b03d7e3b9d0e0b163ed06b89c6adf8af0666379f8439188f66cea1ac29d2d050428206c7a6c8886973ee82d801bc6b9b697993dd9ceab3560f8e52b0a0b6e9c619711705db092fc27f38ba72e501384add18187a2eccf10293c116f53b4144d200a1f1601fa8da4a3d9cc1ccb10fd49759fa45b654a40d63481e71ec69b035541e7bd743cf88cb717a379cab154e612e8af972a2654a9792bd730e772caf3655dcb79b2a186dc76b52320eeca55a350c81cd1b0ef70b5360657172a014e617b62d3f5642121b7e7ad0abaf27db7506a53ad7df1fb8ad43942564c76d2d49b17d1e749641035106c51d70f1fd7ad8d12354dd0e1844e40d6d8109f785536ae6fa7824ea29d1ef17391231c67ae6c62cbfb3a64172ba2434750912a41896d876a99659e4b455eef05d1ba0d8b1aa582a1224c184d1e6894342622e51c45c9582d5ec7feda459f0c96d16f01d1e07d0272171f6c9958448d22d8ab7c1cc212878d47bdf231f7da895e3e53a0a6e60d6a3b3b665d88f51db58111b96bf77e72f064e60f50c6ae52441776e91a43b9f425c68c1b4614548e6535bca68f83bcd47d2eebddae3b89a0fd26eb1d109dfa5d119c0d07a2bf90451778c01a25201c7d636fa81f9506f3af9eef654c55df639a012e565534301b30f4386aaa1abf03640e35b970cea70838238e590215dbd89a66df926e6082bcef7a946c87fd64d1a99bc64a158177a3f57b654605e04a0faa8362c1190db4009b5d76c9ff98bd20d21f26c526a82c3de12cdf9f39cd5a95183e009eca29dfb9f735a8143ddf6c85d6c307040e97da475c45818fd80bcfbe74516be0a95a346a50ffb340267bf6d3193057efaccd2c40d1c33d02f6772a7cf0a47363c3d494d1ccee8e02cd7d402c9c932ebe98ba931539671c9ed3f2cf8a98e71848f230cc5a547369648ca2c59cac5463f5e9ff59000de996922426f181902afb72961961d2a884b55290cb16f93a9a8998689f38dc82690699fc073116d50070f3913479ae4928de3b672ce8edb235e5a517033671f3010e56c5ce38921dcf2cf77c49bdd83d19ed34b96424240c26e3b3bfaaaf046aaf3b9733b02869d310d1bdfcd275c6a5521288828d24ea4e64f2496ac0b1989391fd3a86d02962f063a2d2d7a25139433be2f643641112a07608118b32f819715c347aa84c13fcde0226ed44e29d8d0adb4427b5cc763566e400add21ba520120f224e34d7904d4d67f3f21991179cc3a03d0b8338e64267181ee6b658cc95a7b78917d3cef2f0e44ab5c0f6c9ff5279d10b28f35c92efcc3c95f93f5e20756faa5f52fb60984e41cea6132348bc833e008cd7ab2e9dcc414f5573de573525d7daf73d88ed6e6837d123aefd2eb7d9f07622ff97e29b29ea1d66fcb4a2e129102c611599be51fb52785339d9720e16f09d98aebfac72a4587736be6790deefea411314529a1b7649945cc8b01a3b9d60ae93bdabf0bfe6d6491a6ed7a8d054b1f89ab63c401b6baf11a429c3ab5cb853cb756fc02e4309111993fd72ddc47cbac5d8627a8566e0ef8ffa9736cc9143e2a9fb348dade4a2adea48248fb62aae7814488230890e3b6e19b84ac643df4ac6315ad66b1fe5b13ceebd7b2bf43159899cf184766db75891f1e9949b9bb0ee24500c504c90d841896ccf35643c82cba19da89d219558b6e21e4f625f5779b5459fdb727356e2a87ba268fe55a954149befc929a1e630d8df54830e5552d574cd64254ca828637d019d478677662a9bc4e3a0dc76ea28af526d90a5fdc3b2397be186836fcfde26ece617cb9eeb73781b9d9177ad2687764eba6d3f28a58e78e3820310837af9d64e6541ce56eda0dfc4d0fccf570a7865a6d4d0f0ea1a8469555922afaa3bb018f4a423be248cec4e71dfb2940ab388d904535a65a8e729baa279b76277bb4f22e2b066686e9f018ccf96330c776f1a3f10623e4ad550abb90f61580603d4dd5a010b87d906f1f3abc0c228c3b138f012fdec935e5c2c721b6a86fceb611cdb453c243370bcc1c096c1535dc8b94bd02680b9face9b371380be3af12124de2962c6fe154c065dfa6b7e0d6ff6f81c11331e0cf4a818da7689457e67789c0cc94539e4310890c6b57f626732221e7eaf1cfff1f05e485740ce02bdb5fe4abc2e17995bbbef004be6311333dde71c6fe248328a2c6c7b8d06f8989fd673faa44ee5755cb171eb1faf9dcf1fe8ea47c6011ff97888a61ea2e4cc11010b1ee8e6054745a70534b72637a3d91dccece70d77eabc3119a28ab9aebea9501bf4587ac0865f22e36c7ac542b0facacd72da0016c6ae1bc2032ab504fcfa1b037484c460411f34580d4449b21fc12c4a35227da443234353b77b003b628a1c3846e1abca6a3b520e850d331bcd626365bfa64dadd4c192c5e765ab3a3013ec686c9336a14623c25d6fa290f8256d760134ecd8bfa64aed67c8a8c7639d46df7c29f3eb09d60252a0b13134301ce95c23920d745411b7acbffccd6d7d65551e1dc64f89fc7e486934e81806fc00e4458810c9db221505f99fb0fdce249482ae8eb772a5be2d2410e0ff31bb7cd5bc972246bf6b17b8fb9854f09a25df8f62d29242d4731c836ffc6db7ec39d530e387115d3c70f322740a9e39f34d66e211b403664e81c2e80a8d44ae803acbfddb97e0729a8543777f5d226ad810f4cbd4c13e620d55786a096fb487f7120620f7a4b6944d17e892f1dc72788c554340b65ba22e32eba636cc59a691db113fbba6b43b8f377a10a6e5a30a00c2246f57763387cda4c5bb4e60deb724cd41fffbb730c81b2c3c562979af794b0930ca79c2d679a4bb9355ba3065a1cb8eb18486bb4e37f0989c5412caf1f56dbb72b17aac583f3ef72f11f6c96215b4c4f46953a4d2404a627e65e8361fd8a3d1ed3d24d63d7b6c63c2078cdd52f095db4a52a469611cc71e6cbcecea15ba15606e7a07c916449ace13be19f2589076684598569156a8637c2098a618df8e01aacd6587ebd3a7f5a2666e60f6b4683c274275bef77264029cc95d12b787dda46d315971fc87e4f8866143950d207508319419f2d669cfaec487efaa5e3fd2f9301e97719993038512f3c6ca1d6ce5ac978df0964929d43c111d4a00920afb30134caf596459eaef6e3c08c9fa98b9f7529be23f9e46f5cb27340a29eef148a45050eb1357780252821a7f205375641bc8a40ff09bcb7696eed1646b37b695f80a8527e059f4bfefc97dbf75990a2ad9c08e29fe250cbd5f74cf606455055192cddfd28b9ea9d2c42f0ab0f72ed80d242373ddd31a42e775b8abdce20b8467a1236116c77fb3cf5af21f3ef88652bb6432face10ee8e1e8cae0e815b347a3334141038c860a6a9df84072dfb12a8a95bfc7edc6f6440615d54beeb55ee3333144bf0b1bbf2acc9528fe86236e8530acf909ee8d035ba44491e593e76d5aa1281814e2e6110ce2c21f53894f899c20d1f5c61f8e83fff163b4d7847c058338344bafa29c040a0bae1f48d22458270237533e4aa9f55178e9d24ebafb095121beafb4713931bfc916f49050275c2d897efc404f161445b3597a142ab11d28006b19542ca866bc21d81c21a744fe35205e6b7dcfd31bb0c71ba539457f10fe93efa234caf0788f4d126794bb0d18356f717b563a3b0247d4d85bd37a9becd64da47aa8409f203f0319cba1c589f7f5a8213526fc36554e7e2af69dd406ddcd089b42f0715631450ca4444b5062385aea1e4193b4075a647df9f1def3f35e03d85fd7395b8e556ea9dbc73cd7dc16a8aee4fc1e1dadce225f7b3e295dea128830301264a911dc7d408612a5bec330acbe8f33cf433df62cd38eaae98fab573a372517c0afbec625adf0602bffcb1f5b89dfca0e69836fb7116daa67a5a081c0b848ffb122d5252145bc7a34ebc47389bbaf7683a0b98fa3319a6f3aad8c2cc1bb4804cc46220716c29650b074ebe6e57b86aaafcca8fb549014cbce7d1241e508d2008160e9600f5ffcc5fd1f2e9194b66b55740e28de37dc98b0d6ab112c0ba1ce573a72892c55573d69665bece0fd5b782c57b309f22ef2679fbc2de22ce9a20f7dc1b86ccc80891173d79badcc90c66627927db0d34c6eebc449ce5462393583204b0fa577ab91df719d055c947ad6b06872e508643b4373ab9a7e39586fd04fe2ec050848c409d2cfac21d90d30190904d714bc7620a7a143bec8f8d732d6c698549d1387149e9fe3066fe344c05ce6569cdd37a3bed073b79064346f6eae015986b849293b242fea79a408893181fc70f139843ab6315660a06db075911655b53bef40a1edf0391adc6f757f092f61a4e84ed16207afa26f4bc00dcedb8e3ec9e3b65f8f2976ec006bc9cc35aff4f5c6087b39dab8fa664f5ef19ea5c076619df3b0cd379212a8b4de8db14f66f9caf7e974beb298edf0e68dd8c41fb619cd4cfd3039727fdfaf4754a80c98c1f8744599730926a702021694c031ffa06c97cde711f99250fed6286da827398660166d7246b3cf9bdc8c000faae471688fd00fb661bd3486924d8220200eafe0296d005e44a122de704b55b72ad4b2262d9c5a168dafc5b69e9d838b32435d3558da7a3c819270185ec7608657c0bff214243f5fc9f5fc9e5a594d70590902c2ef94a5a2ceac854761c77bd5b5ba5625f07d7cf1047039e8714df17b61c4c7a94579683682f9cde314e56ad19ae8f7e1b73c5420e585bbdfa704537578f067abdd71d2f4ad0757448d43317f4a506999679659d690f9c494d6c88c93313cdc78ee4ecfe9b6407d88964df77bbdf08792dac1322a007a6e14e8f985b347d19917cd6f630bf63c43dd9ca324ba6a2cafd2ed95458ce23c4cfaa2ffe5165e1094de48852e275880a81671e4796409565f2cd1f8c3213adf1d4c16631c392e1e41f6b403e364d9e9abcec354a538f645864a6924c3c0c05666af1297acbd105bede76d17ca2cacec2eaba9f76b8c7a3528387e2f1ccf38d044fd8eb7869c47a46042165d580a1f4283d15cf52909e395f54c76a42e6a98eec2049135ff41fb6136c8a7a384893a106a74aae9a07e673e26316d376749f2b3c2a45f7caa9950e8d6904cd7c0ba99fb82c8c1a782ef32bb00974895cc2241d47cfb801a83f82db63b60f163a68afd26ea6f5f3e7317aa0f732886574ee0a1fb6d071b71c9fbc90ce9bc3961dde693729d597074a319d7519e139ca59d0cd626c7dfce8e41c3a933b7d6fae171f12f6cbdfa0f9dfa2a79280c24dd31331f554f74ca51189947c87b2902a6a056da17c02fc09ecf4f3b8b65417ecc8d40b3b4a91a47ba2c0a1ef977937da21408a366d9efe820a2da7344bf674265f583408dce2cc2afd3f48777cf4f00a4cd8cfc622f2b48588598fceb38d3debe469d249a1bd58dcde93eae2e139b36ac1427964fa7a795cf761b069ede4cda80dae87e497b7825721d536dc78ad4a560b44284e86aa2d3ffd2a7252202f530ce2d1c1e423ba07a4614d8d9c0bfb1e4c6b66edbd132547fa644efbad69644ed1ffb74b8c7f455f5dee3164d9193148957ed31243833847a4a132e2895408959b3b649dbc375bce534eb3443a0dc13916868d12a25f9e542d8bec0ac174d0ccc606a2350313c860fff780ff0ca3ad8ad4625e066522569ee2c3ed46029896638513ff550a39181aaed7cb9bf0b32c22a628308915262f290626134d258d6f55784242013296020ab4b821893dd9ed7f888847d5fddae08a1158c8c2feb2eac95cc1766c0fcaa7e17f3fc561d50cc3e5c3de9b2415810c48a022077b8c8e451ab5f928253c7306a10682f963779ba0efaf7f0c850fa7c34f76fc586872108767a96e51aa8849f599f9d959ee0f51f120cea06d124ca2bee6da47a69742d58196b439123854644efc119503f3f7605970921ac051aae3c80e12775faee45670e7d2ff8ad4c19c9ad48513b26f194f0f5d793ba11752b923758426a0a1d70353bb4a5ae0d932cecc78ad83d4232b8ab33e3c7841e92897dae2994db4268e5f696cd6fcc063920959a90fd583fa6abe8d9ca49b5a0ab1f17d06e0b6878f645f82408b95bb4b1eb8f9aa27920126403f0b960ea6550e87055b043046f205ee8c86a04d43dcdd8b7973082552d0e1a9938c37c8336b3082d4c4fb9a898867c8197903b6efb6305073e1964349c4b3fa012f86270e371e88f0838cdb1f91e904758b40fbbcf783eb3c0c93771bb918181bb507d1006652263421fcc48566fe536665967bbb6072773a3cd58a55d29c29dcc469b5cb5fea8cc7d962f5a24536cbe59475750af213263ab92090c041daa9d58f9d13d5b70a53e81a8495a8be895fa25935c0d57df796259a8c24329fb90d84bf7190d143116a51597c26f188ba5758ad4b828df0c948d5098ce3f806c088fff0d89bad34b01497012a2943e329dd7ceab49fef129061ee8864986319c9cebe866ef24a295ae61443d91e14c7909a2ea52c0424e78800935e280c5ac004d7e8b7fbc7bf53084046d7819b745726815ec75a37eb13c03e75076de60b6dd5ebfb5be56707f246ddac09ba6116d371ffbdbdac1eab5a0416dc6a22606589af5e8299c7758a4f6347f6b2036afaf1a2df9477ec6847bc6435358178c74199e5c190185e5d9b84695c01dc9d2f69b727cc86cb856da54f6bbf8a43c1c157abb1f86db3435af8f9f1f0f3184d0dc30166a6fc5df42d39abf1236a11ca21a2a85c0bb51e1e87b825b8e5d9f819a69b7821e08a15694e6c8ac31f11ae498f093f382a8b702cd0a5eec205f58dc9a5baeea8e56d418cbdb8a787a65932a97b4216e6bb1d7b6b8045c78e1d5839dc695ec3ee0fb93113cb8f87c704fc4551532e1ac04745c86948e21ac6d87d65abc1374881a30fdd86db4f7be1a78aafde9369e739e47c46e16f40bf89e17905577b7a2118fdf57b83fa9b0d2bf582bc5b96a5e4827fc037627be3224e8c0e24c10b9e7ba92629c9f71d56cd451a3ef258f8a691e62c48400f69651b3a9c080af6f707f8a700a8a7e1210f56b70b95f1e8fb8a3be136a056a29f576f273d2f78c566ec03a45b613e8512893f13e48a09f6249efd827c4e8b9665cd93c168ac2ef47929db36527072595ff856cb6ccc6c40276c8407fb0a4216e123cbd73cbb70ca79f3b429d44db55ff90316052ce7a0d46970a406b764b5c1f9b8c4162908594a9287340655bbef883c5ea57ddf0ee757ab3cd958fa5559c9ef0c2625ae2745a60ea2205e86c5e4e721528520ff38499353b7bb0497383e8e6af2c983765bfef6b0e1a0719eb866461d08101fb5d3509ecc86290b37f2fe42e6810b40a14f198a7b5de37043c621fdc6e2b3b82446345313a61bc4e601806d6cba460c1f51c318580ec66169fca45a0da197226d948b92eaa33cba27d264b86ecb1ce397029b9dab4301f75b45409f411848d7aead94c1a0c66b496ca05ed5f396440e1c5e8d6017b9780794701440ce5d852be30ccab4361826f00898b8ef7a1fd7d1e953b61a08ded31d71ae41399971745c98d7e15574f11ad28b6e07426fb56825bfaf76610d0babbd564067d402427c944981577171a60362fda2489e7ee12dc7f634e2d0ee8e73c05e252b8b8c99f90acbfc8762aa76dfaaef78967a1d4abb9366c2972210316cb8bb3271568ccdab0184a001d2047848985a6b1b1b5847c54d13f7914db7045da4a1fedb941a2196c8576cd35431b1ed9c09b830a0e14f305d2e869da66611dc647db7b607f0a9cd5a1c1732b68af6f152b280ad2a5b8b257bffb375ab286da20317e6e270f9c6f4c0c80efc4cbad0370709add236bbf0e1b65213cddf56fdc95e43b6fb9c01a39880d466e940235e0061649da5d7fcf175807e43e0dc62f79bffdf3e74771783bf2bf9db44259d263eb62464622a190c0f6b2f2efc00f2ef8b3d0ce4b9caf91e062fdd120a72bbc4a550c4589df6a4c30b61dd9c64ba18fce6f8e91be8674162d4aa12d3bb3bc52f6c403a7063dd9d486a3c648669b3f9a2469de2b5a4ebc9c95eea6c781ae82a18974b9a957b591ed0fd9438ede3f9d243ecdf14619c28bf92490b83a1722f1b829c2a110f63e7ecf2bf0d430aa48cc1b2b028c35adc69656ae1d22812febe12ad7e7ad5c99d54dc1717501203028d840deba21c0aad9258fd5f1f4af67822b4b272ff0f9865702acebeba7ef3bbfe5ad30c30ab9671f3b092ca5d1f538b48ac2657a4e9d576fba5069ff10cc0af1feea1818b7fe79c582c82daaccaf325b0d72b9397b7b814bbe2ae283830119f053dbb90eac3a9e6ed77c9cc1930f3e9fa80224f0790aec87f9eead38342924d43909e72468f342dd1053c3590796069eca415cfbc26b14401b61bbe794b8b4cadbb9c72e46362e4f9d417f969c6b866e7f8d75d7727d12dd75df08e9fdc660d378e1f72244ebee6b4e87844bbaea14dd16412dcf14792efdfe674f0c2eecf8dd5b9842776786e7f10b04384c44915ececec2f3bab7f586a750668cbedb19c5965c73aa834e08a415b1f41ca894954fdd6ac2ece374b32af3c014332618e460cfca76caa67935d864d9ac631c5df51af0c6f0c6418d9dfb9f44d0e70f17bb2a3158ec225c4153ad7a73c1380655448e23641ea8612eb315f50503e7fd013f753d52ae81d5540329eabeb2452c8f46d71b83c5c063625985ecd9822605090fb2d5ed83071f6abea2b6a72e9982d2712318a11136ca2403022dbc3ffd36debbc11ba7d6289f095a7b97a79fd4cd6c2f11d24fe18767774ef569ff989d9f3939883b1c013c882b20a22e171a9e84be0175fb8924716850522dd440ca83772367be3d1de116c4b47b199171d740fbf2528f9e1c306ef57644c1fe69528176639b9fec2b5bebf2b1b2a13f52247a59feee423d021d0fbe263716e3b2d2b4fa40816f304f3445e3f4377493bc7ddc931d074b6f02057ff37ce6133a2c9ff6d3f8eb566f28c98ebf95af19cbf1eafdb3cbeff9c1dc8237ab9d682f821bb858bc5412ca99e7b56e347da6b94653998b692d921458d0a32966bdae45740f35ffc9fe56acdd8ef9cccb8c4a68f87d6131638dea19484c160c36a3bbb235671c6ec823586ff90db1ccf9fa90f962e9ff731124b77280f2f17880395194a8c15eb10f99537e6e9109df067aab91b8d640bc25b1b5bf4cc0556bb39a9694837d1651a5f511ce85004d1c36d0eccd3fa2ca6fba19a70ffc551b6ff3087453517be97d01db1c5d1a62fd4f86b0318e8125e0051aa53e86c1863e14ca1eb4d999debb059349bcf63c2c2bbd6067fb6edc9e14d42b0031fa7292020b3aa0806ed92d8d2cfca78da2a73e185e59d38465464627368d1136c57cfa1749dd81183558cbe83f3a4cd246888d9ae720010ea531a27ec1da1d30980e2b7ba6704462e1575aa01e3da4324fda3b8116af2e7f1c2496234d0eeb7606592f03ea360ab5e167eb5e5a6565ddb2a82226c1ae9da1e440f32291183d5a5c096487f519fb01d5f84b67c71fbf9afdd69c73840d6107f2aa06fae4e537dd7b6a5c6e6186fc6ccbf2498d1f4b011e1a4f187321cb536aae1b2e7bd39a001d9f56e289c858b4f2bedbc0ac4c525dee56cac7fd73222d56986afab8443c3a42cb19e918d8936fd08ee103ac761636aec7c559670d0ea09b8c9ca0bbdb693a6ea2c73c51807c56a1eec97048e561e44a0075199cd1d6cc7d932e8230525bfeea5c43faecf25bd42ee8d4d8ac4eb6cc5a9ec7352e9b904e32ba62f68e6de36ba84fd51d95284043d9720d8eef6b0507f31ac49e99009577f973c6d60eb18662fdf0a9a7e087a51f50ebac2a9dd9b88e4c47d174652c95260daa244f517704a982ff05a2f7b233b5f1bc0a2503e6a1638f9c21f30b289ac6acb3dc0d57f585041a0e17817f361b6b6b7e5cafccc92d95a4b0239d80bc9aa2a5afb96dfa7f18c944a0211cac6794c0d05c8c1efd678fd58d5a55fa39058dd9f1087d6fc03b265619872323bdbc4d06d8e988a1dc389bd5a74888ac1780890e70b916fef761797c4cff396a9589321951b9f6bd90cf293d95f69f74b612adffabf9c0978b194421fd2b482e11f09d759303174733ee7a29dd56aa01759cccb74a02c0c1cd1d908d1e428c1727f6faddb9c4fe7648f450e087a09dc3973a0880dc2938362f3f67f6f202af1c2a10e1c5beba6d873675acdbca1a9ed976ef164ed02ec48386ee9b452f5a1853b44fc9c523fca3d086d0ffa624e1a5e9a2f93fc57e00c5668136431fe3026ba7b704f303e179f69e1466c6c372b64b83044b11f1927d2a09f64a6bebd0431d65c6fc74b669a6ab1ad636a1338ebd312c7e9b16ba9081b9720c06cfe7e80e298e63d5c0533457fa96eef6476fc591d3f90effd66df94c859fb275129d54e087a69ab98340636d984ca1a7046b2072532bc041a41fc8803e50e2b2d4622ca0ad629a8fd59f34bb80b564543ca1414c2905b91207726662bfe3768793fcdf7cab14d66818000af54185542e1270bf4cc88e6ea1a937c2c256a238a5b39ed2ada321fad99cc88955dc2c73825ead4c16edfc8b7e3a07006270cb0c232f1ab2e5a686dbd25be617d5704b7111d6104d9ab96609b95b330b338324d6b50f48bd59e5bd2390627faff3dff86b52a3472a03fe540bbcb4892db67003f55ef3fc90b8a25d64e8233863fd26961ecdb6fcc96ec5920934ad5a549b058505906a54b6b5378d936c96ec0d644c1c804a5d270c899337ea65048351a3ea161ba70b8bedc4d477223fcc024351f31be37dcb43cee6403cbc7d9f16c9b3ceb0ab6347719a8185240d522b857f8af6dd5a0f73c6676c249787c3300b113e1159713d1cd5b5f1ff3f8fc4fd3d77e45850e2411dafa9d6e02974ea0b7513602a000e256809d68b67f11896d821db87ac702d9b35376d6416ad9a8026d30ba21a0036557c6abe4961ce264562089c4eae409dce4ea47d15bb096cce1f2bfbab3c463ca2304ded2605ee68575cda204ab90dbb7655edd4c5e2d8c8e3c1545a5eddbe62f74caaf0fca2c5cc8104b778fda7aaf39b49c604aed147b8f6ddffdd33559761182f8b3773207f9f68872a9f221486fe35dcbf4059c003dd01102506210805699155756228f8959ec3ff140cb2fa722dadf7570fb76619eb4565174fc14299a77b35809f8820a097dc4758a3aa59f2099c9c85e66b3f58bf04fca1cef68526ee63cb9c650fbf217aa7c7feaa1c63f5f987f2bb071a92d340ddbf33a34213a7c20f3f4ff31a4eb73d639f92bf7e7317d7570e924c2e0e71d6dbc9d277b390024a7fe545884df0c1368e9780a03481c19544c150860e07ac07df45ab1cac3222c971d5e2befa1a0401211a73c1f49978974f3d008f57df50959d781ffc9dd3dbf0b66012ce5f0119172b275923891971181a4f18c21c1bfd679348836729b8acf02abc5f10c66eb29fcfa49275b1e9a71786a5937ee9db0a7219a0de39c1164989ea98b0ab90004333b41fbe2ae3fe3dbd67971403e139cc34d225ead399039dc88deb80980fbfab8f6c34c112219c82c45bb2c61364e009daf8947af3143246c46618acc5aca3806c2c7869174f974ebc9ea6cd74e9115539e461546cec1d43b7fdb8d52e3a93793b78a68bd76847c39c3cc489e8d9e88be5612ca6584b616ed691b8b1aa8907a4f7fb7adb50d8cae417f40a1e5126106c5dee4a3bd829c68b85d93cf0f35baf518379d76c011a0815d267d95912516fc65dfd5ce46e947e2425a31ff223ca9d404c909ac175990e7a08bf90a22d615c9fc44a27a09db39fdb6e2dc402a9288284e5896a9afffc6d9c5bc6846befd5f40842297439834d7f4727181dc501e5b2d2608a5e119e6358595f721ce4018be8c8b6aa2d4bbb7549eca3e17e9789bd7c1cab3d1dcc7140593f4b65ba1d8a561cb8a18ba432732a4a28e9a0ca0df435c4ee8d497850dfe5fd6858a483e048f1cfc6c94ad77c7afe1c6322bfb8ee5919a12c602e70c9b92534c1dc803400337e7237c2e8e0e88decceb63dc1de8978ed6a72e01e2910d5e3fd2d2cece3092bfa3e34241993dee2af8459bb4246e002caee01843df995b40f126a3d338d4a5f2dd187adfc2947a22aaca2d3c0b99037d672a210d8931d746a6e86aaaddf6d53097c12b6382e2e500896fb33d029ef1111388e88ae0f59448483","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
