<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"585889c3300c49997dd277202cefd173bea0714855f12d52033d6cb46d13ed044a650ce562dbd6510cb9052fa3266b37fbc27bb2ac2dd0636eaa039a50cead36eb3c3377632e049da4df8e24ea6366d9b0fec2012cff5dadf3271377c38328e2b7fe834eb8a23c821e405b1ab896573910379dfa7090be17863b3023f44ac6c818553c7064c5725dd5f8d99d763fd5b59200f462efe8fd36a115dc0d71492099d7f4d7d0cbfdda18932fdb542e71c33e915c6d7400d4affb443ac415eabd896582cb7fbb14a9093b51c8f65747d40d28e1ad9836c54dfa5618f1f245a009ce28d58faee9eb4f423010ccc981c56b2dac763cb2a82d7e5282d062bd965304a5118dc9833c34c042db6eddbcfb4de6101701200ab4cbecc8ba4fc55981c58423c7719b245e5d2839b77b4a6b9ab70525100a2ea81fe32b0559ebae8183c960899bfde89020d41ea338b9c9650fba692ec6d2e534444bed4f8c02b1f71ee0add791593bc2598daad7ed5d2733ecf95d7a843f627b7cbfc67c1d7447ef0e8132d23e7424e627fb3823671826a7ed813208a980a3169b95b54e5cdef4d1c61989f49bec942f1308e4a27089f2f2b06ad56e8b48c74ed04d32278591ec3c7593520bdb5803ab3b54ef490dd2c640e339043da0323f5ee68684126ff3c508f1666b9c4e9afdc4ccc2474f0d588deda1a4dce26b5c7dc3ce8fd818eea13742e529fdd6d0d573e387399fe0de263e5f4c5af7b406ad40ec66b5a8bf411e265c51e0e1f582629300fd6ebaf4cd68b2c33af6da690786852048cf8df4e50abf5e1b3f72e04ff7cb57c0ea88d9e144deffeb3da7ade95909682af0dbcc2a88feff96ee074a7bc56b23fa8c6824895c7b574ba924ff8ca8598bac88f606bb37bc09f9164f71c22cdb1ee2ad79f520e69abd2cdb201b463a6042c46f88c5f7ff76e6dd4bf223750bc1bc0fc50736cf3c2607e3ba5df0391ee00f3e00c642f0ff37a333c86a4f02a63ae521da3ba408ca6a6477c30ef3d3ac5e503f0ec4632b2a71ea80e6958bfc5346e87b1ad9a18bccd69281987ce450a0d164cb296fda21a5c4631ba392c5eff73f982d0ee96794069b7dc832f1319b4ee85169bbe6eb0d28ddfbabfded214486b3e3fa0575a4e8f1822b2d8f478d543dcdebdf692fa83f842a1554ec8c0e7413aba2b71044000be273e0cab192a235583657adaae96089154cd376634298c1f1f050c631c9c6eef175de7348b1301cea7cc1f30cc6b390579c3883a9e5a75db0451a48297f6160b99f88ac5fd1eeac6abc26413352cbda2f8101b85b04c4d9d9e7fe780156c6f4890f30dc1c7a7e9267b3927e0816e80d36b8794288006861b3bfdcea67c37269f7aacf894808699b1d677c5b8839f905f53571f2996993b3530b4067d68da06c8958268de6ee030a3b32dd68c14e925e1425e76896fab4f3035adbc99534314e1165caa11c906b64c93dae76fa5983ceb2bc796edc391cba167959d8f1828ee4a2ad18597fd81ef5a305f1ffd25b4ab22a677e246a339d7c2cfcc3dcfd6625771d3d39fa4c6638f54d9b6395dfce180dcd450731503fe0ea990cdddc3f99a48e92a893f64ce4af7cedcb5079407257a7283f29501b5b40318ad896bd481ac330a0a482b22ef29c02866392f94c7f945ab703f6412d61b5fc425c84c4c0a7ff41782877102537fdd7369075e4d444e833d5dd8423a966e76e270ba81a1d4e90b9e3d9eb5b53766a7ac1c205039b9fa757ba126acabb26fc885cc23f97f0470c4d5ee0695e095b33857108c5d65ab3d516ac0d3c76c06931d075a71120ebe34967d6471548ec74e1f40c8691e4f58b26aadae8ee15f9eafca1928798dfa6996a894deafcb62fcd3a5a03f2cacff57f087e45f1d3168dff668966cac39d22fd55c3ca655aed648ec7f52f0f81f3e8f5381cb660b8cb5fc84be69fa34f789d56286f5986d64489111268258515ba28299e823884ece5d44b5b45ebb7345d999893907f78ec43cb4dd6d127c0ddee02b729f24944e55be1881e12b56c2a22fabf1824ca01e07d3e372a9e372f9e09e6d706058ee59d7246490e8cee63b21f139f3177c8cf2b7e8526aa4d3895036de42efcf7d08c453502efb17873e07992da65abb379cc2abb7b64b9b35203071e6484d82787afff88348a8ac23fc3283e12dd2f5bf686e110eb9e481358463f5927f088c36e62a3cef6fcd48f0fbf45d04a9d7bcd7add9a07aad7ea120fb7bf03b895bf30dfccb73cb8e307d4924d2f1f3a04e6d08654929f8947dcd517ee568bf239f05f6083e05b4da8c97ff2d0e55022caedb848ac3e6bc540c0867f54ff0b1668282dad2248feabd2620b51fe0f73af58fb499b77f40a7676b73c7a59ecbe5cd1a394bad8e09186dde319efdf1010bcb543972e68005c260d77743b3689402778ae13e5670df1dbc93131372f6cf34465ff4bb5bfb9549dc4c46515ae7609f2d241e8de242f2b619e3f305f8f758cef0e765f818ca6454ec16cf6d03a1ed13ed7d5d22e68066c114a2cde38f891b6554d864c2e1809559f0a6a6cec4109489fe7cf50b9d7f2282bbf11df5596e2533eee76f16649d70c7c52b1fed5a5d2e06d48432a8f335384d8f70dd2867c48aa2f3f58dd16e4e65c0d29cc0cfa61ff660f6c0d8680e5de4b470e439b6ab18ef1f95003b6bd7fb031de9ad81045d3e3755028457a8881326427c5f52624e7714749de81c22c6cfe198de35a97911d52b84800b9d60d909420c0f761cecf787f84360a8a2dbfff1a72d47e0a5c35db9f2958fca88c81e7a656540bbfeadb939b3a90421cc6a8e507fb77a9217dcf34631a1469d51a6d520c7a836eb2b2963539ac3b85f2d69bc784b8e39c34138222c5fced2ee9fd4784b65c3d1936984f8903a8fdbc9fedc80214c447c23efa5eeba90957bc425fa4e3d28e0522c3056a5883d13217a5dcb95f4d57574a6c722d6cd8853f027bd41be7fc1c20cc8eb9747bb181fcf9f216bbc24442351db7f1480010d42b79cd45cebee54faaffc3cf564d05982f973c1fa3619721e8422de5dc0114421141322008fdf23d7f730abef4217d0ad3a7029e467d36a580b6b926ac66872ca3b6a6115736d9bb2557a4ac7b6e68cc8db07e059f9f628a6574ab1d27f1bdd715394d886dc5c135d0d64c4a982111d11ea4131a9dc04bc426cee51bd2c5ad6187b484c9ed30cf1cefa7a5711e8e3ba070df0b358c4ae25bb0d36912d63c8180a1921ac35f127dbffa562f488428b456ad280182aaa44e1ab2dbd8f23ec1989487a4552b74b270a4a9bfc53e430739265b1bf8284d9560e5a3af4f80ce39ce49de790f8d7d18b2d248d6c0a99adbb59b7ef2bf78dde2687b4c8110ed94e050bb360077870f375c61b15316f46b8e6d59be996783795ec71f78fd811a1c8126886b21d90e10969a98d4d43952d742b591815333154a269748f7805c54d00d5f53e4f66d207539cf61b292ff3d00ea1eedfb9999b6bda2eb6d1d9e6972ce9f4eb813b615be69562442640a2c0a256945fcee6e00fa9af0f5258f0341851e7b9b0303373c8fca15289d5c368a9e0ffbf73bb27c2c4dd2a0aaee99e5103da10990b5a7a8570ed1b7a30e9c6e68abd989a2c9fc89f4013a80caa78d0db83f3ffec5d29e3658cd3d5899d118332b4b6044e754d09f7336f72e0afab450b915a9c5162435df698fb3353cbec0478b17fb2b350d8313569634ea42e71f0995a07f7a929161b96812fc1b09542fe9e2490eba62c6b4d535f6204f3fc35bfcea0d9b2c0f67be184fbda45626401c73d6c83dae65c9e4eb6a79a4ae21580c9757a13622d9c2ce8c9e22828eb59d14b37ab0a9e47ab3fe66d7a78c534e96d34a5e8422e5d4df74b8e095ec50dce74cb2c6ad24d32636505bc0696ad68d786bff3730209168030943ca235019caee27a266a96ec37d0bbf423defa538c4d9d2f4e88d7c465a0c05a023c5b316deaa3c1d946579e1a7b9a855209e16172cfc8d8f542a3c6c2f89eff144876037866835e9127702bf7f86e1d2f843f499c6d0f29c946a1f721edcd742f62c6207e040088b16b4528825cd06faaf1d9846e2e045a513bc789104beba894400f0e959a2371a0e66728a8e32d8ee409366af13ddd363f19dfe174bd2a5baa0576089d05d604d0ca6bd117ec02f073c48b678bcd6e1d0c20928fe31042d4ee68e2f927b6ded7ff8c797e59107c05cee2fe0f9da68d537cb99376ee9095ab81648cb3b8e1ecad759fa461d298eb25c58cf508cbdbe7310de5954c5de08ce58bf2e98612f325ec0b77ffc741ac14cd4c84eee25d35b3d3d7b6459a20dc76c562855d3a05e28fcbf12450d03df37665e7623fd9ff7e4e7c4dd0d6689588ad4f9374b14d8fc893b18c5fb37c931ff7b81d47e0acbdb045d87768eec969c6dbbf8a366163724fde53f263e12efa599d73c4584b8a8058fd011e15f09f7384f17b7d7d750496009cd870fce88fcaab294ba59b638a932db55bf8d0e70664dd068bbc526f41e57dc9cb3109f4f71b27ae69334526bc6a1d78eeb260b8c01f3fe4995d3f7069efb718bbe68c236f990aeffe9d379655eb8dc0c94df015918cdb1866fe889e34cdda14c5306c50ae48ba517346fa0c78e7845d40b57cf4aab2dcddbd4487009d02bec312b1a51007527ee63624b9a8eeeb160b29fb003b8b87285b8dbc56e5c3b2aa4586364ac713a984f0dac04c46b004037665f91e33657198da495115f5b78d0fab08d76768ed0b16f1d3f4bfce110d11ea5cde1380190d5e3e7cf70f76d9dc647ceb6735e58e6d17d61b5a0c86861e17aed918ebab8e1b9ec4e7d1c1731c3b672fbc4dbfdbfb5456afaa1ff4f5941a2a08a2297b5a1a16cfc76cd1564dd16a731e42e3b9141ecd235c0444130a67fa00976fcf762897b1d5fb4bbbaee7da5de9ce872236861661ffae0959dc18c22ce58aadebaea3ecaac4e816d0faffb07bc390e765e3c296db824c565c429819f6a1cd21196b9a605b89482c1b40597169e910cbac461e26782e11c3be464cdda0b9ce68c92ebef6e9cb3278358c446bc9b7151d39451d4b61eaabbec76a486ba23057581463f5103e19a08a12b3b5487729f925ac950631a678f349b556679e22eebb71b3dd92aa9f27657eeabb4efb259ea983a260fbb263cc51d4cfcbeda1019d91e173dacba4d3be0d71a65f8c21f0ef7c7c52383d161cb1315d15e3e588f20c154f1036e13418bcc1f9d05466efa2b7c90a43e91510b1abdbf061e1e3c599d340298e15317e4b3451a44ec370956cd5bd853e2d530a78aa3207a1e384226c0e8d9c8baf7e6e3109679af2ea940edf367ae8c4a4c906058b25f67f259847a355553c8a142b203d3ee80e75cce2a6a0ff15094aed87d42de9d1e4a722440221096e65491b3d3e9db59f77557e4b6835da907dd9b936c574d6d41f90e13605a7faaa3311c872993144d2af1d8114458332c1a7bf494cf455246ce4974916b31ac8f847ed51e3268de291b983060380521f2fb16edb7488423d2c316dd807d6c5e4a9910b5ca28be9b6dfe46069650cb0a6ef84c71329f2e070a0c565e8f781d2856e4bc99bb8a66f5ae318d5b92819d8cb940f5816d536201184bcfc37dac25c125ba32ab62b567946af450448ba2acdfaefbd9d5e380eb2d7d2231f15c53b2f84371e654f3ab2fb1110a0eaefe0b30626aac1c15a6b053b76f7747ea26b984a7e8b7f7cd171d9e182862de0be760ba31870d7fe5171aab5a46226a24c37d3b93454fd54bfaa1dbd6533f5f0b2a8c58870dc951f7e8026d3309df7b6491b6d3f9971ffd9151cdddd85779ae47edf83acea9bf98944ba16150722ee53465283687f078dae5ba22f8f55ec5bd3783d566be23b97dd57ed976a390dac09c047fe22d15d36a04516bd5a9cca0b26fbebc4da285835d67898dd27a9da50e59a36cb3e04bc698c661f2586f83b0b0c258755c8905f2d8c4fa3edcbfcb5c863850e5f89b6e1337d777bab0cee1399fd9bde1f85a7806917dc58c1aa76420803b686fdad267d86d7da69191d4c27236132536a22457a481fe3fce1e37dd87eccf8a18dc6e80d151b7bf20f875d1db0d9239ad68d6f380ad64f8f5b7bacb887f3e4d0cc985f638f457743ed90a710edf3ae937b43922a3beed4d1bcc557fb58c6193be69b648ee26392dfc816bd906f9adf1b3739800b69ce97dc6d8ee2acb233432dcce3ef03a7183a0760577eff775f4d6533bb84f9d8a0ab4677315388e8674d4159b8b15619f5f8fa8b4cda0efee6bb23098a7ffb7bdd748d18ae27529a251adc560b986f9db6a84ccb15dd3b604ee1f210e90774e5046b1674eea0495c0061cffdac207db3f54daa2fe3df3d1a90df5cf1de35899e2008c056c25cf873352bc366ed6559604d4c02b1c588dd423453da25c495f9871945fe9ef2b2a2028bf1999f2a158f6177e0d4df068864c9980fa72c71f0451d8c00deeb16040618de494a5cb1fcad6ffeb41c7b8b5031a861f095d7fdd664f18b80e68ad3568091ee24f096d99457f95c0b02aa4b50945b8adfd2eddf36380039ee134e99cee553cfee49e17887f0d32f9101c382e02f67796e29cd519788812a1334be290d5c0ffcc750100d37d69fbb44e3fa54eeb6e53822d9f0111f34acc3e1d5eea9d2aee9cccc61e8e4c187d957d6c2f1a1403d928665e5867b183cd8c918643be5ac4dd78475050d7fcf42cecfb471855c17613921b60473aa9d70250a48d892d84a5861b72452cd911112beca73ba2a14f6a5f19668da64fd445c63d6c9edb159eb442d00c79444c6d64d8fd6931ef5a362800a6697cade3c6e47dadc2bd7a8347984e8c28bce8f9e63150a0f469ed9e4832f3285577d58b4e544764a05e455ec7b571ff2a72e65462786e7e8be0be0d01228800ba78737938dcb74798dd4f7c587790d7623b5da15ae507c8b2ca304b823487ef0b50e46033f6061f81b49746f8338a7067f569e564aeb0cf33af3db7ca038f0b6b6fbffe0b8bf03e7e389348e8925c0eb943c245a0df181d68dae12c9c63fafa6aedc312d0f5e967158f956c06abf308b555db379a5e27ee686d69b9618e4bfce6b12cca26e733ccdb0218bc06488275dc08314a22e6415025fd0d6cb298078f74d3ac4ed12c95c2925f9cca2e9cea78d9672beecb0113ca91ee6ada1c8faf9e127a762a66910d3940481e21a883c76fc54bbc49d70210f196e3accf0c2575c46c66e97136871dc057ecbd8628707caf3a1e1912a87862884af0fd3c151e12660648def33192ec0ac96cf9bf7cc61e22f0de479d2d5e462b54cc27f8a14adc5da209a65ed80558ac202b6505547d485764005317543e2c8914056f4e13da8c68de13b582482d66bac47a032c8439810a5c4a8308d314d2545db11cb8ae16d8d7ef06e950ebd91f370d85fa75e4fbfac4d53e499d42ca74727b137472e2c1a3b1a5268dbdb1fa6c4e83fcbdf444a14dacd5c363f9ceb20e5bda2fa91991899b34abe287bc6b01092157027abbac4ad6c63490d51dcc1cecfcc98b296595b3b44ad084a03bff7e6acf8753626e2457859721ee0e4d96c7d34f553729ba8f8fce1a4f2d708a4db3c66d93755da9251745f269260b0e79e8aac1a38cc96b974802387f6ed59fc6db9bf8175305ed1a8484cac629836dbb71f38953356843e6c0ec1164bd2e4bd59f032de3bd3b8941a57723424e2703d58e2445797dc51b5a91432c2b8aba812d03accdb5ca568a37e23aeb5ab456aa4f3409caa7eaa3c571b842d6a588f424ba47efc9b7bef28182a880fcdd5e56fb7572b02d18a76dad252fb39093a49d44d1917cdd628ede9695e27e690b9e7ce9b57663cf601b4e01538d86d4ae2233ab63fb3eeaa618aea6c0ffcb332498ee7c869ba9aab29810669cd996d0dff1d21a280c4fa9ff2f64fd215d47601ebdc04bdb1df93a466f02a35981e11ae2ea7ad7619d658bb920c7c9ab2999c3e3d320f318e6d011fbca8e037cd3bbc059cb2acf4715c3207e7278f66557936423ee42fd777b7f33ea7496e7b13db29e83befb889dc72a6a921d1c1fc25af10ab5006eff018a89d06c5bb01437585bbc0a6f12822427ab112d3e62d200755992e08c707b00a6325d85132ba2b3fd75854999f15a65226088ef56ee6a4e5dafbd6524bd333f7b239ab76a045287ece4ed646bb90a2719679fd1de7ce031e02ebf4e78cc2d28fdb02aadf404100d748df629b65215e9bfc41bcae8c9c8fa2e25ad021a34351f5ebf517a26371e5106cd591d23798ccc5806fd8f5a1d81dfc8c9ac2e30597e9704db7e71ba287f9781bf18f3c5b6540a93561a721a56b67c7077c4c266f737d2ddd3df3f70ecad809e6a339a3d3dcd451cba25c8646c140e5067b46ddfd2c75ffe59c7dadeac5bacc759d2ff31a9c702aecc7dcaf06cd49cbbd52454c95ac5420c2b4bc267d0f79c92c39d57589aa1e070cfc720628c0066b8e4b894d992633e65be8147b330840c1f1069876b355e8f984e70effd457c43be1cc5239b5be837d5579f2dc45286104692aa2915d9f664d569cadf7f6d6429354db47d72a477ef7e1903bd4f9057e508fa71e84243e0f63698269d2a0c5f33e17e7c68afb2f398371999c2dfd1668f3911416837ca5fae015b32c8fe7be264b831b308c27097f65a6285cda1e9cc2f368ce89aa4d4e9d7614ff6811e6a855fc28fa34ccea39b10ffc802815bf2c7e95682a2948bfff38cc8e028f8d167be72573fae06f76be604eeb59235b76324e98291fe2dad1d1a36b67c47928912c9df3a035b16e8bbcf785cd891736576a8db7ce6c00d47a64bcc6f2c5ce71b58d3b1feab034559cc470ab2faa2f7e9881b6c2396192368f5c92b6c80982aedd6bcc6d3cd1573bc8f6203901f87aa28f1d0aeb88c31d5f8baecbe0db5e0be4723f4fbcdf5d2c564099fadce2fa18259aad906a7f689c7328c2c026425931341a66661be12bd491338229c7a1f46bb611a31010a2300f8a06e118d44be9f1875a876187a69c410dba60a22fedb3e9cf8b1cab5703e8346280c8945780c7ed5aa9d7cfe37e9465a9a7528fe83f18d9fe38ee56fdfa5cf2fbc944b86ccaf5741c1cf0109449f704fb285edc8a429cc547b991ce4d6b7eb2bc989d1ead2ca634b719a57cd38c2cde6c6becf332c6d5994a7b0fd1cace23b7bbb24659739bcff37f49159f5d0948b29e82228607cc7df3de966f7a263234870d55b442837c17b9563e7f55a3ba7a037da6f9d63db54a4675fd5286f8169d08f41bffd6be9f5caa4703a4d624d6483edf4a04378cd22e45044c27a4cc895c2c39732369b804a9806d102167bf4368ccea40813648069ad735be77f402b4773078ac1e4d78e25e0ea9047eafeef43920849a2454e5ec7367e70febb05987c8816a80f1cc5036537e24a875a64c84adcd98fa06b3ea05e64cc8d25be6280f1f823ac4af1012fd2d25c8faf9a671b7308e82b038f7b9c114cd035421ce74bd19db0bf169b7c5c2938ecb06cdb4f70bfbf455ee54d8dd418df3a7ffa4886563e6d58affc7a57fa7693d8271c699fa1efab9c40cbd8d17f3591e9e9299cf683d6b24764533da8aa6d0cb755a1f7a66acccbb953d2afa2bca6ea316df7ab62eaebe4be616633419ffcec20b3d48112aafe592b998447c0ef001c27543111b12e78603762984851eaf9cd55f1e4f6c49ea827169c653179d0609a08f3c27269f6690901d55d3033d92a7767e6a801e2ecb21191831359a3745e944375fea4cd4a1c788305af9b69c5a1faaa1b6caf620f0cab1dd5216a54d710cad2fb4fa67c2d43f57463abff5de64f48ddd98d6ce5c8748a25efcf4d800277bd0e4bb5326bd84a63f93b4bc9955c1d1926379f5fec47fd57416a46a525c6f32e2ca9acd84cc7a60a85782d6d39cdcf06d4ad771b21e0342af0f41c08023e3f0a6a0f9c26095e42a54f69f28104c47aaea9becc6974df3d6a17a539e11e4c31b2e10a48e3052eba082ead81b2cd792f77b27c8c399676a40fb6a7dcde004da4b5b0587fc2bc6211762e19a5f7bb4dff47ece7b2b01ce8e9601df110ba492cd69e4a9ad52ce20cbb39a04b8bca781cd5c94a6f641628f2de00f62042f5982407a8fd5724a7867f7aaced8e32d0918e9ab89653118dfa8962f5823f82d5b85077916d708bf50fcb4831c6857c06af2e04d7246e49a0914943c828cb0a17df4472c9fc4452dfff34db8a1d4242d6023939417b8dd7caab54eee67b6f293b250a6ef7cd4fec6f3492aa9ea9d59953b5a1735b516a5614c7478c3937af51f485910dfd8bb12c0b1e743ba3df39eede09fac06eccde071a3ac018bec3f93584d41ab67f44158d0834bf83eb6a6001424c2689226140ecb51654c7b0880d9f2db6f30b8f8c0c894d49f9e2c2d73b0f799f27aec1db3d6559542bc450171d3e95f9280bfc4dc8588816ac10b62dc4592d891c75d5903bbfacd35aa30a30973d14071aa9c865fe8ba9ca823bb0a9fd390efa46f09e87f46fcbc41a9b3c47afebfd208525d36a2a4d9411b530cced2bd375ed9842566060eb1a197c5234f170653c61154d43415d97ef13ab6f70707d7e7653677bee61fff54b41084b7f6215e6afdf34f0aa2484f247d91236db0472ba4e8d0c10546a53f294770eb61d8704f50c5f73ede05cdce5ca687d7e4dc52b031f62d1dd7961a07c551a54178bd8dfb070b9d32efa4e1f07782869d22e75cdb46135d52f9391a7bb30fd3db1ff833446ddba10a1c4144b723b800d03c9ded340333dd64d99ea3717e216aa2d1562569cd63a75b42d8a4b895987d0677345a5e5bcf8d4f19decb24e29bb7c139aa688ab6af223885d5603f3055c8851468acb1561d17ab425596adacadf0c14a1674857d0b717fd7310989e95db6d7318baf672302673594451a5a044fc0552f68ee7c8518263840c882c886c95b8c9f90a8e4517dc8c1cc7adaa4556b434b3a6f6bea95784250b813adf8e78e77451e0c048e97558aa2492baf6252e930fb47530272aaeb16acf97f547d9a9f25ac3d43046e4e764536d13c406c6b3ac1528ab9c873a6fd6494e01d49a21df1d838c33b95d320d5997a02bb28c20685c7a871a46ee4b6d0cc0142d938d435c62b9fb4d8829cf49daf9696d56d4c0fd24ffb76e644c9c942c058a077cdcc0957c0c54b53a73208c9a7714298ee6f3d9d5a6c2a3baf5619ed66a738c6742bbd1d23c6037540660edda0c9bef2d9778d2f58a9d9512be7cfdf4c2d02f70ec228a46fa461dac19a898206e27706cd1cab288e390e54fed2acb5e875292cf8b86cbb4338f3027a0b249f11a81f4ab1a91933488d003c3c9b40c89096a43cf117202b9367ef663ab1bb012c6d17b3ace4e1431c59e489e07a0bf69a6e22534c4ec85cb8cb21dea0a4f6d45424c7cead1de9a92071d322e6bcab97d58238870bd3e6711ec37de4dfe9fed5cb60ab1ab1d15654b56c716654c873ebb5c94365e04a064ad451f3508b76bf1d1279fab9bc075bcb06e7d0b2342684307d8a1577a57307451a39681665688839e5cc055efece668850f5fc0e2932908a7f9b999a13128c02b47bcef9caef37725f69cb8061eed2b63bec22c3c2771aaa7343601cbb853a48b0464bea70ab9c1b6aa76a2eac6e702ca83471fcf37ece779affaa9741b1bb81c1bb65aa28f0eea2172b4a96be3178072ffbdc79d14d31c95c3ec29ad7ad3cb6b671dbd992b030d68d243a243651518536b8cdb1c4e1853c72a0715362255771c8f79fc5ceddcb4151424e779d155d44f33e25763c6b146c680fc9c9e916d56c764107300b49e8d5ff7f882286851be668905d96a290394344a1f4bb4cbea7ffeb08a0c52e05f8d4456e817b79b53cafc7a6934acc71a9f889741664292494393a54cd721044aca535444ce93da0df80dd7d7bab6611f48202fd44d262689e5493615224bbadf744d85861f303a65bd974080ab6e56f98a033da08068e0b5edb55181b89248c97b63b8392f2a123be66c3002e6b91fb898c262e362e138387f29bc04653a17adeab34f1b58fe507ef3c4d9509c092b773d0601a21b591771fca467623778490a56d51ef6e78a3dd6b3995229543fa0562d6d6bdab501159eb3dcf5ba859f0cd1045fdd7c1c2f9b13e6422125ec39a5299952dd8697bf9f5b219f6cc93077976437d8594007750ad3d0a8ff30762a81684efa0f8d2d42e17b66e16f2f753e660e057f6a2a76c3e408216a2064c89a41b8144570b742583fd9d391ffa4f9a6cef234473854352e3a56d29e8cf1a0d519621041966f60b61240d0d8d22819f8afd4c0f854ac13389af261bd8d97e8cc4abf1d322e4d1f5958557a7ce92ce0ea8cb9f04b6d7f99515d8d97f464ebbbdd271d4b4f8ab38fc1683880ea6b5626f022ed246fce298f48ac1b6d64e6c897ce119cda440b58a27915a4a44c3be998d0c56b667dca6fa946d48c9db2c5ac8d61be6313230358cfd869a910594cfff8357a24cea84f88003dde64583825193651206207f94b902807e2f11e3b58f56760bbb5a0e38b167b825fc8db44b798f810595ba71c83021dd35fc24d7e05e192df97e9029719a16f225bdda4c0e63316712f0e008e3dafb8d6c1ca4787dcd97b7b2df3eb4bda9033477b3f370d05602cea2c20c6fb88244a88a48baa022b1a3cfb04ec8e8bebd2fcb58fa8ec1a08f1903c36665cb0d4ee69c64765dd8a49c4b2554e36f6a1c50656ed73925f1e81a762af6aef6b8ac02fc213f99f61884a22b499598084a548cf4a60f58b11609eb14c007deb983df1f5af994ef255fdbd70f93b3cd0ebf9005a966ad810b64e3d44c876fa7201ebc927a4cd03aeaf37a5e8d089b71c9ad0d7544198dca20ad557baacac953fe7ea8d243c7e01cecf93cd710d43874577acd94f36ebc04e1c07fe6d9d219a1b62de96dcc3c19c9fd712befd9b878eec29353eab378e927cf449cdcae6f90bc768b8ca8ff6b2a76c39249629682827986360af79c3dad18e7503d401cd9a69b3eb0fc06d22cd53e8781169af3280f52afcbfad56788a32fe13d43b7b58ead84e9bb0e8dd4bf6d6715e84563aca0f7b711365212ccaf71bba53a32b471d607ad66d2e34f1d15c01f51ae4488a7989e7022cc40a07bbcb48b2b9a8233b098e0f79b13d23184eb2ce73508528af7009c7119d4bf57be3ca23fa40da94bdb48de0b52fbca1a7ab79d370950712272aecbdc25bcdea6945e431be5e3ceec2b59b288440496c95b67449739bc5a595b0decdfd54bb24f6e72fa182c9f36491999aeb7437f3e8514dc89c047f098902b5d8594065f193a6e09d7b0fe7d4098ff78114b86068145d82314e7b92dc3cc155d919b4c4c19c29437f4e1ff2d77e3edcf738011491e20e98f88fe82c8ecf9ed4af6d02cd1e631e40a92180ce30e049b03c8f838635976201b8830688d38ac08a1f27985d7880d738d783a36a8a8ef5842275d573b6bb8eefc8cd6765eb6ce6a8adfd1f72983b744c21d9abc84e26871f038bc3c18e99e531b654727984090eefd68473472246a77784d3704459e215bcce5e9a8511e1024a2fa339e0388c845bd4a93d31859948f86475ae8962a0799d0555b9586bcd3f002f647d7f7db7662c7f4bbde8076faa888ebac1235152b0a5ae8d643e1329d3bab3fef15a8436005eb57766b04328941c4e52b1d00abffcaca3e09cfe0dcbe2324d63c60f3f8e573f109674a43388cf16279c51e96ee3208b434bf8fdcf845f3bf43f8a664014c315b9d6d92d5328763fd3ad75f37becb9a3b3a45b6dd19e64c64ebe4f7ab839e7a55f2b7594b253fdb65ba315c869d0d469ca78ca34b2ac0b4764b354ed2c529780468cffe761ee685fbc6386c55440fe431c3dfbecc3b0827f71b253281c3d523401a698a206ecbfbbe496ec15d1892498e4b795d5b576f59921d7e1ab999ddd5fee567326d140cfb984201c9660a9c66467308a176e405cd4ac39b3649159574320816070912e3e86263386b3a5da42cdb9e23819512bbad408f3760d0d65c70b263401f5f730b0696e962dd8e811f28752a8b101efa4f3e3ab954cc78d8339006cf9be98c97654a12c02aef0211f89587a9721a656c3ff118ef1e16062b80fb82392ad9f8c09f6333caeb9e9bd6f12e38d97afc15e1635379ad58adf75741b1b46e0d4a4ae81fa722662fc5dc5b0e69d6257f3de9623c0efe37c2f55d7aa010e5a7c454632bd1bd828eb5c4bb0bf7d8b1777009133d4e063861ac5a38f3ef4719aa10728f680fe45fbbbae90e3d60076da00c8fa59974afd99594c01b2622ef919f6d916aabced0271aba91673b283661b5b0058970f01d440f748ab81603ace5a3793b7319e38303d8760ed58a6e4af14fb683c5cd9040f73a9290ea31bf3856f9c76fe0457b35454bc8b9f573bd9ca334c6f7fbdc94d19782688595cd300e24de5d1ae046627e1be0d37f50f2729f888b4d4d2656966a57d3a7a28765d8543050d9924f0e6cd9cb0bc8c5c23492f94125203513a1bf5c5db7fdb0aee186a1c97cb95bd2fba564d33ff268b6806dbc9f9d62cfd776c28eece2c4014499e396dc6d867487463cf2e8d7178ba200ca2cbf83ffab23e3efd25d724e42921079b816ac39d912e5ae2002434a7a69ffc6136d0884a46c1d1d239c6bd3cc4b82880e031360775828da8f941ca901edd064900a84159af5a0a274ebeb68d417d3d1808d6c84f1f3d0b86fbd0771a0d8eca901bbad2b474e1a980e68ca9e18a110a09b9ddd56861d021ad5950f27187a45ea8263367c47003832091d52dc37085960b0ab2c39bee8a1af30b03045e43d88870dfbc23ac646058e6c63970efb20cc79762c8aec8ee2efbf27aa3b793eef21b72c68e94bf519ef4c8cb498afca002ff27f0941e4e905e70f3d64855311b1712aae727865b56cc504df20b6c1dfdd4961e0862ca1ed84c34ad2940758e2581cedde5c011ea3276488461e2717aca5f3b6e23915a414d861949d79f396dcc58d5436854545d032778ff317c3061670f6d335a64113653551fd1272fbcdf2aa8296364a55e3c01ef67c426a7c6f2fa9307f94bf21f3c83dded22ec808fc09f213ee328dd1201bee1065456ea1ef38392d6ce44e159b2f100c41556e400de95930019b6a5abdcd4ef9b4341a7d7a6072f602c1d36d580b3805fa9a065ca2dd8e41785cc061156fd6ddb062c459c315b25600fbed440231d4f8a7eed1c19e4b68734301054960b31b9600a24e5e4cdcc95226bda72de4f7a5e404aa50ac31df5c2d119289b4fd5ccdde5ac284879bdab20b04ce67bd79aea2078cf45ecd6e2cbdfa2c69b1105c39ad0d08d8fd8f6401f7fac72cc122d40e94f8746242afea777aa422c6a9cf02000f9860e8a0bed093fb49505ff8920b156a9cee0726cec7d80e895215728a190fedece981e94760bb5467bd419fb198dd461c023a4b50452d5bc68d3e23f57f010a043d7cac608d4f89b5dc22d9215a6b5df8366f0c2f62b236f5e806e0145a8c2dcc444bf084a41fac7173cc405b90b3b10f9d17ec14ee3e3ec95db40ebdeaf5eb1de3f786128e69f116a60b33344a23083a3c632847ece3a3445a6d59895279786715a3ed08880832970d506f3742287aa3ff1c3ad7d45c7f6e4ef1aa5b2aef5f3d86425ad3efc30d93507b93fd01707d8d13f30604625fd278f8fb03ee687f32fb98a80b06c5249208c32b3c45b439a1f588ca887678c65fd0f86a5a37cafe1ffa902ab5c6792184f6c78479b993a48a7f2bbe29bf8db58f5062b35e463cdfc5b366c79021819e83eb973166817bc83c67ca10e903782b51e8d9a91a921ff9064d8fea0d3e26a1c775a3fed0c2e6841e93195bb1965d27891e922f1a9a4ec640fe620011ce116230fb3f83a002f461888ce89c6c4752bdf27092fd201449d67461a0977e434c6a48e35621810619011ef7184b2b0a58cc603c57b46c56331d163933dbfc92dd493212666b04fb9cfbbd19251e0ff6af16c9dd357bfed1dd3c3e03c59ce67daf16eb886014116a48a4d91991568c55e673bfc66761730c6b75cf561d3410d1d4d30217d4408319c4118f4aee932086892591e6f1ce3a203a2e60a4830025251feb7961dfb89ddf3be251ba75a7646bc804d7f9fdd61d198dcf9acfd612fdbf4819d20920fe12a635e745445a25c0a83b6bc9fde6e5dfec9f2de4a97899d6fb9a295c76eb8b3ff75f0cf0425a79fc47a45a641bd0dd2f78ebb5664718af919274d39b15f3fc3b5f7817fd56c593a6f0c6859ca7c71346acc56a57f44ecc6882109f15a019d3364b71cae2f50d4812fa4852e093f8615cf8363eec64a8d6a49480869221ebe17d375298e8bf02d25f9d3395da5e69c865dc009114a42ddb495e880eb41cc5aff8ecfd50bcfcea88c1591a70db42d314b9e19a6720a461ddcf872ed0a518d1dfe7f421f4d5bc45c9c716be4208b8679c71e061ac79467816f9fc87e62695f97e7698d748d4bccfb3dcd6912259eec681ef4ca5480b91f51cd06335b01eb5b4ae8622cc52a663d4456bd30a748bb014b38ca70ebed60bfacfe3d3c0da4c7edb27bfbc6cba15acb72cff2b5706deffa1179f3469d21ad1ef0d96b71a9d23a5cc93425ca2bde4dcf7f1a431b6eb946d8f705db810b172a25d073a979caa066a0e56a2691288fd10aeee2266bbf8c852cb49e966262b93e1e36a44b5dc695ddc99f7648add9e2b90b89d91ce953495f3775808c391cc1cd37a8703c928b233847b7f3ad27a842c899c792915d923bf5c616a1a84d023fcea35cbf2bc5ee36bb9ce08f815da36f043e5612c8e46ee910f3e989fe34d4fcb07a4953b76008f0cdc6dde87455f007ced09f12c5028bf19d25643d6d906de3ae834ddd73b81c275c7a7a7eafc88646def348a26be5b06e71bea8719c71f414b75dfeaceddceaa0f88df3f2e77877ec4dda5976bf2fc53c6c4e9dbf3dbd73312f0bdcb91493d9e897c36327d19d36409abab74b5596127d77af0b285dfb43dbf663bd7789de6b3550e29e4cbf7616cd53b144981722fa71b3518b4982f0b4dbc5b95f3008e2df022280c52a86a28089e0e1ec3c9fbd1e4140e5acb128015adcbe1cbd09a455b4834d3f04f957a9e1e6ae69431ba82c5d32bf5fbed172fe5b0517bccdd9d5a243a15e0639333ba1b50c532282406457a57f904094e474480a2ba67a42e86e7e4ffd229afcb3e5ea72f607f18d84e7c34793cc221440538e1c349dd9a5c8d75806c1091000fd10af77813989adfacf0eef3e9eeafb642df66d10c8886cfe6f88868af3d1d1661a2a99e68dd7b9a1a04f1037cc4fdd7c1c5273ab4c88a001ddd84a908603bea878cc9ae92a7bdc9db715fb227677b00b988c664d73d403b9f69cb91d4744fe6cda0a6399a8ef78540df5a8fd8766f92278515061993079f00780275d6b47713af6470a2111a55b0f6bb431aafa8d1c460bce39b0dae43f3044fbc68815f583f2bfd7b872da2c3ea25466c244f131ce343913a99ce629432dfdb4f1090d2ef46cf7666a86b6c93a19e69734260dc4cf73a623dbc07597cde83a2ff62b76c5e0992554fd97bf36540b3584633fe9f6c53cf744d3ffaf0c6a5e3c99a04111f5944c789eedeb6f5451db7679288350184c02b757f55225e2b9cb42763c607fb0bcc24894805aa61dbcd9a7052a25462bf59b35464a012de69e2f97410b0dcdd5c4982bee47223212fa5a983f84d56ae9d5ad2f23d15a99d1cc1f6b7f70a2aa142bf25d48e2355c4e0fdd12b0966892151746134aa66fce7a38127973509d33d006380e0437765a56740fd7377b4929105f8900f7eacffa8e388c5d0c66eaa855f24001b1aee2e997510e8dcd07e1743891a14557fd606c8b0e122f99cfb7e3298c780df82058d40c5654c6b98410902897cdceb9bf8ee8bf40bd71e39b27ec6a6a9a0677e0a3658c954fc543ca7390c709f4217d619d297ad6c7a46c651ef54a6e50afc634f1f0ed8acec0fee5985098b4fe43a81855077da845b68b0dd758a2f5cb331c1b16f50b32188ff780727d156866ca7a29635b49e446b339f398a196d04d461026aefbb207dcab10714b16e4e9f340b241166c221b8c683a7678bc13b60e3fa31381a0af5cf0c6eec0f93075dd66fa413a1194a0b6bb95b8b5ec66a0558156f52c5f13ebae17d51319ada6c4e65a96a66678c7d5b22014c8a69d9e9b81e61d0ee8dc0c51f0e21c38eafeef3757c30a8172caa5b37ca9443ab7bce22c829684ee1bb1c56960d468603325aaf3eee46061b3f232176e38dc2506dd66b7dc9cafbd13be95df344d2db6393712005def979153c75bb9b768f5c58d5165a3dac91ed7496c8aaf9d26c0563bf577fdae49f3e32662a8effffdf10bd44d47a698e189a618fc6154d5f36633","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
