<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3fe07b9177449fd9d84f53b63da6281b8811e57a6486773923bc4e3ef20ca0a8108a808ab2de3c9581e9b14d961d6aa54c8f77c72fa326b873bbac8f1f009faa77e370070630912d08f4d484a6e4b73f04a6b142ba96db573c076a01a137e600702b2f3617be69fc1244b2bf60c0402c90c9b78851402b52862ac9ffb6656cf5c3bd66494b33951e7dbf57754d2b1b1e6f9c6cf63fbfab9dd7ca7a48dfd3c47706db990404b0629c37713852c09a581b6ddc67027169b48ca6d63587615835aa86dc084e7ddbb8aa6333d5e8b272c0d2e3290d3a4013f49b774e18f423bce19fb4bf92f2174d12fa9f8658c1643922a9d3b15bf8f515b9361d4b269619cfc71eca1d4f4f8fef6d3958b98bb77cd78fbc05d5d59f3c0955cc123f539d580304a40a5d2115f4ffd2e951527a76ab3b45762f717aa3f90fb37d749efab872fd6f85f5eed61b8a8a533c4461dc3823fa59e3620b3af19638c6c86a3c5b661befaefee47368318277bc7a9b3c9ebd1f535857b6c9398a297fcaba178a950894263752bbce05e9793af71f4d819826c1792cf6cca93d6563164e942501600393e233806bc51ad4e0516c19b434cd55ad6197723c21c55a5996c08a82fd2837ad473296df10ac3f5af8e444bb2eb5e43e540454569cf494091765710d571d3f0c11cfd34f415ade3ae97a020d7576f821e7b2634f8eb6d59a93b5cae1d0e13c862066ccf893300291fa3043ea472abf2628c6c142dac94f083ea927059ff1e4604f2c8527d1e437a14813f07be78866e5ae0e05b468366ccbe787a47ad654bd98d026093445c1ff373f750992dfaa0b2f644416d1eed2c4f313dec0ffb1d8827482b6c8e438a0e16187f916043a1e0045b984e9b87502d72cacc7d883684b68a2e57af91f61a5b447a818ff97003492a36d301225da1f90691fb46893093099c794842f029681874b80d6c576f0d778c19f37de4a4d4583f4449b55122d48d81e8b91bc056c6610da379ff38f6ac505b5ca09ef285dfb62648f047150dd1e407b7b9d0895d326293810a820c4afd4eef5d0541e958ae5441c058699102eb8ef65317c5e81cc8d607a3faf7aac5f90ee2d8b9f213b3d13b6723920c745d46612e76b003b9864bcdb88df515d7dee334753cc80912d1e6409dff11b92ec6624ac455d3f7ddf5d544b5712a0cea99aa81653ea88f7dc432ef023b3863c79646e43e4b36df7a8b0e404c00593ce9c81f1d1b77c293ab38d4b0262e91e420222ef09d659f232f456dcfb3943159fbf12a73a19a2050c464c88a32aac36d755b141f59f1e6cce5679e731d8a755f4213cefe9a3a83c2ce0cf1623422c24a76fb7c77afc3e09708f2ca6a334b27fe7c6ee6c1119736b7cd1ae9491abcb5c265fc840b7b2d689895dbd591bd69b3c4ccd9fe9d941d9a3fc8d405ea2c8f2bbb4d9ad41da174370a978ed35d6f346c5b71660c3b42e4c1c8daf6d9dd5c2e6fce48639c2cfe6def293681194155746651dc1a5b0f2fd2c4b1fea327f255a2a58ba91eca878d7b797d28c7d9449b20d5431906b186e3edc1ad1a45f4296c1c987597d05d5c1e768f32efb82a97bbe621fb37671ad57567591ceb26df367ce8bfdd412487d37dae0313b76edfabba52f16959379278d184585dbc899fed2df4f729bcdb48a657bd436951ce7987302229c6cb07fe7e4101deead5c4212fc5feef0dfb9021fde214af8175ea9bd1145bb29d8c045b2330348a327d1348f867483d662f59f25b6cfa51a87ee849377a0a85ae4d589650740777b671abb12b2c7069867d313484939e38a1dc3193486b48da27fddcde24cc0c9b68ce221577726c77c829696bd4002a24a02f8c30450c257f17f0d12add423ad0708b674af9572de6cd2a7c3bd5511c2a0d97414de4cbae71f7299031e58eca1be3185d38a01de8f4750712b00a71149f1cc9a2189399232698bf77fe4c6268773ab64af9847647ddb76bee854ffcb14a1fbecd1c6d3115bba402456db48f68ee2f46ab79c1618d690c9b6d6b60adb987b0e33e3beba50f4c5d7a73b931a07924e3ee3ae5c8317873fb9f911c40ef48736d7faed3eab723c7a718aca09dd5e8d49777ee9ae2d45d848c868588634b645b0c8803cbb6cf317f0e426762af40d9bef97e879553ba8ad9643b69da5fd57793f67225d3dee3cf8d1585e524c941f86272656aef0f32d4f181d4b1f3dd9eed3fa749b1fa50d47988f12d1ba68d586b477c6b3b1dae45e6af3542ce11100b077ae61fde6e323f216f16914915e0ce0c40a3081ee1021b20b11cfc5946c03320ce4be8083740850ebcd8c9285645921caf0b5ec29f64c436025be67295067dcbd21c1487b540d3d8d32c3e86516c4014bfea3eb2bdff7b7fd6cfa6d622f9b5190f5073c9050fa73eddc9b377ca180d6d66bb1bc3a81eb017fa7fce53192262f0701c43457fdfc9a7db94ef1ee8b3b66e6620d9fc43511264cf4192f8fca76007749e45d9b17416af09b7257bcb50526b9efd9a7384ba85d9e60335ad7d2170c04f7e2e0d5f2891ef5ca11685413689c80c879fffc0f5bf54f1ae1ccf76967b9c07a0c96a9a5e28f6183567b41b40d0213bc7e922d7abc91b1617a98830f9544899bf1707f707fe145d56fef26d45976e420fe838dd5d2a79c80e98e49a3eb17f6a8a8cd502c6994511f2c0b62f8569260f0bdf8708bca9dbbf227c0417eaf5054ff8494eb70e0c1ea6d4b4e9b968283bb4987cafa00f28827dfb195281c01285cd7c76286bb7b87c1d833f911f9ff05bab684dbea25f05994c6cc2e09b4eda8c2c9938c24248d1079832d78ac57ec8673aaedfa9167ddd669688b75886c1a34284b0d3805506b1f52657e4b574d33b76196219c3dc7eac9d8b177bbf0a9c394a45829cab9d8a3c9349aa28d2355ac11c733844bd9216c0ed68da09c0194c522f9b557d1d906f661f7309013013988bf7981ce1667afb5edb07adbac005a1be18f0b48b4affc7c04e5e24a5ce95947c04d8dd18ca40940ae5175f64c2b9b8b9b45484e812848489b54ff0073ca4d88ee709d2da24a96c0bc69f5ee3650d1948c8e04e4d597a1708bee2b32922a46d2fc8f531f539e6b7a098320450784f67e8ee7e838ddf2659dbdb427abb7ea2fbe088c793da057da4376cfafdfb5b1b653feff0216d10a7d746e7809bca3f34d540628aed41aac5c80a7b794b8d6cb546ca53b5deeca832f90e98354cc88a5ec15c601f732d027c7750eecb6b270a144254df34104b87603952ec2147c36f7dd4c4ef4ce3c399e4778bb7eb1ce15ef6b33185d4fd1f3eee7912a9cc20b9b4dac09e897763843afeb4c1da5da4e950ff65cb65c3fbde570541599a231bca097c8bb1f562aeae0899a83f63d00292a5ad12c8dfc829c23b3d8ac29b8cf8798056fc8827a5a0b5074572bb8385119d346e2c83e294b24852c85fd737f7a00228b01b8e42a67c5ea2ac75b9c7595054abde5eec57f616891fe2dc825f2cfd819733adba412016e8a8e852b9c4644a96f2b81a36ebabe8181e6a22d83547ab6ac663ca042033cb62a4fb8ffce08c294e0bb1f8bfadff3b877634b3f288c97ff4cc01d19d9e9ff1a3e195dbc688c75c5f3d61b6ca1b465a15e9abe655d767b9463b7ae552912a89a4ba6518d98b975035818574974e614ffe4a2e4f8f021b0a2b1a6373ef7d6df60cf0a4113573e513cd07b6cfc4e233c60d7267c56849388c90c63b310a1636b6a3c131811bb9707154d51658c8dc784af0206d1ba8fb9ed4b33a9d0588deea44cb74142ca5e756493e49169d78178c104c0b5965ea0dbb641d11386027c88527c5dfe2c3efdde27a233df48a95b990a1ae55f09180c53d8a149fa7e57ec5bd362a54be1b20c985b24e301cbb90b195d67298f548882d9fa1bafb0279a451adab660e31a2bbc0915809349d33ad72daa414b7637b5a6abbeb7de8c8b3e8b42478b354761807a94c1652c6b8479dd4ac54226e25455f7874eda18858d933c1ebd0937027f3c7a62d4af82e191f211db1127c5bbcf8021fcb9abc4f638f0820954ea0a577fd9a8b3c89749059e77d7894495213bb025cbd271c2676a1b0339e53e42e9418aec84ce4c05172ff2c3fbf37fe28eea5f6e46038c5d7d390e6a599b677c240b0e577734a3aab3f8635d31bf6d070706089fb346d4e7dafff0865eaf2a2b44478d272c9614fbc3a7cf03d6862e001563fb17be01449a659e557003eb17df8f26b41aacf919f9cf7ee2fe286d03984a115e4e172bcbf3faa5b1360f673767a90533cc6e9c6bbd937b58f04ff6b5f04b3108629c71f05e4250c6e4ae03cdb35dde099bd0c6df0f7060ec890c5c645834437fac40502217bdec06e227092d6898126e04ceaf071e9f85ee236a54fd7206461365db2aa42ed88434f9c316715b3403aa944053eb2b8cf340fda3359be30fcee45a1a7bb99e4ac4fb5869ea9c36dc2873e74b4c98650e352d79df5467396e2f4fe48b4573265efe49be6f9bf88aa30c642197639b415f803ccda2b8a82be4d90bc8dfc220114b107325d9f0b7b6e4cb7951e7c2c999d244c72867be01b7fc8d74fb4ec2ba4a5c3c2e1c9fd3900b36cd9fa80a0b77366eae67254f5485da0fd0cb052dfa57b14d3b06ef1653fb28b01a1d27c4ab322b610fb0a010849eed8141b936f8ff21bf813fd3dfe94b66eadebf26b449d02c6da35b37f9f05cafe55a41bbe380c13e261951c9b7292e57e60b1aa25b5dda4ccf9490567561a9624a1a3e51b0aafa2d1a3c06058e40628306210e918caaab7577ebac4d4dc6ca3d6010790fb07f09475618730c0b617170633b79f94db1f3dca2c62ff50f06dbe31b6f129a364c6c2803d03555cbd812968f2fe42239b35f07715d5e8913fe3a08144faec50003981b5f7c8f76352a116f81709452cdfd84cca2fa6f2a2052f07c8c74d26507dd67ac671de585eb6f05245f9bbf3071dc21b1057f356f9802f766d703cdfffe0c6ab9fb7d0c5d2c8be62a8a502610d6ea75a23cffcd8eedaab096466072e95f95c169582e56f1e39e27c2dd5043bafa49fce0852be4385f444ea459c757a6992e3f17e96a7e36e1a471cfc525be54a3c482a66791a853d98b618365eb70565a4c8fd1ed4778d9a84ccb259a8afa060c1799d71f823f9f5c798fe123b49f650583bcf3840b1a8769100587dfa5241367a4e7b4a276754cf2f47065d60ec6548e0dbb198d04cc5478b4a6f8b41ed140c40478bc1d7a428334ab0b5d80cb76d0ca2f0ab0475a4e5e134c1892417e2d9f491c90bafcffb02d3faf41bd44cc17f6356d234a2282b81aab4e6364eb83ab435c2726331c3b784b54f2aae36fcdd8a5ad52bde35f7263875d9c7805901e2118d3e3071b89676c72af1d6faf20caba2b1cf99a2da8490369ad83783edecd1ae0b10882439b79c812da181e06b574feb87a85c0e381607c009f1a00ea131196a09e08995bb1ea0b31b4eca14e1b0ce185b278f791832146f7ea2824a5184ce20b4c443d878e3834a205f677b1a972a62efddd8c1474e5aa11ea3353aa27a0b88b47f925b511d5094a72256e2b77cfd1fc8cacf975f1c331bd2e6a389a99b9b1a5dc427ca19019efe9affebca7759fd13d37e89e4efb8b814e362427e0571b3a2cbe7c032b59ebe73fc442878dba0e12cac8ade8d2aeb3e58681b73d0171a2a747b9a988d66abca78c7ca63d63d6150801001f80fcd7931d0ebc61820880327cb1c019682154a6f3791d07a17b0fb57d8dee9b00cbdab4af6330d45fa020452167db81d4dfa879ef4e2b6800a96b3067db601151cbf88713c71ca8206bd5f39c662151191e4d3ab40723e5cad3207566038a14d0613fadcd29d80dfbce4781f0505cbd085e860242aca638ea024c457310de6414e9d1bc91fe9eb2096d02917ea643fac9dc9ff37e93ef718bcb89863cbe94dfe6a45188a8936acabaf5da477479c0dfb2c09d21e0cfed219c262d8c25cd08312cb698906ba79668b4598948dccace18848c7e7d75a14de1bf104915d8262920ab530020672b1aba20c4b847f02592419f05fa2265e65cfe84b92138fbb8fbaa06c4d82bf7f3d9a9612d7e40c1ae2a95659b9c4bcdf37821d7fe9395ccd2abd22616c9a2b2dcc84acca8d7b4d37bd5ac4388898b38e7792ad8f74cfcc2ea1b86a9ba3ff94214792e909a545c23571bb4e4db6dcfc3356c1b2fbf2184a08b9d55520ce43b76dec6ad7ce92cd729246677a5d07068eaa4f8f28ad801bbb14275e95a1d21e2fdc3679a5381296c8da9ff4f06656b401f7741831e65cea14ec2508f3304c653ae69222dc9010779ed8a649390b3f89a7a949ade2b244758d52657048550b29b0c161f1ee79b7ee73b5652225c7e8e1e9ecac94acbe10a512dc780952fefe8ee72c55ad409edde0b4c2397d365d3a4edb5f81c81d1922ec1d6fd93e2b5412cd67e3bf26dfd68ae000a5a01a373d020d49959a62ee14febc01b13e81af4065363b4f27561c037ff1e55adff317574aa99a25c5f20a64db5ffe57e77d579e25aca5cd8bc658972b5939a4be8a94f194debfd2e04360966729202e9a014dd024ce748ba21068a767213f4806a9f8e43c0f19a0565a9f7ec2542f00e7d33e63a98e74e7f9845adf1bc6b0cebac59323c66cf4576821befd1db3e1849e1cdfb777afdfd614fa9aa2c2a680b13575dcf3e843edb4cdf05931129ca9c6bd5bbd27f251c3a3ee8322da6a3125fd4cd0246fcbb3cf2ac8652578281607f9236470dd7e8a1de547e7662d771a8744a0aba80a9e11a62dadbfb3a2615a1a74e42619a4ed7a9268b2bb6d071c02bcaa1fc311247b95369dac90eae24f8ad7516f97fcf1bcf581eef65f6bea75071c7f5f670315d6c8bbea3dee30fe70978fad871eb026ba02af3b6dae7a445182b19fdfdcc8b706d24227bf504b18e9bc4a496194bdc75f2c474be7f7258c7aac8a2a9ce629027d62f767f9736874b4113f32ecaa3d81b50688c791ea3715e17f14327030ecd373d25d6d785e5bc32a3c15523e191afdb4af69eaa935221a477d6d7398ea0291289e540b3201efde985529b2994ad66476bf20e16eedf7456394ad3b3c10032db11e2badd6eeca73edc05ae84a8fa8962230d406205f8d25368a171b95f0685f6a4546daddb17a389b7c61ed42323a2038ec0fb6809a86bbf29eb0e75d43749329fecdfaa4ee2444c1a24377c7f075e5aab9ca5682b2907d02150347f0309525f69d3ef2392d2355223d033cc0def638807996b95fbecaf6e2b5db524712aed5652507a8b2f114dc062b21344f4065cc6ce490b6dd1581c06c7d8eb3c24df63aa5bc6195816ffe3357a77b9ab43b1e44dcfed25fcaca5ea77ae08c58cf940d93139cce1f3b644b2acf704823f6c7ba5831a8b7fdadadfceea6521c656b545ee2ed7821cd873f0c3f0755c4b538938f9e07bcc2a946eaf7085153f2dc416602c7eed933d6933c810085c3b1d4ef24515a15153545bf1bd3b683bb4c28d9ee6236d09a060a41d208a10718c9e6e44156edd958bb9b7f68ec032a5c653da55eeb6e3c3a7c0998a4f04e1d37438ac5a36e2b6ff11fb392e7065dcac0808ec37428ef04724d0817b1c8c4db48ac75c8a1b8b1bc568e93a5ac13ea14d620c55834fd63fb85da411bfc5fca5b99adb089d0e32f77f6d66f9af51d7bc9652b577eddd668df537782f4469e453f8f1b9121b806ded91103a2d97087f7a803ee5ea08f4f76413260b4d64f41a27e8d4fe17428b81dd42d20c82d1e598af22a70d643c575f787f4cf334716548edf62f8dd2ef6373f01a54c07a7e6324d81a6c62bb6e74cafb838b0c261365e9c2d5b8276735ac67069c5a889e000707061ca49c5c9f6b5250bb842d93511e755e830a41a3a4b165da2263a781cb2d1609ad1105ce1f68e0fca45789ab7506a151f2ebc448c41741cb775d82e87422628d148d822ad87b55577c3422e9f9eb79b7e77411e0c50d711d5819f99da3d169f455ecebd06417095976d1e5ba84e49e9dab8f3632eac39227d2a62ef3e898409fdb31358aa7ce4f0fd5d26f9cbe1b82ec531700b0d727f376786aa74b8009440082f065ac871f4b018cded0163e5fdde6a7fcace8c13a6f7ae8901517236378bd26c834ddd43bc446d23d6ba8347acd118323ea700a96746c943fcbdb6961bb8284663630629cbd8792ce7879ecb897719044a1dafc15bb7de17c8114d40a4158a6cd934dc8a37e0e15c3b6b1d9baba3f3d88c27b0c953c8a27a9f9ad1a5fc99794c75a4a639a1ab1e321d0a783408be933df0e4a8026233c60e6bdbda7a201adfd5b4f368e83bae743c694a8e3e735314f47b4f7f1e780f9f71c8954b217024fd553e83df14056346e1d90b43e1f49fadbbbeddb1c2370ba5c2a354490294b36d67d7e48c19495e8dc784fe5551f63d6ccc3e1b9022f4548d7228990ba33268c6c13fd7b17896b3040399a929a1a7b6230c399b92d978326abe487468cab48e93eccbb14c30d614b63f25ff4b07fd0f66040d791fc8a83f55ae7cc2a369099621bebc20c2559961a4b02cf455061c54f553341f101ae82d5d9770a7d544cf33c59b13ef6ce393dd56556a96a56d79afb17db0f3a3301650e8e1d181206ac894ca0bad04f205886fc174618a4bc266b13fca883c530b7242ddd3cc86b59df29588daf74c75d6099d38f5bb8b720a8573b490926cc93849891885083d689ec33f968a1aa089e825c1a9b143d3e69d0cb75e42d81438cb5036d07e9d89b209f3d85eea7ed884fa7190a5db38840bfd15201dc53e96e00a2fc88a4ab8fb5fe82fc79ffee3886a1aa2a14ca62f67b3f15365bea17658f89d7c13a66590a511bb5ecaf224a895d802a6f19b5010cba9820c1154e77b81d53261943f416b468943fd1ee432c25db3772ce35d0c1fcfea9cc5eba5e68a2e9a3d91fde293d068d2b5c8bad3a63b33f3cb0c33bcec5c2238051d2d53f2653b9b5e2a8bab28dba513e193e4f3fd259c07f01aca079d698fbb70d480a3b9085d3aab16e0a0fbab016e4d4cc8c5bd9dc3b25bb6019d81eb5c482fe0c5bc40c5de44310b235ad8bab1aa69f71a6fcae68b5f45f4c3bd667098f3faf548206c812121e1ccb74bf9e37a3975246ad40b913c3ff48140d721c09e10b4684760b6f38fedc04848efd5926c544ee6be403f4b3847699459e44e5fa1921e5ea10896817e4fe2dc1318ee1b0477fa0671b259c5a3a393525cf89fdde47727c5044e28fb31d4e86343d8863aaa7f9ec619b7375431e8ea4ca8a4341c9b653643ceb177269c3b768cd2858c74c558845f9a2953358b68f9e21cfd84c2afad56ed817e170158cf069b49cc69984cd7aadb2c3845745ae8bf2e870dc55323446bd59fb174cc9c525401e38a4e771fc8866ff6f1ae75bc5d26161370b66d9bc30e1dfcb74cba82d0ffafa14d8937c1fb0797dabff3b31cc01495ae2db2338c67709b6a43a306a9ca64663acc258d2d0758a04b694f3e5cb5a755d4aa828b95f36663b3535dfb1359c44246e4b3c17938b67a43026f6bcbe4297b1f9d475d66770d169acd2b0c326aacadaf4b22c879c113fb2df9ee49ec91a08c34f25bdc4d45838d3f153399224201da12bcbc3fecdafcbe172bcb0054daa0bc99c4fdc198638dec66587003ab0b60881809523c5406080d5d95785c37c9a39739449f5ab9a29eab6101c4cfd1bc9418af76628b85153c357c5b2fb090e2d1e77008e77543ca21eec83109d9cba05f936ddbebe1a2b3e4282206a18b05cf3f56ad29f22c9c297884aef9a738a171559ed729f1a3620a64943dab2b4e1093fd0308fb6652d758bf382d82be59c8c09949cb2e773b66b18c8f590d7926fc26e3c426979599f8fa13497e5a1aa7f40d8ecbe7a6c1194037d6f7c575ca05e8ba7c88afb4bcb039a63978ee45766d8fa80294dd6a07fe043151d02a4e8ea65371787067122a11ab3dc4e51f4947fbea5973e68907c01c508f8884996af59d87af3bf36406eed7c13f273be6504b92521945a4f9c038a65cde9d948b2dfd63f2ba8702a828c95e7a12be7c7293bcff8919c3f59f9c1472c41102722fd7ce83f5cdcad90c2be5d0a0b9606ba1219374dd8bca5c23070903395627a6c3b02904555e1d4cc83edac93badbe8383ec59fab76a1fe5a4d64ce9b97abc8e9c2697763f65ded00648449dd9e3a61a5f544407d03b48160353417267e7b0123308eb00d231f0b9884e1544b916e898e0b5f6de26db86bb6b977e81da05b14c634171ce460aefa498270874bfdc55ac9f76f5824b127ed372693664b533fc87a5de8f081bd3dc212073df27759981b05e486eec410e291302f999b410cbb620be603bdcd4130f6d99f243c7694d8cc6b195e758f9bf3269101c9f342fa72917a290e2b1b0696f96e9d6e250336cf9a1b2b18144cdd5d6f31727ce9c5b8cf504d7af373323ed42bb74ac826bb6281124dec78f3a80db35b7abf20721f9e347ae6e72119c4de2d3e46d46193bc3ee987e6e1b0cb73f7c9036030894f4919fdddb811a14892fb8220c8c3b5a94e6f211f0b4a1b9f7a49c4197c1341fe2e628ecbf80bd05f23f4892e11241e5359d6b7091f8a7036064378de0b5137c85e5ee4d02940dfed893978f7839ba99a4045f7df0089d4b084ec26b47c6216e145b1501df5f5a88ddf950b19ebed503473ddb29b2dced025257cc68d495a06abbede2f9cb83612414fb24402069d9a1f82c4d32e9b70638bba823dd44dcf38744e22803d6bcdd57481ed94695d2c9efa467f6baff067a9ce0444457269988e4872de2f81976ff533a215b80b25ce96ef305e796f73ccd538c3f0ef370f00591b17f8367bc293126ec3b67f046db7d34eed39b9ae11b7b9ca09a24cc177b5fe68062caa9af1bd8e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
