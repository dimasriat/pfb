<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f6ed3dee08d96233ade805a7e2d3586cd2abaf58ed7879505b881b1890c18b77f1325eaf8397e0ed06eafdc56528c12f2f7702ff035fec9abdba4395acfd32fbd8af4f7456e1db51516d81dbe8fc7885486e9289fdbc38bd6df96e83454116c4e9a0be00552d96c91f4f535b87ed9446d039a63cef7d3527f38afb498ab85a9edfff3ce02992f92bd5e15325fe40fd140e88e9a922a9725cc4f7f704330137029899fb9f4f3db6e4090294e6097d1bfef5dcaa970850fee3167995d12a0094a90569bf3848f13477fce03b75521231cff6daa8d08b872449606d866201b7af6926d52a42553ce19d9d7fcb8ed90a91af898b73ced38e9448e1b09b9496dca54415f5f63026c3197144c8942d4522a9c3192386ca2ae4aec8cbec56ab5bbd760c130a247bb5bfaeafea5d4929e9ce94e84d40b0b8aa781da0a268d5b9c0dbd3403638fe5505e65a326425840993e98e7c62e9118abe953ee32a6d17030bbb174bc02af72aa2ea61f0719daf3043759d7e98485c7803086730154066b80c7d0aea1c5cb78e6bc2a0d1a5e4b1c3eea1ac0c68b37b78b4b869a53966389503f3a843686fc6197c6acf5f5a967325c30463babbe933d74364bb581f803a323145362e0f5d950ed05b95aaac87f0e61e1d6f931c55fb2c8c8377a6ecda5192ea2b4adbe69c83473a6cb99b62335fc5940fc5da5caef03e284e2645ae02f997f7d777842366304d5c1293e1ccb5050fbe9fceae09af253c5e79a1a77b194663e18487f271bc945a96d5de10e2a03a0e115b08c62506f7cfe6a38d362466b752e4521c45a0e3581fe05853779463ec4a6eaca679d7476a1ba2d06d60a25cd4399bfdeb61164772cd8cb267ab3ae4357f0418f4c9d906ae90a42fbd8e8db14ebb28f23da92104e314fc9ea54cf1e440d2e0c11e271bdc20324783153746d3600d5bed161f95bbfee5e703e07fbc02552e1076d02653a1b7eafcd84b7fa0572a58776d9db7048fb4945889c3d90a15ce1a3b7737a3d5d71511294706016b93432440d1a7b31b1f537b7d822c4a55d99c0c75efb61d286567bd6b88a1dd36241eee11e18340c39a278bcf9f09e52ad0c8d7525c2d0d8baed0a8d1876748a68bb25eda4a45e83454d135cc67d944f3b521f2fc1c724efb3579c44f2eeb474feac6e0a8825304ca236c1b12d664754530602e7c4e7c560379b64e848afcfba5ecdd78ff7b209631a79d0094714ce925109d5d43b636ebf4dbaaad3e810844d4ae4f1a3ea6d54e4f4a0afac1d064623080e54994c83749a6a8ff44a19bde8b525dd8756e2807abc1bd2eef6bb41bb49c07491351acc8d0a0f3458c71a73003abfe511b21d92bb9469b542c6fda3a3e183a989a90166be99ef1a66a81f1d3ccfc6f86811ad1ecc13e0c90d14fdfe9c122e4bf20618bdf731ce33643d7721979909fcc428c35bc8ec38c9633fd628fe269c405cde4862f839d706d92e35d3a5117d29c273bf5b1eb4f9a68b9c7765305155fa06f689cdf69cb34e0f4eb4ad7397a45a1bebe48e8c3b0ef3d32b4d5e2a98e0a34513270382e8f50ad160520a3ba273e44fc19c7763edb6100bf85513a801ed68b5e49ee15a8b8d6383eefb5894b8fccdfe286a8eed829de8e7bed3187a08b2d1a0c5d95f405beb6243070e3e3d1b43f9a72d37ac7293892ed046df70e77c0de93608980535f22e3343aeba0405ec8ff93737f30f1056ad51c9c7cb86b6c85601f9644978d21545926376c1d3931305e6d153f598ed8f53742259315dfd9b3e2bb5d467de0845b3c1f4d7fc2fde7a3a71e80c72a97999c51907470befe6c5295fccf5c126e0982458f271648af9feb82ac531b684d0ab1a4739d094c396e1f94ce5cea7ff34f06bc11fb9948a2d1419ac221d4de0597aa122a29163b35f2aeba150626255ce1d949479f378ea0cfaf35521ec057b04cf1ca5dd8f15d7c1e36f168160769f1725ca48a1c8b0f3492c758b27bfbef7bc1bca35f5ad4624e56f5bcfdc3972de4934a111fa665148391309f8eac57b57838a0abe1036124436891c8df609aa7fb411d82af2baa22e2f8f65509496c6d27dd6e483b6ed1b12aef45c961323bf9b4d861894433fd568496e5c12978cbadb245a9d5cdf836d1893a7d73e9eb60c4a3489cc23ea84c1e1381ae25be0d685b71a35f017ed1b12fd851f2e581f9f96ffa68182eb64b62efdc975fcef703ec5ff6d3ddb5cf221b9422f75d3843c5a9f22f44d198dd248030840bbdc2bb28f6b52af8af09c8da1705f80d20836dfc7d78be359a7b47b71abe170c650a36aca4be12e09c8071a496cff6f76cf37cdd0a41cf6ed190448b5e0b5b73351b3e00b5e641ce937f522354e2df56c1287f372d48131996630d1d36bd5324e88c195b0c24bd6940847df5031930414c3e7283c7f8ab21427ecf583312b8886d23235678b3b9839601583750a348d89d8d14d2bd2e12b442cd4098c46040f73b0e6f1c633a47539bebbb77b5d4576a5ee30a3d830a78300db8758767021322b6250c21be07e49d0b2d2ecad90bcd70a8b1503e83f4d3141cc0388e2b076fa33d918b765c920818c8b6ee44d86dcce8ff021aa73e4b6e26add676414d349c66cac8ccc3f22e0773145e4e698b96b1b3dff7a6052fbc7d145019fdfd16752729de4bf1753f9fc58fa5b6aa122b564cd231b7179b958a44747d2be26dd78e383481a5a305f11c97952f7387dba0891d3de13c88185d5c9c9904af94600c4c87a9198f95a7a65edd494dfc3b60b690321ca1eec0207069606727593601cfc4a9d4ba995b3ee4db64fa82c458d2d35ed8900c89326fedb0f51ec672a6d13583c99eefd300107fd685220f8766dbcedceafc2f123e28430fa99208b591fa0f340f08a6c3a79803d14a81e8b14f9f288bb739dd7c56bcf3daf2fe58b19a13b30f667a94cf5bce84583ca1d74dc258e9859239a8115c28ad6f36e2752f82fcb04ceb6429daaffc83b1bb354e784ccf00c07c53e7e9efa190f3f978136d4d4f7cc388bef17e828ef6539b22d8fb82a5e6695ec8593a48d35ae52ada2bae381fe3793f0a5f4a87474243e0fd213c476afc84434206e7b1de758499ae10af17bb700444e3af13c951184a22762f40d86829230255f406b9705bb06f83c6bc15c164b765bd81ce2bdda4228221c92ee73f9c8b1dd8f15f3719b590d4fa29cf443d8ecc7ce25eed5329396e9e76b8f013859a05a9ec41a176b66c8df41bca3cc181a9508c0c2d11d8662202df3654d50f4440b02cee701e0082a27efec39330d9f4f41b243d381278f74b70e6d3a0c73dd98cedf94ec0d5c271b594c09205e9c8ddf6f5a5f0d135e967984dd28ddea0db05d306e7b79fd1bbbf8368397dc6413ac748854e5d5bb0e49085159b0a2040bfaf2f970450c09ed5d14a4b92cf3e5d343ec8d6ade07b9a0bc1d2be53472d18a05deae5ef5384f1988e2e61404b4023d1412786842cc452a8390ab15156bb6a07f80a87c1e38c7961607ad7caf930e83c2c2d0a11955356c5932c438a54110339b85ec9c02217fc534734444f21981d2db96d447738a3476d089e9f3b4287ce7299dc78553006bbfc1df9406b2f9f3ad52a633f322a57d22b266c1f74dfb9d6a8dc906b3add2c7451612027e64907f0b09f55252de97c4edbd290d2a03bb1a94f24f7c23c1aeaf55fb946956a2dfcea968cfde6f81e014455ac08c99667f4241f26e02a8239f78d2e62427b03c2bd5abd57f489dcfb89e09a59c2ff92700831cfbe47c395383fa2a04496cfa0b303125deb9a6fbb13aff54beaf4a4ed3a60fdfae2fb2a789fde0a9a498cd2cf80b0f4ce8e03d423d987650f43480f98c1bd3850afd38408d1ca51418024ed94636a8d81b1d88041068e72d15ad7e2942390af6fd8b51ef29896736e02222424f24ef2a8ad7bfb22a5f3411b256548cbc3c0b9fb81abfa4d8afae823539e09a558ea2314e9722455861bd89ef3949b2f9a145c99c024582671e441394e35820fbfef47a9d8e882eea4ce0340ab06ccb16068418422576d27c5002efaba05e2cd1781717cb064369b0896950c62d2fc58428e3c17d8196b6458ff63c1e133a368a6334eb688786af9f7e6128aa721abff5dc1b3f4b3c693330ca0c66a96a6b17e5da150c91560fa23abf54ccfd6d4bc8ac740722eaa1b19e55d5ae31df4c6fda53febe2780a3dcc8cc92766999e81ca3272598288bdca06f25269fac36ee50b5ffc7e320763b59f6a5ed8a64ec0149d7fa03c8d808c4ac9472d680385af06d64cdbb1fc761fd5b9e3d42aa12194f3c17a092fffb6d20986798a7e892e563b17ef2d2c21a61be1e351bbd1d6aab4431413198f301761457efb197bae1d95dab664b8cd0c16ab94e56d9defa14e5847f4a7561330de902f5c2965c7212f40b6520b3fa1448be618a08e47d6f92b4c9040828291661b4f7009925cef0c351b87a62414287584fab31e93ba70f1140bf4859783cd6ca6c56cf11bf4912702bd62451e20bf0687ac180fbc8d21c3e42d513570c4e1964b91fbc92c0df01bbf10d8cb3a282ddce40422eb8fe66df8662295934bb93fa2c16f20bd94dcb331253a38fcbdadd5dcebd7479adfc26fafd17579bd3607d4cc3c9fa3e6c2a186785b04f93ad52588a752a341b7f5c8603132c014467b2ab21ca83b2242de227c17c89cd1bb13e1184fdcacda03ccced8287d6236e56a32b55747d113f74a7ab55ab4c89899e2971216ea30bc1d235e1f0e477a8f06d41aa2195c7906e41984374dcbb05c586172444c256234ae31ac617fdbf55ef62447429389adabefde6f770d7bfb35a742ce23fa55146f7afd7445c903ddca9e74fbe360300a34f84eda14ed8ef03a7583d2674cdab656066aea34cec257bc79c1c50eb4583cb85b2e2a100f7291b038297ddbdee89bf3bd4d499f023ab27889735c86f0d302b81ef706ec71e93a815f7990c88772f04e61ab24932c5ddcba1906f5a9c1a707623e9e37e34c9f2c0645dde94bc064f4f7674836b610c95e9f4d6a828dbb6e84e6df1ce5e9d6f707f9706f06d2e605c5340ab27e7d8d9413e6f196cfb2fc200fee99e8cf51b63eee287a1b82c82822c3afd768418ec6b08a1e3be7b492475e0cc514e5c41a8811009c6cbc2a5713a5ccba2592c438e14029266a69c859b6e880f629b5a7b7f11e44d3b6481323b231cdd6c82fcda3d47be751e1466615ef2365f41ca58fb30f1b51e03b4a0a03077cf3afe010c59468c86433615d633f555a85f3f1301036e8ea00c74b35db242743a8d311869594eccc33f3db178319018458c3a68a6865edde5b16c34f5e48c6d7bdf10b9eeeb89860824c79a2951e322392fda84f12749a29641b368db295d8830a3b7f216941e72807a559b5b214a7f9d785602df75fdbc9dbf887ebfe6c01da23ea25b3c5ad761fab544855d11e12ad21d5f5328ace8174d4e3ce4dfb0e6ec95d85f6443db8954cb37de17265070e8c2100cf48c3a59d3396e2e0fd057d36ee60cf0efd31fca61e364b34a47aa6b2366cc5ad67b8934e256f65d2999e2d45a8b63213fb57fb44ad787391d0b2415feafe2709c5e647716bb7f5b39d2a6ec19e050e589a4749e87c8d6375c71379a9a5f34cd0f9dddb3e1e0302e35478a979f2e2dd95708482b64afa313febd638315cb54b01498e3d4627dba9ffd7ce59a86f6c7307393e78511c272cccee0bb03c8162f028910c62e9ca486cd90586c61dad66f22ff8358886ee986f8e787503de09b73a3c6cce06b5a01e801b00c345044018ddca20d28f696727e3e1b63021c40cd0ba619d5fe00c137b46d258945939b4478bf458d83cfb10e038afebc4e5f2939805b6b69ef42e3d83ae5baccfc3328d2a102b9733fcf0b5a2af41fcb24b77ac7ef1564b112d7d48f54121e31718fe32bee802c89b4f65a8cc27eb280672eaa55a96a1d167afe26a0c53cf7f2f458aa8d1e8d7b12a0aaecfce04171741de768c7fc8582087a30b598724dc26ffe27cb3064406854d0b87218d463bd167d8ab0cd395eb1a6ad3d1fc12200f7b465f5e52197fb81a506dd86d3f393ed5e9c9fcb17b375e72e7bb5c1bd898ea285b0b77b3bedef5a69dd4b50e6b7ea2b6ff5d4a30a86a436b46747ad396bdb4148470609e78a7f6c21a00921c43f4f426897c49fbf093066deb9578cd716bb3f06cb98dcc74d430a3e9d306e3ed0da7016f4d5829716206b5756f1baa43be80f08accfa709f58420cf984f1e3893b642fe7bb10b8a331f497faadea63e07d5b10e3c5ea9ff178b4324bcc759d9add5c3377ffb017ccb552aece90a90303c0477f5e23ad7a3d7943bbc9ca85843b422d4aeb1849f8c10441288b02f0f37ad3bf2410062cf74e0f55fd02f9939b32c06d7390ab35b926b5654d40c3397f02685fe6ed2d0f41a7f9f5f2aebfeb6397a8ba10aa936ccd6f320b6da963c54184340b5a219d1ea2a21271b328da1a2daded91e7de2fd85395882c5c050be207879c72afc52ebe457bf41dd89a14c460397bcab5664fe41343ef5a223e44203212d75c66b5fa131e7a10e83078e9e3be62a3c1c678c44dd78e30d12ed727503f41a0aad9eae8b7bf972098042b045041b4f7f28141198db0a2b41e70fbe47e9424bb0780b48c44f21dc9a9e93a3d6eae2810417cbbbf66b3b7034960a32dbc02930d1fdbc159293d00ba44114d0d81c795adc9d0051f7e30cfd11fdaa3f4b8f6e35d841529b3618c470be393ab6b9271a16c213050b0cff0f128ef8eb7d6e9cf2a6661ae80cda9bff788fd88f039716c5a51f8b0066ebff44e0d24f9b327d2ad75b4925bbe570ef2deb73faf546306b1426b8cb8aa78b69ae079c282c7a7dc6b9504247c356a60f47b19fdac92b2d2093d37dc78b52cb7729ef43eb2b82cd370ccc68733665616f0c23cef47ca2f972958c71a9f48ad1cdbf718f4a176bdc5ed9423764acca334616ee3bd042a0bf5be03173c43e8ce809bd213e2ca56070cd5421565928a53e53bde289a944e8d245905e09b965e2dd79ff217ee152e704a9e7b51f6636ac5c7ef4794670763dd3ed2279fda6d56669c995958440fbeac1f05fe63d38015785d9fe6fe6e6f40b32a048fc69bcffa2f5127151ffe359a2218f0965dad9a78f574246f44a368392d75cae1b49046095d16a61888c25475439829d6610d5cf48f090be781c3c38d226ff4e24f646aef6d7e143bae9fbdfcbd6d7a0bd70c262f7d73a1548a39b284b2f190a1537d62dad0a8d2bc5c87ce7979f118f1f38a320f0fa8471838b80bac33942e988a83f95adfdf79503dc5546a876b77affb7cb5a694fea78606d80954d3b3067f5f35d9c3295574466e526cf72c03bd9d1b293ac5cb8ff624848b126e4e82177c282437efac8883cd88425bab35de561559754ecf0caff458d47fbe0ef0bb232713bce08a7157ee68e6e772ab23f2dca69c83f8040a5eed91de0c2d44c8e522230489f20eecee9d7d227133acb75528d09d0749a6a78ee8ad256bf92cf4c7272e9e3b4fe26f741f0cb88e701a795268dea6a7a753a72ac428e5f4f679a992bdab12e82f70896630a4be982bc7169b9b19da556a481f149f786d035c96cffcd3926e2c514212276375c7de363446c6b739e07263a824ea840cf9ef7b12d7662e806230429fcd3180345b32d203cfa9c2b3945747a88f209e46769866d942e76cecfb22270b788e2b284721f8fcee3560aef59355307019f208c387a126648155aec66831bde6b548a16b3e29deb38a3d2b59eba71a4ed9f24e07aa29922e3a12cf8308534c76168e5d59942378d9eee77711bb81c820dc657d0608d99e82c37c6f7b4c3e261b4520042d6c831178349155ab9d940f13d9d036998c62bcf7b691c93fbfc446087f0eeea18ddc58f235c1ebea1b9a71e8b23f5fb494317c301ce330ff3a9f3ffdd982e091edb181040dc18ae4b8e2bd2c618726ea95908501ad6bb7d40402d5768ee69d2f2260b4188bab96f5c4b9b2fb3301bcfb9da9af090bc3d2fd12c80419bf38c6b655e0a40e86593ffccdec3e30fc6f90b95c4c852bf61615882965b261d8153273806e399524487ba66d6db93cef61cb6124f2e7eaa39b4c32cd0c9bb36486469dfa53f427597ab8885e4ab6a84bc4509ee597c8dd333b1dce1b6a8c4dcde72ea98201df8f065749a1260e63b593f62c33891b9a8ec4155dc635bec4f8e78a2556f88ba3a66f14eb25facbc5cf0d601ff1dbf8c802108eaff5c5846105ecbcb98e12f62f7cc2eb1ec891dc098609c69e9e2e111d4e0166f13c08fbaa5acf89ed4c0533958c1741bfdc37594e12d11ddf2f532d0cacd7bdc09da2af5eccd014d5acafebef5d7b3663a64aa88f67b9961c770e033fa3ba711635ce89f6c0b1d022b254e65a48ecaf01c6ff7e3d1801aef5633c954269cd5377c35fa3322a96877197591d8f196e2e73dff796ce85504ece5fb4cdb4e88e89dd9ba54215b5aa95833fb668bc6b63a868130c859d067df4d732efb3ea9f157de5c7b30a4db26e752157946afe83f62213e55967dacc142988e4fb5cb7f124fde58789928d696c21bb9ea4a1546c0f7b64a31f03101b4ae6b6053f0876fc7dfcb362ed7ea22ad699834ad5b35bf0451ebc47a35a6b91a49f77988c259645000995742e7caadb9b1197af08d94177503afe822770112c3fdc69d600ff22a862793144693f6bcc0f25b9cafe33f177f76cf95b9b24480a9136a26e4af7c1c1f116499fa765570b53d2703ec10127ede2b8fb49bed67b42bbad59bbb5470c283027f5a864b14f726de76694df225fc35386e8bb722e0eed16692c6d1baf0922a8a6b9bcd5dd526712c936569080d28268c222a28eaaf2fc4911291b8c9990f1bc2e709063b682d1e0b427c357d2c391c5f00d4bdea5fdcf7628fc742c772860e96aa233cdde805bbd9e24eb02bb9bbef62fd173b7ad4ec5310c7832867603922bd12d724a0f72d6a8151f1204ec2d5b49316fc53b9f851843e90ff8832e3b0291d86cf1c7ee4f866d4cca547de93c64a13ddebe615acdd6e2a4e8396fa03d4b8a9ba8b1c3689aa32fb53ad1474894722efcc9faf076656d61617fcd5af953ddbb3bc43c53ce481a2f4d0337ff06d7a0868e11999bd724ceb1aa879a8a6eabddff270669f6eaf6e3506d25145d35bc025c116c60f3bad7dccac2cd9d0bb209df228fec3bd353b7335c53098d468ecd543c742e43877b7a338b9bd2ff1dcec8aaab9f9cfa6859ac4fca5b5fd533f41a90856e2aeada13fea8abcc94cd80c61b6acc5f1ef0ad4e10452204b7aa6ce74f1cf82bee1d11998abb43c09549e434ab5490e50e3a92a3466dafd2d2355372579c525efc56529ed4f69816197c9c7ed2b19f45b3ea332b1e9a76538c7371eebf1360e4b494ccf03cf34150ffc914019afc2ded5cb53b09a9fe031f4e059de35a1db5979dac900a86a136ea99d283c0353796760df835932018cc2c0f06f97e12fbb7e1d56822e144297ba22ccb12a2e9ba195cec977eb8a3e195395e7d8590588c069612350dbf44e355fcaf349cb52a26afa1cc8a1d0beab6cfd9eebf57082dfd82d44bf8627d5ea7845ea875d2879273cbe624aa165621eb4f8cc736e3638ec463c9b0305949f0cccd894093886d65115888bb03c491c7b1bfd6e4d56a3046a4c5c32a19b1ef667ed80a2aca6146d4dc729e2b22683cdd243e757f73f9946ec3b6ae37021b85cc8bce2d6bba0d62a08a31b7198c7e78a5def0237adbf1f07f7e1e7e1cbcf229c7fdc53932b75b6aa8fe17599b3c8862b168d1ebd5cdca9ee33bf7def5e3765417b8e5df9d5fd4a20cd5b6621a9a6ede0b9234307b924e9ecf575ff7b6cae2fe2e97a836b109864a875e15cb7fa2c67beb21f12e27146a6fa6dac6d02dfafa8352ee1827d514fcae3604078ac3160aa95b409bc9704bbd447446d9720d5aeb702b0070560c40e7b233f87506c89bdd8bbcf9ba74142272080e860eaebc7e8149577e0a3471b3a8b169fb04b9ee2bdd09504351b3ec5d704961dcfdf3c6f11b8b13191990d0fa2e5fc375500ca693a35ee5ad81743669c5009a0ac78f4f5622507b19bde16e14614ab9411a3321cfe69737782345b708b2178b75bf2261566e2c53058c1fca5cef1404b46bae3f74ed2ff419260fb3bcb2237cc392f0ea6a41fc5c63d3204593e0b15bb16ef2c530f69b9c7c54ab77663384a60bcf2fed926ef8f9e237597eae1f1e19d7152c8ce347e6a1e9119cd590dad15871cf4a214c8d41ecb6cda3138f58ed869888ff0a5793d4aa34b082a385c90298f0d8d113a16071dc755ad2dcb8a0db7d689548935e6d12c958efe77030a4456bfcac7bb46f211b94ddd653714af3fa166ae542976edad78a0800b08361c71e18125e48dc6ebf84145bc360b3e7b38076b6782f3588e34cc9edcac23ddb94516b98fc3d11ab40efca704a74d0b75073d48384cf3b83fc4c8fb11c7ef48111f4dca8f19297a72bc8b7cf24e2fd112e3c34740ef53228c3d502d5812c4f1180d67fabd1b898443f9a21b264e6625cc14afc0ca4bc23be5534b8c259c68a3c23d079669bdb96924f9c913d812ea95439dfe7c18eeaa6caa5c5bafd7ed68be51650745bad833c2478213aea61b2d8752adbf6c3b8cc509c827787dc6553967c79ad0db8eca0bc4598c0cfeed3175d31f607cef5e2b1dce32431714989b737ed93386de2b42e9088b5f00119921a1d4f695c570dff87a7da895d8cd99392363570421e966da1a1ffeb650b6fc192067072d8937f56b5c94a9fe18fef2c560126e052c226db60a1ec43716b9c0bdf0f642de0834e60e88a7c0186f0e4c4faf0fd4e770747d585770cd611d1bcf2de647892809d75cf21ef9cf489ed047c2dc3973256f81bfb5108027fef21b51af509ef816a34b94325a53862b56a4176154f43baab08cffb7f221ec341c596fc465723d321b8543cfd1527567b1bc609da818caab075234d1e2efea097858a480ae9036ac6ff6e70e160cedf1200066a8903aaa3dab05686722090b8ef97c369d381b77a8458a502394b29cb5b36a6cd7f80653ce3a58c82a4433ea35f72f6706f07c59d4cb77c0f024af1e84723bca7e2fc747a3426625cc501a40de4e2fca72ba244c4add8b8965c7334504f166511e4388b75687d6409a13210e52c3350ac0e7aa31eaa71d13066e086e3a4e96b118a5fb1eded5502d0971b114f6ad0ab5da2effd629dfec3ae5c3e31b73a9ed70310166bdfebd8eaa097726421c466dc94021a8d725423aeab8d34c0272be51eb62f013319d5bc2ba215ca9b23770a42d476c77110fd57cf19da9962f13806acce7c014c7ce3ee81d2f501c39fdb44e0a1cef38e79dd559eeb2b2e2ab9dda81d5f5f3499282e375f874b9a145e316cfae398a1e8c34af1af4e78ef25691843ab5b4af60377c0fb808be6b8302dcb841ca5cbd4131f0dc6ce872d12f0e320a99045977e35d1ec4498bbc64c41e86e0","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
