<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"512d3d283daf32941586f1e0676e656487afe38df7f5f68e68f9cdc993b884e2ed6e59782df0de176c9af044b1511e4b56349c7bb160f04a139e87560fa35f84ec68d91044436c82bb2f7f729307903e4bfe467408c9a51721b3a934202ec9417c13ad799346a73b9219df23197bd9527804a7d18c489b2dca5910e7c05d1d7c6355700a81f969ab81aa4608f991dd3080a13d9591da40e6639455532a8b927cf5b24842bc84187d6ffb94ffc39b6237a616c89edbb3c9e3055b485f41efe1bf21b6d0315e446e9378704e910feeedf554373c3056be30b87954e8dd4b7488cea1f841b72e039d3019009d39ee3f7ae148ef9905678509c15eccc4d8fbd95af9a077702a144c97aa1f3b667e57f3748f47cb590b7e8a1a5ff8671828f607ec8592aec1da048849ab2e44facce8098c48ee95a55a1020d807bf8995245ee1ed1d2c684b757f8d699cba8d487f9833428318bd1b8395fea851bf7a9c0f5025c8d9cac7297c366e7bdf6d02d922e4b8497c1619060d99ff59ab20e86092eb1d602f53b877393d901cdf3786ace1504757392f3f2c272b9c22716b7fbf2593acff4c41590c0e11339483bf29d8066ba2694fdf75e2dcf12c80176c05ce22a30000b78fc80f7fb0ab7546c670afdc9c0f8a96a75005f627ebc30b38f34f74dc2893043f78a38db7f8b18d12954e504364b9eccf08f6f7ad577de2689008edb494f31d2a5c991a1d1cb4740167ee620b70d037fa4ddb1ca7e2edf38b5ce514c25cfff7c9831c09576e86c3a3ca6332ebedd2e59ab19011b6a160ed993c50959e7b566085f1e623b8fc4ac53842678a0a840b4ba13bebd2edcfbd29d4e5b2433b10290d6b3b1d1f8d099e90ea1eed6edf07fe143e8e9c7cb3429285787d76d670a5c6dc0fc5190f85a0d5b752f940555538cd1bbdfb6bd37de872cad860de4d89a4f670c1d1a34bdd7c0e7298d381872119505d55b08abb1ba381588a674233318b30d4487a8bc45af98e920ae47b90591f37e0bbef148e1e4db048d463d00055d051964fd8ceaa5f63cd7f55333fb87dcf9ac65a3e3daea5e9b40baa9bf3fb23eda75125992b1f59bcac44673046a5bfa89079a3fb6e76c80e96eb1b3be9f9e3f2f07a11c5d44c5f33e869e77d846bc3f8dca7d7f8b606749631233be99a335ac906b38c3d51394a1fd5ea2f5b9da07e22ddbc519184924e3ebf388a7ee7c0111cf00331e34a2aedfdc5c72aadfb99b49b8d43ec669d0f35e573b58f28e2b963471fac18993afbe009785f414f9a0717c8c14f2ac1b5867e716aa89e5c756603dfd6070ac228dfe90830415e83311fba06c53d23681fd55a7f052f2a19e844d17fd572b87ba516ace90acbb529b21fef0682193fed32a8525572282f2a81e8b1304226ef5d38ec863c82fa4f4d23c609a553858c672693f006ab30813f7dea8b56c9f1ff1c094e5d5744de1c84f580aaeba0226b795545ee79151771d50b5889c8a4ba605f35a795d7e88d7e8381fb7ebe5d0af8873ee29714c47cfa19516b6d02ad51b2013fdbbf3a7d7b485b059cd0596a0dfac2a235aed6cbcb699379cc5c58efdcd56242445f6856d6c45961b62afc576be3688768841bc15f0158c2068761622b19e71e1fc39964eea6f8cca439573b4edae52ee46b7ada980321a1fc91fce129875247dc56deae1373cd9fa00619250aa129129fa2b50f4939c07a89ef2a7886909f8e8452b6af2e59e85cf508ab55f4511daba3e59bb963f5d68121e6ed3d5f18493e627f77ae077d383f953d731d14056e5c13aab9a99b9fa15c46e32487d6b3802bf920bd269b59c3733835b3b8f1d1b6ec977c5ad75c7db042f39ed7646ccac483aa1bb720f99d26068de96f8d5129a67b7fbbeb9060a24eaa9f67414af68ca41821c9f4cad9847f087c9225043f0828113532777ef4ac0958208376089917c0c1150b66948656cd2e826c828b064bc655e5e04dd1be40092924c69f1536c25930bb7dbcd68e15e5472c89eb5330ed54bf89ce8a78d2b065f9ee8a2b69558a5eb5cffcee3001f898fe5238f12b6bda9cdee306fbac12edc9135f8a6293c708d9976069f1dcbc1b1fcbef951b09b88de8fd3f67f7fc98acfb84f62fcb534a04285f58c0f7a6b9aa0985ba74c119ebb21660df294bd91cbdc3fbd17e2192872f62508bf44bf79fd98423987687f2b156c413cba2426a2cbd254eeeefbeec3c24e271856ed0d6676e1ef1c7cbd1c196e4bba4125fdcf22087b018e21b927ae85d3584e7e935e4358637510741ef7df0e3b50d0e4e170494bc2635f15da7ef89469a5284245324df0be5b9db54711d10a61b38a3ff9c9a795a6e403fb5ca949037e544eda7a7598e777ca6032ec5131ed1c337722624c2d7538172982396a4447b5b13822b2a42e755f7c9dcbec20d56f235c61476fad5f731351175b0bc8c244e6f4f629437bfec5e30cb42a303105bed069bd3d1bdc9afde758c40f337aa40dc1ef56a5cf9418c387a4d7acac2ad9d5c46ee01f1227dc9823f226e5dbdc24101536c8826c692ce759249874da0480d57940128579b8e4f1824de736c0bb94af4204c76aabd5928fe9b31e9ddb2a610183fc5f1627f5d2d2f55b389acc778b279f45bc895420b2bd0a362a9cbd7c09a2b39d4dcb012a18e6e9e51f316d73b00eb39f643b0a9553376e0702a154dd4dcc18bc707c9c527e1c2a4c803ad804c744b8144d54a4ed45a05fcbf13822415db7387943093ff48ef5ab4ffe73743b012e5ef0d9a447c81dc56e51592bb501fb0bcff1e5cba9d2397349036b9672a870d0a6637249f236f382e4bfcff79c4ae9bc058793da0bd49c7ccaa33e7b6a62727daef2cdc1de72c689b5fbead9ddb291411c6c0c7018ee36250487c2fc08c8c1e2f7efb068645f21a123b40ef5816fd7f322b86ab3b17408f4d4c152ca1a56d490707f1f8946360e06847847d46595a5b4bc48c05a45e2c33e1c22b7d8272513e3261ad672df5f4bc7696bb9862f747b96e858dc688554da3a3545025501585e1ab8e8f22c9009403b73410710407a706582f306d71e1d1e41ed5bccc8a8604f43a8cc3603318a3987939a76e5ddd72825254935060b31932f0fb4e2ed61c58ade502cad4d455b769f49a9cc0cb994db972e846586f77c5c4a84f657df45f4ed4fcf61a8523789f3d8534b7e61bbfd85a81c7e6d68eb50831c6d7fa3fab4137ad157c6d9ba7d49a1fc92465c0565b06ac82dfc911461dd72c9270f859c3ead5dd4782cd0f5622fe4b99bffe16b1ce4bdb895fd01887ed22710a2692445ec511170adc843076fbbe8e558f386abb5c9f964f042348daedf646ea559db01a81027f47dcc2089c4b662629db2d6debe15de7f9f20110fc68789be3bf6cd28e1621bf9bea512b5d9a9f15a8e87118f4f34f882447873b04c270f8afc542cf532c2363990f205a7558d7c24f2c607c36e8ba8c258e63f800c33d29bf89e4b710e0bd19810c07aa4dc2f9bbcdb1591111c3a27bab01e872b3d89fc972bcbad2e7e6f92a8d08a7c97cde97501a9a53b560ac370eddadd10895c39e19a264cfd3b6a8bc54a8762b01ce215993a39da16d896b6833fde2d2e52387a74797d1ff1db23a9a3046b7d3430865b1f3d9b9cc7a38629453d75071197a641dd35f0b6961eb9730deb2c76cc297f797192f02870f8c1e867c042b526a6df2c0f8bd502b9d1af550d6db71f38355b217260e754b156b26b78cb7aedee149e2c16a77d63758600083c334a706a11680c4669c4102166f350cc6f74affebf05e0b8aed617a157b5d892c40a31c157ba6130084c8c88c6675dd43cf9ede2992726fab3d5d22eb6a8669827957ba748044a73086511b9e24a2211595a292182f13ef0037101d2e5866ba2fd1c097e82ca11a27ad75d5bff64b03a916e482f0d9d0d77c83b7812b8cc0c7dba50678baf9cacf681d9f1c584b12a752ee8507974f94f0ddbb43450511c347f66585c19fa75c94b229ce144f1e862e8e0f625fb0637f0382212c1a1183196607a00da73861eb9f7b38381eb9991dc09443d13693da13f8341acd94e5595f7b22637f87cfbcc759a01d2d2e19825c3f33658f05c271e5304a9de718083fd3cec69c3e238b51529a6ad22e0f732bf13f8ae61ba2d5eeb5c44af3e4876bac24428f51d95b538ac6005f2eb3ac55f839842002910cb10cccc5d542d2606e4a63f7a8943421d12b392c46105a7fc1a59d1fb712b02b92b1ae310eac8fc7c18a06cf2f1913457e964a42914b41f8b853e2ff29b643bc0c8e82378b1817e95ac0b13b3f907a0eb5a7b6965cb53f0002de524399a86d7b5248b1788691c4e7ada4fa5c1b57298dde7d4c158489dc55ed2ecc2e09c365599b0b394e61e6a97702f498634f62a0b4eccd254e8a4f2efb3a3cfaa3ab491edf32b545036adb13cdb41b1d0a927cbad7e6dd0f9ced650d0b176ffa464b80bb79b8635e40c7aafc237f4cc4ca3acaba53525beec1b10d7701d14aa7ebe7da6085f138c50d8e7d4ee3d81e441b56b8d134c963204cf92af82b3fc9b9c5623883e967472e1f4051007f316010d90fc279b162b6023b9acb3322c5edcca851c571b86ee8cd27bd7f14ef809dedaafb2af62fb80ebd37b15060c14bc30203956a9302177b30bfcac2643b4a6ed44e16bf5309f5573a9da4f8c6126e5f3d5947f6726316adf2b55f694fffd2b4a982aed1013e32c3b463218d296b3b45b5c1d85c9e9742a9004f4bd88a6c9b97725aeb9f9549f49b712315ebc990416c1acc03f1cc8195a0738978aea914b4dc658ace7952dfc5b41890db0a7141987d37fcc987dd5a4e3a0296f0aafa39217b0a03e31860a9e810cf8bb071030064f7517d30e0941d5db28909e2ab317b93580100507393b01d9198eaaf0eb00a938958a8de0bc1b68eb04e2795658d9edd1bfcd39cf2c1295a81f091cbae35a5df9c833e48dbebcf8e7980e59f54f26dec4edd8dd537fdb280e1a062e6c07f7251c80baf4eb1a0805ea986c9d9781736a6b65d112aeb78e2fe0aee37f8db30d1ef902e7182c8ec90373d442cb47917b013bd6ecfc25803ac5269d54d69e2b7ef2af62b44cec88f6c4545f5e3df44ee07c1d20623a2cfaebf55639c17415029fa22047e915d68e0ed72fb700e5ea6e38aebd034c510192cfbce1ed171c0dc8a9a3a790971c89804d81659b42c2ac605d7207e9402a63d5cafe3e8a47443178afd2fd50f67c4a1271e78ba02e1392603a7e85217deacdb5431ccf2fc992e156e22f8d4174e6669b6bd88ab6baace18dc91d73dbdb034739efd2ba0c68ef617daa47a5961eb94f646d71b904a30acae57a150d0a82cdad1992ce6934b63e2986d522262f2fdb88efeb7ea70944593d4e15a5f3d380fc343fb3487f0a96ec212dfaf2aa4e333e5b0390b99d4faa40ae9500cbbdab58915dc02eeaf8758da6612eea5255b539a2aec1ed3d178507313e904220f235c755c62c79fc9ffd47894c7ed50aaaea1f38ceb6acfbf738653ddb69605138317c5b04b3c996aa2cb6bedbdc5df95e82cc4321891f59a218cdeb53564d7d31cdc8d5c45c618c57035d892ad92e5ccfe4cf33fbb3d119a79e1032942a1afd58242057b0ac9d7d3568e43917c80387f44217932ec679e98e189946874d3684c8acc2443d8f3fec79bcc1bf4f77e465458fbba9046d2fbec58b1cde5d1de2f438cd5e7744358ec483c7581518dd11e033c2b6422e33b5ad5e01e21ab2a052c4ed709e83a45614b6cd236856040e490dc084c9d1cb19de3ccbc506f4a5ee0d8c4cb4396f40f10fb652637a438cf2809f018884c33ad5b59ec0868469e0ebdf611840a644867219b210a5a41fdff46074de4094ed3854fe1cc1a6d6fdcb59c5ace06168727ddf3452cedbefcca727dedba81b791977c35d65314c66956dcec08f0e84c65543031e62587c67c8ff43b903288e27d6e9184803c714e5a50a87bfccf18a6aaecf224260495d7f4453bd343c0c762cfbb0249c2af654d73f48da7e6df5904fb32cbb9d16dee1bdf700c024c68f2793fda7a99dad90963c143c65f6b4f9d2d516cb8e9d085acf73f25c74bf059f3add29864bc370725d7a82221d3f578defa15bc85f57384d32aa8764f5b7132f1725abe6f7e593dba688d7e6d11865dea89f4abcecf8c5a0331f6749e6239d424a0f7e2fd60073dff75d7f31d4490e3b17bf5bac18141748ff7256e0925dc743cfec7abede480052b51c6654bc7ed78dce4fe235f70072141e25dbb34a95c563ee3f8ea5cbc0ab8523b52b520f688b39e5a298382ddb4ae0f2b846f9cf6c6cf3150c1ce4ac219761cd15cc4d80bda9ac219e4e47c13afddba283fbde8bc2f3441871f48da212d35b42c909aa98e7133f7453f5592a17572bc8faac9d98b2d11c26adaa66e1be6706cae2bd63c526a7599a82fcc4d48277137747324bc262f93ba4c5d9cef5875873cb6287f451c4f8b380839216276bfabd6498413e70f811cad9e2a0705711b68466871f9cff3734804cca0e7ee7bb4acd3c1678d4bdb59807bc9b1df284e7d85cc62101af63a7f6a7391f9c0758983ff6b36af7d0edb72380bdf54e8241cb4c695ddf5c441f19b59aa68f36b19ed89c45e5bddbb17d29bb2806ddaa8782ee136f62d62c64ed75f3357cb2772b6a93f02333283b9427ee92d5768d13f336a53cba3d06dd0913a944c5be3aeab8f2f6c495e92fd3758b1a3199737c5e3551b07beba04b73a24fb2bd0740564d3a71103196668df42c39ac32f1a62ab1770ad8c1697f572081676bb016c9bae2186f9e90c1f9665b0e3d73e9b4fd5af59d6b941b70d06fd609dfc97cf78e3e8a6f1003c1fb888b385cd9f552c939afec00b80f73266d4798c84e2586c9e56e28dc02b832ed7550dd2c01312cf77764910966cc22d9765921d8e470e8320dc8dae0015b11b5c35d196d1a18a663029766d32bfd59747e3e6b316b9ae2c59e64d3ead5528703474d7e3b85e3494d5770ed3751d29e2148f09c1b40d87531c41823b3abb7d7c8948322c32d0a708de287d23247900971e488a1907f36bfb4f6b326fef97d2abe5dae9ba7835e70edb979fb838a39b2ff9bb46993d19335fb41949f25375802fd8a33625db5991824b9c07b57a02ccac00ce67c7c7a9201a93b535ad69ae27f25b26ec4496dc892971a759c06b1d2a5b410805cf66bcfae90c257cdd38888dfc4c1ba3a60e5f1ad651fc3cbb243254a2f77765b6d34684a5021e0eee2e9a73125a9ce950e1fe15a8878fcdc1acd166265ace5059c7232e130b83a56ea1f2a35bef66eec8c76b64f26e4af1542b9f1f904fa984c85991dced263ff859231ebf940926ebfa44f93fc2d7322d8dd5af957b338e0a3254d7982e5616d1401b86003b31b037069b6a522bd9c67734221f2d2ace0c6210d2711c4a8d8fbf6b7b5da86811d91b6442aacddd33df1b11f46d41e53dac55bc28927e06c0fefbcc614e6012662f966262e58e35cb4c4a0d4ee4d410a6c8726d41d69fc9dce9a50ea5e58b00d4eea04196d432f51cba657f01e20b4ee172221dcf50c80321acc7ea54361357b25942a7a9b646c61a5fba561f305964c6e874d084a04580460f9329d40c4153ea70137527d9d52538fdad57583331f7e1ebcf630c6b019df3469da36915f289e4c8df9292dccd593dd97a5879d05219647a0004b43abc171b67527f197ee0305d3799611a5615495bfcf1e4492adc3203c628da4755943467be41a0070cf25d5363826c1a5b6d95be02b12523bbf5311a6d47021df29e47ddaafb749a094a5ab12678356dedb8e6cbc2da4e197ef185bdba2589c0b7bc5cb06fd817c21f9cc878feefd1a39e7419cc0eaea913650c4e69594e5c6738792e5450567969a69b342c68647bedd07b823aeb38388d82cde2fe61b188da384906b4fcf59f0896b6ffea431319eb7e92e4cbaa3ebed43cd21c354a0a4c853b3133e076d627eff5f49b7cae917b9e6eec0f070812815f30bdae7fbf462cbc52a621ec20e2e143a00813003eb601b0e9edfe2dae848b6bc9136e738a3bbbc107d7cd8fb3f2f076a2d6203c542fea00632a84b342eb3451ff9bfe697c152985d323c2ae464ff72a05f212338bba7046fb947cda49613923afc3e297bdfd330fb333ed338392b9f37d2da5d80f9f3ca1d289186632a042fe69416c76073881331d6b3ae16ab9dfc49da0ffca71c13d6c0f9a83ff92d625e8635f796e0782f9a5e1c3ff65ef11b34208612c5910fa650dd4f8f403b5db7849fc969092217b94ea2519999040a041cbda34c027a10cf21a2d46a673ef7c83809888074eea391ea0f761f4a6ef4af5599faf26d1c6eef14fb90905af860b2f037f28eb5fb2c23b8bdd74f02e616daf3a654701d233ebcad41bf074914e4c537c53a823659707fd62a86ec45f4360b2ae6c1685c81e9d9eb726246364fca3a63e23845c65032f4aa05b4aae9fdfd690e819d43667cc5f483231c8c4907de19a6efeb235850316d21e6d4e02e4f63dbb5863af1bca78448192d1b2d1f60caa70d72de4b9c3b41077380fab91409971d7dc455c17bbe9d785746e9835537625e89633ba8f358d513c8eab0be1cb4ffb1818e49864362b4282f21c9746babfd6f23ef985601c9b6914ece538c4899d89d4b9b96d018fcbfb5c6e03d96d77cd9cd4e57a1cbcc604d89791001d5c641758d2834796850afd7eab5f6c3cbd89acf6448a12fb18f5ae58942ffe0020ad334642e4e6b039099c168ffd92eac077fe150153cd0b0ba5d1eeeaa532b4877f98b660f0b80475354d1729c4de9fac7030772ce27b3ba174aedebbffed28e944ca7ac096573e01088c667e9eed8cdc58a19874791ab9ad80f9168265789425f89de773445c6862305ce79098a1f6153acc6c1440dcbeb9f2ccb053f405fade0577659da2a991f33d961ea51c183e4c1b2b573aac65c5c1fbc8df34114ab5724ac3f955478fd7ccf81497bb029a3521b117076179c892021025421068e43e1b491109045945c72d5a7a8e8d5c5db2f38706e4568ac422a97dc7947489622c3bcb5c43a0ef2960c8e3fc92cf34b4d5e18bdbcf94fa26a7cd8bba42334d49b6c1111bcaa05746f52e165fd46c73c6c4ad1ee983dffc3d88e1e27d5ccf56ec463d494e4247188bd1abd32304249d63701b3f0d7ba13c3948039c6bfae1f8268a8f5cefaa5ade7c4765698ed30a85819b3bb34bcaae17a15910f280f1d39dac57ee2c4231f3b3fb1fefb5f922b894e0f807e8d6287277aff99c97126b7692fb3fdc6171d2492565ca891ff4a789c5bfb5c71bc9ceacf7d5e7e1215f9a54749cecc19d9c7ca93a94b9e5ffa7375d127da4d0e9f9e495120c3f01f56c421d2f13aabea4ff058764baf50546f735f036d5bcdc8a531a91179eaf5cc26cdf6bec789264a0de5bbdd732746414ae5598072083968dc260533e407c6b0ca66f87508c2e874e40dd30dabc9e838890f8a6a6dae3c8f7dffd665513a9b5c9f67315d5c5ead3361a54a8f169338f9c61ba727b49743fe38bc126f18b106fafee6821699604f06c172264193c53ff20b810e351f0a8db3900365c6bc75244e217b63d140e9763abc52864d7866ea82ded6bd5a881d8ba32c774aaf242c46ce0b285b22654f531a799e77cd6eb2cc74be929da41468427a7029cae100767f4c4d824112f54059420b958225ced5a8aa2c13dded5978f8b4d63773961ba96a203cebee5dc873ef52958b4dd4a8af330b7f0bbe299f1dcf1c8b2b6c152d1858c4354bf2357b27bbd1aa6d036a36ae4255a6f5694a4bad140c6942ffb628af1fbb93aad1a213bec864e63fb67ae0d4126a276822c0cd0675e3e1db82fd2a18720503b9de3fe6026b253c14355126a0ada3daf41529006fcb453c635769946d1109f0c65ac3da3a5fe47d3c5d7155b3909f8cafb390c33c92345126abf73aef0f5dd438e5f35f1adccda7cb1e67ba80395bdb62633a6986e0f8a29a98fcebca319738972f9e9bdb05a9f79c21748b89eb64067b693450b166df1a6f7f6a82745fe01524abd883fbf8eae555d1054b59e129e36ff9bd5d5736423daa057d4eba309bf68a4b5f242630e94428a0c3fc6d57b0b3f39e06715ca14c2601f1a9b47388ff9fc0aeaba500a506a47d46da79ab288ebf7ddd3bdef066003780aad656c7bd85c627ee7bc37111d1a22b3a1aa0470616b36c3c392bd33dc310797bbb00a6cdf7b6ea04f948e6a293ee265f5c661b799a300f829c43048275c1e1005e7100b8d949bfd25d0db2adfa9f52c1ad2aba8c258aaf121fceb0a68992e81a8b8bd6f2072d0f2ebbdbe61c40ec6ce58c99e892da1c4320283b8167660c94bf963f14d615fc717667af387d552294d09744e5f831d12247ea32d84c9c0b8c2e61e4d00630a54990bf77f37f1454e4b92634533cd977c31ef65183faed92e417e1d1863e3dd646308b8ca1bce8c773648c14cadf2ac2c4c01159ea1915772fc94cca07bd56dfcfbc98d6f90a4c7570f7f1b4e933b7fcb5e21e365f0296037f3fd0676215c7f4cbf5085674d3871f5d16e7394f0dc9d90b0571fe7fd8b40cbf9179a7fef4d50e8a70a4af616ca1497f8bb706dbfb602f58f4b472d9564238b055c375f5dae1317ea8d2352bd40ddebbec246ff0eb106886434052778fca729688aa6c474decdb994baaed48197f6987b7a32444ae97e4ba2aff13e3d6ff9d0686db648f16e33c8dd7c31391dc283280073ba4f1b841bd736f5577dd00fb5e5d05f200da8c3febee427fe45aa92fd04eed34a9d61d3bdca3e1824b8f63bd6b91d64d0d6b3606286d01eac08ecf3be69000ed27743816a901564b262eda34c804b9df6bbe27b8049fb9ae73fdab0712037089142b81157c9d68823df0d80e9f825cc85d1847a3ac296cb82cd6623df0e155aea8d80ea0b6c953f8b64c43397fb2e356a20d4299bce3facd7ecf8591ebe63ccf910dbc13b44513b6e8145fdb992ff425783652b1aa7102dbb7d3da4a0b7245765f0a1dfa13d1dc29405b5bd2022a38072584f31b50a1cb03fedfdee7adebd11b65d10fe61fbd5e71e6a1ae051856ef7fbf7f937bf36ece702e83df80f453066b21f868f48e409df574b59924242ff784ef8550581df25cdc5425527c992ef39872e35bb7b365d98be29641b609251bd73b17cdc1d2281ee186d69261c2d9399e18b6fb5d0b226328ce9814a3b182e505df9da9566c68223579540a101af4fb1877815d9f2a5cf26a9742c6b1ce750e610c9b75e30bc71e144549e0f03b6302f43b0eedd814485f58a595932bf86a8d306af23516e6ed4485453cbc38f6a1525f73eda2766c7763d76a7970879a9f8f1c03099d274e1e196e981af8fb7034873b2d014cf38d084af98e4a315592fd9fdb7357d637f089574bc4ef15020a53f5db50bbae357fb66424ca18062b48b22028b8e7b30c6bc9e6fe994f0635216b3c63d3041c61c41805ebd032458ce52f8d1b4dd74f80f7929f3d6e8722e822573e2082960eb18994a9cbc05d7c070d14e75b10bb164c3b354cebcb06042300f911e94036ea6615994a83d1fe9379680603b5987155387b2126793ba70d5be1d244aa6b1145493952a2bfd54438aeecdb0ffd97109160090a72ae63d23b8a24d353c6e26140c02df32b1ce1fb0345dc8a66810006ecb8188c8160540034e42bc13a1b586ddfcb6bddb458560f0eea80bb4ea776be6fcae9db6a6a07ad2e2a2292a8d4d35fcad214dd4a763b7e8430b85c3b7c11d0532eec8dad8f40085a56daa356355ec31a31c6905eb0c464569e200e4a72170330446b00ede3d2353505e83010c14587f7eb6d7d815e3a0733fc7aa15c2583f66a5c55d605135ed996f0491cc6717606b9e475ad4a3c6205bbcaa89b9e98b34444e2d05d78562b5f7b3dd4dc891b01497394788b27a1f79e99d21e6ed6a9bf3d3c14b63e480c4fe474e03e597edbb35b056344b40ca0feb218ac4477571d386928e1b5a5cbf9dfed5f0e0b67ee34664fa963a005a0213f091a519abf9d08e9ab49a902a0ab9c5b3d7d5a55c5d6cb03a162977e1a5eeaf6f3b7610d681519b3a1792845345d21f88db9b642c24ea7d016e909fd656d57942b3d755c5414d4864004ce0b42e505d31843e230a73af7f13048b391db30d9bb5733452decf4788756c2da992d7410cbf05333a5281597e3d8ce97dafa5823c52dea8aabea1b5a61afbaf65fdde9203d9de8f5953e3dbc55721ebc7c9749e1dbdbf35371a91324fcfcd310217ad353fb68bde199ea1c6f427cd4559317f6e11f809ffbc6f94f3c0ed3bb93435f88b27d3fdf19ffe17fc1d3a98182888a21a0f3db9f09e5553770f360c01e71bc5b14900357b294085252b3c25f2b98c71ee3d1021154115f6d33f57a53dcce238ac846bb3c3a40ddb56fd9f12e2ff074b3a3b5ae0f618ad6129c2e861d7ce30cc4bba22d653e9e78d0ca2c5c00480b7fb95c298b31f7365a02f1c839bfc1f868e106c5f1fa06e64b66d68e5ff6e0a44adda4c050cf5c41951fcf29ba269873b34c13d8d58b4b9ff06d2b6bdf67f265ebaa026e049457e2ca3d522e03846404d77e2002834e194df3b46346606f02dbf70f25fe52a23f03b8cdadf72ed7bde5746f0a492b758997683e78bb9fab65bceca735b00d90f495fabb0f78f674c8503178ff35deda4b908bdf0a5634a49c0758eef689d20de753eb63d5fd8168f950deb2dfd5589f392a6afe67fc8ca1f8b92e89f5849591c57c16a7dc4d33033d2d10128c4012fd1f28c52b5eb171448a2866e1713fce81db42997ef2b4a4cbfa54655e20384d342c01850aaaf8a4e97e5f8261a6a6fb929fe89b1cf87411ee4b4a055461ae893532619fd7a58f88635a89130f399503bfe8157e28021426f228404b507eede0d52672ed59d9ded4d4807c17b018e5b8aa3ba100349a14d8b60cdd5cf2f5b3c0f6899b7d085332024cf620ba5b1dd5239d93a41a7b7bc4d1cc7c95f85e24015295b6151d022900032e45c2cdd23fe4bdc1e2ab6fbd33073ff5a66de98b7b44c6131e5221d83907e71f1cd57f840fc08b073e2fd7d516714303cca9be05b307d04c5f5b295527ae126e1e8c656044b0c2346a59e2a9d22a97c3669f339888fc6b3051c3368b60e2a06ab16e6356788233e0651378f8158ab494e7806175b0e17ea044604a8ff856dff1edef56a6ba227c261600da5fa0c2901dd78e3e9481901f12614f07617470ff7feedb5f50b159a6222528af35914fe8b2d3ab2e7fe55fec4d179c0a4a40908ab73238fb2a0fb8a85b821a866ab1a8f6c75454e936ff005f1420c1dcb0cb986c620629ef9d6095071d2701013b6dedfe9dfde5dcab091813c9327378d7044a8f897ee0e5c8aebe155882c34a1658c1d4fd4ee083988d21ae2bb8ee465c0933a59a1c4cb273b504d2af8ff237e234f8c726cbee53ab2dac04534f65adc50776d5c1370de128617f7e130a9a728148f868272659c2384c110cc4d04e17f375878e4463a05795a045216e3a773451e2fe40ab15cd9ce9bd74302e578e0088087883ffcc6536973f37ffeeabbecb3356df9b5fd19f9f8409e8bae509de31329c944dc953f60b040343c0f846ddbe928ffdbd9f6bac0fee71b1be20eaea16f175363af69c41e9ab44bf5efc62c54570d7e7ec81e18bcfb447fa08f46b734be576f2a1dc14841e4768e11015f15f948bf570491c25309d314104be6f6af2d82c18e41c91a22c333b2b94196664b17c9ab53db6ae0f8a2195b03965ab87d8d76bdeee296a5b098902ce0e4c4d964384bf3d8b8e4809a60c5b724e644e131e02fc1e6393790c473707d4c7f762e29d5d945391842141bb152d8247f5340faa255b233becdfc1b2a10616a116fcc79233cc61c3dbaf2681dbfe2b05611f2fe97dd195edfd33c1e08907a98e27df86ed50ede6ec9442685ef1d31d8f10cb4da83a8fc55faeffe6082c52dcc496b3d5c5af23b531eed8b6af41147ca47600dcc08ddc90e7a40ae429dbd40e2606c5a6086468cc603ad21674207a85f90ab85f36da3b1c162f1707bd75b1ba3115d96ff3ac45d81f44181472d0b47164d431c38daaaf3c56242008e2dc3fcf8c3760adf0019d6757b02591d960209c4f3d8dd82a9cea80f3b3795afac62ad8ecec8207ebb03ad8bd32d7ee45b358bfdb6589630049f7b779ae4ffa30fdb2ebaddfc5272c75c45442bcaaf8a696d16fe45af5217462d8609d78051bfbb7f5cfc68673b30c79da19d304fc6b6460b11bdfb3c0864499353824dc0bee2e5144b33c08cb288ab0bce80c4e5b886e85f585a232de153212a5e60742920a6cb7a3606e1c0a07568230e38abddce8cacb6ce68bc536af8b33b1afc933b1adc5abcc969ea5f95090692a03d8f9a803e92b1ef2d15188e29a47ffa1afd9ae7619dbe5df22357ed9aa078d549b01c28a05bf1ffd34af6a818d741f1ee877026d4f93f33a10063b57521633a1ebf2cfef565f9584b769036e4c72336b92d841c950ce37442dcfbe02d6a17081a0f5e0f15cdd29933a92969e1eec66ecdbd72969525cdea3ebabd28000eb72b1e7b91842d2e71e5c2c84431ed7685663d6cb515a2ef36b42fbbda63750ffb4446bbd8355e94bc5bfe3b2780d32faba0b383b295df4c25c5cb5ed5e18fbc6f2c637df39bab5c74badfcf9682d7a1011ae8e40e6dbaaaa884f885e419fb7fcac30ea9682277ab50180a63bd879ce47eab474e9eb803e0f1fe0cc7073e91ac36ce9ab9344a6463325bccd6537247688b32c41ebe75b297908f3462d3a0fbba7496a1680562ec9687e23be9dffeebc017767410830c101364723ba7a18ccc804290011711b646d51e8e89d065ba32d3ef39510a328f0d6bdc90ffbcba8d1c27f9e8ac8a05e835ccf824fc1311cd593d8008ad1bd9b9c50ea17777a0cda8a81109a3c85afc61f98cf0bdce186e583aa2db311bcdfa2e93b463dde39197c495601784718a2922d110e84733ef9b724c8c757b0cbb549355fde7d6ca6c567a05fbebfaafea9ffde95cf9104d36f10b23b883444d30423f406e1dd032a9bacca394b846acd03d695250cb96ebebe80c3a7073ab72f6679a983729516bc5380d4dceeb69cc2ee38e39486a3a7e25d78a5676f40fd5596ade734da3c402c67586d6184dad421df7ff5a0c01c0930fc310a1e93377378f3ec2ddd4f519e475de5dec6b899971a0049c7498020afb53cea8fa3d4642fe6001bd4d54bc9ac215688bcf2d892f08c662a8839a5a2ed21e60bc9d133d29aaf4419079c5b00bdba083a400ee5778516ca39fdaa5a656c3d7d263396cf113d235c273d75694a958ef439b11c577e1ab428afd07caa59a1a189f96cbfabcc286fa4c774516a4f8ad1fff6260d570d0d315bca928457bc5dafba753c7bfe2772937675ff6cf7118e52db143f79a6e3f4fa10ff2bf649a6989332763df30baafcd1fb6d8b182b54dad97b83ba6b6ab8b1b24a1a45bca9589556a65afbc0362ee026c0decdac164700cbb3ca856ac95f7beb21938aecd076361842e250b0051634efa7948d89a2b4acd57d14829b63b4fabecae6aa53a49ff3c3f846ecae7f8c2e7e25c7ea0350c8b0944fefbcfd287034f0fa82c2824fdcfc7e84f0936f09c6e905d4944acd4d3eec21ab89c0581dadf30d7a5ea543f306abe25bf0a643024807abfa5442dd1a7ee94986d0ff7cd8263ed570a9b318cd7a92bddfbd0679eb44fd10b4fc71672c64fa8f485ec0a8849e047668a487062a071672d2cade517aa18db672111589b0c11fe79857761e534e76e8100a6ea2ea4ddb4d5c09267f213aedce40d84b24bd3ca8a2ba6e981e8ab88e71973b1d8c95ed0feef33027247cd47843302a98fb7b95ba40e0655931dd729a1fdf3909dff4c9d0cf575ae334a5bb8deb85d6f0ad6c61e0d3ab6c7897db97058bd1365bfe14bee193cec0cfb185a8981c078564e32c3473dda38d28949ca12cf609dcf1879366d2256aa0914a29f6c22cab732522ea561089d103f9a0bbd54539fcc5563a0cd1a44b6e4f2bb2113ec9382ba21e0d75c238ec42d6204b2dfe6f2882a4bc35c424a6006c3b311916bfdeea8da6014a2c5223c6b14347873e3066186de3d9c80d3ac71b91492054de70d3b817bac7ff526006ea711426d06167f7a2e044d024a6942d87747d3ee6d17676958c72fc0503bca5c76dbb32f75805043c4058e5fc1dee3b204d89fa83b16e027c312b926ec1ae6aee86ed751828c4a75cb43de4753d7abf1c2998e177d3f0f619e94c45a5af40fbca18246c557f4fff88a25c5702e066b57deed50760c755a79fdb3adadc8d838a37949178f3625a1bab9a1722f2aeccc87ae00e621ce38d50d919996761d1dcf4350547e6a4f5aafdf231607e4d2bcab094d8c0d11826f35ec5b89585dbeda0b91cdd5d4dc52cd9f11b65df000d1d663cdfc200cc9b898525928c4058ae36787600e7fe9dd630f8c7e10619020950fbe70d2dd265e1b7ff802a871a394539255354161aada181330c1bebd503486c1df0a8b2ea65c8245963659806d1854334b34482301039964b41c20cb5fa483df70c738dbc8b90aa0b8d4192bdf06e6f5ae8f2f0bbced06f1bf1f5da5f67a8c7e7b82671d251d330257231d9708fdfc62bcc2c08ea5957b61d41825eadbc9a6c6d0fc876e0720a73ab41be91ebd89baefe1d5bb7aaeb41a583c1c43f3957e13aa06f7933c4e94be7c2c5e7b47cc2b8a9f201496d6c8e378ddf0f75bdee3f54db4990a7046be1894cf18ac13acece3964d9d06b4e43c44f599a637ad36f43bb33d2aa8a68cfca01e51a9995adf0683c4cfdc5706e67297b6e869653aa7de4900a9d08d0b7fd7e9cbf796ddae701f4cb697f041e7cb8127960c910a1e0b91993da80a948bede456a2ef852eb1f3dd074f76bcedb8718bd3f2d66753d9727af0ddaa34c6a57c23296576d81180355b5219e58b97a8454528b3623c097eff63ba3976fe34559fd6fb66e86db43d37cf0f4e8a78e92a29283b93ba78b2f50f1097ec453eb73495a46f7f6c7ab3ac6c52285d42a9e2f1d13d0f7f90933eb207f4142d9a6da995e4789c14f309932778f784e912939ae3af1448a69d725b763c51f7ee567f600b17dbf314c28cc6222dd3302bf8c714cc5bfb6e46dd0c390d577e6e551a52ba92d1361450711cce3774fae37215842f4bfab314c25761b8616cf07164e48705a6a2f2353ad4fbe44bee8bef96a3704f4984287f28bdafab146c1c9ee38ebae90a909bc73017c79e1678fa54f954eaba2389dfa81ecca92911cb24543cc3c52f53cfdf4612f6f9697a85eebf1b705c6565eca53b3089ad51c47ba63e196c297987c64fd6391a501b4d80b012f8f678743c802cc792bde24fea6868a880145df224df2bc900b96c1c139d6cd5d595a793fc48b154c8beeb7e8ee48c130036b5791697f9a2b5d7ecbaaa991ce2354455726e7e77c32250e2ce4f61cf58082904b121eb747f9fde132cd40700b344c668109da45a75cbd6ffdb278cc54cc081b0c99f107ceef589e88d45fbc972f038dd2cfa57e816e52ce88d41be5bca1a529819392473739116333a1d23184280b9ee6835e942451485e78d4179027518249b65e0bbe8db23a1680a5eafc7b617e66e695c6f4b12bc7fa6f2143fd48714165e566a751f57abaee78b01f6fcb5243a9026e0ac8c07f665f7a4bc9be5836826a95e48593fa6864a465a175ed77dca095af2f3b7dff57c20b804711863797849ea904402d8ab44988af66e5052819adb89d166c7ff4baccf073329502a95f450e67e3c800a214e102cf81013a15f09818f2d3570a786fb6f14ec970ff253789318f5a9e91fcae3b96934d920e11e57a218c0ad9e9892fe892e9efc14cfaffe88d1a3a357e3b35534f16b51b2ccda65a979d113aebd77fb1ffcc3899b7dfda7aae8bf62819c8811ed62fd6e1de8d63050494359b4c86f53d9d6d67c24adbe7d89e034a52f261c296e2c9bff3c8d2a0ca0239f807936a91314a95bd55c5dde28ae6e85a01ff51550f92a61b261daa0bab5d34d7245376ab887a0350ebd5893d7cf4c5f03dc312666a9e3c47d81f5cf44d49b144d7c8d5b7d4caa4b66c8f0e57d03067ba94395fab274a0796d9e648f881b946f0dea6ee3e5108e1eae82439f48ab7a363285c8dbb2fbbd200b4a18963a62b1acc163fec98e7f1b3b952cea5de7531766c45c97c19fcb841c64278d0e5e2f3d1990de7a4702a9609bd7b9e134246131ecf42b22bde78ecd4a0c12dc2fad9f3c9eebf4a59eb3ae8598fba5f79d8f212310bf3ae6c5f2011951ac659e833e2dc3dbb034eca3a0d08c55d39fad9d9ca41fb5463f6a465d3d627c390a7f7c1e4bb7a00ecbd4a7c2d419bf7380b60da37f5dccef5ecc9d3b9050c67c0a9444e1d22e384d22b089e878c1262bf91a7e373dc9570a123dfeb5b224eb08be7f6671d297dd0661dcd100c88f5475508c23e441682488f4e7c671fa50b34c821b865b8c8a6210f3ca3e86516638123897bad4cbad853dca816570533a1eb6099ffa343ca50b7d9b4a0fb265d0fb55f8280b19951d7affc6485feae3d7d46fe50b93ed5e12a6f36443732bbaba","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
