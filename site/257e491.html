<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2dc371be653ffaa11e1880485824373dad95bda5434fe7c9d3b3e3f3b64d428b0d3d072ab416baa34753f118020261be1072a45eb085aecee2fc1a00511a51fc20bbf5f35557d6c5854ba4b943b84cc075a0ad4ad637cce30c9dbf61449757a67a895793eaae39ef86545d7c4725c96cda1f369957ed8a245cb89004b5c66ee15ef11a4b852dd467429cd4d1042562e74104b0fc833248ae73a17cb682647366f58351e84b4875e3c8821a5055c33954d0a97982b88e41e1f5e233310c1bb0eed2dc06673c9dee705bcac0248250b8b79185671496be2b0cb6a75211d87fece67b585503c3df63c899b592a5ea455f676b13113f01310bd478b0652e84f8be96d5c54f48baa0a89a24f2ce8284053fb06ed453b09920582e5e057b9b04b84a05ceef13d5ef8841e3e888d87d0e97e61785955e0972c94118df2cdfa9e0de3eaa6ddddf6834fb6eed577b9b27b7fc93053405897af5282342ca0962209a2f58d3a0974414c9704d2dcc6d88d80faf476be88fbd97c5271f71cffe0ea724157745e0b534bdcfe51c54d5bf9867d77e38cef8a32f175d2e831a344dc6ff8ac68077a94ca4eb7a5ff82934dfa1b2912eedc69ce1b76c719749014e50579075cfac7431c3df04775c08d91596097dc61291ff821a0c350a1f9f02f955e0df9640be8b2d5621a023fff80c6a94b015cfac8af456e4193e897a94d5b3012a1ea2d5fd92b0a705d05d63024fa6c0d85ed27277f161cfc6e8c38456f9e5be9ac2b95200603faa3c1613d0f36e8ecc9011843252ea87fee1af078afebdd34dd32170d5a33d3cd6e57f360237c7efd06c1f1fcf1017c0e3d7f8ad7418e1bd71cec1e97bddcedbd04d0b59f35783444e2eaf796e204aeba66679ce22292dd399d035393aa04e874ef17ee23f64d7d772ab8ab86c862b2cd1b256ad8c4a7f5e5e2fa652033dd595bf0a98a52397f60af5e1db61b72844bcf3a618f53ed14cc6dda61916c069b6e23364d9aa9b12ffe2e5329a6a67ff450ca51daa4fe79a831a10140f50e1af18943ec957dd509d140d529311694aacac63ca95cd36e2e57910bad1a16a440d8461230bcb93a69650323ee438aae7af304e4ac690eacd2f1242502610cbde89495a02b4f5ff5a465666b47de28544790d9aecb0047ebe1001e87ffad1dcc94fb58141035f1db61c8e48a69edccdaa5bf144a8f334597dbaf3a0028d83cad413eade5f1f57b1bf0e98c8b4ede72b5e011af6dfa2c4072892d719e8848adc8c6b7967514f388e5bbeca58a65242aa23b22bfb4f0f48d67fc6ae215b9dbf17c4ce583f93a9e5cc166e50425df37363a6e6e17cd2714ba20013be3b8b6e6c48cf205df6168f0ca8d90edb60d7b313066a1d589e3f02dde4994548c1b7f699f8735ac587cf5bd2d8351a83e8bbcef98e4ed48a0a403b116060ce88f9fa6ca6d7961ec0e6055ef369341febc2c791f6878d19fc5b8bddb4124865c529af684e074862685056ed2abecbe2912fce8a683e81221c478ec510477631d6240060ec581e455a70f240c8259b1a07aa150f8cb9e94e216928f5ecdc1c6700c3cd519d0e3f761cf5f381af68d03ed789bab02e9e18465f4c7f9b6a582fde2dbe15f54e1310c0a974085745c3ad7a9cf70fd120884faa58dddfa04e3143ac3be204a08a36e1a33673db6182a53474056f14c67097b7b060ec221d18f31b6a61f97a01cf44f5171474fd66f7faf104068f053db9229ef85bbd6c9f4080362ed3a6655f6fc9a1e24114bfa870401717b253412038708902831c5988e58c461a6da504b4599696eb5c71e1cce64785d647990aeeae79be198b37ea69ecd2553de2d1492f662ad9709a8d4fd413445ccb28e717605e94f57843a23a87b9de029285b84f0d38464a34aec281e822576010a15877b83552c21503adcf824251058f8a4d6bdb1fd98b032fec78e089ecb1e371312cdc61a609be4ce32597e33cc66d8000e60305112f1196507eab24e03fb8e2796285c62276065a4a32f2ef1bf57afc181ebe51eda15126fb3809a415dfc17a96628b5fa68fec147906b46317dfb509b61b55004501975db22f8e2c2598219bf908be787b19300fdaaa0b83fdea1fe394fc6245c74d2df6a556f185f450a646c7e736cf3dc54f7ab825f4a5beae4d3439e16d346370c15c6460dc9c1ca51cbf4811874499125bf1baf054eb5f19fdc44de3004ade08447af791aea6598f3289b757af64707217bf0d51bba4b3f262935de2cdf5054cd3bc885d36fca02cffcd22390a0f3c86f2f37c724aee94c09fabd49206dd0dd11f23bd575436d3842b2391dac2bb7a4a2eecef22fcee30390445331fe9eef0f279f97e31d2acce4891aec48a29391d0606159ef29ea7df6c252d4dd711f07980b09543cdfa9db35106234342c6f69fa0771a538ff0487f835ed4096f1f63ace047ddb2801f93da727c8f8527254e03bffff8fbbbb07ef6dddf785dbda6d0c14cc842a0a3b03ba094b6d32ba7cfba1e30db07a8c5ae37cb60de0d73e54e3c1fc8f0ad0e76847281e5d23b5644fc2c84a70bf356b684c43c29ef6ffd62b5355c0d269841441c0f2e4bbd302e37382148d7226336c858a33de2ff083ef92e4c4ed4407adbedd194e0987e043d60c1bade6083dff5f812dbc8b5ef97534d40eb36d8de72e2d5985083b075bad5e8fee3dbded387332f61dfb71ddbedbb69744a8bec2c0a5e06373248d826dc116103fa8d2c69b80b5c7052b493ec1af2809b4d28bb3c2c3d3a7a211bb893171f545c2004aea467f54f700b23db82f3e7cc75cee78d193e35131a6ad7929ed348e4b015ae3f54efeb988760f84786e153baccbdd420bdc2c1f33c3f4a620c6635879b0b1d40a3f2a19459a39b2de45173b35b7c6e1a1097d550c9d514f31c17b1ccad46a8bf25a0064411e5cba9595ba5497e60efc5eeee668a9f63d2880d8d954c27082d48939736147232946ffd7ad18377f47f5facbad451622a84fcf7b54365fc47163779a9d9d97c9c8157b420ea919532a6c3e61a26589f04ada599082e0f304461c3718b6a39dbce976aae4ab2dc25464a9cb3ed412c3a90f431684b9faa8c75eda81af41dcc1d1810dbb1aaf1145a1572502efc023e96133eff98366e11e4d55aac4ef94f1b1434264d743ba8e5ac1beb94591991c3283d72e40d4c77787685b98697419d3f3e2ec907726f4d9826111ce99eba6e22e5cd386872dc22cb6381c7efc3e1f7b72117d5ebeff4ca60ad8c32de7ccfe6c1cde3d37d5868d1f6ceb8eb36fd3b0e5b635cfe97f6663955dff8d40a8405686711262fb98c73dfea6852152f7bbc0a7d1c8f570e668d57ca73cefdea41c7b3fd78a19c2468559775322ba54008c0262625d7ab9991567b7f7427bed22a49a23eb37152d3deb6bc0c979ef6bf86e5009a5b08aa690f6642c22ab8d0c96d91ef43c408ee13838f19734722ecd4d480cb50f799b8f8fb64120160f250098883b5b9a15c6d767c6c7ce7bb9ce9e226e2a6c09c43ced7b8a3b538adf4b6164fa71c651af1d1f2e894828d2de5131fa7ca2a87ef073e9ba740cab7154f4fc4703a00e032a7a38c4e4d0f028e00da50f1a7818754685813bd504d20c524332f2b467796ff41596adc93f579fd78cb35d5608760862a3e04a79d0fdb163caedbb8aab014d3465773a1f12ccab77d938bdfedadb796549e9d11d81c3a104d66c733f2fbdcbf76f2d16b780a8593b6b05d3095d18a85489ae7f0a5b539f563ffbd8860f25de22eebe06f9748bb38b0e49d1a6840cf6469b20de7a01727df40d587649a6bf194e99c2752772920edec2a8dc27f77874a59dc51346133f8cd8b26528c3f915ab6b37473137d99d27d8f40b8e09cd9440919dea348c3ede67f38b9eb5d324539add18652fb76dabb188da0a30bd90ab650dcb4b6a36f30e86404730348032fb83643c7c6d9402f51ce1ce84226727c198ab4926ec82dde9fc1ad2cc9f7426d897a08ea34fd68d28191ea2770761d3c3982a70a823498652036031a347c0adc36237c6bd6006ac71cda06ad1469d6fc4b3bfedfa3ea5fa17b18f9c1ccf7212f0050dd4d5d754ee2c03c4bc9a4139203c8e8c23ed23b29d456bb77f72ce93ed046a774c5b1a5333876f86e43b1faaa94a28b1f41a7ac7a9d99c0dd8647490ac6855792880933d8a67aea8918cd1abf42cfaaf3e57110103bbb01897af5792df89f2afd58bbc5fffe9dad9a6077e2132ceca503bc204b8129ff51974f3edebe2afecf2023f503ea4574d2557b70632cc629dd1d1ff94473743275f3507c3cd57cd48343571fbf876efd9f379c7126c6f586b67461dc57efcd7b552787c5283728fef5881e8f65bc88ca9d0bb025d0a3967ac58fd36edaa303f70cb4ea4b6c958124a18b163ec38097962da51a2dbb65c563aa05ae4cb5239bc76ee4f50d748dd75ccbd354b01c052de54a36c6e20d14dbb248fc699cc6cc31412ce51baf959cec3b439c49eafda2d2d14b6bbfdf02a9ae863976759e500779c3b54d4f6ca189066f19bc876d41d4b3dad86bbe0239b0812d8a41265f1348b8760cf1520c4ede529963d1c2e81c80c694a4fbb7c8a1d875df22e0c22a5c5d9313ec98aa97cbdc8672e7016e9a7c69a8204ffe3d0186d4bbcbe1125309a062784b462105e1b4c60acf7fe04c6ca8ee58400a8f5b27222ecd7eb6a326adb637845e61618a8b1d837d483088edf580bf47a64eb46687c42f7561e25930d44db2baecf4ad5d4cf2ac3f5a7187029e39b7dc09a2eda3950c1a5c7d65e14ccf13074eb68cb73fa107a6fadc7c7ba654b7329a6442cae4aca4a97cf5d21a9d54eff07fa9e1d75b4764a66c5b5c2c3b4ff9bd9bcf49d4e17a96e5ac54f2d14afd0df7a1d0485391a17797b12ab4bc728ef650c2ae136402d698e836c77b846d2e84b862ffafa559f81d915722ba598dcd119ada09dc61ea8cdbb275c72e2e127591441096f7e20dfcee1a4dff1c133fa241ad998ef2b5b04b4bf8753220619f1d1a3798010c79b5164d9979f496e7fa8efddca2e93c6d27585315da830b35eb78aa9718fca1bc511553f4c1dff7a8191de2d29743ea488f7373ea8aa65bca58968f3d758af1df1ef51f598bd4b24b838bc89269839adf03fe9684c069713fe71167fc7a21848a623b6e62805ad1e20ea9c5f4146f1342e2ea332d9dde2a3a11507715cdafe5a8dcbbf5f5c400956f2bbebe77020a813008621c78f28a39bd66b1f587dec40f50b9863998029a7d9ba4882b4bed43bc02baaffe770d90ecb5ec1358440beb454b2972fb91c9ee1372049a2d6349aec322ac538b1c0bba44e0c73c3daaa44b9d806b971f79b1c198b16f21ec60ad24ec378488dfe47171f368a87236855e741df51556cabdb2b5e49a7b1b3648ccbc1b66e6b015a392a4b0ccfcaeff73b75f3a03da9951698127ca1e348d2738a5b34b2c4285c457a145b64a595b791210a6c1bf5e8e400dd6a221eea9efde98187c32653eaf36db2f31dfeee32a528cbf2da2c25a88dada7c2677a8bda26be922d06832ec6db5cdda28cebffbbd600624702b5684446243f2f5a1bf03d5b0c5e40fe820da692dc3c549639df087c9c403f7e53e6a19dc2a9543b7eab53457426bd80854c4ab7484f66ed9cbf53c2f74616ddd9635bb8eb3531f21ea961ba6970c0e4a6b21eed83d00a31a49c257e98c6560e5d6174cb36020257300d8ac2ed4007fe88867d301a1fb33cce02341abc3be4e6533b8fd30fec90f670854785dfc5dc8e34944657710cd90d0858f232407515ba5fc8973199350f1186b8ce7997810706de25acbd8f54018abb313290f1220493764890dbdbd43822acb6850fdd71a5bc3348066be7edd2fb91f85b9352e68d9ed2e30ab95a294a6c90cef704fe4a6843793f55b6b83118ce206d6610b700a267b4b454c815acc6fc8c2c1c389e2c791a9c27b782b28419a1b081dfcc59ea9cf8093c4202ffe1ab78dfdcef5684146182d50ded345b1f56965da1b011e96de9aeeaa38c724a1875ee4420105294c844a30e676050d976e3d076ce45a99172921fba1875c4b6ed9339a75901548cd9ad36ba4593fa78098bc54f08660d0b2698e8f84712d3b1269da741160b211604b794da81ab2dfed57425c8fbe8c986a7ab05a2648650c3e96768fbadef71f1b786a2d8f674940d9fefa8cc7dd638aeb63aa386d84a84be896aff197c12271fbda6113a2eaa053c591160c8f6de3145e192af76fae227bc1aa5a9b7c77b780cd4469c7b11cbc8aefca04bd090f276ab679d4a32c9c4867d605817d8c386cbe8ae4dc0e18b3b8d3a68d97d5dbe0d2d7e326916682cf298f71f63d11f4654a2a58f19afbf3c7bf657009f6c3737a44a13ddfd65e85803a276215e0899aef104a488ea55eabfbc939f78b136e34335dcfa1b366e0fa80eb639b5dafa007b681309ab4299b44ad32410bf71ee3a6532506ae932644016a46d888303ae5844a3e59a2224f6b76a39aa10e647da52fe4889abf998bd479d629aceea097a1f3b2e49f933a04f89f21e38df91778488ca4a6b583edba8df5e004ca35d0d4a05e0473619dce5f1c4036a9b78cb372fa6bc6540df3aef695dac9a2f83cbb4f862418548f16d57d994e8fd3adc1d75f766fe34461b859725af0236c7fd5eb816c911cc80ab25449e18297909018cd90e932b70ea4510638939a266b3bdd65a11b5c3cb6662788ac495438cb02e4ee710cb8f5854c5b6bbe3fb163dba5e7c741533b8e8798dc1fab79af81f3190001962372fcaabcde21c2c8d69c756b4a9bdde4419c7f024805d0cd90c2f0bd1a87548348ee8b14424fec82f9f6bf012b843b289740f4bf996767b71c38fbc856745a05f5e426ccc2cb39727659560cd89bc37d99342571cc488d2a78b6c8f89bc3f489df8647763c093987b1ef35dd53e78cea63e215d8e074e0b6bd8a6da01bbf2b18d78162d6d549e9cd6d1e59581b4cacd42d080379ad37f4a96f4554a1c5dca3d4f22f5f952b9be2f40f03a507e40628386ba1fe0879a5c82118ecf477954bc03d535317cd6040c1749aa097cc2cfd22181329fd7c929988a0091d0af8be4183cf1a8349ea979f6fad798f206ca26b1a45bd9697c775c1c706881648e9663f5222195990d7f26acca1ac089e340eebd02154127d80bd75730fb4d6a7fcfb2fbfab0f2082e3c145a32a2609c2ee4981fb99e183fc1c3dfd06ca1973258ecca4a3af37ca13db01f07f8d3a43995f121deb050850338ef2c2e77cc33deeb631dfb3350bfcf99bc89a11606b4929fd24add7273ea8a3de1c799999b808f8555a009f992e54c1fdfda539bc52c9204845ed386dea7102e1a755e4a6ffd7a9acd3720b76122b198024449fb929b028b0e8b8d669d77d208e80f139a5d3dd260c76486703d53ec2ce56c0fcf3790ddf006ac2d949c40ddd5b819c701a8e89b856adc6289762e28dc0442db7224f8cfefe7c9cbe0185b5d1dd27cd3059ff3283370e943b3b262514b49e20f390aa92e80e35b7503293abc3897b34c34f39d90a90accae69c80b33904534e980ce34e3bdb78e16a89dc347521e79edafc23da9c01bed632f1bfa38db99f7513ac382eb7608aa5c1bb8927dd25edbe9403b4c78c2f26b8706ef1e27446fb04f3b296efb75f32ed428a19092f47c5ecc4e063f02fd6c21c35a16effde9eeafbc310339e7238885bb6f493f0dae2c7d989941c093f58d5389af7fcfae6a3cc0aaed78d2fff9fafc1f20374ae87c3e166847d1fb81d4178c3ec34ba8f5184a30ca86a54b8df46663dd143ce635ca18a870d8764efbdd171b5ba7c702c3d3f6ce2e92942b46e1c51b80142f0db1d4dbdad5a10ffff63e910df1421a4c94ab492063ec39e7705fba7d48158eaf93d2d1bf8e8efbafd59c39880c238f612d896520f763871e418e1a99014f73a8d42f99be962e927aee43e0222cfd837522382db7765b457b12279327b918bfbe60f98ac5234f0979575ee46d0cb6074a9aa9ebce72dd124d37a5e893e5eeab544745a2e8bf733ace34c92321986ece0668c99ca6cf3e1c2a6b6fb8531eea4778e369563cffd512ed3815425fe9a14e79c0b7295bbe3e3ed81d7cd32814daf5e3853dc8ef325417ddc4d032c0d64e82ba72053caa247c8b533d2a17f826bfc55232b5caef8c185443b53a21498c2035441ba578c7072f8b0367b30e373de7d32fc4c76827a26a8d70a35f2790efebd3da96e71750177774b7889d2bea617d75cee95e7dc2accef0e4860e34c37d01e16686aeeacf76f20a5358b844ffe411c33a135d8d79eea3d821325adc01844f2a29c9e5443e1e961e987741f0e5fd36d341a636d63033f5e60a6e322a7b809ce741a00cfd8034c1ca799800222711b18807bc1b597e3f6849c41871682e410dc44a4e15ae2ba5755a43465800813adf4fad57f64e9f21845b6e2215c5aed1c3bea6c985c82cf64b6c03a9067480ba5ef17be7291063b3599304650567c27433c76ac3336531717a7d9f607ac10dabf009d86e9ac4671045e10a910961d0bce6e2429879ddc6002cacb09034ed3b869ffc3cb82a7a0a4ac45ecead3231c5681ff4ff9d4048bb37482ec1307e01ca38bac08b937bed155fd3c5ff988c66c37880220e007a84d16a0a2a85f437cee6c9ecadb4cd0daba7b25d1dfa21f68b972713bf0e51ccee9b1228b9ba8c50defbc610711d6310fd5eb2b43682e41886a0209336b9408e9273d9fc6077db8364073dd5abd8cd1ba430241c7156251ac14c34a7d82aad4bb0b3e74baba00c0f8a42ce5619dcf69d0e25f3c2364cf5b3d89d085787ec7fd273dcbf3e47c0bda9f90900bd376e54a06d7efbc0d3ce5e1ca30d12aee6e14396585a34c43f391388586f00a60a66b97bc7c675387b5a2402d7c3ae1b71841b6ebd92985caf1a4e9badb7bbbca1d646daea901cd75f16c6557fc993cbb7c767b719c31e7c7d3c576b6f228958ea4d37ad2a39c071460d7f531d9fbdb98e9c6be067b42130c594c2653d5bbc1cbc9b9048e71e3cdad0643271aa8027d503f248757a4c23aaf1aa84b8456d6f92505393bd80f6a77c9b1efd2ddcd0dc3200199e2e171e320f069ec2ad52f7f4e82e6cad150e8f524889cd199fe3c68f0c60e1d0d9e7d48e0832818d6017a6c0ff1f26a52523cbb508cf7bd407220f4bfcb47235e2d4e4ea2598bf520f4d13fe7a1d1e961b384203e53a08bfb24cbef7a057b3439058fc805c2f0ed970c4d27d576d6f086a5f8e4ebabd9d079b42507c4d6fccb4d2a2142f0f9733e4560f7906ca03581be1aceb3d0c8845d5371d5d924446e6164ca82af9e5112a8d8716a47d35672cb93708a408f2d30cb9daea81f78b33d8da376cfcb38ac6d929b2f2beb0e1226c730bc29146135368e79cb69827e273a718fd2563516fab6da7da59030ea9b5aec65171d0107f9724a095b3f2c603b57ea3fc342a0dfc0a41d07851c4ac10261785d73a7b7004e9665ca0d49f9994eebacc7f7a9ca9e55717cbbbfb0549c030f96c51531770cd24a57460cbda20765cfd65a2db1f8b0ddefa7a646e99d19e0aeb4d9428f088457bb18858c2d4ffdbc8993d5e1ad593727e73d793fa5c26bf9cc56db6e396ab00441fa371d3ad7f69493361f6ed621f089dccb1d15d0f462d7d4dbdb06b4633fc9e190181c0699e54752cfac3728bc7783efed5b8ab511eecf40ea0d016caac2da41d9b3df56be307ce5cea70c4b7b147d1bb17c187e658557e88fbe916742d16cd2114a8a7855aea145b27311d876081fd86560827b3e2f67c14a80d1b413cef9f18360541b391402f28acd5e9155122be31c0e420259335ddef6033e30f15dc524ae6201c6091c42e22971765eaf178da10f4106cbee7cbdb977a6e161878376b44ecdd362c413e755489fcfb264f820ef474410abee134f85ec7be416766770d3ac224f055abd2db3d43d72080adc5a42149468b6bb933ed16e9142334db4b1862a4101ac755267e8d8d653f05d24e246f22bee71c3fe4d42db8b4eb1f8e2b7fde9c42856a4c6ea565cf6f4262582768edbd51a8dbb94e5be0e55ed11f392d3d00e11561b960db9abd8d241fac08619068aa3c9d220643c547b2410801b18d86bd16158288db70bccea6fba64f7db3f69224143fb8eef605c381e2185e994fbcffb40d24a775f29f76ba3e5cadafa4366434e392f2143a06467d1d72b9c3c42a69dd0703ee90706c59063042ae8f7f101fe5b92be357ee09f92b23153b2cd2389239553ca8121e483d80146bab49d4e717f54d0921a28890e15cf2cd1d659e0c7e32673374d2135e9edca6ec4d17d1262b963448d0058eed521a28a66a1ddab0076252616c48f1e51f1564fad7b55c9bed0f171db4fa1df6aad5e2fc26797c58cf812aa429c76218859961cc8a5618ae832acf1e3db1ba46a862cb45a8c9ff96e50831aa56196ae572ca64f21afda2fed44f76db034171b8524883503c5a023c03ec0d92081f275e12bd3cdf694acd7b6ade5a3075b6af2147440ec8dd8ca1577825130096be6815d86de5c0002e975c6016957338ad1087b2c5a0afd1d9dddf921b9e0a38bdbf24ac09093f1bfc6a64ca4bb68a1c4c0d9a131545167125a95fd075e1988121f6829d18701777b5b278c60eeb7f971cf4f5cadb36f587ca519ec0703c6e79e1114745186e181b2c6d911cc73ee994df7657e8923e1a77633f83391bbca5e489d584a8ffee1a511f39071fd9eaa8e96afe04ce546a12a424ff8626f21b984255b352cfc217b117441645f82be5c04e358cdbca3a69bdeb18638e8d2f5ce36bea33b11189fd21cbf7c1ccbe3edc2ac53cd9f5803cd197d213b64fbb98c68707d46b53468648dd29c28f674c2503f907ebb6e1fa1dc5ca66ea4c9255a6ea7369faf950a859ad5559bdc866656f0d1fe46a8e547884d68c936bbdce7914f5ac5b3d0e1e2945099f2701286116c9fbbc8f9e245de228e26a23f40c916feec93f2dda0ecb970b301dc0afb1ddc85e736e8ab255bc2f09b4e6a3a3f7ce72480c56f77c57c91ab49fc721a1c85a68bb99ad517763ea5f3f8dc40c2008943cdd3ec333cb4a1f5c05088099264b7ddc0cabe20cb34e8a58181cf8b5da8c6b27b12b153864aa9b41a95777447fd77ce3b810c03bf8e07ed9d2a3784a782dd97793801a2b9223ca041eea945f9e0f03d03d8f76a9bf337c897fd3f0c8f4115577c7a7be1658fac1e55bbc8c7fc24345ebf0bb2467ebe4c40a5656dc5b91832849d1a8260b247633f0af6a93c7c618e87a163ad43a6f1fd2f0dc1b5cd5030ef9e62c2d7ac22eddb92c5e9bde842b92b0a62bb9d4a7f894bf9641726ad0792f9b375aee6c36d8eeed1758a904e43fb268123ac83246a33dcaa6cffa95e0646557aad7a1c9fa7abb0b0dcc16aa4a8daab7a05b90735174f02f56fe355925f0fc23734875d1b4cec1fc2a068bd8fe4cb47ebc6d61612a86ba76d0413c7dc5d3e4cc38747690","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
