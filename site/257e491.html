<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ff4e10348f080015c1f27675110b83641efd88482034843468e3cf3fe92357b20b7df56eda1cd947ecbc222457000d8afb91f7278ed7e2ddce20a9b254fc77c2b127b09065739c5bf589733f80a57d2c105730023cd7adc02883acf481ceed2ded7f3fb675dddb6638cbb6354ccda2dc63fc0506797988503574925714549b2a1cd95f6460a49880fc60cea9ba8c092a7ff651a4400d9bb5390c8934e367cf3f9c797278635fcf718af8450ef079fa24ef8f1a81a51c933f3622a96e9c66684652e7a962d83416ef6b25b5e78a732bed7360e52f8268d4e7f5ab2a14d8d419decbe552ca330f43f6ef4172b245ee6bc2b884364dd9fe75bf95e30f50b9021f1171ce77e6ed4d4dddc26c42bdb708564cd465aa46e5c59440d47a288b51e9790d8164a600a5cfd95e7053f156cdc4fc352d4ab39b61e9043dd2c55e3376e92bdc494bffd8dbb95a0d82c5d7c9b8114a800a697db267ddaad29a8bb0423bc5287b6de1fbd40e98625d9ff1fdb80a123eded948244f74462fba15e59867ca8a88d442dd6c88e44fba074ea74f3de8feb8186462939c6b9c191ecc04618942d7a2fca17532f61ba2f83f45b2eb6ee008cdce92d309600eda57c3139fede8dce241ad566fdf294fc2382ea4265b18275f39f79a7749b0b2cb554b4dc39e16d97e4fd2da2c75634390b83d83ddd151937286ce146200a255d5fec0d23e5d15b1ebb2cbcf0ce4c3ae132f484c3029901a0835c0918e6b5366a04e195cca194dc07475fecfaf5572dadb522eb511577ff70c7bf2485355b7e6d7c54b7bddb20dab9e98b74506376adb0df06990515d7eed7eb8727ea99bac742564f2daf5448cfc2e9ccf0e243e94ae7fa921d6645b0e924c0e35840225330bfb64ca47c55b12d2d6b6013745cdfb692d3ad3f5f486c702c4df0286ee0eb71819979fd4f8b78ffb62ee3325bf309aa32e3cd49950be4b9395a99efc2386c84f83fc067fbce3296b6084ea7d7609956cfaa8c90174115a267509e80da19a7cf1c319babc02c5bfebfd8e9bed745f5221717e21ca528b00b71660b2e11b72ffd71b80b03a61be1c9f465b970094bbbd81a5675d05e7bf94de700394b3606d58cbecb5a4dec420c43214c43186cc5bafe57eb13d174ba688e9c51a530b956b8973cafc1432015575864f8ea1fadd7aa812d8b1258eeb218b7090101383d2525e0f8d1421ec49cf7dd427589c5ad1f4f6fc84fac4c71d8670a0899d53cd6c3b1bbc67dbf5831108860eb9ac8ce16df42ff7307bf91416b9f4255a5296d9fe01d333bf2fe6610e40fdbfb8a9542f19b5f0feec4f5f0a851e0d9183cc7d689326b3db1d3ed5cf585a449a024c31fbffe15bcdff2a92b37db3e45940b6037a558d5b0b7d06026cbe7629a3cb9f0c7fa93abae84b1865e7b551e20d89ac932b73e073b861ff1c622845ddb7f7c8bff9831dbe9a8f01ab43201c49930c2ad10ecee64b17423b454477fd99e998a41c25209d9e138d9ca6ea38e4c36271901dc68fbda8af594659007db55a9c59a811f97c5c9264b40b59df5384c3dfd72cae040da4c49fa85e0d233457bc32e48bf0fdaf2aa0a171aab460117c2c4c0fc24f401c834a02f13107a4258d50fd45d5f57137d6efe658d82a9b2f91331741e1a679c2e91d38180356196aec1f78b36d24b829e1d92c8d1e2c7d5bb3fcd4dc977db8c657e5392a3fac27166fdf6302292f5468617b0e6570211df1caf9221ee61f32a0a2396c97c50e160590b16744a52b1c5833e40f55f1afbc53c4c0ec4f5d9451c53d10a7a2193323fccbf1f8997f9fffa7272e61bcb4fc68d059c915eed9220c76f5372b9babc350247df513ea4b3256673dfb364ad0a7f09f65601b90bb7abf40e72978a53be053dd574c81eedf121130ea5684ecc86a2d057accc2ef9d3856ea371793d3669f814cdbec1d1a9525c1682cba46ffe12f554fdadd1ba8f83e65d86b513bf5798593489150d7d954101629b34b1d190a7da2fd3d0cce879b4239901cfe0efc7f05924247eb833e707228b1be0faca514cb25c977868313473284702dd7716450da62f784e04e49509993918830daf3873ed92c63f01f11043b6b43a062c16634f8f9a475e31dc0068634c895767787a3874fc900f29baec249603b283ad048b07a685c543ba7cb47e0bff562db030fad53ac3acae52069b113876d1e088752015e5ab9a424507743781fa940ce9d88063ce2c6838e8be337113f32dfa69516dd38335e4c3211cc14dd4f393b073b690e369dec6711b80359544a072284f16e59c679254c41a191792583cc20f8b7628c19b0f4d26fa9f15aca333cdec0b85961f68cdcea5d84878fd706b5e66387c7e098fa37713cadd82bfcd441c6cd9e05b4d21797417b8cafb2fbfa20d886eef55a9d94c1006b25f881a613a8e70362aeca972a5c59a48f5cdb529f1c75c570019c96e733d54da82186ed0641225f5c56c384707c8cf2d3791d74a74a9055b53c3bb4e889ee05f291cac3ce6543d2299e1e3fd87d23f51110e7a0eeca95a51601e49921f53ad8378385fbeda1486f584a25f78919ea65e985aeed56be05d6215ca9bba1fc395a3d56d1e57c4f63cdf2de6dc94eb3eeae283dc67f016bd7ef3da5c1bb31ae1516bd0010f6e909ca8e294e5c7b859347ae74eef386e5c7edd084871f178fe269a4837d326c76d5fe38942daef71fc90f40d163e5f81adced27a385d2732202e95ea0610617d1dd8cdfcbe2daf505f55965df4e9f937db30dde2d0ba53640798f506c323693719064792a06a8d316ba31b7537eff5d0fde0d60f8f2cdff0ee5215d861885792a1c786d93d14a627c2e95e0704bb1b768f7c5c24b7944b1737b1f0cf1b9ed9bb3407eaaffe6feda69dacdca6d51d7394058b702ef590e26743f1d7be6a01ff0e133112bf5807035f04e1ffab175c5a3bd0c33ea86d5e97f210000b3de83d07e7af6284a3a8e47e89a33b0b67ff722d6a32deaed1db4cafc991b09266673955c4516e5dbfb26e2a26f0946f96c2d9b7291fa0cff768a385014df42e9cf195e7ac7114a4c84f836dbe03cc0e0613bfd5f6049a712ad2dc87ccbf95cdba0863e2fb310e14e13decd8c1aad37b478b311a9234fc0950b29697b191f6167878d92f1e436654ef09b5f3ffedd84db27dd6a801b23fd0289332cd05cb31880a975d9b9b2447173d48cef78a5d0236efee8d568a6e87f7ed2e762b193c35f1a44b5102631a4eefe8d28f6d82c2fe3f77c7f934f11e377f46c4c9c414f23eac3184599ff136919b5b66a57f308f66e0968dd39c5761465724ec9a32f47b56e90e85a48beff7c6042c7bb0f002989e2d17542ed7d4e02d89ca75cdf57e86bc7ad579dc57f744c455249fd0a68c25cee2082d6ebe40d14bc0783e8897c8414b2f13c1036fb5f64a6842d98489e0b21a2bdd85b6d36a65ec6d451ef68244e26a83df40629d4f28576750dab26f4e8d7beec5a19eaa761d0fef9c252af57787e9268d78ae6da61da10bc06dc372be788eb8efb633dfffa4edcbf8e079efac405419e8cc0e466e24bba30d678d0570650b01282e8fc3866da9aa75b21fcb6c5bd483fe67f9ca37100b67e61edd29dd8ca3a2bd5e647d316732d617bc7840b4012547ac34248dd3117ed81876e6225f863d229a551af9d6f03e4784f081f20fc68b6eb9a163f9044abd2fd090754cb3b2514c5c59a55326dcfecfd77131dc899ad982dccf1205e723a77e1eccd4632f58054b345935a417655048e5856b8da5ed5cf4386883cdf7817aa04a59bfccb66cc88b19b5eff1dcc6c0d0c0708065a8523d4d7e4039eaeea40bcbdd7483de06a1c67e19dcea8f25061c06c3b8b90486fddd56220ebc4f5140c96e7b7ca7723d12a220a919b03917bf473cd70221552608afb08daae24c5fe47cc9261a0fce8569fe1e96d90432b7d0ecd80a6601123ca636caf2dd29f1d21b503efe997289e62b9270910289c45416b34396c4fb1305de7a7b5650dea52983821e9948ea22aa26b75ef6ded86094d6dd3c774332e734e1ab5f28a234687bbe33027cae081abad55daf6d2f8e9916fa3ef48043005687dbc808f32c05c99464df76ae60fc2435c8a108a2f5fff1b0a48ed004409b691e1a94c3ec07a7b148239d2e126e355ad74826795acdcc3e7a8480ee9d67698f6f45ddb34289ac146d8247014e519aa321c8f997f1236e6e540ee73e491b4645bc0adbca74e8faeee40f856206e6672920170a6b0bc460656799adf685e8b16615bcbdd36e8bf24fb455deee893bbb6db1b9881aa2e3a6f0db1454663d577a467d09fb9c1fba6e7926d91406ab3a70c7f6bbaebb9cb3aa4b29c7f8b8d5609696cb2f3016204fb8ae71b86032d8f1600bf6cac187007413f715a12b364c7eda3dbd3c29b91ad34d275a6908607e17b363991718b1f342729bebbb2abe36b16a6c55eb1f272af075c6b188c4cecd3cf536b023c3d6494f30f1ea021c7fa5fc98358e22ba45df9ed45ee662ba3522d8869ea1698dfd838bff1d84323d04bbe6c09710a26d7d08308363805180884bb78dd46d5a83b4366341b0a7598b0e70a34d35d4f43ae301bc0d615862896be26b967065f60255aea640ec2e3bcd379546b00e629f6ffbf86e04a4871b45873304522a34b047eb217b63d66bcab6f65756ffc11e1d86c7147fe07303d8b41477b8472a93563431731e11a08ad2af8055d60c23a905cc248db2afae42f39907e727e977860017172ecdcaeb9f345a59cdb2090f7ee0a7ed78300add858774cb0a11142399e46384625379dd1cd56323ec5f032ecd4d59dba718b75cd0690f8073ae7acaef25c55454a00ca3d5590c355d1c26d20eace04629af72e24e5e34c2da35d97226484fc0453899419708853def7be973c416a20aaac16e4bbcd9022f94e33f145a30e9e772ef30bd700dc827565858670a639a12ae35d2d37f334ba541c44ee705794283603f0ef72b09ba714f378e97149886530833f01fe1ea8a66f177835e6143c93233ae0194a07433382a2355cf7d82de9476fcf8cdc3917adea61cf15462e1b5207fa920a0e0847dfaebbe2aa5a391865ab504bd7dcf3f3742c4af30ff33c3bb10a808bc178da2ab3e5a6c1606f6f40289c8299b1c6ba0351884a4b47b3bd51e108d04ce0d3228e656e820e511a395c31e28fafe970de5f4e5b74a6a77ee13cefd39f214feb7e1c3918cf641409367d1d65ac437019c051fe821f3afdbc7142fd1aea23e05f62cab17578f1c12705000b3fcaafed7183a43632bf2624335f00247d02cd35bf88da30909b255b1051a53b357b38d148fb522f787b37f170e1fd0bd62d39954343b3ae88a13f09ccf309b1f5f1dd24a827977024608a5968a9bbe596d05d3389497eb162a3bc028dac919de15ebabba62756eed6c3155c3fa6a70fcb0348229053cb14cf21fa98c378198c10f2108047fa96594f947b597fe2f92813d3fa1b021b697f892782f62f32bbcbc096283b9b5747a2742f8bb1d221bb22c81fa5a61b7a398b4f9538bee4f0b756ed963ac45845a7a003d1d003f9108610d23a93f05f4548ef370beee5db9fc178a046ab9450092220c150fa3785e4b513523c6cecbb9e6ccb528e49591fbe7b81331b3e5b86010da2adac959dc30eded150743d93f43fc9c94db4e3758b2421ed83163011c3f139c8fa9dbc2f818f758bbeda66285190091f1831e7db5c938c43b15696896f5d61cd354f5b9326824224e15e9b0b40262543df7239beb8cb147772846aa894e94db0cacf772ef9ac5914faf7afb8531b08b852b51b04ceef777475573a054674b2e6a4e1c22569a8f03e9ff79c48fe51257cea232de0dc48735b9644e64eadcbacefacb3f918b34937faf8f34ae477396aa27fc5abb665d964636892f0e8ac23808709ebae74a0c69cec090c0600213efa22f4f8fb0c2d33fda4f35b5edeb0d227415a8cb1158832c09c607793c017f76e59d54d4cb6691e907ba19108ce1d2d6359eeb08b46b91e476cf9238723fe5540a0f4e3449250d3266bc7a70eef38853d3e7ec827813a6fc880c9c88f5937a84b09485ecd50505a7f0aa965d9e598d0217321e9409b0986ab6201a869d606989515e79971fbbaced8f274e545eada344e7a870df2b2d7590624620c9607b739d069a591ac29776a41f63e93d010a111ba517e693122afe9865fe72a7c5429d533b162cbe49a95c0195ae5196bdc60e62c1d4271ee4a8d7b1561cc7d739f18af254a51e9079a59bd51d584e4703240150d978d2396a3ff2311b0ddfba7afd015b4d5b457cf15f0a1999ac1590abb764ae44af27ba03790812f2196f54b1e50dbfdcd92f80ad28222f5e33c125a7c6aa3fd76f18a7e5ce99ced3bda243daf61e82460aa787f203b36a9ae2ce48f209a41cdc54c034dd648a3a7f405e3551461b08ba0db4c086890c0f7c93d633704edb110274153c3023f1773ad4956ca58a39d94c2e09af7b0165c6891d3d4e5b14d2e29d5130c221e87a4e15ec34c48f42829c93887857d837d4fb6bfa91f128732b1db675a4d091be1551f4015cd41896e76097e36aca387d94ada485a8394c8bf5bcf4bbaa9e73069f86ea22b8b9cb1ce641fcc73cecb5e514c666a6e65ecd0dd8f32f5a1e976fd6c761c1ce56aea25145793e0949ba108ed96719ba0f950d69159929b623f00182c4d229ece1fbc1f14dbe80ac0d34ebe6eae959fae5eab2c6a6236a3fc8947dedcce7083897ba98a75fc8ee48c6814586a2ffa423e79ec7cef01eb626156b33bf6c60203198d9a496d10f19732844ea977da2013019638ac7ca35b24e53099ea2c8909475d94a1f344489eae292338a63baecf94a82d12469720a4f02f44aa046813a203cd32e8e1ad12d6dd502ecbcf515e1879f6243129709f2b6a735c666a37273d561dba532119daa136bce887f68567846ca48edce7ff2a2dc3ee77f23195da388a2faa4ea91030806ee74c569e207a7a277b24c2354e748df412974b3a6150593a0383e283490b8038de82fa8d04beb7a1b7772e5ece91c7ee8c01077192c06594253ea6c0214bdd2c009f6c5eaa3160bf6bfe0233610df9eb66171c4b36a1f461fa71aff942e666a621e697a7130eee5179abbb188d7287ed3304d3451ba263f38c9d53541a48769c9139706857752f257e96287e4aebb671e3b2029b742586bd2c7c3e43984e72de827aa4f789a9241da6a43b75bb3b7f36ae06d8acfea237d16032c609a51fb16efc519415321fc01918f9d4d5ac23c4d1eece0879da7e226d8d91cc53c8bd62c098ce0cddba27c8f80b62b047cfc43b774a7938f65732d3b504f68d9d8125968d132cc51e5fc913aaf0f2a1b0e49ac27c5deb26f6690345ebc78be9d1056ce1f693b169cd96c1a153aebb1638e8a8fdf2858f7178e5c9fcf99e59fecf51154eb853f93d906be48b9274a25ec264821c0562ec69bf1e2cf4009fb806f882129dc50c381e084884b7d4c487ba4dc6ab950aa833fa478972f02e734f7d05b17819a0f0128f3f48e2254e4ff6ddd0f5ee38300856de822c60c595aa483ef0b52a6b9b2ccc323a9fec14eef5750a3ac03094595273f79085aade75345e26c0d45f1727e18467fba705fca97bdc226e3b7950fef5a1b6cc25343766aabc84dad8e17edb7d684ad7f5d78d52fe466f65222de9b59b2b110670e6e54ac1649864a9f6a38cc0cfa5002959ae8894afb5e6a6402803238a0d837257ec843797ef82c2dda112df30576b62252d6cc7973a92b30e4a2980ef3880b15197277ba6b7743400cc4f7760b1363e9b7d241bb75c2e20ad418f4174a7520de8f6731066d4f0905afd9a39b499bf7515b3fdcab3fba31f36d7737b28a891519a9add36263918b73e980c93ba9cfc050a3c41a8ec4514a3af4af092792e6c6a92734d8d9d4d3028663fd216bd5be892c2e054562964622989fbeed28db3678e63803452c388f8e6c30d4d4878fe1ae4e835f987a1bf8cefd50c9c675734db00bd54ed51234cc58d962fdcb876aa821ead06b5ca9adca00b3027b0db5255b82a32268217bd808a74538b69c072649b13146880aec47cdab2b130d013d1b5ee6a9ad5ca7fe8a378f2e39be56b63b368799713653f1ff51514aa1d63079dfc0c5073ed2e7f264e4d514bb9d3bb0bc0c5e0b63b9218b91b466e69f4dfe8a415ba594f51e27d0b2759635c3da60d3d85dc52976b12932eb5f030c2c075fdd4ddf4f5e40dabe52436620aa113a46d508ca8f92f7457817436f70f797c45bb853a2649fbe175da697d04a1986a0f2cda91fb6c275f11a2be2f0fe770491ef22ab2c9ebccc7dc9ffd0f9982d118153069b09b42423b30f4e9332d9fa05e2a5644f9c2f238101cd6e7c76a4ed41da73434258e96c535202828ecd6a8c9bc605a646761e77cee321f614fcc9ab94692266caa16562faccb1c79e4681d45aa567a5eddfbab0e3ee856a5d7564022e48758c256f4a6fc9f01dcbb7bb948dc9cb8aaea9b93c0819775acf8bc076f9af3a724b24194bc172f51505658f900bbf61ba9823592ac854d2f02f5b8637f4030156ca458ce586f9e42a8af489446c4ed8ed35d195ed07ef741e023d89f7528a4184e0437d8eb01ee8e9b4cc70c670f5639119974fe850db340bef3cac68eebdfff51e34eb9af8393b0e39bf96b9c0cf5e2b323bdb4de36de954cf726a9c46837fe02c890d0cac3b27035d0105da69b02be4e02cbdeb7006ca7712dd9adc64cafc30929302f98dfdc28c33fb810172773fa2e4dbd39ca87c5778e6885ded9c3af8fba701e9f923ff3bb5c8b9e14741d8d73f70d78ec76a0cec8b17771f887f3aaf5958032b076f81e9995a6305019563d2ef9b92835b3df2fa93f01be48f7889fba4cb124af3d258bf4ced17748d1c30c8afd165802ca8624e1daad35650924dbecfee6e4234149969e29de62e00d154dac47e6acbe7eae6652db66d50432abbbf77e3a70ba2d0f986f48bfc59f2939033b09728c970f03a24cd9c9547f9230ac38f1313f215b33a75c0f17e6674e74284c2a90d22ff5183d9c343de8d324da827ee9da880dbc8cccece0bea7e4ef472469375fdbbf0d5c38301627de182ff133eb7b3544738f093787045e8ffe585721be0f8e2fcb8a58973d1046a50fb7baf168eefc8b744cf0a97f91b3223bbf7f91be9946cbaa4bd0be91bd2db8334bf6fd5388b8a5d6c299b154e68a7307371e09e6a0a289804227f3817827ee15e54809f54d76ce8b2a1ca65cc5704a5b9d86a5c8c02dfebc8af9d661c37aa9c9a85e1e1f08f24b910accbf03b052c641dfafd103fa3ec70307f5c988a6d768e535f87963885a55bed71af03ca505046b77f113be94c4161c7b455864a2369d868a9e1ecb249f2da92f8c1896348271d5ee821baaff05b223d735e675bddfde1517a25dd6a12b50b6346f1d5a2ef399d088d308cde5a2f77fcb48f788cfab2d9f0fb5de9766c65e5fae1dd3921fc884eae40848fc8eea3c9daad5163a3c358d1c7c12eb615aa8210681d0073dbcef1e183deca809b3cbd3fa01a88dd364c161f3f8f8ec6232ffc235239d508aad0d5b6fafa4e459b9a025268169b3c3165b2da368d49cf53d843939aa2a4e4295972aec88ebd0cad88771e56b6413c50cab948bd05402397f3f84cb5e07b056ba8986ea9172dd90bf096b11fd9071a8cfbb11729c273d52a1cf262fc0ea17bc8b1245525e46deaf322b5c51018baa85b64637dcc39a408611aa9f64b352779dc405ae8e2286bf40632762a23b27be35846ad5a1929021c22714210ff41e56dc5387ebdae607e97fa101b394006028a232c15b97dccdbc7fde2967e03a822aae3ef38249945e27a129a5b89c24a4a968177788e831ec6375471fb836616a1c2e7d13819f3635c8de8d4db6ced223a3fc302453e13316ce6be0ed37811b6f5fbf46bc7385218602cfc63097a97901cd87f71e2fef5d8d1511fea53d3eec0431f10d2300b74c72fd947269f726c59a3cf5bc42c94fc4d645a02e5f1748f3c8880a341d1805db4c9ffde8d3c9023bd1793db4aac3c55b407c334fdfda80e2aad5742f34893a750461506f3b617e3b2b8f2d8b489157f546f844131c7fa4e4469f45fe680681cef7efba6e8be6f2c0e6971f94855a6e7bc3ddc35d22b068468a637b7954318e782507154d5583509e0f3a8e734511278eef3f194094ada8bc09b897a2d6f6d6a753e11acae0d3953cbff579f6d24ca287fe441b210ee9c19b77cf4eea5721de99b55a21b6b890e29c4d62551909e19b5f86e51374d89fa585ac9784879418ab57c57fb1ab4e48b0ac0c453cc8f91d7b6d112cba4908f0f573822e2fcbe77f80379703e5f4b021b8a8a2a97e33df7a077dd841b2eb3bec496b335a240cdb894050ebac56562a774aaf73c8a8770cad3a9fefb78e5c99a5904033be8b814ec342120facd57e8f45bf45915c10fb9cf6f956c1c782b930519f098754b5f3e50cf2ed2bf3f086a9ced1e391de56fa64bff6c6723eac8a949061f46b8546a9f56c20e182606c64b7571e2bfe1305b6e8a151f9aa9acbd52ae628eb813a5220066efc634046f905993c67f4c5a960651406ddf58d58a1bd6b3482b4a9b89229b7d48684d63c6b82f074421505c8fce30a4f055bdb9eb975b327c3fc0d967958ce30d8452e44f0566f14a8fd4b63830ff9855548d013c1b9f1cdb42144b319f579b4ffb1e9b292efb9c0d5fa6fcd3af47afd768d06bcf3c0a88a9aef4682b04cd153c07b2d98bc20d94a5d4e9a9b37b27ad77551fe10f658f7aaaa6b47edbc0e2cf10e2e4038c366aa5f6ec051be155fdccc7e5792a01b5f05a7191d34b74061785d34a62496b4d8939157420ed34c98c37de72f955e4361e818726be62ce8524db384157e3f4c5338058bbf515cf5e9eaf49312329406ae88f884dfff35e201e037704135241563e56296839df4b4e0e24bfa3ab256eb6178be57c37abba5a25153a02a57b055eee03b6a3176c6bb9daa531dd9827ca07a743a571b700a69aa05dfc991c1783379b6afca6c1a4aeab771d341e9ee329f47e9484fe7286906349eb37bf9f1844213083a8d872afaff64a5fc93e9671aa7cdc3b4b7f55968dc9c468b621107babe6fe22d7e4de80f1eed746812bbbd462eca8f5d54a84dc3bcbbc7b269c96d2f09e053b4a01a66935adcd87896dcdbc979f7c7b769f5e1ea9e250b56d0ac14d9d86faca6bf720628bef8234e218c411b47b272e53090bd0afe71849058ab0f18fb0f7286ce4c3514628a3332794e4e50def8fcd8c0558d7588fb09f94d5ec65f675af1947278fabb267472e759eb81f2b289d54c9a6c3db381bf0e3953bd7a1a1a6aea2f09693454265179ce1e7aa9b5ab5a98056205f0ec0af72bb32e3295d1e6714483c0fe545b57091c486df80c953859272d6e6b616d4129cb69112d1de72c2304cedc12a06fd583bc16676b94b2ba01e5dfa7d06d1b083827518cc","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
