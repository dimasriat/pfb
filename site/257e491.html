<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39a2177ec3017db9ac5c6be4af2a6b49ae072bd22cee069c81b41806dc6c74ebc7116b0d65a981989caca4d7695c2fd635ec35120cc84a66df0638bae2561174a8fb76829e7ee63c9103cdd6ac65128ad4937820317b7e162d625f611554265cd5a03f5c0759fc3f7c45db19a211ed81779b6ffbb08350d2952fea16edc88f71ae063ba6d49d81e86bd93edfc8971e7eff45b3481c14fe47ca35e77a9e92ba3cefd23b6d5dfed7081f4d40f1eadd1ad4e97b9501aa45d680c7b65fa15f1618dfab4159dd49e0a432030bfc921e65d8358feb5ad056f2eb1e86471a4542fe3db1e754771935008bad7238875366b94681cf32e9e87344ed5bfedc256aad64720e00c11d6b106bb7d413859e5cc7d3b5127d0ec693619a02bfb62bd4e437635688a62ad290000c9359219475cfe6c07a303d7367a48127940c351d7212bba02544c5611b94a46b0eabd564c5fa5d46d736fb415427648dc7c5b37c7307318297b4d90ede05697176eaa95cddbf33a3da5d101f6e3232c7466f68e95a786c20966124f9e85ca5ef0bb251d1173afd1ae24108387ae95237363c27438cb0f8381f5e090ababc09262791705a91509af917e954f84456944d183a772b8cbc6f708c0bb0b91e140e1acae99350f545ea0ea834728378c9f0479133002c82ecd72cebf500324457ce0b282d075581dbf50e860daabd3bfaa3c55f49565f56a0fe0dd9e8dbb498d944d33f88476e998d1a2be9a50bc12a854475502011d200ae927e7c3fe39be8b012e64f9c0cf599b6a59b0e7c8e862f632fc8ec1f433e9d20408dbf63d15df894c1cb35983b00dc1fb1abcc53184f1550220bef583448417d8e27d3ed0b6346cfe879cc66367e9f0fc789903590c63a51b8d02a8e44c5c8abc65611556765b949c5bcad765c60f8c0dc8111a1f4d7b9fa792206a991af4321bd7cc62eb49a8cbcce3723bfbfb8d8e88f616a8f8d50f1ea00dfb4a6b6d64c0ababdeda56ac495f3fee14e4637a28d140fd6c8563c6502f1e7836c36825c75af5b0a25e684f61a8d4d02a7d1a164563324ea5972e9a1089c04deb8650bf0db9c6c21b524fb7b341455eb3cf33b9edb4801b209b00039fd6663bfa058b40aa86467d6f2049de5127fbd183da5564e63aa1e5a616777e073b6cf165762a9f481018c0eb8ef48639163a716d53a50358739d58666163b3a2d7a5ba48c7b126f3ddf56bdb48bfcf922613bb4a642ed6cb3e7384fc3b9e69d6a6bdda938b956f3f6312357d85e9995c10b38fa9ec21669c4892b67b42c3bc3d9f2c7cd25bcd934d8ba52b0080ef3b30b63133e0bfaae6ebb5b9bb46994f7d8fa9e0f84fa6555256fa36a21d133f0958325eb5007e7403fb04441a68890653043700da56c171bc3b92f645201ef7c5dae88cc28db65f234b718bbf4cab203b1bff18f93fb8c46cdfc6ec4945824eabf47291dff626a19a1ac776a803d5bde8d35fbf5f3ef0f9d328c93f765b08acfcbfdeb722fce4d921f920353ef5ee8e6798c0e95be1dc7854aac998c8c46ad97a0a4e3af0eb369519a711bc0e5d297836b7217e5093507274f78575c264afd3008a1aa35e7a71b54dbdda586c2e99d8dfab2c061b3d6b55844379918b6ec76a4da84420ef7bb7780a40e0150b10fc9b329e15d9bb35e4b4114e0f932dcd814c95ab0f5f847e8c51001082c0319c39a097a3e14cc29856977171eb08676a40df3fb177293dfb44ae27b2b27665fb5dc64b9565f97fdac1cb8a65d3a4a72b2341edfa8c1f1eaf66ce577ca045bacfd55c199a5fc2e7211ec1366f71733a69f136dfb68d6d112724e050741cd049232283d7226bd1d6b52ca03b036c39541f5967291d555a4a9a416111c62d3c0bb16104d3bbbc82670725c1f8297fc4044ac4d7b0688bedc90fb9216cf39200d6e7637fa973cf095b1d1e14f7d8f656101600e379f4428edc9a03a304ff35ac95744a9186fff034e1a9ae1b25b85547e96575696e449e245d40378516e3166e513d18f5a93c8e22df20a6135174d574cc1c818571b363647c1646a00100ce3f64c484fcbfd9737b1d149a48addf7359579b24c667c80c99fcd843af63e27ea8196e551d32cee5b1d6c19feec6a91d375f9d7dad1ee48202e630d4eaaecb8b710260dc2ef57abf9bec71852d131ae6add317fa2181f9018b616370f16bbcf5fe51e3664150c7bfb4c6f7ca53860a386b74e2500c51f6bd0982278d3ed720a0af7341ff94f7f50ec9aa5a5fd35055bf20d1a54c600cb5f77b2c4cfe2b0e8d2796dc852f6d35f0a3d1c5aef6ffa13db477e25051082c122da459d9e4381c5264c8334ecb67dc550e6f69429ea1a8080ec54b9639efec71c3659107c60ee3af102494f89055a4791ecc4af964fcc34a6d270eb7db8c2d91d299d6f04e378e26709d16d344347d397799611744949b04d00568a6d9f7adc55c48279135f1b7a6aa4eafcedb90b5b88314244cc7466e99ff9013d338745ea0c152fc8d073da0f370ecc80b2daa97b5b5819b775cdcb5f016e5e424d54feba4ba5bf817a67652dc80abb852ff3956791a80dc1716445de22c540f584bc6861e1af9290fe9da044129d60e21cd11c9d75e2d77e0a36b69520ec3f8e81aa82939d699e354a72125173ec2d93894a2f1f086cc8bc05bbecc73b5b1a37f6b9f606fa53a607c06afa0d04a612f322cabd5d5085e6b3ffe669d690d45cf21b625d8a1873f7a0b2fff9d1f05536dbeabaf45ad01da3a5c1dece57c6d202062a76012415ad32aa80de2c48d5fb65cfa21fbe384a99c921131ed467f132bdb7750df75d0e9e3cd0adfba690b812b8d911ae55a396d64341c383f3c578385173c0ce20f6042e5c889e7c2ebd968719bddfa39b192a8dbeb5b1216b2dc27ab013e17c570ed4920f0a5a53eb201dd1cf231a06ee610eda7a5addda9a490ede39d0335aeff2e62913d8936e8b2c3e864f55296eb0fa84b345036bb413f92dd120c017fc76c601bcf26d0857b1bfb24fa195f28ff2edcf7f87d96e3b8f6c30c2debab041d174fd874ce77b0b759c62d4bd26fc6c1c41df875c8b481659169669c3d4d2f17a3159103606ee4c956c699ab20de1882c2d9f1cdbcd8005c0e7baf86640b21b6f0cd2bcf1577e0abff3084fb24f1824b955341301a5bdcf840ad28a6570595168feac4e298ea5d3fb2050cf2caacce198396972095e3cbdda24eef4339e634aa57793befc26d7382e4325342bb711a01f13a480d741dfacb428688bcd36cf12e4e53bafb8d4f0e95dcf3de15d3e8ab2766c894d151cecc9d8cefe3dfaca61ae89d73eb8d6f5f3eef8f247f367cf101d60a2dfb61e738ae87771d2eaac16a19f181b433fb8651a6e4879a77605aa5db872f4664a43195b13495ad61bb279155a12d36e970fdf4a440b8a5e9bc3430239e6bf6eb46f0630e8f6128b88ab665aeffba264d7add6bafe2406296af25dc53440a9fbf5348fffcc56c4d6b81c2de44f1a09df52667494fdc20ddb8e1bed3887ac528a23240f342cb8255f4a05ff5fb50d6a894e6359c79d82b256d22ec376cc29e60c29f18a496162245fc31ac13049438d221b1d7b9a8f57c469c520ef55364626bc74fc3da859442fe1ca0c27214bc516c587d60b209d88c312409152ac3d48e2477fc4650e9b0997d48c9b0851d00a1e84cde07fd8dc81435bf1f19c61fc899accc5901506d96f82f165d06a52d269a36e72db243b1f9c62e7e3febc2dbea14b414baacfa71d99db953a887d9167de9572476d4765a910d221050c68835438add16cf8736f748c6b1c50418475788133801f29fb904ab1e1398dfbf1f275d72e35f798d23eecbe703e034566b0b130113ba6a0d98500df687ef705352bc041ed8befb834dab7ec93bc5a82d06223b337641e5e715aad37061ec64e2fab5b732ce9c4bcf20396484ede25b49f896a311ee7db13fbd6916b68255d4b9018ac499d1d5b959cd342441e772ae8fbbf85390cafb74aa4c5cf10b3241be5154f766ebfa41a467cdf1677e5dacb240d8079b98a51e37155289bb7ed7bdb897f73fcbbb5ca25199a1849c692c2260f7345d270b0dc34a1719d5934dc924e92d8976859dd8372d9b52d7a25568ad9f0c5d98a2e4441e43164508d74ac4fe3dea3bd06ba0dffd7a6a276321ca26ffa7607c8f9dccbc7d4e8261bea424d84bb054e31213ba29e15579847f57e8fe55fa605eade2d035be7ae8deead915b0dd6f31e5a3518009b872fc55f0875e5d55e5f75939c939bd70e61a30715505efc5de04a40f8be9d026e556e642b91ac5b57d94f1c8e1b60d74d15bc3d645d5e0f7257fa5dad8a427a58470401e317bd6e7c056ec59862600f5459d5a902eed79a365eb510f5f9dbeec9ddd6b1bc2d678009b44bed1ebeca4a4fd1f545477d0fdc039de864e48e945e182d1003f029c559e0549489f2480be96172b0a04555a67b3a483b518c991c9708a3ef13f617b65edefdb9048ebe889844987f2963a6e1b37be4d8596e8884d03be33cc70fc23e2eeedb8c07f57052ca2918424c98ed7d89a0a4eb70f6435a77e8470d14785232410ea68845868dc1c7490c2bdc488ddfad23c3673060ec7be3475dbef7ef602bc2a3e13a9aa8bbd26acbd50bb9b1f9e57592440f252912509a6d4a41b6bc95d2a735542b941ca472fd51775ff89490c7b75cc332e42a57a7e8d976a13afd328f22d982c29d0c395ee429b532de36be14fbc747e99b9847f92151b2e9f9c5c6f149441ecad0db34a6e0d5dc5c3801afe30c2ea01d7738d1cba4268abacee9fecd995c89cd15461299c335d31b9e2aacd383b675956845e46bc36e323cb3c5639841a3b5b96c9f270dd83c3c3e3888c6d4e6eafb0bc4ac896ce6f9bfc2fed0d0d3d060e93b9b5c783eebf0465c8dc7bf89a58517354ac828cb997fabf46a52eff70a05791a9fd6ca6d900d69e4ab24bd22fefb50cb245b8c0cb30f9a6fa5565f7d76abaf2f93376f99f133144e7b1945b1b08bed1a5dc3f96bbad9f45ceede82fcd335086b4f4268fde9b4a576de12f80856319a206e202dfc18ec29bd8ff260ca64686b75ba84b89eda4363f4f5b948852f246167533c29ce2dd4d665f60d00f8ebbe60999e8baedf336ff798a2dfdea3485012aa090649b85f2bb3c465053fc2a42c6875064f061c8ea29dc39f3e451b1c3e6455250a078b2f40df5de2ee823926ee46bf907c1fc542a810a168e5fdf6c1c9125c02fc26d4d72a54d13f6fd1abbccfea8f02bd89c27e4055e122deb1da1065c2ba71564ad4550a38f46ac8f91a3e4943f70d943ecd4cbf7ed61bb42f151a664cb9fca2cbddaa39a701f3e4b1136e40970de8f7bf072906a0bad62ee1694995a5763ba187aefbf4b1cb91df56d903cc30c94c93d04326e9d56c6f3bebb9e2a8ffba42f581b8731489ba4b56598c7097e63d399dc0864d72fecd4573a418169cbdf9f7bc03d1eb4206fdda6c9df334b0c112224435b1e71a04c43e2d5ee25795eadd731d3f0157cf429d1f74c90431285250b8b319dc9cd874516e4f1d34413d22cdebbd35559b358cb4a2dd01342e5c071a677e9aba495c6e91b79732549708fb1e4c560456d63bb5812418bf98b432a6f032285143129bde91cfd6eefc386dd0d07ea71db568e244962a197a830c517e1df6303b766a3b61b2e9143669523e2c4f83078a6ee3a36814a798cf2d4144bd90182fb9eb6b07dffd1be487a46b7d953efc02a909397306ecd829a65f0a1585748e5ba763f7d7bc823e5c153babc3781f0b9caad2602d4b1a7ae6bc67cbde2f5aead6a1b6938bfd37bbacfeaf1d520d96651c2a1aa34fab5529de805edd78a3a5ab4c89ad222de846ea6b0a7230b4f12ba78230fde4c36c6c92600cb579de91acd16d8293e7e0b4a8beec0c74927d5847aae66873c8e01a864ab51dfaf18b46a0e87ed3b2c5892d4346ae8849150b8cddf3ad9604d154fe36db42dd5d557d6b833a89b899f7b21b05ec60596f608632b384c6fa8b1fe5e4e645418ef18c3b6c9a9314683285cfdb9253caef2389b5e45db30c1675f04b9b1be11407e5568e788ea6b75f290128c96f39650b04154a9db3ef4157b1176609dd44c6c887ddff73f99861e5ce6c6279b52ebbf9beb897a4e9ee812967384a08d4c38cc8520c17c0539dc01004faa741c27df7196e2870cffff3321995f138ab414ce9f9977f9a7167001b07072b3bb2dd4b700dc63e998e1bb4d94190b0a410e4133e3a372eb14070c5014cd0694e3d933d3ff721b60f7bccc10e5a59efc983c4197d2cc1f6d8daed6a79134f48b0bca8d7aa3166458faddd597078cc4389819470143ab6424ee79eed956907bc247104766067bb6b729edd63e0153e23b8c6127026ab05fa45dac7f9f3992a33d84601cbe255202b90ac815ff3e399e2c7670a59c65046e4d7c9323131d430d4d252aa55bae8864af35c196b5fd73fa7c1ab2fa639ab5a63da9f7e73172d4bd582cf0984b87da8b65dd392926776d7567c5b8adc620e9196a4cd2e95092021098a95badcfa38d8317cf51a1384772c343f27299d4ebf52d3b5fbca202b90ba0da85720def408453f8ba19c5be5691a732ab8ede0370e7066ef52d8bd7cd3d4f41b55155c517d9ff4742707bc860b4dca6ceeeac3ed8790ef14f5b77bb6a2110b3a71bfe9ed01422b4146c248c846b21ce9f82bcbcb3270a21c1cddbed44b7296e5bc495f1146726eeba002e2c4ed787b95c0b7cb2a7da15b1e4c581e323002115fcbf925b973de73f90265be1f64a2dc2625c5d9a2d1dd1654d0fce2c36e4eea24cb11e346c4a3797e90da80bf990a52114ae3810a5460267b59611cd867fb9efd3022f13a1bf42dc0080f4d3305cbce3e45ad0925e26659b3245fc7bb958efee395981cef6a1c0d03305533f6c94c04fe1d3160fdd9652f279acdf2dfceb0e68c113f0f6ab42423574e74a91ab11a8eb2dd77202ce43447f9dc9fcbfa0ff6646ce668ec1a3f0d8506349e0653fa7b478e544c3f67fef218a5be4eef0a8c5e82ffa59fab412b7d35a2a634c1495373d89836195484bd43855ab027cb1290b7ebe89ed0af6dc6aa0ad9b00af278fd70c5173a0b13297dc138099ac81905debcb83c5c2c19c300fdfedb651b71594b5c1d61e18d7ae8503707505e3fab645ef72d71c9689735481d254850b04d02609ce0115b763e3691762a677d7c5d031a9216542b42dfa0c1f1521de85edbcd744d99f97576c9dc1cf6c01182af6e2824dd070c18be373b64af9359c140dcc2d4195e1a946affc28311d63bafa07097b3d2c19f4da0be4f1b9c672368b4db20ca616ce686ac5a041f262ef7b8cbb7cc407e9c60d40d75cf7700ff52f8cefd07a94f6603d8f78145623c0085f8c7fe940e526bb692c0ce8928eb70da7cda19e0f9a1719c43ef66a787e9417fb0185cdab5e78e325076f8697054c0455deade2e8180d71d13ad2a445cacfa4c1edd04698cacf7659c6bfcebd4204647c7e30f82fa552b954833a29c2afb0cb72981cbf98352cf2d7166077dd54f2e09ced4d282805166444eb497eb3d558697aa8bb65c0a5c9895168475387d11bc48613fea645e1ad4672d2fe9e85f97a755fd113ac54f4c87dd88008e4c6f3fd53d91863fd567cddfa4d4ca881faec781af44ba871293a7fc71d082fa70f60f3d96ff7b1ab935524e18832c115b7a985096ceb5d85b287fbf2dfcd3a8db54adc4679d2fe8651f5c61e6f5a9e607c0769cc1cf337848a7b6147ef444c9f8ca431e635dcf0b80162f5f76d4a0ce27f9bd0b16d40628eb157988d6e21976dad0e16153d13a42b00e8ec307cb1ae98ce25b309d55abc7798c59287fddf75813088809154342453651fbfb73842c5ba03b1a6282c100257a088034dfb4461069f17f7ae3966d98d97e24ffb28486b57b4f694ba3cdc981f220e3ee1c1b7607286a3dcabbb8cdb917ed38632be0f7305bdcc37fccdc98c9cd53292f403acc6737e17b4b168006019d8eaab407401d181a501403cd7d151b53aad8a4d0bfe007825206f8e71282d977edbc5f2ac2d71c46cdf49609f09eabbadc0ad7049bab7476c81160a9095533a106fe8379d02585a46df80a8c489ecee507f6e47de98d03e37650ebebd9b106988c3b21267cefc147f873fc9bec451d43c669e6032baa86e1d9074ba2bdd08a2d34c9a2677c1de23aca87813ecafc8e5ecb81666808e46ed3a93c233a6515f94fa91626fd8fcc9d86a1d7eec99463f04f118319cf6eda73c0ef742a7cda7382919893450d402dda9da6f5466f0bdf79a520f4dac71895d68c19e73b2db0a492fdcde31874f3847223afffd3b77ffc6287e303cac990a3512245a25e40f27444c2ddb4b2f50b25df7ea6a2b13aef20cdf3e030f2e3caf76f5c84e4fca9277c935a94f4961e7e354392216e1c91da4a2c2ff8388d1cf0520f225c7655d9d7b1913366f8066b50e6e0bf7929a8926c1b3c8ea3ad838c60e1447b4e6f8a1ce83cb2cf230e0991d72cc97b8cb390952024947f1d205181459c3134f6f818c749d0b651acc9f9cfa44212127e4a653b98bd6a44669d172efc809d6f347b05a76db2b6706d494f9e00b7a67d460736b074205f61cefd55a4620c1c61d8181f4aae6c10f6b8acfbc353f2555c4beb0f326bf6c2719d6d6bc29a0766538042f0870247fd96219080859e56150a2229c2812de5f47c53781b0810a33b66cc6d0df2c20e7285cbb2c2eff5c1e0d86d8e8d0063c68e53f4e326c0bfda90491c720345b43e36154c67b9aba9cb8e3095b6a3c2d3d7e2f3d133c91ea54f1da16a8c065284b2b3eee7c35515dfe19533578b2292d55d83ba97f7112dbeeed5e811e37db70dc9fa316f9cb6974aca812966df02f9c804a3abd82e30a791b2f222bee7197845e5a5ab4be9b19e3c1e0bc0a968b4f345755669007564b78900a2276d5601bd766904b21819d450f592f5500b43055c248ee9f89b87a3f576339ae51fa9d89967fbe57730cab1a2ad079cd7123630d4ec50ef40cc2b6cb3a584d4633c5c7e1b340db9df7220b8033b0fdfadd80d6da933f713d42d4226ad92f492fee0af4e0c922d775b2ad9b11907d8f62a21022c4d369b3363cef43e8482acca0ef2395788311710aadeda96e441ca565b5175df6838c82725dd8d7bd1944907a8d26dc67ef041694b6b49f0be5e571a17d4ebf33938018949d6f89c6b4c7f2fcdf5bdb5dbebf25b8924ca6f069330a9c04ac3cc954aed863a6c079a4c0a7e31b25902b40712c25ef4c585a6887d7ce47439f3d9e33d29d2f4c3a2e0f0e2add2f514359fe2bc361cd1ae7db0af4281c795e2c9f3a5f7a21d1f08dc0e32b5f1a0d7fb4c13a34d5397b05c0dfc84deea6be987e87d5e12ba8b5b511d9a35423f9f1d416cf9383e021a42b673bd83f4aa104c7c72cdfb02a45a05204824ed12040ba737a3fe11e0099d4d2729b1cd17ce70178052353f5219c114e470ba89010739e5346b37668f09874c663943cf7205f4601c22190bf1346592dede494ea09984e32d30cfe8434932c99979e9a694e4ee3ba7583035382cd958630dd0f1a47599f8c4a0a6e50f7649afe7f84577a69ae885c93fe0c921dcb78f6942073fdf853827f53e3ad702e6d686e5cc83c4f8e196d7896b488b2eaabff4480ecb5044465148ec866598c2eb9b5bdd0af5f60892d1b73247a9e4d188e44ac71d33de995221fbd06d257167992693a5784f89b9968832296fbf862ed48b29a4c7f1ead8f6bc3bc693c0128c70ddd0f96fc19c4c0b80be3fe61bb39d56ca34c4f01b3969a6c9b1cf2de1c0b314bfd74e2b2a6c49f3ca277dd09c8285dfa40c1da14e42d7455064dd331c05bf602766c0496255e6802bf6d55f2441320b79ac3499a91841918f02b55310eaace571286a8525ff89c15169a966593c3ba05d79b71ad4c9bb16abf731023cf1f80d7096bc90e0375cb5bffd221d7306263c5925c832cc27302ae3f69fcec034d23232df550194ebe2f13dc56f0d9080e6777462cc8a6854630ac28cbf95618ec61613d3d8080fe160a858a8cdf030f6e53c346a9642408e6f4d00928d243d2857bccb6d7db1642ad942c3f089bc625b797c982f98e17b2fdc3cab69953a2b5326ec8742e3a9b371c6a787761971dbc3d82d25cedd54f1296fb648607863af3ae4baaabaa3b28ee36be6baa3675b837f6e820b8c6ecbc02647c5410145dc5906c3633ac18ddec8fb3366172b12eb9078f0c4c78ab72006c112bfd790da41ece5a867b5a1d200cd0a1f7411e1c954a286c05bfc0e90f2ba52f5d4b92e9925343ea6713f9fb468e697916ba3e49053b78db194e28ccfa93972e1826936c5af989348e5733d4fda2373c5a925fc86daa2afd973d4cda5d893b74ee9e238c1bfc27236efae31862b882dfda15fa6892fc8a2126e18f96ea21e7c4dcba6fea4d42fa7469d56bd429c5ec9f0eb12fff5b302ccb937de0d296dcaa4371378306ee82fc94bdb467b3e2f33deb159535d914394e6466e5024f7feb2e79810bdcbd60104797aee71682578859e482372dea05362a75dd2cbc96520bf591ee932fd8af19ce6edd2227411ff8bdd19593aa984be9174e7584734338380f7f388c78f53f4521e6db9bc0bb30cde1edae09375c5df56c76b013d57fda8ed594ad459a5f35bed424d35aed65b81b66f28a96a4fe3859e375e821f1b0e2058271c0765086264ddfb547381f1587d2303e8fb13306301941a477b3f74d383e1f7872d78ce1f7e58054c5d10e33deaa062f3b5ae75ad146e4973a53f54d7a1d69f86de28fbb37d895d3381098fb8067b808f85f87c0caa3c03aadbcac259e94013081317dc0b730d954e08daf3f66d607e817fcb5d646d0e52657b9a13c0056fee6cba230abbdd8c187610aa040ffc9c82737719f1214a7550a64ab1459b69feac3411dcbc99e430b09bc1cbd144ca1aba4210e4b7b7dec9c3fec2e45318fcd790788cb485a297f4da469904a0303129c4dde2e14cfae848296aa5616f570d8927cb779b2bc4ffd0ae275ae9e88aa83372e187c0f41544b8051a213edb9872c5bc19456d373d2bffaf4f160d106319f37771241e0a6d2417795e1601965cebd51dca8a2aa0927d496153b3d730150a62fbd8c8bf0e0a1cf8046112be32998038ca4ccb92afe17f46493b623089a4de290b3410799a2d85a6bef06bba4f1a65c716529461973db5d0053069a8c51255bc42d349c8c7d60d8c461ff5c989d64162c46b5601abccdb43788781ab10dcb6de918634aa0043b193b84e5a056d58a994a6d8051a3c0772445ada38e2210d4d4cf9d1f59ac38a1cf3fa80d2e8ae35f771a94ec0a8f2dae19af1d25e1bd7bbd0ac11189ab608ded4c5d5f5d98e76525522010253c605a8c8120662124b844858563bb057a23f5c150c2566f9c2f154d27a69ef9454f5cca4e585bd252eca1e4773e94bc2da3f3a6a8cd43a82282c46a978743ac918421e3b8ddfed18d5df35dbc9bb89624c1863df8e7f0720218a2836e6f1151f96c3a31a948301500bddd27ed9462fdc49c02110d8ec2f4a6ae5e6020a258d4de6dd358053fc2d8ee6383eb0319bb03134e6d33af07da3d36541d1e2267a6b4ec469d123559ea616b67b29e0ae21e8aae78a97465e65b5cfe92c408d21d4697753dec06780ef5131a64be2ae54618d300890dfb1ac185ea3b508a2d5398601af8de41f06b254aefb81e7304410b5f23f44426556f6e23c4282cd8f40fd6ab2d3efb9f939e8d93d0c421e8619842dd3e1ec04561233f6b3e994a9032bc6d5fec10059a54deb340d259840bf097fa553d8fc3b1e30a3a495c83e0bb1e0beab58ace525b87f5b1c2ac304f483bf0240b9fe787442c7d4370c20a39a1ea48df780450958181654f80092b0f0a7c15e5461d55aaeef1d57924867b1217d9e9384bc42d47dcdb33a1cbcc6e494d93e5643cb4f986191d290aed4cfa5900d1e267d80989e3375e682de38cd9c8f97104ff707f2f09a9278d12bfdce17d7b9d90bf78dc9b2f67785da49bbf417610dd1c7fef8f3803e4d4da403c18559f682f331053d321ad7787ef57f5147ff6f","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
