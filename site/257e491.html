<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28f2255c7ffe5f1e1bb2751a066969da2fa62e8d0ed17c6892ab994c175aafcbf2bf968f95bf30428cc95f5cc2748d4e40fae2eda42bf52945c584f5add7edca17280e0c5534880d4f3044d5431fb18370071c23f7fc3ee172276019f0bed5252e7a7ec9ddb3ec775af98f5a6cdee1a0358786af84f731198cd1d883bb64986ac94790c422f3182da256a9e6c5c44bc4f9af3d81e2a3c6a310d0073309f448dbe69aaa9ae2b6218d181f4d56b11241b3658e6e19cf5d0570f2b8a130683841537d659596e5852a9da333adbc4a3ab1be01d9ce7b95da138ad1943959c63b4d3c9da61bc8e60bd93e0e4e15b336603b9d29edf5aa24b2fef72ff2ace11938bb9f4b88ba4c76f974f8de6a56ebf65782bf57ce5b748d0f0d50a5314230efdbfa62ad9c18a0e24bcf361f9389a5dc830745fbed00875400169d1132461049dcec80cd2e75789a4053a9d6afb5d22ad811270b6284139ed2ba9f74ad6b5e0fcb7de81157eabf24ba2d5d0c644b2b42a8b896368041314bcb6afe8ca5ff50c89cce47180d853bc603890ea35fdf8f00b2e42d19aecdc6b65d9442258d3e273ac9e1e04a924bf2e5df326402e6bae76cc43c77464dbbbf2ed27ee59bd166dd696c081a2c184f7cd7739f1aab6aa214f6d71c928c24bfa517c4c6de540a21e6ac3be2fe306b5e0c56c824792eb61c861f3c30dbb6f5b5155e8f3ef6777842c518433f2ecceb3b64bf2853360b8fce088b59d82c14ad13074251db3447ff932734a8ca1f77360168e7dd6d59872773c4b6fcde4b179cb5014f4ac2dbcc7f7875d21ac5972962085a2cbc3a37d23582951a8bc2094212fb49ab1599cd5ada1a22f14ee1e40adf7112e00acb1c1c8cde60eaf0bbb92498a98f99bf76af51e881463ebb9c83448049aa06b20763dc3b19cec07db73cf498be7c61ddf3e7e190bc1959eeb7496b6992afa6b030e6bd15cb01c809571f5c1cfe3ea3b1b0448b12b31d1d9b536e336a798909efca1d2d8e2d46688dcdfc11c8c1b12a11d1144aaf6240810da95f87f56a0b924c6e3ae0771ff8251eb35903615a24c08f26c47d044ac94f80249ba3a54ced86e04c916c36c5ea3567ebd63e49d89f7c8893dcbabfdb8fc822e8a330c1e18a87f98fb471c058809c9605d6003e428e57abed1d07ea3530bdc995ffa85e758d49bea5e8127ca192a44454b114fd195ef1ab8a88668a5419d52bf3d1b133199d8e3496dde98ec2ad83315eda779b24999b45aad913a58e6c3a846d1cf8947e02f8767d3d488e1387df2796c67a5546a0819eae2f29a718fed9afb3a49db2adfac7042bbdd302b3d6e4bba1c75c7beeb35535dcd1da10fe0e5b715e2b6a345765173b0c3ab61b5474c19f60c3733c836ae0e031322043c77d9f67e5a4c23c11e5f8c2051f7317622aa6212341b3390d7574c9f694c56532f795526ae35aafd0ef006b5810c09a947c50decb0db29853475a62b5e794c29b534f85a3c1bbe55bb9d1664f90ed93270c8072d269692c6270f0a5463f93c517d242fd3b962482a874ebbd5fa4b6b905974f92e34eac9ac4a90b9e08d46a43d052c30bf01463f6aa89eaa64e49a214502e25e5b55ad46781db0c6afc79872f7524a1fb1e985a5f0f142ef527b9d0c9f2a2eda1917ed6327df7f7a5b5185a4dba0805cf3d332f2357499b44f20deec4127784078e5d885c501c22eb7aefff245881a700ddb141ab0e5c37db446b87c4e77a0676f4396a7abd0d4e99e99d8c48099f9b34af72193fc9bcf7a5360cd639a60b8494c349f317570c9c9256fd89f596c0ca282b691de60e669dd6f22178a626ee9b7f14cbd8fcbda165883350a568e1716f0d4a3188856a0aa9aca004f0bcd30bc81e7d87a936e3e8f9e4cd79ad31f8028c91c0c350673807b0fa340a4a3fb993e4bbe024638695f1526f5f51e302073ff4b41d036614090a35c0540f8d130599c002d8b88b8e2f227c3ec68244b8f03e2d3c9c2af9373c6f1a5331a21a7f3c93d3d554b15a8b648e47fdb28587acf9f5dec36aa85ea7afae2a4aed607dcb060d5686b6ef35b050198af2f444a3fa80892d1d285a7982e7c2be48cb5a9f2e502febac9705b1e504f54d90b36e165cf3337487c9296a343c1e6e252fae398954eaeabb976dee639418ef1e391ed7e835e248010062caf391ac6e5fdc0b729274ec2db9fbf07f0a6940a3ce2a2aab30b8af5d89e6ad1351fa68ea68fc938a44deac00358c7c6172ad34184ca41d060c618280e2ac40e5d3308747cf7d76b5359226e5fcab304b6e6212ad8f398727c1cd7d2f5a34d1db0896442e6d44d3a12695d4c115ed514fec782642b1f3fbd8df88528000ac81ebf1c47a7869edcd18e3828be43de706b18fa0d6345a82c92d0fcf3a919a41cce406c9092489dd88b157da32bb4ce0c9dda67099c93d45984e57a848207fbf672ceafebbdf5045e6762e4aa1400bdd493a4f2b4800d54fa87f1e3944e2cc4550796aa7729863ddb38476b95587b011bc91e9ab38e764587cf5bf2af68e096c09aac2960dd9183cac7410436a811574174c85d348897bf0e1e274a688d8ac6bdeae0b0f6a14790baf3885ba729116a3528250d097073c681d7d3faa69d456e53c67a86489878a1733c599ad2524280167ab975bb6e22314dfbd4ce9dfcd1a20d8880b98176271de99bb5ee7e722476fc151b4ecabe427b59b1745ed19843b606bf62198736ea9971751892c03b00ca824bfe0cd6e5fd55d9264733c9f72b8dbc950d6971214aa49ce9e3411563f9ff282265ef38e3d378f7385a463de0b0776e3a7c9e2045c6c95e59ca52b15a6f914c6551d8279aba8ee94ce32f90c01daef8e7e3c3350913c8e0b7a38b3e004ad6dc41441a3e12c58dd7849ffbec9ef61c5b7ddbf0d59ee8d6a5d4c3a92394c467cc269d470a51020c3de85442385c78b07d37b7b0b0488e01bcb7f29126848e777f9a0369b56f015d4ec1ff9c5f12b28ccad40468d074a913a3f444fe9d6c471ff02c3c5155ae1ed1a42d8ed4a4027d1286b347e871dc3938542d7f27f49f051be1a6132b03e5199312cf5dff20f954c652effe797d25178728f1da2fc9ac848b632e561f12bbee3e5b6045edb8a23d9bcae9d9d1c14f0e107f62b7094f48e5a710dcb59affa6efccc30b2716d3d428138d750513a5990199ae67a00c864a2a39ebf51f89135fd2b7aa8ba9dcaea3dbce8246fea2c186214a244bd32a8f87c0af0e0dc3221b48f97c7252db768b872c480f25787989a16381a7853527b437dfeeb5947cc71f0c8ef47743361b6338c390938c752260950d51503dda7d630f9093061454188d5b3b2237f23f3063abea20f39bfe96f15bcfb28de2098de4b663aa0f68a3c903e2c11b732aaf422296c5b1ed0b8fe99a0e7dcdee78b01c93f3648f6ea37bfd72e5a0406dc831cadb68c2dea391a01dbaf4da8d7d2497eed9fe37fb2edf7c764cb6a850b3a884f33c2e21989dc9064c01f4dae82e22f0da7cffff28d1b0d487c35499c632542e639414d47e3b88101e20869f62f9f1f6ac4b9e1d7fab0c06a094ca5b30662469ec88a5f6eb3b1120bb1d9086179a898f39766496006b18df71743a27d247fca5460492755cf0eb4a592e6d545b0c434f973467ccd61c74f6a74e5d975c965b4166c7ad038440b2edc5a2079d9a43ba22a3c249ae384acb25c0044c406b8480792c74265fa15afb4affa49b7e69acf30d94506a05e39c02c9eb51638fae8f2d0d3549509c17458ed4287efc60df57c3e1e15782fc6c1cdc792fc088000209d9252700ad811bf825e9066b8552af91959b56bd9252158d176f79273518403edbb12925a21795d808e0bbafaf46fdf5bdb31d619b03102ef18c141f6a3a07f588765f14b17b82967cce8239d1c138bc1c39ad44bd06762c717eaf56faf1f39eeb9d470883afc322b512d4ee4a6fe458ded8c7f93fa058ef7b7a734c7f4db3a08ca9ce635f49b8b666eeada8681febf759a83f6644eddcc2a0827c6150d460f16d16b36e68a9e6327cfbea5747585f4f0fc16a3345d3991426e92309ce1468d3f351025982bdf56cdb3c65ee3146438d1db978a7a8e78909c0c7b277871ef2c708c07a191a2997fa3e1586bb4271aafe6cbc97ea96f640624b370f5455174b2d770d12bc91c82e9cc05b78bab78c73e40ca6e15d1352ac9c3d60f12cdc0d490a9bd2b2434157468f1405e4114ec7a656cf342a2b648eb96694860549ffb5f57b5c20dec93ac3c773b0a57d6e9f312b645554cb55be128396420b32aad7f983e600b69b50d33d9f812a1d2827dd9e656137b99e71f52eed54b74f2ecbb3f511ae78a3f323c4bc9030631ce02bc0651486f8b3cced9bc21031fa2941e4bea3adcba2024ac749e05c4a449f525beb43a47bf8fb4744a0c6127cd8308d3b192f1e7a023da9593eccfa11b95a7d17dff7903efac7fb4e5fa4e1a627fb70bb53a1061979e3477ed7746e5afb3d4dff9b3fc10fcbebaa790bec47b901c9758f62743230c82f0f68cce55610f3cc3074ee3a30748c3c6be79f87424a9599e88a41fba7bb5b703dfbc85907907ea987e8b68cc89dfa3bec6add4d2dc67bcfe05ffa91a685f252d1dc824dd53ee2eb2a7c3ff28dc43e486ffe1d5b626cc9435a4fb6cd25d8527809954cd515277f1b7bd4aa3561843a34f727e61d92adb042b0fc9bd849300696d12e7a4dabf0ed0b10428154a92971162b557df93bde4bb80823f876108254c6b34486aa543f0e34b3d5a7520515ad991f8af5b147e2009b5a909bf812caddbf62e5f59db89e8dbb821f991660abca9ea64b840625087264a61a7fc70deade8c91f5c4b81165b26ba0dc1cc039c91516638edef646ba0618b996df91cf4eeede26eee8d73bf7315016ae07c38c84a44c2d2f8b666b6204eeec3249f0ab4d73e1248d683cecf269639b33283886339ef62b3a3b664d0e05e6f39c75d764890bda3224242a07796554868bf95d3ccb0b117512f48f1cfc30a4098f0f27340d9c7bda66e53e735e006904ededc7d71238bd30d1d68b9c93f34836b6be48e96f0a7bad585d73dbde1fa8916472df30231937b666fca24036404790d3c81546a21a6238efeb91e554c0cc7bcb2fc19ff5aefec1d61b39543abe4a192f3ec0be7dfd9596dd4aa280ec4b8fefdd2d2c6b53f10dae17039bd35d7f3115c0ba028643534e258b55b8b2834b66c533e48a0ec707ad650b5e7015fe4ec42101975fd9f2ac5dc1499a387ba59bd4b7af1c974497629668dd28df847795b5bacd5b84a17144b65a896f752e85a3090050e3ba49c58531ee0cbdb7d0a9d6b3cc5280a90da8705b0c94e32d228757cd30bf2405784abe931d5f0e539c5ef728771aaef87fc45856f74dd3e22bef5c16ddc585011703a783afc90bac2ce3b333e5008887bb748bae229e8ad28a6d10ef07d873cca564aee1f2eef8201cef818aeaaaba5d159299fd9f4e3addda0ca0ae57e67541393cc61993abeb6213bc89627952a68e7522a116e10c2c0c74160960b2d5fa69ed390a48a8eae444401c5265d6c9ee51d150f15157f1db3f4693a00119d69925e61eb243bebae5cfff14af4d750ad67c9aafb33ca412d6d84ec7bac1dc93988998428543cd51e76c70c8accd60c0e76a6f57f5289d69c57091e5d4f8a739f9bd6e0c1b1157b9568a5fed5888317abc337884478a0f8d0a0ea449b8cece69e683d246e9f46e5a8520aecddaa30c44c89ce69ad3ab873e3126c902d6c500546d038bd0e2910cb9af348d5aa5a265fa99fd9b8030b184dd7df28d01ba5bb0096c0777322933ee8cfad1114cd8f7b0da13b7903e1e78d7561d1e8ff3213d20f7e0247b72e1ab53679de3db2b321cbb7453068ab680a7723adc9d8793d4e0328deb74e533afba47222d14b8df2a41329cf59eab6169ce0737697a2b14aeaa102947e317a59d0d0c03a94cc7ebf20e4f3057283bd8d605018f0434cd22a66c56ed3442712fdd57fb63f72605a04793326d9e2201ffb4f6034dee1b8435b61e78fb3522acf35bb0fe7ee286d341162a754f885ca842ca4f7c90ed754f6233845c22dc2cbaedc1e01e15eac10823110d13c0aa67c884ee478afa4a1c6616fb81d26069f86dcccc0307dfb1641e6485f2430df61846c463408323e1404e151b2a0e05b297d12c360281c6d2bbf1d1f3f37e19f7a259d158d5ab812ab2940787916f192e56dce7de20a14418851ec140856cb68c4ddd7c60dee232934fbde0b55a29586da44a72057675301ea254b18e2c3b7d341e833544a97a143b6b1b8f17ad65577c936c4c975084af3d22120cfd735d5f93a8fce24d46227663900af035ddaa01018241ca4e6569beb14ef4f990cc01bcde833a0ac1f97d578e880fddd58c880a3ede551c56e75e5f249b69c9198cdd3d3c46ca2c4f7f0558409a044f6d507d692473ccddedf915b7d487c545782aafd6b5fa0356d35786be0083c7e7d5234538a63db129f4493838e5aa53b00b0f8305a8dc0b92c7655f4e8fbf120d54459ad9e7cb758510f75ea58a088bf6f22eb08d6b2c309eddc1cf12b38f71475a7033fa42a434993bf7bb2c3990e4cfac7421815e20f6710a1bd42a057e82a58801bf14514da0a97029f6b2ce46cd7c4ec0c087b5b1ccc4e82c3a4b1a7fb5636074e2851490704375b62c6473dd020ff2c22f7b4d35d1d177cae51954a685d3911f2de21cd3049884a8ed660e82f55e645a35eacf8c5cc6cd12fb7c6517413b3753c70a46143160b8addce438b926607a8d23d8df812329f5d4b00fe73829bcefdad2e9e5c1e1b258c23e994ddf02ac7404ee0472ceec568b1524b8ffb831a345c20fe1a0f043f480d8aa35da003c695fb5fab689f0ec8f5173e4d1c365ad85dfb9ace0a38db72151f2a9e6edde45045e369ec896149adc6cab9e432dc31d56cde0b534272f634915a961fde5b01dc260ff56a7b62a324385210bf65d4d383f0cafb48796579defeb38b601ff1711659a14369c6ee1b51a84fe6a336eb511e14d6679391ae974990a9050321158f04facda9444e117397c74c8ac7eb0bbd1af3a899299a41f69697824c90ad639597d672f0058608b3b859dd160f6be4edc9a7436c0a79feb87545c6f2622809a16fa030bd47580561e6d0f517c92f53d84d9447781d8428bc102ea0239ea28f9567105576097869c1c044b1a2e51bc91a31eeb89e26665afacda2fbdd13424c832d0d56ceb7be86013998983b93882bd7d3e6ba6c309827f0898a0f91bbe9252d719a6b593e92450e25139102646b9609b81d48c9a747599d529fafebf081ff89465cc508d320dde902e05f9d6042b6a2cec2b260cc7ae1b0b23803f80360354197ac9423c0be41d6423b9f66aef4e0354b6dbd9b10b53d16228febb6f289e7c6022f90e7035015a75704f298707647afcc3a23af4c181b99572f838b7e59b634605b0b42f5bb67b13399bfc13df426c4dc3163120a7952b5294028c3b3068ec31b07418c56c56288bcb0f338ade8fa7733195fd7d6a3dbfc99d15e661cd8f8473fad933080dd04e8c9cb2d035e9850ef5d88a5ff1855c19a6ae5fc9795a94436f4cff06e6677f4ac4031fcb726459d172c6ec0ca770cb7e1a9964ff970acc74b240cf9b12886411df6986845871ea4a656e7f8e9ea7366571c4cbedebc23baa8fbd072eb3024ef00bc8712fba6cc58870e43b216c0b9ffd2e9815badc39c16e6e5a2ed20a185683fcb9134dfa7b4f0014a7ae4e4c46cd4729d8aeab1a3f7232706ee290b09a260d7c9e5d5aca87e9a8635cd9fe500a702c32aa2ac7e3b7d0e19082b3df213c8c94e8ed041bcbd8529c500682488fd62c9fd1ba0b1e82a430875e9c244ce7a81ba17b2e4383474a7eb683a5f376e4f4ad7efaeb4929981a9626020553452eaa3294ba8ecdb7ed695d6d76ff110a67a354fee14cd7c9e71058815005f1895a18443ab4022fca95debdf6c13c258ea97be107d9a1604213795d5fb8e3766673eb88302fb4697236b6b0edaf1a66ed477cba2c162eecd24f29bd9353e7d17a5d852615cf222d019fe570f92e0b273004702cb14399c13f71763c8f164beb2ce9731a95117883b427c257688e36ec0bae6af09140cf229ad648f40c8065ab72fdf274683b0c932e6d172d0ad5f53b81dfddde171483bf874712bdf22559e67091d95a0f751be3bc272ead9340d96775a66afee507ed77568c7ffe668e1b5fc38c01f6da4462446696147af24c6ea694cc716825e66c8893b1594a9fd22ebe1b317a2b95b684c784e653890344c72ae67d2883d08b388c34863ca5ae9b43765d46568916ca8b109cba28fad20d91b01f710c15be383fb4e8668dc9a2ee3b9a9b468810f6cc873faf06b00a432e9d4e59dd82e72c36f8d52513fe9c757c91b8d8b185a45f4b747fd1e0807fd05408703d96a1d712409549229abc090d111d5e7829850ff26b84d38129015a455a17f74d54061a282be79bf65b3fca636970e7c37e35aa9c2accda3c6bf633566107afce6e3d38906210de6da0b8de93f39c6eaaadaf30ab0c8f7256a6c3f1c03247f167fc876abae142b64bd9ceee4a9a7a1642d13a0f94b5742a0af405f981ff68ac815af44230b77aba785739c708fd4c96e96c122044a1b0ef774240228fa1c46312e125eda46de47df3e9f3c7161cc9aaab8f971c40a739c60af20834fcc9ebe5e876f2584243f4321dbd617cef74a4d1e301e94f9214150bb3939eef58c818a9a805744b4d1cca2b6f540b92e2443725f9c53a31ef776fcbfa7f9dacbfda48ebdbf4d61b2d448b6ac68c01fd15ef7f5ce4afc39ff7c42cdc0b32a124061f39558b89ba0465fbdd614c34216a6fe8b5d7dcdabaa35373978be3b6724182804bb3a9ab88c8b6afcfb9885d66a38335ef5c555d02470314427d0e2fc934c926af9936d922a835cf9b530b40c064e81b6788824cff5f34e1e203dbc680f236ae7a76f7366f876f6304ec6c1143e9194d93bc6c23a8102034c28c32cdafdd71b400afaed03662e218cda9cf334018286be4559ce4e3496cb31d36be4015aff89e242a519b8ade91b3d79a622e8409d5761b8ad3e6d214838d3c78e43a7a6e823eec6666bb136d3cb9d2d1ed9a98ed96b54276e64dcce09306d6bd01cf94073b0ec57e5eaaebea0142fe996d3d41b49b3521c3097592566e75415ea3fd8158cefe732fab9fe3d0d74d7927710af66a9d6cc7852472d6c32124221cd386936951a20e7a69ffe51bf60c8c538a675506c8ac953042c25ef1cc32fb47e5f0dd7135afa5e93b8dc0611403ce7208741c7a5d8867a1424aa757624b7262deb2b7e16ffc6fd87de0331f523f43a60e0911429b4f8ad2a80cff57e77e43ae684430921d128003913757eb0bc621e4e824d97d1ad6c3aea95d44fbbc7c6217316ec7d9cf52c83be74bd0e6c4421a3bee30a07e4b62fe50ceb54f7e6fd0690ecad17cab3b7a9dc7c2556d5269a21dda533d1a3e94c739489976567362144b064c220fbbe9842dc5be59095f0f275ad750bce707333eef7cf529a39a3463ca7c82c161db4e6cb8b31c78a0e4f85eb50022f9a492e2e9d849b66ba89a2465a4634704fd6c6764775f4aa687b0197adf45521cb723d4022660e585e54105a100036dfed5793e05ce20fb91b7dec513c80c895d967b939cafe96d9241a0c7c1e2cb2cd5138e27be6fd5b870823ac437acd6d19f04b05e2063dfde66383ff3c631f239e11fd102f3bb2e800ff75d518a0eadf33fe2b1583a6ba9b7beb6abfe0a644b5c534b3bea97105b248fe3de3885c420b68010cacd3e7aa8308aa975964b7205254510a8a4fd866bd447a0848ea2a6a7c2998eb622767a4b352b4f66db93d36c763b8a7b4a18ef2625185f4b5446c1b8c24548595fa5704763384a0b61a38352893186e115b3e1eddb92d568b9b38c13495d0870cedfaed16a363029ef03f70f8eb00ed9e48ba6b6b60049a7bfa8e89f9c3ebe48460df708604b9411cd43ae2cbf1510d467f33536c9e117e7173304800afe47a1833535563b0df6fa454f26663eb353414286f9755fd6d5c776d81f7e6dbf33be3a758f8b0b4bbb9eb7cc8837d1b787be379b8b83e0438d2d21322b081172582619d700e890ce4b3559bb2855776edeb05cd1e763b376282a605e53c02ae9d5748c1539619ebe81e6e64343b2eabffa1e4160ac110538318488599e279a373fd1d5b9247711658f7bd5e7501bd1801f0f8acbf3edd56b2ae91d2f65cf6e34b9b7354018ec77eb97b6ba2c55fced3c90932783d0367f1d4021bef9492296bd9682665dff8caa0b1d98cf883a88b39f76042dd4ac8603ed487cc168c5d5d1d5d25c29384de9816a1a1ca0a76881fd4805e653a19cf4b3ed62be502a626ad80a5ddcfdbb1b4e08681e227aeb532f9b07d2ffe565aa5b85bd2c8a33a5437ff487eed76c71ae490b9140e86f36ddb4c36da899efc59ecbb8032ec91868e2eb92e6f76d5cbfa31f6d0bdabdd2b3bbf89c9b0af9e71dbfa21452e946707889c8c3225b61a27f99a06b08a4779c58633eeaab744c0cc9d6bc5b0b939011280c42eabc8682700f128d36d3f045e9adde63a1c69baeffa3bf156f053cf2dce53f2024b8dc1531bed7bff793b57dd571f71a38b9329b3450cfd5c05451d447e39ee280c2d49fcf32ce034b725481644fa3ccad150958334766bfd71cac752c1d83ab01b3a2576cddc69748b06e1173233667ce721a1a4ede85e75d3d9d29bd9884075c38e26fd00375ed02bda1e18d10a11d8959acbb77bfd33eab709a71c5c9b2bc2e434c463c9a565997881891d91d587995b7e7412c2d2bfbf9ae087535cc53b64c07ec529b14176","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
