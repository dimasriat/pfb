<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5438154f7e6a3b881ee9c33e264cfce1a1cd8e18f5895202fa96de5c9a39b7691282df415ac91c33f0fdd8cf53d225ef0551dc27f7fe226ea831375acf650c7ce03ee3ca159e4c2cd95851e4d4f2648a10469e5d0ca8bd420d26584f0bb4e2f2fd4094db1820c871948a2e33fc800f9cd202e6706260e50127636d423700323c368d79075f08d6c5bb07bc8f53c5fdf87ee94afbb4b68863441a1bb5f4db0688db95b18396b71c379ce00ebd7e788cc67fa62b172b71037dd738829187cbb5e99a800e3a3366289a2d3a143237c7d88fc27b7954ca209d9a05786bd3f1d75bc39370fed64c6ad374b81310bf538428989e1ccf1f355bd83352092b24e92617cf183948fb12d191c50e8fc8a7c82afd8359d9b7d53350a1f3c76b2fca407ef0f6bdaa365587b91b2f5a438a150e5a144489a10e47a1f5a1ea1d5f3b742d7a415247851eaa49731356dc83babcc6724eb6e74f508569e114c82ac2407bc23ac1d5a0844aa32089c002c9b84ca3dcad72679f99f2ff37d6a6b36eadc732465437bbdda106fa8d71cded174998f417ca6ba67915265b657c222de9b0e6086d3b11c3e2f7fa79a2d080b863c48c5c0443d63f1f42305702ce82cd98208d7fed04989c34aa5192e063f62ca4440b5bfa66552ee764d8f870fb1b47aadb44c5112a125e3d7e71b97009b96a8831531f4507b9329b3a2daced9b359853a88dfbe65f6f8a96f69b0796fa78f8fe664ae256e22288a5df53c1bbde1a45242b5bac7c994dbe2835478075ac4a47946935035029f7935e7023dcc075487f245da5faadacbb413231b0c2a98311ad65004a5422c82e6e096d0b4a0a1ea808dfb17f5b25a36a0040fd526a785df20d4bb5d879351a9a1b18149b4c1c0fae2a077702186147808904ddd9d5a657ddf94f3141be224bb3e1686f6ff71101af7c126b402f2b5d6d82dd8eaada7c0c97b69b67d0fc8ee89045b30442306163319211e51f5f4c4db1207ff73bcbaa52331b096fce1d84b827dc97b02879a8933c9c9dc9d0299bce76a3ca1c08e49a6a0158b2ce2a7d9ebe87465ffb61666bc9eda1e30dbefdc5b424410b9a055c036d23391705a699f60c2198820f6f92e960556d0f7a34463fbd7cf6a4107a995bf34f2a3290bcbafab7705b521b7e21f5dd581127d53fc9bc71199b3303641e06b8674fcaec4623e0e3be7a622b2d2e59e2af9f92c1c1da0a36ecf52dfb457ccc20b4d0878344aea84defe63add2bf9864f52f9f623b2412ca9beb1700d314c13a042b746bde2418de558d06a58869c53dd09a53e5037bb71dcb814f12391ab56e4a457b0c9dae840c55fb047111b48303c2f885b58a2668290767c37ca1bf356f96cc3402e1c87f1d65cb16a8a2902d40ab331957a4476a184b04ce54c47443bd73f7c4df3dfacdeaf35a865c91b43fed4c3f3341208d51df31e71f70d2afb95e0cbc339547424620817999807eaccb91e63b9d9b1c3e3dc6c405b915a80d2972400be2e523ce8ceb38dc2b2c7a92d546a7b14eec1fd25e631a1b1a8e364ad389c99ed6f6b4d3b1a45324b7e1a00f29ad50e4491b5b3cca56b754c9756e9f7d5f96a857989aa933fd9cf3132880aeb76a902cec66c94470d478f843b3626f86b41208499d2a11f00af0235fb110105b2e4b698cb8123181b93d2f8af7610a0c38c4a52ab882960e72d528c31ea7ecfaed713398a2c53e3e31915150fecbb5142f0afb16fc76bf4058e60b0ae49c31f5c64c662072027d9398ca89d3f96913fbea503e9081fc12112018c6efadc0151af62c1831f24638426451cfbbef0d3191a9458b26cc778a141e12be75c1df3282941af0c396a6e53d3e30be704a4c40f586b0bbe44873d7de356eb45c0c334c9b3b5e5282fd6541504a0a094e6593c707e1ace83b4bef5457b93504be5da5547a7a82d227067754d8b52a3d41fb9680fd78db8c1ae06db00ed55e84f245c05f52470f6c12fcb120f1ef0b6491b8fc9972335c2bb43d6b1736427d4959afa77b31a70de886a0a14153f3b246ec0d01e16f41607a2bfbc358c6d235fbad522fb1ee3151da30f834a482a85f0d2e58a25baaa9115102b1a77dde900aafb14cab18551b3a2efa12ddfd75631c8a7273bf62f39158fcca82e05a23d6a8957dce4c8a20c74e202502b1d38ba2423fb98e5b6b3245f9fcdc05cb5934af170b286ba94f33a149bbc5de2c37a7f078c9f9c217ea179af13e65a3ff46460d36b32568038a09779d9b4c08dcf1c4d77556a95579688dd5412f63596fc39e4d47946e421846be9f84d9c80f29054e016ecf5f3a3c7013baa6c32778e069016f4a717d3ec25c81eebc12e48b0fb8f2f3c02790f7506b89e0cf6eef6edf468d095d8c888f3ac45270be4c29ba8d431993a7b6bd0f40fc33352c3b99f82b0becb7084397b4f2e0f3c784098a244530bd91f9a6b03704da0fb044e2ad072a628ee8e20f73d86de27f02a0063f15d74728a0293630f693170fd1348926f0751a99a6475a26e6f7366a176c84cfe6bfadc7cdb7364bb09466ace4bdb8fa40b70fa0a039765c3af8c2f08b88507bc038d42742d3e59ba631fe8343758acae960119ea885117cecbdbc1f9e4a8e06eefcef66979166b456b6cd81a5ea2f09bfeaafb86fc47a256afa7de1aa630b131edcf276aacddf6257e62eddb01e2ee04c13975c34f8d0c45fe1a492da6b02e8967d6acfe4b3372baf4c60f53e3f1f42ea833a715977858698c2181108495693e8c45b360fb1967bbbb90dd8e05f48a30b4d2e964728c59ebc5576133859c5cd7a88b536ca6de56d4c7e786c02729f46f35f6d1bef27ffbb4f5f86a8cf757ca5f34c8985d5be0aec7506f0746fe1d73b50c99436d623ffa6a0face0f77f2e917606be0c320b3c425aa3bfc360e14108179f0c2a1aab1da1b17814b2c69b425d4efa62bf111da41349d17b17af1f14f7ddf658438d86b95fad0055de7b9d2e50179ad28f4ce33e6c4964a14044ff997fc5aa78e11450388527dcaafa6d62ec5135d772fe26ceb2ac958151f254333c80f6d3953923bfd83f9727c8d762527f82531ee49b65465b80e931922617b98836dcf0dbac9263ce5638775348eeadb07b57b010b982a855a050ab718ccf7336724990d43cab05f49d96932c0620ddece441b832a70976661bda8edacbd8ef99dae3359ee2c8f9a0c81f31169c02c30a1f562ac5dd354c21a7ef8954c82633bb0c2e5d2395fcb95a661a5c1ba4b758b43a9df14211f5cb918a815a6d962492b05c443031ee074d9d7ca91ae24a78885db3d9ce13d943be90a26e007ef610686ea202b699bd6cf7aedb0b95ec526d9d109870dd85877c9e81640a0c535b6d9e680a3b82988197ab360d461dec4b6bdf95fc2ba18dcee5adc015ad66b9971d3e9a26531db6a2109eb6605d3a571eac0f23bb8b171bbe24464d45ec758093fcd01a783e4636a898f300ec4666e2df6e909def6ff667593284995e2c4850762e663a163a2fe19230ecb120a4fd03bee211a3b727df96abfc7aae3a0d3a4f35db8557f30832a30d04c4f70ed261abebc98ddf98115bb40bc17573694922ec2719dee778b0a55bfb9f0db234fa3a22ac8b930ab0dae61c0fcba46ad920217aabb9aaf37d95955f63f1a332ccc21f984183c6e9c234231e3df51de55c43270a4f2a71e2f9de5f64bd5998154cac9b44c55fb0cf6fdab4b596ef8da030d03d3dba8e5f891141dd3e50f4164ba2edac9e969f49b9664393788c7dfc19d6c8fdb1b24ee74d1a2cb0716eefb88421a321d0c018a56b6444c1939cd05a256ae8092bb0e98a5dff6b4e109b225674df01fc4a95d8f7e663d8f46ccb5801f1bbe30edcc209977c5c34e4655b664229c5a55ea94c1732a50b482900d6e44d41a696f54d810353a28c73e2e04e46fd75873a2c15c1823bc14f8e9900f7f3116637e41f9b2be5aef2d04da428bf399d3455faaf8abd8341e4cc94dc1b3e1f580d678b732e4818c7ae436fe17df71688a9ffacb39b0a6ecdbb0c6e37306d125b8df791f64787f8d8dc38b48e202e21a8ea0ed5a04e291c5b3d93bcdb9ff772b746ae4541ff2965e73f6462aa772007ee3b4e76003eb0c66ef0f9889f3bcdd635a963c93dcca3736c2311ed27493029b34833aabaf4be74c120be1cbc9b49089f33da95c6d75c13e5c00313e317f15cfe8cd1ad8a9900bf4efa19f358ceec940397ae7f845873a800ed63d89718fb5312d496f30ea9f19ef927dd63d3c1063d5ae6812eb26a9463d9bf0c0f58da05cfcfe41911bed3b72d3485e814b7b44ce15eda042f1429b70f539f48150513066e9aeece733fe4b1829ffeaa4b1daf5c42e70b1d6f3ad706710f7854014e3bd7aa76467e7881fd702ce4dd412437024fdfb117a68aa32d71cb0ad62bcf7051850b16e6dfbbd4d639635bc79864e0ad516e7c4aef66a086d773a1d10d4d159ab536b48c8d1de6cec384487278c7571079ccba99913e76e055a2127b365f086aeb4da4b55b7c298080aa5fd92557d1bbe4a7c0ee974c8956c7a8c99447861daf302f2e6c0c27da1e9876b4b1f7ddaf69bbe7e779635f0f459480dc2b3c0ef179db0d4424272c7c84a2a58f1bcfed9c35b5861223e85ed513b413365f10f9a39e209b2668a5aca6520f6e3cce6ce74f3d9bfb1450063f9d37a3e03e0b1845713df78f2b975f62845694d4dcf28db2641edb272f1e211aa879d6b34f5876e80fff7f38643655e48e2b60a308250afaf252e1017c653c4d361ecab5c3d608d5a78e518c8247469b71c67fe9719a2c4ebdd62412df0c6e73c7c46c6fcfbd33559a1037f02e4c215d31c86069cf4cce921c4e2301fd97e59cac7fbc04ba5ad68daf6d1e69b34dea4fc75f7726b017e4bd0b4bd6f0edfec0a963c58d53aa1b6ad2c7a03b8130e0c73e49278020ff7101dbb8ab8eaa045b0a35b3a5aca01e19b29f8e8d3317dc42b441187f285043d616e9710c54a733f937e25c05cc13a848effdb6104600ae556586b0f72c2ba1eb62821835a24ce9267a640da19ef3ff93eeb53d86070938e93fba76b9e99c68326a9cd2d3916889c638abbeba1e0d94d9bb0e38f18a61c9bc78e5a2839aba670b32fa0758e88af836b718edd04e9d763cf8f1d4c3d10bbf7ec4a17cd14ce4f6addd5ac8e86a78fc8721c41fafd97fd83506cc234be073251d1a8998e7cb991c2b509a5c4c893a286bfc748a48be1f5d19b9ff033d0881ea5560492d162ea3486a3c2cb70ccce2dd7a25f960d6af5fbdf3938442015a22ee0834e6dcb1ddd250c3f41d5fc1491af1f72219afbacd10090c9b48b12e5112e6ea3c13251a794120254e9576dfcf40cbff31e90e0ad26c17b4dedc3cef9bada6f98c00fa2ac150663b45191ad023cc7292679facdd5c9b77066466f3f9f50f6ca2b04fa75c60551fe145806ba353c666c57e12c9024b800bc2c947ec3c8927807031cce455894d47622641ccae3360ada8c269b7a5ccb2f20b1738bd6251964cb0f36c9c968a1f8c9dc8a5e3a9daa7e7f887039019dfa5fac5ef360c4fde8ec2643d3b484846d88d7a747c76618f644515a52ee5382840df686a416dff8c7608b8dc72982dd2c06b8d0bf556fac729619a102bab45214fcbdece9141e3f30541d238d6cceba897720b47a021c742c8d5ec6c73730d7c6a6a3b994553879b57d1970f3c6c5c1b78f72674443dbdfb8fea45f29b1e14c00e150a7e6a259e54a3b4457a2df1f7f9b1b022282c00e63d81e0f383190ddeb107e464fa660ffdc136ce8a80edaca5d5fcff3cf4e0cb565a4e4a19f722ed7c2038830b924e5c23465f7a299c52387c6e171b1bb2e36e78d21207a2b4be702aff8e21805344538ae81953e7cf4be672a4087af757301b01da590d44ec4031d766039f2e872d5c1cae7d66b3a7b129246eeccc4b717392d1ccca5bb2c8276e5d41406a01b1c70ff440ddd2ea90e2bf1c52227c2add9a5bc3dd9e8b36b0b4e0d506c6be4a6a90fd1b06073d51b3a332483fa17348ab7e6ddff7719efc902d9d6947b63761c282078c7acf2a84f7ea2670f9cb05815db22b3049033d972416d0ce6b08ff60f50fb89bd552000d6ca144686a7d0d90b5789dce355a807a9a55e3f58789154199c406d33af288b2b95031406d4f72524a837573e5858eb4e843de8c02ca8bfcef7fe960ede8cc881206a0fe78535b3b30044b863e68584f2197c15d7d24ca24ff395c2653f27edff95a301354e84b8a314ffbb8d4a2c3b0d96018568a3b258e0ac144f59936a4e2884b8e8105e53fa5918de1e24f64beec4edd5a99a1df215253382bfc15cf59bce3f8da64cf23d6a4fc4517637d2283c25419aa716c91f4af61505707c44d546c2bf210750f3435451ae0e6cec1df0f0a19b40b38820cd8ac61319bf4f85c25ff79c4800442a9c80f3cc8a9dead41749a044b15a346676c4e0fbc144ca64182c3ae7de698ab1e57aeaed0b112efb89a15c73e641584df922dc15cb6685db059daa6e80850033fbe5f7f8d0a43c4a18ec1fbda3174b8d3a6d40a0e8231379ea10af7b706f51cb017f2dd9de54abdc35f866a15504a557c0d94477d7324ac2d92bf52b733b151f1b7879d6f369673f06f6f82ba06bc6e771f1af5993628d8abe14682ebfcb30fea255c8c100d234656fa623b6963531fff7da153a74dcd0c67f7dadce45833c9caf20bb3604749c9eafb0bdc3317318f2f9b705f75ffff68089b6b8122f37d62697cd75adf61b304f2463ab5b78afdbc0c5d0452f3fa13155af247c7d865de49ee7c75996a44902d659d85ed711227988bdd72be41955381900273c0531042851f79e2023edd370880d38d8b83e00c3811a683ba313cbe43fd56d7fe03db14b81cd21b6b55b77f4aa1af65b09f33663cda74e1f4bccf3943fd6164643887e2f5ccc22475f5d7358e7d76a828b33c9cd6f41c73daf55be1294c6276c154d6ed70df32f21dd4ff7842ca1754fbcb6d59680d80ffbfa4ede014a81e7d8fcdcd4410a76b6e269400ed1232110d2afc4e41fa263162d6078832d21b3aff66f7a2d4ca04486a3044bb0db615e77b9cbf040ea7442f14d396c91f755af6121b927e9944fd6aaa666b838f1ef864d5ddd1f22a15bf9527dba53eca06379b3f5323b46ffc7efa9b4f799507d1b493668db940215cde951e469f0356be9912163f94e29476eb1809e2b15bc4ec1418e3237753d9361c99df457caf946b5f448d1c29e5ca4a19970646cec2630c2f93cae9d35bebc1227f7fba14a1f0e9ee8c758625cdfe0707af77c116921ea7a8c8826cacc15d5c5ca231011f7a192d4ac5999dbb7caa4dae512731b879fb33ed3ed6f2fffe3fae77a1556130464e71a92ef84eb8cc4976563dd40eb0214e6da0710f532636696d0036d9e1c217828365536638cc941ad1203a103c999f4a0df76fd4b444aa7394a451cd580c24efbbdb8338b1f37111ed2a6bbf1dbe0d7c7b2d48a3bec7468631f4f093a2ab0ec661cf4f66ddc009d138bd2db0f5761911dcaef5b829e32871519af73652efd879fa4defaeb023badeb89914d9b70b3efdf8048ca95e6fe7b2b9b56f7810339cc6775501726639a97ac3991acc8711bc8fc37a1bfd5ee2b0b467f6ba60ebaeccd38a0b84fb02709057e3daa7b736d5a5f3101f1a5b91582fe332a316e41472c1613adeba180ee5a6b9583f0df623a298849248ea52b17a176815878e0b62f9b73f58083ba2d69d2cd8d0f3b6577566a20235bf36bc678912c38b620160d8b4951c9356d790dc9343afdd2b0935e8928759eebd2858fbd067f071ecda7c174d4725b3ac24afe306e65c022af01597710f71abe89774559d7c0f77065c4b88ebed0f7a5eee8e029d2ca5df5669c9fc6bc0c5c46a95c9c8c2f0d3e458e2a2fd3939ac4cb825c9c9f9b8c04b3354eca1f5e564b21b33dc991b4a6ca20ae1b68d5534a6d0d695b60edfb8e02cabb7cc81ff4b2e4ac50405534a7ce11799dade7307767975bb5084f8b2a3e60e30cf85b60f0140fc749bee7cc4febae5d7806b6ef87f185597141ddbd8f11efac661b8fa90841985ef07efd716b2aeaa25acd5a1ba249882787ff908f62f237ae8e807a3622d97afa6dda839eb511c5057014b28f9077922853dae416eb329ab39bb0ceabb476badc8503cfa8add101854aef793b99bb934e3a7b3de9c00bdc7307f321740bb2f2079da52190956426ea041092861942c43c2254a47fe58edc420274ce59f8073c6443030d68e68e508e742c89de82bfc090593b4073294b533dc651645aa4bc08617e8788b99daca53c605c0ba96ed7d0bd8982e9e6e1125b1ca199bbca29961c44494abf9ddf15afe528c7123ddb1ccd0cbce5ccb077f6bdf51e21f0052461811ee3391a05880b0225e3ae27e847fc3390033adf84c4f4f637e7aa9ae6d5d485f25a21b452d0989b3a6d93e758c69929e1020efbc4a24cb714147c2cb221ba8a797d28d48ecb89e2683f3767efe954f0caab431b37d798df86bbba04f86296f4d4765ce1ffa0ae505a542eb66458e2e50e063d0bbece8eb7c9ef5aab78821ce75ccb062b74cc0ad2ff92d91c07f3e1b9d93f1350acf2abfc4d7cf4327068f9ede9884e5ab4467d87b5a7bd4592fd88866ca1deff96760db8e5ecab3a4c88f0d5308a901e3ab353d9448b1c7ff874d86a4204ac0295ead0cf282b0f06fb02b559cd96266aac1be8e5ffb52ee26c6a764e8c3480737ab8dba0c2dc8490fccdb6b31895149b34c161bc92c912b2a5c8f6494ee1f248b1d233e2631a9afa5d25db5145f1033a9af19c1e2a0952532632cd49771bfc98bde8f760d804befac4389bccfd683aef322584361efec1cfa4b6c52d8616d317dca6539baef25513f3e9c5eee735076c33f6274e4803ef1cd48a86cace6a8f2e577a1aedc37c8572a4b5b85f0113d17ed09b088b1ac9abbb260e0cb3a29db30613fe307c0773b70404e4002f404bbb1e5e8c9ec9123fb3dc8e61f323e7600d8dc0ef24726af7c4820a521fbe7e3ad250e71c697786ee3aab0f094318394fd4eec0526a9e0cf3c49c23e0f56a977c7fbb1a2f49108426675a3e9d6d80b37106c18e3948bc6dc319996f07d8e79bfb4b20fd3d0664ccbc8435bc4aa57c56e02ccd6d7c800910e8a53e08088e41f2db70f705621a559a18cf9c7532120227c4b83d39f3d8f994f0eefbb9c83191f80b0c51ca436aacf7bd320088242ebe2aa65581f7774199f6142445aa58e7edf0d59d439070ac7f2d29daf8bebe1b2b5448debbe02a36fe7f784372aca7d21673ddd0cf045e5284b5a2b3ead9db37743dc20569b012c9b83a791f9de5d8fc4f7cccaa8ba1167e61fdb30813984cbf900056773c3cc550f15d42d65612804ce5dc4a5d59ba5e8040302a3ebf7207fdf26b17d8f0b28b5c744e8b181576e66e06985e562db749e2227863242d9a7238039302d657f2614346875e21fd09a321ded9ad5b14fce8b929001d911327ecdd5e20f4747eecd93c59a9eff95ae2b2bc62168f445553144119253624e4a90582dba1290db5a629daed5fb0d3813970077ebd1b60a62bfd6423888708df9de72e86ceb7a62efb202f903c40619ef515a2f26010cbd08803eeba6f048251d7da3c2044dccd599bc35037d772c9614bab9d291c4edaa8dadc3fdd94f21cba0515cef520fdea504de9f39fc03ccf86644c36923ba2c9cff047202c78e9b4212b578908ed4c4b37a3acb402ce3ffe04c14b0550ade84c69d3413736d4c7ee319543c438751827f4a3da13890753f77ff42967f01ab803b1fbf1ece03e61dbbe01cbfbb5ce1122e0cfab6343895314c96e835d70d6be8cd8fe0b0578c8fcee6427279db0ccdcfcd64ee042dfa83e666dd7e88a6e2f27c8cf775adef3822f7aade9694d6974c41acbd9e10e462e02694a679aa6f72704616fd9f7a329c8bedb8e8e62f1bed0d6a8d0b9affecf50788c19c9335865acb7aa919153494898d2a48a6e2cf40f20f162d724625302084050f9c48516f33ecf4a609077aa2efd14e9602690597130457f91d3ac15c90e0e7041074b0df7cdbf7f9a006a6c57bca098b8819aa07a5c857b33bfc0cb94b17404c430c9a2788b7a77783f2b6e2509ff90711ba44be82259595927914865c99dac489aaec08546249fa01acee84f1ccc026911ffca9300ae124308ed4461cb33d465fbf62df5161c0b84e83239a5227ee7a2c683d3de9de432015057b2d02cc7991e199a8911a15dadd24f45dca9db3c3e869b88ccb7cdc22d12c82bf5d8a12af58005bcb713d952d4a685f2cbd7da7f8f89e165016a2431c22980f44e7a0766ae4cdc574ed66db46ca3baa59291e5b722e9611dd5d9af27dc215b126c65fdc64e48f33992ee902d6bb687c346d30d1d22b770f33aa751c6a8f6507c44b2680df1d93b61f1f135598b424e653f54126e86ab408652de280d519ec724b04ad86d22cd1cf7b33f179808df390a25af2ade1a97b76cbe0decd785d3ec0e5d1eed9eae774c4175e5a4cd82436194c2a696cc6c7ff81097e1e982f79c3cbc745f1349403b37fce2547994bdadf02e9ffd1cd79ca9ac8a856708cd28034b5aae03e84d7eeac80e853317d236eaf29883b4110a370788394bb2dbf75cca102f5e0c906bcbcda1e8cd72617852f4d304ba6ee1f5b470a179fa55aa607fd4c9d601cb570ad88d2e2f975887d02541bf494d1f9b79416af1330485248f29816b87bffbda73004b491f4e7fbc72a16a77874fa04375b359bd876e7230b5a1e503fd960b068d173075722c36d1db101f4d9eccf6036bcfb5745926a9d2df5a2d4f46ec88fa533f0a02cb2c4496e489ea1e74b2566e786dd584f7d519fe44e9c812b00108115b6e5c017ec0afd5ef5289d63315000cf8757c27d8b28a01a6fa7b506a5b7c49b0de4e971877ecb685f6afa1bba4bf3d75d13e141bde304dd267077132974e5d518312a9a70a03948b17b4fd1ab4c445e77ba7e3d711d3496fc72aa3b3a2a180e6fbdc078569ea9e38bbc8ce8a25cd379e577e6ad3bdc13d1a5db3e18f0098bc9c2ef7f7dba8316512deee77d34685de153e1517c07e4e6da4791d1c4d233474725842bf548d0602072ac6930a3de2939aed1b99e5ba71e358fa0eed822bca962c4b0136f7997db3b1e0273d923954b6480b5af491b673209502b8c48bd47ebe7f266a6118bcd7c935c478f13de7e7ff1d93cf995044ec02a567290eebcc31b1a67af335fcf068e977103405d0d2d9148982c77565fe37e04aaebf5693c310e1aec4fcf4e8a19bd4a0ec4a22d96a0329179c6b2a01ffe6807b5d4722822729caeba67e4909ee0d5ad79e94d111767a0dbdb4ae0b4d51ddaa973ddde43f0d221dfce4f2ed4068155860ffbeb083ceb26efdffaeac6259c5c37c67b0d20c6fc17d7eaa01d454814ce985b06b5909d847dfa55eb0ef9e96ad31ddd5240a5fcd184d9e5b35059c3bc4d1e4411249c14c2a2b5f555e2e72873a84f77298f","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
