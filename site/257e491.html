<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa8f9c7862256c1971b8d3ad3234a230985c1ef3235e563bb216e3e6d6736186ea13c2d1c990124f300db4c0a3e179a81f4c4fafd6383f85b438fb41de6c43e645036903e4cc832ebf56b75dd2bd289b600f37e202f3c85506a87eb05cfbfb9aa149bcab052e05fe7c98a6e92767b891da705ca5ebed141e4fb937717d7be899bd18fbbf25a54e04fc354dbbcd7916a0878628d2b611bf38e3ac951a5d749d164a4a52ccff8b6db080b1bd626b3523a2e45d6c6afe6b0b00da62e4fc9a1ccf751dd2bcfc96b2a82e91acf2efb639a65c5bb012413707cfeed27542c534a3c9e62eeac572db06751f614267e9587e5c7cf91e8715daf22bad4f20844c9297889c8f3bf7c0ff50cf3a9c31ae142d4d4a41d1a8ba4a2cdbd77ed8102fa9eea03d3050b46948a417b4dd8fc4cac26da5d51e184d20a530e9208aad0667451ad7e9201eb5e1ac8821c78ab6f082273b4124ae0d4009c62b212881d9392531cacf91a1d05124c9c05467aacfd29313ba0dc257e9408be96ffed9a2b0901db22957405db6d4fba16828d3aec4fea719141095044fa8a3612aee0789419cca2d41c1cb035ebfdcbe0a9811921f5afcc0d7253ac2dbe5069513a75ea462e4ec6a20c39a72ab50dca873e62525391a78fd31d4cffb3b173e198e921ee4f472cbeb5d96685aab46f3ce3efcb59ace1300eec110fba845089749fe7d5d90c995bb412d221c1f1804f1476c42679652911ee22cbcab3d21c541ba8f75a2dc568d146eeddcb6b60074e3963aa7bd10882bc4d438c5a1dc6fde6900c6e45ce741cd7e3099ebe202d21416ca48e3f30e475ce6ed2c432a5284630613b554792feb9579eda3578f0a3a8c8feaa08063ade787c380fc23144b30c67104c0946400f4d79adc6411aa97be08d5732dcf757659e416a42d33bd53d0d99293dbc915250beaf09ef19dee7c1e27434ac320bb6ac9d64fefb1d28dd0f2d0977cb564954a667acd5f5af3d1cb21735702de97c76fbf0108de1333b0c8dd4a89d2762e5ac8e762d2124cc9482dfc51cfc3a8e274d25afafa99292e2d9c7e2c1dc4235c4b188d36d141cb0b5070fe6a42f734abf8188106a660bc4bb6591c9497c380f1235aa5f404acbccc94df840e542f35c094041d209a96b3a195ce025e6c0f38e7448976890444ba3ff1ca528779b051ae63f92322c731f85d319ac2f1af9c5ec0d6960c405307455d91ab5ccb58e5ecd694fa262ec66d8074811518f959f28bb9cc51c70cf720835c73cd7f6f77b7c6f434971fe6b4ea4d0abed604a791ad9b7cb895e5db182cdabfec1262e830996e3b7ff3267bb589252eabe9a752f362ea3b88864ed994f11afca3b69c1854e8f6db806df40b77ecd40bff1793f44c41515a9c450a5be2e386b9556a57eeeac0687c15ca3b24bcc22339277254dc15dc8d50d766158381264aa3613389688ed4d12c1bc6a847b939a0cd7e93aeff1f2108c0ec453f5704a22b22361496dc93e7ec9be5e476c9505a0f5b2dd78f0b464cddd8e4730ef5436df8b3a53325569b839713a31992d86d97d82476ffe4bf6336cfd16bedcb27326ca58f352cec49378576358ee1745bd6ce70218b3f94defbc588712aed3a2f4298c84674e09a5741d905381b460d39ed1bb1a6d85ccba82bf048fbdbe51eaf09b44628260da1fa36018d2fe307cd07e5d36aa2e4575664b55512ffb00cc7b1f65a173bd7722a68b26c50b68401f366840f3a7b3b128170e262c4078845fa37d4efabb8336e1f8388f0437c668ca997cd5e7d1c4f7f003be16d1f9099b677cababe7b7a92248d3fb83e91019a0aeea43f6507a5c441c025a02a90c9e296f2f5f93e424e80972145ae1ec559f5b7b5ee9f6a94c7ce95c29be0a16c4151ef4917cce43198e0dcecaccddd1163e143fbb2c5b75ea264e7635b08485cd5aba12b683e138367fcc14c1ee2f4ae9e5ad4660298386fc3021514bf2be8d6ed888cd75cf13f94fd57cad34fc1f39523b6afec276ddaa0bd638a8cb79238cc0c57fce42a4645811d497719b91463defe31108ba8585c6de07b99efd5710812b4abdc9374fd5e6e5182d1441d4e4aa6cb6f205d82680899e63cb8bf55285c716156e423bfa4c30e8bb03d12197efeb8dfc88614cb98fbafb2fd956f45c012b4b00cbc237d2ad70d2927d128a8717b0378184a4c350db8fdfbd15d319dae97e5c6cb8b1aa7f91e90da0bf192d8ef7971a9ede1e8ffa0004128997987ab0dafc8009df8bce4131ea29681326428bae91844d49866c6ae4082718f93d51e6f8014db0015085825d661bd40ddaf4467d4edaf31d38ab1596e1d09a7ee2fb0cdfd8c28153856a54b0e3704a46776adcf2ce2e2df4a748081bc7a1b2100dacaf4bf2fdf624e712b8ad1ed82a34c723645836f4dc7273f4eb0ee81ac3897e181be84fe866ed8e1cd869724c000f715b6a17d65af88f889822d803a22a0096e18302f384afc063f12ee2623b250b1b2b0c0a39c74b5d226d8a7dd104ffff2d71b202bf0da60fac6f360c088ca6928256e857a25e112122f6e956d16cd2f881a3bc014704a194b40fb0c681822d8d1c77de3e2bc04e94e00bfdd254867f110742009459ab8454c1ac5090feb8e073e8f1d3a262efd76ac01f7c7d44ea3212018e44489ce56024d75582654f244ec7aeb51ee590948f9192a298594e0a9b8973a260a1dc96c1880a53e2e38689433dcc48fcc18dd499c5912104b95776392d0ec313b1c9aa8a7a49592ba411975fd8c83808022b2c8df16359df575241ff6b00128b8c2295a69f7d84bbcb8019b45c5519ac7ed39776a7802bc9dfd98268d6a04de0fc2c8b78d493e436925cc8f97695b2d8cdacebbde2b5e439f0012b8bf82487a279bcd2f01f69896d47101d9bee9f6f1444f302c4f173ed8b8019b5c24915cdf9fa288005828215b2c856ee30abe18e878f32b31ee9d1e92dafc36b46ea7f69aaee0bfa140a77b7da53ec12ba73c77f0c7626b7026b19b619403f63fa520ac1d27adfcd3a73d0d2121a06b643cb4b3ca74f1aacc90f191d2a72f030f8f3cddcd922a0e559d8972c0d69b08183c636b0b86473b3fdfc372f9cf7400d951726a28997f511e5413c4ba9ca6a40bd954b0e1c93cf0b385a9e3143a2513cdb7844c66f4726007580a1a9532c113e4470c7ed6f20fee61b62e669538f666786a3a2ff02b8605d245414fdf142630ff2769501338375c5f9dc9e99a4724b406955f62a8fe48e6f5b1e161a56c8a22e2c54902840b65fabbbb4c652585135c8a608028d75e585cb7f469e5bd140f40be7c9c91a35a971085acc492157101ba191d388f2209bbd7c9f3794a3e6b8140b9ae1d09f6e0bc046046bbd8ad207c750fdf2266fb99733c27f8375d52cc19764ffa9fa237313807ff090d0c6e1cd94ef7f6abb5d96a81f1cb9da4c1dccee773aed83d710276d853816d64673b6f955e3537ea80386c4e09c44f0e12ef814de06be305864418e5def2d6e16b4bf5b14480083cb8e95031582f8233d007a0d545f08c24aee7b025e277cfabaff67c0d071ab1f43c58ad8082fdf92a42345c3f71ab32c01cf0149de729aff8fe3816eeacddbdf2043c5a72ef456d98b3ffc2235c35c02ebb227bc830788815bf4d4fa4c035428b0e55153cc5afb0c8c1995aa794d1bd7559b396eb26c0fdddbd2232365ef7bc502513581654b48300c0df44ad0005159b8711494222f253a9b95e630f789cb5b88d57a945401d09857705708b532f798e3df8f258b40b8687f362b3c5868fc535fbc387d02f0698fcbe82a3c8d3848094484251c44822f0b89d6dd190345f4b39e3b9c1e77517d0351b075cae3ddf2d6b0d458a01eaee13f11ac458054ecbbef998170c760feb0077e88c53df9df8ac6ce4c29428bb56aea8600ccd4e12313825c8e1b3e96c37d2345d547f5bbe5a7f19feac003e5d8bdbacb8dee33602db5093ac91cb6d2c7ef8cb35a47fb587964a04721a3ddba3161c4ca3dcc62c42b6b5f976e8362b8d8d6aae277e58e9840e3ab5bcebd0b0f8cc0550e4ffa6334890ab6d900ffe93c12d5e7445197e6d977d4b5a1c1b9ea6c943a49579fe1a072ed300f9c0d2764b811463613675764c43e874502300586023c9b2539019e473bb165bf91a78f8172d4b2800d3e86f24f7bc0bde2b99b69be9ae12c9f9dffd43a76c01dae7ad287bc559939ea03f38bf7699cd219674cd1be8a87630de3a3132a54e84f88d01a1e3e2018a540a97a37e43e2709f5701d3197c43ab65cbe910a5a2bebc5e1b1bb1557aad0aebb2c8c75d912d3f4eaa4ff0989821635deee7cbae709c6804adcd2290efd1f31f4474f2006f487823e338d1d5b02c0eb83dd80ec4438a580765266924f5c1946e4f466ba675e187791a0caecacb6f7909c058690d5a749c3fa77a8b6f298ecd4d6d02c8a3c46eb8eca6501fdcd2bc7f3b92ee86857b3d951dee5955bb1023a81f7eec1d3461b4981ac16963454c17f0b0a85b48c365804f702c97c68cabc4a6e3df674d7829ec5045e72a67f91695b24c15368687c55491a20d94474cbfc4d9025bc3992757ba8ae52e31dcae84bcdad1bdee7a0cdcfb2f088102a9248500f6ccc8b29cc390c02c5c62bdeb591c0bea2fb70c2033f5b14b5455613698a0e63adbb5f958d8d034123cd4e6f2234df53a05783bd7f73ee8592b1e57d05aea091a4003d24b9f35cd9a7435281a3408cbce445f7462fe99f3b5f45144acb0f165e86f353841de0f322007d02fb3d61436f327a55ede7ea699a7bab3dab2283c9479c3c7a94056fa5c0198b86bd83fd01512817e5d45068c3180e6584e8f569cda4ba9781a329f4ee7a1ad577bb2656d7c4f0d3b078f5d2afb37b480b420df2c36761ca5b300128812c430ccfd6fbbfdd10686842e4a9bdc2e5c2ad192c3b3bb765e4a208db913a6b58afdaea8b534ca09f8db62f17bd4e86a9f6f0f14532e3f53e52ced7533d8282705e780287161d5c5cdfda81180d58270e58d8e12fdf026dcfdf32f4266e0ec9c18d1906200259df4fb8d7b548254ab61d412911060b96c653d02fa3a93f34524c3142da8962b9a9f0c25b365c02399592cdae3d864b5df058b8744e5e03b48d3ecba30998fea0467cecb90cd7dee58fe4a7791b1353d160435fa9f4ad9d42e7cc599f32e1370025cb917c070a15c679a95b5f3a11d03223ed35bbec6f91dbff97f91a011601968b41980fa16f4fae2cc6f3f35fbf0cc5c9abb8c95218f0c1919fd5fa89e3429efdec490df324ea53e024a8af0116faa7ae2601477931715b2e3b0417aa8b7258a303be804555826bb907c48bf1a06778edb5450b8a8562235a219e9023bd8f3f53400a6d4bb33087885cf924ae73a216008c97a7bf18ffed6e82699fc9af467e767c2133d223ae6ea0abea626506069ee3d21d38970a260f027b5fbd445889598bd1bee6a6fd1d4c11741214064dee96d2428aace55378617c80794ef5e780a51b84c85c989071a5cf28362ea2df2c0ff25ccfb72feb67f26e0bdbf4bd9a72f1e4b25b4a43c562fcdc357d5c676363842ff4d6c5716965194b1c13f965f0c500418e6c54dbe0b4b30ff98b96793d28f5dd86677c0a0496622cb074f09c72b3fd8706c9c8ea2bb71148c4cae7976e6596a85eb946bc9162cc03c057b01a6d0d6d9ecd3e46b8001a3440ceef5b00936e79d46d8dee8f460d3900c72d6071a8315f12b50c7c1270347768305bd97cfd3c67657e839d8d7502d7ac20a9e76acbad06843eb975fd5cff7ad80b42c459e0b7f9dc47270a24df825ffdeca447fcb37914c7b5a0a12c0870795496621bb6a2b4fd47beab174bc3fb41efd22836e3719e83bc348bb0018ab5fe1b2fa49bb6a03db479e6520201d7184f4d8c4383b1eddb00d3c1f22c6a68746d189f3811fe0c7819df2fcb3374365fbb2c5c82dfed8dcf65a69312a91d5f3c76c00c9ec7aaecba2ae3a22888f67e3eba40b41e22b6e0d2918ed1e8323a14b566b6fc2288545413e82addda1ebabf0c07ec313c2288348aeaa5a85666920d1dbdfb6e69452b13759b34ee8418d3dedef729a9c185cefaa387f8144b3c813ab6a96a9789f0730611ea77baff3b9879aab10284f20676e532689058c72497f060e4ce22b888f2cc74b0ac298e810f1bd1f16f9d82044cb79cf102e03fecc252ee72de150c08a9f3c72ce79ed3672eddb6a99f7fd8971f0c2b1fcece6d90f9d8d8069efc870bf20334295bb97834b2600c061494500312b94ae6e8a9b6e71a07968c52f5b353881f75f72efa6b2772e3b24065efc3bc9686bdb5e9d93bc7d54faf52aeb52af7852257c9e666656f5374e81f81fecd7061a1ba2ac3037d6f66923f4702916fb16bdf42541cc4e98c86b6eb1297ce145cd872d905a305de020b535068112141663d3ec1182860549a764a2362627e2a9f905b7bfd48b5c87dacbf9a37a74dcc6517e442018f7be055f15af42fbdee2679061f24f3aa8e3e311724ecdcacec66acb7f6d0c76774437de65d5c07ee57e366883b8a60d281c53fcff766a903241bd277ab396f1b4949ffc2fda3aad53c42c6921e5daaad8f2abe2b1192a27c2a03cf1b3540cae069c814d5a7eb7074bdf1c545dc874f0f7cc1359158f7b6d4d6c92e75c1ab01163f4db7553202603b93f534579a9b6f1b666d5965f87434cb805e2c5962e0982a55337d6ea290a040d7bc3152e72fe9664ff747b8ced4a39f73ed9fa1b7610523a557d848bf163f235248cee98d03bf994d8cf92d58bf393803a56922086e330165f424bba689bc144f5fbac3ad91057e53d06f1836d70bc5a2a24aee4db9fa57d2605ac600d90aa2ec908f9148f90cd72412a5043f37ab30d2bc8eec46b0615c2a5d9b65f3555397c82e787cf6ef2348ad7ca57560e5edad833148d9c8c4fe9d8c98aab76b31ee10fefe116bdf927164d1fa7a65345e99805fc1ec1092f809323dad2f0258134e3677953383fd020af536eecc116b9e3eea53c19d114a320a23e54acfd5d04ea579061f4415e5805c47b127fe3b542759ca0a8cd020ee2dd665eb46c8d1534cad25b1cd9ac7be575acf11c0272fbe26f3aa7215f6dfe6cff71cd5b47e1aebd54e46de3a121edde37b7c4a379a144b886fd9baaa2fc3977db2f8e2ca94388ff44f6203395ebe1258c7d85870910d7b59299ecb7dee1b7006edf9f2c55833844cf575472b596c47750826828e6b1d9967e28b934a8b5e4efd8fcd57c4a66cdd3389ebb335ab5e6538d94316b0fc2d1f6d713240b3de0b27ac7b1e3b509ded407aeb055fc03ff1e8f9b2122fc274a0ee06bf6076e112b3f5f703d8d91369fd8287a5e90b71c1afd0be0426c7d3a014966bb9aaf29a2847412469d1c5ac9ec6e10ce56dd46e7fffae2d3ae34a8ed9d6135a6c3dd3c601f6ea9f612de48f83e16bb6706c62ee9fe5c4a91a338f0d382ef99e1925c75b68a575335672f913bbdceabefd58bf92a4f444bb005963c676be89a676c905061c1affb6a19ca9c786d52b29465500b3a2aa5c93ba9ed286669e3f68d0410f6a1dcb7adba309dddf9f0617a90a695a4096c8baafed8ea8b69388ac4bbff8a2a4f629ba49a4155bbf30c0611e212a46e5023a26a2d49559f65d8287522f50e0981d8819b09f58ffec38bc335f51e1f95a6d32e1d6c0dfbfb623b91bd375c39347a525cc4ad9b0e233ed839ca9becd8efe59c1fb4e6a5ad5e01daba5de6b5d8d436201daa47441f5c816ecea23373bbe22c5bec2265489269fdddb7e8f7e5bdc30512bfc89ad67829b8dd87d13a80736f118e30cde1dc877f36ae34be49e95d228f044a9c4534ed31c90ccac8436e35dce3582cc0f7cc4dbeadcea556545c747d42102c906be30b75a700fee89b6850d499ba5ac7a8e09fce4a332497f5b37b9c02e6a6ae447ff1773587b09697380c1792b980dfe5164f2880e8fa3334bab82fa9e757163151320e0ceb19647c856c9584db64e75e4763ba4ba69bf2362faa39c063b171e3317a8daaecd62fb02fd88c99bfa71a9147c9db6299d857aafdaa7ae77a1c2a039135e170a349f0805f0c450dc4c33673b1a1d2aa8f8c4fa3fb4d427003fc7ea5f604ce576f099c15378160ee77dc051006338ae44488bc848517feb164a9bd0ad11fa0d6134052feb23b2666aab89c9ff840bba55d563dc005b08dd69ed089ed8f45cf42f53e1e4677e95309b86b591ccd9b7e573a949e9fc28ab164e65fdb7122c16e54e028f6a418c44b96b4937274a4d02151af2456c222870dc25cc4717fb307ccc9bffa92f1d7a12559b108841e88ea9bfe1ac9eaafb7c4fa6bfb57fba001093ffb0cc69b6cd851a7b078affdc34fd644f352dd73482191d0480cac85242a2176a41fd598fdba5a01cca3aa38c7aba92aa7d25f82042dd1abb497cf00956a2a8f1f3a364963f8bd09eb66033b6626c424541ae1ef63cad24a0ca22a2c46199472ad455fbf12bb7d8d8ffa876b1402377da7f7d10a700433a2c70286f38495820f86c240201f454c1361390e305ca620bf9037bdc442c26721b13eeb6c4073592b6477a676453f5fa5a92bbf2ea46c22197e8bd6f5ae4e5dbb4a189c763d65a5bf1496b5ba034cfcc8fc2a05da3fa41822924f22617311279b1c8276e61874789d28d2ea48d39f2491762dda65b883ca3e11bdfecce650afd2d3d2fc5ac5b8399e0a8bf507376df741a599ccb6367bdcef17fd1f7e277b50fab84cd9757b968144d86c24aa87af9d3b28cc7c2a40fb61fba337811b0bf2528257464a18651f7bac69ddf36cd248531fefc15047a5cbaa1cbd9be2417c1f3b6ea6a9712503f8f2f0f71be265dbfbae04cd4f267dcb8479f98822e5db00d3ed3cf62cfe432348631fd8a602d9d2ff8dc3fc418042d2adbc1dc806716b10632763659350c510ea1d1c9e723bb4667552116e7b25bc3008039a0b3cf5c3209cbd62eee81f23c0454c9e60a0e6ef935ce9b3a29a34fb6ce36e42c3caade9956e81c7c41a4ab3a38420bb2bb59bed779956cdb3c9fd9777c4dcf4e806607c1dbd488117644fa9784326c24307f4c90eb6cb0363016de2516461c3f00941ac03b0d9619ab7726126ecfb8c9256ba1901b475885a2eed5017d809cfff92a51c2363fe6d11fc8d1bee4274a2667233377f357bc48211096857f3435e2b5b0fe4714cbf6f206a250dc66b992fd1cd0e5384edf5be2a56f4aaa38dd2c04a6c8de85133248e2cdecd0eaf4c8c37b4e14915c67b135127b6f707304248cb56e4f805b7a67df09c7aa341bebb63e096a204844e3a0cb4d4b70454576b713a9202748956050b9b7f266b4357efe873cf777ec3fcf8cbc8e22cfa39e02b75386929f86999e14862ff9520f7e7d89d4ae42f6d8b46c4ce0d5da94b40b928acbd46b3241ca7eae5f40918dd75b0c314e8b8d29536523dc14c68aa9a97e11a0f31f31b9526d18fd6821103845aeeb8ba363438816535380732bc2e4a16180f063258e2cfd3d2a1302a3a121b42f78cb2a87d28d798e932f7da3fd5ca62ed923ecfe28407190076640f7cbacb6ab6f79028d7ed5f9d294e8a80f9c15a5c7a9b3b1ba36dc89d81f08796664b1ae6de942200221166a714d3e004ca387e362c299a3a22fe4fc838b23195023dc0b4245cffa9ab00f59bb5749f9a35f3817354d9255fef8668f34d748b2fe74b6a023fbe3ce1175f944a75657a99e3b7f081a2f004539c2cd45ea3a2bdc03cc46f71f4d45f2895900708b5cbfc000cf5a5974c558ee3fac45784ff350126b3ae1198ee172b2c69a4865bebbff8430248c5a61890c7616e44e1ab96ec0312e1c64bfcf92ff29e402b0d544fc764d1405d4a446e7048042cc519e7e5e28db21b3516a1587b1626a7e9d450e6caf643eed50433ab0bc6e2a21db525643f1a31e5e615f4dade04d8eb6541696f4ed6e564219ff1c85687c008f96d534c2e2e3b53d6a4fa2e47e25d7d759081ac4a7ad3ebfbecd01e36ec402d65ea4c783baa8bc47d32c7247294a0d7d243dff3e198ed9268f3b93603c038b46baafaa0899da94b2adb6ae10049cd1c95a2c59d0d960e8b104161fc19523afb800c9b7e8683f26d7b63a6009321f4753cc9eaa476ec6754379159ed33ec141ba7cb8d478c6acd7b8222c293a8fdb8f8f190a5d82a3c36f9cdb9adac0fd04744222d686339ebc1ff951b3e1b343de0a672a7a72d7798c1819e56bc2b5b9cacfc81594d5470befa9f5be8e6e2640cd8edf16676ec66a657e3168c6eb3624e7b4639dcbaf4bc8c568869fafdb1f48f78bf7f7ffae2258d979422c5b30268c295eeb1a79386c9b18fd89296ec0a509e95da097219e74c6e733130ec19b77e6791273369c095cbde22f1b3b3bdd93444075d6ef70706096abd77fef68fe7d064b871b5864e488e7c40a7ed3082a5efa9c70a600a722694b86433db9c254be1d0e3783f686aa4d1a155812ab86cd6544706397b8498cd4cb4fc8eb07cc616d629b3999fb0b97f2462adfd4bfeab3d1aaccd4dcf6f1d2af08e74019b9adad403cead8d4fd41e534baa8edd4ad19eb3668b9db3933381dced1fd3f5ba71383a132e443ca11922ee9b9f620e24dca5030a5bd4595594e0713e29e873d0de379e76d0803c2872625e3d686d326a224ea5a61d6819ab23ce4ddc701d66f3719d5f650a03f29dc8bb75e19054a8bc34f401467dcdd09abeb3688c8e15d92cd305d7f79b0705dd6e785c0658904aa00b39cd365cbf08f0e2fcf9d89f16c221f689eb86e68773c6fe2e4b60db5e7e2f5c70b8e710c6170ac35eb2dd03bee9c9bc05c868a8d01229bd68726306119b34e9234acd7b35aae79c7b17561444b4f7f0cd2ec3670c03584d9702d0f64161d792e3208b358c4701e8321c9ac2cdaf77a519131d177ef9a8b1636a204f482e075c386c562e9dd91b2e8fa65d77aee55434a1bedb12681edf5e1ea3b8d0bbd666b0614673ba1017ec98b438f8ebb0385d051f4dcf64f17e13ebe8bcb883ffba9a2458a5c757cfd7a11e55f6301e0410d21712c462fc5dbd331e996aa4f7844efe36e28fc035bbb9d8362a59907a7407dc40615b9b402dac503e82176f87ef39175bbfb88222fc031d187b6818d959076693b13946e427923fa06d0d31096a843d2426a66963d7c3ee42e39e74f07bf0cba13e9fb072cbe71b992872ce929452994450dd1dbc84946bd999f7234bb0adec841573d87bbf66f1b940439d0b03446dbf37c04c8446cca6253128de176fca8e1c6f631ee6e104e81a670a4dfbf8b0a10c81a707c2a0da7d21bb4c757ab7307c08e2ea1c599ccb859c70cf1b10aa66ff0be8d9c23666b7afe9908e5d67832d2d99915f250d08a294f95202747485104560f96ddc595a9bd457301b6f67cb9ff9dabe4201b3af715d5dd859902365eec43316b281537af527ebc217d54a69eaae63627eec8497bb074b97e94fb1b717c486b326c67ac65860d20e1177f0b0fc91d440c911793f8f4ab08f9a4e2d3315","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
