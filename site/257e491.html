<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2bf25abaa6ea1c9903e6a57e3b468355bc8592854cda7b9bf5dac24a20a73bde27b4d70d7a7de761c53060b90d2aa12ff21927450e3b894ad55a576e6ae0f645755629f8e933831c0bc8aaa1a7f93c08f125bef6756101314ac4ffffd090ea7807e14f81593f2a3922ce415bbcdd1bc3595a70b0325f54253323de1e2a1c6ac84bed947dd1e275b1c314a2d663aa49bcfa61ec2048716035b11af88697b1866ba79f482a7d06941c24fd895834f1e67a3d335467b4f3a5c3b3478425aa08dbce565318d46eb1736739684716f13305e42977ab94ad0dfc5ee299aae5213ee89f4c2fec03e9422a71b8ab51dc931354f9639098ab7abdeaaff4d9bac687abd79853c365b6879c33d7735827f95566bc8d1b9e6b4bebdf6248b109b3e8339f34e6cf5b1e76d6e02a1caa9d5ad4869480a5daa6321b467624f92c5454f5348bfa54704799f880bded7746f23d2a37d27a6697c80dff77c6b50d3a1fe618eeef4e3036ec32521dca0cee8882cae0e058bf634bdd3171896eb671a0ef20b62b6c5df8bf2e1262d573028bcc2962c234e58efd1b9b3817f8a646bc809c9a5a79da4d48c0a488672e9ccc221dabd78c408ff0cc99da6ed173aa1d6d0ce899e12e3f30f7f810a9aedca6ecc6a967f8d2388c2482956d4cc8d96e9d57121076047c9e60dca7389d2964cecd2c8e785761b7bb23c08ffd0363c7bf44e70a151c823c75e2365e1a697141b37f1fce4b6132da5944632743943d40c2d658a463dc8eb676394964c7c7b8a620d68a45993d1506600d1602a76940a5fa859a4e7f68043e8995e749ba63e54d846a4adccd842146a9582a6e33487cb0a971e34f02728944212267764c7a88c7bfb35a719765d2b67019da4bf0ac7a7d8cfb94aad7411115b4c31a5fb3252c0fdd3766faacac7434e18a5dcd7ada1377a6441f0b133d504efeb6fb54be1ec912a7dbcf54bbf9ebc868dd77635ad5ce3a9f05776008c6e780bc6e1a1853d18ba0d9caad6085c94c36f1e7046084115812f03969d46009bdad9a1d6ed74bb0e9ba6d73641da254b82016f6dc93788b4672ee337d75c5dbfa4081a40d081cbfbdfafcc0040bda9a1a7e9eb0cfc5ce3c2e3302998158a569817ec4792751d1e9aae49f54ec46a352d69f8fe79471921b62bddd8945625a067994970268bff95509ca827f46f61c936b9dac4a8ac4040cdbb566c40fe52a0cd47681e52715777ee2e4e193c128acc26ba862b668655ca8cf99635ca52542f2da49d46e12428ecac41e3417a56e99316aa876e3ed465252d797ab523f3286fbc35feb688358bdcc4bb38e1686e4fff7dc415be90dec37d57f2bd07d3085dabb50aeeac52f48725ef5f7dffc2c3f801540edc56b9e333856ff5b7e8c13dce1daf0ed31bea80f1109891694e66bc7c9bf4e74cca9e965c1af82bb79c7a987d23825167bc121f20e8463c1027e8e342f17dd2f09683a4e30bf629d22afe1d0385b9b757ca02572f99505576a483a0368bd3e28a8c266dc51443c1532f56ae384833361c5530d4e0a05ef43c078fbdbe1bd4eacd243fbe432f6e219008c357a6b6c83b7d84a148e4583fecd4c15d6f22673fb921d3b9a118b4d38372b146c8196afa6f4c2378800bdcb141786f91df47518e25db8d610770f4f1a773d026fa994bb8342f820e7d3cd0697269cee1140933e8d9b0c4acb99ee3ceda2fde43fe7b4fd154d1ce53fe4a03b31c9147b6070188e203d070c945b7f67f6e75f27e1cb8e352eebc7f6ceff01ca5e986fe3a2f5982ac6859af391958a41bf7a8d731067499c736f0fdfbac5f179d598c73fb5375d83070121d5b7220f36a5f82f149214441c89dc788f06425eb40c92cfd44b837e09a57f948a4654fe763f72f7bdf84a1806ac6538fb89c449eab2022b15e0188d028271f3ec371352871128174857ff54acf3a81f4e75bc758151dbab4bfbfa20f71c198d7f29db1c408318028658221faf044ce19b48f24c235f65f9a47ca5c1cf9a6b5137d8748ee496bc0da2cc44d3593039f217e9fda93f00a0431178fdb0f1198e9f675138133732bb012ccac935f4ebe61f98e668324856ec633a9a959a08d979a76a49f22a6304cb06ada60fb0442c93fe9f589583340c5ab665c075e1fe279663575aa55b8745c4125e1e23c1912360e241380315c9792365fa31c08e48532d831dff3240a724135468968b7e8d091be9f03706c8c4669d3c3f7e82162dad80fe9fe31edaf0f99d1ac7815544a7e79e9301d29701d03c317a62ccc6c8802d42e279e7b4cf99141d19ce8f56d6e47efa1592616519cea87dbebda1d39af85481a847dd15d50326854ad990b87d1def9bef7d86ac5dd35bebada669bc9e3862b25a2c6caabce5a41f9369bee89276b2f9c05e0764dc6118204b0e1d980a973ae9b948a1cb3e5b09e47c6aa55b6b05fb96c727dc977b3dccd95c59df818bcc6a6d29263dd13daee74f51c684bcc9025c299b21e0e3d1825a853839b2f757c7348664b042a93466f3561b80ee3bc7d02d431fb842b132c9b8e96b9b7f598197f4a42885d358fc00fc524a5dd3732a788c494be6ab6484e963350dd297c8b52afd8d617e6a971097cbba9c71ed443fc5249323dc2ee87d1a22e59fa8bf56106a358ee2c538224da4b683af9936dc0aaf82c0f185614419507d96587979cba94c0beed7958b41c2ef1140add61eb50a84c58df7d8fe2fe5d5e7bb2c37b097db3ff13c410a313cd760f69bb482d8dd4b62a99543883ab70f8f809bcb7e45d06e269ec1f74e5b12e0974f64a74d2a36481662fd5332955a22effe3ea20ed7dadbce6ef3775ecd129301a79095eb6159b649c23eb0236b6d28171e9605e687fad0f59e3b75be4ced6902f5b18577c6dd0a3305f453937707b1f5a2e7d0e635f27b05c292e72b27f656efd15618aca217fef691daf69e0f4b9a0e01b8af234753f81cc78c1ca7970e953b9412dca319478bb6a3a93fae539b4ff3f5aa4a530c7e2ee5d5e9e17b842af59894d93ae872c6b3fa25d072dae3ec6c0b455afe9abca175233a46113e3e35a23c27a28e67d674a2b64706c89224cbabda51afbcba0e92696cf2b86cb48a201b14368d37c0ded6f598cf950a6784d8d99bac93a8601eb2c5f7e678b53c0b50f5038487baa9f2de43162ac5b258e58e48ef12a231a20746e1ddc8f6cbefa043bd73687077d64174e0d14545e1605960e38f86193d43c5c43584f505470b9bb72e063c253c0c490a4337332ff4fa796f3a62d192b36544d874f4d32aec0ce493b2924a323e8c05c66c6345257bd8c7b8fcb4cca1fdcfd41f759c51d78fe0a49e360b87f3f8982b4aaf8b574407ff4015ba07b83df2a2a6e72d29be16207942eccd782ead46b8b47046dc7fc51dac49a8a77567a4aab1ebb5df500eb46433da4f51469020e3d894c3d6b1865a404f6aaabda8cda4dc825042fe8355c3a5ba878a58865d229dea6fb14b51cd8e737fe47dc53dacc9a9e35132f9fe43c0943a16075b6ebfa18bf8a8b36d9891d1612546a3e6968d2ec93b78ffd7aacb799450a8e537bb187e50db6ecc924c8ebd767282c0158d73c04674e06d5771cbc6601587ede29fd460635efa35d23f6f57059816fd397760fa65a23e083be40c48ce51a89a9cad2f7e9daa613b4f699b1c0816bf6c38d169fb91bde6fc7d914346aa8b6a173a4d5aaeec41dac3085f8bd3553b65fdb62ebeb8e2bec83a304e6f8d6ca42223d687e7e8409522fd302b73bd4379a0b3e0262cd5da81ee112a6f2c768b51e986ae5b7354ae72304b3d9bf7fbafa51f988edc257ffe27425b8557ec7f02d4e59171ca992378a73e1cd922f8a6de4a7dc8968facc707c9eb5922fe4cc0cbc7286308b628749e29b9b9a04baf64686afa779c48244700f413f12fcdfad6b88f41ffc805a40f9ab275b567e76adafff531bfd566589aefecc06d7c088d311eb32e5c952a14399b9b97392b41f0ff91bbc27d55230dbe6ae9b8c88661ee5587fec5289f2b8dbcd4d7061827b8222955190d0b7019f5418daffedb7dfbcbf657bdadeee3c00637fb6b334802bd8fe4289d8aeda90f10c6ed86cdd0ac83ab0efddcaaa88e8f237a2fef215ad3562cfbb9c5b30079a08d9b97d5e84afcdf34c9cbf9fba61b4f97902a5678af24a5a2671e2e15950a136481f3a8df106ea098b5f6f6025dc50559070da2a397526e52de097bd51d8e7bd139874967172f3bf52f132f2c3d0403b28cdb89d37234871545fec6a39a793dd035177d8d7cfb31798fd39a800091e1b7e4c5e12baa80a7d180e4a279e8ee3d59750f117f400e61cf227d48d40b083eb036454f758c7551b73e08cac312b85454f64dc97984a0a7abd365d73a8a3d570849d6076198226fe17558e9c80d50eefa5ea8d7f1150f5e8b818257bce5dbf05f1318d2a705ede18e4246a4a818fda0f5a4b71e02ff5907fe78f15b2f0f18d9c730f160e7da176b3ef16589ef2f03dc49ed71b31cd1c2254a9bd8b3e64d500d44e720f37260fbef0ba10dc9cf454ce792862ab3262c96ebd04b88010a049e011d7ab7e870b6cdd3bf2bd158355c5558347a3718206f9e9cac596e2baf09bc5d449e809ad92983160d5281e3633bb491d9c45c76a56a075e47f1d3ce2f9ba1c3f741769304874967600bf1f7ef015a699be3f6dade476e715315e2b665ba29372fe9df7321baf7dbd1aab046aa17bca20b53aa584f1a58c6c091835508f5349a0e71b473efe42da0d970ebab53a7d763b7736aab40d05925af2c9e57a0f56f6d901cf52e826c11cbf87339608dce2f6aa3fef3506fa6a48c103ae050e326bf34c091a75f285a54fcae1832bd721bd1cd7cf3ebfa26e46936621dcb809025f41a4f284c326e045b3c894bb18dfdf2e95d2918a30352e14634030085e4106323ba75221f1101e2c100f63e3dbe2fbd5008d1971b161e24f480fa19e44725ed24f0c1099a3ab1b178679f8bbb2b9bc4f3050c96fc788b805eec72b9b94c57a71cf8e2ccda497d9829599f4af9451139425783cf13c54f3d2b297ca7f4c15456a1c327a07b0f51353c3ff5eeeb3f5457101d19348831b68b396186c4fd623460780554c8bc415e3674646375b6d239aafad9b1ff14d59105340d47030fa04d4d10ddfe16da26af8459ad9d9f2b398f338f4f4e54697c0181ce4442598e8142acd5b3841528176f7f3fc4d0c72a5ce17f9c60c439f157521c777cbe6f977a5e037b7135d54f7839ab292f724ab3cacc28eca37062fb152b03cd5c548a72d3ab26d70ba219786551b51f0cb17b6f7e1aaa322335be9a2841d158b29842a5fa85011ffd73244b2d70cb97e5923d1fd3a7d049e6caf84915855337c612d32b22fbb528529a7f4ecaac940853f51167b744039be324dcfed3ef0c4f524798ef1f9f108600058527daaeb41fb55e23ee834f3d99402b2ef1fba0eaf53198c6bd8d8afcc97d41e080cc6e8d7f8ad24eb3c0df88550057fcadf0575b84a6d5f3e70757414f127018bdfc49915ee98b3b8151b27743e17f179f0eaba0bfdf5a998442bc347672af75cd2875033e2c6623384d863e0f7f888a99d545e4e0b1b46e240e57ea5e0180c2a0fd8714ed27a3adc51343fd4e867304218c18f43845c730edf8ce22fe2113180dc562b3d0ad243af513a904973c464c2a9d02019bf891f11dea81c0a307f4cb2898c02b40d83790484569a48da1cd90ce2f9a3521f621a374e2d882621785324006f500981d7ffc2ed72f318adb2e1d58c77501f281e02cff85239ce32516cdb083def5d17017092e50470d4201ee9bf10c55ec7ba47cea2972560e13446f8e3fd81636ff649b7dfe6d4d405d286f8921c22f1055ca4c5c24554c2d0dfc9b441d67093f9060a2df1232c2bb71a523c943f23b54e666f6a61eb4053dfe9815789d6d8b0da587af3722e0cf135b1f88570892ad756033e8b9797f4d02ddb703951c962b43b2fcfb4fdd1e210ec12669f31fcb22858c0f715c5bf717f0d5215ed8968540681ac4cc1ca5012fb87335fd68edeb8d6d895a9316440b0766765bee82d55c41961c6fafa430d2c144f34bd4310744afc5d4dd3a3f8036d9cb82cfcdeadf0fc71ab2b3f97a2a13b5cfdb7475d713f13f6b56be040799e85e8c86065b93bdeab922a86cc8036c190442854084c89b48e33a6bc2e6084ebe97a753d3b241be1f3fba4e8bf90b952efb8011e7856e26d5960880d5d55f229c48c69abc3599a235a0be89c2b81c3061a2d210ef7caacb91c5bac9d9279b8f220f8fa4009ecbbf4c6a1d671f052928696a4c1b19c8c747360985f3c7bdd0981ee5654768803f5dcb4e206e9345b7638d289c3e73a8a866217f963cccf00de0e36bb3530efc186f0b61722b137edf3eb49c8deac51e1ce8c535dadb9e398248c09b1f733252bea7d6b3d1b810a03d35c3881907fe69d39e18933de3b258ee57387451e7492240097c15fb9d460fa30288c96ea2e429203bc13cd9f9dbda99fe01b908e3d4b4d2d475823f351f4fc1f6566cfb754a54089782c02de11e804cd57f00020eca14c6025c2a25d9e1ad6cda435c40b257bc9e4ad7310e7b462920c6c2d31867d7d93055b2efae760e3fd40fe18f5a5a2d49c50d7d09a0cb7786613a34db29245112755a93cc8f478fea7e865ba53764246c306145670288059aed1a96e491af56a3eaa0e01c81bae02aa1cd4291a4a5134cccfefcdecf8ec74039f518a4c46d221152f84febbecc6e698207cd72c5d00f2fa56873520b9a89cf318c8feb4094774415939e09b1ac151223f0c429972741cb7e6c6c298abd308a9ae89e9e5daefd47f6e073c38a2afffbe4ea5c56ec2fd95cd296feb48757541648408f81516c721ff7a619c5a1e46392d3b10a07aba8c4f9a8881b438658bcd6093478f99aa646f62a967dc32ff69c3258dd103b46347586b5f616e926a91a6b3d8795e13a8251ed836557384c5aaf788e19119d9242693e2c34dd39ab0912f8ce24ef8ded47dfd80a85f6611a79c4032a4b47d982fd8377ec49b2f321f27694729f2706bb504c41e581b37256f2528416c906f1665022920168fd560a4c34198fc6044e5b328c64ccb1c60ddac69218df8fff76a30ecb288a1941df48bebc3de408605bf1487c5a207eee50a23ab71fb67c0c62fc098e81e1d487af1d609168a28b1a8ea61d667494555f97802945fb9cbafbb0abca21c03bc07245ef4abbb08427169b578cefd34eed0a90895b1e38b83ba54ddb6569799caa64fbc5cf6af7940e583b6c8adb43cfb189e3ef8709748a9703ec68fba73acfd62f2a9a7a327e6b1be3c27f3b84936bc986f94d4de576e74fdf532cf9ef5c9494c394bc13a0d8f99d15be5735885e7fc24abb25a2002a752dde10f24ed64199bae8bd0a284907d044bee7eabf32e1b6ec4f0f682195ef3f536375cf2336de3cab635d90bd02db05aca6f6470722f64ffcda477db8de716dacb2204c9b01bdcb667a291a360ba507dff3fa92e35e8d4ea46c740588f697e3ce80936f3a8e084cb79bfa58c487d429c0d4adc3d09d5199606286967a1f8f324a0205bb9e2eb840dea41fb37f2bb11762fc1eb5a7ddc1d03e0c94634a5c1220a6370673f1a2d77190e2c064963d264d587690ae2816fc8e5bf17c59c87a4ac9886dd995e7feec2e0d95fde214689103df59a04b16d8d38c2efd5a615241001e555d4375077096ffe12921434e9385156ea6ce8367803a60d939eb33c2bf6264efcb6b83794577893035aca382abb1490152bf1e424114cba44b07e671371535a1af7cbd5f288373e95a741958e927bf900a08c64560a7ffe9aa4235035e63a05ab8d18e39a759d8ba5c36eefce1ede5e53f79ee1d38e1c7fc4b2f4a8be59394297305bd342b3180ca0007b9fe515eeb3bbfcc3be1f9eb7d8e44a745bc3cc779061e4e4e4239da231caf2ddc097a2192cb2b5fe90cac620abdaeb4001a34fc2ea48495fb9186889f67c39f108af4b4fec9f164d45a464fb0388b0ebb07eb2a9dc4cbc8cd63b21cf1e9d946f2e801c0be8640a023ca47e1574f8cb922a1e81dd6fe23332468be7d2034525c3f853d55d7fdc9aca82bd0f7a6a7b35c6cf95289ed81e45a927ebcfc45c81eff3d217dcd09bb52eb9cb6019dd425628870c5708e7f59c8108afca6d3d2efdd0732595400c5925cc63557e44ad13ecba8eb9052bccc85b0b35743aa65307dddc27d6b8116a4e22d6bd82bf02af93fc377a74be27cba6cd4063527439177314877bcd8402c0077a3caf14927c4cc32b5e319a9a1b69619f3236c3769b2e5a9c9299a4386b02aa893b1a54f3bb2bea6454e709b95b2598fb3a5ede318e0097f91ddaabc2e8d106c37755e3d8953e4b8aaff1dbe8565f2dda2d67a81b9b8655b511f0c190d0b511b6e9aa0b6949cdaeae22ab5f482292e6962b5aa064d6b66cf4a9d54bbeb06bd6af476330d9a1e58be0a40dbafc9a050646dbaa357c182675a6e429b332d0a45f5ab487bc31582b193ef10e184be1c60317952358c087f5a86c2cd36b07fce7b129187f27b4b694b671d3945ee876ce18239fea582c154694ea2b9f8054b2834531044f8aa8318a3503f7506df28884eb46ac77b4ba2b8d9c1c790414402ce1d92db612816a04388b11d36e40b62265d9bff04befa3fa685bd5d79963c3c15f415629cce37572b4bec61af9899db1da5c71e2828683c8925b8fb6bbb0723ad3b64a6f0c7b995fd61ab953949b7b1c5fd79e9be39003d1302b3a2cfccc35360102eebfae5af4b828f4075474bb844ed1a034835badd6445938216531ba717916264508c7d7c3138c70c18fd067861ec70f6df2b4620e2ef397a2be9b215c6de084496b9a1959b098c8de8f896713d9a320a8f87fd71ad98809b1c80c678d43dbc951e0cf95821cb6b74753a5416451517bc755c94eddfe8443aa149d54f6d011922d1874420a67afb5158dc733dd8082a47d7d2fc52ee653475754a2f99ed348c367bcb3916889cfb7d187fa0ae345047fbcc97ea9771fc04931fb2f343471046bd71fd93f79d42668749fc8bdf98e161976fa45584d332dcbcf677392944a60f4a5bf08495a9a032fce2d42ac4329b3694244625cf0b2e7e5a3c5e73756ed17fb706d848a9733071c36ec5e12cd58887d27d48aa89fc3798e7a6531b1fb369bfe14e4c5381ef3dc88d888fe28ced8eb7804e978775ce35ba10ebc3aa0842974eafbb4e64bc55319b9d2b2254f146a349d400df20f42b7760a5c9910d8d9020b36894159405b7c823bd1e9c64c2dd7ea0f5d3b35f255c60a82278eb4a2ec95c96ae9abebb99dbb9b89c924ea455accaa86d15839a8c042c6f3e03360e647e46d8b30490a8f5532ca8ee40f228de30263af7c45099008444eb1590a54ac9bb09e1f3069559405b97ffc256762455af11dc1f5ab272e5891c07743f5983427b4f69456e8c448a5e72616175c6d3a80b17ffb78ecb0622f5c6bcfc6110b48c13ad509a046acead6e4da6bfc9e4cc9eebecbe2ea2d55bbef2224110908d6e2795f15e9e229ca6efc217430f0e7d14240d79fb31ed4080baa9fa442f208be76e2398f5b2ad1d0fa293dbb5d4a6cffb4c08b7e12b1ee6c943faadb0c6e041cbd0861435632ecddc8b57b3dd11558061b242beb77f88deaad0533df0ac477fc2e2a4aa6d3aeb46f34f78a6f446df197cbabeed659288b042119121599922a3e21e58a84e5bd588e8ffb049bd3286d45221594f621fa2fe255f3b9559808d28676f06c88c4c5eae6923a55a9e7c6326defc6f411e8fb821c0b25f4ab7c92a974405a819922c43c992fd72feb65662c83d22d58026cb4fa526cec23fc8c2b1b30c62f63c860af399a626a77a9760048e68c4392443300fe5053a65252350d33530365422841f7021b2d32489ef83656b99f000d3cd4d5effe92e0c487e82c16780f542e38666b61566658aa8f2824b90791b7568c80d13eea2cd41fe27363cee0ea52e4e6de8553d8d9fb72961af1a005a1335a74f879259865ddb1fe3c5d5f7332e96ff423e9aabd98d4594636818959b16e29152217a90e1340e67bedba4bb45bd44857d312fcb0b31e3481e9c469465365d95c2d35abf98c99c603153ce44b1e35e740f8beb31e66f86724e2fb76d161a149e86ce02e8ffad7d52d40a59e1286fb8435f67e75a7b74e2c89e0926875489e911f130252e13349ee3a2c8ae152e754aca2ca12ea8ecd634419d491f58c420b32dfaecd1c7054df13a89fc264a477e019daecdc799977fc2930b789ac155e41201ffe6f512de3ef97b72bc01f4ee4b893cac83540e1ef7759789c7f63c82c81c123bb7448f400ad6202bc20961b82fb5a120e691bbf1772d44ace7ea63b7ab3e0fd059529549912b72bdf2bb2e034d9efdb3428c2ced8cafd8dee021135c1528313c72a31dd01dc27669ac595cd35e477d17d7af18d86047dc39106fc4a3ef1cc575523d01cbea96c7ce0697eac95e987c20ccc7d48b35692631a1f3577fffc9332e010b7eb4eb103a2515e99213519eba57d2fee9074a37d1c5b10fc198e6e47fa7a0ce237b7dc67b2d1206edc1bf2fe6554fa9e5c4d1297c5cb80ec09ed277e19dad14cff382d19616dd996cc1571f73957f4f6d71115d0974214465f5a595f6f2ccfdf9f53a02a34dd5d666b8c57c9c49bff5029b03905f8ef402f8d712072b9e150c7ff403dd16f18b3a0593113bb8198c01fcc824634abcff5cbbb899865faf2a8598c857617a9eb16312e94525e66657e58007f7c425c9d89403d7a1e25236d96fa9baddcbb3ce661b89b78c23fbedbdb23adb494ee547a4521db45f73f801a1724bb3473914714283b636dfaa1ba56da836e2d5e959f8050628c83e4ed61692c88f323ba075a5db2e8abc4c28b70f23fc75cbf1b9cb5f39d69903fc1deb49e7ee4469db5c7bfe253662765777a79647cb9c68900204427d6e0ff438bf6fe6c7867e5eda16d162707b04bbbb558627afd0c297b290ba7961e2344acb2d90d342cd9c62f286a6c577304b8995d98682e6134957f61e602a59d2770dc3939b317a0b071cc3f136c058cae789fa77900fe1d9f3ee2fcfd6ca16231a4a37602ea73a8d74cfd9afa6698d2df4dc3a72b1429b1da2cc899ebf339e6d922a488ff9e0b6010a2c359d08a9476dbaf145b752bdf7195f8bc165d7418484e975b3867b403ff8fbc316a15bb4f085dfe90c1ef149732601cdb12be146b969219c9a0a3cec158b6b07e3fbccf853d78754a0851987ceac998042d4b9a15dfec0ebd93e13b33ae6fcb5aa5dd8d21b51b2096c26999ce4d2ce7ebc0abf5a67df45ea509fb87da24392eb2b4a6a4b2c70584a31fa0acd067219ca3a2a9639f57ab5976c9fc1e2aa3ca0e190172bcb79aaf1d481a9d0b8720b3422735bb34a096ba0aaba4535560e4f79e89878e7de1d96c82f050c23b7efa1c6ab0a82195f8befaf6401c35fdc74571ccb44c467e47438a378c5da0594377e8","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
