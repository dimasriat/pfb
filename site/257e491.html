<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eaa2d51b09ba7a06152d9f3b0b24ca159fda15bd404174baaf006c58934032d1c1a81ae95fe3326441f376778e511c523e5ee8ba6b826e2499a0118ac1da469f1cc6e9b8ed4f49d606f1961c14ed04b5c0cb0c47785aad97638a4f3f1b55f29c74d00d581718081e5615d13f94610bb1389f6beba092827a65e1d2e709d6de6b5a3e1ccc0f85e86ed83dc6205dee60aff9c9942a754cec9d43d56748726c45bd967d5e890300e320f936c687d153a8c49b85704112a0850c7adec1117c60ac0dacb6a1d9cf6a2ed86a54f6db72f1199f3898b714c165da08ea625d96632b01c3b079a2a91ba9221bcc2b439e080dcb2877a4a9714fe2939695c3e6b019ed4156549778317ce79135ed4a95cb4f443df1481d1cfada7b5e3f4cc33413b86c1d0c0d1b803713aa776c475c3d2354d529968abcbf9173188d5b25aff3c0ddfc9021fdfa98e2125ac757516a13bfdffa50e9c0eb377ded2aa2c012415d80af04c5c36ba0b06df04dd0d1984f87bdfd8fff21157a854fdb5d08411ce16f501da65f713ebafc68e988bfea1003be6c56c8ed504cea43f4c54d2b04a9e2826007833aa7fd476251378c43e67695016dbfe7c79d5cd9f8697dad18885aaa657f0bcf815a8552ab35e2f6945ceea97bcf3e03773c29a0a84ef1444c49a12b5ae837a80f337b1365e7d21b6c85cf4b8acca18d05f0e33f66f0837b95c11cc9d69434e3e3e4e4a36633f053687890f1687af0a5bac750abca07609c26b112e55cae1f3c8369abcac0ac987fc26860b41fbe50965559aeb4f5a028741f1dff8ecab308039e3010212a956c680584923c031a10e06a164fe077086f4ab6821917c95fa4bc70c4a858c55bf0d0a528df59aa26393a6106cbd5312ff17820295232b8741c468fdebb1d19e098582cf2366b6d6495e33ab344abec0c12ee6870eb43c56d13b6fc9ef66add26aa465587124d61701b7d2227490ea2e4a458408ca354462b8945dc5fc45fe9887e4dce5f77c8044e49e6c6ffa24b80b5e90519bc006b89f8492f4cd0a1f22f58a6b913700e2cc4707846c5ab96b7876bacaa7f2307e9579154fe9b8f3f1c075431a102c77bf0d2cb575624494ee9d3913a412c78c2661bbee173c0398403dc924d03fc561f47c520272efce962c3eb00574168f873c851c34159829cb67098296cd10eeec18d5d5172d0b0393a29f920e93efc55349376cae033b2c5c0b63c60fe409befd3df8dc445191773c0e77200b11ea444909269bfe9d9573737c712b9add98119463950bad808a0327804ae445c27abfc2785b533126b20d275e557d4232dc1ca4d186ee92fa8c0e3d1738f7ea893cf16481e7c7ab7661b6178041142119095c9fb0ec3b1494c35d61c4f962ad5ddb9794ed7b085234596ae4915d763e1e84d3f9fbb803306b6ea4f19837fde0cd543214c9a7768da20ffdc5d7f61ac7c1931d03452d30bc9cdd91e721ffcc7bbe6280689e499a9a4b312bab697ca68809dacce56435300fd073ee2ddfabe7e3bbec631f9f7cd76168c3d034082b5860607b185efc66025212f4b419e573944d5e0398643bf586f9025ece033af74a1e2c9d59d98d7c9412f9b8900c517dd4f23c8f637feabce1fec30be3579e62269fae11fb0104e16e6913ac0392014c5e51cf0acd0eab92ae0710512e3e9202c331e5e5b9d10707baa622eac7c1e7523b4ab1a13d7da38d7594aa0b5b76d5a9b4d822c2e829a05aea0a92b10474fa1f78ff5e348e5bd19d6481bd442ea0928bc7e41fb5c6013fd629c535d3cc0d21e5dc1f0d0463fb7298ec65fbfbc0a55c9b1a90e3d9f45ced932183bce8ca65c56d4c5dd050751a075f5f959aa07efff17bb3405646f9258c3e5038552dd223f77ef3c378d17de3c42c0fd99c32cab3ffb4839d67261b90b848ae537d4d83cdca10c8070da92479d53b80df0ae8f6247c7ca98ddc2c2562d5834a03317a19316f3f092de9fb43ea860dc924025d6e533cbbe373cb86dafb1e7bd73edd608a5715fac03cb69c83c0c05a7ba7f0e2c814b3a5b050f86f573f92d7bdb873050d69250ecd04a4cf6c7e6864cf749fe102921d9945284f817f6b86dba90603786d2489f66a01187ecd5e7a7640cd653e05dfab2000f9853a12d66b7c1b5a17b978263db84e07ede4501210849e8fe5785e36d1e54088bd2726442cb6c657fc032da199707ba6de0c8959215189de27c2e7e058ef85bd9ca72e3199fead4b46c95a8b08f2939c0d8fb5e2297d2c7cfca71a5a3c7460633721758ea40c921aaa0276e029ced60a973aa8e46b196a107c37838799b24aee9fbb4b79c89c1568108e6976376402ec279d24e261ff9c422b9b625a244b0c7c855ea81e926477b39dcf2d2fa14f46a04b3f153234170f17ed2795d3d777b96d355ec2fdff5e958b22dff3ff22675f4563bf854b20425cee9785c1d8b57c8a0f2508c5c82012693f70336b42d0737c720c6b0949f22012d9714f322f12f9dce0768d8779136607067dfae216ffd41bbab15295dba53232f08ca456c433767c38efd82e69ed27a252f7e8d45f55d5d5b5115cb7117368969f578f6ff541226a1aa644a891bfa75ae32d72a23c4a8eb1efc15cd615131b030607ad530bb80290c1454dda4da6adc2982cf8cd0ae7d5c3fb25a3b596117c96d65c9bc029cd262ac0a84d8f6f2b4181b642793d279cac981351ea2c30a55fdd82786330382e141ab14054482eccbd6a27399a8c380f001571f5a87e311553a20610576328887dd3b3636558573a27ba0e1d14b70e910c9d339a9098c6ae64311605f9c89f660c6e5c09d21eb4ae0bd8f349ed9ac71dd2d7383a2182d07ce075a546401a9ebcf4767603ca78cf7c2da1ae89cf11fb67a4603929e5300c50e0172ed417468e2366128b0169c317d619ff42d3d2984a8dd7756d92956f4573deec262bdd160cbd21fa979d8f2d12375051483a9be7437447beb37ed3945791bd4c2c957b60b555e65bd5165b9b245bee9ce8742b8b5d4db6cf916c45fba57039853e60f05a96484725cf2f33a595a10f2fbf765bbf059cd6d70d110b4007a13ea37c77dfe37fba232fd072dee406e7de2a08de7548654267913a7797eea9595349f89b9300e6179c75cc24795b8ce6b7f5e7280bc393b28550a8d084f176a52302b702041c0af05d41da4cef6a2d3196aa9ac3cd70a3e745f58ea2a96cc0506e95e744512ba9b6f0e22cca87c72e0d4407e72ecdd4460349ed04a8a6821e168b701f4354354b35f071fae3aa167e0e49ff5bc48e7ba6c77605426ddba2085190d041cf900053c08cf5db57945c891c69d4007780f7977476174744b41af8c0bbef965712966bae360f042e2866624cec1d763dc19cde135a86059fd688c4fa7ed45a11f6410facdde50319b8794224d4004b11313d0f7c49d7cc7187a2abfc36d41bde5212bf8216fc6c2034e9e32194b50cc03ff4b4fb4489e954a3581ce118449a9e031a747c46ac7f4829fefe0eda381b12aa3ff2bdc57fab76c2fd1eb5c9dc3b2efaee107ca6d751109a4750af02f4ea9e6fb2dbde093128e91925e61cc13ee1f1d2814370a89dc9e4aa4916cdc87de66c47c3c7fb7d93cc18f2b47ba0d513c033f426554636478d773f39d27b854ca470a7eba94ed691534f1663c24b3f0b23f4d31c1fff3e948a09c908b7b1f7859215ea09c5ca9964a120bb05ed6338a2392c2e919e4963046fa444c573c0f2906810ec7c53f6d8862bb19946549b9790924a849668a81706f1b150028d61fc018a41c432c58e1143741eedf3fc8417e51b83532b494edd1a76e7b13e3734b396ff307d357a4854152319531919703be077e69fe2a46cf611076472fb5f837fcbb4022027e76f3ec42931cf6cbb095cdfcf3c3af012cb8e9b9ad55579334ea7699b9412a19eb63dfd5b14db33c7b809f64ba1e90c66d31fc95a11b37313fb26365ad8d516f0135cd1a620db9c54bad637a9fe5586a677b803cf3b6b5747f5e1d8c2183be32f13f863dcfefe7321ce18e1d396be05eb6c7418a2f28371b7ba576ae10ee00d2a00cca019e90be46f9b3168f269120c76f0e04a3d2a267909b5d7602e2dcce62156339400e28b7bee911c9193b086988f13a80d48c0c1a763d8298b6111a00aacd113006fafb848b41d63ad4e3dada5c9abeb9022b7103613e3372744b98faff7dc7ec5be2dc82b3389331764e7a522f4341173acf05b19022d82f2a9ec74011a234d64bd4ffc0bb1df36ade2183c89cbd9aad1d40f819edce44c3ef56c099df0a8940118c0ced0d77d7208dcdc54da7d04af17326a91351b21427a6e8f391d627d082d7051c0191fed14ad924d1148d98fa6607cd50b9829d68f4b2cd0853935cf2816353277e776df7dec6e75d9a1d9dca742d0276b04cfd403f3d5c684e1204611d829d6c89952e6a9687bd2a2acd274f5c97ba1a7ca8fef1a8bc3c8b813d32920f18c2dbd912922287a61e2e9c66c36c65eed90fab3e523e4e99e68cb1c0fc0d4385709ac8cd08098a3d43ae8ec496b6046b23734c3503146e5a329e500d18f0e42db8c35d6b1cdc42b2cf47c9eaae9fcf3ca8076d7bf80b30390c14541473a0ea38269496dfcecb4802bdb4c7b9de1fdbe0d15eaf95d357860db22a12d4de32af724ce97cbccdff5118883720127aa6f51eb1ec454a3256cb481e54b8925adfa7cdda6e8f989096bfb9fbdb5e0095df954d284a41e388b5ce02e4bc54eaa069a2e7d03f819abc848031a695c26fb48173757ac82adaf4a1f760b0ced7a5119705ba5bb2fdb07560718491509e46341ca2d89a2d7ad9a2793a82f6cd9678b8a4be3d09d6b19c23ea6c6167f1ba596de0bf3155cafdb0ef664b2d55b8fcef4e66134378d32b60c895a0b0a27e2917bf013e03c08c245035117e63fad6d1550cf4ed9da678fffe7692d8a1da801b820116e2461894498ddb47237923fc081ec08bfa7b644842c747fd19033f2816ef8a1c1f1b1a39ca7b4783f850cb0b9a3fecf8b1446a75ad904ad92fdcfcc684d5340509651958fa64d3eec8d797724dc6324f04165d785bc0596acd65ff80bfbbac87afd75594c44a45cfd1028c70b1a440686bf74ad1fc7621b55e4dd6758b12fa43723d0f1b3d9de2a362644cb23828685def99c95d87932e83000759b402b55bb759eb976f422e744626d775e521e921fc53f8592292a615e23d7ec0d1660819a454c0835f23db5ae4c492c9fa4c01ca55ec2c1279d72d1bb8f84cff462a257d2ed23d9e1b70b103377f0e4c12e4070c14ea441c5b4aeaef1e51bb2f6fe25178ccdc6b0bd92d0b80412adb4902550214003b2128cc2b8b0e0a4a9a74836f44db880f3f9d04ccfc25a288ba5c8b995d1ad98b9759163e720225c15be771e63ac80e4bc02ce9a637c4832108ae05d546d516656c559dbcd4b47542733963cfc10c65382f816d6a98b44a29b6d2ab153c601829f9372fc50a031397da414d95bd4b99d7b0c47c78bb1d7f8c220b0a44982032832a072d0979aa547bc14b2722f7b9ff4409925d04bbb101c0dc42acc40d539ecc209776a4397fe530d9c9fe8e653a532b0249c1e23330afd8f268575cc93329545bf4562b7c9d5cc97023e6c07c70f0285ff0ac7fdfd076f271cb5d30f48f6328730872a2ed35ab7d088438c3130ca0d973d281d64684654a69809ccd3a67ff9ae9fc387ea4da49b1f2b2e0b2f9ee0884cec32b239630ecb83df9461d4accae8c00e60ad40d2a249eaaa7555f28aba02f0f275a8a035102dac21d0cc2d757370e9d0edc35e419ef82fedbad4592258c89c001df9461407e3bd717f3114db11af1ef8049c46d67646cdc914a27878907d7e4ee581308626ab69d80de682cdf458d4c3903c03355474d2248003eebbca1bd6f5842e3ca4e98305ab506965c0c9e1bcb6b977e904ffd1d58f4e101e24284c03360a4ca52bfe1ad379d34df11733f7c0501e116a8d0d5ad1358d692432ac4bf5bf93881af9353d6b4c06027d12408b6209d5fa66c30bdba478129a23ab53f27aafd491b61bddc2bd2e79463d82e1a26f0c3209637218b2d5bcb77b56311e006e56f31b9d00a7a476d77e5a557c424410563ac89c787c3daecdbeff11b9d339821902413650c233ed6c09c38147e48c83fad942a2647fd65d2cc5ecaacabc0d4ac0880a5a2481fe8574928aa1061571104b9d8313ec4fb247548ba2a89e2d1574a41e14d3909fa5776dd93e2427f5dfe2d27d6cbe830f505aff3f1b26abfc76000c5b221c3c6bf7f1544282eafcb47546ec01fe9985d51001d0937d62d98e2cadda84cd7bf7692154fa3ce74d04af770feff40a6d6eb2b344b318f30eb1b8f37372878a9c7fdd2e8250917cec231e296056270841d45374a86674f1604965980f3cef170e610077757403b823713fd9baed78a4c0dfbee5aeb21d2050c34c77febcbfe614d77170a4ce35c876ab0ae3f8a547b3459bddea38947da6189aa73180bf1d02b865a3d6fb5c4bb8478d2e02e334c98d73cb67416613fa315f1bc2267830a84705b3d2ab4a3a541a93563c1826c3c154b84667ec593be7def7d7b549efc58f861c12f806f89062c4b838c55d3fa4994a670ceab9ca9e0df1b6af5308ee1ce65396c337115deeaed23960ca8d55adb8cb684b0d646c49547c2a9706d6fda293084adb9c255d002428a58730dd1a9277f3bd5920d2e00e799266a3a50b7938624c947326b1045208071d10713f1ce9ee7a3b2bc8a20c6d298373db33558a041881ae9f25085628f48192de107953901bfa2dfef9fa6cc4367ee5e48b7b38c415685c6b2db2f45f367aceb6b9856cbd10542e6a4d68936b0297ba52d880aedaefab128ed7777843fcbebbadb3eb23fb13d5b7ad7acd4a5e6308fa1ea6b56fc7fe17c481a867c27d44b5e58e29b902ce8f98baffec54fdd0cb2eee1a59c51dda6ee054e0d1942eca25649e54d04cdfe88eb9fc8cf0bf42e763e4fe718480d5732ca99ed09a7f2b00ba2ad54c783851b781aa3d623cb6374052f732090bf0a1e61f1dd549723de8466c07ca3059e4d48c8ffbfcecd8979bd4dd56377b63f5b7ee26cdbe4f0b27577500298b5cfc66cd28a01f36c2900d3ab09ca3bf251b054c986479eef7caa3fb6bdc49ffbc2d1236a82d7970f86da97af46fcedcbdaeb88b443fce72156b2ade8ad7a8d2876f7e6b112b8d866e03de1e28a5c2fd7e8a713a4845895cee38069d5f7185d7f1d9e85c7693c4a15b1dba814cccc45cd7ecf7ce79e6dc4338ee51ac31f19c2a5e20c1907ccf4b9d78513b5cb38f6d4d26e3c308532748b61bd1286147ef8d040fd00c50d97020652d5fb307f41901f79afdc1c10f0a44c8c7e87471fa95c0f66b34c534f9259b1dba6b5c3825d1ed9f44ce7ab3e6ea4f72945a9168fc0f66e8eb5a21434d58e2e54d4e6546a0f4c8d187a0108c36ffbbb2de0dfdcb3ce058e6d24bd3bc47a4c92e43cefbe018467633b5d3af43b27b5c8759a1532871852793917ad7cd99841a8c9d876777cc5e9eb13ab747302fbd48ab4b34bd538c2d795513edaef501efa9408ec3c615008ed5f41ea5d409820e595b57208b7349bcd0bf524381ea9acd272320c9941efc0c1c7c538de334c253e3e1787f9ff4db2b9fdbfcb39ed3b76506150027e939368f9e0b5c4730418f9fc5980d72c0db54fa1867c64d7ebd7a89feb4f29f82b125ecd489a8f34de092f538b67b159161358ffc6c1f2c50ef201375be2213b945d485d02c051d4149d0f4ec1b337f5a0c02e73adf34fb93dfc293e481e5a94410568d30e4ad40e1bf849b6749b70fa456ee2eb0e82a1eee47d8251e6ed6adc30b8631edae34d8f17a4cb94f35057f4bcf2bf6b0da0256da8a38241f4f54853577174c54fc4518e2d5181563e61056f50e81b6614a920274e8a823d9343af4bb6a3093393c5cfb2f74074edc2f12ce372c06d6c937763bc6403ad390f60479d9d994db957bd1e6bccaa70fdb2042c0f72bfd2a55e21a52666b70fb8631deda4fd20f4809dc4969bd5b77c39943053b025245e33cfb1f41854a1994d20a259645121a959f6dc40ba60ef7d2f02c3cee74ba4f8917c752c52e5360df11d0ad21a8cd4349e64510a1b27b3708e9894edbaeda3819ca2d45e504c69007eda8e31b41792056e97173fe35fddc3a3680cffe06f0e3420a8d3d83bc064b58438b2d44e1c6ca2cc6878b494576a37249cd967a5bc4710758d02f5ea2c8836f30baca322f5476928deab68fd18682695bbfbc2569527a2d7b263059774aa4e5ee3b2de6d21ce65af31be09b870d7d1d56218c5745fcdafdf39e69856043f621d055a260cb0e5fe463d44fc4d36f4e534c4096a50d2641741474945cfe82032121fdee90272e3eb0e817aa235e8bdabf82da29a3f6e7787f4a000dc20532e682939cb88e67f2f3d091d3cba03f2af7dcdf893f76af227ffabcb6d7b57a4b87d58882f60d227ca6693beafd487d77590535b503728ba4d37a0e995c99556ecbdddb3f5a4ca57fabdb2b4de21e676df8a19f244cd445996ce49b761700bc2f5a3a054229a8e9247df33725c77b9ff5f01a422ca915176bb834e106bb527d8a7ccc5f0daf7c49377b55ca9837e4173fdbe2c912791eb77ac844f01a66229fca538a8cfff0d9d6bf95faad640307102e0a361b08aa46cb170a548cb9fbb4a20a0444905d288cd500a4193a0b4ad27cf805fe7d2dace00c4d3c2bca4c0cc84a6e51e04d2ee1b664162f4bac738025385186944de9038c858d0f5483824059f5636acae7b9b8daebf7a7a3451e60d032325349815b1963cfead6f754ddd969c96907172538aaf84f3065772654d0b8653bab7754b533c42546269d545d5cf1fde4e73e590148c7b71dc5fd45e50131317e1ded3704767b21ad77f4f837964e514b03003e85981096acafba80edb6c4bda34dbe64c8597589cb879d2cad004ecc27815262bba513948e6f73a408b898f80170f6db4c18c2699a5a9c8a389a6a821b3e5b9c64b8e4bcbc8d2a99dd480b83df5bec598776f1337c2612aed49b5c2eccaf8bb10a3fd0da037b842ca8607d7ff5bfffd4a63ec6b8b276ae7a32eabc3df8e9843c08c0ebca65c2021bc404ed41bfba8ab2523b3ae407e46c29af1cf3592f542d9aa57095dcf88d302121056e61ab6dceaaecf29c1e1af04b9031d302fc53a74852de6f5b9f89790d372192a6483134b0f54c5c4a24d2ec43e964a1fa7e5e37f26eca8987ea92d2185af8923e6e9d0d091c137958bbb18baf66d061748c75970e413f45c6e710daceccc39dac6a5cc4b1f112018019a85db781d4dcbb89a93b7684324eec10cca35970f8e6b77dd7edf30c90e76b406d19eff2f8898c8f81c0024d8c58db5c6b84c82f0c607c4638ffe171749f34bf00d220d6bda50b8655e9e56005c45ca49db8211aa4d47a98cdc79ee542a110fbb172c56860c7ca0eee8d0b35f92e238cd757747ca3675eb72a26aeb9ba5465f36a2cb69a9ccfeb455a96e78cf2529bbd36b3ee87a380d30dbccc3e851fba5ede82b9fb48f6ff3746286e1032cb1753251f7d97145706a2e001670fb31e3e8e908217f039bab910e28afb67479d485c770811a10b3901abb0f10aa82e1ec3e0211bf5bc1c546a59a6f0051df2d834a2dee575d925372fb942611d427f69fbe60e3f5a24354a2bf51ad637942d3db79cd8530529dda90989bc492bd619b3083fddbf7339941a487efba5320af93fa306136cf945942f49e48a60e524be06129abddc197df1770035fad791fb1419af634a1e7b5066a2e07056aba0895ad3dbe2bf277cc0bf3ae674873c8570d5f4eede394dc937dce2c754148990931f659709b24a59a8e1d952fdd31d26897ccfd7a359cf5068402895246771663050f49c5b2b8e7029724852c1330998dbac54a577420d10994c936d85175f8014573b2cfac8a2d3f021798d42f731114ec95000b45bd045cbdfc7d35ab9e8045fcd748a3f3c9de3f034e19f78cc5d3c39f5c1b083ba0f036ee2c747ffe678d1047ce35aa4aada58f58a263a2ebca4866abd653ce93b24332a53ea50ce3c01d31ad5f5f0710147a4fab36d73951e9c5fcabd014af94d427faacd71497620085911c477cf9a22837e569b2d18536853a373933520aa41aa15b97629ae4333f227e8aaba31b08cd405338e9f156cbc51c7f84fcea951b0ab9426f7e7eb113648e0c191873f872a156610aef7c6ca4ffcc9aa5585c9ed8704e0f5913b6251f803e0d01476df218440eb1b5b0fd6d1b4bb03e4340f09adec4b7e29dea80184e0927da8abe049a27409a3e090be640cf418684a5ae6b1280a1233d14f28b38d978f6c9a07c77c1d8553ab6a8a57eb151f5f4ed8bbe70e9dc1ac377f8f700cfc53038839aff4b6f50bab029d02c76a405f02a0d47ee5a0435470be95a07282ce506f5a4f156e2f73658791ce20a7d7dd6affbed6f3258c2e5ffedca0e13cd267c5aee499674449f7cdd419f325515fe3d1f5ea535f03393936c0e91e7c616d245d70280d09cd087d83141b5919f00315bee9ac7414e04490e7c8001d765b04bc109c0c706ca961cf66e437727ff3dca4ac1bd0f8222741eef8783fa3a912094a5856f9fff0de2427f25e58d675b045148254d694a737546243ff1e0928bf93f54053385a6005105790b5acea3b6c677b72ee8fd698d305f2dbd1b2fe12eb502f4c58adc16d52af86edb02df5825801da79aeec187092628b16416591e27e926693e1c0f4c9255da1e0dd7c214fc535c59da6c6c0f9113ff9734ec1d188239beb393efe554c781f439870594a7dad3d86f36ea6e70d2532881a55f2483a582b0fae1aa468691e0a85a4c71bac0fb15d684be6957c353cfc7373d44f46d20f92c9c39ed6204e3bfad7f697fda6523b02692a64b68ffb680f1c2f6f0231ced2068281f69ce8942348dedcf75f9304d472ef9fe5441c394ddea388ff1a9c6b28fed4bf42082421591b88c2c20c0fe54d8c974ee52d00b18ca0e5d6146412d0b0686c9f7a36a0d6c44ae93a00af53417cd2c589414d3d17397443185f3627894926b05cb4b3988856e6c6efe6e0409569633a7a93dd962abdf75715f214edafb740f464d914041f43815f883b8f01a1a5c141b2f31fb8b2cfb7d1fac6496389278e2549509122f377388ddce410d578c31026e094d18343eade003ca242ad6773017bccecc8d44d83bb1281bc5056b93f2635f793259f79862551a3d3455897d147e2c34d72b0385218eadbfe8285bd52c4d20ba53c3e4a3a231f949ba31d4fcb22e0995bc4d9109afce966262f111de6a1800509ee0bcce4599e6a2b6c10c55fd0ea688c57c11b70cc2f8128821232577617a29bb2162e32d160c9f31660ed9f010d620df5c68d07d5f43ec7a186ab1762136a0fa9653342449458e5d408723fdbb192b9c9030e305fe996b73dddf26c0262ad1a8082451665fbd1ea8a9df3239a8cfd3030dd323d22902dbc3eeaeebbb9c08e2686b81fc53d7ac55a94fe64f60a2edd00421f0bb2bfa59ba62afb51f8036dd0572eb201074eaa48b1977506ea3252d2cafea16365e26e7ff37df23bc6699e57d9e3a99249b5b4ff202c11ad0ab679f197364c0a956c17aa6cf00788380a71b0f5d330e2b390a85e3e90b6d334a71b865a111a0ce7b0fd19a322267c1e25942541bfd9585445cd0f6cfb42648f58852a2197f4d41855535985411fc2f59311af0879c479d3146922037d668ae88011a4d1565e87ac6da2c0f26885e87d946d41e6bff1d8bc213ba9c49d9d63ac620bae39a9c5e91a688cef5701a40d585898e62b0433c5f389f0ba79af239529aa56d483bff7f1e130cda3da44f9b0c389032d0fdbe412b2e291a2f6badf566756562765263fcfd2259f74459b438a13644027631795bf34f2e9a0c4418ebcd3e79523ae5de33c968d115992d1bedd66eba498a900266004b5f9f31c07e71c43fcd1afbc30578c2d4fbe69fc9db6fb80f0445e457f7c5bfed792117487641ce757d15d5879675c06d40b4177492f0c4145488675f8f86d238812a27295444cd2aaa1faa2bd26262578fdeccb3c204bbd3","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
