<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"618f06378eab4f915002547634cc7dd7486ee73c52df1b98bcb01fd8831f91b7bc80c4287dfe5e5a2c1a9280e69f949b394e9b4ff3f6757ed7c2e99af5becd8fb50eb29b25b1166035b616a67bed9ccb41c95203f65b1cfedbac7322bab3929654658bc5c9e7f773df7df5ba5cc163c66ac7773edaf76440a80a68ed76347a6cf75601b44fedc05be2d97ee24cead004e1ba2022a446e31e8910125f56e04a4ab0055fec7a5b62fa556603d86b5c39dddd215356ac1fcd2f658df476603391bdba2cf7f98f175370e069a7387edbb80a9050a7e3050afcc0a5eb5b6689966fd5e211ca2d319a124e338258d2a34315016a79153e0756fe827354d14d718613d649e14dc2f93a57d343f40657c90f56271e55742244e6dc200497d85219bc89d7d81c3ebea0ebe1c03ee3ec774415f5f1c6848a24816f4ef50926c809038276e612e0b6211b81a4c2cee4cacdfb59bb3615fa93aa25697f594cc36eaf904f6a0d6761496c7aa046fc734a8c65e32ebe36d2527dc3a3311dddb255029ddcc5fd2deceda12bbb3a44cf4718c47a86444c84e45139905d3c321302f34026a0777b0d95efcb7ab63ec579903d92964fd82d08639257bc7ea4d32b3b3961c48c9444be447123d9921795dbb2624f344c0c9456a58cc5efb83f0aa8e250fe70a6570dac6d1673f7d348bfa686e1f1be843895871f405bb4c71f39482d496f3884bafdbbcbb0fd53ad52996c8a6c23fc8e8c71f6e5fe6929dfa81e158b6fd37f3d1992f9fcaa66701d270e91bf1fe890966a011422d9e9b4a7e5019964b83e0bbca070a7c721ca9af6364b705768aa1626a0239359f609b94d3c9685c591a82402c394ba591d26778b8d64e76daae07861170bc3b8fdcf01ba07436b6d6635d4c2489936a9603276b797a5017a49dd9f76697168b57b6a018193f6d758fffa5fc26ec553dc5ed9de6b36a52bbd2874282671615da838500c52887a6ac1c668453714a4f039ac967e2fb66f766cd591dc4874ab6de8f6f0e22fd385e2b2bc65956d2eebfcc1598de8853d2b2d1a43e484811f5ee6171f62f25207ac68b5c1fd5825d9515f2553b7592728d189068336614af6c4072f4225166dc1ecf111481c83e0228b8f8b64835e8b7dc788c1b0464ac1d8df51b9585102a6ffd6cf125cabf8437695429e8eabd40dc31fbb095fafcfcde127ae22a5642d21c1ecade8d22a183a061ac4f354fcd359f56c08a8296e03cd90360482e5e4580458f27ff847b18ebcdc8ab152aa0f70e3225fbcad0facc5dbbdc64066124b1b885c4a731521a517139867e1c849507c495d9b762cc397e259060a99a175434048b6917a312f79b287d0b1c9fc3c21816e2599b8abedd8685dc6f47c62c4a9d951f0af296dd681f2620ed41f04632b648161c44f72c1630d48c06c03c69ec8b65dc52500d24cf39b2627e51e0bf954f6fcb2d1789330de416b49a4ce793e5bf780d2d47a10115652ad7152b9a28fe95d4ef68a2e7e23aef4101f3b442d9ba77435a8f9c920eb153553a3765e79fe953d587a2fe2c5b51b293a1f6447029eab2faa1c198bf6250a7d94fd99439634f8edbec625c7da750dd5bd8393c1e93eba2ca87f7ef2adcc1c460c0c2344d08830f20e322c4605562c7bd2043d48dc72068a26cfc738429c3e912a0fc3177eb1ad50b02d4b00c55e20f042a735b520e0b3affd6feea2a06132eb5ce4adfc2acdbd0f5de4fb61f10e65628868edd3e51a8e5bf806d76fae4919ddd8467b73da9ec839b00faa48eb27989c003615271c43e75b983e94bd986641027cf9a5ed5a74bd40018eed805c9d3c31da179d3b096642a5ad050e973ccbbdaa3d3a3606422b6dd66e234588c2e8b5b31fe13af724313e65e387681f0cca0861d4c8805176fc27d28c7b44797d58f08e59582575d3dd0c12edc7908384dc50e60835afde4e1863e246e37360ff2a965359cd7c7c25958eb9662c16d4f2b65df983e2734c82f2d0e95bee70ae87baa1cc8fad372d3eeb7a0f7235d9fb169b0dc6fbb64d7e77c8804776634759aeedeeb63a2f58279c591d9dc5ed2e34e30a28b12c6fa2669b4380208d4fa9c05e27f806b83cd47592af0a2baf0fa76cb79cea4c821e0b167ad4b2f685b804e358d81beeb2aff7df88a67ff72829658e017d25a476e0884b25c47f9017aa7fc8366be90ffc9b2fa428b2faf66646629c7f7e8c17f66a677cee3cd7ddd6e3feb6e583e4561bc8c0fec08cb1b2a206bf62664f5859fe10390b5733c548518cb36aa204a745192f90ee792e6312621656576b9c1cd2f508347a4393ad66723d4b3c68fb0637d792eaf3fcd77695b40f3328ae593182a5c42ff4ad2efad1484d29b800e707704bd0b9e37ae999c53cab97d8d86dc4773f575e3aa87e89d4c30b5dc2a030944228d0c04dc4a3f15a860d9fed961e4b6661464939274182a02a1b5fe2a49d29debea979ec32bcd6d7845d12fc0774aefc79c95c8b74ca50444ec99a6f8f315e183ce307d0d5abbdd047c20aa8f7eb12a1eb1eee72fc6f5223d53fad938739dbb9abadb6dbd87fc87e35d32b754e5c6bee830b5a6f1a441bfdd8147590523833544e38bd7b7587b8a3a971820d663b8ded2523f7e274222932b6f73fc620f08ce3a19ccec66622030e34f65176c7454196a010374fb7807601fc4df2b20c5559f1fd1bf0cf685d99d629754f3792464f0bae2a1bed9bfb93d065f6b401d630a30f155ff9390f767e6efb72453236f61e16312247ced2825898702df3b1a6a87e3e735a5283dc9593ac36c9754923b16f227b72fa9d99855bec31b18008f8f22e00188fa017e55c12e5fa61abc75ac36ee43a6550a680c7c8d36c2a8510c2c3d69aa87f88ef1c6e4fdd70349e58669c6995b8cf1d49ef8f34a6270be48116ddfad82c1570d40ee068d39ce96fa772be10c331b0bec63680cf4befb4868970b3b856d5137216985e93431e0a646c728246c7db1dd4c40791bdc09e7e547ebf6c291a282f8b311fb89ad11252ace0c6435d26ac1ca38e4ae64e72ba5895b14528cf54f745e8aca054e9dce26f2710a4d5ad99b39747e0fd2714dc123a4843f1efcbfa9e9d582c682527544df53caf4ff021b9f3e0bbdb58a5c5b3deb9a4b3417984efb94a9fcb4292924f1c2ffa522e18b4da489199b8eac25c2f33d74381ec1c5090efcde161d1e8a0996398c2540d6a05a7242c9cc11309cf7f2365dbec15c245ee9a01f610cc9fd47a87e1d340fdcde40dd46e04ab7a19aee4b90c7706bd5133c1cbce64820860204dde5b0669b3f67792c546cdbccd807477e8cd48b550269c2dacb8371bcfc40a3e4d7a6dd1634a1e997ba743c3057193bbe25d9d4e0516133c01fef6e1cfae0be83429c0432a441806ad19a1b3b0d3607edd489e43ebd5988772f2922bbb91c27736714c04adcc965aa09894d33ca0266f233e3e6d1bf314b135da41490e8368cea0c76a137c61c5fe49fdd2771517601c3681505999ba98489a9879694a0c65174e724c0e4d7b9951af2cf10112cf808085e36da5b0c756d13d6799c17899abd04122cae0520b60fb9c5cfaec740acf1e72e0083208e21d832346c723bab91413b18d6cc0e8492e67685066f09450763cfc30b464ee8f6c16db67932d1908147dcc99108b14e7c574a0cff2159bd206177947bd7f4f19186e6947ff276841972253ea72602d7497e3e9e92b1b134b334ebfa552a1df75acd18dc33c2943e64a26f2959d065a4ed80362f46489cba0a1d8a7b0065ee1a05740234792a92c2d232335a6fe0ffe3ead25ea64bbf7a7930e582e68fa8a5e7cf9e03dd9d6c49f2f0d8f55fe22169d81e407e3d65510e134bb18650bcdd6f4804378a865faff4283422aedc8e8b0728a40fd6354a71cdda972f16776e95502ed05fd81becd1bd7c85201ce525b6ecc82177c8b611b1ad42083d224a8df213e5843bac3575740dc4aa26bac79da45df46d06691bdbf8a0ed248ece65d43e8eb8a8d12231522c88db2546d38399cf21fdb620e2408f6bcf3c0959daa5e8634cc62024db0e2542549af748086db147c17733bfd0f95227ae40cd9634f151e886d6f278715bb5ea712bf2b66b8ba5d8e0870cdc68576b976656a556fbcd7c018aeaabdc94ba95cca8860f15a11b21c07ef7621a5c70130d70605c8533c4ce7bf163423386367969a61728f6c70c7e8aabb669cb525ae6df6a84e65f119dca353976cde697584b3db3123cd49c742d0db49888f5f088638108ab7b8fd489d38a6a16862da061b9a87ef0bc6c400d53531f880d5ff1dedf55d4cd5d0bd0aa9c24b82a75db15f1e93ea7336a08029d6f2e3fa71aad9af3761a5deea1dddc04f4cb6fe20e0ce35c0b989cc76f20c043237cf7e3e77853a23288759721519f05bffa32627bfc5d9e1f630204940692fb097ab779f5b3f6df666d5dc6d11484e9522c6818f748596b1a65d6156fa9f09070b205ae54ade55ea41d3ce490abe29cb4470b113ee349dc84542ebf28f9b6e6cf6cf8200f1b0d24eafaa2ed851e0eefe5f45dab87cdf3e982033246fd7a9392664a6ee502a989d69521e541169be8270e34f23de56b1a99db98521cb60acf82f46ed39dcd14ca3dd35e47357215581c8bc10a2745c027a3af744de7b311f69899551d6fea5489bd6fd2a5d736d7b405b32a2c4f0612c2c98418be09b6484905501963378386da37473cac13cd85d6e7bf7ae070f3dcbdb96cd49a770a0286e92ac6c0d32d83b216ee29e3ca9d41dc066258e1ac114e55544f753b769388b7dc85ee9153beef5f6edd53eb1247c48c1d1c9f35095cbc574fceeb23558e23a8015fd115e0c01df0f65a56296fce3a8cde3a8c60502bbd9943233e6367650d717fc24f9a33a0f0bee27fc6862d2c9b463e3abc80e5b65dd15c64a293855066cc6fa795ae01f458b901a3af9939f2a235eb1b195fbe2055732756a7360a21ea6258d10fcd627340c5a8926e0e069dca6f803f466625eb9378d19ad7d973834abbd99b5d7d33bb8bd3e4501bbe79a47b2328b8b403f7bbba4fc0f34e95d17df20f97f38c171c951b987ba075501630b9476136cce4034ebc3830746e1d7236c2b0f8f39c771c5d75a4da64a0afe2a3225b9a29736d7f2fa3d649ade0d358bbdeeff6e597d034f0f50a9f179fe793c6a530ff61e9ff10d207dd23206252c9ecfc8af3af68bc1801f8673edc9773d6df1fbdffbdbf38207001f743e5e1d49e5e7d7c6f5650f47407e900a1cca23ff46b138f5ed425a044c55764cc3e0e0048d3efbec89747d168e2c2351d90260062bd4244cb630ed16234d7ab7ded042c5f9fd4c59cabd6835e766bb7cebd014eea38d6e3fcb87ec0373baed6d9c196a5776b7725c4df47dd8b6ba7eaf901bb6d5ec7aab48348edec7c351bb015d4932dd7ffc3245e215b94002f7e8e772d0b1a7cbff7e1e2001ee175bcba3c5e6a5f3264252fdd2bce276e910bec78b3d7216adbe76d2518b7174be21c8fc7d45240c8bbd5dd7a8b12352a163b7dfc457bae8e0527e09494941e04a56b225c31b0709222b2a0bc27e04ebd225a5dac670714706bb667fdde3b44d17bfbc69f41e5d3447ab699acb719c1d98f1fc6bac79a5b3739e93d5b88eb04ff89f549c163336cd04062c52ad343c0167b24e0592c069f72b2acf1871ca460b60e4e6deb01aa4c696dd663df1bf4d5662b1ff0c260210955435ac627c8563f0c27983bc8e85ec0529a4ab1fba5ee9f922fb511db6e07a1b7d689870907a74d21948fa42a0c3db985a9262298de53135f602b9dfd7714ad80c0d9bcfe1a2e27805f56072b2342cec0076f1c009324defab90323c7eafaec45c9880482d0462eab245b4c27be150b17ef563e9ec394be09bb340c46bcf88b5bf3e9a54f3efa819fe6c558ed4d936b54ca0603a2b0b5972b10623d6fa3ba35bf170df6ed1c82a0a394f70839e2f0fc5c543595fbc86868ec479802c7e4e54f5168397edf380eac21081bd974595aaefebdd031e9efc529715aca4005d4a36657adb1ba860a50db76903e2c911cc5eacd717ae0a859c87a853c4e0345717dd770891ac8750ebcf93bb6cad08c19b1368483f1fd8f0286f3e52735d2e4695b59d8bd39d6ea2853525a88f8cbe007c9ce5a7a8890c0a7068bbf4ff786d8c86c98a98e90ced74680ebdd251e333824013feaf8dc2b17177c122d33c0e3a7564e218de282ea01dd26dd8c2ebe38ffc643957ae03fe0193eebf9d3bb129ab1763cd81a736b986613dc741c029201a458f34be4bd6592297dc40b5474d5189a0b41961bcc0ff511b586885c59bc44289fd9e6022e488ea9f5844a386033a599878dcc6bbe520def4612bdae18b2e32a789bdc119fcb437963d7b02971e8b9b09953ed4f62faf52c6f1ad51a0e92fef8f0ac5892f4e5d303a147e0264a26c615019f1963a27e7440943549ebf6dabc653e39e8c81992ba0c7595876c7cdc02ecd5ad5f27685c24fd91e87557c7b40e307fc024761d052c7662f3bb798fe1c4b385bcfb88557f68d768aded05f606685682f039f1acc65f6de23d28db7a6472f97b053aeb4624fb42e55ec7ae9c9bb4ab9c0f66c1a1292b068d71ea8ffa370faba8aa5e68c2aaa9df590abe116a5b4ec9ee50206bdf7c0959579de7e848789f6ef78730baea78f7fb3758d0b2c0a6a2d3bdf874c5d93bd6fd0b38752b33d9ff7177002fec00c4b7535fbcd0e29ac23b425f29e76c73234da89a852409422628271e7602ce694e894bcde9d17971f397b6886d68de74930bb7561be7e7c2ee9a696186c430e31466b33deea5f8dbc44dec0d3785f6e5caf591b9deef87e88d371f4665e785c94a1b0f436fef555d6b0a27ec1eaf9b516cebaf9de053e6eb594af071a3d61c889b3833c62bd0bc1cdab4546e753714f0c83071a6e970418601fb57c7060a858764d9d63b6bc31d0c86694dcff4f4bfa080b63f3f2c841e41c783e0a12f5332daae0c70cbaaa8398d410e2e350965553d9ae2633f4e895466579b991ea3cb7a0711e1df509c645a81d03441281543c8dc9ac54bfae5539b4972c5703c9b745987da72b38a072e49cc264e30b9ca526e1ebdeefab6e80c4c21db93e197dce97446206c1c0536d154635180bcfa85c8f36cba883a814b8e054440b51c42f15b61c03855ba53dd44ef9fc348598532065787b0abcdee30601d087630d8aa26875b7762303880e8f435f55c883165b3328a45edbf9c32106d3a9cdfe67cbea0ad6725b5fcf805bd7dbe54e478544aaefd6f8ac58bd4ca34811d7e11d34dfa65bb0388fcd4c28dc3bf2d324d3dc261acc93e89e8d321d0444a7d91fa08aa0210b63b27598cf26677e1e0058712dad33a3aaf112b9683957ef524b2ab50ec56ad35373189efd14688aa2d18ec4558e6e4e06b8eb0953e4257effe1acffbae1dd321b9144d3033d3ee82d5b668fee93775c44897f252f89bcf8d059f0290d9369aedba96c061e259f99218f1e11e1aa245e6f112ff65057bf0f2232b05aed15de552f6ce2765204724022efdca993dccf9a8c8b64b41bdb984a4500ef4804c79766af87261b2305eb14b941e985575a701b6025acfe3698777b24a5c53866d89d83d33f7e51b3db850c3c13dea1bd355a4cd3dd7b4c57d1dbaa91b79e7883e1f11017eceea35c741184993d2b69dd8051be20fec83dfbdb9bc12259a1489b7dad5b70704de51e595dafb88f7b1cd24740d011604d9cfec9781f7485da4d4b1554d13012117e4e046189d897fd57676d1065ceb07cb0ca208fdb5cfe2ea7c057dbda7842079f498810127b37f6389a1859a76c2766d2b8c4008558308762d38ef1f548b6a92fcbf73597c7aa03e866429e1260c3bdfbb44c047a0d89e127bea9cf6d9d092496141a71fb5818c60f30b4690c66aced9724268825dc2d32dd928e83c70b8a8ade007ef06a81d2f575b02cceb5ebaf938c9bfe6caaf5e9edabb68c3eba8262c664b034582770a3a13dcec79fa1561b745ef4f28a5dfd6b83b860adf6bde10619bc4b0220205c3bb97f16df0c3f62f383a0060bceb7df18d8dea3f8d6b0a3b36874b43a7111a74c48d4ef2032261dd9ce6c78c4fe167a60149554681d92c72fa42e705a91b4d1f083fb32d3c0016c51dd8cf8a73d0a7fd55355d3f66b0d7ab3373693cf701a5357c25e25bff0f03b0f4c408172393da2769836575cd761c993743c69892cc754c1829a3ee63b62c6ffa65ad4c25b03426fbc8b1c35b68fae9dc2d8c9c0c2d50baef6a878760f36e8e9624eb4419d58f60160896a2062d91b24b69791027044f9ab544ce07e9f674ad836bbfc45aae920030b6ffc5c198765502df73c5958f42508359b0b115160f3925570e8c8b198c0c1df0209f51a711ef0f9d89a960b4a8066b4105bd973fc8ad5fd42e8bd16a5ee3cc34cdccb3de5616fa340d3c1abfd42af2d82bbec4c9656b43c18af0a384cfacc3b011ca721f89819497ab3abbe95c100106a435f12266bbe0d0168a47a4af0861515bd9c79f529bd68be8dd4b74d8dd439d1331b9b667ff887e76d994ad26a26c1f20b47126d1291607b7a5bdab7617999c2290d235c3755f33ee7837c0a38ceb3306304102ba32a2411ecd561974e1b8712c1e4e3f9fb1c415dad0731f57edde4bf615ca380d7f1120324f45ace69000bcbbd3377de22c9051623c54859af4b842d3db6dfbbd3e7e67d3338eea9d2167df5ae44ad22ee4fb6a5cac742002884e03330e81a23b1011b9ebef79abb06676370cca3614c93684df05106ae509e194e2e412802864d91244d945a9a5c3a61eafb9df5665bba648344341e48797042c50f478b5f1e16cea271bb7188046975ce669440b037a75255f954d34f5fa1e49cd3b1c603db7feaef4ca005eae97d9a59a7950ad495c3527276ae3e219ac1260abade3601098a7af8d797328919c91d746ad52656745a8c862e6d42c1f795d9fb64628f4f7719e73917409f564d3c1a660ddf3d2fd469b2465f6d7a063b7505f83e28e51e781cd8f7a06ce5604b307f32924a31f0bc80184c3f61accd1c17f9a638f21b3a9e333fb80243ade2c7ac9331ec0970c51b0f82e6b6f8830ec6640ef5e67728646014a018c860d9bcb4c239214e3172985cc341ad24add60db95a9c4aa9e372880620417a65f17acb2007f56342372d7a04ff6a3fa7ff9202dc78b7b656ff815beaddff77076c59d16c90c6b4ce5ccf5f668edb5d6fc9ec09f8ab838975efe93a8d534c1d61c3a729e09e88db450f833899a7ce30f5e3a849e15ec6474b6adfe6484c5309b763dadb5751b9fbacf25048065e0555fc10607d4174e3e140acef5714065118681d81daa79fa5a3da8df98014273480d44ac0d9b31b54ebbee0673381c5cb18c263059c8c284f84a934206663a37d6673b68b8c01886e70ed925081d28f7ada7bcffa13d399e900fe099f51f5585f0a9e67913fc24b42b9c9d8ccff4d806124dabd724cdaac943c8cf0f1b3b9f94c8517eaa4ad05ab8d701bed61a6bd3a907ed9fcad4e734e2f23b14636e2afb3286caa9c4775cf0c6bb05c6719f19a888c85d17bfda8dc38857a606f4e806b7831b7e9201e0469bc89468f4bb4093e227cccab570a07797432123257ff2e50fd53f2f882dc0d317dbbc7f30fea601ee6648815338e6433b340bfb52ad5ad2418d53bd8c23ec56435ce4aed3c9918987e14bf9dbb88c70fa15f4062b5b6b98c9313a9ba2afb38a615b4a30d55d05ea8fbdbdcb3b7628f49526fec7762ba4550384ab9b59024e61ef2c93bdefcdea5fa0644c7384634d8fe5f35eecca4823d1c10693117168cbad8baa339119b9ffe23dff86668cf796b4421fbf63eaa009f633e8e3f04fb2e307fe1eacb809fd8f810d3857a217289008e7c6d010fa8170822605fcd08e2a7b82eaf8b9bb46973ff1fc3b8bf769ba75098d3e0f30de75e279d9557195d24d0d94a957b1a30fbfb08aceb68c65a67a2d50bf811909369e4c0a01416bcec04ca2c69bdad3f133e93d6727915037fda65768ba93f52f00b5ed00e7efd381f6adbb7c21a16d1431fefc21eaccff5af6fc21cc16f88d420cf8f2e36a0bfefdaba367301f350479774c310f3472acb401d58c2d988a3b87c3b4847c247263994d203eab299e63e85ecce7b75fa9a4b558f8901e8c8e6b50f5d5aee8110496792b585ac71b94322775369b4cf17021d3ab17feda5507866fab10eaccafaf93b7ec3f2750049184dccb5daefd5a21eee5a7b028488bd75e00e3ccacade16bdc806194eacec6914a6184ef07e17a8e32140eea7dbb9b0293a90d520bc5d3cc36eef9dc0a29228205f0242cb9e77711e9b4f67d4b0038e4d47a19c96f68224562f3f75826849f800233b0513e46e27fa9be5336282ac0f009e71ba9d810a77f5faf5f303933113e6d9c56d32b0ee2587bbefcc2d489662fcf4b50554d94b5b649630eb8a9648f27332506148033ba868230dfef444e3c8311a99c7bb9bb27fecf3cee878694746862fc5829731e25cbcd89a0bbc322aa04706fb91f67e7178f5126085b964d96ab03b7799b0ccd919e861542b37a280f4b7a7ed23c5fe6e3102aa2325770edc9cb40be72829847e31f68f2f352997aa71c2a57aa33d4f355f1debcc7f9ae99235921f0e00a3041fd74fb029f64b840aa1afd65f84be27b49c6a41c9a17fe07f2681f415d9d02ad9020f6c8152ecf2a0960c64db2747410589b33b32d5f8c5c33a21ac14dc90abc001f7389050b1a4225c608d1c2a46a98659ada1b6b77349c6960d61c709cde55890e3e76aeb9c10ea913490ff6eae7362755caf0c4ec9f2af56fbbfb5f537524b80bd3b14d58929c07a26530ebafa3478c6a424703724b6804cf39bb389218d77c9a9a9bd13272fc43b9c56220520bb9c99de55b8647ee16d7ec66aafa4b4b38f4fc858ef0d0fd2958d2d7a24cc8e0f3c886a1943dd23ee5d0c34baa82556ca708871153c94460118555dd1d8ef3ac393cb70e20f1f7c30b606f0a89f36db9420a1aad520d6bccfc5182de117341097bf63b3857104d9266e71f8f762f5de69aa6e181593435c84be22b2f3cacd46787e277ff50803bd50d260f6d761c4b4c87bca1f5545ecc2cedda3d0079b3d61d96fcc8dc3228e60c3cc876fc4afaf830b1cfbbc28721b4b28553b32a0cca279ecbada8c84e3827945588c9c5a200df1ec00d50fa22d976f572f425f0e877f91675273a05cc67d0c449918eb8ccc70ccd5ca54bf11e7b4386a88f079fb98b92a8c801d47b3fa236ea47df806d3e9662a28e365ebfab04b3f54b53236f21c0116d746bde328c89271d78664e12efc5cb011b5fb42467dbdacf48fefe8b88f37a033f60d40667155c764d59bf00077a605ea71b40a1865badb7dbd6c5a9d092ab5d87aeb41a9193105a6da19894b70c42484b6ba6eff6c4b372edaaa016c6ea8b931282e1ec54fcf6009e05b7235587babf9a9acf2dd03b53c8bd15a9d3eb1e1ab8eb0e2454e66fa62e3d76de0f037bf22dda0f9784ddb5712a483b0e513e08931ea6d349ee3e8121b12ef19bd361df50343c412e61cac761c0b5454e1c68f36639a769fe700f3f8303c6deb08b140d55a9d94205da75c29b724d0f1c9b30d5be7e7e75d2d09257f1ac0ea7da57f9d6774eb01d3aa30255ba62dacf1031d5884e366b201dd3af47d0e1c8cc82d1466f05bd865bdd34de4d69f7a3754ca5b59a77feef3b017cef92009b202a6763b41e87964bb761598f03e45eb09bfd081e42d39429ec5cff8e5374906f936c344297970dd766512449c68cf71e93c34f8a8fab0ee2296e470137e53e03a1e16da5e50938399b69f7449810528dfccbd602476edcb25bad2253ad7303a99b73b706ebdefa184647fc07f4c5419eb3ad65728b299835df3a35d5ea7c88ab2a8e0a860450241c41dfe5877cf787960d96696567f2d458c3be9ceb5c57f968d5507e11b7a51fa03a642ef8d10d42de99a7eba1da2e3a5f99e730992c5392a6a2e7f8755c5b8498d1d1cbe59c665b3ae931f6d81b43772327db2a45db07313ede4665748b997bcb9cd7b194b16e9ce0e139f864150703015cd","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
