<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0511224e3150e82c3a14937623c888834c338786c00b360857fda343314e7378731530b0d50d31b11b0b78c60b54d646b4d8367c28487574d56ea1bbf5cc004a233d9c055df15d43c75bf42667fb9ab536b6f385a8e5cb118224dbc0e30185aff68ecc695bb23cb67ef91e07aa906b957a158d3a389668f91e23895a83dd205531b1e87f3fff30e1dad7c3b787785ec03d5a28d756204cd04e236eafc6a65e8f8426f7223b6e42ba9611f9eb1adc47acfa6936cee77c3b3dd03a7f58bfe3a4d270b8853c5fd52686e919979221a54bdfff7e7eab22ea1e5ceddcc83fe6521d5e64c06e26a891915e002206e124435c78ff035e237080ec5efa93027fc65cb09f0d1be97914888707ba0c9d2d51059cab92a597a9b614868b45662aef85fe5d28a6035b1e78d87920f0377af5bcb78ee7eb36db412a663706fb9325d821fda49914631ab194acd640e6610eda9b8669ccdea9e44a2cc2d01f91a203198c1ae1cee6627817dfd0886d289746014029813f2f818fc8918817f8f94bed790d5452d1c033d791bfbb5c9c7f1dd7cb90c85931847dff8d60cbdbe00843c86f3b09be895b57d93eefa994183f3e0cc0d59b2598b828e9c3af22bc4c70bb236ac6d6a42cba9520234400c8d571c2591e4c6fa07cc216333325fc30c6ccea4624001bd7bf7952f5461e35351fdeafa290ef2bb317343ce2420a3e6ca2f35a0ca731fca204a0732d0562d3442a38eb549aadb6578155d6ead2056e1215429631a24e1384146760788d39ac1f1458ae097b202e0b25bc5c0e65ba4c167c34bf5c3635b70c5e9ebf2539d9968022bd5c619c9373204b0525debc57caaf17f0afc71fe7032a4bda884e77fdbf3cceecb7b4c75110fda572b0c9bba2c2edde8d618937c33ef7bc7eec2f66d561a00d9f9be808e227a6cb85e0fbec7fec00aed717aa92a731a6cbba683eddd03a92c3a9caf5450d98221ddf75914e2e251271faaaad78151551cd24632fbf8ed9974d72d5771620ddc4b2bf39337bac332f904f18e6d496c546696e87945be1d9b9a1d045e7d0ad820b5a80778e955008ea83241061c1f84b718be373c07f56b40130d4b2d3fde4fa5dfe5292596d7c2d425a1cb001b602c5e04abb15b5b70f6b17e6a71a73ce2c61976fd96e960297db7935e0fa61029792bad4fcd0c1ab58ff33271dbbfd28a76bb39caa74648afc28bbd76359bf41d2a00bbcd6525368571c42dcdb64b8f48401af272a2041d4ca98aeaaad3a2232d3b1130faad60ca68e5de8820e11f44b88672a802871865ab12751570a10ca150c871254aa42cade2000978df59de9f63b9575be3f9303ebd5f1101225a3eac3e772bc6eec939ac62246365d6b38e5687ae12f8943d40c5298e0acc5d144080b7a8d7ed8b2c2d4c046b7e5f4580db423435b7f99216b15a1ba5205bfe66597e5b7cf496c8640b52806bf5fbefe5c5e6ee5800681fa92da81c7b90202b825dd37261e5ac38a5c2497866684a84b94b18006bcdcac31f0f257ec91ef970ace85f34a1ae14c9cdb7bb25179fec0cdecc4c95fc5602479ca27c7a564de92d7529c508d9437dcdd89e3755ff71bbd8c6f6f8a8f651a4e75b2b01a3058f6e351988587b9d3ea5138eb575d5a6b56cc3e140135eaef39663cc01b200433ccf24683b2ac036448a8c26948ba6dbee6ae2e087ff8715232b6d3b86810d299f5adc86a9b4b24f0162f93078ee46be996364f96dcaba77cc47ceaad739f47c190d01efa880fb664621f5a426c63e5a19a0f760382f111e884a85e019b691baa7b56c288b89385861f8a20e38a23f46c35911607c84c9680e3a75c98566eac24dacbb604d6e58f743f6bda7ed620e704919ef4f2e37d2deff018aeb3a3a1b5398204a83a7cde3e8dc637058fa4d3e3f53eea6eff27e3e254d42c137c205e6ed3d829de27146373bc08e554934eed07f27e62f5c4c651d64c0d2f3d8843ab4cd44086be1f9a61f5cab37f10993a882bf63937080398ea16c98eaff493b0dc2c5076a0cf1d2d10cfbf7df675ffc7b284359ff6d09601071a38a97cf841f970631579c9570b73cbfe0d9629ab1fee0d8e82d81cdef02731a1b84b3be9cba6f4787cfe2da05093b440922e701a83e3f35496ca5860a9a4ceacf755b21193ff6c7313fcc4a321333b44a2e0e7ef746331165b655a9043ddc50efd323de2265690d96f4f5ecb92781cd7fa78f853fe6ffae3905a07b49a49f3ab9e78b37ab3b4cb060366b3939d2aa2b8d10c270e7fa288622559551a61121740365438b720a7294e786cb2203e8d08b4493fa83ff016a7b7ecf5e0791c900244f85af689e0e13db9a67881ffc91f79a83a7033f9fed57275fb957fb62e46cafa09fb005493c7d836dccea5c465c9a159b411a5ef5e6a7bb32b231eb5428d5e52ed557968b0b2530eb4bbd1bf0a3f96aec0d4ffda4c65780a2aa229677352381bf414b044bbc0c243ab044c0b3859e146a0c6080955e1030a85c2e73eeacc9257541887a3bbf0307e4544406edbb3bd4ba63f86e7415d624cf37730bfca8e83c142d5f87a465be0b2bacf5d348c84138d1b7cd7a7b38fb2ae68274104b7146f0309cc35edfc4744cff5a351df5c205af965525ac01d87cca6df8e296f6c788386ae8f9ea362e241f05131665f13d1cafe72ad3e4822267c1e4c9cafb990df19660a73a575d11059264a09fdd50918c9023f030a3366b692fa53e0789731c1842839e8f22522f87d29bdb4f9c4400032750b76b68bf4228579768145a5dbb57732abd27240552545d32cc9f26cb89016ff36530b25fe0a126e38f3b434278e976cb11036e35fb307429a038afb465932e416b20d3f866173242a70e6537079fd1ac367249befd6a7034ad5b592a307aa7eb4c54d0dd0e7ce718574daacb68170d7a2f512676225bb04c0d6accbe3298ddb4f4136b9af92f76e871d7e3e1a89632c453ec61a3bd4e3377c6d429743dd946d1bf370b35197c82bc3843c91ef9bfe73c60112e3663f0db56ed9b3f9694f9e6b654cfbb20828ae60b44adca920cae00dac10269b1536ab6139cb8e063e474d6e7cfb5e6ca4d03e0dd1173d84fb0e0b206ffc35fd44f0eeaba2ecd97a16fa68883b9fbf6fef8b269693b5685c6e9fc6eebab3501da07a86597cd0dbfbc551f52d1c09177c18c8484a1792b9598ad8be3b792007da14b0ab244f2d5f545947a542120ca4dc51e0986b3fcb431f18759bf734f9474d48549f6235bcac53aa69986300dd40146805f0f62a76a2c4fa9ac3c7aa4bfd05283464952384bba3be02ed901b322e661bcbcc97a23776a4414c8b4feffa4d2bf77b650c1be913197c07a45fdb9d65d5bff040dc230f917c6118a95fed21d1811d0e8cce3f0f9f4dcd76192781d0d287df7c29ae372eeb1416ac7271cb5b3b7cf2c4836b858441c78fb4fa82513fa818d34d9dc6f9e43fa1fb2f17ddb1bcaf761f8367dad4558d7d839b994a2a88e4d0f719720cc6cdc8d4397e1d53ec4547dec3bb3779145db56cbcadb387088f65e5759b497c2440e7984edf68f5a42d7bca8b662bad7cb3275431745cd601bb51ab273a3d2d2e556ed1d4c0419a98568cd190d31d1cceaa43a41d522324d10003743c00a5d7322590bfc3ff955148785d21a29ad78397fe7296cd98462c7ff38d5fef9b46061ef2fd32e03046efc11a1068ff322b8c82d2f30c060c55c8058acc43f84ed1e43924f9a28ec448e33609532e1cca99241d251145a0cbeb78e9e93b92998d1b5be45ae8d0b9f94d3621e39662b7709e75342035e9e236fd72d567f540a28bb7261c32694ea281d46915f1bdda15812d8752a373a3e2e40865444d7f9d2f23ba462b26814ce7b163336fbca5c261e78e9495aeba200b8ce6faf958246a9d270ccd7a9f5ebf1721e2aa89d20cf032d9d268cb1de9b59b1c717a37b06bc19453e07f00ffbc4111a6b58b044523c6dc852dd639fc16b9b6235b04d5995e841944da5cc05dccb2ba5ad9b330b6dd7c455e00b8bb985b54c066603e32a34dcc851684b3af47cf7773de7327590600bd6dcfdc8deac88d1984bf76942b11254e24f8eed72a166d20f5c212d54de40d37bbcfb2231b98c781e884218d9511cc9fe607fe860eaf2bc1a28e1763651f89eab4978e2a5d17be6a5341e715a6b8348640c80615d14245f3c3db256413a759e96966c66b82cb6e13ca02629d345e21e7c0d83e219f07e49b11efd3656b7858ffd496b0cf6d20924486b49b8c6fa407319cfe922274faad4e5ff8056f9bf439122a57b74ce997e23b7cdbe13f945dc5f52ed6c74905853bbe4445ab2ff282dd7a0727891ed72100ae3ba3019e269f2bec3cf943273545679043821a24124e9b7cc54c4e18ceb90d5dc9af3b78475794418da93851747ed64788174e38c64a05dc45286a09ff67dece0d38347a3bdc47b662373f1635fbdeabecd4f52f0b3c9a7e8d05fffbd7fbfb745684c9b9c8730bb530deb9d43648ccb37d04df8bb481a5bd45332599cf4415e57f2e641260bbd32eb08594bc585d141e383d6f994387b85e869f7ffc8f93698b3b703c7777015ac84abd25fc73bb920b7dcca2696655284a71746a1369933e5d8ad9b48403c2684ec046e7586314d18efd026d114ec3f59693357664519deeba043e7bc2224dcdee75cac2ff7de06471de63414de9a6b0818895b173126e39a4666cf68f0fbb775732bfb02540f15e5b4dd0da6bedb8a5fec09777ba32d23acc215b6924191557811db074051ab7db86ca4d4a8f25e8e450a1260334c576ce7637b2763739e737035df669bb99bfc218d82bbbdda1db2404110c4973d5090c7ebe7a86ba01239d74938d2dbfa0ed9bcc3ee679c5fc6af16751a2833a6c6067274518a95502aaab2d2590ae404efa0025a6ef24887fb0397db1fd7d1c02bf31cd550d14563c98ceb7d4e68f2c3163816a56c2573584f2d38da298d213d7ca23ee88bb83bfa986980e917c74098f476e8eab2ac20b4d655a187dc8b17cf56f98c70d2584b2025e2bc093bdc33bf6ca9b7fd7fa1d9c48367f6cc3f3b00653c69f827a3ddf8f7ebaa63352c4e65bb0289f8db4661bba2f519ea95a98fa3507a2ccb1cc38f3e5bf6dd45668101a93bdf8f40993bf10279ef41e13c0ad53d1cb2a22484f8c6cb0901f4be1fb4ce5d3779542cbbe5f373e8d1863ca1672ba583ab6ce2c40fb02b5ebc560e3e320e67fbbf87c20290a073c147e1ac83df872b61ca51612e16abe601b7e2a40fbfbf5f09c2b5aa5260a0bb107564ef9c4be91eb3c1051d3a5ea9231900047ea5e86b523e032418c53bd5a7907fcd7268c9f10ab2058e11656ede4418b3fca73a458bc17b091751e0468ea9bf2f4ceeb2cbee263cc1fecf6da53aae71ca9a163772666edbf24ba976750fad51265969635a4862e7bae5177e29d7993e23213492ec46c037ef1d8f98a251340f086f247680a1761a0c0d2092e2b549e4465754653d3f968bfd6f213dbfc929108860dbe9aa10b5b08cf2d47b6fa0127b8e5d7163d583c72632887e90129a137b3991807c193e01daa4b527be58060efa98a821224446b759834b3a7cd4f6266cc5a9af097b8531057f3f4582f4edfecfd983c1e761f566d593c38012bf96642865e1ff53211f7ee469cc63f5a9c3d03639193c618f233dba421c61383eb15448ecfa9dff93107bba5bb151cd2e866493e9041280f9f8900b0e49af161820179c029d68948ce23fa8d5eea5f1b235918b58c48f7a9ac4a37321eee9d191e9d0a3281c101a838b156eb2fa35e2d0c19f626fe84786e45d88ed964c3e13ffaf1f3536cdc7b491440544e9d721e82a3112d4f85cbb63eb1809826d15e21fe15743aa7da8f61c34d732b18ec6c02bcfdfb76b8715cc1834289b24636420fe2402911bfe46f6776e739204ae4d098920089c5d7548f843cfebb30e7f2f9957281cc45bac76994593b2c290cc9240b2de4c942270e28679730223c3a1abcee5f0ba047c0aff47b19587e33334b28ab3d79bf6279005fe8cad978c6c4e5f4296fe2fee0c78fea80f840c335acc476b19230c157ef4a6b68c173128415cd5a5eb10897aaac14f13a35f97ce619376d8dd648bf75b8d03053937a7375c32db0c8e4db3cf2239a8538657b0095c827edab025b460eff1d49d6247442e53cb8cb8774ccc23fe321ffd71c48f8fc166187ab6471589555767c8d840aa8553cb31658af14407f988a9fc04021097087f7fa5ef620d42ca2e0873624b3bab6bb95e8c957579efe7841aa722344af63d43523035db3490fa15ad5b41c343e39dc72b85d5ffb8a5a759d6aefbfb4207cfb1eb60c26b1a2672cc871406a3865690e9f67f60f51773e3211cf9d7851b5bcfd0878c694e85f846906f7a9781a35533042851a993393768d739a6e455b724fbaf7e7dae03f1f7eb284da8e9388f00c625ee3404ddd09d3294728847927f5feb1bd5c363b03041e9b46f88568a1ed4daaa279037e52078560f2c0ff81ddede32c1a840cf5382b2249f01a3e35c68bee91baf2ee3fa8a88fe48f3fbd21113ae7d891b075f4c2b377637dda5d4605163539a3706e3bea768fce038a0a3b6ab4f4c8881112ca7d2b76493be60e615201d21bd10a3941c81e9bcf4a5ca008b3d46a7be503e6627cd700a2efb0704a09588345512810e122f15d94589b964d1410249c8aa442a74341599ea4758c39e808a6e6e35d3ed2cdac4e09bece5e05af44589167b1422cb671acef4fde9b8549572bac39244488293fd85274998d122655cc17060b2193b4d2659c83029c862497ba53f134faabc98f24aa302fa18d25fb8183678832ccbe49d0327a6fbaa38e23f973cba2c8972cebc40bca0e274ce88b397656d82ad03b823246d39dc53112c6e31e20ef8f9e95fecc92812b043afb5d03190c9ec4c55fedaf3e536803b6a534c5bd610ae4cd22ac2679f06dd01462ff6e9a85f6cd2e43640eb5534e08304ab1e4336740d7d499cdbdca4216c2fd7bf83a43f81b11af586f9ab7289295a1b340247ab13a13b8db3cb765f56d394ae648bc761b19f01714f6eba00db0781a88c5f243948e076e6f22eb43e51da80d7b362d9ec068d042676a0e6744dde362a07623f429a81ad0b9046932b7e7c6187e8c3ba1fbf0ec510562262e8155dbd10a63b097357538c43f78b32f465b3e13b9b8f3b5002dce75ff42f3a24a6d9214c4610a55edba259a981baec536d2de88e6e4be468a8bb84a6b0cf624c57296506c4652383315c24234969b062d617d832a26e9a39a113e975cb32598e53839b0f6d317476a900058bb15df631ed7c39a446de128e0b295edcaaeed3f8ab6d4f51e13761898e1b4f93e7e17f3f4305bd1eb634de9f3635850a8498b7808d971e96e5e3f9b3cecf8222c087734e87dbb5b15d8050c009801af74a116767836c1b012a5c7519b9693ce5cbe86171340437ccb87896b5235da06e824c0c347bd1fa00134be7b3167c452dcfd238552d2b78717e18b38f07a905c68088f2f6ee7ad8a3bcb41536056dd7cc39292d9f20bd2cc00d08daa1f75247ce09f219afb3d2abc454caae41730b717f3528c314fcd695267cc3b9dd2d23e200647b47bcd1ae6db290a4a9388f2b81972c1d284c9ce902166d68ca8f435d4a95ce15eba1ea6ea17d6b6757b7670a79107a2131c7dd22d56239c5328f5a6b16ebfebe96e37d6ec50ae6f084e888e895680376b181d2e3f39ded9af2f4e65a62de5646beeac0c4b9c480aa562548a8a174a0e2769bd118e17ad6fc97b930c2fc11f6205883bf450c86d3b41e8c0a1d94af58c90809de116e1c625389580893e428bb2049413a1b49671b15fa81980ade066c8e3512863045633c092be7e99aea2ed78ebc2670f58cb18dbcceccfed788259e6e6261a7e7f2f2b65e89ee7f0d8a446ab74c53b7fb6382f6f00bc8b57b7254bbe3622fb624ff9091c32399dd72e86bc9eb605d76667f41d0a59fa56d011e95de380e5200e0810ed9c9381f20531566108db284598506e2c983ac030518691cc4255d573f7909c362a06d3fc23e2c68bc3f796a9ff208a9276321c0fe3fe93eec58f89c8bed79cd297ea1db342c1c8e6f64233c7a2c46147c5ccb504c2f968e7aaed2845e5c240814ed250cd6a1b27bc3fd15a09642673abe2303f11529f632f0620be873344a10efd785af7884cefc4e57499c0d5e3bdaa8e252ede99d9c11b68715816ba63802c77e7e5ac889836e98beb37e73c3386ae8603fe4f028fb396019ed113ac440c90c7bc648304b45ffe0468a854c3d1b7aaa37534b11d30f7d4f8bac755246f97a930ac168290e2f3bf8009abf82249d3a40fee75a6c85787038a3f0b7a7b22da16a7e2dc30777eb04479786a5b3a74cb9288d76b9c9fc5a1de55bf48f316b5b608c3f9ecacb65bf8db16e015639a20ea323e22a120a7123d8ba4d245b60f99657178e61c1b6bc62d8475630a5de17a170605fcdb0f8ba0883552adbe1fe13b5a2247902b152ce123b0d593c09c1754c2a8ef5873e86fc9a933ada29e4103ebd615abfcc151431b802036d593c1e38cdadd9cf47a5c22f4162e0080a24c0d375b587584c21e835ccf150ad652fd1ff9ef7f47013b4dd165a9570532ed2c42160d7453cca3e28ac191bb2919f57bf61f531e603d52eb946f966a75dbacc6f291ac1926ba67ba408de9040c47a8efcdd57aaf6ef3762d96c0f657bc4835879865255007cf3e5aa68654ec45da13271d7a30ad5b6da20e4af012f5767945c695de56bd39fdea77cbc3619c5f836016bf770221178dc8a0428522bf89318cb2b5d44770582c926a40843797cc84d20addb2d4a4d27cfa6e027f010d02ad648dfeb528a08f9d30d66503b961fdefe89fe0207c06000219b354f736ba566e957f77aae5ec014ea04a27555260aa552dd8855e353ea21e9838900abd2db67c8fe9fc00ea45f0c636c11c3dc8ccd15c23a206b4565df94089c8b3cf5ccbe7f941aa08077ae8723c06f0d2fe22f1ebe53f44cbddc86c8cc880d104f2b1f60fd7f4040b3347b024844523728a3504b2ed5de5ba0a95e418f965d4e371cf68471a68a40e795f513eb966222fb394552ee8e54d2099c0944288ed10044ad66800b6137b40cdb2fafdec02e1874349ec2a3d8e817b996e5841a4ca739591e79284b5a0bb99e30184952782e7c103dcbcd09d68721f5269201414c39c085d5e2b40e32e8f13cc3d7bf5103c455036420514d37a5d067c592c100c71b3fd3b843faec760b018b460d496abf25bb7c4534c8dc45355e629a47daca10f2f19c70eb70d9e1b03fed2de77045ea3c43043104a8985e363887b4f8e1878fb11f96a5061d62000cc4a530eeeef67bac626560da6cf3b7b492f57714f974dab5e69528c579f464a8f38e3c927bc993b850104b19c7dad026baee1c142597b37e35bee2c5866f05bce8d9efb4ad6026b99b606867bc8281a4b89b47c7df23f367eeaf18c8a38ca43c468e1593144637107aab5a2a249b4b44e01df43a607a2b6ca186a3d61cc2078ac0c86334c442ccc2d9b7eb64d716973be673a9242fd1d71c9e0de5587d50bab4166c533f65ce4bd771eeef3578e4e90a4c26056190baf67f4b8974d44af5a855020550408d998a4cf71a7b7846a04baa4f6c6d6cf14b8589c42f20ffe89e7080383700b9c5f8548d384e66a20011db219efbfc4cf09893bb42d452458f310140c73b8b7f161ff0fd9caf4ffb5a3d6c6004e01559fe3d8cb5b35cfe98ef5aae16bb3917ffdb6c3368ededcf7dbbb56add29175577b8ee746c62af71312a56ef60b36dd4a4f7d959e96ed06675f91a7d9eb05ae6950b5a285e0337a8a2283916012c3616b4a7672b77fbfd30e31f0f33448e1a7963ad2ac38c6fa1ef83937b01bb58f0120935b8098fc052c80844f7d0d97040cc67b969d4c7898fe5dea37bc5f6ee05f92bcadaa1b71146f45739514a560db2fc8ccad570c8e14a2a3940c1b9108124cbb3e98b19e7c8697129462f73c659d1ac234ae52b4e11a57d8ca44c8a2aec9d8e300e7cb8d152841e173847ffca42a1e1d7ae2b9bba6ba3e94d6158b402e041615a7917756fc18dca7738c040ca6bb60ed07efcb4bc658486e4ac2adab4d1a832b6a5e3ce8eb5db8e8b6559c2b21c89a3fe3ecf4711a9fdac5df5914433e07c73801cc9de28bb634fd2d1341b3274bb5e8b337fd2551799c63ed71f8843c1e475b208386fe37dfde2b0b15d259af7f12d044ecf7e07994b957297e835efe70a71d900a317b50fd95ed0570ed7b49c15e57ba5b5798d0f0936f641a2c5883767cf8dcd50eb22e60213481d6d258e72a34fe8757b96fa0c55e47010c735b7729a4907bda5228af0b67b62e792bacf6a87af4f36b1fe3cf39df3b5f3a7160cafba20d814df4a1a3b55c73ddd654387eed8f49ab300061aa2165c29b96fc1cec1499f2b9b133d7a833d6430b0df120a41fe9d30e6d4f2b8ee81cb0d4614945e36522a02a1730140b7e0b50596de5cf3b3dc3ef6e25ea43ae82062344cf901401b62586e139be692f0e6833325be91d6eab46cce79e13afcdd38484dffdbc6d9159f4b17a7360a5990a9b2b38fd9548dc9fc11bf011436fd816209b8557093cef73a4e5ef711133891462aca00055d780a3a369e56700b99ecaa27b2e18d00c8d8432ddcf779fda055cde7dc60dd1fd706ee0322aa9952695cc6861e77697d188456fe808c44dd92675967effe9ab96d4a1de08dad5973c63dbb2dba8bf6061e377d1f4283fc5a3a026ca8e1bc39a3fdd0527a48ea0aac1081fcae68e27ef9cc37ff96fbbed5d390609d47774512c05e8eb9dcf530aa1f5c253c87b6a948b49e28bd2958e8889d4461dd492036807487a4be42ed89cda92d286448f0926b7368ce63a0f30bc165c6ae40b75c91e0641e081590c2e1bdb9ee239b9776c64bc914a25f05fc323edf5d40064e66f398570401f9baf2b2b9934e9655276567afc3fba252cc1ced071d374c59d76b8c4e6cb78ef6dd8b0a1db62fbcfdd9f135d5959f71a67a7cf79974f4e226eeb01e7c41ee6c66d14347b739bce33319dae410e9654018e2f385ddb618334513663f640a171b91a5509cc44d54fa8e7b16e270e7df2e8e65888f247b12ebf48961f160a8f82a6efce3f9dc98b41c87a72d8de165f891a7baccec11e52b743c97f0538d7476e60323ceae61665f6bf0bb1e9217a790bc5b1fcd936615862f40d7a5a7a2d9b111a4b90fbfb4da04feb51ddabe3391eac8f0af65ba56aecfb351ba3df48561b289af7cdee4ec1237a4341282168c7aa80bf9b87e1bfce584fc691ec1b5a208e09d386cca6fd3d770f12b2a378c8e39d54142158415a47db08c8147d1e8c622c07075d0baf33c9fc41bce651389ae6a4ed50e0ce827f510b95618163d03121abc2e5a3bb56fd1b4c00ad3533327637b999ec4cdac10d43c46630403980cbb97226b1044d2825aaf8ec0283a4dca1016ac4acb6c75cfc2673ec7ff5ddf2d7f56f80551652b98477d1a9744a6ba2bef4a0a313cf8b767f1410e4498acb39584db4035563682a58d1158ea21771ad79fbc879c4cae24c771c9dab94b329f183f6e01089e5cb7ba244f17460e83e41990380c0ea1fed36b9311bbee7d5f96c787bb2c46fe2854a8310fc7bd08c322253d95126e1f3f5a05c1bf65316f37010fca2a1281c8d05246b5878c42b85515a98fa130f7e8dda706184ffa6efe15745c16788d2c36f7f63cd643e991069f3cad5fd099f207d07380ccf06bf1ee5059047619d4a51f880e4ad3603f751e567ecb8da7ff187","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
