<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f258ae88c02e0900bde0fbc78597944a01b1be6c00a6ab967b85e645a097f5b095666e8d2d18c80b3a0b269bbfd36a48f9e77189922f0030a6fcbae6faada962a100c5bafbf7ac4f90227b22d453b6000da1996f661088fb75a41ec694a48d75ebb4a90d05051b4da634b7233bc99041cfe17f0f89394d86bdca943a6efb54e4a383a173f187b0541978b5e28bb3d8516fce455abf0c96490215204c50132927545951e8224f106e2e816c28db5572ea05c1ac4be69d9ab1eeaa5a67f354ac25958cd589b349d74442b90a48ac97233e225164ec646dc175b57d4edb07662666f1dd58be021b4b8988c0ad4c6aab9a6a2ac89ac5868dc4f658609ebd740bd9b099be17fda377f3cd9edc868357a103ac5bad077c92ebd60f32e68398d172ae0e6ff1114db0948d60e99a000279f628b46fd607f00754cfef5ab69deec15754f0742cbe7e47634ec971031dd396b6d725f73c98b22c72a49ee4e6a2fe9607298379e46d6289b18f23155590622646b651593182c9ea4a54b0bc3f697484556cb379db1754517ff1375f0749a447d18814c277e2bb0c26a25563750983e8e3df4ce156c76cb555bcd1d1922502f9c68eec87b9c5830d13613095e7d3c5bc70c3c7db51605aa36986a5b4897d77c41960a5e454c477373ff1d04186debfe0835384d058f580c85baed17dfa672c5be90e22462979eba4f649d2d7f337aa8e6e61770965bdf16a1594cb4c53aa294fb655f1dbda41010cfa0942e89098bf0a428fa25716888b2552929c45cc85ba2a70759e30d72c9268784d7d667da5f79870c97ec3a070175884e0344567d598e9da81c53e3024cbb6d88d9eac86b391287fe975dfaba56744ead46094bba886dde127c02635ff1de4b9134ed62266c2dc52ee07b36553bda21b0e3b8addd989d42ba1dee0e52c4b60e93747c83105e5f00c09e00613a8603a6396498878a04fc65550a87834b6c2af6e6741392696933efcd2b55c4e551fc152e597dba239848b4d30e29aa18d76a32399cc95d47125ff3c9199fc10f3266862a4730e4d36cb86b35fb681209703b302bc803135e44c2fd6df3df226bf4ee0569094360a0e1d5de5315d2f434e9a3a53f2fa1c49d8cd92c14434aae54c5bfa989f91d9d3152c38b375df8831fa0a1b85936b0b91da3b31fb97b4e2b42c5e133822296736ac736cb02c872ae47c9795123e6abc93b8fcb1d484302aa86927820ffdf53b62dfd35c4f457e91f677d5a8a7bf4990d9d1e43895fb82f4e2555a84a4e3f5c21bc8826ac547a8a3e19a61ca960e9a848831131c646d7be79d24143a47d5d7553309168874a5a68fb1c85860c645bcc804a5319ca24011d24c96b1e558a8df9d096b8520a30e44ed355e76b069f887b30f2d84ea95b9227d7caee73beb2ec6af8a0983baae2fc3c1ddcce2cedd12a8821f2a1f11e5260f27e2fc9c5591cb6334677434dadcc6171b7e626a0f78019745aedd65d922b4b818c5a6a98595b32d3d00e159099e0945fa35ffe083a0e0b9bed579ce9f734cee5f2cac8e4ccbfec211732c163c26e194c0b0d4bbf17d23a356f34de2f02c0969b708135e4110561b1ecd89078e1074cd35358638a63152f4caec078c5cf5d74b594b3018861a66092010c262cf85ba8e7cd03b1d67bb4ec83a24fa0ef210e9359067afaec18a8148610275bb1f9cc32cda81ae37469e45dfb912375a2c9e7f4929bd3c146bac23a7ae807457737d54cbb3bd17804679e3f98b559b8aa5567a872c5ce308747d0646df8a4f129d6e5583ed490fe85074624c2db9085e77a2314940e14fc1e09200a8bd38fb5d1c5fb5c5af9495d55c79c73d9b8d0acfde4c79bac41868fa057f141fb19a17c8575fc3f4156a02c0923abe0f701a05cf18cd0e62e34aa95cf1e603f9a966a31df657dfb6407ea1b85a4eb6a5ebaf715fec849843077c6a9f31cdcd2271e5f67e4416bb10962b467f35608f910d26c1551c7b5fa7ae791ce8b4cfe9040fc6573521a896f3d9fe723994699f849a1fb15bf1b39369dd273ef69c69f87d3c235ef2fba80a3c7d8bb0db59497f18e52ee9e50a3e2c74a8e5605711f486a7f1faaf38e1659b61c04080dc44a8e28f9fd65736d81b31200a42d3ea8ab5604f5b6a6b8e8598f9779644015a36bfaf423aa3b665d2938add6fe79fc32d46bb49f69c22a83298e1b04358437fedc2277bd1bf9f65ec604b97455e8c8ec62b2a794f9d621d756abdfc7dd10418647a6e25bf3e23fe24683aadc0e73e5613b931343db0f27c1604f5b8ae92952e7d0cf7480c2179f2d8be08dc34caf9dd046a8268b53f60a6f3cb1f5307bda4608cc7cf7f0ba2e25d88e1101089b27bbaaf31a51991e35e58a0fb48d6b127c14b1f62568c76b9044847b1fa5044575b7e6d48a7849643e298b9472f89181973ee56b8dd3485a90cb06a5666cc426ac103c1326aef0a2413b1e56897edb9821e516c3b7093efe39d93966970a6ca7cfb45a6f16769b25a6a9346503f894bdc3b277c66e273e33c6d159dd973d09b401f567e88d36783a13daebfc73d6b71a7a19ef01c9186c1d3343a6f88077ea115da56a8622680956f334587df021e6fb8bdd0ec0c4019b7fa6b3b72b8cf64a84669ca0644ca9098f1a9d29a8df582b86d69aa78e7dc20a563da4fde0b5a0d9ff5aa04a738ab078b04df5386818c629b02aebd9df1e7a20562680db6a6c85e458cb805b44116c711332066da2c6d7e7030b139b3a40a1bd4dc4a4f65ac9b99091c839b4fbea7f0dd7a9faf9c99e14f1246efd23a74157a85e917663880329ae49b26360d4b00dc636f3112da32f0d193f5b7a7da4309c801e40b4cf36c4c7e01aec4cfd43e548aa1b9884a0922538909d49c19849b2c9dbe6cdf20d521cc449247c0c02f1da3032e529c01b82213102f2112b0699980fd3bc3a0dde6c7e99f45f8c9e7e609f8c10b0e365448f1a7c2e68317baab18240be7869b57de63d912df15a1f774b583c091cdce7b6a2e426b5f7ebb8895c9087772f60301df893bd197542176ee05d74075817a8ddd93c3f76d7ea41e8b45ef5847ee6f79fef031540bbea040c59c28e9137e9c7c40f482df5999a89434bc7034ee99ba27952a5168b65a30f201316c87b7b003f83f09ca534ab8ab7702cdb96a3e7d5e68a56d8a3c54582ff1348e0f57781cbb5b006b6ba6a2cb99cafafab98bdb02a982dafa014f6283873f5f6e5d154428a1bc6930ef0d27c00ace266794c0ca2f6895e212bf3054697e236a84338d5a77b757b3ada627308fc0d4dd0e78ffc1fa32ddd59c05c4eea774f21585e1b06997cc41c14270d3417b5600271cd09bea22cf5144246f62a0d196df315a98d40510bac7a0c7adb7bb8bed2f1a80eb3007fca721033a4f38fba023e9d44b895507892df6d8d01a151c9e57e76ce20ae0685b6c462b92bf64b2fe914faf973d210d2f8b700cbf0dc17dfb6dcc4ed2c8d23267025feed8552f8eed770200530d655e98e6ae26b3332462f308c1458cc19f31aa867f89e0c98eab785df33fb21e6cb85cd044fe9ed3c2a8adfd5a76852933f60274e95de63582ea9c9a485feba70cea501c50ad0757ccefdfcd21df6f78b5396eb8b211b0707b00fd89a17e4c523581932b8594861279e136ff02ecdf80e16fc7c01040a6031b03767f68f3e76eda9000d9e7d8d92e4396258ec0e8217f0382de438bfc8af673ce68305b4183c11f274e4251624f60e0ff128faa6793a0f6ffe7e60c341f1fc7b6233532b72b285d2a556ca11bdd2f75f4353b55b3c0959f5be5e7d7690887dbf568aeb28e0eff4ec6689b129b18fbb3f305c0e2c9e6889ca36e0607b246ee2b7dc8cc32f8b3cb978c8361ba7deba6807f6926dda318ccd283f38e240f650d321468d9f47a1981edafa2a1eb2f5a3c79438dd0f4ec49131876cda3b1fa13a0c46e12f081730359523a455839c7275844151a37b7fdcfd2784420bbed5bf4e19e24b490aff3be1f6ffb569ea9b3fb365a8ee0f9a45cf30594b4e1c7d0065269857963cb8f39dbc5ae38b064a0516ff0ed81cba7dfe075ff7c1d7d0d96ae14640a29b5cf3c970fd63d64a662f27b5e9e85794d4d1daeabc8f62bf5dfe3a6a1bdcf73fe1b274893de68e105846ef651fefa01e8c313a90bd18b2036b39dc23049f6291ca55700c5aa6e36d27d073ab34398875e8a6cabedd87989eb7ef41dd0821ae8c4954f1e3692d1b37e0a9eacff1dbd1c6c5781e183ff150760d2a0c1fc106021dc9d01e19c8e165a8bfab4cb05623262b0e63e5c03de58535d024b4df1f635ca2763464e9320e9bc47e7cf7488afa9bd01c86a9cc220447b181319341f8dff6c8d460ca9269ef90be7e15905731fdb8a965eac53ddac2040640f48718eff63fd2dc4097e749a3de3d95ffaf67e3879b4ef01bf8292453a6ff9b138414bfdae61415cbf6514642cfbfd833c79c426a18112af60db6827bf24e9d252faefa51bfbf1b50913ff5b7f140e1ea377403efb995af25553ad517e7833ac64ee460e6c06e6fdc061bc1b635a5bc4a6482713bab1c77372c82925e0d406435dd97894a310a811f0ea47ca85b15324c18718663f19541bc19b0508187518b4408541c5cc6cedc21a0da09366feb86a06164fbd1c4399b1aefd49bed927981ab48498e7d6ee74a6e8b3da811771fbc508a78ff717c6a86f8c8d2b575eee23e8e4c4574b0544e633a5bced309fdbeba5d1d34c7606c5748d2dfc3aab8c9a1744755cf0644273dc0b835e4c10d0b4f53716fa00ee8aa88572a647a82359ce11488ebf348f11e67bec8e8871ff0d63ba368c4c1727a980298819fb66a7ec4d73393a4a06105ae73b9b342d5a7818256336a11fdffaf6b2f5a3ef92d96bd705cec621aa4dd10e3f16b54e86b79f9426c2a178e47e7089451e36a7ae5ab6a37e18ec40802b521525d80d328aa6a57ebc007b5cd93b582ddc3309054b782f4a1a2732ac30d9a4e7a1a612524ee087dcbf69459a05de1ea923ba5154a1a778b4ff65ad8edfe4668af13efd776ce74ef683cfaaf204392a5458193f56aeca5b233a5634cfd021f99013a016010a7ec73b5e3d31face7126dc32d4b002b8c9778b9e4cedc138dc4238de4620590f0466f36e43aefc9f87b73be7a4c6dd3ab519555aaf8bf96529c35f5263508daeccdbd6d6fa8b5d3a3468b772da0e40fe6e6270e22c4a5b307b9d5541022b377a3c6b12710f70f7d56ed06b65e074bf2a8628dcc58230d433423ad30f2bceb324ba2236a5d3f541a27702c11d783091139c7bf2667ea16068295e8c14fbf81e915ac29d3b59f01a3bf2d8dd1756d2ad7573ae9bb7afc23cd6611463916434c857df66e6c84129adce6e64f9577f17037cb2762efeb89b3250ecc964f8f95052f69c9b5cf0da6fd991b56aad928860a85ddf76fcf70b29c06b42d6153635a745e909594ebae1e9ea73525ad21b19eef5e7d824f2d1814145f40237fe9d768e0edb6c03d9644b02799a21ebc801fc1e9e2bb72dfef80476796f579ccf689183e23151a72d111c523f633d2b5e9bf3e0974c1e4739340d787bd80bbcc46343861ef70bf2e8198be2387d4445d220e5d914ecbeea835b84c04466b0619499f9ec682d3a1cbfb5e99ba99b0bd040c4eebaf69ced31b0bbfa30d076ea0881c3533c9375fdd5a9f70c354284ec541a251a2781e1b86bb22a0c9d637f0f9344732f28fa53294225e0a5155df488453470afe1df63db5b5f80b94dd20204431529eb9344153cfcc3e54c8aeac09a45e954aa8110973d90f45685d5888b6bec889510179a76a7709eb9de9e0a2e78521f45467eb42760727d1a6aff1feba10c5b02befa8b014b04070fbc0980c1eb2514622ac51c2e6731a29431a5b21961b0848c58c0f43c68d26be98baf663be8d58e4d93d1bb6bf311ffcd3fd7f0745701af64564d7acb492ab766060acc4ae56982d9286151739b16415c019c38fa9df00f0e38750b47a630d108092140fd2813db4dcca56fd9a495da537fd6edc6aa8bdadb6e188609f85320b98437ebbe97a78ab439893c379b184d5555c3d1b26fe8c19ef88021660f043092b23cf484d075bb7913c7a4078697982da99ae179f28f3de9c90d507a7b002a78cc5f177f6a1e1d16af6bede7cdccf8d71508453bb3a614020238f64a42aa96d3cb074643e1477a861b98f43fe78a6b039692e5315cf5c9c37b56e9b48f0a2378aed1d652e55699d70659b13695837abe651f22540b0043d2019d21d23550ef2e6a53455a5a828975d69318eeb29eb9a7acecd1f9003621cc0095dcf1a4921c3e58ef009d84642b68dc9bc8e6fcdadf65a24e5aee76c56ca9b9a2125d0dd879582b0d4e02b55a12089a4ca0ade35681d41a4404a630b7513a3a6b3bc57ba36f85207619ba1a87440dc5ad46f90edec4337c31fdcf1ff9a9274551240a6a569a0042c6b8aa35f88410b6108bb5f369da081882fcdbdd5577a15e89489b90dda0ee206cf5d19542a6920e8b81ab4b362eb1d4ba21163e5114d7c1e2b101c958ce81b98f36a69b6a4f72dd23021ee7b7c71391c006373a028aec2cf54c242b51835bb2c0f68bc7c22c0bc467f9a2a0262bd75e91642b32a39ef44461c9c64165ae4a59a78d3a77bbf259d8c372fd94345d78ff9fd1d602ae5a0488c1d5e5a1d9ee8f927bcca370cd3d077cfb5387627d9324a84b3b622f25a99a2923ad9a8bf51a13516126fa28799fc2c2ae16e95c4f08e018bd4440e25e52aa7f55bcc5c7483c595f9386651f330dc7d92ef0228603bda3e0ecbc0cf1e94ffcb3a5a8d16500f58303d3b650b63b1ba23291694705444fa7dbff0ab2f6a33435df2e6562539396a5636edcce3aa864fac3f39896e6fa62d603d30b1b59ffa72b91d1b5b67bb31e414f4bdb6a31ffd388ccfc9e6a7a4b79bf406c159d53a8316f92b49b454808737c754b16d3f9c979e60e9c0ef4182154884aebaf47caa44881a76499039bf592f635e0b2daf3cabae212c7e66001a57a31b013fb3ec2dbcf62d7a999755f0fc046a78a182b974dbfbeaba2b2e998c756495ff9f5e60d7019267e9dd91988056e180fa2efff0599b6235816114dc2cab17edaacb0416945ae895ce82e0d39cd8cf7a3a556206c18159bb1caf0a11d7d69c74b3a2d9edbbd11e89a0cd762c27825efc2293e31902fd900a668becff97894e13f2b361fbdcff8baa3654542f483cea022451c8ad41cee9382fc13b665d70b8bf6999d848d509e9145c3faba5ced95033abe6e9e9d135b49fb8c2af1e8f53232f0bc407b6a10373c8d12e03b5b08ecd539913d27cb1300e5fda61bd491b5c0ac14b85c1b92969ce46a59c0c86db49d415bf78bd6633d9e7ea89f3428a2602f7c028a58079a6c37cd1fac022622070441c8743d2e69cfbbce13235741fe0e0463ebff2ec79f93d1dc7592495b949099d6d045c78270d45eeba15d8360b72ae846ebe69433d20359422aaa6d212390a668d7830a2d3af8f724e769e3196a644fa82c8c43c30d68f3b6a3087874905bbfa43b33351ba8baab7d2ad8d33c4c3fc36231056209d29010674a94107e233e00866b61df687e99193c50d88e56a020d1e0338969197ff08d79c0356438c0616c82eb4b4a8486ff5f84c85af6f41b3e9991fdb8706ec8888ccd51c10074c113207d11ba3979d0bcd61664592e5f3f66ef771cccd77dbaaf3c553867e318c9db6e6b23f856e4e3f1b3c61b651379046b9edec557b09d14a955f2ef4ea178db64fa18f685c978aad1cd5698870564c7f045a0daa3d2a1d978e919827974ae54d89723a45a59c0dd90f0cbe5276cd6fba981588571e2744532402f41c57631d38af8e631c251a6faf477f5ad7870de8393b8897f93e104e2fe33049911fb6033255d23a7014adb3be44decf572b5e83f55dab31a6f4770edf1c6e87a1fbd309dc5b1ef53913c133373345c82298781b19a971ed5757e73d73181b6c56ca5243a6dde36eea1984d29d33bf893fea402dd0c4e648f16028365609718e2590c753bb6bfebd3042f46872a5731227a35997b5ac520994af54b624cad2265f1bacbdf0105187349f7901d03621a450ac61f95daf52dc1b6743737a3ba57ace7ec1cf76eb27bd2f64bf27888960b86e3abe4c38cb40c14780cb4580675307770ac40308568399ccbd8bf1bf88c79fce7d37a20f464e305073bb67730b63d7fc44983cdcef6ebc9840de2d84570c9f161054f9d701371b99a9b2dc7d83c9999e665b4b037a737a6715b593e9355f86c1f52bc00ef2389b5e1a65b5f197d581fd0f48f7d446e74eba89940c7350abe1a6518b2a97d533a406e536eb87077edaa710e56e27970ebc7dc72ab2bab2838f0fc83899a6781ad52d8c68e651ff5957f64e7225ce74852b46ba06fe2539575323ec72869ce515ceb527b9312ce33d3eac4cbadc89efce6428bde6a7f019b40ce84b275a37f99fa343c2597495b91701a60700c471b32c482ee3750eeeaf450b8d87c3410268ac6eba59d0617e2e2b4913b1a205d5c59b43aebe25b3ab9d9f7ac4b7582259bde0bf9a56f186bb794f47a7bed33554e4e9f23e676611ae603c5871021c4b43dccc3dd4cd4faab63b2274116d9dbf2450229f72627ad0a147757a94c39e880fa9615d1db4b6f4b1a2eaf434d537d06bf2d7f9a06eff294fe607a68a6c7142cf84780aae83d4894ec9023f49ccfbd26ff7ed3dbccfa6d0df5abce195b4ba50a71d84a7c552447f8d797ac6b609d1184aba3ae0d91325915e57081f3ae4ba92284775ddae8c0587545d5d31bcd5a915271bf1026e3fcb628241e9e639951b66f060ef597513f17f041f998711ea931677ab77603ba203c681049c09b85bc2def7c44f36ce39451c46ec702fb9e52cf38add16281aa5d5b85309a90519e41a3a1df26d1d028dd22560b18aaf71c8cd032531adb2f93f663988970e94b698a94bc6b9180a244f3c69fe0802971e30beb27b7cc598fdd1a2d652e1093138b881aca3223db59635f3a3026c93d4348ff4dceb74045de0080937e15a338acdff7d2f72c4e23f43b787ffecc492d6d47367d2eaa1f3738c8803bc804924b3c411499ca1b767b2a272442b0b95f5ba1f43e345a8ed87ec3aafcabd737d479fbda2369d5dfbffbc0715e76de7edb048cb564eead9fb32b070a52bb32481e4c653785e3d7af14b29c9174f822beef08d1172779b07d3878842bb8137a8949447db55063f694ffb7be8a86bf09e220999715a835565bfbdb3fa9fe99108f62e84514ea65c493ff6c6d8b5062e608ef01cde0760cc8edc0fe16f15d7a33b4a6bc5a9b917f0f4fe808f6471194621df8cfc880ddeebf921823428c762cbf1a1696a1c95b7f98c92657ac2cf103b1f5aeb08fe8233fe3b65eded2b98adf1068ad664fe53f0053cddd9b31903fadd0bc199ad1d32cf9fee67652564529f5dda2f0ecab8039a8a32bc2a654ea4e2234a30c5c51d4986d1e63c57e2f4023b9257c1619e77481b60d5128c0fdf61c356dc3716009509d562e9399baf6e7181c40a92e462a301231596b4ae6e6bbca84e6cabeb718fce54f21183a8574940087657110db5dd8fc614233250a09f914b0b08e8f1b9226b51187254adf1782e47e4b7350a7a36d7ed4c90d1040e77ff20ce110ae5bf64f0a4e9c2abc5c3cfd02fd9050d91fedeca12857df1f2e17c02af45fac7d8cb3629a118245830338f8aecfe6b160ebd60d6bf9cc6f731c4c7ea21a568c24cf3a16498b1d9a2ff8ba2ecea565253aaaddd6cb6e2c87298224326b4a0852f846b1e511b8ec40c2637b8ef1890f1037ca1fbd18d40257b2e26ccb7a651e9200246212bc59d769d46de8942bf55e0e637b1ba85c88adfe6ad8bbe455df87e68487590f1988c00a832fdab34f0be547768d96eaf8f1d300f959c3c381d02661d1d1fa35ed0c872975846d2dfcb6e8001325462d9ed963b03ed8ae23d9bc7ada2d3d1be9efe9f19b8e8088480b1943237e0fa552e3888e3a10f82b4d063616ebab62e4deee89a1db870041958597ee42baee0abb3c4136727f73f58853d65a2cf0fae22ad36d9722406c8cdd182b66df2c6b0c7f9753f33ab7ec358bd86063d54851a46e4bc2933c4f32acc1b9fb9a57e1959c251ca1e91a87aebdf6346b666109e39433de655da738de72c911de54f760f180f120e85c50e8703682be74654a46ced58afd3098b4d913853edb16a2efff5aab130c47c05b80642f616f6757b4ceefd8258fcf7ad0348be7728061f2312beb0073ac2f8dbf827b6690f3d3e2d8d3a57d19af9dc382a6533a0153719931ec37dbe73705c134444c68428346b3b62e47b3f5f7e0e3f0bf034feb47fde0c09c6981bf9770d826ad836059cb5dae345bd27e3d2de0c2b628712f4b7edf9eb6457ba725bb33139a1e8de281369eca19fdfe39a892de9d3049e23d50d305b3aad5fce2de6ecccfc3edf24f6edf6d7d65728d33031021d7f07a2423b16cc5ed6e3eb73c525108a1b063bb0b3acc1c53d740e69d0da65f7bffde1e13d0b8dca345b11ef8ba7f28bc3a809942c081a722fcbc7be13c9baf3aed695c88f7553898ac9e1c6b7e01dc19ba04cbb47fa5b65cc44e9641cb395fedd4d66a6c9231aac8f34d02ac897b2ec97d83bea50c22af6e4108648cea2e3ee66db74a132356344600c348196d9a8cd29c81fe45e009aa052438eb603c4d7a618df6bef2e0fb8ca437da70edaf7c0c8a7986d82ceec1df175d25b921fad2c6e1f6b352fa2577593dba0da3b9238c7b6b6ac825a56463465c188cfb49a44361c4703e49d8bd55cf2e0063eeb9902000a39360609fcde0bf045637b77d2c7c6a29becb8b3a89e65448cc8e2688da0c19625788e06fdc81340a5949be1caf927b210b4bcb03482c89d59a89","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
