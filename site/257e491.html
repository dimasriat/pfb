<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"520e2535cf201c68be144bc779cb29ad715877cf190a0efa48136944037ddfbf7f60d097e037899ebcd4737b0e442c565d059a673f6a68926434cf17453e378359cd47dfce04b5c427c1d0e25679caf5198ec9f8706ad32c92783b6ff6a7d14d1bacc0f52d8f09502c01abc88f5cceeead242a2b8d86405b0062dc412fcecfe6234196a7561a0a5a17134446a71854c35a494d06dc178f0cb79ee0093dc9ca55c803dccae3a14956d35b3ad1fd8e7baed9d142c58f20dd62391d262663daf7bfafe15f6ff682fce9cdbd39ef675263b38dcc9e1efa72b8b0aee0f1ee64373c615b42fdbfa94a1c93a8d3f2694fac4614393778427aaa3bef5c7ebd62fa8e436800c33b2bb31f1e4688092cfbb88ef5a7049de36c40e1b91e6864a63d50e86fddae84961d5efb900d74c8024b87b8a524125997b336e425ce6eb8e5b48e97d68fa56a560b6bcff061b9fc8ccd4784efdb0362e8c1ed26c05aa5c56975a3bd4354b4c02fb54166205bec3d7fd68f183d9b61a0b837572c0da1ee02274c8c94f03ae3be0ee4b90a6be0117473e195aa8e4f03a126d847bd80195cda6692fcc126b4986b376a72ea363da755674e8c745e01cb23f42c3513325fe7335b0163770720043e16e5c26e0e053471d1a43dd9e287e8f8eb0bbf93b68968c6ece32509383291e972cf157f68dd0cc56cda8bf5e9168ae620dfa03efc6eb7fe86642d713871d65ca9575d38728d87765d936475e8787450b31c121ecf42f43a2c222b26265bbce697f0686b6d99ca53e2ba0f0b8cc744a726db66a56be28f71c6fb8c3dade02cfa813a16ca1c05ac98c76ed396e2f487339c2de227c8e45d5a19ff5fa78e522368d4c6fdb3d3228cfac76aab79ad2faaae250b5255e82023bb176420012a21cebd3cd330c5e6b9f0f154c4512e960cbcb703a2f686a4a6ab2ed9281dad836b8568a77056ab28f5043326073c5963bad0adfd04232ed58cd3c48fa214186b3ccfa33106bca0a60b813df81130d0854daf9cdf444222d4ff5eab6a7302a70a3a4769cafe8843fc62c01037ae89f3d4c9d95fd1683e3561ec345795fe94a4cdf70e586072e4b9e964a8534d5d178257ebf905a8103bab321f776f3dcc8ba82aa42f2a8f91e4f704686a9b131e7d8c30e6fb42acc56b77c420da1f90ba9d224ffb53b2e2e4c267fbf9a6782dbe1c40da58c6443dc79fce2eeb5ff97f8120d6328d54c54d15e1a05ea1645faf6c7eab0177535f2c5e369813031a04170f6cc56c8cd4473f5e457826ed68cd2cd8675f739340f3703eb873e2bbe13eac6c0f1ffe12b0fa5b0e351f453588cfcc2b561c11545b4f29ce0c3203c4a7ba5889504ade982400af927908167ede1c912931c1b6bd0fc48c00563b7603bea88c56eaab5c087e05ea894a3ebc8c6dee6bd07a4cff510dbf910d77c69413ace6cae156622848260d3e974a5ef006511525f3b08d0b2d17695f3e622cdabc8df6fd810b8750156ea6502b5b354a68713b176644a3436260ea72eee5eeaa0e41682f57a61a2c9118cc5d98113f6f5c43a8379f30eadeb806a09b1270a66ecfd98c6cd8955c38c77add805340d6220aebc47b898e70c69de0cd76ec1b0670de2a2c838b9a1288b1fa4262fcecdd67e5629d78de25cfe8a33d6dce7383ad3b267899de66866ad7d6223035a3570eb2ac3856afac55a32ba721d6b6b59932549ca41fb131a9588de6dc1464b7f0bea88b70e736343d73774a9660a941261f9f44b6ffad9f30bb5a50c82a53696af5e7688ddc9e11f45bf7d082c6adb4608bf97492b0e450e54b12d509848afb5e748851a1fbf9fea724dbe0486e28fb6d3a95327c92d3aac8823a3c70e6ae799df0f73a9c2d7ddf08e63180a370aa0dfddfaee60a18d0073f7beaa7429fae831ffbeacddacb3262910143dadc14f0f15676150bed50200cce4d5a27f88f83d82379e9aa67ef45ba6e1d4c727dfb0970ac7f1ea216b4ead20df4e0a66fe9fdbaa9d29029029090524c897af5676ff3adb7c6f07df37f19380bb5ac9a2612f4844ce686d849df68487feffa05a60728a3b0069e933611e5d0af605f0208cfefcd5b921e3ecc7af3fce9bf260e1adcfe06142e404f5bec7dc82ed6923be5b75921682621739b29876dc9e8c4c2a21eaadf6958e2c6ed89c6ba40148f08a1ae52a5023e8713b4d856a3becbe2f6294953a11d6db50402c8e9052258d93151e58b5a017498b2671f0214d227c0f1fc7446396908dcbda08546d49cf1ab555b485cdc40c9242b5fceb1ef6a45a611814522d89666033513f7c8030329f3bdf9489e7054bb2cb34397c7ca17aa3749db9f1879d7582bcbd8a607132fcacdf6b53e2de352f02466d77a98ce741ab6e8adb07bef1cb9dd3621e2ea69e714847c05680ee711b113a53c7eb80a4534845d3a8fc30a5347a19a50226d07b91a0386444fd172bee965f407b99468907e92cf2ffeee7082c1fa4355fa23eaae9dccfdd6b14ec54e0e30b52dcc7b242f0585ea2876e7343019d680ce85759b468e3ca1006537fbf0c2f97c270a4eaa65c6ca9790f32280d8d2145e1900733405c8df72076c0d0157aedae7af3b27f66f305b52dc51fc2431bb733c8f62c747d4c9e6dd0c6f98e2398bac431704ecc131844ad32d7ed86493549068acbe90e3b2c40601adbddb94e81d9cdb36369d775c39b5e6fd4d19e417b504b51b4606ce984188ce28d0e60dfb902361ddbf1bf87b3d404db972f306ae8bcf7ec777feb51804696d6399b588920891eb60ebc7722098fca583b6346869aed099d4f84cf7e0618e8ebeb1e12f4da3182b15364e0a4c72b5c23e7af46303cc982244e73bf07cb83366b82a8cc9aecb5662d32e166c3279285858954ee883492468ae4f96e907716528e2a954ca1dd7271a06957958e2cb11ae6bdbc994598a468eab326cdf16667eb48804888a2877d9f62580f0c0f09c45d5671072077f7c950f99707b5fa2c03e0691395921ee8fd62b79b14cc612aef143054116c6a242497992c2689f965c8bd3885c2d3956556a053c9ba602ec4b851b7caf5ef2e37398bb58c724415e3bcbdff1d79571179c7506d6f863372cd78a10c386ede4dcfd9ca649eb33f015bf81bd54f6aa43b5f70ac37ff50d3b61687c2b7ce3b6fbdf97d6da73cec7f850193181b17771cf4d557bd6fdb60572c0372428889eab99978231827711d19f80bc598a7b3a25a5eb101c870d3455d32343592d33b5372a2877aedb611e350639b09c5e8c427f17b6185a291d4acb762a861c959df1ae77dce7d54035c92441ac3e85cb7ae64871c8c2725dd1b8552f519fe947268f5911bf6ac21ff313908ab296c8bf8f8dbb013b8e158a5a04ecc6a4c79a100c35617b76555d6937016207286e4b8a9cc7190222fdd801b1b25ee30253b6bcf2867dddb328b7268e4150605ed5f8b2019cb1d79bcd9758a450974ea7745e32385ab24adc6007d9a45344e6ccab9d03dc8bf97e2a35c1adca77b1cb72847fbe1058c4b4c4d9b1f4007011d56e9089b4bd239dd423d080a4c4935bb5340f2d37ab9e46e86787903c5a20cc9052856dcb98f2d253b61e916b9ef5542df9af6d61af584fc1c85ad32ef582e9fddb2c0b7e61e995fdc30e80b02e44dba62982d556a7fa44212adf14e2fd00b5063db9102c6cc2a4cf0303ab56129f72a6be1339529306bac84652120a23cd8a74c69f0b209b1f0084485ea1b09ee581d11ba90e575b67c2d4c95007468bdae6917f8bac2e1fe4c04f4b8061f507bd632e48e2505be94ac7179650e1ed569055377ad5528f4f16ef8ba78f2d448bf47bcb6d73786b8c62d7a617f6729442e581840c71df6afac33d0198a0d64aba3aa3c37f21524ef7561693630aa45d2086ce0a802eefb45d0cdb7cd29d6f25b651049965648c124b5ed6ec9600409c99c55bc8bcec953f81b646b9f66a0d7df271a95e077d54cb3c00429909f24480d328d0d555ccb4882b63ea285a1c00f177df4c714f438e4e825def16d16983803d889df64688b5f0c623c34b4b8baf13a0bcfe9c6bde176fb91f06db305bdf2fa00927081769b8a914197d3829f5cc597319a248af7512962271c8465b2334efa5e366cf6bcab77cb5d24a085fc4879aa006eef3c2d5d1fe55a66f79dfcbaa82103c314c9a9f1333b0b9ce12d5743873f3df2dcf8f6b8ebc99ce37b7cd830047e73997a739f515ffc4090b8a95b086cd64658c11afe382755447cadc41eabaa32c6b3af2a741ff36f738221072274d1a27963e5cae441125342b0d8b2f56dafd7fce3303979c9a99744c7e72199f08ac6ae6224fd6e08df89477d8a4be9f225aaec9c69e1cacfe20796661f811b6c4ebc276987e44405171d22b50181d5c6ccf47385118b9e3c884a6ec1aa52406bcd9f4aa6ee45adf00c6e4d73f599b05387fe33bf8f4c40fefe3f59359eab5b6461045ce2922635d38b96265daefbd4f3f2ea77a250a6a0ddf78d520adf40e1b3bc40f510c48399c25d5f937022d0d677d6c3242f27b227c108930611ec4e507f7331f74fd29086c46a9bbde9f78f36d83f1f9f9471d00e2520543ad9a19c8ffa3a7501a7d29629053c09475489383f5878d8d67d54665f817d68dd3c62aa27526b1c8176eb41422ba8e9e6b0a7b6aec8c93cbabdf1c1ec5262ed9bf60c149523485694af71ade83817cf271b1eedfd2072c8f80965f338c7233c666ea1610ba4fa8e1d558ddf44026c6640d677160089b5256752c9263b71b9a0800a8a7ee30c461edbba86cafc74be064b35c0dcd3991fafa831703c7e92477103f5aee54ed4b1a3d193bcd883f10154948d48584e2fdc399aaaf9133b9a12bf883499a27114b8024e664e604b811878ead2449d380d42b2fa230deed60a210453e65a1f4870a02aae94a60e209fada9a392142935f50f1e07cf4d037260e67e9b378f5431e598be208f7e335e02a73561dc28c565e008435c5da292f8494636226b239aac1dd990a341d9532bc89ba306896245adfc91bcd55fb2e21ac4ff5bd9437c3f335bdccd4f838fc3a72951540aae5bb16592a80c288c972bc9e0aa799f2460571e30952d37919cb812fb57181d585895990d89f7f4ea92d475b891a1077971f884d884c4d88a31a3d31625011a2f643761a622c89cbb6a0ad02656bef68178f022f43de2077edd47d05ce8f6fea45f952fc325f5ee94511ea1df34b47ae5f5270713489ebec939ca0e0b3db23f65810ebd5c70ac683b1fe8ba39d6e974e468f478b90fcd70c1b564357255b44ae1cfe4a99145cd498f6bff6a1c3b668f029745b68b79a86e483402c0cb38af42e4cff59b56adb3fc50807463bd6b966378539988c164e437516e5ac47fecbe1df1e0b720f380168a483c1eca9bf624e5bff4ada5fbf7f2e2cf3afe5cdcdde6001bbdf484bac514aaba50c5a0bcd1c4f401cdb0d376d86b0a387b272e7d4426e76b174bfc2cbb5ed5b8debf0ed22363e809886be875c2d0305cb5e83241306b047a13ce77cbf3ac74b90120f915e05774197533d8f5dd09aa1b8152ebb25f41b1322bcc63f73191e068c1bb6d72643f12e95a22b5d7e915dcdd453352a96baa020679d60d0ab0cb04b2baea7f9a86cf98c99fcf24995185e5824200881bc7fc760142090af52d6ef1bb6b16cf74d6ee7c6198f6858226496f14cf092dd79cb7478dffa1ea37399a8050bbebf576d85c7c1a379524847b757989c134987875eb8212d48969acd6d1c6e911c7ab818f5fc2cd2294072b657ad562d26bc3f2c725a7d402932c8d80d4790939241219a8c83609eae317e322ca84e515814b5a0899796fab4eda1e07b7c2e869c9b5fd6faeba49fea5ed1bcbc48850dd535e6a667a46ec24925acd29a6dce3d6d2dad8a212bbf6f4de8ac3a034500aeada886a30ba83e604070edab89c61debfcf592de7ae8043e96b2aa2c3b81c0db160d2c3ea804b98cb1aec4cb1c042d38b90e34888503c1813a7a1b3e746ff644c7a6db9857591181580daa4f0e4228811fd7c8c4d3cccbebd8c5e55788016ca4ccd055405afcc2dd0f5dc6f4ef0b464826e56c665d295cfdd0966a44bc2417b82e327780b74c043b7b9e7e4a2259f621a39904cee49eb69c672e9c3f64223ed255e61b115eeba774094ac4bd7408a8704a8fe45d5096b998411428f0faa28e1488dd984b3571a4465ba533a92fd050895e42eea5644703277a9b420fd0eb9e65ca901d93c9b8bd2860a130df61e9db37137e2becb4d028eadbab9a220ed16e8c13770136b9d509f7f3e49fad68837971866276518e27ff31916e8ba56945ba3a3f15a47150fc990b20c567378975cc6e79b64e4d9ead8e90f7d96c3f468f0b00460b65a743dd06226002f1a4702d3eb6c723e7a3d73ea7497eee8898e90da575360055901237cc017f48ed33bdd6647083fb58cec0c489a6a4977b698165214719cd14607db7753da9d1271caf825e5312334a8dd544c3493e103e595d92a0e6112bbcc96831a0ec12fa2d1b5fac11d1ce08be42a896defe034b7f1b0e622fd7871df2c9282e9321d79f7915f3e4d0ed0d36d0db786758a2efa21b8e38d368dc35f4cbd6343f4ec3121cb6f02ea0d1bdb483e0d69e78e87315718c994b55662d11e414884d85df8c26de0d778b3b9ba3877a92de22c2f9370b23187a0186fd43979da1f7354dc7086347b8b170fa8ce43e1a3dea1d498420d806f15663a46b79072df93a4218fd40fff64ba2297afe9d02ae12e428abc8a14b0435f62b690ce4459e12d843a32f207278b95f3b6b8eb37285f0c9b4ad613c8a2541ae42b28838e157e83675c4b09d47eaa2fefecb6e8b5b27107780a2f60c1ccb60d4d8279bfe9afaa68d1cf842a92a1b2f80bd6927df4cd776ab4d5ff8ab3ff62997ee28a152a2cacb955a600ce94201d41c99fffe57eb1896eaa7207f0d1e480fe7b70dabff3d7b30d3fb22cd505a14f6516e163dce923d457407b741309175cbb2fe2f90d3e76cfc46929e0b3ac003cb04655cede931f9285d31f3a1e234bfa2ad601980c17f6dc8f737b000488eebac4d7c9b949fced414c71a17dfde9d0e369972d5292b7f37153b882c56a480f3f4c75b6233ebaf215394bbdbc0600c222044440e9c57abb41e84761be9b77ce3eeabe5a0063a37c5b2386ce387f360e9a4692956b7fdde1e5a560a7e1f4e99acf9382b992cc3bc8c3e2e4560df7e205a6b90ece3efb089bff12b40fd2d64c36c198c1a9d7d84efb304acae95b4f0c849d335b42c7157e11535cad6ba978b96b9f1c7a8b12a18c110379ae1711e2a479c8833e8cdbe9999af74920ddebb49d45eff973d03f7fe1b20780f3d509e4f70861495165caff8300c3799dd661cb69b7acaa22f3b304a1537a6c86cbafcad85cec3f95b15d03b482eceba89f63dbdbbe075a4b4b7b8303aaff8c7722917144c8948af4b279eb876aadc11b25439657ff1caa18c1885aefa50cc1c4efb6d309baf69c23c6f03183fd3919ba6675e0df048a62a3ae6622908479f05e590ab9caaf3b72934cd232b9a18d6087fe00cd3266194ddbef14c3ec9ba7a5424c2ca84e7d876c2b6563cb851cddce89571eb9839b13d26e4e927020a03253936d3772314dd9d21530a33507167970f227980e0e888edf99e47945c374cca7742894be01f8d3c3e73bc3be39442abf6c517d6717d2a8581a3422700e3ce24418b3a6965096d463aae9249170cf28816162a6c412d9fc50408098ab1934267735d3e9924bc1bec9fd9153f1b1a6899cf11fd44705ed86859e0b7f62f2f2d4146103b3e304e604ce7c3eff976ba8429bfd2e9ac5a22d19458dfff98cb580ae6fa3dcfaface0c7a9ba219052015d1e9d20f426ec83efb310e6a89fbf9138169e9059ecea04404c233a6cad5717c6e74fce89bee6dcb68e39031a9d77b7d9bed542e44778c6828ac9a07955a168e68d3639e2817612b0b9e71f58b076cd075a03fe63a123e82688c117fae6dee3ad625aa435bb9b2298f05c8fbd70e4580ed69b5a335a335566ca97bf8fef33738997f70d269669461622bf1d4e16b6b4511dcc3d99e30ef4950e66cabfcb201d4d70033c96e84f2af5ea01be393c18d34eefbe465299d791485ee8a94eaf41f648c6e8c1484c817c8fa2dca97fbe9ded719ab07b2a47d07672b3334009f421817e7aef1861d8efdbc4133a90173537562d578af941a2dcf8dab1a0388395a0add0f4f81657f0923d80936811d59b58014c5b83ee4a88c773cdf66d67b53b5759d42ef4e808fe22b1143e89aa5fc6c20902c01361c082ed140af678ce2e54ece5df68f8fd5bd6cc3426ee06ad890137b6a4d3f0323c1761254cbb3742b20c2e50e4eb4d0f8af10e5c2a1c372d3af57b0a2b936a2309e68507cbcf0ebddf8bdd106a9b8ccd5ac81b2e1cc9b3634408a4a276822bc36e187c14c3aab2f710fd979b1ea2c8b6bc71a1a6dcfca27fd978eabc3fac1981e4254d9924f0397f017e8d944613bde4d2db7bef0f6b935e708cae2de4f79fe9618a3d411c40f4e9078fcaac0d57dd52c8d2bfc33fa3277dbd01d3d31e9949532a0b2d6ee7c97978f5eed1c743e14421dbbd59b6b3f163d19124836f9ab6eeae7df59e16c636331c908ed93390a166f8d8611290338744ecd7446340f084f99b54839c893b9854876e4b800f42a87bb5041fcb4aee9f41ae3b9483de1d56d747faf7827e04c0c34929864d227e2456c16388f2b7dc4075945c1782238b023bb367f43e29155c047b55a3ad88b17a8b55fac4f5e8dd47402f5708ffc750ab5a71fe486aed7ee254a9a12c77cbe3d4dcae75c4b78cbaa0d306f483181845b26b47c222a1253aac84d85433bfc7ce0f80157755283192ae426f1331469e158ddf8fd2c85697c43db5eb727613aa3fecb10131a94aad4a2f231261b1e18f5d421968bc40c2c53782a977a7a61ebb820b5d70493b3da79f599d6edbf8256d06acf44478c8e71051875e770347bb0c5b9d88b773d0fdb94b81065f4f421d4704251352e4a23d13435ffd4522694da1ea318974454b301336ec6e4857f96453e25a11cebaa626e1ef6984b66f5ff61f74fd5804ffe62d7c8938e61cdc9905e75ab3ddb72e5190fa0b8f1d84cc7ec05e962f6e8097c7c08302479e8fc171ff2b37d9c9d308d806b5346312cc81a587a69fe704069ad84fca1ee1131f1eda2a69a3e9e57681dca8763820777595b421c1f0b8f8907a66abfcbadab704ae8f1c1f8d0a196fc1fb3d4eae3a95cfa35496377a08d8634c52f3c047f79f7373d95b38345ee1d4158b8038cfb1c8cbe2ce22aaa186abf58157a39d429913be0a6658aa2b50f590a01430054f111c3d0662110810b9f5dd549897dfce41d00c2c3921b6cd1bc97f5964af5b15b603f006b3329807e24bda1700f6d2b04911da105fe5bc42c510d13891e2ecbdfd8c7dc2b3a3d4bd111df7435efa54672409b1976ba62dfdadcefb373a5118ce81757c544a88a8e2c844b6951ec2644744613131f904d60612a3e61719b1338bfbf560d86922899611d7ae72cbe52bed8622d0b7dc8de922efa44b2edaa3e5ee3b3ce2237f54535417351ad733896299a24e869ef0c953001ca813dda606f4f64c5130da7db41444ed459fd8e8fc7ca9ef45f8c2340727ba95bb1790777578c1a5ac9f6d568cfff9eda89f7253ac1276bca9317fcba890dbba6cf8b434e3f0e56a8f453436a7d35d64db7ae505bd00476b11cd8322597a8a30005e34838829ce7fcba543a6cd8fed652f7a0a5ab99588054243f2573fc3a55d62d7dcbb08468e55814321ab56bfda81647da90c1ed8c4e63c91d877eafe4413cb77a4b565feadaded322f5b77303e7b7d0162a66fcd31d7b460546f7145491addb2532143ad6f77e5c3b41ba119a23bd1f7e3578f4634048d9aa1b3780488c7be443341bf7fbffec6b2a016cda244dc29f5a691608f66227f973cf29882f46c41d3d049d06cb7175c713a3c582b9ae99808c599ebec148c026e8af736013ece13a2ff83fd47259e4cb1a1871bdb84d70a97546a491d1e960dd7edff7288d899c59322c51cb757c5e807d42af67b5ea3ede6816ca953b28499cde778f97007d0107dd25fd493ae0c7a23572f139e76a19ed7bdf5191ebad0cee96cf843bb81b478db125d239d96b21788b182b6a5d1ecfcc6442da08433cf15bd599dcc08c9aa93114153b7e4e951d4a153e20174fbb04170fd6d7fa002043dcafb30f7c985ea27ba6c6f6ed0fc74127570017eb084217b2054a64d48d10c18f3ea3152228ca146e86ba742305ba5cba963d3d6cb9c4bf89e6781c884dc213b3428d976b7025ad87042bba09ea57b8a89ce6d3542e9e406b33fd37b8b5b647283f52dd59217c2d395e9132d6cf5f449983817f11b4f93433d9586b426a93a329cdcbc3c685d12d5df3feeab1de656ed99204b348389fc2d28b4bb0ce92d15b05fe821af7ec37266716a4d7bb4c6c7045fd34162ff0fccbf3bda24d93799ca458dbfe03e74860a79d283bcad16a1f43b78114de0c0780973393a1d1599ec9afd90d03522068e1e3d41025ba4da50871eb43ace7f9de611f48d78dde75abe87815cedd9ac1368c9c3920aaac7b1e2705da49786fa342b348b42f04c1215169ddfbd7955bd457f24eb086b8b213af3706ba21dd6758043a0a228e911dfae8b5ba9053ae57e9193ebb128f0f9c357441d4bb848121792e2c899b5023072a693604f173e0c5120beb0c488877be2342d3cf0491b55941ca6b264147ed7382953561cdcafe9c4e3e312343e52c66609b060020206d7b83217834155d38154ba77d9c1066811631db76f60e918bf40643ed09e0f7eebfef11007c09a195f8dbc7ade0537b3e6fe3ec6765a67dbfba2c17e04e209a912f60ba6ffe237af","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
