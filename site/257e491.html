<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e150d100f1cddb131ce4a7f0ae91b7bcfca7aa2238072b94bfe54c2d7a76eaa57ca0f8f9f3fa365dde127085fd6e24d660b1ad04cee2e8f33d306d127da733bbd26091db765fb31afc0056130872b642b3e7f79551754c129a01d5a33633703e87d1d632b914f9523f5101a4d54b0baed56cca9edb4838727a19f3f63a3a8a118abb745db5998283fbbf67862f2069aac2fe4f33d30162815b3dfcf106377d8192e679fa1ef9662283209ae26eeb3a164c813a80fe97f1aba5736da85477623e0c79873cbd8dd9ce7ff5f16d08827ca5f163a6f268ef4cf9358c82123da02873c21274818f388712c969887a8566067c119df673265592f113f8fc8c16fd6f50be7d77bfd404915a087c4d893c44aabacb045e6d47c6f2286d43d67eb5544529923e5f438d3515e9d3d7b6547d0734fde9827232e795b50ba229c787d8939d2f3f2308b581896f42cdf2a5e53e18fc14cf9b50e44ecb683deca9a1f46fbad3da852cfcaba45995fb26051487b0ccaa785153b75137a5492206631de6d2570632b8d1082fa92651ad3971071acae63d77917dbb1d518602d08ad043b803e0dd203c1bb31947214c5aecb9396b66f9a0b8991ebafce1cbb9b5864d825442bdbb701d1e261095977c7787d2472770bf9bfafa7e1e5d996dc77b120366af4f65d7b4b6447a8f19feda3155d5b61e67dff3af82fa452c158a80c73a52939d7f90882d9b4a4e5494192e8edaaa11722263f56cde8845fb5cb2e61a1499544d53cc4c0b51864db677518f790d17dee33703181b6a9d8973c6d9d174cc6e9d6291b826acad6164420cb263b95cfc7b16fd4b4bf0de33bc271e7a2f64e1c6d9d86a58a38a2871d4db7b1e695fc6e3960820cbda35a0612a9fc6376068b81e8d540805eb21aad0ada674b270ead030a0c70550f3904ab4f2adbb56dd1e8c2c490bb8ac144d9c761427d82c3d6aeacecc2aff96373ea8bc45c072c77e9850808b43bb9bd19059bc2d3475eec36da71590f373a06983fe0b3bd04f43de776fa3995faa3989b08e7c9aefd9b99aa3ff4c4758f51f92322ce750c1640c02778e137dab8c72db50f893462b58a445bb23f78045a1b424a8b453f8d5daef3dfc5a1b00ee662df530554908a564a2d4b26bee1d32e4329fef08147edf1e0ffc1eb88c2065b0d61570a4d2e7dbaf69a60968c07a4f64488c63c1446114f61d3915b26d300a97eefbc960e598861150bde9821484c986cdda9fce0c68881e247b419cc21778b9bb0d382d1c0dfbadc0217aaabeeade508b65346aec0cb8bfd923fd613a8ac7a0863319d1198eebe30bef5424c7adebcb7f0c98127a5fe33de8a24dd03e3d6c81835aa5d91bb81d168aeefcf4611f507b3c438c4d8ac3f3dc63e4faf75f5286612200ea48cd8bd8d20ca7ce5c63d984173ee6a433940182e32f56753cdb9e53fe9c5a6679c192a834a0222e9e8ecb6d2e9c49f2284e3df0c86015458191791148673f5be81a52aa5efdcd6942377e6ce31e8c53bb0b74f9583d56bb266d95f15ebcc45a1fd353255811a0e872f4e73888e711fadf0122430834b7ff1a92dcfff42845af7f7a841850a632677f5bf4168e9d21f03830892357cffb7421b8ccbdc26be1c58ac30fbf2d12ab4c4967474e1f0feb3bbced6f1f14ecc812c655c8924a88704bc1b361576d7fe51c68000c10c41724c8f8b1c77b45612d7afa90705e96bb471e8f521e7ca89a8d287d46ccbe93aa95cc9946fd8f09acf893bf67d8d8f38ebaf58361ba50fa00f9c3585330ba8f16fbf94227ae9aae8afa3670fcf4f93bf8b7011a7f99a3e042a97f0b5b6d9f3c5cd51f2b4e54bf7cbbed024c5978c1dde386dc89c52dfe68b4ecb2040b0c87c1a73c3fd907089379f0a4797f705e7294955b6acbdbe528a112aa8f45f551d128ca1df572a705e805f8c88999d09ffdb74d93aae13836dae2c934f049a0f8bebaf4377402fe415063fe89137dfcebdcd2369499b91384e7991b0b5e6ffe4429fe87341025e3e4c60f674767daeffd4f7ca0bfcf1ea1b7bc0fada80c7e5c25fbf9b1312e35d09ab0ab6ae9a57cf75afa122b4189f926bb0434fd189ae15d74effebd247e7346055732e11d7bd0236b216c3b650d95346587fe2f69e130737d2f42ffac4bcc4ca09e70afdcc390e0d475838a4a816d193072dec0baa27138db3f9990749141ce84cf406bf6fcb02e66aa3e2c94cf092705b6a076b431044f07e183deb4671f872be6a8e4d09b51848ac33d7ef48ecf767a9d30b25f38b6f9c81f03774f650c1356b492a6f6c9ff414c065a1301d70a817cf0a29913f4e62ad61fddd4f3caed2fffa2992d8a8bb7de1fd0b402544e2c72113864a9f2844d95d9f702fdb5fe84c5c91f3f3eb1c79f762569dd6b735987c5d3fb8b1daa47ba3fdbb25bd15cd2c753d93660645497697e1e9e5554e55082b3d407ceab322730098417f79ee22fd2987b6779c598bb8114f5c728ce0fa7c4bb12a9068c1e5442e3c082c9083feb7a4ac385131274f3e9101825e141f2773dc3f81565b312b93dac7052b443520356c6c36ea2951870b1316b9f104833f188f71ed77ea03c75973d5ecc015b8b9cd6ad1dc5d6e58446ca1614e08698ec4bccfc191a37a3bbc1a87b7f4747130ab4b9346dc0a8edb7178b115566acca29b4eb2beec210e5329938a1a57e259251bd3e24414591c1ffcdf0518b29d9db90bd71681810457413c1ff2aefa9e9c553d4ab52ef3e17b81e16ebccfbc5f745349e58058e6e08de19b591602dad1466e8df59f20d8cd51ba86415b1ad8c14b16e825cd4f09c923991044591c74e34c54c56dae4c9de1ce5ff7e49f7b339f11277df820d19baf5c69305bb2c6cf7920db7db09bc5fd7192de847fca89e4917274e279f473f0b10996d2f4b4ef7f65e9682a61c2362a035518d617b48f53c184b3616abb1ec7f3762fe26235099f497ab2a122e10434e8b933d422167ccb444a84397758993c421205264720805b7bdf2bc650dd62cf48c5b8375e1980cb38693484d879c65e901bc41c155cc7e6f72bd0e314b7135bc2e866d45ac074f3901cb393685983fb92fc0ff289142d19093e8502defe18a64e251b4480f2578847cbdb239ce75d6ac154adf53549b621989ecc68298683c0d4bc30603a982f8622df3d54230a53c05e78ed97244d4463e97d0e764e21c782385f44fcb31df2e907db000cb93c4344df204837be641d8aac90f404b0eb78d5c53d120b76fc6005d204db18ffffffad1f19e5e220265a48055e01c592e7f40c8e202a8e397657742013c6ab322c00f331dec7e14e2f7667c3bebe32f5d4885bc86efcee8c2316100bdd326b9c98dcd84e9de30a218878ad8c090fd48b13545630452b2ae0eaa9e08d93b9c2d2c20ce81d39940e4500661db093825722e87df04d3c7bd7f9a4157cab02c354c33220a0cb6c76838f10280bc7221139114501f963cfc661712b9dde4aa58bd0e9e224549f213b30317eccb792236c8fcbcb4241e7250ef1ceec8fefdc77acc8dba4601d057e746181eef4a8feb9d5e2c8c1d53b53bb4135b61d2929f7d79ee99dfd68e1b56788fcfa72527a3d96c9e5d0a7e020b6334cb022bad8fdb890c96cda125030351a10c3112d1bdf2de73c613ce0dd4a7723449a61892c17856f8c1cb65f727b78ee3d8acb64ab49e72a31d1891873af32e21716d0d99ec8cf8c0009548469049fdd205cade68c90e29deb8a00036225ea389e8c0df73f3fbaa44d565aa32f67e2619e5204c29fc623314ce2ff92d79b5fe3e566a0cb34c2ffe0a468ff76a2157db31ed1d128b7e011ca836fb5fcdf3e124f2895d151a51edfe6d41af41d332f7dd3414fa19b68c82ce21d0851841b55302b6a6362405286610d3227fb36d916533202161cbb3a2c4f46ff4a0627be856dc46228258fdffd03179874b87c8b7d01e7d52df97c7368162e9ee20db4f6e873563fef0a80741daf07d28ef9f3f0eba438a53bd4c0e34f063c4f398fdc077c28fca7339c5e0a77742347cd19b81de410adf651e85c82a034a314a2bdc70d995d9b50a5f779a6e8bfe962cc86255b6766b488c42d1725af6b6b9f09a23e173dd83e85456af0147c17744ec43617459047ac28559e7c0b1d38cdf34e380b58c044497cebd9a72a6e23a18df68ca38d6cb5e5819582266b47cea3639ad1e8c1594d658012f46a4fd1f605431f85b85a21625f30ed16e331d1c64423a4a95a5574766c8b00a6c0efdb1eab2f38b9da116a68f745b79e474dcb90b68fc42f77871bc9b3c6f406ae63de1119fe12894de5d171c8fafaa6ae371beeaf50898b1811adacd5ba85e08ee0acc7b3d78e4defc57dec666ab8b5474a0be237e25e1c04cf23bc719a2bc23b03adb91f17ae119439cda62c74eb2c14770891cdb81ea6ed2a423ec2406b99fe90d350ef3f4c7e87a606b2cc8730f4af9e1b2205d4019cb80a95753c1c134559abd3b6cdd56115f1f3e5dec3599731fc7a3e7ec6623bf4439458de0efacda97f1315f5287eb29a12fa97f016a2d9cc3ccaa66ae0d10d440bfb20072e4616771264a1cbabd43540ada86acee865312bc2ed3aa99d439141981588e1c15c127177e907926bf59614392b2a8cf327eaf6aa85426c7fafcbcbb449b8a8bbbe44cd91c7f1acf7d8286d5b91a410a61bc3985eb0c494dabc567a06c372da66b7d9c68c384e6185c943c76cb44c96ecf29231ef915c0a92f8ee8a57468e3ab5c22133f1be11a0a5a26db08125e1bc04c4209ab1223d884c6815aef69bae33f8c237be880ae00cb7e38fd9662726cd3f58a6ec60d21c58a7e085bbc5ad548e4b5ce72353928bf63f54a3f0f3ed147b3df33def79a2001c5dfe0c5b09a83a793110f5295be3953463826974bc89eda36219e9d3b20f39eb0aeb315c212b7c13b3e071d767326a78c57abdd38c3fba87aa67be61f78602c3ef552e69603002fe582625bc539a956db17f57fc290686cbd3cc3d160f29c959df4c6ea74f414022614c3e2387e2a3bbd89cc4b8b9867ba62365ca51fdc50047a5c0661d1dbf8a5fcd56afa91eeffeaa8e37b1cede2379f747cd6b5600232fe0444269b52743e99ef1f6500f62987309013167f8f51d5bf45cbeaf15cead0fa3c345123843c7ea0b198a32a8c0b044a154c4fd8b3d10d1a98ca61265c1425ae5fe3248d84033f53eb6532bb1de49277e61fe023c6e9c4adb16880243648677182f06cb7e2d5348abc6645b2b687d91d6c81ae82e331fdb06346c734c97fdbc47bea57181398c7f2ee878796e8ae424089d0915296b6f42746386a2f670b7669222cbed8107e1c0e56ba82a7987ebfe0fe05a6a71e49edc0777052bb3ee7d6a252628c2ed332080f845ae584892a952fbcd9e3b4a4075c6b2fa37384e10e4d12bb79688d85b69cf1d2791596dced7508ceee1d58cf6559c22d315de2ab8c261141bdbd6faf4ceec537bd5bcbaa337307e71d69e682c84c16ba6fa7e54b32cf4676737d3b096eeb54f2264d6808721c65ef8ccb29ce6c46882c943d51176cc20f8ca54ade6bd6a82f50f1909bf023130f0594254f641c91cdd33bcf0d1db6ff36a349c77808b8a8c068a6736ef7c8779958b9af2c12a9367115a651db556b8ea135da540bd804e61585898032241188cbc9ec0e89d2b90f74ee5191b44d78e4d9977614d442ca6e2702ce0aeb23029751eb0e234058b32bae988a544724bd955089ef77230ba0529a62b05c3d30fae47d3004ebc6c2cf95c8b91d64ed41f8cacea21dd9d320e95381d490938403ab831b02a07039975895e749ca162228eb4237d9128f7351938f85daf685732817e48d6dae1287a86bd7d0b15b40e30474c3ba7099e54fdf9a4d4965f5d75bc799775650c103a8813fbf7f4e765022ceb8ffbe33a2ccdf2c8d380c10374258b83197c7e969ffd0f155898e27affc0e35c522bcebc97a68cc12d81b18d0a87e72d65bab4664fdc16d6ff08c0b391be76126a08289af1900a895df667c0e18169ec75332216c57537bb1df8636ecbfa426f0286e710dc0a1133e9b82bc6a60ef5975becf4ca41e02e60b8a6eade86d37de27000a310e800359f2c04c2d53983a490e05fdc38a3a2b011c1ad16e20c1b9594b021644e4ec2acaa9b1166ff3d059cd7fc5c23b9abd7bf715557b86520535927e79bce947328b2a8ecd68d61ef66b266e304ceccaaf916841b923493169b9e4809ad3673a4437216753f29561bba46f5eda99af0424874002ce772e5aa030c965a926e163d771febd4436d36e87984be5696b1633878f3b53cb5d3314a1bdc446b9db021385064f6b15a3e4cd295c7e88e648f9794db6d7ea76bd2ac5388d3196791d60e5a0b81ee190543699e227c55f223cd3875fc53257ef481491982db65ef6861ab97ffbba9990897cbcdb6d79edf1566c24b53f469735a682b483a45f715072ee43873a67282c2a21a9328044b8303eb6db98ef68edc9a227c8b21c6b722a0e5a398884f9a815bdcac174f4a40b3cdef15baf8111e46dc96391c9264e201ca47abd4c9e3ec46e489f511e80b42b74d7d49dea8dc5253ef639c88b938782f7257b8c57f5b0f3e74c4e79e99f8cc371b76f9f8670508c83c42b8fb251ec7cdb9bf5913ec09c1e6d9450dd2791758c03463005f7e804d1eb8f5a1c0f259729507272d013a1cca5e236ef2430c96d09d815e5e0577c0957059677b489f71b8228461ff8db0bb9bb19bc75653c6f9d382a9d65c64462fdf112e284370467f186b69650099b20a86c732ba0a24e1f98bea187310b4b1f1af769cf0803ed0296437407ec58e8aa27282e21e64e9a5abcc8a3c8ca1ea62fcb6653369ed702ef6d34348b98155fc3158b645eff1ba040a6f65826bf1edd9ca810abad48e434b14186c99ac4a2cd54c9333f34847ca27cdd8dd789e3326344f40b2d1236452d6f45ab7f365bb77114eb4769f9a118496a89ee837b179d11f279a1a7b51d167c3015029c041dffa3a5b750558f6c19edbeb6a2f98b9f3e7fdafb3daa7ca35ac231b0dd7be2b4de568dca61f33b78930b2cb35458bbd15494eef66936d60b15bfcec369c9b559e19ac982e8d768792f91efa6b44a498a71316fd09065865ca9dd79aa2630e81d9a26fcb81c0736be0f70ddd0a8a5ebac13900fe5c543ff4f3a1c920b8bbfada329bc37aa47f0fd933c59dcd43640ac4cd000cdc615a9fef7a0d55c5c951b9c50f125bb01be5656caa36c496829571bfe4d8974001ddf0d0acef949b280194f76f6a55f00942c8783d3d0c12992a849af2c4d30e996eb9267ef7d1b59bee1cff98fb68b31d23795133b0b4965a9b22c82adce62e170070666648c93fbb342b0f54abd341ea429481193680ea1996defb6b4314da77954b1a61a989497e8d6b17a739e5248476e9f94fdb3d1187f6e3c0a07f49c625ffa52a8386d9637576146b5476b1291589e6c3fa43055da9f1dea354edcc63839d8d4ce13d35532615ea6ccffeda501e4781e55fe4742341de086803e5a51fc7534113b497f0d375bf255573dc2965891e4c809be4315f4e87a403d1dca40a3456f56c109b7b1d983eb09aa21260b75e08343092a2bf4779d9017dfccfef0c2913f102ff114dd5dd50154907b854ecba80357d8b7f473e527c4e59b6401392a92986210a50375c49e8a4f9bca6d850d61ee01467913c24012a320a22b560600f84f035eda71c9dfae382f8b0e877f55539ce4c4cf04d51d5d5087b1165e46d0acf54a94d72fdac5a3037fa78d83f55ab2df889736925333dd95d9a6875799c77c4ff3d2b0c853c22fe903c1a8d6dcbd7452de0fc11d5ea32e476d9c01cf83dc5b7f198d34ecffd98c7dbbea353d664ac9c8d73d4dd2e5603c8ca6707f606f7bce26a7e3260bcf7c1ca92b93f14427a1b4a2a49979ff23c36f11ecb407ed1b0236856f59c2eae6e7656bcbaedbfa32bb6bc5915e50868b106ccc444ec8ffa8cb77f42958d3982b7d5be94d0fbedf5807bbd6c43bf936e3cffae4d44334a2f8bcc8ebe63223e4f87ce74d0920c3784f5aa0f66342eb6270c71007a3eccecd22b39de7f965e0a56ba4ba828778f3e1e9dd221dacd8d0bf12c0b965e0270b98e8435748df7d5c821522fea96b2e8bb53dff49e5d3c4b9947ec1662a32c9ebf4afa3e8618a81020c0c47079122a0788dc0a051e1650ad1b90d8e9bebd689e1bb05422aca505f8e39d60770fc55cfa1a89aa384ea836c95ec2e61722d2ec8881c6c8b527834b50f1cec382453a3426b900dcb7ec093697794a335b4a6ab211f7a6ea4d902e168b4e3247a519cb6f7670736b9c3d4a227b9654965de57e5dba2a941f2d2eda740632bbb5a77f1e99055387a041e3d150509a9ff32e2db6d85156472bf0740718c379416d764207cd468c0fbd3c9d02305a11e6c874126248f6926a87e59a6e569a60dd6c11d6abf0d932a62fb11e0a77174f5da413cb0c9c17f45bfea7dc9b11bd8695beb698c08281c6769d41c1fedf43df8ecbc328f7576f735c08772485c6b0fcabbb17b889286b7a718b49d3498828e4e4c7dc5d2647f73d3aec04718456aee19df84966649f370f68c762f619584fd3bdfb41e4257fbba26730d0b19e09803d1c4e8abb3f6d8efdf8384fe0f097804057c69858e0fe57c38b29b50fd1a33fcf6352134e4a321ad13fcf22dae1c5ee5a5a3dd6aa3c21dd48e5592c5d3cb0e68791ee3df362afdfbefc547e9b3d9b7f984f4e030af59c4f4da9844433a13a816e19f2a26639526d341821d8fb2cfd4772aff15f62d3f7f9c8dbc0af0b28090fed0ceec633ab7b3bda30ad3ee6a6c1c405e75ae0f223bb5167dd214016e2607f779fbdb4ecc8193c2d1660528b811171704f98e66d650d2808b4de9d852966f8cb98227d19369dd1718ada27454e0f2af2249a7ebc046c9b2546004e21c218bd3307f9f4c7e6c367ae88b7414039ed7aab70a142cdaa854b8a4fa2677ac2af3798bc14a6cf5902cc52e2978cc27483f529dbf360fbe8002c2f07261f8b9d72b75c53bab8100db04c30958422f268dbd4819a6839c7aa300a5197b9012dd6a21c0b23ea3d633706ad4c953b020f5d0dbd097905f22a60648c9abfb4cc1798ea48ba73345a909c4c27b07b39b5736b2a6645f29c9b0f4d921f2d528e27d8794b82cab2d89975e7d105d34989463dc414fc2fba36773d26a1dae2ea41a37e800019746f92d09fc14c09111871317389e32ec89ab6dff224508a20014e49d1254986d07819690367ec0ac9111dd651a008e1e579a037756816184045a758e6a9e5ae5eb19fae89794ae5d7dbd798255c4ad148e86dcbc23fe07a6377018178b859b7497541e4481ca6656c8aef492032bcf6684ed12da70a5dcb6cf9e54ce29d010347aab77955627b8567ab18bdfd69fbca95eb19be5d1f05df486ee2156ec6743243a9e818ffe2d79aaaac355d93f59c178fed7c4ef3ac8b3572ef03d943691ea779717f172c7d2329f3346737c35fb70b12dfcae6e6604473c0aeff5f9bddf05979b8228bc84db838c76281be0f4d1c9a3d6a78a931dda0740b72f0de0f6b055561852b88087001da39ec151ed8feea9b6f05dee95db3d08c2f072d4517a6fbdb23c89dc4a4e85b0c9336aa0dfbe46ae41024ecd1af3179b462017ad2b09b35a772940a159fd63a7114ff8c561e0866b098e1768ea86392d134f0af2bc9e7f2a2ae443e85725dedaa2030a34ae5a44c77003db0a0742968cc8f090a62524df75f7b7ff91f5c78377f7931b3b72aa7f6fbb4a580967827bd37a8f5321e1106bd17b75403a23e13416b362feb704eba49c5ae82183a09c07c8598c4609742241abc2c6c7758e91723b58f587bebb79f17db8b42d6dc6f53ea89e3eca37afbbe908ec2ea0d56a4e5affc906af546163d92507ec745df6e88c352be2cc84b4710b5d55932c839d3f859735306ae10d79223a3b5492bb1edb3e2b1e8147d9604326261fdee96269ebb4723c033db8471d76c4f6ca9e011443efc965127565f6393c15eabd06c71175cb2ff39e921667a94f6946895d91d854ce0e3655b4382eebf10799bfa6b3d42f992447253a50ed7b31ca1a8d1ecbbd7d5e615f716af30263ce444a813f52d8453557c3f15c1ea8fe3ba7cb035b6d4da26113f2a2978bf5aea92f0b79261ad9f9ee5b01ce3143f6f2ce481c7f27990068d170f707d274a7b11503ba56d047bdd5e917cc052fc67640623868be994d00df4cbc5fef8a08ccbff0a2fc6b3ac891f3981ff6b1cc5345d598ac6459adc94e12dad48b846897b789e3f1779ab069b513abb246e64d74c4f62251c724f78046218cc3171f5b0379a3e4cb9937fff2282f4eabee152eb3df3e9ea2d86ec8c20bab4f414706480b5cce5e4829d0ca8afe383005bbf85ddf7acc4ae21712b5bbd917e6e9d61bf7de52c729476f856545ec647db02a2518a8a8c6a69b748192e7c7c5f4f5aab5a4c7efafacd897c68393f5ec8ddc7fea844da433aa1579c10b9d8eefed565c83052aa4af60a2b35597f5e84fd8ecff8d5e10627ad5d2749712bf26a82dc521ec2b78f9314386fea6bba440a72aacf2d42c1980bfdbc233a1d5fb70c746387b156b2a40aa868525d8a2ac03a8f06ba5ea09e39d932cf169e11a6de8b1c4087ec20ee78d4b52b76b711ebc834fbd511cfa1767886bcc13fef724128a7273f41caebf094f5b9963aeb8c2ec03095dfc538f1c899bd3223004cd749aed6f4d8c19a96a91def305d52996d4407eee01885bdcf086b76844f854c39df94de2d7ca4b3da43f3050aeb584d719108ef5d15ac0e740b0f5ae1cf9940b3cdf29114d7676801e07fa54787665e8320967bf271ec27f336416133fe275752dec034af2bd65055f828e373e7e01ac3fab11afe9fc78c6238dc390daece7e50b5038e040510a274bab795aa14d1e50ea0b5307eb289a596d62d21bf8c2a692b73300141611cb95aa97ecc9f37aa1211dc898c51ab0e1079864134de2b6215eff4e0bd3d168244342b0bf8153410b002a07f4aeb8b3c5b520790189c9cd091307b407634c33b2c1db848ea912f7dd9afaa86d10f53ea9ceb4f07b25f9455243ebebfc86561d2aa3df1e489b32e8bbccbff2a95bf853be88fd0d79839893367f621bfc624d2e552f3c3d1cd5c7bd291c014d87d6d35d8f6cdb42d653aa823a15f7b98762a32b6762dc5295fd79acb1e4437b17133343dec8e5d2abef84ca7508d54a616704277fc080d7f54bf6208a8349a21f9e2ba96828aa5e6040ce01a31670a5cd6d1a2310d2ec1ec4b39057ac497cc86ec5c2427c8b755d99bf28e306b34898f382571e234c39a0dcda0434bf94a10fa68b68a66098ab5492092ce8e9a42d8aa1c2e14cf20688ea01facc92b06e257caf9eeb5d479cd8815dab5da146bc9dd81c2fe573fcf497155a15a4e8c3a5d0057609245f20c26661fea98b2fea94688b58ca27ddd96d431a1b78984beedd632db55f55e543ab85","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
