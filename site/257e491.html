<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef1c22f1e77005b17b6bade1021326caea34e0940890fed7563e8c545f74efa0f7ba10d393efc8a31b57186db7457bc25196648a8b712da25b3f064fe4790518976a85e2007ec0fed0b0cff0a6cbd79fa3d067bb9429be568b1a05fb356662ca6034e8f8e5b4b14e49b1dd94cc5f579a1f14cd5cfbfe24ad4c5d60f812dcbf043bbfec459a6af5837f2ac7052e3183421381002ad3d00d94bafbab9f058172b975feee6fe93f95f1c901cfd1fa3aa9bdd31b70858abde25c6824bf086bdb47b953b7b50b24821a30723b065639b6a9dab24537392630d67cd78e1638e82f066d55a1e4365d9c0b0666e93575c67dd70cbbec5416e3a83698ce9369b6610e36a333113f8ad65970ac4fdb8b1e7e0cdb887ce0b2bde4e9f777422215ae07cc9e3ca9d69a8ff8fa342341aa25f4e1d9b2818fbef0c75d5976d9fd00ee14f50b2f25b4c0486cb7a1c20ffbeef66e2ebafd76eaa35e683498604672cd86515ddb94a21cb8073c72514ceafdb0d976bf749624c8c4823eb78e561b5b11f3a55001967a793027ff6dda334954e1e6b607c55dc726a96fb63404e2a679713232b1165b6335ea838e79b1aa38e5223cee5eadd16315a4debb3b7b43ebd63eddc4c2b91c7a2719db37477db270c8629ff1ccf4ab68949ebe1d5b7cdd1fc30c47925e9ee8a05f6304bb8ad7a55b692f6e9fd902fb6375deac1882ff33a3b28974c4ce5077cd92897949ba2d383d12a4e9bc4f2585061b78a89257152f85a33b4f821ca15ec6c4d42ffb52613b06ebed135cf80bbd7978d6b98a0f62a9698a43954a4ba9ecd60693c67c072d3cba5e13894805de1bcba62802cb540e707c2e723d4af81b26161206f9d0600741033c7776b810edaf8a4f17b5dafdc8a5be3f8869a01d934d7bd340db0eedf887740d8be966b741073040f54a7ac8a5687a7b233c8d52c352a1d09657acdcd4bec86426b6503d948e5b4bf54e934d9712b8363e4ce31187d1f02a62c5ea272b028ee76b7c38c47bcaf5ae4ab7763834e3ba323ee6eddf30d8b60e31a2950c0bdb9c05f1bfc065063500c5ea83c848b794362ebd0c1a2cb65c7fdcb085599a953cce290596af9ee300517457641f5a8051d1cfded31ac191931077c61dace4f335f7e8f027fd91656d035ade87baded50be3fd2e761108f626635ae8c3da66298e7fe7be13bc7df5b0dc3a048e9e7360ebc98ab909d984e8064a27d46bbefb9ad80ca48a58d3ae19fed06d0673e5b6d7e0aa2dbb60ce3dfcd5451e4ee2b4e2b41832630cc6f0330df0940aa7e4a45985127da93b32f7b59142180b8a9b40af58516b98df28e3528f9d32d23ddbf887333563a64dbbfb4e19cd12a7222370ddb939874a0b491b6e14a2531197d56fda0eb96ef57d027beabe2644dca099320f7966f4f3d8e9e2472fb42c136aa4979b756fd9b8183854f750bf8f4a24430872f8db3930d2724ce92f69ee358ae74e49e35f6d9cdbf257da19447dd267d26f8e2deafa025e828ef10ca38de931d72eaee0bcf684bacb027cc866e9f31fee0490bfa5d4301187f0d5bf447e59f57909e4d9e2054c9f549f7724fe82e3bedc81e58d03f7877daf0e29e4ef69c2c67ae9de3f676c41ac83ba982650874de162476561f9fcdc5c7b50e2161ed32230f1e03424cff5b5421aebdf6498f501fb25dbf84442b57cecca80cfcca4209f3c53368e420b3588af335e33025f0c7fb89fb0321ce80fd99a75cecedf21c8df661b97586f810a30603b2e24c11aa88bcdfe234b915a99b0f6ab0a1e4277cfc515d58738711cc17078ff25c407e80c8d031f5bbc03bc779caf22070102b3146f8e012750e85b58fa2cdd0b33752d4a9c58226ceb60e5363379434e8765306bd8a7d1a2ed4c0121a27989531f7b8107eefaf3410d00c300d844fa2244a5b96ed905ec0043afe022dfe14447446559f43e232dc2e8efd60c5f7cbfe797f0928e7145244aa3250fade284668881bf2139bd44b6d732704aa3633f414ebdb8d7dd26c5e53a2912c8dfc3e83c23e819a87be2d402d2eb4b28404a59457c7c6d163a0b73b79a885a700fade77e24e76f0458c2424a76cc5c642ec5d7ac64149c22521f791c3692594f93a14292831610096c44a1d7675f425615554345d602b7e5d696945d18236e3d8f2fa24a178049b09aa63d8c45c2f527f9e9e6c39cd2cd9f9fe2600eca15b2c1be9766654d02d5d00e6fb30705bf0f033726c7598f8ad65ba337ebad96ca96e0fb81787846c3676d663073c21c704c71738379d769da194ab277884fcb4b12ccff109060d4b7ae47438a9ceef84bb854b4af6b68a360ea0812e8901aa6b6ce2c6e3b888c93a6b2ba24736a5842b7f8cd805bdb87f31bda859901a8e315129fc0315a5779b37a0a3147e23e538107e946c598793081616effad3ad0a308511ff2d5b72b97594cf1452f65b6cdd9f891210c5ac1c1e0b77c363519088c9a85fd12c77fb9056453118378d7fc72ef7f64ea979b1c7fda7d216ab97f4595d94c637a10898754a8bd1e6cd25b33024caf24284d44c998adc6e5872956514a94886bce7f83ba0a60ec913d1a4d6acc99994089d9837e3a4e4d62a1e8a7afb5eab52dbba04f150f9b9aaba9f848d011cde0540d30a557fc4f3d27205daf359ca780952f9de51cdff634f5566e6adddcf9debce133456085063586b0c4ae3444f24a207257004333699c53604f5249f59814aa303f2683ae22ae12f0aec0ac65b061180a6c5b81ba10ecb70474acb035946afff09e54bce3a0c005fdc87225891ee28c2b2cf08fdfabcaf8352f72ea21c2e17c8e54070ea96b6d93a45c5d4fe09a97ca4e593232969571c4b794ed134390a66718f787975eeff63b850770309e5caa2e833025024b759af60eea10d2ff1d079295b9b90fe7de7e4011bd069c07bade9f4db9bed318f4e2a5dcdfeb49518c45d055e355ad6d18cd9151798d844959a22e8ffe905e4644cf5dd2c7ba86e719c2f3676d56bf91ee59e342d99df607deda2bf14037baa8b5d11c8f101bb51560cb88b9a7e53e18ca14fedce491c81df0bad5c02880df2b6076ed5d799744116ce88dbb444b4a72d8cbdd80801385ab63ee476dab0603f9592f893664a663c39991a3b36359935b93814e267a647455957b68af906aaa604500f6809276685f563359373bce912a9fd0ce6b86794a36e9a66dc4efe3aa2ac00bd6c12966b92103ff75e4d33ab81ef0542e4f0b97fc772020e1f51e2fc70fd19658d58261150eaa082b9fd5a4d02b21fafb7f679d9034fcccf719bd6dcaf79ed3d205c6a170d9637be6bc780f5ec8c1ef2f73ad375b4c03d6e3200a2603e8452eacb95ee8c71f89806fcd971ba536ae69513ade45f4c704003f4c0726d3544a179ef5cc9096d7aadeb2276e3ed728df981cc03c2739b15e3b2cca8c94f28b5e3b80205384af3fec42bb39e9af30c8a3a28091c6e5d4dc3040414124cb18a578d1c1fd1794249875dc30f7f5392b53f9a8e0811f55ff40ad493bb7d55a8ee13d5af43dd76d29da626b949bd82478bb50296cf3b1ed41f51809118c641ed94f40d9e791861bba3b1421e960be0f6ea2706786703b9df716f02fdb262725be22aac82d425f9b8a611e2aff3291d1914f639ec705265c5e3b781eee88054698dbf103c52894a8ce83e85df2998fdcf598baafa76248f8e231d88950d6c1dd2a836b19b08230340fc005941dfba670921ee6de057096709ba68de1fcd4a777f9b477aef351a182cf346f225f38965b0b908d12fea44758030c41a26fa6a0076d089419aba98325826d90a751e5d6b4712f27e77cd67167178cf52d9c9c9113883c95828a82a66106354f703e7252e729f3c94af0ec2150534b1b9299e0bcd43873c6d4ccc303943bc716c3baffb3b855f3a7664e79c6393b2032ddde818dbe3e19b23efaef0df3710a35d1b7dc1b5225dea6f46d83d636eaf45a8d5ba502ef9f4398c3fa1b4ecf676974e458141ba9560c5354aa31bb69c1dfef533acc4d0a78fd4a14f4f0245fce8bbbc8f2f1c059fe3208df7fa65e12a3e5dfff92692042c6d8db630b602dd7962b5b2176a9a96ae609fa8647af3af9bb8bc6349a9e4eeb7152e2d0af5975080254b7da37e0433d5b59c37d270a8a9564f37dcde034b54f1d3e60bb693a572a5f6c416569ac6c7a101f18c2281d6a9b61311d45511ef5f6776431946f6d11195f0b97fb41ed9267cf10065f197daffd399c4e60f02c31a47e22f5b4ffbb20669400030c7518c5788265d154437626868aabf7c05f9ad6fe7371f9d128c27d380608fbee55300f577c8e8f9396a7f73d5078a0133e8d0d5a984d1cb81a998aa70e53fdea0ea4b9379c467f65048f5db1df6456dec6957d3cdd534373dbae891a843006bbd1c95440f7dd03562c45fd16871837dc35f7d1830579d8258844e0f85349b1600ded49dc8e744dd7564b3849331b3d409c5617d3d66bad801baa4dae7c3b5e464a8a2c0342693ef8c3044e9e1e6fee8642ddbfec65946e3ff2d68ee980c2895a3dd6a18192ba1f370da785e82344215cbaa5c5eea1db3dc9985299024be47d8d1d7bc37dbc4addf774a8103134528709b631a3fcae8a53a6a7bfb78d074b8ee50c3427f2a7d91633d66ff4a9b399e63fbf7239fa41c380304ca2e35d66be321248d1ffbd3299db77bbe1dc43893bc7257e0ff05321e3b6d562fdf0664e43f0814f5def4b1e9a34af0309d65676257aecb224a03e7d96d680fe159710ed4138ced5dbaa7c458ff9fe0550bc0c73b8f8727d8bb586c7c71043e8bbc43fe64b8f0493c0575a0f366b27e0412217013e0e162efaa63752f7189494665b4b28105f8570fc65e8fe290b35dc1bc2844fd9cd0a3d80738779d124f835899be9993c3ed7cbfbc79cff5c0f206c3f851e12114a79edaa300ea5718ed53a1b7eaf02a68a8a5df3f62fa134071bfde1f6af57c609d5a4c22e46aacdb4abd3d8dc3a184f5a126084c811eff38dc1dc519deb35cb0b69afa3e1cd6003de758e7478abdeee0e3cf5a5b5c2178eec860406921dee8a594a26b1babc61ec3bbe491e615273cc4f4d9c982d9c7b890bd665fa36aff4d7fb55396203f4042e07d810114a3c816a96d0c7fb22e35e8c2608095986bd234f4f3f797a2fad8f6fa8614e3f68aff53b0542d63feff175e3ca940ab9df16079ada32d3e824c78cde7468862f467fcc891fcee21a792ba4920a92ca6968fba3b4ba5180dcce8d2eaf01d6a3500cd89a7cc9576ce1299c72e2223af0ad94326636f62926cb02e6c33983491c78162cfc718ec3e994f2ee841735a948f5fc5b6d6c7b4efb9288eac4af29314838f0fbc1c4e5be7902c5acd21936804a8abcf133eaff7b53ee12225bbc8d2a56db5ca1e1d8b6aa50dd4221994254af85c91aec4a3e6639f535a21c0d1beccd6f1bee6e67e6506a111365977790c093df52964ebe53f42e9adca944e336897e4c4536c5dd6d304617ef1a6b95651dd38fd6f2d9da57809006b5b5e865480b77a7e3313f334a61962077a3c2286ad6afe37dac6a191889e03087e658d619fa1d7c147ac85eca2fd2665f850e53088f2938ee30c17a3f5be7e5d381144a18cdc30cec5ccd746ceb179332f7d4a13cfad341ca3607d1fa48c285cdf03c1743e692a91c2bcf3278e25d83495adb41bbabc7f29552f61b9691b43bbeee80300bea12b33e5853fa5e3348fba7c3decec4bc8e8a697926dd2a480160261268fa19d91739ef5378cb0b9d63ad90effb5b34ea7161c2a80cb53acd83a638077ff25a772d9b30b5d291a0d779309fbeb73e2e491ce57de786a23637bce34048e786bac76ef6c685ba730c927908188dee52c13c4e68510d9fc88a4780d072e89e452c9a9b0e5e51ec58d4d7017391ace46e87f66a0675369a517353a573364856cd6ab3966d5d2e8d5bee50d6f4737a55f85781a4d85aa6488f65864fde8ecf0ed92555277e5c2c2e9ddb1baedd625f7bd6100d1770539b1a0a63179b37f4137f6b7da9e3f3f4c65bf353e2caf6c2ba83dc5c125f1e7f63dd1743264d354ce33855951ce8306004a6c245018828fa2ec8f9098fac35ec33b29094339d006e1adbe6f8fa48a115041db12fc0de42e63718471d13b60c68f4223ea0bcd0c0b4979d845824949cc87788dd2c76e30d79c929e5fbe5a97c15df6cacdfe9578929544b5418d97fd1785ce75280e916a129141de3c538c75fb1497b6f022ac7e7008dfddee87307c30dfd12c4cc597151e5ae1bd4bceca3f60234e58e851657f9b0d57c554dcb5956a9dc3b559874b6ed9f7a388b825d3529cdc519b36fb849aa25121c6db844003353697db4ec567eaf1ef383eef319a41bcd5e222dd9cd6404d023147985617868743bb8c0b444728a2cd70a507f93294dc25bcc38a90a9b656833722af629fbbb1619c337b36c5575d5d50ea3a766e6e29f65181ffcb8a4a32d026d08c358a4273f0caf3724a8bea93e39605505fd5bb18f6baf3a677c8edbf213cf640d037acd7b60d866db460a6d61dcd8b75a96cfc2e16048020c0d96e3bf62a6bae2522c201afb7c65a3c8fdc5f47d132402c3754f41674faf1f2c5e3800774142c3dcbf8bd499dcceef67806da22c38dd82b4b73fcbad2830c92b3ed500efbe1e64dc7ea9b085b9bf12c2c1e8c2a651c7c4b0e3242d344cb1792c5aae4ae463d172b4722f47fd81b90e99cb719efe8189e577de74e011a4d1e6a4bd1c93e014628fb8496ae341a454e764f8636576a638c83380f8ddb42735fd1f4157f1e617bf6a566b04e7738f9ce7cca988bfdbc2a80e76110c847354d0214204d5cdc8b5a5cc1195cdf43799e55179a52530bc31161ae1f046924068eb2f7e39c4acfcb21af0a3239f9c0b066c9b99e5865a9cb9663f8e849822ad65b0d0548af6f62746eb94f15cf382dca5cc8aaf9bfe5dcbff9f4a59db1a8eceaa0dea008243d54a671a31f46e1e44a2ee170ed7e32eac2625ffda5649003b095c44a6fd55bffd8752726d0417748f117df0f684c5db358293072b01c9c50497c0a4efa40ca34da2cb6efc7d7f118d75f2abdb64b70e31128fc8fbd4ba3b19e1ebcec340786b00dc06583abf9866b76cfc5bd6da4c0575c28526ac9becf1e04be8c02366b51789da270968ea2f46f99c12b6eef8dea1ef3f11171b31b4ba56a1d4713979e5909b7244ab3c23be9edfa6af396e10dff510954a9cdd6e980d63b6e352e2a603bc91219e616d0d031ac24f43ffbc324a2b1f4344ec443a47f67108aefcbbee3db3d02f59ee1f2786648730a48fc71de1441bf1622b06d42575c9744d6aa80beb479deb57b201fb2440d6ed4963ae564adbeb13100b32df7e36673d7acd32099d462157828affd7cf82ae66c7f91fca2f4007af653097aff65b87cae2a8352fbee2e4cb41edf8cea254167d0f12d3fda03d40f365d1d945cd3fecff6a09fc995743e97dcbd803e5d495021bc54e0309a03678f5ca6b76e5911be0fdd7c41ba90d29b232b4d994c824b3a01d10868eff03bf1093f3186cfc143a058d96e220634a0ca86813afc714c6445ea0d945f517bed40f5c2509b4eab49af299fb7eaf9a71428d6ca679214bf6dfc3cfa86f94ede10964ef4d57c7b2a06cc452bf8d33f11b8ca93abe2688fbee76e9a8b7775dc236348c84c670b921c58e9a8f58591a7bfe283ba643480dbb7cff804f5bc5258a44a995f7b8ab5c4e73f3e3d2da9a4f5616c3b9183af5baf3be5cf283cf91bebc47d429be27a958f1e4cab40e310e08368d38f5bb5c1e15517cab25dba47086e285fd77dbc7af31834ac21e89b0c121b73eae8a05043b5c84a6033817240ebf64021a7b3c6e2ed3ffa15b1b6bca12a4a416bd5a9ce78c2ed88547558c354fbde1532b363519e66c9f7c1c8ab303c55de134d2b7de0ddee19dea37fd0af2776563a4d7d5052e67ea1ed54b2ec80dab5a45f5efcfae297823df69596ccbbf0b5bc9f5817a0b3fd9a5beb6153d1f2c2b9680440150445bcf4e030558fca24911b17e8078548c67125b3b408be58e42d2c9ea1a5bef4fafe06f55a82bf039bcfe29e6a731495ea531b45eddac2ed5028b81dfc0e27c59da5bda26b25c54eb77da1ba8988d8d6ef6fb2aa0860709902285ea20bfda147524ffb934177562da8dbb788294ddbf141b598415f042a1e54c570afb470a12f006d1de26fdd83dba457406a2f00cc867427207035119db0de16cffe426ed0179b23ea2ecd2b8a587ed9f0c2d23c67a5aa4d07bfc7ba52743439ba89b7bb4cfe02e2ee6a930301d3aa6d989b839c2ae2e6d0b2507ed4f42afffdad701c350aa2ee51d07b9f77d8d5390f3b3316223b462b8f734eaec5287fd07a0b96bdeea1a90580149346c229364ee843de29a55b09a93be8c439545bb6f24c4a4e0edbc9351a4265844cd2f1b3fa5fbc49a324b9143496f417afc08f1814f652513643922b48bb97b5ef1dbac2f8c63abedffc5c98ecfdb4ed5b0ba27c92a466e9b1fe8c612cdcbccb6e0ec6e4c1ebb43050422a461044999b5f724db8453aec459d52e63015056acc260cca7c7913834446cea13b0978f47fb98e6bfa88e07fa1cc12db96c06990b3831e1fd5ae1a562c9cb2e0b5fadbb20a762a0cafa546d01428e85c43b75262d02089669e6f5f950c128d6cf92eac7b5f8a41d169c4cfcf96b75d19abd1af2e733c16a6f78820d6b96739eadaeda5170ee4ef2c8e5799d3b0fbec18b6501350e2a63970489538614d10a963db09dc051a186c72183769be0192fc752c423467c8c8ab4cf6f04c4b9b69396e046da05aa186eed9a150d599df31946e204a8d32abbd9cdac8bf6a3093a1698aac1464989b8d7e4c5634bbb20739c8df66b1b8e8da3469973c8974b261ad90a72a41cd3540854e596df774b70a97435bfcd3b99409d87eb8f4688fa6ed419e830b8bc25d51f7cbc78d825bcec34e22dcfa6d22bb33f99e043dadbe89b598b8b16cda7ae9896054e5e7d8ce93498eb610a6aeba18819e5940e875e726664ef4a4b262eb34c2a25a02cc5b2f44acc174a061a9700eecf558fa626d79d13d689263a5bcd0358c46d00c855b28c37dcb4747649df6a6915bdcc817d516b098203e45baf7803d0b2c28be76517a187238bdb07fe8d946b7a1badc05b4dbb6900ecbf389addc2301bc2fe0725181b3d0aa92b1bad7bd600417923b5f0d1a5d455dbb131dffe52a414856027861295318b62edfb79b6a1146340c98ac8f33711ce0b5034fb6f4a944516b3103c215c757f46f9314cf4e663a9b9589a09dc27cd33c396c75de1e5b3451a864ea6d60e8cbca7acb4e7b01eb67127ea2565b412fa24e190f635d39a8fac7e1360f81a0517c25295c57e1e71701a39eeae98ef7c553454ed254b02fe61fdea4a8ac9099419329789d86b8e845545e03d2bb03492c4c5f1474ba45a441a39bea2a43d079985dce085d71f1a281d8a8d3311ae110a850ff41753c6e3b0ef7037bfa33d23dbb10b99a2b05c3b002dc8e00675b8b4a328d58e41aa0157c6a1154e6d1ffdddbd9568676dc8567d19137a3f6173fe20938cf373f9d6e9f3733ae8da158cfb57a991d6ad6aa16266fde593f97d62a6b43616b4f61ad850ed9e55c137430dc9b67a1292554328582a4695cfac6f2a29b261cd580417696b04027ed7042a2058d0b02d0b1c36889bf07c95d8f98790edf5997abf77f254c0906c1a483fbde4ef4b82248f60f7fe57e7c4bddd63b63b30c54875d20b3106c0f11bbd2bd9dd37c76eda54345b36c0bcda72ea81e6838cb314f1aa8eee355c4645023a0b4993e34de7b1589a79d2c155024154d463214b87749cec66e96b62c6b13c2774cd9e1b87948e2d9417e7f65ec7f0ab7a65428a9da5cf89c70b4b220cfe8698b5d16329f09182bd602501cfb162064097d5323086e7cf7c7b9e8e02dde85bf3c0f3e271b4dbf3c4938ea5bb8dd8951f05eeaf785628f1f310118390b29101a77022e307ef2d731edecdacf97e701c39185c7c20a17fa6eed1544bcb1c12cdbab3c7625304dffa25bcffde08810a6e5faacab19e92560dbf62d1d9642ef5b8cd79d74d5535881a3587a72aa91d35f805c08ea78d89dedf087a6990a1482f05051c1a4da648acdb5fac2da0916ce675cb34eb135fa23eb71f01271a0db82ea59a30795176102b438e86076f52128c65d534f55ed9764dc350d49d9dc1e1fea4abdcb6988c122d236b10ed597e2db1effba9db6f41f9cb693f15788a467cc2021031b570426f3e2c67f858a33f502d6e7d7ba1d91d57dc26cd98930ed870527bef4bf4d6b09e44610842c1511b64d772ad9bed3395bf10855446937a97479332420c6cda59cd4cd9c83531203cc5dd4e9bfe356359bdc837e34be80a58b1adad3c90ae843ea287a9e648e27f269de5bb9adfa0dcaa7d1dcf712eb0cdf97d385130484a1b15e583c7433f1892c230a6f9d13ad05384622ed1a013b578a193b7ade2a96899ad1ce6ea5e2648b8fd068395a42ac7f8d199a6ba96a9384543331680b8814d1c69dfb192d09423cda628f1711d6ba11b6d6d9274d581ddb4ae951ba9be082d73f0fce87d37d6017448bea78bf8991a4b6d2a0a756045f89f85acacb8fba1941e7414813c72f8de961994cbf5fff15d690f2c960a99409bae6a2fc1662618fe887028920ce749342888c283613e042b886e324327d851058ce53cc8dfc43937b3207fb52d3e2484729084ced0169acee7beeea100ac9b9a6cd604df8c5497ad28fd3970439e69c53e34a16fe3fb4fa893c4acabbf4797b1c0abec08e8a1f0531a9783b3b3ae9211ff4f7ac1276d26bae44636498d824303a8d8d9dabb78fbb12e35d20d83b68e630644fd4453dc78fb7df6bbe8f4bd0aa42ea8cf19289d4d9515300c6ee43b6fe349d9f8e8c1928417aa9dbc2f908f696ad45591f988680c2481115aa2886299efd1288785135365909f9a68edf9c766da97c2bf4b1055cfe020348300b832c442257ba383fab81ffef7d1dcb5d60f1a44d38303884b7379afd78b79bb179abcf357e366f108ea3e4a051d0295eb277790b8474b70205a9df17a5a5822ec49f08b251bbb97de3ea3f50640b1289490401d39577c7d09cd31e251beceb2ff936c790620bcd32cdd5b3edf21c27477587525c46475e83a6e6135f539255d119cc0e0c1cf5090d09daff9b383cfa039f881722c7b0ef0fa76d62ce135a5125d86a6c8b833aef6abb6d9444a4a144a20e162d7e25cb10cd28cb99ccf8fb1e0596d33524b0aff30ed543ff44e378ab41b66790a14648fc8bad98e82d08ea1b72eca2c78f77240c1401c263003bdff9a7eadae1242b54fc9881d6b56c063b1c6808f552564a59823f00d67eccb44b303ec48d2c1c84e1656cd860202794c1041e65d9cc9fc527b8a2decb21f04a755bba549bd64abd7dbcd220daf6ee722453e2607ea98bbabbfc3708145efc05b91efa32608b43c4f412f0f7f1acc1afe9d8aa880680009c2625db20e5a30d9deb33487b9b9e65760d1dac7db5446ec9efdd2ff3de167f7047f66791a26af982ea330bf186880180f5a758244ba2d6bc5762a95df8259cf8e4f3abc72ee9452ed155343c4810472dbdb925bb4f6f5dcae9cf2f19f743b647a6167d353e889ef7da1a6ed94b33dbe417a051aa652e8e40116c25ad85a3472a469c6c6e49e43e3e357a0e6a98a0368dfb6cc89ed96b616d7276092312b6a26d78380630c0277da985a38615958663e5c6aa36ff64b6b4dbcae50f5ac415ae4a76cd408464975239d677c539818ad11470951d3773a3c212f940d363331110f5fd592181ef22d0ca806bcf5fd453e6f7ade7a4e1a43792096a6287e694e29b4b7e3eb0a04836ae108c69d9115fc580d2f24d28ba1eca155b7361ac3482318edd23f85a549b1fa19651c0f5b5007e24a55d40159d75983e3c053ddd0ba32a1bc5ee302d23ff5df226e9237a9dacaf162ac9d2c7669a03037891876443dbe781f494f5ca5501d2dd475aa3983898443806a3d00605525da40a390977ba68faad2fe94d78157c393eef49a6ca167663038782d1dad43246a445586","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
