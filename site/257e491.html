<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47650136005c0431f299bee15b707e8b4c9ba5d605479fe2bddbc7970f8af61441c0916d658e1c5e80e6ffe6a3f83c5d9b8037a6ac873ac970135315659a0fdcb3f06403a1e309754651bf175b823083730c474c2e3a3d50f4675f60d898484ad45b6bd368f3127288cc1964125c5755a840251d58eca72fa608e9d9edb79068764b568fc8b691ecaa541448702d1cb3b280ac2a784a23b44d3502fdbf25e0b835bb78094601237ac219d4842b831d15404b88369579458f2e874987043baf1a84a394ce4245479267a1a697a3dad13d0c293d10ae8ddf79f0974d9e8f79e7dfb72990469565278043949a9d1629f5ac0fc452d6b991051e11ad898819f6474722e586abba6e0e7237c54166befce5112967105de0de92dd447e022e89ad7784c859d65b589244e34e4a76fc672c6fb2634b4621cf9fcc01fa820002edecb4ceba67dd772bb3fb6ea95890bb69c25df6f689a1cb6f0a4622195048651861a34fd7ef09393b4470e0e454e3f9a1982cf177d5c59396ba790ff78476fb97e98e99f9a8200c916e70dd1e3beb2d5e087abd1e0817e5f0a25818f10cfac86663785e718d199b449ca4fa7a8099f122aa37e6f07fe946485efa5060814c4fd9b313682dc7473d2fe208ac5c5f4721bf69da677641861b075c9fd39c909db253872d3516759633c49c510b7a2e07248d9bb91d07fe733266dafed176af9d748657294edddb0196b1f208d2dfb7cf9468a9f20fb807182036c6be6b764808992e1fa3316709ae8048215a2c4726c0f430ec5386766dbe9d3ff58864a39062753c9ff18aa1daf74297ae95b76f7a6380551bfc56ae359419da720db8e3394782ad1e518d91cb6410651e1a7d24efb3b4e41bfe7a11e68cf9a3aba45e90f6f6564cf29437fa13781d129ec4bb87abe361ca22e760825192503e279b1dcbf6af7ef5fad97fb8668f85be6fbaa627424dcf5a07d8285b0ad98859c51d2a7ed4488ca7bbb312a773106dfb2ef1cd48fb23c87f3db00549a7be29a54069032747f2489299b295c704bcef4c7b224c6c120d85a14798f3fa390979c53eb8265c86f90b7ab37235e3ab6c216a4ff3a6a8b520251bbbee8603469b2f339f0b76b868d26ae74a65e6f9f2f91086e45a5cc3c4caf00ccbc3e6efa4f3d2589cb86c35d3a543e1d7b7058492f6f6ef1c1fabc337a4a77700d80dd0e3c2aba19cf786671ccff81ec89b336c3f8e6858ef561d4a6b04e5c40b25b95448f775ce8ec1082ffd9604a2ea43889f5dbc73e9d6c90327f22137a3dbbe00ca8712cebe23534cc93fa49963d77df8c9f8d07f865d68de25c406a6c7d277c4d1fcd791c0d46678509871ae8ce4d7f6b1bc4c4bca81c55a8c89364a598649f4bc04f811f4e4eead553553e2b0965fc3b5072f708254a249c68c38382af6254a5f51c0944d675881dfa72e7879856ab204e521483eb2237649b13b4d199f54244ecb82287e3c8f8ba5a91dc6b1fc6d33b90baab77b71a2c921ab95ff6764ba3df2c8fece6a388d902c50720bb2affb7f57076a9b60461f926fe7a0cc162fc05e5794741d19cf5c159e8cfae94d9d31063581f79694fab250582c7a80e23ebf3f47387f7e750d1d18611a16440396e4a8c8d190833e7167a53236cabf0a2c665df0bfe10f1dce9d60a6560a70c97cb09ab1a82b3d06f7426caa1b29ab232ee2eab2530138aaa79c4af018e29121b3c2ba8a85b82e66cf14314348044d13b05eb4376885fc40cad8a43607cf0d4e225fea6aaa17beb2eca06818b87afc59770d7ffe886011ed98b481f3d9a0867e037e20bb5e204746e4329793772db39cdc576e3b3825de616c04913958c039efa6dc585c3e83737fdde5a48eab6dcb4b0b95047eb9dc364f1918e0aa35b3b6053e032eefc9bc0ff7d048a10e0c71fe2ab32dafc99979f27018c131df62075a1ac0359b078b4fea2d6a4f28e25138f83b267335bcdcc5a7ae13019ba5604f6add3a7093f1044cf49887eecbe86c6e6e6a21bafe9e94c7283fd2765e00a10396664337bed82b414df945729c9bd3fae69010982915721f5dd5c6c62a23b7c66b00204e4fa526125922dfb075a57376b4e7c63727060598334e93ebb9d4f9d4c5577d00e4ea89c459136b6e7c4b8b020dad11ef14cb94b559fb93cebbeb3a5f486d303b40c33b3685e3d2312644151d3d73de04946317c468f2cfa916334b9ed9d0de05f66876ef69e37dbd19dd1fea6b1c4e8bdcb416399a1441818fab9c86bb6476d1a3c04a7fe1278d0cf31a0c5373140f736f41a38698b759aa8890d7b8da8029c4d37d3f9d40e056190e85fe1ff50cd2b5a31933ad00fa760c3a1ab2a3f1561900b2ef1a1e9d3f9ebffd09bf5e94644c4280dcfb0b9a89fa82d61fed40dbb803f1828512cab61dc79175e41cd4c451fce37809e6ed55a806fae80b3e99b39646785f0d35566094d21dbb35871461e6e8aa7069f9b851ed7ad2d8d844f50f9a3b3169c07ce3b424948961b68f567f8eba02a76a263e5737b397533aa55a012a9f9fbdd5cb8162f63aa401ba461c90a4e4f6a4cba5ccf5ff63862deb8339ba88dac9574fc70c78f5d5ea2b9acdc434da5ea607ffc166b064eaaa38f5a51fb833031ff950c9fadd25b5199f06d66ad18f5f79aea6e1aa315df97580f41990165ee8a569695a3fe7716fdb310c348824564fae927be7d0b1eac98d1938fd989998a676a278bb0607580fd2488ac6a6d749b3aad3a0725d79f28428f555a6a5bc9a70492e77906ec166d79b6a866ea6fa92ba004ee62b7bf451411ac09f1753bfff0675969d750c426606919045d446a3785416c0af93aa002481b18fcdb40cd573cb629e5ca560d6c5f91848815bef04efb119b5696445b6c8556ab8f638afee1cb1acae105cf7887b01f2d4083a4492d1a2c4507890433d87cda179b199d8e680bb57afef750cdffff349e895cd2200768b4fd7cc37975a437f764c08e1806ac73a312f1f834b234e725738675ec7de7f71eaa3ba995858da44419a78dbf581590a1ef5444f0cf21c383263493d13139268eb5f0b26ada9983c12678d38f4cb8dcea094675f55dd60c26b717693af8253157c232331651dbfc7460496abbaa3c0b99b7c52bd1395bfd53dbe61bddc55c718c5987c3a19fcbf6831ae7413ed5ddf096072bafe8f087df1132800cbb1f2efbd34ad5299a3f5345ca1a9c8ac7052dda4b2b4d97ba034d65bfa2f1f3d86b5832ba2b54a197512e9403ca946ee4e6410064e43c8e562b41f191f5ab974e00b46c6eff413e53e6f9c85114681fce7a7198aa76c85e28e1fc78570e1ce395b32334c9a6e4b4dcf9027092ee954b2257ddafed90ffd7d5cdbf19992ddbcd0fcfdd13fda9b91c874bf5ae496b9b066d20b79c1f9edbdfc69c69da50fd75403ae33326ad01c6ebd436f5c3eaa8d72cf1d00e4c9bdb06c9b4df939034cf26c36395d996ed48a0f568434a03267f2b21d57cef9a580deea149c078bbe4f38fada43a2af2f4f7ca761cd4e7ef97cfdac8f044ada6f4e2b3486dc0e7f810914b1f112580ecb9cf19f243b80ec7d263c16a50931aad33cf59f6fd20890798ea76135997eba7950f9ca73bd415d55f7a226a2bf67b1a5c844793972174f76f02e43b5dabaa4ac24d1df503cd7a073030fed5a87b505c0bab5d8aca98f83802a6420a433db49eeeacbe006ae55ae8188663930131a7398dae67847c8b5f9ad4c87c1d06cc7165b9402cea444d7bbdf9fc58000929b67c78beb659299d17748a1c8e6ecce8c2bc8f29b28d870ebee2c94a8d84f799f263f839bf411386b2253ec15e30b4bd7a6910f1c4800a9f0324b8382e4b7af031d86028e61a4f3424c05cc3e42dc180ccb1055692a2457ce6bbcbdf3091a9a190141ecbc49e227cfa7fd1f702c3cc5f36826c6b88a14b189cb7a2a4c7f5385794c81328abe44144bfa53f3e1d003bbbae20dac0d4c14133dc1d3d2dd78b2b974d40fe8bcb8c2f2c306e0013e37c70fcc527241cc1cee1272a2cd40679fbd47594885fcc513adb7ab1f4116d8415f0111f1e3f53cb9c2dd6a743b737ed99418272544cf071aadd5c8fa41537f669c624ed76da088c1d8e040e32ec4d2a949f51d2538f8ffad21d943596c435ec0ebea2b5b815d9b90e725d6fb4ac50dbc74a6507c457166197e1b704f60d39b45d1205fe00df35ea286379284d7281b3ba94858c30b2037370cf7a3d620cbc938aa7ea250e4c1894e71f877d180465d39c070f8d2685921ccd02b5fa23290a4037250a51c94ba6c49e41f1362a05b2744a46a1ffa7e37989230b0f90aa82bd71ff45262b030ece06a2238ea44e52dbade91772e7790cd75abdb429509667a1b209f64623ebff332a00a908aecef463d67d2bc0ce575f7a5e7a0e86e305c151918dd2cce148a31f9a6b48543d8b791341a346e7bcdc58c698f1acc1854f5ee331d4d17656b7bc7be5989e3cb251d8fdfa2b3fdef8a83679479adbf7c425a0a8dbd1dbff9f168cb42c971083aef3cbbbe0a99e066528eb24bc68e27465c825d141b497b22664f5c9aea7a4f485c3b7a58840812da4e4e1856461a15b407a41a8b61e97a77d1240e0ddddf5b168277dc988354f0b5e49cb3746237d2d128e24a2ccc78138973d628b7e2e8aabbb99445fcffa0f5980cf954239cd7109d850d1111d056283ccf878328a19dc02b9d33fe9a8dd3998482fdb42af41175f5da82c90cba88fb5e3511b120273d776258218c1d5682d261edc9e2bfbe1a5a32aa96dad55442b5743b8c91ba30e375b08169540399e1c9dd6fc714fbdf05ef1f8041f466890838719e5e64ae17d00b305faa91f1989893732a123293126c7a758153dd07c0b82af5b0709a150e0934b737a106520051556706fbb296787af84eba79844c2250f7a43768b3a188f8329c449ba0f7b0b2cbfa05d0445554546a48663e1984082e4c7f68d3dbe021b3c49eaaa30560c4129343fc4ffd729841b5891a04393946fefc4371d85a89cb97b07e7c48e1cc1efca4d81a43210d3c4f67bcd51d83e24ab07c51dfe288298297e1c3402e9912f111b4a1c6f069b749f731a6f19cc925b052999e33c4318d49cb3710691a08d6ea212c9b5dc031b796497f6a572540cca4cc628945febacb6a727615e7e9b3dbfa2c26ebb1fcdc3e004518f89dc1f2a536acb5d495650dc7c46066786bf7067af2065ecddae3b92b3acb698655ae29487ff026d409957ac9415207a246f3b9d049acc69fe9134d4d90be4fd9951d3b65e78a017995f755385560d83f5fe18e65b5fab45ec2bf2474f75ec26cd136f7c22a4b523b0e649716a95df783d8843a4e0441d41943f054c1332e3706d780451df11f00a3b7feffb636e4907a443d375d60123f726c3c417ceb01117c4f45c1a4581a144ec51dc3e11a3d6bf6d245e4d5a9bb74b1b7292a224fbcb5ccf9d93902babe7b7a707fb6047e61a89e7c819e249b545125f472815d01f0d8d0750430cf7c997a12dd834c25d9e0be7ce8509c7807161c95acd3e8f9b57fedf4a140212b891b4396fd6b2507753b9f32d784f2fb7ea14b15e69d8141c85b5e884a36fe5077567f7a733dac2220fba019ff66b2527b64885a541362d40211f01b682445b45f8cef2244953b5c37ac51e9e50696cc14fe1af8366753b47b4de01e92127b1aa906933c4aec882c82a4df061cda3cf043f6f14b09d49c572e80cf0bac4760e891bd2156bf6a63ed28b47a54f68ff5b1ae131ad99ab0fdb8eb9147321e478adbcbda0cf53f350d74b76025ccc13d026cfef530f7f8389d27b4c0ff99c1e8458cb028e2650ca437136369bf5d996f55202c10c58b122c2a129f189b458c610c57051da3060f47a227c99e4589b4324b54f49b844ad8b732f4d3acbf1682a060eed2e97b76c03bdcc720b6a7a3364f36755e214fe2b73d389d1515b82f745c630f461538ca9810ff03eb1b21ca08d6771a255cdf696eb1d1af17380ea617297bfe728e92430c5e9931d6bb2370cac462c6e3620554e7de470f7138079b887bdcfba68c9760c4caa844a1667c5219672d0cc51f10410da92bd6106e3cab60866d18daee4b6cc5353ed77f3142c4999ea807d8a8c71f830b46d4a553c4dabfe6cc25a8db16aa04979f635ee2b6436d01dc46575ed4371f43c8bf016150b34e00f9291b727f1e02ef5ecb8a6f77503f5d0728f0686a6a88ec50d4d5532c79e08542216e298804f391a095891521f574b5c4444765b07151e42ab723460ea7f2728e843d99533894d8ca2f7746b20a4abcd619a425df4bfbc23aaa672841c626e68984c3215519eb786c8fddaf2c729b4bfc94fd244e968b0a10db15b23b48c604b9d252fabaafbe355210de98c67af7d9da3aa7790efe77b227ac5d20c365a8151119411c01acbd4b7386a7eef955c79afed037e4eca5150f98986d3535e0034bfd0f4e92dcd91243041008127debcf251b9088ff8617a514de5ffd10453a99e5a30f6bc5d05f55ff6a02ea10d5133474aeb346df0392608983aadd8838975382229974290b04bfcd4242e4a4e3c8156fb9d49bb4715164486aaaa10f0b8f06f48f158b53689d78b0e952e94286e32137c4edf2529c849b2f0fe28846b28a36c960850092f6831a10bd317c25ef9595ff7dbd9ed34135bcb94574d32a7824d4b3b8249f5d9fdd5a5db705153f013b3ff384139cd1e643906f8e63fbce4ba721c272dd781c02e27c11df6d9b19b026bb2e12a0dba3c483446af4f74da9e95c6c36ac4ca89856619adae28d22176d4810cd4475560fc3b0807377a03cb0b8b85a1944449f81f3974da52d5ab82b6e334da4ee9711e8cd6d58b137f30b9c38ae296317b4a136aafd9de2755c55d04e67e27cf6377750a2f7da74edac2f32f1419742a0d79330962d6144bd30511dce858aec51396a60953a259876040bc86ecbe828214280d71362c8a4eedd8d6dceb4be8cd670ac501e7fa465c3ce91ace6a803166b7835cac10cb47e8456e157b2faa009314f0a8042c50cdfe657e7e8063366a149d140b61034d50141b31064b82eeda6aa328445f60e63c84871c40145aba2ce12176f1408ab261b7d549872abfebd5aca099820b1a2f489e8bf26738d832597529caf3d9b7518fc1a6306ae8f5d070799988ed386eca7dbb088174951a1fc01cfbcc3fd06c7598f9761d1c11ad02c30a4962bd2104c686acd7ef81b868c09852a92f60ae18706346bf8793aeb7725999dabc63135b4d10e4c6ba292269eed35e519645fec87d7acd030dbacde4f0bc25fe57a4a69d0a67f9c2ee7e934c9ee1e02956ed864ce7a173ab8e68574b6f1b391baaa4beda966b54e640e3d9539423859f38950dc4a09906e3635e3774a3948edb61e0c9f01795259566401e548128680ae625491ffa5e68aeeed162c81a490476c5c61937e3b5bee5f2af7b58c5c1da1fb356291a360cc048bb3eff7cec7adbf4ce92bdbb3ec0b6c6051022f1d90aa16a8b650eedf35f74c53a70e33e9b104764c43e56aec74eb9036ad059b2e30113f160adab5e4524c0edd0ce2eba47ee5430efffc81f8ec9ce035d21ab7cdc2d0375636452b06518b1d0bef399547e622678124c0518334323a12a75071966861283950a3e320d80ed98c63d951745aa62b3d91e433571892374db6488a590c2ca7a3c1fdc255c675fe7b064ce73f1669cdb8d5f80321914d2a60058a97593a1a539112a872872730787739dba6dce6dd9254217abd2afda838f0cdfa5dc762e91804392c5036ce6453df311a8ddb94d7e989447a6479fc9a30e36bbaa982277b3209d31e47a12e3bb40b216095ecc6b6a482e666e6fce12e9eaf04d9f0504543512c179730089e2e4fffebb245d8166b1d0e9eba1d52680ca9abdb1b1e4d77a07d43bb9ad41dfbc4543cd9d2d18e95d0cb55060e294a89df035a254f14b68817b630210ad31a35bd38315b68caf627f5624af9dccfd294716f34a650a17019018461dbcd633904b560f579a1a84e5b8fbb6ed1d85e114848ed15d7f5286d1d76e64941338d34c9bff94cea3df420c43efd3f82ee88e2382bc8f5bde74add79450977986a67d2c1ebd83754541a2065bb45d5775b786fe32f4a5d1e8572334d277f5685d0484390afb552f17ce921fd490a14cbc7a186c921318c05ae0d32d76b277f5303e015769fdda58fbb45ac1aac9092c9dd70cc6111e02a9802c41d04126e8ae42851fdafeba75a5ac8956b71560fb62a964b12231d570effae3749027c7076c6e80e30fda63b2dc4c09b0548482b0b1c503ff59c73f0f22223849a6a9f1284aefd89e2b084974de6033294208d72e58a2fb3601fabaf0ae6ff545120cb82ac05015a28d7c48321c694d350e7a5c52f9c1515de51e576eee8cf715e1ad24d75b4def605b1920be0efa15989599f8676fb3c75a6677d2d760098092befa4717aec8aa363725e997205a30a2605ceeff71ac1de7a083409641e49ca834c5bb96d23fa7c87a611b654b8af1f8bd995d0b397cecb8b104b7e0578385fe61e87edd070a004f94bf3c61061cbdaef1ee748bb7c210f3c44353d99c37925eff2d918447ab4c37cd35a6c77ca2f324ef6368082c1e4a807ae436ec45db449c12b28228b6d2b88e9bc2b15974450e4efb28de9ed0b5370d046f48b1295e2f632e1c05850f0d472e1f01a5524d7c304d761775a287353fe4a9644cf2804ebe1dae5ecf43f867944ec5ae97023ae3d48aaa03e161e949d44cd2849e55dbd57dfe9ab47f57d94439aadf96ec294b7f80fbc4cb09563aa0cb8c9c2759e15a6f600f1ad46075a29f53854d41d2c53e6bcd6ffbd43b84d0e3c4fe497fd3c55d6f75be0ffadcd86b4f44d00d5ecdb5757b23968443c43c98f760ebc1ea30dd565fac240570a243a430193f5296e321a069f0abc6b4a6c29234ecfac7a5bde91b653071fe858c0e16a19b616b34398a4d6ab29eeb230589b16464bdd6fc80088220465640728af5c76be32d2555c181da024611f3eb10b7e5c77c9603119ed4c584a0c8e0a9adb48c724d0d8988bf84ad7f67cf811374b961128651933aa25f9a6da95b582ac0759a2d65a6906beeea01c380c0d98a2386d4453436b8f4a247f4b6e93b95243f42fe1be2152128766a88ff8f34d01036566b9b8b274c4135a225bdaa994a3582a051b122409656a03ba4fb6dd846b0268528e1d9861aaabecf280c7490f47e7950de29a49949e66b4500ba1b47117cc0e1a5cfdc0e5a65696b1361279086dbeed1cb9bc6877bcebb55c8ee4b2555e92c9b4cdb2b3f8ac4714515e6a5ce4269b421e5d57dd926af1d86ddbf3ed86a99d4554c16fcd965a350f6bf47c93a46830208fe4e1312e8e5cf98b75cdf32d617f2e4383804b13babae6af2e007dc17c25502ffbde399975422f39d084a31f4f376a55cee91b7b9007d4cfb1faca5e529c02044c440aa76fd8d7400016dca20e549fbfd6cbd5959889ae02b5190b26c47dccde0ca76092ead628dd767110af3f19d9cffd7f662573bde329331a8f31b213ff035334733e8a67c25a37a8df584879f8f23985c198919cec159345a2af923d13b945ba1ecba4f779bb4f1d2431af671df1f78e7492047c281007ab7e16769a7d9de51ee0676ec03a5767334d21adf087de1d8eeb236dd1e9512b82c3a9003c9d237f5738971620549aaf34dcc342798bc8cd823d2422684589f68903d6c3b4058f62c34c644c204a7148150b7d26a7cd2e515873650b5d9127204433e060c8670709bdea49825a1bb4b2b464bec9f3fe68e49a38aefdb0f2648833b1a4bc0b9c0a424a602387441ed07c51e95908d34edca1e8973aa8d3f1ac3e04e7a08627e81e083672ed0b8a0ff67ecd72a20768aa9a3ec55505b3127dc3ebe0b58610ead143d411e39239bef8052fde074d60aef3dc7cb159a4cf3770bc4196c51f50c7d4dac74023b99c9f55cb12e3b6b56610547bfddf07448d88614f2c90b2c83a370fc980ad4426515ba2a789d3ffdc90ae266470d41b289a6d46b75579898ad40319e7f2105aec5aeba211215630d82f0a46d6a4ca96260113fcefc81fc8fa067e677b2f1e0b790bbb74c3d32111885b1e9dedfd55719469fe7a488e3a368cbb8f11f47fa64c0ffe274d97836f5da051d1a6b12f420ba9f7e8b7831f2b5bea33621709027f62152b86211adfeded4c9ef726589150644ad27220fa715587139539822cf4ecf5d437039d2aeb935046358bb21fd3aee5ede3e8183605f59df1a93a77cddfd482c1da0b82769a1f7409ae31b636185c43551f1250c2bf1e2580bce16fabdb82384ec4aef65c4cd8aaaca80aaf97dd6efbe3f1c047ec10f816ce742012e16d18d8718409378de32eb6b537d881434961f2332ce5a8e08ec43c39e9f91ddb5fb33f37cb07cffa9acdffa24795fbdf1a72693cd8fb860db35e10bfe68164d4a6af32576ad07f857f4202353ae39ec13e4991be269bae73e86fb1ac2d07557314782684b3bccbe3304829b530c4d330e0192afa54578600f7c054e797523d320a8ed0a9a3401a16aeeb83caeb2858db20e0b5c9406938e2927f0241bf66a2afd185767ac76089729661376031d492a634c5a6d55bae70f5e8ddbc4231fb766ca47e33bd5e21d9c67f1675f8825e51416c6ae164a03119bb4e1f68f6117662937dd01e8e068a07f51bfe0b8819318be8f8f21cf3d933b0b6ee3605d710d89ac67ecad0213cdf952d73a95b369b045ffb0e6dc4c1a1517dafd79e7db560c4f2fbd346b9c5b61cf3a6da6d8c6b3d7b729bb16ad07fb48ab8ead9c4e65b50306d5af7403b3ed320e3cea66c54e456d16b17536ba3d5bc9a764297d54ab91dcb132bf9e4f063df40e2917b46b9f0ef7bc437b883a778a5bc5a36ad8a53d9406a84c17d4409419962f9120a38d8a8f9abd893ac6772658bc98b3281ac4dce374ccaf835ae1d44e5d4799e75a267904cd3eef14dc04745b4a473902736ccee62771c9d5302ee5b0f9ae7408b72474ad15f9eed11658b215f8d12e75b8e1c8479d7907ee82d0ff6d758682c6688e6ce0a508e3e237f6a03958144b8bf3c826241a351c515712c1ac21254cc498524024312bd73e336a9134afc22627f4fb067f2292febb4db5356bd456772922099c548dedd419f94a7413ce4d338574db47e472d319d8b7b7b29e9c9cb106caec7744ff498f9c8fa2a56829b5ecd547971299a3ae872dd95b9fc87fd53d0a5d8313d1d216a6e496b7fcc73ad3c322a1edc4ff986018ad6f54b6d5f80ab01911d282a217d0829f83a561d741a905e7f1d1c432e09739633fd6d932cf3d8383325448d80be23f16a1390d7d263d7f154ccfdc223697ef2010484c53a09582f056dc083373a9b40fdf1788cbe92be698ba5fd74a8cfcf36540efa6cebc8416a9fb0938560ec0a3ad7af138a57d38803eb33dfed6a3c17a04debdf17c2de6b8205dbc46333da9cd19c9901fd528a4c44c561f41cdf5def4469694aaf7973dbfc","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
