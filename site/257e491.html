<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"954bcfe5bf61318137d6a5bdbec4b9a68e428b458420cb1fc3e3db3430a5d26e9139b67a5b9a5815e5dbc2b13d0d0bed2e34cbf58e06cf51445a478b574491ad3e43a6346ed5a1231c789da9d089032ca1b0990775547ecd7b40beb1a549baed1fb371d0b13cb535b3df2354ad4b14210e95fa792c16d41ef92ce9ead6d303822fef537a37be4ecb65513252de6b45b0159f5dcd83d9fc9d0cf3986b561115d874550bcc1f384bda4a49b843de85777d0933f9c5cc5eead6091275cf339548943771d34db9ecd92aac441ecc898345d448a7fc2739fdb9b8664f82c794339c1c5de3b2cbfcd3de5f85bcd598c2efd0e633445c5ff8f7c416116c55733f52cdd21d54af3f34dd5d4a54d9bd0b24a33100ef47eea1ed10a11f90e032fb61227ed47cdada47630a2625afe1e31de7cf53499fb4f9a763370c95e0e634fc3eead613ce3c15c393209cfacdd8b6e80fdf07820eff798f9c61b0514caff50f8e1dec82aa08b2b27c2b6deb3b4242e85e4434aba11fdbfd9108bf95c8067315ceacea16b5da3f572424565c9508f30adce531c5294f367052afb0f55b4fafcec377f2602a638452bb36921ed4c58d7fc01e6baaf96169bcdfe621c2b08565ed5235edcd54199b5f271cb495426bf822bf7736bb344743ed08d3d735155971996af1812e39be429c8394c4490bf7f7e2d632bc57925e502170b3a66780ccbe0fb8ee318d9c72c671ffc2c3657c0d0345b7cce79e20414eb2d4ae881910698ff5cc651bab4c90440ef456741a99a131a714aad579a720ef7a55d6bc2255ea8211a591648ffba8e59bb6a57178923f830b869f7b5c62872bd00a54c8f96a000945c1b1f457991fbee9d1c372e65ffd76578546fab4a7fa26173274feca3b7f1e6e49ece0e13c9bba76806780b9c5bb9787ced505c44c012f2eaed83f0731a0445eac399540a4b4346793ea9228ed4dd659e927fda25d5abc6c5c0e890c7a21cb6e4e3937770a994fb1a3e80310aaa655995a0b573546f4b51665f5799bc1fc21eed1a9658432f830f9eff3289163af87c814e88c27e4e03b041fc0b850da7645558fa84a4dc3032e85983ee83c4b73284f023da7b24ae9197c5ec8f4bd4af5feba4fa58f55ae7c5f82fb99ab22f45e152010c6facac95ef988af6ff6b1151ca1cd37b94fe10d6221f01b5682ce607f1f5a97c956024334579544bc694c65839da065f39bfb322a099015f47622a9e4da720b1bdec0ed9ff39b18c76c850306687282d851eceb5028e69cbf6079748ea4c0090f4e238d4d6a5d14dccbc9ce1b89e9f437856659b06076a8a3251a5b152c66034db79ecdab01baad949fd1889fcb5683a4aaee9823ccd600f363a481d8f703ec7bace55c7d2e9a5f284bb1a3a49d2556b5e3a2d14ea425f486c9ab3782db3bcfc5b2b2a1495dd20a480d305807fd78d49222e09bb15e1798e08d431a62f16a6c2e41259b5cc22d87bd174112502c18964ed3e1ea703ce65532ad80367963a02583805ea80a4c7d0ac9b5e0d0d41a07a081b1865bd511f05147998b3c59d15643b4ff7c0cff45243e52047cd2621d3797d44486968a82d50b062510b60649b2c9f37b5f21d6ec0382da42ffad70209ba4a02cf7bc1646556ede621fcc9be4146d19fb6ed4f2c2ca5f5b556937bc3bb229086d1b0b55837aa5a4848ba8a382ec56dcde809272da941af65c69590b35c92e31a0bebc784435b92e47aa0204ea123167c4e4df539dbd9e7b9120b7c880bdf30f1ffc349f3391dafa64c5fbe8ccccb38c7be94f6ce8389d10338b03fa3bcaa5961628bab2d89195f9f4fc75a2b392cd186e1e1d778de34703205fb1f3e6b9d61b473d9cedf2030a6e2b496c1343577712df4c8c00e95d84cc72cfab02a50a26583a30994437b1b9eaefb5673cf86531549c746d8a27e1d9298a328c5792cd1d75011801b69493ec5966f407d6295a68035b8d784c1ae05a6917eed986efb64db7cb3f4295cc16ac2c14d1f47e25003701e9bde266ba8ec225f64062c6956c1097842c477754d614f56731570e318d1932d0c6ebfe0f196a21dc42b22d74f504113df4082358408ae3282735d86a6ad65cf4131cd0c21b15693ee7d9272261305398c9cbf2588db5309de3a585fc19d9eb1c1b191d6725d0c102d0e15753526aead4770aef7779aa09375e053b60384d1cb4a704b3f55685b72af7060f3930d1bda288ad2583644ae05c31b3e5a3c2c6ac7f3bc739faef46b3320a279d42beacd1f5042f3b8ba95259ed26abbc797d713384ea006df15ab05b1dd0f49437ad234d7dfd250a061ce925a00e50f2dedccde952df2c9900b7bca8b394ad83b94db059533d29f4dd4d859a8b8504576fc49d24315d6944e9dae6c528dc3cb84eed7908e6c71073c7c23840ac373b9c7f7c170dd7518ca2ca6a109dac0e135def6fcbe4a6e44c1765507f1b247f6c0cedbb19d2af712adc6b2f43712e87a409031941da835775a0f4a3eaa91af2ca4d092763007c7f098ed15857d1c03f3a0f72371329d242ca7af0370f85169d1a50a7f2564373ca995dd1d0fa632ab0db94173e7aeb4173ab2eeb719cf221ee4b4d6245122f89c7477137f8148a48592ef6bab2356f8b43300dbae042dc56f6b22b1d629c0f918746121fa486c96af629ad0add68654203f17ad167313d8259e82f4f31c5cec94e9c1dfa3e149f169d65aabdfb12dfadbb696c027e2df5b432e6dec548f2e31b34c91b23313ad6b05112dab99a7b93707c8428910c26f2d83bf27d1f612a35d6c08b78669f31705b02d5a6202f1c67ddd01f220e57543349b9b816e271ae346aa2cb047d47bd64cb081ad47f6505ad9e53e4d36561dee645c61bc4011beceb53cd24ed27437d79846af8e3b38be51f4dd67c41f402d005e638869bacfd76e847b64e9c47c928fe2d7eb32a8a83df0cb249590b6ad0c230b04c3118b0d2ce7333cb966b2935de21bb6c5183558d7355b28989092d089a19746895de02c8f1b558fb14915a62c3d45b087476af20c25ae69df5693cc6bbc1d92e24af8ccde37dde66127ca0aafe9b6669a23dd96f2462a4437853c3f7120d766c9a3cfce7fbb1117fda726bc73cc569c91792dea9d0021249924f69afcd6767043252a4240ca5fc22611986320fc538258ae64b83496d82a823dc6710474379d71381018f96666f42ced027327471935a5ea46d0dd26a09aa7234a84ef76098a3fce82ed705a6a8690fab17076b58f8b7ed1a5b62e9c474ca4e06a706103337c7e35b251c9b2b436611e4a5f530e3b7c06c46e43041be48ddef37dc0ab77aba7e65d474c18bf352493173488ab7b2807c792511f244faa720c64c8c550132f752ee571d58cdc6605be025bf6b35ccf1e9528a07f6cc7cf732159046bc8a5bcb4af552ecc9fc907ca1b1bfe97a3a983cd7cf33b582f9289ff6c14b52374dee2181c66dcb73379104ef69e5270713c1461a759347992371ec979768ef01728649a4d4d00fd64e068b44b086d985b682ae9c88ea902f6fa361934e68b6f3bf5768d4f2ea0656529592cac41492267dba033df6e1191429ace05d7f1bd0fcc02193f61355e835b7681fe79ab8d47f25cd4aebca5053a6341e31e8328d759679d72fea6281bc2f0cf00e9f7816265d164499a821586ea2823dea52b9ba20e7dbe0eeaf61daeef5a737efbfd2fcb18313334d4f87c0ceb7e49d829e32d9b8d8e454c4c68504158ac4b71a953d161968ac500d06baf1114a85b5b5b51281e76a8f83c22fb099604054e614589b2c1bb845a4983d2d52adc5a4ba24d258b7626cd1fb35a0878689797b74245d87452ba9de98e7ecb4641cea3d40ca2bd0434a4ac2c92b51c5f7ca788e33fbfcc0269487f821fc30c39614d62779dab7c6d46df146511498f0d076baf66e9274caa730e4f6662f1719eb0e615f1277c9a68a10dd26a96d5e18fcfc2b4be20d536946a6100111056951894ca7f18501b2184b7e09b2bc54e0f4c605f4ea41e8a3fab783bcd527bae883cc808e8d1fca53096d8de371118b8d19efd6b0ead9cd5dae95639919069de7aa6842fce6649c151914d95529dbea5a2ea83818e6b1e5c50c806b2b50d41f3885ae6d20b109a7c1d72852e9827e5f4e8723dd4f5de44f10fc06d3a61ab6294c5127c93d3b85d43dc5ab446e64e72bad18a8237203d713c1bea66731f785e6b474a1bf73a74a892efa5251696a84db93ff870f14af1f4eef4902d7aacbad1cc0d22b26a0359f434342a55b1df436e116840e0be360610bbb673468000facf996513886a391b5f2f22337a75a9c29a899ce8bdc3ab4dc073027a80a40aa01e7bc4c5fbf537ee9566e84ebc40f89460d65e99f487d9a6807f356deca9acd4153724d9391319b7c9feeabbe9167f130dc90427ddbfd9a1f723442692ca2e0c3ff1878bf69db01363c60f0ea31fb8b5ea14caf10fa907fcf577316dec161c7cbb3d77fe90b0ac85511949d3ff65b607271759ea9f054a58a2c37320b52ea936ec557d587304d1b01c1a171b06763eea691222f2672eaa90ae88fbfac864f2c54e56adf4cbc4c7d357125d9c8f5acc385a71a1c8133990b3925701cebde1ca7cd3343eb6df868d4b43402605f63652031c46dde1d3ff0fa05519302b971caf3cdc3eec8f0f8879603c8cd3a109b6e0211fda7ccca5e0eaa315bf7f395994ada40c71015c37f9e4eb9ed98699caa4e25d6f29f983b2dd94904608e44ef2c97991d4e528b39527fad195b09364bc86fc62d5c22527e24100eced20c065eef3ff7f2a004bb2bf5dda396c48109c00de94618b79c05b9d7e218bb294ec452e613290a5056892c3110c135d681840ad80ccf78d67d324c10e977d9c5a02f3660300b652e0d4440183c4c68d2b92f516c60e53de7f272096aae909f9802120bd66cae426059424fbf572cccc291724fbd517c4bb17aa9b704c3153fc23e25fb240d7aa2aec4de3d23de29ccab194854fc7eed6b6ad562047b338a1f286c11156825cd4980686130b02bad9c24a44725265eb5a5165ab317f291661784fe203ad34f3190c0ea69338349e118068ad713b01f7c4da06f83c85e102763bfccf1ca7826e9e6fdf233063ee9aa84348eb3ec39b0977d1fe1f93d41704a2abbedb661d9c40a38d02e1c293b519f3bed170f28b5f2f1ae73b451440f97808c795521e781df1f506a7181906d4f56b3290a04c6905719ac13075fd1daed8ab9b5f88c8c81d5b5fd46bbc2c3f1db327eed174cc2d49501da2c4605d22296d3bfd0a5adb60374d5ad54a7661188107d0dfc7ae98cbe1ea32b04c57c7a6b72d7444cf69fd8997ed53a32a8289db53a471808d2b1e0eca5b84334f87e1cff4c4a6b684e6efdad183514ee15f1f540c7bfbf2e0e34f4d980428cac180580bbdddd267fb038da45d0c3a7f950c4ad79dc445bad03842da989d19f4a11c024abbdd82e13e7c0dfc8235006ea8bbdbdb6c3185f3d82bb013491d502496b8b232f8a64ae6c5c1bc749502ca3cc1924bb475d35f453c24cc2e3abbbf7f80c2f913c206883eb47e4a3da1923b2195289563e57253104e558b8ec253acd535e10632182eb8d31e1ff81c2899d8bfa65f2a32e98cf248a1b29f394c68ca8ce2195bc3cf758b03097df3b00b76b75b8567181ffe87b088cbbf02302b13620a3d4dbb1ebfefb22759d700c71c3c3c952387a7855af1258cf6f2914767d82ef193ac5ebfd7aba0308b1447570ab5c24978f8baa2d03ec4e5630ed656f0e681c1ebb3ef90ffc67abb1831c3a98d8b0aa77fca7f4879a700acf6a12643f27c70a88a6e4277b79b98335fb8e7be05bff80b44098468b188a0aafea2f1089492c02c88b20c1dd8f10d08d4243a3053010cc9bf26ed8121d9ec2093f813424af3b76efe3d9c168fdd6e797079b5859afc1f2515044724e3add22b205d4a51b6f2f3e1c108eea01d2f746a60cf4a1c37c60fcb22f882c841627a3772762d21ac35e7ca0a9ad165b2768befbe985d011f5f01e909a3f60ac70d6958bff8bba8afc33058249f6d79d890fda0a332f793aaa0395e48cdabeee1efeff3f4d37f02dadc5ece36734cb55843b79f437786d212a1ec6b1b7a28d68cb5fcf62eabf2291df89b5ccb9a64e203c58180230841da9289b8ac0333b4ba9c4818b9818afb06764fb165b0f251ddb6e91afc084fe482961eaf0c914eb8f9945f201abbbff15fb0ccb025a63c3306f04a03a512057409eaf7beb1f96cf9aaf373784234309ee8c8eb61b9ee642bc57244050bb777e894e6146c3a4ed456a94573f2fee0bf1db32001fede7376cf9e6279cd77069b161523a210d74fd14966b092cc6e7d943f7859da488addb2cb754364930a51fbacdaa85dfeab3286e31e0fbb39b94c35240bb419e69051e9b88259e9265e377413ab881e9d7ce1daef411ca4c96fad6434c86eca556901f56e827107d94072983675a6660fd90ececfdfdd8c7791af55d3234c949f18035b2261fbc84bbf0cb709544f4153136c5341bab71ff55fc240665f217738555f287428a6e54290c46a7e4b9389aaf156a1e8d3a40a4a3b8cf4ec32793d5d1f78f3e588e79d8017d550a63c4c75bfeeacf32f2ef21f4f744eb8b06482501374bb2d1e3a66b83dd02e830dd0ec1af0f7c6f9169324ec66e34b9e83385e09fc3d7d8197ae8c98c86a308fe9681e559156c9b3b2423480d349c4bbb67292d7f07cfcb8de413653dc0788d41f81fac8770d2b7327c9d330ade0aeefa0f4d45ddc4fa6da0def954992a8fcbf631a456c3959dcffc9df233c6afa01efc68a221e661dc60d8225287d10d3ab884014324e49da6766694afdd687045686423d243e317a77daaae364ac73ad0750a43c98c5e0e969fa750dfb3fb5253a65c66d7ee673b908e3f886f8486c017233ce05d5861914bbd387fd5690758dbdbb6f3670010d71567c6d8754ab70ad648455dded28fb1cd344e6709955c7c25f724fb61eb35f2f6ad45d10abcee8ba392a3506bebd49e6fb34ced4b23d5632c459687e24f62491fed7a15cf3e95d3584e024d028a748f8b98a97e18a06dc9cca9dfa7284a5e59af1593d416023a667e0b6c18e4366768b3b90a8a116215517e24b5d7209dab78e8d34254170fe69e5bef578f5cefc6305c4989f118b779bb0e8c7e3ac8c82c7f2d903a39ac5c934ddbc0454df01a29256d71974aa92c43e1a86880832899a9471bfc3960ddb06532ea9358a7ff77970dc4ff24df2297657a0624720abbc1f410f90263947c0f3d6b56594ec7f9cc6418bae2b3d9a702cc73eb35485646a29279e7b45b0d84137e8c0ab666278d4898685f5b76bebf87b558127f37f84389fed9103dfa76c4f2994085753a188c265fae4725ad144a5fe5bfcc8428e97caea399a5128d82c46d50f42c9d17a7513ae4eb792f7ef72f5683cdbc3147b86b6e2132e52821d3b14c6ce3ba1d2d7b7e0b5671b930022ed5c79869ccb1812a05564372676f3353bf3bbf5f695dec60d65ae2e33c6c716d633132d4e1b93292f57fda9961ae6145258a599f8c2d55de207674b23b566e784f6bcc5c6eee80be5f6b705bbe257e872ee3e0ac5da2af9c0104ba094ad0775a8aa4b655dc8af191f2cdf7d7e1808995fccd9590c5fb0b2f5ed5efa6b6b0583b343ba4732c1833534fb1613415b6e00a6ae09af167ace145ebc0956cf6f32695a6c5c640cf21a0aa2896cb6880b62c81497ee8f1a1a4715652cbe1d2fd11a9589c490650bbcf788a2500435679f105d8002155f87e72ebcd5bf31a76e7a7d08861d378e73aa1c775e38514e6b1bf19c9ff65b699991af469b04f11f920a1c85af07e925f3434b0e9a4cfaa8f28234841671b447bc0f43c2ffd216de73481bdaf6a1e3d3d3f0194b6b7fb1af195c74a02622fa178bb64fdbed58420d5416fc6ff45cfa308080e6757905730dcd796f8511d1067a08a59cf9672e8f9cee5be9aec4625966654b3152d5b2bd3160b1a56af5c9398a7e29cd75d228c907845e0e1785cadeaa61c8de7c7ff8636edeb11e00de72dba05482abfd085c5ccbe02b88fbea7e94c7a20d200daffab4fd3ac0a6ff086f16888a0704fa0339ff33b9bbc550f376b31f60d0593551fc005f0ac24874a72dffaee7774c9657b0bc9814634c1d02d2e1a61d60f6b0c606f7b28953c69229e3a8692e475402caba92efa906ae0051ee0cfce03b54fa82d7e451f9c9713b439992f6553160d7c6fafaccb070e7f92bef41df3d3f52cb73430bb18d898011b1c48dcc2749e1e3725c95f5734ba36f33a3064965f2825158c2c6fb22e0144020e1b69717c140e2ce3719f0aef4c129fd1c5eaeed5de1457e03767a45771a7b46aa72a31da316318763aa990d37b2f5251ade3016ca3fc7b9ddeb86883f14ce0c3ce552d922a9baa656eff86280a8482f3e9c9efe3a821b5582acc262f4e6cea7f9534a28ce50f4ce91efbbd066726c72a5ae860d15791bebb91583c043b3a192522fddd0ebc23490049014765df0454ca6f52d5269ff5d4a964c54c8427bb23173a53a589ea5caac8e5249709ea96be4226e98accda936d01ec927f04e611eb8a0ffa43e936cf21306244f8b602ac70221a305a4c3d47046684603c25254634a5a094b9d2bac62bc35896bdbda05544b1485208a45308419924956fd259c9c6231d3cab0084722fd657f5ca1f0a74bcf51699d3f7a4e3986d7ffe1bd99f87cda72c8da9c0b67c7a50a88fca1bafe08092afc759d4f6a48f60e9323bc6efa8715134a4c485f050b252979aa3933b4d472dd073660f25b533d32febeb6396d5112150684d57192e49b5199c57d1a496bd0cb73b0e3f6af8f1ef28b65524e543bb92a7d8a8a48b770861b43d5cb5b80b46a35fab5311021f08d189d96a953923c7aa553a2e4d25100bb6f99a715bc7ebb708eaee5c53666dacf561a9475cfe07fadc170569715f8fcce97e6e4fb0741c180ccf0279d9328ed55cbb2f5182d60f45f5fb629c526da690b3d77105c3b3afaaaa862d932d92657dce901094cd1387e8bf4338b09fcf4ad1aaa1ecf6e72c4efe0b6cfd8bba12bcb11e7867dc17264334f9f59293fd8d97dc8bc9ebc200c050c5393a0b3ef9dde97585e58cc235d206b4e159837d7f096db9b60e3d774750ef253fb9d9183ece6f428b82326758e736b9592886b89c5cec3d866c54f7cb1404523667dd7863c15643d0cbf56ddc005d95bea18f8c99ce7bc988f9ce7cea8cf1bcfb99889913b2b7683c5c3836c6aed7cc66ab2850c636b48d5bf8c612a601cac07a9be85ed90cf599395c94bae24319da6802ce56604b03b56446a70cab459ca65f34a9da661ab0e9435b2718020a8e1ba9355b9972bfdce406d54b614d8e76e5ad57cb083ebf18d1282742087a7255263a67e342e46ce59cce6d902f4396230035761c25bd887688d409f0adbaf69369d8e6c21692414cc9b4cd6b0ca14686b4495d5af0f6fe0353742f05c5e5a315abc3b32dc4f81842bff17ffb91b1aa71365436cdd4e4dd38e25fc3bb846132671f480f282724372ed5103728e009182ba12da92fc04e5cb17ee46db89d72228ae2211bd2353d88c7f70fca2acb27697a8b505b3da6355975a82f321b8f8ca2f1ee9a1df2f226cbaf249d4f04061110978443c8154dce88f65183b965a5497d18bfc3345cecbed4a8eaf661301fcbf09915a6f28bc5c035e4d36050ea9d784976df4861a84aad419e9353fc80d10b77ba788e1c7e44f34a61bc960422a9f094775b67933efbaac7704c6a21b3f2950411df5a6244b3383b3c4a03e8d7823707d8f07282d366a4b38f2de839fc2efe92c0ba6af8531c75f7eee694f9e635cdf070cdb57d65b0b9ad496864de51bbf37ffae0c793becc7653bed5ec9b7ff6af87a51184db8a229aaf2dd27de058008a4c4bc13799faf66421eddcdf6e869911cea4d3bc349939119ab201b6b50572be1a43b5fa1f4cf150b6bcb2dcab1da2dc075fa8366f53f7a173ef2a863594fbd8aa785a67016ea952b94ecabd7699922ffa04ed3a7d7a4e63ca47d26f9b8106210113f23b96c1a1d43552d7016eac2c2a97b2c85ac4ef9b1432b665e32bd27f828b8d8815e1bed97fdba17b2586f9c133ee633fd06c3b6ac8a9126ebcdc4252797228f6e83b23c8025ad26595f7d8c6679d812d01458c49f86394708162222284badbeefcf8a24816d19bac941d85733000e268d1790cddfb6499575c9d8a435c181f862bc197d354db0e935c8ccdaecf841064645c87f62283e4bb45ed1d1a206e77881079d90e4245df71d8037246f5a81193f7eab6b113b492c1135f4eb4eb9f3eb27d723569258ff198357fc56ffa4cef00053ccf866e9c6e574f2601c1caad9bb775e7901645846b13d5b654af671d4d428035c33848ff5810a67a696c35863707a4106753d42e3eb26a75b3574df26400fd150ddf018d622828ded8599f6034ae9bf14b7ebe747e174d2a9378e012cfb54b3adff89475b6f5f97805ce46c50c5fab991770253a825d62c677bf292112d7c6769ea1ab0a46cc30cd14594cb6cf3b190300536c3d510eef1c140fd2dbffcdc8653785fe257dace55ab562524362dc905429627f9469980f987c10219231ae5c3bec1bf9dca3632c9812eee548d2110942556af2f0d2afd7d5d7d4cee574579734df5e711bd6378704ffc4efb9f71192cf8b1dc394698d5fbe4e309b63d1d4e8178af67ca856919ff058fd54e9501614c6e6f8cc3ae630d65f74c1a0475eba78b1d12916f61586148abcd4dbf0a34543d661a52f85bdb64ee09956beef301dd058921ef2f2514c1d37d78de8d31c6eebe555df444b1b91b791683df092cba01b130f0880d68e7d95ce1daac351c8e754c481f35f335fd46dfb6aff0f6c9705f2d2966d1b1e74f137d9a9c08add0c22eb685b0876a5784805b5f43a7ac06d33e73cbe30f02e6e72a734ea2eb0c2318cfc527a2730b2bc3d5da0d50ce7dc5d8209996f273836b553b8f540beff94556ebe4c8e6b4dfdc59c40761fea9600c14d2d2416467edadf7d7634971a13317ba087300f29e6dfd1241dd9e7e90db2606444b4395acef523c874b8378b2d20960f39e8947ee6d0a76559f35837a3e6946aa54e2492dd0732593be829d70f85fa3161c936e04fe22a6fda2fa8972f712d61d587d57fa396f3b95d26892612ce2a72a07f2ec049c9a7ab69cad61a0a4ed143f5cb69bb5a22a935e4c5d7f68d9c1fcefe16a15b49bcf7b4caa41670b5abf7ea6270b009808538a6855112572d63773a05c2ad72019e5ff9796c4961de2e89797bf1476ffe4c6a0e978868503499f52a5ecc6c3a12ad059afed068c873cedcee2967904b8eea7ee261d641c0f15f1b83cef868976e979b4242711f90be5f15ac6f031a77968522ffc77d2b5fc33b425e8cc5a349d8053d6bab314b9d27744bbe10607e632177b9ddd2a71aee0f172e8e2c98b2958d79662b28a8744cb7428054e453b8bc17d0","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
