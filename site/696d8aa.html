<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7efe67ccb85054cb6aa8a64e3cedfde19cd88a84e33b129ffab11ee14538af194127cb44bf8f057b8d566f3ad91e57d11bfa9ef34576a94c1e9f0c311bc630713beee5832277ed1eedc5076edcbd95fda5035fe7a60e82f3506458b2f9be84109cf0efae2776f95efeaec5e94658a1d317569b60fd9826de5aa881db41eab11fe1c2a9497a26eb3e54272aa0bc64e18c5139ba0f22edebbe8b8310b89baaac67b94bdf607d1b0c57134a4f02c3a393a5b83cd0f8ce7d599c89e131101fef1c76eaf7791b3078828020f02281ff327c22feed8e78d13446a5e8724f319ad3cf39cd743da397dee3d6f5b4e0ac1c7553101753c2ce21b96956c6202848f1415af94b6676ac18d7860012e5ba0eef45964b7368a5875b8cdda4552f417df172b5ce3133a76079f5314a9eca3e97003862724f8c9ee93f720fe88d4764fc0dc740fced8fcf60e5f6fafecdda8062c31f176baf4645e80ba1bc2329006c83ea5e6eb7d990e7c514bd7ea67cb42936b9153d3b7589eb11788a0e4538e9c7f08f04c152e45f4306f7ba0beead45a6bc0b8a1d568e6baceec80794b54ad4d401e6165eadb99aed330831c0a3d32874ca1e0e9c1bb284d99d3728b6bf1a0632f04ba303ae6b546e2e06e6ae1f22ffeeb4a9c6b3370e9cd14fa179e2b518298abf19eb9fc584d6e4ffe5506bfd0e5f7cfe4aea0d61317f0da0966192e806feb877b767be67e431a06fce1a7c1740794b15ea36be57958c88b53ee45fd45bf03f9223e6cf9a9675444d5bbe81bf837f2f7a280e33fa12d2800bfb4645d25ce61b5406700856e9804dda2a890286aa30fdd5d91f3edffe5ed2b287994634606702aacc73d9c8883232040a817ebcc361d83751ed6e03af059f2952b95931c65e1b5edc84d068073231de66a998dac0bbdf1fe826557319d7de9428af9f55b185348a4a38917b28c056ba1cd28ef20b3873204c0deaf5d0cc9712d20decbabac47b4d27981bc81706ed272427fdfd7aed0017240af4d3e7633d34115752bd6359284dce6a4d979bc271fb72b24be7904dc001fad5304b4c9d674da2f20957b67394af04d462dd676592dce7fbe14e7a6dd0f35fbe72d85e8ceec18bf495602e9ea305dda61c207ec1ef9b74026503d2d044f5af26cc5928ba7fac157e7ec387c8af4fdbc759dab2b5a6dbe1c331fe07f5385536f13a4a1671746fdc0c3a9ffce9d07fe02bb08b8256320ce55abca3b74200151e624395c4ea4784b69975a3b15f8351ae7d7237945bca048af5de202f67096cd85e5b0117cecf715b9dd947d4397968a022a495a9b3197e1b3be8420afcfe12694f37527dbee9fef7b9313c6030ac64d71a2a166837db2fc0265c6aec933164411aa8db01cc9c7f6bca21dec425a923153efd336b0302735739e5887909753d5f9c4d62d0c180f49689e473ea3da0677e4d9fffa7c81b71ffca2c1a01cc26a4d80dfe0841f397a23b4dfa12b0300137aa4bf6914ec40ea813df3f3038413500c49405e57a614d43b95af28852eda21e2f99298c0efa468af5cf0c3a55d8786467046a61ff497a5c0125df21be33b036b3597879d7972b4753fbf683c177824468b6955ad81b15d73995f35c6d2c39bbb948ff4dcfa8e610b7b5a343a9ae37f90e57ffe823f838bfa77df1be4098ebe9ebd1dce4ac417c584b55807407492ad3c2d1a7a3d99d30da247972f9292c69e6d7e8163f9ffc153201361289f1fa9c96050513b50ba1a6ed7075461591aad9af5a6343be2b7d17f0bbd8b14fe2362620afaf36d99d188fcddd440a7fbe81e087f23b5c718027b832540915e0874d3e6856861a12a62e59cdcb37c151438c620710e626c51f73eadb0f11c5d6376b6c6a5a25bfa2df36944c9e3ac7634a85e259f385ddf9a8ed457d1c53897a1ba7b4463f0b437dd50d57b745d61a4246803cc2608c8fc6af642648cd0fdc77225d345a90815d8743c94bb04ffaf3290cedcd89ed0f2b6195b95bf905d25c0c70ba5d9e3bd90c79452e3d54ee11d370b6f79603d89bb6205c98e874f3736ccd2871597b29b660c4fe2ddddd1f565bebf3e1a623888933574f1447d6ea03403e2874cb7a300f385ee8e13a57f4ad346ae152bac142a14a2423855852ac8410ef7e7d2101a644ed4b97bb065c6ec8e2cb93aa04796fdd00790fb922629e2b077dfeb53424569f07535fd3ba4377cc2cecdedc4713f832d6286cf764351a9de14ba1437000fbf5c338a70539e99bf05539ce88fdd942a0962077adcbb91831d7d354d7fba63ad328f5582fba4288d22bcc7a1e4253ae28c06d67cc08aa5026d008d0f8d391aebaf58eb8936ea67e04d869a41679cd4392ee441832469a73b79df4533c15087526ac6a00850787a828048cbf995cff21eb08835cb893521c24b226a6c55a8cb699bf0edb1c938908c0009dea1c9463983f59fd206132721e56a4cf91b7d91358eb8fbebcbf484a825b9f4223feccfc771a968c81bf9d7ab9c802be1d2f97a53f9e484992e134c32a1f76e149066a7924c298e9986457df0b7711f3ae64e13888cfd6691fd03875a372940764faf8a6cf554036d08f67ee445b18689beffc0b53203186d907d4c164c272279297a4d428cd5e0a4a3b36d86bdb15d06b54bf73bd864aae3f95f3b6ac41afa95a9d4cb0ee2e28f1012045ce7b33cb635c939a9415562d162cdac63b36df095240db91d278dae2118425491f30deee83a63d9fab50db8eeadbc37ae8ad94dc3364c63f220b9db5acb8d69107a04da71a4a250d6a6a8dc777f43f2d4c25d72712425b7dc99bcbcc2bf007ecaf79d6ef5f288dfe6fea7b90358dc0e5d951f2d03e5c39fbc08a20611417c5a18c8c4e8c9a75612c10722dca783cdadafee2b8b9c7c470a0d14fb07348e3476226bc57b2355418e82b579f262eaa53c52582abd160c352f37e0ab6d04a430949f41c6cb02576a7d601643eca1b9475306fb99bf112a8531ea3311fe23e22611a60a6b12337093e33b4fe325abe18fbd89f0ab6e4c59c0558eedf22eba655e65524b62af8cba6d40e1cd09588ab6fd449668f852da28ae881dd53e1800f9cfb387603b4a63df527b83aac5403db9df15b157771e4b1c1fdac27198b2eb1ca4641f64c4497f78e4feba1d10eb566aa9e3b798e728a058fb9d1cc81b90f9e2f728edbdd4b6e248322aa617355a4cbd30a2034d7bbabc888981b5f07282e4a3c5b044f4baeeb4515b316feafc3cb297f43b4995e6e5e3a22294bec96b4fd3faa985d3a9a2f42914f98bba488759b0c815ea9cbd82ef29ced55f6126f18694ecf1b06f22b3742b285865e3c3fd72b59cc7e78d0f11bdea45a07ee3cc70b9f8bc8c146a1a07f1dee956c5abcd68d4da4cd8184761efce4fb47ab68ab9e9d16518b0f6012529e6bd84564f59b77c63475e7b1847f7e4c968797e2b7e272ee7abaeed729f711a34f8bfc8eb3465a8c8ec04c5be5f9530e4df2c273fc89f4063fc617387a2f3507d54d7f63f714fe197cc784044e5413f3922746cef7b54d164fc553f1c42ee2ef9b3b53992cbb8b443c63343cc89c7fbac2f84451bfb81306e7364a184f899ba9883a8033f7dd8afae31159fba25a825033cf8fd0809a1cd596c89e7d8ec0278d01ac1188a5972f3689ad74c3fb47d4fa63e9f4e22ecb88dd7cad15a6ea0495dc8d521456bd59f256813f6979aa148c5289c7e56e11c072136823718a3b27e4cabab1853719c5b95f50155c6852195117dbd6cfafa6cebdbea92c0c0a7287f18984ecb45256fe8ee80c540594c37f0107d0bbc7f969829722ee39fe258d2d0a7c1e9d05a21711d6b6b8fc6d4bf9023be4390b479a01d352f50e57307d49fce0275d06ffcd36ba02288424fda36c6d3c0f31aa49ad86c19d085e3def84872bdbba0aa2e4fba7cf85766e38bcac79a02cb169ad26b725f9ad2b01e3267296c5e147f7b82c6764c6c66ddd2275a4f6dea2d76ff4e4128b804ed0517300fb454b61c1740b8527853c70bac8c7352b118fe17f478374c54c40a44c872eb79ee9db2f6bc9b7b7f7eeb52df2e5a4b8f0d73a420fd7ba34e27a34ef2528cfbdd89a4f5a3e7744ba75c1257a46f55983181b52a75a932717a398b75891da59042a77f392c1fc0da6e1c94c8e68c5db608f8465c0ee7714febddbfb5fa5a271887aae98cd4bf4f68d85412d0046f340ada90bb898bd046cdd56ededba713e4347648a37319d281decc78cfd56a11700618c4cc5d48d234ab11156a271c212889509b59e470e242b1e3a436c224adb19d462ed11fca79d8b4a28f4cf5f3294b933c17bf2e5c21ae0f622e005b144557b41c074f92c0ec6cd414dbc31f6b48a74f882bac9159678e6ef2bd0d80ba1df426c50d3e5659e6ac5441242ce20156d9d9ed08e49ca1db12bf3667bf9b0c24dc70f2e61cb05071208ea0b84c21d20352e5fcdc1e1fa6255c07186631bd22792205edd2deb068f051514d8fedef923f2cb37ddbd22c4d7e3d2586751d32ff0a3705864fdd2aeae6914cf341ce82922623e490908608b077c3f1a35e9f009bf767d333e88b7096cee84b383a81c8b01ba5fd2333e7ee00f05578d4a9d3dc7d25fd6e5fa06bccbd9a5b16dcc051ecce36544736754c262ae93aec0aa739644dd513c7253df750b9fe8a54a8b1e7bbd4ccec323e1756cdc07713d022cd68c8ee498cf1e0cd7bdcc8bf9ecbed666ff94f9d84201109caf8999b8e3e311f1c5c68d2bbf5a5584a42730e365468a08648261687b3a6900425754b651d98f8c968ffb8006ecc6fdf31c4553ed29a298d530e0cf331387a39359eaf79e6693aff841b2c1368a7869b7f58c542cc3d653768eae9f286cc0bd0b959d99d643d60311a055bc504c7c06bee07fac5946ef11ec6898046c15731ac7f1abeeba3a1ccc089f740147e256dcddefb2e9d18813b1bc57193fc87dbbf1617546c6cefc8ec49c611617ed46202abeacc4b4cfdb6f4c253e551de3390f1e524f8f9926bf48949806dcded6be291616af5c7978418da3d607d26bba5bfc914912b9be62da3548a246fac90903908161dbc2b6ee34f3d1edb7168058129d602cd423a63c1fd5f262b2dd3ab8699fdbdae8d9811ece1c6e26479456b6c3d342dfba2d3531166a1c68ac861f50a0e2b161827c260f6030ba6a000dd4ebd0221b49c47b9d5f7989aa85fe1d9f978b2f722e50325137c7a2c42f44a149467e83c7796f7bc52d9bdb5e347927e615f868924d19f6d1c2faf8b66f3acb4a22edd0ef1e598fcf045f4e268b72caaeacdfd25a45c637147270465f431f8a3630a7ae3d9a8461aefc0baf1f98400fc23deeb1f5a2f33e5031894e00bff8b58a72a16960f056fa5b00e4d1b8ab33f04c3cf71a5d42fbac7bf674c51912d0e85edc769793d3dde6f3c6669df75d96ce0efd0ac62c635fff0494e26890e59f1ec5d6cf7b2e2380d4907b745cb2d53c09b7114083387699583ab4120d02f086a4865a2492dea20ba07d651018a238d6589d94a189fa06cf818941eba2d0eb2899c0bedf77a415ebd7b9154a322ddaeeda865d69ff57816a86484c24bc3d73c2469d1a72ba6057a9efe2c260e818550e410a4807880143f7a5e2bbbfa2c5c0ab42e0d4af3d0c6fd4a04f4ae0d29f5056b1e695520a43ced8ab8e617094e2db72fe35004fdfa912f0ba0937fe88852c84f9bae2fbda5b14f03f363ed4d0fcdeb50d0887b2ecdc34e089ae8667f55c85b39feeeb42f75123219804b025706368de6b869f400a161aaa7e678350d897afbc305d82268ddcf52de2b7f35cea4816361f5950d4d39749af922de51db67b8534530645fdd29fbc6faadf5662ef8d5aac6b3f54f37f2f46af18bf0f04556f9dec8ccc8e8f07b9315a71675f49c90949e1688f826e73f46a2ed5af8b96f9f8db72bbe8b0fdaf688654d5c2ba0944f7798e75ba1b99b3842b8286a417fbd2a4e44886fa627825e0e404f66739e52c96c6d370aad14ef621baa66d79545ffd2d2377978f8d1a0bb6e55f37d41c65ecb0ac7b601fe1f661edf6fb0b7dea12b5379e83bfbce3fe93b9636c035ebe23be0158d028d70ef45e4ef86bcfdd64e4cbb560a42142caf290db9b4dc341713b57895695e07b48b789fe887ee13c7a66268ce1826756bfa153c051c94e5ea16dbb9e264c2534105b435769f38597bd6ec17d9acbfe3e63dfd83075f057e6b45bbf79c42b31411fc50984d4e004d0c9b93e80ee12a6c13865fd37f55959f298ec4d355fffa3b3c7ffcd684697ab36c22537550658ff9f52edaae75210d9cc08880e64e9b93e9dff7ad7700ed4a0334e2bed9ac0f0ea8a9decdec92f414a34c76f3ed6f0143e4aa3002a0964cbfb4b6c642abe7c8fac949cbd45decce232d418fc9d403536d1a927b47c450e6c85cbbb3a1ffc19e5c66a6e9dd9783cce3c8b373a4829b8523438175b75536c0a564ab30dca5c0f26017efa09695e907a34ee6d2ee0bd124728b4de7ce52ed08eeed4de291975a76c1ff2179922b5252abd5539556675a1916f959b64620caa3ea373093622ba5ebb90cf10cf2b75dfb42da53281038c68c46fa9391c83cda9b0f7a28e392bd737d0d629200d569a90f9914a69eba29b91111a944a56206a0047faa35f5268b6e3adf21e79ba67de2da950b1490370854f9daef0bdde34d3a34e2636f4946ce2f840df1d9d8fd33b66dc55f0400e21743916b90b8460eda9789486f6cd20c2f36daedcad6e06aa9f40881f12604b0dcb5d55ac3388bb6da08596fdba29678b6ef1e26ad748275d3b6aa06c6270e1d174193f03af61605318e784e7222062b1c0e1002d8bc543866a6fb6842ce327be0ea70600a625cacb90467c24e474723792505d37b38c1190955e34e448f7206aecf19a921491c84c8ae499c52d644911cfb1688d3b3598c30322417927f176a934df8d2c3abcd115a915c5dca784efce46553bf604467791e251ea2197a1257ded8e96486bb832f8be9251ed0fcb7801d882677d63791fa41a6d8c18301c642d097911d8416a6bb6c25fd21ac444853b198e1792e8d8c0128aae01a1e8d3e6911b967e529f8f42f5c5109f5c30b9f3d274e3a1729ebda360d1c1b19febf510d17a2e6353f58bc614f5458e43562edbddcf0bc8a04ae0dfac7d24813d435d137c447120b011dd94eae53c9acac170136492deda691b891438948e8135318441976b25df53b2284e15f8d47ee7cd5b40c98a7a0fa3890e81d7f886fc067eaf62c25744adf543a41cac87616dfb3ba8b6f39f99d4fb112d01f9c056db479b1821137cead7b1dcd72dc11bdea94ebff21f6fd17f8c63c232edef794ac1551f8488176ce070d109eccfdf7209b0a57383404af5f20b56cf718da4c510e023f499f5663e4f27988ba8321ff6f05576aeed2d995f768627406f3c979c50e9955ef5084440e68489350bcf81a1b08a406886455ed0deb07b27ab063d9b4cdc4d961e23e7e3399cc50feba2eb2185e0eed6e39f9678535a0f31b4220398243e9e6653083faf76e77ae4cad7f88a23e3751ab5d5da23d8f66a258f6494ba6ac0a4a2e17e1db6196e5e178ebc92b748496c0ad96132acdaf04ab88e1619479d31682717bc4e0077dc0fd28041a3b5116714f5a48afa4040ce9914c6ea2aa72ae82a1819dfaabdf39c489813a2fb5b05ec44794dfc4347746e0af25a068423b78a11747eed4a4978eb9c6e23a5fdadda5569ec35fbaefdbbcb5eebf17a6dfc9df49f53ceee0aa2af98bd6be7a32b59cdb239f9964970f78228c214699ee9d64849ef2ac8dcd8ca1273abe588240abf093ef4052b7c8ceac603dfa8b26635a311bdd269377cabdf20b3e100936320f601baf288d9506c899592730a69eb9aed910e5ce90656da6d07b0e448c7ff4e11367b136a6365c5ffd3384007cc7308329fff33d39a853b579d0091648c48bdcdf0771f88f343f52cf7a9855606ac79fed02400789830b94054532c4462091615e73dd176f4cce43b0dd595a2c480d29f247949359b89b23cd0d5cd71bfc007d4868eb85a60183e8bf289f4a405f6d54fcd1997c0280cbebbb33c8537ef51d0ee628183a5acad0a46489114e06076158749137827a846b2de879036a19c5ff423cde57ec8128edc827969322561f9da78f8f3b08a5433fc4e27052a41cf8758bdfbb8522f5eeb232c2bad8109ebf0730f0348e0e9b06e71c04b5bca8f5c2f583b5c14132db82f89866e41ebf590bfcb306ebd3bcb2d2780c9febdd810c6eac93b54a019a84a3d3d417030ea2ccab0142ffe29b9e8464f53c859036c67d0aeb90129b413c4d123cc5591c0634aa52dbd5da052f77c681e5d0b4cc8f9039b6ef96ef5d1f09408b8f2224a81195429685169efa5c5c1f1b6308f3e67678eef8a188aaa7194f51dfa1503bda14fe42b9b164199720413b23f3e2b78d547a3500258c4ef6ec771076796ec005164b21973b67211bcdf5889bdf490a707080a087a0dd055735d83f428fb5bee9d965ff080b64da16a3224f47f61eb9c56ad2a5033405bd7714901263af5d1605339e6e5eb4294f4889f3f37c0bdd358bf07865275483fdf5c60bf740020658203fff394a0874990b684de27ce56f11aeb3b2b409e82a7f2e2e311240ec87b49016a53fbfaac29917077b3b41a646d843f1927b4be9c693815d62dd2b705fba75267947597ef19814dd7764d10e7c029f2e6550e9bdd3490e468b308df0c94810c34c00236eca552cf610bc36553a0cc4e40d4da0b198530ebe1e0720b7c84723c1a8758944e44e637348272f1f3a28ad1eed62d46e0339eae71100771edd36a0d4114ef51e9b81c38617686fefbd945e3a38b506530e2e09c93197e9f7f275092ddda1df5bd9263b7fec2340071276673dc620498e90f9d57ac4d565a93076041afeeb87cba7e90a021aed36c92042b4b2c9b7041cef8ae6ea6933299f230b5c53cfe958ac0bb8e0ddb478a69c287d59915114e514649ccd25b52483721518e30b87075b4798f06697962c840192bfe8eafb1ff7e4ec81985b05e9c926c48c96f550e05a856af72b2ef9a62f5d965b2749c3f6f342625f09c34f6421d5ccc5b77fe894844487156926e4314d86c313ca279185d0b4816635afb5bda7214e0670c082cdb7ea7f0e07c114c93dc2fb7a185c1469abd73ca139b236d8d305960ec83f1625a39d18e31d3c12a84abd45944e027abc86bcf394362190a0bbc7be450da54abbdb10bef9d4fc47599976cc5f7d0cc59d7993928c7316e71df7b339745d8dc0aa653794fad7adf6682972c7c64a9d7284587fed972a9265cf8b576524ffe83341fb0dc7d0c1521609baad2e47e92ee412dcaf352ef0a9ced8369354ed64796e5fd37ff47c209cde6b6d5080819c862fc3368a6e8bf777035e81b3f21a95727e232e3e92fb42279ebea3c8207b435408a40482a6b23dd525a88b197770f525f7d61c1864dd5eb8c36f932932918e32cb1437768055268d78e3c21e4133a0b8125ccc7db2658558fa971726c4397c2d516649ae7095bb814795aa8b385fde8924e247c1fd2398c35ce4f831b3c962753f66731910c37cdcdc055770d19f9ee0b4eeec81e30930833edfd70b6ab2d4169a404f725b3bd8019a5a5afbf8f15a08de410cd3caa93622fc5b6b19877e9b7e2222325091d36ce0238564a5d8e2bb425ecee66f0becdff8c6ba53b6e75c8fb661efa5f628ef386357d9067f0085e00ebfbb7e38e52b3a2975b72d2953abf24aa79e6a246a572d605a3c2a74c334769680b564e6d83d821be3463bbd5a1c3bed2955e1e5cda64adf351eb5f361d20a561f2a08f4a2fab4a27b841f767517562deed674d181742951e98a71ccbe5004898a28b10efe8233b028fff2e94a6da706e3829995bda7109aea1c0f777d97ae8dec627d941c496da5461f96b0fd2455e2345ff2d936e4c2d8743ca77421a13120cbeee184e4ecc0141a4a7dc38acdc8fe0024fa39785508019cf9413a3e27818d6ac42184e2fdecf1cd88e75073cddfe1003cf9cb8fb2f0dbb5f93d7bd8e4ec9718ea26f48d865b667d6650af2b72aa98e57fd3b5ebc6779c2e853ac9548b78e3f26521b4f2ee84d4c0daf1a5e30fca97fdaa394250d551b7852e71d7164e29265c63c43032ee90085326638e195a5075052e1b525cd53893b54e0dc9162db2489da33a5771ae9a62d616cacb987a63a298e071ae780139b56721b5cee18ad5faa054b6ac15ca9b5ce3e703fcabd9648f268ee21caa7351083ac8f1de4310b3b98ddcaac35b665c0310bcebce1aead9349f4e0b5974a31eb0ee2d9855b5da28ef810f84751da50bfee4a961d54310608419bfbc973fd090ec298d7c304a638fc715390ee35b8f8b2ec2f4a0942fa47bfb4219b55dcf857a888e4693f0719ca086b246f40f4b0ac5e67d9892e84a561d7c6c53669c7fec3206db24c7c0a707e38e75bcfc9e989976d2cc24dd1b92dc151ead1f883fbb09bbf7c1956ed9805fb07f47c8b06a6678fae423a0ce77547e71e93bb9e2d7abbc280d15d5bb3fe2d75f58f50966b208ff71a791c9a588313c36ca1bdfd9ebd3dcacd4e3b92e05571998bf72364d99d1abfdd3f2e65252edb5981c3be701a92ec174e8cc849ee50aa91a5b490a003fe5f70a416f4319949366ba2a6edfd0595098d2565499304bf0a288ec2c657870e851436e41aa5719add5db62f2365bc501f6829a794fb05bea341a365929d61df5aaf21f10d066019fd9696044382823b969c89460eb1eee939a9d9f624a049dce157b6560376efbddb0773c13b88bd1646b249b6746feb2d0fa3897cbb2cee2d4806aef5f531fee7c93b519237781d91cfc1ec273ce98199eb25752a734bdbbdd3a19c17f4e7e3f36e971e7d1c0","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
