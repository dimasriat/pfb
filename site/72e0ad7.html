<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52e80ece3d06374a56a0c359e57e1cc4472e390a22a34f9774dce0fb09a5d9a8f7dbdef59fafb37c19b249b5f83fc9b61d7d2cd9b7345e14c2e3d26290d23e39379c0daf02ae7cf03abdf302d6be3bbf9601151442102500b91ecdbfb90c68876ce79e6ff1d04064ad2a968e40fcde77ddf00ce9e7b9c36711af96232fbe8f6c5fe64069ba97b5f603e50fafaa89ab0f7ee228d596b2019e9c0191dbc0cb8abee7240916186085ab7f298da08abf15ac4139ada7506e084b955124945e9058619a791ca417e36c6377c8ee9c32b243de511f993ff22fc40ccaa9051b9112dabe5ae78fb6474bcf10976493e1701ae287546a6063b9535abbdcf967c4a24f2a7f3b1c8a91df1dbe90648b55fa82b18d876e6baf7499fe322a6444a9751ef6901681b8d7114e520b6cbab044f130b6305decdfe763c265d304ca8e19fa14af1032325bdb7f010d2a86b44943d0a15debbce496f80121ef15ee685b511e850f02b74826ee232eb86ea78754fb221299796c9d7074ec02fb2a75a09fa9f19b2485086e0f88115c0a46625529e2a11a7ff0de275ed729be9b7be53982ce92e9b9a7334aaa10d469ee3f4c14619be9eb0a4b845090d896e418e7c96bb9ed79aead37cc15f1bde72c884c9e871c47bee04211e80ccd45b7df95c206ee7e2ad1747ef74d8f77fa290ae85a1f799f9f06ca923b9336d52d87eab9ad9ef810682de69ceb00b18852528f07f731cc264b404a74f04ff87af6e3fb42b2ed2ab8a2e9372aad6d488703056a3c6fa94d18bfcc66cd9ceef9a12714643471590c0ee80e08f8ca86ed11a645e3fb1cec7ed92f01104cd8070eb90b8610419ad74920b0f23bb67c45fbf8de28344aa49ba43290e676066af11bc594e7b40e9132ccebfcbec7bebf2c41e51dbd02d6d2d9b362f950179aacf7975ecabe0eca9096ca2d6f4303a8125f9a9246b598f16893d258ea8098bd865dc413f89ee4b16c8d79de682664a4554d10ad820decebedc0b7b76368d2a1e02d225a0410edf1eafd59f57fdda5feddfc968e87359aa26fef914140314b8f63faaa824b39d506737b6e0c1ef3a07d7bed8514e7b74840ce90ad7fddcdeaea0dc79ed62ba23aa850e0ad7b6d4cf94c3b5684675de4468de22af18938cd9bf1f360f99bd429a4d22d8dae19eeeb96ce33f4e81ddf15dcf9738ac07541a89bd7588cc46c45b09163af2bec2695884386a1f9fce31d00a3b4343e3d6ee76c7c1d80977cb922f7a32958b1b139a4de116a5d026779f35c75b5774a62294dbae720d8d8881fdecb77d478448adddc8eff3c55167ef48655104b00ea685a6f7bd53ee2f38d27079dc5488bf724b45d0733eb329ede346fe506f873944c983839c477959ea3f1a5cb626d486b6d58d6743470147dd0b781377ea5d3464d56a4f4164e5819991f58c85e423fe1b3eb75070cfa4043818e7e372549ba360063dacaa72d69447062b6336abc40aaf7c3f78b5a8ba30ef775dd87813a58f5f9d66d42e79c7d1da1dfa4a43a796b6a03634b2b45ecaad378f0e79a5da43e9275e9a02b14447b7f5c0b734cd7cede4c9072a5577c182f2c1cb6f7a62de11e4dbc789f6ec1c214ec4750cf662cf53567c690474bc0f25372d4bbbf7949efeb61f6d06892c6d2963085cc4a819ebf39e89ffcda8ee6ecf95f727a0abd3c160a99dd64aedb846b5278339e34333a1c181c33108698def104a2338be34e4b919811aefc78988a60940fad4ff5a364e04db6d574becfc43c5e6c6a149533e36cef8524836dc6146f60f166babc849b8f63dbfc5e754a2b42efe8072dafe4945f5abf7592761be32fe3d6ff5828754c012bbe9488e1f4f6f45d6947eedd61f0f48511cc8a692b060a75efc5c6cd43f7a6f740a59bed3a35c27801bd1f7a5e6b9220dcc6c641a8210a6136fa48f45bf869b9a0e76639188b8a4100837d3ba4df2fa51e071e3ebe3f79b5b80ded3561c15dbbb00825deef4db146122bec03ec58c54c40c52956f7b039c8a710a7b023a63070e5103211b87205a251f2daf71fb0f26b1381416f26b2b5b216aa9d69eaae700e3c91cf6104e0db46d514d0eaf608d075c6128001259dd26810f83b580339b8d1078aaf42dc703b78fbb91bc9caef3e2d0558a79976c1cc0acd550002bdedac50373f29ada316448ef4eac75edb4fb14f8015ee6ba2a5a585df2440e315f1a13adbe82093c781c640280e7e7d12cb7ed621af83acb6c714dc46ed8ecbc717161345c99cbdefc1deab8b51e393b157e26365570d03114e2f2cc2fcd9d87e477e8c760d531dcfc8e7fc3a32a18cf9950f7d8896db7d524affef4557daf83e7fbfbf8ac7ab16e900cf1f01a57bb3dc0c20953be087629e4ec90bfb73712ac28b3dc453f003097a6154655414be00cf0d83d5b00c6246c8348f262af8f8d95aa5480b26ddf72fa8a57d245e028225b52918a9ba122c3ba338a0b622ceea209bb617100160de2a6fd510a5c3e62f177a04b02a6f66abd8d45d09b42e67756b9ec0b0a7beb5b347757a790526e8ac3761947c8d39c645f3f0ee57d5fc60c78fe3181941a7924feb4338b8898ad37ef068817e07058518726f2db8a0ee725f3ad5c6faad277b6fb21ff91e464402d701131db9e6851b72194de8068dc5c728b734e398838fd530fb2992c32af9d4ce8e8ece14716e62fa6f3809a6afb0aaa24e4e3ccc5747ac142a7ffc9c28c07d29d41f92b72574362903cf885981bce5692ce22d602d3dafd1acd2bccb7a44edd0c17d6501d99d4f593eb809a20428f16b3231eba9d98bcd3c4ba1d73766b7644a4a9a0ca4cfe400b72353c67f00d42d0bcf9e5f8d49da0cad15c0bdc3454d7fdbd96f4135961c493f4e8545e73422cace5f5d32d41c8d684575eda4847e798dda8e4cc866ca359bfe7b5f5ea7a7f984be4676e6f9299eaaff0c2cc47d72d14bbbe59e81f0253d4ecac6d20c31d6cb54d1ef9fb3cf5ccc8c2cd9f3fc9b07729c5183db56d8b7cea9ec902a2215be0d98eccce0fe41a47378c39223f8f4534d351ec2fb8a02c2b07bd7942720b8e2dbef06eeb14ad44a74bdd77b154c6e3cceb4b4c8237d736658db4969dc603622ce1f7f572af5ebf983ab583d3de953c27b9393736bec3f688bfe233f8e9068427f953fb842e6f1997bb918b951e32423514f92d33741832eb9ab80903a5c75a8874c39db95d97577a0e28074c25869e70f9fb48b7bbc411ce30ac0deed6dd2fcef419d0f73a5a6764982b1ad218127af22f13ffcadba86766a742789aba9c48a02cdee8e1d7ffba25051acb1b792ec2d839610ecba016f0aeb6a5f22a7d35455604c4e59c89c735f6222bd928e3b07cc7b8ac587bbb28337a22e4830ea74d32fc3769966c3f6894da068a4eb01f484fb442ab5af3df53f35c21635d179d25c2ca28fb82f57779f1d7bb1672e729be00988a884ec6a14562aac5a0e0a70fbfab7a1457c38063224d4dd1fc68f243d6d7b42e86a48f9e59dcd25eae86a226dfa25b3af7b4e34e8abe79f865b0438eb87cb321f19168e6b24a6100d6736991a08d7d1d24e296b7b3103658bea6240761805cdb3ed0b2d5f63a05ed5a80ddb03e4943fd669788a929e1afd040b4029ba4264ddb23351333dde416d30fb003bc9ae43e1ac3eaa5f7a4d8d83929f3692b4269ce73729c4ae64ac2e932496d07cf3e305e674327ecec3a6d68f38b266991e48ab27e74719b45ba72177bcbb7d33ba0fac82afc6aa524da66f163d9383eff3a3ba9f761732571e8f3c4c7c545cc64de6db6dbc7a71f3fa3cd945dedebc8c466cfe55f30c2460c959acfcab03446d10c99291b3a67de78f9c6ee2074ea9b043a9725e6e30012040aa1265e56f3ddee5b53ae614801681206fabfd0290ce2dbb184dedd390a9d95bfee83ea68ae478cd9d379d7ae800700fe5db163272914cd75b65e95830be32455f27d6f64744a5117bf9cba58dc94ceca547e759e9c606eaf9be7904df56e0f163f086464601478c197a5fee300a6de5680d9689e82e9325a05d857df6d9eb1a2749f78fa0b24ddc116095b13700988d9df6cbcaf3e5c979c0b9dbf7f1c538b98f55607c08982d99d8b8521cafd07ff4223ec407e87868ddf45b87a9b68e4df6e3de3a6298f09eb7baaaf513779f8b86064cce92c168c12df8d089f8bb4ee773bba3f75a9ba0f3e674f40e0560cd947cb38bc620c57c635335be35c79eb95dd4af6cdc11661c0d9686506eac59e581d97bb1831210fe5246de1d51b4b01fab8dace6090be3c1ee332764a4140e970150dbbb96840583cd1300fe2bce0b690628a79e1a628f5d95a706ca5364404804717e20abc755c4be4639b6c114fa396f12d7496458a925794b24ce595f796d7ad4e5ba1ad3d65e3f2419354f2109a9892185a15fe2816c6670d769afccd150361b88f22c79e085a781a868e5ece8507c3e0a50d7c84d643b8332064b7cd8f2a4992b7d7627ca633508320876839a92cf73393f542c9c5706eea3e95ec26d781753a3afac7c39e32ff43f0a89f16c14658529b6a2150f22959454e46873b4cb4c17e112716ace9b42e7e90def14791a5194d0cf533a04ac5a2088e71ec10116f2cdb30e0e5cb99c8a84f569777dd60cf6f1045c4a2a4f1132e2e45aa5a829284804bfd015bdede0cd5fe4d1d66bba555408b4a538fbc144d8b7e1f6dc7e505b4471219a5c0f97646aa847a5d63dc8dd7b4bdbfd94f3ff6881fa4277a5a0f03ae05e2c1b6469270a6790b9cf430b435a30137bb16c4308990f8797fa0c8168449c827a1d9f29a2656974dc5e6035f1b773d296a7b8bd7e413a85fe60c07bbbce436a1cd0aff20956d6ecc1355ecac283c09e6918e8cd6f66fcbabaa0d43e31573e323de1e20fd61496781cf4a6bc3b7946f2afae7319c3d6cbcb7dc7a9434c23f2a1e382a348f20f2ee785417f2813e748721a777de1fcccb5f9889b96ecdfa3c92f39baba9fd9f1f9f59c4fa6c004512c0b51576025dc605f2ec3fd632861b5c60c5f46a3c1746207f34fb6205d96c63258ca757d2b528300cf24983bbfb4261a85dba44e0548d69ebd1942e4a4feca7153dfbf0d20dd70cfd4473984c4dd9c9b50c6af34f094c55467676a8ba72e207bed2e94c80b04edcad4aa427bbca419a321f2bc1958d46aef891d9b36dab76f8e6e3979fbd9ead9d32c28b8b47187cd0e5d7622e93bd2ec4de1f27b367f6a16f48a528c10db818fc8eac48b5cdc850d2858b4acb48d83fc0423833ff24cd2aa408fbe9056467f5eb1ffe707c7f86c980a9f8e8f88de0d0b8238a5d553bb6ce35457d44f6fb2212b47a85dac43312d7eb839551d58eaed52065244b550b22a346b83effe29fd8611fe6822ab561ba6f7fcd0e18103ba9ac55b6f1b976074ee3d309d198024013ee57a0b1add821107c9c498b52858247eee8f60d0d30c58fd6f991f5541c573434ce10d78ad02290d3a696d48de6a5511f32bf411a862749d82d74cb4ad53dd44fb7a80e1cb33ee3c487d730fe93a270c9d73a6896cfd973f35aa2224ecf7c8768bb81824ed53cdd82b3f33fd1925491a686a4d5b3cb91499d8dbabe8b5db0bf715b47bc17f393944703987ae07f3f82130b3056ae808382c49011387dd8616913133b81e4f5decc7226ed484e15218714ccda4e405543cad4bef5cf9001475b3cd794156a0139efbb14bf9eedd0695653954c343e11957fb3133b5c170562248f2c8a46bec653be95ae28a03f561c46c5ab0c91c753e7aba43091ac805b93f40d2c6fdd5c5f12cfc2b6368c95c314169bc0b08f30f36c5326a6808ea4b6da748abb044039afb12fad7897dfbe5842712be6c3b8c6d8fda2dd28c86e002d56afb6108e41aeb52ba9c137d19cabd02f583531067aeb9d2844cd24c2fbe9db81ee2607090112617c126a16c566cdb14f8fafc68109fece3022991400a9f93a887c15f6facfbf51040d1bd5bdbdbb5bb58027968451133b6f9c1cf4b232932aaf8313ff8f83293fb3010f23554770f82b614623e81012b25c6c2f577e8e8241d33228eb863d1aaaf6e48156f702b6c0d3b8e0df664fbcc49a4592c1ef2fc2ffc309ed6bd08476549a12b3abcdf818e9710ac37eb6697d1cf0eb40a56c6e097e31a8000334cddaeaca4a3b078b06449f317df5a8509d38452f8e927be6e94825134697ae0b8bf03d34599a239f785633ab66ae5b86f6e62a26420252f75ab20e5098f5d51692fb6b61c01f7d186e55ff5cb877792a2e8746379d72036b418784e85d17768b023ff405bf7807a02d8f07c42f9cde38070790066023fe7e0c182b8b576dc35717817a4618b3ec7fd08c1c3f46dff786be91a997690bdc0cae179b7e43f3a1fa7483637b62527c17717ae1a20a874a7803de7bd3d55361e60d8254a64b3877534219900355053ece359848d7a83c101d6c0222f6100b4414fdf637b1ae7c3ce0ff7d2af0d85ca60e792711c918396d80b9e08977a48251ab0b760b60399daf8aec7635181d3476316ddfa6a162933ab5ae58e1e56121cd70f53ce385dcdf5b689a59fedafa45d9c24e6fd28f477c0427467fa2693ee14009a293c71bc9e9cd10295abedcde8184a6862da2704084c09c9efb471d4aae7e3f994823973490df0c84b0f33eae30ec2c06a7841229ee4971cbd5ec22bb22beb3ae029bcf5b1fb2ee2f5e0e7b37e2a8c38a0b57ed131bf274e398fadf789deb5d42e7f38c88f1fab021dac800eaafc6be72d58393fcff50d69946f0fde81e506d45a62de99cf11b852afdd14c9dfcaf7d8cb9c3f3e39fee7430bd048e88d5b73b38c7fb2fb99853fd7ada72ec0a10f65114dbc9ae2b5cd4d89b1b14ba65fe85c8c92d25716eb06621345bd27618eb2fe6b1fcedab2ecc84a8067d9e354c7dc806923003fb62cdd569abeacc195f9a081ea5b8fc4f21a221454c6a8bfb07701b43cb0b73af2fd115f6fbd72746b72d6cb229db13abcded0613adf7f2f0f935fbef0342728791310bdb1d89ce8215b6ffb82369e8bf41e4820e451c2c3aa7bbed47f444cfd46673d9bf2eec15f908c8957fa95834fb36d366812d4b2b8e3d6b08c848f24e0047edfb345c2b9094df9b1106b0ba4fb1eaca0901f022aa364d411adcb452d534300363aecf8c968b6ec7deab92febf7106127d5c01ba95d2d7e3797912d6232e02b2e985583e7f0d4429c6a350ff9e5bf50e2a61fb3398edbe54b24d6235a1c6fcbbf191193646afaa71c46208fbd45968eb9b165eb097385317e7b95e71fb1349cd4bb0354d0b066cc1d187a4e7fd0c7ec501601b5a54545db72739863f96ffb49af4d55000eb702b60021a4162e8dd766384122482ebfa04c142edf79e4d746f1de779c14c9c414212f7aedb160c59e832d2d3e56726ed7cd0aa324b71f8b06e1a51583fa81d0eb73bfd4ded92870b2a674b5f54a1da22bff890d5ebf94b3f7416a14e0b757f4cc2fa6f9bc827c3f427fe94bb81fec3dd9c87abe320029a129d84709e18c622d17fb549f49401ec4f743e8cfb9292b3abd741be74ac8cb08811026859217d83ca38893c74b2bd0246762baa2d89f1d69e97fa27e51c85796608813df342cad87957d82b014ffae2e639103a62465cd164a46528b745106745333ce3329db434825b645783e1d806fcbb40c29e3b3fcc46a16eb6fedba24ea207e4cbbc392759821175536114d25ef3a86db0bddfa7482c70e19083521cf3af84434b509e240dd1c9d72b215de17e6b39b0848a24fc3f5449d8f63457621dc468a7903480abdbff830d4ca734ea1c26f236501353fe100c48874a9d217330c17088a26caba48e065d62687ebb9cdd4d3b31ce703a9a90e8f92e92456df3d7586581340ded581b419338ba65dc2c235fd5c5ea883c69892a84324405687581563fbe0305a1995038144b0a784e930c37a15b1c559c1ed8d0d9ebc2f66d212ccd90f82f04dff6b10bb4f9e50602876dada3a2a0e4b5b1df37b8fc2909fa620174e18820fa55fc5bfd57239a0d85d83e06a9c15387db0a38a5b2dc9d26edc0a387fca0c92acfbded06fe723f19fb56dc21edf7990c5a5236f3c0614657957ba5b85456f94c101f85197b500086982ba57fec4938458f48de10c4ed738acde62d4ddb8ba76d2d646d8e3f3735f24832fd6721648b379007486f1aa17b1976729d2ed9c887c1972d2978188025ca12a4f00a669e04ca9056008470422c6623929ef991488f2f5c5216d74a86288aeccd6b12b11330b33cf7fa98efa64f2394ca21c74f5856303531bcaf1339f96bae15ef563188b203ce3ac43b069045a467f25577281e387ff6950b49ddc04ce6c67e557891ed2f0a32a3f8ea0afacc776f4311095036b11d2ddb96f6d67f513496c6f0b55a3dad09c2dd7e232bb8b9c0a9f4a26cc0104fe4cf6bc32cfcaf3c90835d7b25a783fff49d707b46e33d357b233c6fb69336ebf97001b6809c90a9a75be30b1780b75b517028912aa5d0c9c4284b0ca25eac4a9e8ef9a7c2f15b2c66d6b4056ba77270af621c44cdc7e27bf52046f14ceed05a1bf2b400c33b638fd65eebbc39360a9f405721de3b734e95091220890ba397fe681117e8563e5abd1255fba79cf204ba3818f4f21a9863d0d8fd41dc968edc1dfc9c086bd07ec4de023b722b89bb5b6b7085c53e38ca1e646912d394e514be6c836068357fffce30c22573c9c1dae842421e58f03eb6883b2e934304f8209be63d72f821ebef9b108b71a5d28e0c9df44cd9c2cba6fca72e0b6609c909bb338c427ff6a14b6be4542c09ac31b16e4e21f769a863ac31e3d88c0bedc42cf53764ad98137fe38d369008dddc1b0034b47026fe93de6dc5496905f7c7a5293f05cedbd268e76931a41c4354815eb50d8b005804cab7a657ecde3574aac4d6f7925bfc368a9c976b1edb20710797b0f755255ccfe5789c7000aa5547e9da78c98c322c8fb46c940475638c425fc0f197332142654008bfb550b23ebbb7599851745b917209b969f92f26e4338087c2943ef887eec813d06de3973754a2a5ea51dc92baebfcb9a602e47a36a4cb249cdadc22888dfe167db3f6b7e12d876493a6df6728b3c6c842ec3a88ee51cd6117bf904e2eaa8e332f706f227812cbbf2297974066e27fb0610402de04bf54d259fb2d452507872d4bbeda87dc8e3594392a8dafa0cca93d3a3420871b5493715e0f77289c46a60a75382d385fbf38f88e6188e193ce4d91fe204a46adec63b94b538e5665c5e5c60069c9980450423a40bbafbfaf2de046a0b415e3238d99800b565842953eefad3d6e9eeae93d4dc94a4e66d26ea5588184c6b7c9b922108b78b297cadd1f793017171095f31b655bc635b9f0dea260a727452a9b18eb7e22817c1baf58ee1ab5d5960f4180dd7bd55086d21af02cef60859d231cf816a80290ae31f2f60eed5acfa8bbc4b458f8b09d15f09bb1dd29f2cbc0be53c736c8285b86c709cb63deca8c5bd0cfc1157f7a045fee1c8f990bd5302c9970f1ec40db49f2e7004e1a83c4702ea6b6e09adf9faf57378c7ea6654934fb43574a653913693aec6228dfbcd0b37e24c19ac8b47626e690d00e4344199ed2a520755b53d0b001b8c51a1ce4512c905b6f9ece9d05b679b191c3540fbcd468c31a55ca8cb5079d65e0e11ceeea8334aaea990e98f576a0ac1254f83da704a6ff7196529972d3af0db1bb2ea8549d2f6d1ae14fa2ae17ebd525dbecb5d8f2eb04f4d3e16e5e9e202aff235d79f71f75c73c6af417090b978258963311588ab067aa4ae8739232f0e793a9a779e015518e1f971e53430514079af9a7f281555a03e244d3b17bbdeda5beca3f9fcdbc0c09951614f97ea38b434a8b555e669193c3900402e833a13c6ef94117692edc1a20c9541df668d1618273f10c821d43be67a8d7ec8bd5cc69726834c4fe7e11687878c2195c1c9052c223065f3b144e99b193163f92a37ea2592518e78cdb0ee73c8279ed7eb3eb818d0f6193d1c15a30bc89e3534b2b81dabe05c3dd6b0c9bf2b3629549a627a388893c8996e308a5338ada1cf27c669558d960dd954589f5924e8390df57f085a6328ba0a0201bf8aea049af73be51a8d02c10b82e4f0da3af9c941310ea866925c3b6cab5bb6accb48d6b719a55ed02420bca85a1a19170708ef2412a97f21d92717e878bfd786ada80f315cfa00faa39ffa9476628d1f21765a10ef27a2b4daa026c119f3e029efbcbada3653363b16ecc9f09ce8598ed4fa564191dabebee5b423bdd3c7d8e9654b0b48db66677eafe6709f08daebfa85e8a514c5904474659f3874e50bc84a01a6979c2bc5fa14ed3a9609e3d014b3f3b917a0a09cea2205f0b4630ff6a8aec844d298d37c2783641afd2de8cff5da48ad0ae066fd70a8b829794ee2b33d0e4a030b829d1e9d30ba20de42357b59a9fc0c20e5f169842d50b438b6ac9856f6919e5051301cabc5acd98160514bdf59da018a51affde58188c9312417f7693e0d202d63adf6c6df1891c4db1719b5472587f5b71512a3144b91fc63ce04ba46d2533f6d58cbb27e0062179b4107755a55907b726aeadfb24347dc3a94ca34fb3a6b1a2fe75101adaae5f6abb7323571442fb63075448333c5da413d16cd52fe40209bdc3544d2000b41ca51be83cf867cb810b0b8633bc9070682ed5aa26e2bc88b5953e5ec8b32f6fa4bd4f220819d6bd1e27f178e95f71d9025c58fb59ea31770dcb1a40f3d2e49b580a57e28c8731166fbae63193274c9d9acea093bd0eb381d2e1fbb9fed9dbb0353da49ba2bc3fbee71cc09496782d3f9d77bb1e42a05a07546a541ee0145d5052c9a4c94ed859ca65e5a20ab6f45d353ef8616ed9596b7df3572a29555e40046ca939f936ad6b22049dfec10d96a42d823e7044b7ae7d9ff2f978ce5b598b54e1ea85f152ad98b9a44aad20cb6a2d5544912c018e94a746c0f0929b2ddfc62323f4b75787f524d061e89999169f32e292fbd20650686f5f0ed41a4b4abfc2a6f37079f77c2df026c1f40fa8230784e40387d98d6e32a331cc5e067651705c299ef06488dc5b42ca4819a93cbff1a2ea645d2969b77f724ee894fd4adc7910a693a3d46e432bbbcfd4c9703b57c4ddb680ab9e3e2d05db43dd16c302cc1afd2044339c28a2c00beab086c15ee6a1a36e0463121c7f925d09ef7b2a6e087f666770f1486fbfccbb13848d4138927ee52bc871a639edeefec3b6bda0878a7519d58da03fc5c608eb44b9b0d2a137d95e650e204a072c384c9215a22a7f39e2e32296207718f4de736980de5d68dafd54bc87d19527036a886d9ae6d63dfff72814ffa758d8634a0ee0d1def8d69d337f03d914759d236bdc0b92cabb622797872220776bd7e9e54a7ee62ce0ee69dbe2add98162e92300ebb34be4397dd0049b6d748a6ade9fee41abf2c88e742fcebd6de4bd13a859222f833a21ed801f40530074b747d74442c0e89895c9419e8ded136a74e97db2bd59b9b87eecad2a33158cc45001363e2ba72db240931cb033ade150602d79ba7accc2e3d195b08a5fb563122acf0a100c7ebc37774bb1c5ed32279aa535a005b46dd29c18b4c47fa00359223b84eaab31f05a868c374759d9fe24c08b1d45c3c943efbb1e7143d6d0093511852ebccb0ce373374a0873ad2900a5abdabac74fc27771c43a5560d39bf9ddc4e01a55ae5cdf124b3edd1b2723ceae41ba95a5dcfdd30f5b3ec902f58de4381e56be0fbe20f4f88ef742f9aaa207c1aea71e1b4e23c768c764fc98ff915694f0af99a37f44f0b651ba66876033740473f8fd447e8488d0a9ef07f5e5d5aaff6bd306da17f608440be7579578c15c292df894fb9c348e447ea3b415e2e34a25ae5a6e62afe15fd438e067ece250eda290b0290a8b31217a86d29bc4b4217ef64173ef32e7bd9bda1631d7645a5bf8e0a2f7eda0f2d664a8045c806a9fdee35775d11d5c31e8ace23bd82b50a811d53ab8a6bb52bed2b92d3b75d1ded8a8ebcc2adc6da480436c9d7464763b67f448f7b8b45bd9e0b43dee3d773eddfb87034664799fabde3db5ce135674d97e23dbb09ece5195bc0b1090c6dee000d69e735dd03b2478c8105398df06124105e0472c68d74a40b2e1b840d7f5ee6efba79da539057898f6e2053aecd02472d540d8896fb717a3ef314fa8be42816288241106895058a3eb4384b5dfede95d69a4fe88ebd74f9eb495e5fa5c1bcd245e94b407da207e698ab6dbb3745382e6d63245c41f8bb68a2242b7336293df16281c89d6ac5c3a156c808fc276ad69f8120bf095ab2562ca1ab4eddc9fc37da1c483523465c378a8fe144ff5ecdb59cada100e9d11d58afc48f9ace17d81d4c0ad48bb88b920d3b8010b57b1f31f1ae3458a351abff2c44dd2b3df94da107e3ece2a1e6f66fabef7a699a56f676b3ed99f093c0abe4c25218d7656173bc57fb14c7456b538287ba7da35adc1ebd51e889d65c7f085d0a25292d34d44fe07147d440246844b1a02e11d1db331472bd31ad550d15ae78b970fb7897ea1aa1e2e3369fa5d9cb076c4115ad3da8c4e2391b3f79427f36f65ad33a6482f7f3263540fa71ea145060d0ec82afbc47f130b0407c25093522ba3580affc49f4d2572667dff56dc911f63a3f1dc72d450ad1a502a383a90797555f85df02b350e0b9ca1c15554bde2561401075953fdd22a8fe8c1259af27d47f7d127f489128d04c6b9328f066770e6ce73419d926311a6c8f37dcb5c6517f08ac5c55ac5e39d08f016b205e5a2928a90c07521669e1c3be112e9b8c7dfb555d2b3e30ea6f49feac724b3bedf87a6ba7dab60ef812374d5f3bd792fc64990507350c5d64ee7ffe5df3f18562fe9688ef898524bce0bbe794c45e0ecdffec8c9f7bcac14875a2dc7425e7bcb37df40c1a918892422d9298005b49ed8858a5f10983f4a84bbdf319532bfe74aad0b9d43de6feed54685f98a80142b944bdfdda5d7a76183b7b219412d622031074698ffd7029af3aaff856308bcbd4fccdc3c9b300f5419ade13c31a6111c57c185fd460d18c8ec15c229ab2e0b19acec36d09d4a5d8d3bd2d111119a4f303d81c3948464828b17df130ea2f05b4ef00e75f914a4d539408951211369cb81351d867fdf8bd788861436c14a7ca3d6b4db78218cc162f60db5e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
