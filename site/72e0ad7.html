<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73d13bf86f8241e73580bf2d1391209d9669f47b9a87a9b83f52093e0bcbe106e328bd8d8436f4a268eaf273ada648aec06b44dc1e9b7204fa2a24a0fbdfe67916bcd88700ede0b20d15d46622a1fe33113313868a83902a175c9a3fc5f658e6c64bcefe5f97d1ced5eb86b30d51968a35c288af238b01455490fd15b58e00b19d6b7ef949c4b89620b9d7700b2a2812d004937eab6385b415ddf210b1593b1afe1d8000e54dfee67c768efb8717bc2e0f6a07c61d6f5acd964656ac178691d59f739906237ea92730d67473b3b98b0e51c196c7de6e665ff02e917d124514e3e3b5178d8c17f38964e0ccc26ee9ec076db821f1da2a6cf4de0e468a2fa991cadf80d4d1638b8cb9032facedcd7707324c2f4de9be5283e79f21f4bad8a92ad799c3f3a621c279e1ff5ce6ade3475fb0661f0cb9d7533c16350d08ca9c1ce7b42e9841b39e02b2fb6c465226cb6a46bd66ba01865d091c6683dbb7ac25aecdcac8b4f39fd5f5c2b1530f36b5b8dc272fe1fde6c369ecc4dea32b83629aa8aa8c5e3fae425cd39af20b730c479d598dcd870c2e35d66106f584c4080c54ef69e9e11e701cf0157e6f44deef979d7721805346f08bf4ba208ff463d4ad8a2d7dd25bc009768f77559705cbce373a4807d167a280b70653b8fad69dd8fba4425e8ffae0a61be9b5535e86a56f41de4ed38d7386c4888234567cb9307fe0f49ab41c05cf95caab655dcd87ba6728f7c98426acf28719e4223aab0f903d8281bb6272c1db6550cb6c60bbe0871c1cb3097c17102967502a3d00f94d9dc68a79e2c34eb2e377e70a4dc5f026e6f9581341469d1078eaf5906f05a8c5455ab020900953593532a98f276218428629742a9232c6e27f89baf945d7f363513f9a76c0ed1a2103e96c22400444d65ad24a9f05b04e24b823dc084d252e929acc81f6d5885874dbccaa6493a9b2b26370007c770b17a5c5d54ab6442bc6037a7f389c0931cca3e28d21d4e438ad41d7f745eeb79dbc04c8946259bf8e22b2deae67023f0acec72b86f57b11bbc08d3a8c37943d572fc291319ea2a21d6899d54f6f3d5d6c48a1f33f5774b5e69926e51d0f26e295c2ce597a13e732ee46a1edba6dcc2285e670f466b7465193d695507c5a034fc41b89c4be96680d028823c50bd952502b5cedcff48cfa07ba483714a88ca0549c871f0cbe0319db69dabd17e1fcc15350dc783197bb5319518948190f9d233bca01877c2d0aa8e727834a29685a103fae8259cec4b0793c3b13e98841d94a8817c83890ad7c6bf3ccb91f28447c8290b27b88dc69d6b3cf117ce8469dd3467678f2723799d5b8e6b728d0e02a3c6164eaa380e8fe13f8269dd1d7f143cb2df3607e59de0e5bf47ee9e07fccc208e4369c1e5ddb8ef0378d5c6a74c7670c3530dfe941c5440238751ff17ce7a32265fe982017f5f87e801ff643abbd634c7fb04e774b42fe7984230b4af6938d90979bdcd1361d879273a434240028d232f9857ed7872066de6e60ab9835df662ddff3d2c877bb57fefaad28a81969a38d96e4dcc946af2869aa806a53f70f213acb2976dd3486b1bce2a80b2c7742e97d42ae2254fb965eb246af2672438d91a7dede052047864991c5e0c879e91a9464e27ba6d7206f6e5ef4d6efee68e77602ad9118b0f1e092c8ad2f093c943a4bb6ffeaf203f57d5b2f9dd3d767b11dc2f103a33993ce1edf309a40eeb7b4c6cd9d732d25f5c0204418e258b9cb3937077083f8da6733977ca0ce5b6a55665b3d24dcca881c4964a9b92289c87db6c32c72078454466f860d5bbaf5134478aad34a91eac0a2474561fd3e73430f2f0fe5caa99aa38f05eeffe51de24c62a1f1e23460b51988232fbb4a2787d4cc23a99222e919f072f3c05d9248ac25923d2b04a75c76472cf25c141beb699e71e7e83971bd9c1a137bdfadb5b820b626a2fc14b6820c20e5bad845729cf0e7b9e42c7bdeb86541334fdab4c224e1a7513592ce10c671dc7d6dd5f2382ecdca1e6b8647fdb502ef2ca5901cb973ba114d0173ba37369781180685370ad1553e638176371b247610fd0fbbf1b3023d979bb4975ea61919b9b749c1b39b0f4c8d80f582fae4ca50da2c36cb7c63054b587a98eb2c0013db9bdb23072cb7e07d9be1e5640ae82b1b6423fda492cb88c9bc485ecc647831266d75733827927e5b6efa9eca3dd68704b49ca3dadca3a2b05276746ced5c119030ced183bf8b5ce2b64f22e1d9569bb405d5536971f8a833e039e0c237c52a40526aecf521cc8ef7261f243ae89a47cfff41e276dac28abf320b73c80feec6daf1b449d06d14f4f304cbb932101c73aed664d3369d37d7c63f4cef077b67d83e1955fd11907ae5eb0e27320459961e96e88850116db61003ee3db666bb36e435c547df037144d6ec813059a7fc319adf5eaa64abe8a5e69fee6d24dd5be4c09f89b240b10468c46bf7e5077abbf1d69fd19fe165204f354d97dfff2b2b434fbf1ff8dbbb322dfa4bccebba97d033ae32b99006fbd36b15cfadfdef20ac42a081dc7f547c164ee46e1f6c59adda3a0d7502715c5f6497f8671afccb9d44c1c94318bf7fdf8d8e8de5085ea2aad21358c8832f403caf415e1a5c67edccf24ab467e9b5933ae7122b4a16bd97be746045afd43e4e462744c25ab6cd856885b97b01983a13c29baa0185304459c9894461da9ded78f497421d0576298762b0922b302e2a966bf3bcf0a4b30bae9728dd916c79c7199e1ad70932e60533ff23873fddce29e89476e8bf21638b1edda7828faefedf9ad29995f6a26b5c380974639e34033e650c4fb4a113a047a5e590b2137fb3dc6d81ab6d8f93f9a1b3f5a53d4b8badf9d6aa6f62c542926d1dd7d2d6f393e515748b142fcc37249e281adf1aad0588292111dfe1469da693d78b316dfa344e99d37b92f6fa6a8536dae1a9e52c822ee706b2285a3cd44abac8d3490714c809910d3749191c226cfe1da747671ebf0a787a8adf6180d7051dd783fc924a425c38de1856cc37a3535d75a980c8d745aa402793158b84cb9309d00af476904d8aebf60a2a12b98322e0c0f9d45fc848c21fb097ed987638a4f59726ea701291f79ad02e8bc1e8f39799ac47bb316cc3ae8e225109a260d1638e4296679238a1a22f2430ab97928f327bc70622d440ac026994db4d51307b0027c441a97bea4fbb34fae85fa77ad8453d091787145ed917c6146f3b5b296b24382cbf22345aa098a3a32ea908537f8561dc140c153677ab7762e96c40782aed65788db1accfaad1953224d4e3fe1524a7542bd0c96fac9fecc4b48fc6b9e0a170a3c07ba907944ce4406abd2279fb0a021c2955ef01b19eb72397c8d728b104993d2c9882939bbf547a060271a4cc847a37474e64bb18b75b6ebf4fb4abf6c69e2e8ce9c761b266f17c17cc2005f41340e04f06d817d30f2286649f2b23e36713e00b3f861a774d5c6331440ca1807aa9f0af2286d9fbd08fc8c57ce2e4f5f5f5283b478a4487661234274236913c1ef5bad454d5e3abd6f8708acb3996a2113918917cf56f436483b7a3336eec234b69964a8eae08c3eafd143bf0429dc74a792a47cd5a419879fd82ef553b7888cdc1991de74fe8e7609038331f6942ebbcc55529afcb853ade8ee3f9ca8b80697ee4efb0a5af35323bcaef0f669fbc472d2245103ac22ed90ddd926f7a65bf829bbfd180ed51d69f4caf7b13acd09e1cea42bf2ecbcb25b3896b0fb671df980a1a76c8173cb29dab3b6c73ad87aef2c9ef6553c90007ffd94d210e13910bb33c8528ae83e0487d08371b38521e9c24e7b6e6f492ed80047f3e5aa7994404371ca157c8a1c546768ca8d250a72182b5bd55f872e74dd3b25170a6cac118aa167a36f9351762c7b2a6e5f462ee8f1891465c8df1b751c80deda2da19073d50b89197fe117e040a3e88b8a5b1d49752346f19ea56b811f5baa30c6c18ce50f1b357443358b31c12e3415dd188c10cba1b3e2b800c012f38c5c040adf29f43281276438a69ff1d1e34b02edbeaa149d6fb7a986b3f6b8671d79fc140b081350b5e854f8cfb208a26dd331ff8a6cde232b9d4cff6efe3f7ae1e5f6adc752ff1c305a437fc0f2236c4b9a853450d463e35a0c92797da7403d3e2e0bea6f9e7f1d08868ea53ebbca340ddead291d8630d31722edd5a9ab7f92f5c3ebc7583c5c9924ae8cabf62fe25dc164e174d1d07c0088305f56382e982bfd19bde7f22025222f0a1acb3116398c529f4a52fc23d9034d36b984d0134c495bb3bef6a0306c7b6783f5613f4c990b76716fbd9e7924171d1b2105026bbdd6889491140c9572fba8cc5a52acbd311b10cee46cb23b08ad4c702f4e2d6dd005ea9a466ee432d5e241edd3c458f96339d998179d8076b429d76ce0d04b8d4f88f88e19b2ffd7bf81f7b5be6c007e0fe1123e0d569a22357f0d69cf4e8329bf72d7e1bc60edcd8c082b9d3a39331fe85413b2096f6b7939ff944fd92e0496d526ba94b5e7b5438c6ca583aa5298b6f7c3b183bc747fd862a5668e97711aea8bfb1abea689a18c63e4466903ae5adcaf68d9edfd9a8d43e3ea20ac159f83c69c7be4c009a24ef2babb48af6d30e705b57e210f794a0b9ec682ff6de96fa3c47f310e228f4a277807cfdf9ea720870e2963f6278bc2ee792765300c72773262f5868866ed6d6fafa55783bb48f093e529e15fd0fd7e78627fc671af940143c4b615fa2dd26791628ee54980c0ee7c63283eaa263b2ac0ac0d787685689c2572a86f8f130d451ae157672e67b977833b7d9851b20a0c321108bc1ae77b4837faf4400776d7a25fd74d1ec6a1ddb72676c05460ceb3fb5b2f92f564d8498fc843748db87b451f44140d5d8457e0fdfc693b3ef50e4ab6caaf675256c762cbb722e8f0e02a7ffb900f7564fe2db1e43039388364be0377dd845f117d24256950b621cb3882f74f640e019d6ab5f8f2eab50b27bad03bb19dbde4aa447ffda7458ff1bac51c34b242c6db1ad06788f551788c28d01dfde79e8a7df866ce7bc01070aa73a532b8b8bedb2b9b972dbd55783ba161bd90119e1bcbb8ecccc204715eb895e527a1fd17b507195cf27e69115ebafba366d1a032a55661e6988e219d1770747c5a8e6549750fa21cd5383fcd28384c404e2024c85491c9fa32a94285e3b7dce418f93d19f6643752cdef89df1cd21f589f7c7dbf3b2a276d8252021af0bf564deee455287b68535ee734731cc9f585baf417afc7581f31555362cf0bdb57fcb56457c56ad3a4d3a8c087155dce468547d5e948308f8ab9835cb9b9c37234c2f09dd6e4568aaec29df8240112a3b7a49111e1898abb99e1de60430326a9377d8f10246c1cd87d454204620b611552ca8e20d63737afe3aad824816e84f348f309b65ff3c473d41b07e8960e84ddc8d6ba8ed98f51de6ca4e190b12baf419a748324b31e7cbd61b9c222fc7897d826d9c136e198749c4b2b5a4210d1509d36280e99b0da054d863f8b0f4313c0f778e660492bec4ff8efb3abb07f4e62d487fc3565b1f490df21f1efc730d4cad4fb374d3ab899ba837814b99de13d8a3d64fc40259ac7fa0a2c809f83b1699318632332e3f12ccdd6ddbac7aed0e3014f77d123c337df9856093ae48074fa962256b0c6e56c8879279c3584c912b9af3d4f3a78d1ec618c85d8bab26fa1aee7d7dd9332fda6d2d51eabb41342ab99087361b1775012da1cfbf61042c7cd69a989ed91dbc7c76c4ff8e33da500fe855c8d3d9e8e62e8679e5c3691f222e35ed90f2357eec6f03cd74a373c57f6d53c1d547cf4da688767dff8b60c5fd4c4243e631453440b22324cdcfe2f67db31a41cd4acc0102300f2c9a1e19f883d3b75b52bc34e4daae09f21f78a711f60c8e18e2c964e90aa7a1dd431245207347a2d64659c4edc8fd5260e3422631511bf3a7f9ddae6ff96fada03ac46754db715a4dfd3e74349aba8adaf4ab82a6c807345c1880c25b995f52de9693453084e879f62d792b98586e6bcb249bce071dfd23e5c0b2ac99ef851f67fe0d5e0aeba1f6aab011bd8da4ccf935a2b8b4642dcff929c55f750e66a1903d4499150378932b2b24dba1eb4e1b34f6342d1f314a711506c2972ea01eb8d7e722e2ae213ba3f877b3aad8e226dc17b3b233dc8752ae0a54acaaffd6071cd73cfa779745a587a87b6727d422b51250948fa70a6ea48e4a01bae6164eb0eae16d9bc54c001112dfe86fbee23d589eb0e3de7ee7e32afeb2543361e3d3242828661aabb8b1d7bea3033cc7a8526f299dde1d9084f203b55a89f07011e85b773e5ea373675ebeabf991cf482614f9f687cce1cea67918df9cc28b2faf976bea81f1adfc1f5ebbc00406208efeee7f24ec9b447bdfbc301602065ffe4dc3a6a81e6089b59f1d7448f750ac29c1321ce0a03603d92815a2470d05079f827b0686cb8cd593ba86dacab3b28d07bb190324112f1f90168c4b5fd6881c4726ef080bd5355fb01d60a9b8808482525cb660428ea0baac7f8bd165d9b2151a299ca8417270dda6affc28f470d9667e77d828a36e2ea9fc4d7abac1369741f88f32f47f6c496981cef9c4aa7046394e06a5901ee2923ce98b449ef1876960ab8144dcef8aad2352718f8d6d6cfe78530b29d29dc819361a91d2b2032c38f90edf0dd0a5b43ac21fa61eb658af320451056077e55e6f8772cd700db1cd64ad387df7d7ea430114624064588cb6dbbce816f3cac9e7a8f86fb7fa8642849a0c2bf677c863ea8ba958b0ac6e7b8594b8396fa8ac0de513dd7f80a38f789fa66c8025e3a805d13c5ce0497d6808cdd923483e1e54fd7eba9e89196e42db35185537504eae6acc6ff115cee6f36d1fc769b92461bbb1ee4a3e428fff35835f16a74a19a4a0d925a255b609df91a354ed9c9ba7569a7d2635827629303d07204886a84283023d82f6c6ee9b2e5532fb3458ac0e3d0f49d221ceca64b21e9ae48020fa557675db03bbd732aabf261cbd0ced7c9ecdcd2463af4b32861e5a0bf2cfe7df40b9291ffe9816c0191c48fe333a4a6f7dfd91e55aabd7a8975eecd2f4c3a9b80466034ec05d99fe07e8f01057c5c0bdb44774f2b6451abdab12aef34facd9a142ff3ea9e49e39864de1688204f897787b43b4e59d3a8167db24f917577df948a1c743402525260451ca0b09be001ef7c87bbf482fb10af563e478b641ce09b1881c083e62ba88cbb16e637ab5762365d70a71959ab7515c6bfe487eca04e62683ea0737aa17bea96d358733765ee37fe932e1e4f860c6717afe865c34ba1feed2bc7554c2c2f8928ae1451bd646835c3da2d3ab5c2a8b9c506d61d0e0cecd6e1e0334c060f210631740c6fcffe1544f7532aa0b13a1e1be3a29547136006c2dec9a403c8e0ac66ed7795b0986dc1a8691f353f769e2185fad3d3101a6908448e50b918becbae3110c4e8876e413883ddd5d5dae73a787e7f77b2da09721e323abd1858fc2fc5c5d468cee3dee0d243899c43eab3b0f06d55fc58cc591c4d99a3d47b1e913ede30faecc0c1a567425c2ff5622ea7051c2ae08aef04ebd2575983d0e5d7d454f1eb1d64707cecc9089137ff56abb6066b48a3b3bbf713af2a6ac9451b80b2c2321e7be6150e69d52d43be1b67ae0ac93c3bda5931506439d80604455dde2d7e6387d8db8d6859627da5bdde27648782012a24d8c6e6cc59a791a43229db784faad5d6575ff2eb67daa9bc7c6070a805e4147f416593df295d52e2aba02a237f64e2e6c67eff83da6e690868e8a9576bf77454504d262d647468393825970f64afb5cae42c30d0979cbfd5861aad5a7b18a3da7c258fbcef4a8f205dac54e4d983f1f88df2b88a53ade4cb0f6918e44bd43a3d85b9c340ae8e78109c34fec1ab0c47f5eca74d2323b6075ebaa80fdbf8bf5b3cb35715c0d27a26c7ecfcf20ff1a947d1426ae994b0595fa986b82af3ede50b5a1659f5a8e7fdf3811e3fbdd5bf8b1f5ba7b737728fe7248833083c9902dbd5326d53c646ccd29aac128feaef3813e74dcd5ee9117ff53beab37a76cae577f758a9e6b06d3c2b7256fa022b526cad3da75501a5bbb7cd9f7f8438ede5974b330ba4e98cc740d9d233322c9389a7556cf615e34c2304262a51eaaa50865af2599f47287cdcb9ff9406add79f78b2d6448cff5bda304933e814e4537f86b508193d3762a912c7d69843c4fb483ba02ca50cab86c805864f89bde73c879597b86b3def6a59f65f435c75abedfc7b57bd5e140c8da1a6ec7a2516fc32a3ea534e10885d23fdf03bc3a270883696f813359134af154d07d1c0abc2abfa7eaa11fbb8ad62b490661316de310dea3bdc99d2512c04f441358580bc0a3bcda3222da74c08f9324e01a7a36b8009eb82161d9d9ee22deedb4aadf67cc3919b85b615bab22d6b1253b1386ecfcaf976df17d2ad78b938b532908e22779da25853c24045927fa9fec1884dbaccb4fee5ea977c0baac7ba03e344dbff62f86aa454696a2eb462d5c5cfe63d2442e22c8c670bcd11f012486b0a55bf20e08a16d01833bd91427733ebf63dd76ca11fb24043e79d6ce0ef0a568e58c404d8a099296d7fc7108cf897c99f44cbab705562c8983ad8bd950537050ddd690c58ed4372c37e238c149cafba51287cf9066f1b28b3579bc1d33b4fbbd123e1416743017c1c86145ce8805fb6333a4fd9cd608cde7377ab7a8c2fc96a4f348d522e05fe06549d22efc88c10e731a42a8af1ca1153b0d81955d9c3f9dc1d7cb8c0e3726c2fe6661be3cc16b87856e261ca6e7ec0a5071366989a427faad912f5446bee80d377a71bf3d9350f54f13dd2ca6e3859801da4796f4ed2b63787ffcab8a4b0d5168482284d517df5a38618d3ad282913af8c130cf157e1cb40e7d6616f7c86c58a57fff4fec86b068077ce75752a81fd4322c76e15e29cd15897d28eb2239bae85b6985261672eba69d35fd27fedc505b9dbf295adefa2f3a563b1b0485bb591e74ca3923536a2676b6f929b0c566b785942919261ed219209108e780749483ff50d0b008d9d29890d2505d2a44b3ef76a24b302814e320c09f36c08ded46f5b4e7a71692c4bc227d90e2de53089efadeb5523d49c4e982e771e5f936a7531c3984359f9e500857013381c22b7fa896b558f96108e843e2730dd6bde0767373fe95a9fb2dc44e98c2a2c10ff493cae951d915ea7135221c00c7619a81a04f693197b88e14da3b68412c1d26a715ee227b7cd30ac9c651fa69d125f41849469eefa93be9a850aeecc3adb2a4a5859e693fbb51bacaab1956769fdf2cb6ace28f70221665fe2dd46b2f04c4902531d277c88e25ea266384b622b5faa64624ddc99eda71f2203ac9bfc8947509ced9ab6ee49cf035fc8ddcf1e7cb6a7d56947c4a24fdfc67a87ff950aea93605c473b151d777e457e7847a81c893a90e1f0780ac36fb3e1a1b623a61db4be13390eb9f15eea4c6511481208342ccdba223eb07c0cfe33335e879fce6e289fb744e985dace1246848141cdc00d45f2e5a7ebdbb485287885f6d8bc5deed3409968096887fbda7605bf39bba26e7a53bc7cbada2cadde5aebfe1a6ba2c3a591b1e776674cd4cb8159239d324f242cf0d9419df204bc8329adb13eecc44a2adb1a22b77d4e6b321325dd8845e520c5cef3e93f0804d0e6d23e2505226d6a9c9603cc2473d12f3301e0cd8d2a5c392832ce8895737024f581b91cbec62de4694dc4fae19f0598bc9ad82371b4e5950ce818f4740fd37e09652166b9a7986488531c0a0c183738a984a6b42e522d309e5210451037b400479419d20475187af26be195cc78a4347d5b92dcd125baac6ee4120ca875ebddf5a9296e87fa8e1a851834d5125140414c7c3089d96a4ffaa4fed1a37ffd2254fee85669b33750dd27504c79de20d4a80a3c29b12baeafca7408af217e2ffbd1bca5f00160f830618ce4a48a1938b197600aa7ee333801ebaa68be83ba5f00ee81ee919fa2a499eef4f9accb1e29f6330162edf9bc8196337a843cef18c1a238a63b0c36d8873c5a9f4ea276a90f81ca6bdc9c518f50eb3508b0d5502057bc0cb1ad383ff40e2cad96f7ce9642e8b1f223f86179eaa3495319735d601577c692dcb993a7993634fc34540738bb4f5dc6eaf11cc3ff81965fd61ad0342c5c6abbb539b7c2779a9ac4abea5ccf0ee51ffa664372b819539e778e45095a0c031cfe7bd15ca010a16519d7acd37dde351aea13fab147ae3db89ce62eacb2b8c427f579b85db69e1c06e8d0a3c8550a04cae245b75f6c8cf2605d152eb563176acb6ad88f6021c9862a67192a62ec60f96378d35bb6ce9cfdf0963661247dc32fc015ef894e60c30a114e2df1e466269cb8eb358e9ce9f54759b727f9d1883a75e7777b0c915225bb168835a59a24b502ad42f3524d10ab0bd09224318dab268ca3fc7197a06aa03e4765f3ea53f8f90e6f27b9ba3bd87eb085d9c9e70195b3522bfde7f6e97be7f9c4af8ebf35d957051fa3d22c3e585afd73f80456037f1a572a0eba1face860ef099841de411e21daa734ace0e61b38b1dce359f82a5ce82c740eaabc7d3cab9a8664523327254a0bcf518089eac355c8264d14a254be8663b39f25e5690f2e88e4014e69b5b389188ef9c94cd1c9825230b65ea7b65d39289c06267438e45ec8261d91f46dfefd59ec53ee0aff99ea6b66e0117576b5c3dc7f078daa5e8e014a3c4e2898e7a4d4915377906d25d3262f9078e461a0f592bf8e7c603f3845a2382a470978715fd78f9ccda870474b602c46b1772468189ed473724424623ae9d3111f65d80a43966462b53677da5ee1855d6593745283c1efceae01ce2f9bdbccd8225d9f252999a3b0087841cc035d22ac360f6192ece59efa6a4fe6a4bdafa86015c100e9ab0e64b2d78935bc0fc7dd299cc0129e9621dd1b316801d460d6f32cb7da85aa55141add6578ccf7d5e06957355e2c3aeafc007ee5cc97d629d33a653b6cff39f30eaedb81c1b8eec243bb3a0d4d5293613d007930d081aa92c47f0c70472c6053925ea87e45c1868de1aace7b28aabd872ecc996ec5c56118e136db44f6faf855f51dbce871df5e70560e74f5dae165c61b3ef24326ca51a5b4c358774fe4b243c3554a4276d0aa93bec2203691ff003240ee4fe4004c0e7f5730d97022380f226441766fd604e6f3fca0b63304f2e02fb6d6d5126b1950f1e958bcd5068456adefd00df7a21808174e3de8105205a51d916a84ff3b7d9bddae98fc74a5f9fbaa57432edd5f3c440e9b778469dca9e1885fde31f7b213970568a3ff9cbe170944b0485f7e4921578a45ac824c70fea5d174423036607f46edaa174d452e2741425818af280d2789165d45db8adebf967d0d74e54e75560397f994e44a79011a71599f96ea2cd4af4d0c52aa302ff35089377ff704e7cb43799434cc3067af006b69d5d67c637bc9592796ff3804aecc742d6c4c63d62c89e3b0f885fb29b54d7439a2968c24df2019a240645d5a4ec1ee6464d0d443ca5fcf7ae622559417cf0e2d83b15c3aff507432e3b649a650c30d04ca61bf83318c7e56241434ef0d7a562eca6097bf628e579f52046924f5afcb01d2dd2cde814470f48e7773a61843dd4fa8d19285681509d2830f36f05df539920da731f6ce512e5d0705143472fef19a21362e2f7e4bc966d021016ccd0183706e19f985930c9b173d5c08c8a031ab8eba97292b5191e240d3b7c1bb3dc09858fec1c73a14ffcb0f65a63fd28d37cc4199794aee09203ec653b23b218a5fe3ce61b07a5fd66cde61c772fa8dab956d003a81c4437d888b20f168be37a6e7178236628286e626c8e3ce3cd59907ce719fe5241c328c33f61217e09630078b7b618a0256bd62bda93a07d0afcce974dea4b761945ac1f5713ee181068603aa9c3a00ff11a26deb2943670ed685f27334b46a91798e6837d2ff2f731a74dfe2fe7bd7d3622507efc8b7c15198fcc346a542bbcab2fe04fa0e4a18020752def7b0204804939614398990401deb2761b8d11241bdd27d4d9c43e87c7e63a77c598f0b9b1fe20ba3fca104bb53bee0ebc0da81c8b5e335ee8a599d9a0a980df55ca968ee43163a7f4492488fdf0e3ea7798e9ddafdc1fc69677768edbdf8777b3558296b342caa569c9b878e7c13c3043abdbb320218b5ac0243f15effaf7264b1e0c268acaa4ddf38a9f0cc01732b163256e55917d0a62e41dd26e8ec2a2a6efa0bbd6bdb91937d631ce9246ba6ea6bcefefa5f8266f2bbe614abd5cc83dc33ce5765fea557d6e123d2fd9b37ce058e16e5c6749c6bfa3b6f248d0d954a7da4d090b0d9ebd6cb6966bb14b15ac038e83b68de28212cee609f96f2c5006b3af8baa7cb8da86f1e2286b5b20414beed56d2c9ca565ab4e069e5f8462268af76ecded449a0c0233fd5574b39e10627f8fd486490d94cfd774cb62484ab87cc2d939898d7e2ce7413cf77bb68f5c70cdb2b844646ba5ab99fde13557c34824bab6d7c6ab192d55e5f609c9d6b43174367036266b48de44a3aaaa11d4a2797bd8e7e12331122d0a1d3d7503e32e37b661df696351e67db769674deeea1f1bc8a298fcdbb5f167d39a122b3621c70fea54af4f53fa934e0705cbb32501b1f82830b0b06f4ff4f674cebfffe53974da9c953761cdaa11d89765fa3cce483cefad58f70866366f339c1ce557c600d10b4ec8ad851ae2650e5cad9541fdc2e34a5d2e86e0183e7f624168ccee42ad6fd28697c95ae99bc32f1f9d6507d738c7659f20c81793d628a3c234fcbbb73ccecdf67bcbd28bdceb8c77437977690f916d04dd3127b21c4854888eea21e4951fe4c885c60698b05798a40ed0eb6661183ad8a789895a9aa8a6e534af296a4fca32685cbf1f59128cb6abafdfd760f95ac3951998601950c5a89d162b0489b47150f8a27263c4128a2a692cfe4f44ca2ac2cd84d59f2223215b244ed4cc450f5b8e2b7a77f0ce8a926c5ca7988186a73cabda566d96e9553770a71cee4be5f82979394ce8f5a775dea2e80a4ba83137324f1789c76b8daa326488daf2dcc818a0ad55da4357ca01da5106bb41269a3ad6b4d6a5b66287fc20f1f80f3b8aa0c559","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
