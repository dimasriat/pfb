<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13b0db7acf3e19fcc7db59c001e1bd1d0d5d272f09155401657355c3801655982e4c35e16aa9181f408dc14d05ec60817de4e3d96e3f0e510ef7a88b36789040da0e23ad98872dba5fce10a09d9dd824ab44e5abf552c0bbe5c2d3422c4fc9f46800781983b5a4daec1ecaeb5ac3deb93adbf721903dd391d3e38db09da77c1d2aa0e9fbf287da4eb0126e822f64b6e6fc0603f27b3546e930722971b364834ad1029136f37f2844ce79c72ba4acda3d832898ecb58fb93acfb0c988f618932088fc151570c6c98dc9deb17fae5e193ec887573182f7de6b733e40ce7166f8505e222bee9c7f0b4744fdbdfbd468533474bea28cf68b90d17f3f8a861fb36f5009890b3aa52ed3af851443947acbbecb227eb6d03776975b939080eba84c5ba64932c850e26b583a8dc7290a8027fc2ac7a33ec8553366bbde795b0406b71ae58c957d3a9b6c9e77d9a0da2050e4581de30a70426b7e8ccf9b227688b12245f3f94a309e4407f87b225ede83056e3a56fb84c6d2983259c52ffa8d03f19a2f6be76568a4f0335b170f8abc8764d94464ebe565598098acc3660c959ed9b0226f4f8dddaab36ebc6d861f9bf849825c0bdb1904820ea0798ca115acd105619aef63ec006c905b132256b455c12c19203f8f2239e46c6552d89881d8a45d23b8fc083f62a6abc5ec215ee900ed0c48e5299b1fcf264cce4b118c42c5c49c96232d000cf89b3ec19954fca245169d45f620dd798d3a976f4da91567e52ed8b54c23d3f45383e609de1dfc76786eedae6557981dd09f0d2add875ac575e168f053fe7e8b736d65a42a9c13d0c42c3cd600ee6002ecf39749b36bcfe748667ea4647148397fe7e5640262d2b59cf44a5d6982f56d4571b66671d5afabdcba18b2fd7b274520f672983db42b915f12ea3ca06f26e423ce72dab4df37097efdefb99ad169301634ed70c849bca62a39c10f79f109a914e13e3046250042ed488312c4f2efc0139697e986d33f9fd99cca1555a482b0e2d8185cbf21b1bb80e274e517e3dab2f43ad9663e747d405e64257e5c9415730c449c4fdd5c63cd0d52a977a616876d889d48fc2617a33073d8ee31afa7cf827978b1740c39b6b26fce008b07d405cdebf4e91207ff67490feb7bcad2f95827fb8efa019f67a90a4945549337c4120dd8688395c38d5ff43f208d0b5740e52b0cfda835cf4388e58ce0fb549d2ec2a620b5d4404e6d00b2151c6fd61d050e19fe1780582064e2ed721fa0c18c8e70c101fe92a0b269510244c1b80d1af2cb029ec21dc4f0d697c5981a798e8c85cfcce3b2043ff6abe081ba900029433db0c7c497eedac50be0e7f6b75627a100a63eb6574bbae82ba004f0e2f2f5bdeca17f9686f027b990afb3d26888bbf466d98099be5c078d3184556d6e39bd6f742a9967737f2bec42b58d542a9c4bdcf6372117ed863e83bdcba3f9d6b07a51771c10367ab139d6bb6de33e03c0eb2c9ab355b19de38bb9d0828e7fb0b6288811e15e420d95ac11021594869ed96b8a0dbfcbebf2441923e62dd894998e1304920cb5e5623352a5143fc88b76bac627b6a77be88dfc23555ad082e3d9c5e5e1eb21c57ceb899072332b65219fc97eb358139cc5e138bc83dbf73740e80e78c210df7f8d58a533095eb5cb439078e32aa97f8bbff8ea8e542dd7252b553c6521f0a69a834e9140686dffa09fa9961c336a20ffcfe8e119ab5af78c838b5eb311eebce7779e9ffa1adf4f1bc9db84678c799279858562248e48ab09022ef147c6567d87620caa07957b4429aa1c85b83c66c76acbfb37a49008caca065414e7b6095f1f7fedcb2050fe621843622c90240cdad659abcd8f1519342122caad208ff89eece1b08104bd569d4c769432a47b39718b3392b9657d2bdf0ad89fd8a7ab7292b7c22b0817f73ef9c1d5b70a1210f9dc5484cf9a8b5abc9e9e110ee33473b2d292a1e057515263a04464edca6eec255a8519d994d90831dcff2426b86eedea20503f0464cd85072d6e538ef95a04720fdb69e9b3a3ff75a58b3255b99fa4d973ae2e6ffbc0f9dfb89d4b50cc7de6e6442f70711481c886b9ad85160dbac736afc243a158089a12ae61c2984e6417ef512d3effc1c6ef16f5958998bd2c8744fb7afd4a145124dcec53da2a362e72f8f2ab8ff1b1d462c12c3953a3a6b5292b6c471490efec59fd0ea0b6ef7ee128f413ac08311760b936fc72b7390b40f1d97d43cf738121924ff352e9943671f29ad068b390e04a7c60635be4c7803ce17b55369e20d98895c6258cd5484eacad9a4e87b639dcbd51e9995a3582a5cd0070a6b809777568b9c7f25b0ff3cfd44788e9ce2312102ab7e207ed8345b87f6b17b99c4d91e16fb9949535bb49400bb502b08caef920b6c11f1d1ac2f9fea67aa9b443a51a92a28358fe3cbc45523df8d256e78baf4746aae189a3f738fb85af3ac5f0fb78a237199f8ac69e255723c609697b20f6b461f5134e51dbb32370e0c17a144468647a0b245daf8daf9b594c74c4eca89140c1b3a6ffe097334bffcf569e5e8fbae88c77ba6a08572976062a4302930af1736866137a245bf6c7867ca5fb6e031f1caa5f05b6644cc6cd513314f9ba0e69bbe600ad7dc16676e7aced4c8ab027a8ca7a24d0b3b08ea1722f1c216ec2874b26c9a66ea49ae3dfcb7c845c188ed5a34e2f476567920bce317d940d6720c3829c9579d7e125bba8318d933371b2c6cf98fbb361654872868ccfb742e2338d4071327e616423b4e6fd4fd1db6b184e4d4d9d9e5774e3501382a772e387695b6424532b70f868412cd6042e4516edf0f5b41b485d7c925c32e5322e425462da154ec46ae3fe7974492a6cc85a1f76a7220586e2edf5ee2d89d4c7c3777d554ee7aa643346f471a92dacc3836d2e82079dfa8867a331d24f6c55efc3b5cbbafdb6ee4ef74b9b4a2409eaa90d0788629beacdbcb362eaa8a2dd02f9c3c2a4f6d6f22e3ad9bc709ae968296a46e8a886d3bac345990664b81c1952a313b4d09a1153fd44117f08efe18ba0f7208cf7ff11f220e17b45ae182decc3169d7bbe6ac7dcad1b4c4991f7e3141f3714e6bb9ab77f6c9d909d73acea17fb4fee844038483bac252eb9439f4c60b8a64974db0d468892b61d39e2f0171f64255a718cda323a947e358f338936e65b194c526baeca8431cfc075cb6c334fbdc9e6de63d5ab417858c1e414e92166ad25a9fdfbd21bce61a33dc35da377440fcdd4c13cbe54adb2ab2d0e6362bd15139de8c5a4fb30b5dc464a420f7ef688137e9b89be8a1fad6dc096dd638b989ce8db5f0a3e8c73585d18e554b1954f98e35cf20da325945a7cceed8bd6fd742f95a30437b0e5cfb12894b5f90c38a776eba65ebab1c16bb1988af3354bbfa01fd303f90218e64612a489079b0fcf1e156b1ecebe06a519bcf62867b7789297cf34ae50c5b75ba8dc6edd301ce88d8f60e0292ecf57a82ecb7490b9bb2216f722fe5b239ea8948575b348d9f6962a17cd5ae6a3c36574a7a1b0a1f8ca3f6cdfbf10dc87a193fd05551e810ef8769d95383b2bb35f98d42a536373fb3ee57a21734c69d93c6d2b859e203fbc735b71c99fcdd27d77d4e40bd1c9b3a3e890570f41cc418a10a5c291e315a29a8548b8de403a9261577723176a160ca0f1c023f3df3627b750c8c3e2a9a832c1ace8e3d0d5ec21b222aaaa47d7420a48e971042b777dae3531fc4abb09f24faaeb8e0e5867bff3a43d1d85199d27f255d89c72d48570971b209ed7cecfe293539114b486a97713a920a10dca3dd8b970d4e79e07d72ebba76946e23cbd004279617801d4be92a72084afe0918b9943dea9781faceeb2cb7530ce0dad06c533c1c9e878385bb29035abc92c9fb99d738d59e2b8df4cf88a85a1fb8591ab8ea618255045f01092f41715fd9957fd5cdf162f8166895e30d49c644dd87c4ceea815f40876d40e2cddf36604ce76ff95e5d1d98f189b678f5c39760b29ffe55cc74bd0a4575ae3360e2ceeae57afcc333b2457d749ca2a172ee932df50180aa0571b36d01dd815c4b1a0556ad5252676e0fb546fc67ff58b9ba8972dddbf8543c2f834adb8cfddc7f1e6a00927e02d964a1b5c5d14d73b47cd1f97f40acafe7fb01bb57f6f0c4f8b764e80fe830a52cfafce680b8a05f80e7e43f87f30c3bb91a2cdb293f6cf112205d0821985b959864da4877ba1ff7925551e498fa99b52e4942ee68dbf46929d699f73a599a998004636f92f7317a2a61e017aced3f3d6dd3c9e888b743473ee71d60ee5c051ba92c2627fafdc402589dd13b8a32f64f5ded2028ecf516d201eaa45836e61c9f10ae946e33c3bab8eac6a13caaa6037953f803e569f6f24f67ff7e44b30284061e6463fb3b45d56e91d1a3a41d67e4d1bdb50348727fb61ee3ff627d961960df7a93e3bb307f96d665afaeaa16f040619a6f5334a8398161c216a61d85ebff4535c2b014e74fe55dbb19d10b2c40e8b97f3357e6d7e52da8e6945e78cf34a20b1af3260dc17bceed0bc940c9f1e12efd3678877200320fc0afe0f03b60088b6e65683e0a3bf1455043d7ce077745f845c5b1f43ebbd3797ca77a50370203f129ec7e2e26775c97174a9389f469026f7e7e40e9f8ec0c4ace697222ded59652b214040e6abb5e26d19b5b808d021e5c00d4f06bbc71779640e3214f19b7f01bab6ac3c1845562c4e9263298d7ca27996c1acd26ec0ab38c869c511b34f1957542f49595b0e8e00baf697dfdf0eb36c4bc0f52a9ca797e13340f2e4c4d58e37f1507c6dc262797358344918d4360c9c3d961d368918eb1c6c6ebeaf1afccff35b51b69c8ffff5bfc8640d5212328b8161c4ae929d8df9aed1f90a8a6c33699396578c1035cc08caf1d52c1c80d729b4997240045ee237cf552478de604b8fa4387c584e679605417342c5b4c3b8b560cd44fddec2a9020400e2380fd01c9895b2e8fe3f68af43b0aa7ce5272422cfc7539544db077631124ff142d61bd5e2035cf57da7ec1481043d27d82c528b9890f1a43ffad65a7107e206b925cc6cc62ab1a88018d1032bb11439de5f637998e863fd7335803aee01be9589780cc2eb2721b9d3d268443e44d840d9cb4369479016495e123ba893e56a4a96c5700b926ddb74cfe94b797f0960dd9d77b65b647239574a3e705ef54e0c0e6f700e0a0968f775edf7525e82674a208ee9f16f217cbfc60526fccdebb9f3e37ed1c8d73a532714969ab06ea52cc7c450f1cf1e3d25cc587fe8ebaba63dcaf5f5c8c2e2eb19b2feeca083a8e98c0601ef3b83951ac6125bc45d4195513b427927f12226733e4df95cb1bd4850a5f52c4e278d8defe2fce8975ab74135c9abcafc15734dd3d2ae92d2cca4484cc0d95f9632db422016eeca4c64b8dd99400381c8e9fd6a631431c6486c249586a575b43c0b44c692a412f0688292dd4cb3aec88ea987dac569e604bf73e05f9417becd17bbb945abd0a0ee46b6323ca6688c8a66ffd0f317b624b29cd299e5bf11783c43fb21bdfb9c7cdeea58038afaa6b1686bfd15556f23ff0dff1132e79c33e09df44c7c32c27b108bbb46f467c49db05734073cdc965c7496226da7745e5de6c81cc8d9b192a1d6023e5f8afa59fe733f5defd975a89feb8d6f1397cc1c04415e5448975b0863766d26cffe607f1a71d333fc7ee71d9896be56148d2c0facd411b20c490938911dbfa49a2b5de738b1fd55db7da093bfc279a49e9bbe4f864d83e9e08792e0536379e27ed88fc2cab3e671f42b27cecd67cf2f7741a5c3b2780878b613982fc2dc16a067666b310b040550ce3e8c5a56cf5910b3194f7158fdb0d7cf7ab85c241ec695223292e9ae8fe25529e4e5e1bf10c6cb731bdb96769660b5e652823fa4e42ab4b9dcad61f05e9dbc88a31c6fe736429d55205eab72a1824166c0c403ebfaa7ce869fad88f82abe0aeded66c592a1d2fb7f43d6c9eaa6209de35f728cb5986ad4727ebb706aa20e518b1f0bf915919e0dda04dca47fff39a1b16777ae8a96d8a567712bc3c5dcfe1712d30c846008034d1a2fe8c00b79eb117bfe6f56a57fb2c692e3eced0aef6fb1d056158f7ac88c6c7af4d7477d94cc8a65afefaa443410f8e6a4f2613c5cbeb94553e7c95787add80da7507144ab2596f556ff4dd6a966125b4c00cd85cfb46fc438d7ce77b675ad80eb47bdeabdb5f72a70dfef14546e0957c82174f47b4629c01d645b8b7d9dc383934c5db2b91d2051c462bf565fc177c143133a04fce01ec2d5d0d24528e1b2cee057e7bb05b47c118ea653c0120ad4d8443559802df7154d82171102421e998338c81c9fb71b8d9cb8b161ad843d510b2768e20aca740eced045ba3831c9e6d4c1aa1966b221378e1356fe03acb0a29d08877bd0d590ec13d9c7d4a9ea279dd924c13fdfec6b367f56444304a2c4e13b6755771589cb4062899a9a3d5d71dc95052b5079c44e8142acdb06e05a39c8204a516610ac4988cc6af890f4945e97d7ba5f51ce3d0d536cd6c891a7b0d451513d60b04e3db22c62638afeb125d987d723ca323ff29f0e02772160ed4402ca5a6984ae6d03afa761c633aedaaf308db6f2984d7eb788b3399c2a02ad1631fe1159b4dc6c025dad77a669801781818000cc3c2d6eabe4fe7200334daf1cf649cff52cda5ec34ddec608b7c685254eb5289f6a5b45968bf2a8749b2f6b1200339210cf58511a6305395d78d7e7fa8195cbf5791a7535915f7f6fe6e93e95069696b5205039c38c8c1d05ce137c7aca21892225fb532cb80fe698310c7467792e9459626dcf549b606c70d22c15a7e6df93da43af95c303f3747b96c7b7f587d7fabaf9993c052fbc15fd0379f0061b10263f41f2e59df94c7b9e17a0b9436788d12fc28190d7a9c608fd4146162df8acb1fbd147fe83d4669aeb54754afd21d01d7260ec564ad0638417c7b1251c09a6f3b480fbcb08b5fe8244245c64132c2b1b3f3e3b4f52283606960805f9fdc7e3db3b0720b3d2de2395229a5ac8c9aecfaed98b142ee9465fe94a13fd2a784f3f9ed4d423f590ad868a658dde32fb589f82853d8d00a4b2ab1ff8a2f202b6aca7369bb038721223f94ab4e1e7e1af1042861521d519dc6f06e637f62022fbb55317a24f35131d3e81e58676da3dbfa34781df5284436a2c23daa3f8f5c9e1fca5bfdcc86c6ba9ef9fa0b0be374aedab02a87c61b17e66f2c9d5484ee54307d83c7242eb1a9af2a072529b69b3527e82f2be5a090e2e9842bb33ee3837d41d8beb4c70febfb7e919c9c6a9437e6b19a2ebc3f52c3ec546854564948af91bd0ef84a1e8166470d38ddb31cf32a5257a44534dba15faa4c21c1067387496a3f2892a2be59127cf9c32741a6c8b395f8b1c3dd882a40f639855193ddb3121b0015bae5b42ce1726eca000329a3c1db198e872b0b7dadd3c2ef72408d83a9b86c89522387a778f41bb65931292ae2f0e2088ee9ea396a63c852f02c920efc8932776395c3f1b9b83e6e56e5fc43774d380ab3875773a6e72965b5775f31a54cd347659f5bb4dd38efe1e6f94578826d40e9b15b68ec99d36fd031a795bb783db22b16e022113a49e8984525c77b42ffde3471f10a006d3ffa2ad444da9652e0b242a7102762eb720f1fd8552ce7e3ee6f7697e4d87bec9385abf8890290744ef5f1732ec30f8619bf8fd6e7bbd1ef409089f873f35a3cb10caf857ce9edfd4fa045a0a16faf2186e3835ddb70cd1e1d2aa6ad48516326eb76c6ff5cd3422147079a0c370c79801e46aeaea3cc9dfb1c9bbfba6ec56b54298bf01c4b27affe8ca0b896e93c24bea8bdb56d8cb638ead2e828b8e2a590455178ea6bc977480f8b72d2136827f91d8066cadd238a76057975872729192b8d7f8284dbe9112780f68e978f9273606520896af3c41544734a7c1f0e38297e7919fa2c520ee4a261256b80664e0f0050eaa100924bfab38c1a5e877adbcd5a5a17064942425528d12232266bcdf38ccbc9b5ce7c3ea9e6dab8ff3fd8eac8b69178bcd0f70e7a650db85eb2779bf260f16ac672090e3b845a283ea4c78e4441cc9ae860a3de7659e6ef5ccb727a79f7ad8d647a8d5cd4ffec508971b775ccb881af9a04ac931d803e0f89ca9aecec1574c855fba6cc7923ef86ec1a19e1c5e15b28401c4868c1b27dae54e4f79af5cf49c156f21aff7e8b57f290830002352dc0e187ee8f4bdf1f45bc2f7a2cccb385c8d825af61a9721d7554de7b971f09de558cad558f81d594ca56276e1f9051ed5a137e987a4d974c7f69a1cc289ee2aabd9773f91ec546fe9f2f7f8f18eb08a71a181229a4d42aba3d685ecc2e03587de8ca8d58b0e34dcac0e7f9c5b2bbdb97311c175f1aaab4354b130cc7baa898cccd09bb00efa8448d1653d245173086dfd11801cc37afbab2d87e0ee518f8f67b005decfcd83466bf7a9b6dceb13cad6b08ad4e43b4a9e77e1c96f41da5523214c1c35ca91a5de5884414816d9f3662cf743859ffe07f9233dfe8f8ab6e8119993453aa9239a15cb8beeb4d6fa9cdb5a03e8e6e07b1ac06d8f3e77af8ed5920a5e52a46c950e194325798781866221534222a6358d35795d3ab84e0c8581d1a6add2570914b8ccc03ed1062b7bd71d4daf44769b92f7335b213a412d414b707d14a35d6a8ea8bd45a96198079cbac2e4a5ee4b6098677d25ca5293a8abfadce82a1c31f3911871834571bc9ba156c1b4c132c782bd91872eb8d3995aa577720230600c0206474fba992e374303b24418b13218454c154b585a740f697bbbba94fc126a8ce9a099eb2abf2f8810cee42e4ecf6c9ae0e05eb5068f9018132871a026456e114e8d08f959af2f473ca60ec8c8c9fae9783b3cd2537a0c518b7d49843cba10dda073c71c4b941a45c67f97e835f1e6e26b881ae20a09d52907dd368a40c3251b8d4cee24dfd7cb4ec4275a8f82c6373b2bab036ccc98e51677a189d037679643df01f6bd397962c0a3bf1135881957a785ae71444a125081dd33cf945240795003d2cac1ad1ee7819bcb6de671012a8e65461fe70dcfbf4ae263200cb2204d57381002cf8e46048e2ff8af962afbc6d779995c43402feeeea8184d0df3b9a894ae4e02fdf101e2610c51bcdbcffe337a0c35c78ecad80711b30e5d4327d4defc7dd65d072a5f0f25a121a044066176c564fd5e9992d883b0116f288c6bb461d0b26f15d1ecb79f9891bd204f4a7ee167168405ef0ba6185543c10c8d6239fe030e6134f53ba6d3f5b95b4565d300e125f654d7ccae115f610f080a9a91b9df8fa83cbf09f0e9d5ae5fe5366f694f59d8ac4f8db723538bba65b1751fa5499f7b1335ece9c161abaee5dd34c87ff7a5c9f4442bbe87802865a1b42422f77e353bb85f7f3a3a90b9972ba09c36c599d0c7b12e7890da981a5261d54aa7c2253639e0812c35c47e8e1980413f4e497cc720b1a163741030bd3ecb402b23209c5f63fa9b017ce5cfab11763d432f8c244750c837cd7243fbbecf7c9aaa34797d4b6d1c0539634f1e454abc9b953e7d6af3c24c9ef4289ce8e9ead417efc0bb8d2660803b01737e138a985a0780b06337d9a8e4e3525f72fb5dbbf7e2b11dd2a2ed27165a8352d07c4fc2b843dbd313526d095c721a7e2c58a98374ecc796384b967e45c07d94799b3e23e7c34e205c126fb4f786881ee32db5f42cebc1aaad40b2d6569cd11a8108fd2df7e5caee5dd6b8dc3ece682ef166773a254efefe349b0855e59b4862124f0178da44164d0fd6be2da1f0558aae8e9efe6bc604d0e011fc81ab7b5bab85cd5913501efd83a3f61521b8bf2f13ae5ee11d2b26422fa228389e974c3339e84a81f03d24c2eff19952af78695c96e127ac2cf54df250bc215bb99c785db5e2cae630fac70c0bb2ab013202dbea3e7bf7e11cbe27e7d96d95e5763a400f5dbad128ffa2463861c1c7a96df90b1048ad3a173b6532178ff5bfb1f6f42fa227f4103e3193d8041e9d982efc5bd97c55877bd28ce9098ca55f4bb079a277cfdde5f0c05c7cc50f079ab88a39ac91cd1a94d1d504cd108f44d86feff7dde1a70891969cdf99b1ab14d1cbbde1e30f366606d3b23281580cec4e711869956286c2e593fd07278c8ad4eda306fabb8ba9c40af719e74d491ddecd3faba3253bedc7f4180ab52bd9515c8408f06402e212bab84286adabfddc1d4244813be1998d06e668af020f0faab840e3a7de505e15fa88a58e2c784ad14133700767e19b1eeeebf0536cb9425424af2355662364e7e4c28127ca974feb96b11db7626b577e53c0bc3790e6bc96d5996eb90a56a527bcf0e012301bd0f9d6d2baa734125f8feede81ae37f40abd6a1abccfe4bd905b09299b74dc55e3fdc9897ba60e9fd9d9cdea792b26d39ab76d9c57573477eecc7fdc01d3dfbea00196fb6ba5096ebe73bc1243d348f581206c36496e51fde791b5aff9eceb3608a83b487dff63c69b84df07b0c3d5bd83ab366234e91c7813bdb3c6ee5c54542f17b107afa3bd6875e66d90eaf2b321205ed5ef540bce722fd5f3bbe007f4a8b2a8aaa318be56fac561eaa8e67a09fb037598302b4649e286e543bc41baee1121128de72a43ab7b9d53b5cb22895b2a7e95a7041ca34cf5a8cba936acdc87d3f03769f39fea921149d737118d8a9998c8df5cbd4f4c256e52b8a76ef3f58fb6e07811eded0426c38a351c44acb0c4ec0863a342e2bd3381e954b5707fa6ea4e10b17d091e7d79c438a712f63fd1ad4d471cd56078f8247a44fcc4bf4d2934935750e6e82ebe6e9ef6740afb29520cc75b540e5e200629fdabf5e841375f566ed7b91feab4507b4e5b5ca1c4d52e567fb68531fd16ebe83b514cbe7f0d86319c667108969e8cb6b761bc63a69934808345d805d52e0c80d614b6118ab1deafbf5d26c015d50bc10f5b916216e00711681acb897c007edeae877623a9ec8c810259ba3ce46136408c1cce92c53399467fb4e8a960614c8f063fcae24a596a5f30570b5f00f5c1fc1e61c36f5c9cf769616939835ec43cb7bdf7a83ce4edc47d750929d772586dd63cfa5487059d9f18c8e65ba50c7fa288fa9af78a4fbb23f81f86b6a905a217d5816961f9b3585e0e09031403769bc283efd2502aae34e05f34f2f52289337155aa84e723e2abb527797023adafe204dabc1818af07e2f0891f76051df6b26d69c0de290c3879dafee2b22319415d919a51fbbc042044b45e665416c1aac76701d14486740f708f77e1117ede5f5059dd166bb398f728fa682fa1a401e7914b6daa00fff6e426aefd68949f98df66d8946ffc5eb28f802b796dc33abb7b1f1d633472d3f7135ad9cefbb7a4da958231f6d98d0095d9a83b7e818ee5f0889e0a9944686e39e17bd2a8a13215b62af87a94da87fdd9210af50cc32b55bd27eb866fa4f8c0fd2bf2f0ec9cb39a182758ae73280047969ce7401178daf0003dfac27e1e9736ad30df867ff7982ff8490bf57d719df72dc9ca700947db150e67c0b5aba0f427ec9c5bcd2b18b36260a385fd282b398a7eb11e13e4877732e5d19a8c540b0e3512734dc740d9ff40dc6c9402310ecb4dc71b8273a63dfa5fbe65b9e4dd4049ccf3e2efdb4a5a3b830a0b825fc9ebca500fa5f0d5059b9993cc84e4fc2f27ce4a3e0dc0b952aca5f609aef658719751909f2f98285149376d68e00dc0a0abc07b88820fe2361da38bd621cb7bd98044ee2d37da4b334c99ccbd7eb6cef24d2de6caaf2eaa996edf912fe83b95fd8acc60681b3b931abcdba8d03c00427c55c3842b7f72d4db793934234c0eb4dc632cf3565c1b50a9248ea234a79d045e9df4cdf9c8264418e42e4d3e8c7843c11bf6d3ae8953cab9ff4204da499526714a51fda8853a3d9a5cf8727821e7c083f9e10410ddb4fbd5e08db66b96fbf3c9460b7b401a000089972eec6724f2e7a87126c40071d9eb8ac3fe9e7704fb882bae6fba01633d3e5da401c4f6ca628d3c939321ce7a4cf8e02c77df90de3a24d507d80df84bb1aabba63e1617816e109da113c2cb6a8ca87bd4473a587ef71886c3dd5d2fcbaf3fd6039019758fa5c34c3902ca6ab8f2b62cb73afb5bf884b7752b8f99b749f4c3f74570799c2dcfe639981177456b1450a0068c8e3e33f5f19cb9e5cb86113e20a88b43d25482ec73e1d271ee79322e68efcac3f366e2b786dcac8b1d9a35f8dd27bbd33018d5a6496df08bcfddadfa22fbf015fabc75f7cc5fb8d1d401717b2ff237099fb604ba7e6fe3b89fd0d4cd9ec732f2ff92d4e389b160049f4b6c47f81eddc693909487eb674d5de2585b4cb11489ceff6ae496c2b62e4df3a40ddb94859550bf14d02408556b759304a08ef239b9f6462ec2f32023798fadd6cec8527f6d6c7f897badbc30ae9acc1f117e716fcc5e132be3672fc3be7db539f4ce8f5164bb715a4ce2d6dedee4486147fd9e563e4a99b961f5b8b7a72313c1aeefff880ef3c8547f1ed0ce05bd529d58c2a80bdbdde1b1ffb2abad623183e95b02d7f452dec597c6b05de67f12f745bc053ac097a7e41853ed386febd49455f2b545490dcc2c34fa4b76063fb3aab735964ca2cb6efa2f0a0723dbfe565555b7b44014c421bc141a028ad84afa8b24955a38b5ad64d271bd219c6b2fbe98acb81134511adead5ded2c187aba1d0ac3151c11f2a166c7ba71c86ec0395636ecb16e808c1a7e19048a0a3dedc3f8273a1a69c06c99bdd24bdde0f31d753984c562b0954a85d2726e9d887a8e283e2cc8c15c98bde52d6baa214b3d52d8ed1e25aca92615f1de37ee3885e289e6b6e3cc9bcc909ecfeeb786acfb0ed331446599d100dd5344002278e86282e6f45de811f641266d9f8ee4ef0e93e8d4c8b7d88d472515a09cd790b119cab64f8168a1ad224968afea15be3e45c1888d280dc93da7f7506f2029912101e7ba42bd94ad05a1f883829e5cde5a3272ee4f2100b8e1fae32843bf005726fbf43e1fef44b6843ea4ce7f37e5ad13add6b3ceaeaac6637d1b50d13b3134aa5c8a010aa98fae25afd197e69d21ed58a0409c717e490ce3c7b77a5178dead781a5e60729666eba6ab33a947955f25cc8ac3a2deafcd8ac271468bbc880d5e99d599e640a47041e8a5","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
