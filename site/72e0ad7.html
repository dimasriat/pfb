<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7d47b3052eb856c2e1e8e916e84171f94b5f29a9d6fd32337d504469cea8a01eb649cecae3a53301081e6c88e3e5a1cac0d60b3b53501ed179c264502ae6f871acea68db4a315a7663379d77fcce5e3fac27c9401dbdc05d42e159f82fce67e240e358c51f653f052051d6d1abd4037280e1578d5117fb8494bd44282684ac9db06f70afbf226ed8b823159e14d1deccb8e31088477fd852c9d757f548012e7f890cdd8f8bb7d2fdead20a11876501dcaf5eedbe9ab98e8a962df2fb8416d7f7eceb5cb67add6dca4e84a4497518045e2b4fb03bc45bc373091c046f232f2a10979585c9cb6be5f58147fc7ddfd5be53cd32b325f13008b7171ddfdad83e23a81f8dd4501fd4f48ef46f8070b61bdec2330e78074d021b0939d2dd2407c0441d0830a8d56b211d468f3086c874b66a83c4d2d6f5c2a6b10ec31be2c748da25321f00a626d546c660dfe141694da9f70ec0d46ac90a00077827f51e2851d05a311e18875e2df2912ce1bf7ced560c63a32fc481d5ffb3544c2b4c555ec498ad0e83b20f0fc06af68af6f8fad4af8deccd1a719f84a4503e1c54f3f4a0b38a2a9e8091c721946acbb937625452441745b72197e3ad2bafc09c574a908d8c4323989d9689ff0baa1b8cfb24f4042fcb781ad2160641f988a33703c3679e1e21e8eabe7e8ce08b0ab8a4f28148a462fc8fb246ba463da60e2d4f964e31ce6352cc28fd9c69bec5cf9e95556f8812d1c3bfeb0c21da7842c6707c194b9a5ce745c04aed76ba782ca510697687e7407c0df87070ed9927349b204eca06f80e813fef11f3c71fab255a0b646ea21d86a9a3529bc96e8f36b9c81340f8b3a9619ecb5dc04e8f2abd3a01cb1cc1e42d648cce60e19c4c184c9120f1fbacdd55e872dae7faae5fac91fe8bc4ea7fa2431703a6114bae340202873ca1659e40670289295b92ad244797a1d03f4110a952c9e236abc0b4c1f0b6afcc9448ca32528fa3be0e7b6c1e2a58babc327014795898fa4aa7eb87e5ca7cb5bc8f33085e1806949af09ee34c4ece3555a0ed07bc8ad5d4075223e3dde5b15c7f5a7312a347870a0a8f61b831a1e8cad8c265d9c444c3a619ff504706d4347bf2f2bf4328ca35498cd23a48c4856c9604481af4ad1225885a7b4fdd3b2a8a53c04b651de94b1ae5cdad5c6cfd2bfdb9fd418a0157bc7bd7884106aba5d20c3928e37b7d77ef0510391c9d42832872d5894336f5a2129f9917568c18b309c64462fff7a87278a35dc1e3ca16d6736b8905815b6d8399dc4e66fb52af79fd14bb4f52cf56f9481122c6d099495d71926e866588eeef8f0d7a3739e6fb298adf60df219f7544614bed5b16e95b574a79c4c718f50128bf081582b55c895a60891ba2e984681d53751437b2a90716eb6fda19c907c9e7039ee8af6ad47fcaf6a56769d8e98bb06986b088772afdbc75a191a5f6bd96e4ec3d6a66d6cc0cbbb4ee7cf5e7ccb2bb5577e763a08f988c4ca7bfc99e8694bf2b89e176119dcc175bd7dfa525bbe6be8413c75bdab806861cc8015f2ffe0f997453ae38b5832d5698c40c4e775a92c7cb874240d5adf04fa89a87aebab6e003615f20b0acb6bd20e329186a2fd8643b2b321fcc477b4543a017d4a45ad98881804eef121d03aeef86181896c640259c7a0b82fd22e424aa30a4071fdcc493b7f436d188f4703d5538681a04aeaf402640d9b887fcb7e624ac4304a4c9588fe1ac7babba7827315a5cd250d4b15342c2f25b9436297bfbb4e606b8cdd984661650c707ad45e2812f28cfc33cc86315d6f14594dbeb31129ebc196c47b2b7a81f499c46dd341323c99001b83c6eff6e417aefc04b37edcb9410e711474cd87dbbdc4a15fa8e741e997761053e355cdc4b8a79c3705d5efb28b259e98a8faadcebd2ee3c6cd435f64755603774d24d17490ab8fa1aa13308b5555fd4ef6597f16fd98a1c36af718d07667a260b7eba4fefc7dc5f13b011c9bf9cdc716f6b45228188195a8ef3905073827435c54439cf4c68e72767de8be99956a455f1fe2fe7a643bed614eb718cc270df696e18f53544c33b771fda87804a4de4132b4462b5f33a6c0899252ae4899f27e33b2dbe25e1a7e99013f5bbe0367980a57c426bb522487b26edca11598b40ca5fa97794cbbeaf2dd8cb276d61cc098ece4ee35e74af8c3ee7228ee913d02ee0737dda7d5cbcfd13742287d607f5c0032e26a4cb74a6ce3f5c3853807453faa65aad957874ecfbd915324f832fab650170de260a5ebfc79ce068aec3204fbb2a7fda395d8e0efbc20af506e9234f87dd3e6e2cb1cddeafb4671403c3857ade6afab8ea811ce3eba7c0a37c66ddc210668f6394add2bb1c2e281188a8d6d614d08ec69b7fd5d1edd90682d8a12b70a2cf0f404efe0ccbc3ed221337b8095169c2852cfde953f1ae23751dbf5b46610930738a0b8b32984c3e1d041dd80a3e2eb95c9f6b88b350ff942c4a33b18ac536edace9847cd4c30b144941328da0a7506db1466cfb8257e00f8a73e6558bbd2fa254ec1960482f9503eff4dd97dd5809609c371fa2cc1dec182f3ed6396662fe9a23ebc7729bb449419f371bf574184156fb0ec2677741e4d3b3be04851145dd8f2d4f39f9f44a126a397fb2f1b16dc686d22a477d0edf37afcd4b9297cffa809c56c90c32c77180e7f8ad02cfeb0915b69892bbd9515f5559b38cfc58989de3f0e266596b65dcefdb0168c5b63498884e6c5704dc00906630fb0c5114370732920f9217490ffcd92971e75f2249b87e860ad9ae7616e8ea29c05914ce34f51fdc85e0b4ead9b441d9f1d5252d7838e02d4e34cf5f52337bcf14c0eb0db34b497835e10a2ce35fda311ca5d03173fea6b9edab5a99b00e5761d25a4dd3422abe8a7d766563766dc3ea93fb80accf083d96174cabb5a3cdda3e4025068b980089d2fdeee42a7cdb3fab904c74fe19959cebfe6b12346f97b45acbfbb41ec50459993c03be0dbf300bf211cd0ee28fe3a0031f390d11c800bea7f0003e21423e6eee1deab3c91264e8d9ab31d4cbcf7a785f96429244c5ddc0092c43116142d768107171d74222664776fb69bf8c5b02660ed2fc32b4c526b2a8d544bd47d943f9117884333f4dbb99efa84ff34b7da88b01f4da9a5e507324971d16885896b5aac9649df904b700ae2816a580a2d4a3344e84b1439370636ad6a636466fc38a6f273d9eae86fd83e6672da797f604809ed7ed805ffecafa8875de739b52382087ad4c9f442ec3b44b2eddb7a8a6f89ea1e6d7e442b0125954497e8375e3e3735e892f149c60571524af5c106f9a08d011186f0b02434a9e93c64dd941c1f7261784aeb34e534f5ff1e273af7e6adccccd66eaca133f101efbd61d89f606440e58900922584d8d9de983f85742c3685e431c4c5bd9c1a1403761226864be66c90af4a4e0e8f48353c068e68d12663081d08a78ca7bb6226af0dc8197a6542c0a344099ebabb08f14f31e5afcb0897b967d18fd67208b536165d78ea7997cfa1deab5ef0abf79f182555e77e6555afb149da0f1acc931c89e6fc33bb05d030964ec4a4e65b0894354f0907c6ef9606de0e76e60a296486ea43a779c9102a11f389b73400d307408c53bbf9a0df0af3f2b3632a4b447946a9abf479ecc620cd2f684ea1e8c4c5e90ea0e27c83a35ced8893199457677c4740f8fd1704e806e3569664339b67fd93d49903eb88ea264ee7cbfd69074781c296689bc1c0af69b3e50fe4b6d8f610ab211967d7e7a5e20710a3a68f956ad36d26a9a7de991c124a5cccdbdeaa13cd2f5997f03340bf0083729f8d19aa81f9fa5929338d267c56b03b513ed3a73e1e09e6802487b8806c71686bccff39b6baff14c40b3ea4f6dc1fa9b0e5aeda6f7bf660762ac8ca884ea8561f2e69e576ca6bc9ccced126a3d2b708a78b0182f254551d28ac753e9f7e71423677dd73c82aac019af3c161fe44b61de1aff65c6b2a018d8571647b105a429b6279c8d8e464fe19a8d171383602b56aa788b342c6951fb4f50f6b0dcc165edb42a891fabf38fe1c67d8e33b63eec0bcd90f416499f53068f2a8d6b1867e02ddd9eba76ff1347f0bad956db12a5d291936cf7e073e87c4af9d91b1d6cc07a7806b90805d54bc873794afb280afe2b4fbfe8f603a7c168b11dbfd33a8edde0a93d0bc1b169aaaf237ebc55b04e2c87513b792a2899e672ec5fb4665dba3eaffef1cf06712ec2cfca3d7edbe4468ebc97c0c7149dcead5b4794b77f617b7f8e514e39d70af8797edb80066c15808bdf0262673cdfcd6fa1b77d1ee43e31a232055b0c7e64b00b342fe33f2188b8f25f5d1c676e80865bbee835dc441567bf21c8961cb5213560fb9a1392de3ce4d4376088f7fb3cbd7feb7e2ef3edb6140fb58c2b3ede011687ad2ce2de4afe3a61d006a5a4cb4a0d38529d88fce03dd2cf4dbfaebb7423defc73dc80e7f094d68349cb46cbc50787a8a543ba000f520f5a3345be455d2d454e27d51a619bfc5c12d145ad39744be4810384a56a42b7ef65dba00b5a8d7a548f95f8930330895413e37dc80c351b14dd806a1b6b2f7a12eef6bef91d5b152c5a7cb20ca01c8f9ee7771068b4d7c2d364acf598494e637239a8e58c34c9ff590b9b9e07d956071f1ed1895a70d3873eca4bbe5c28621fdb8c8c8e0c95fccd5bb804be4fc29f540ace1cfc5107aad90e7053aad720b5db89e384c2e28dd534d52bd219d7063010cb5b337155800f360192c9abf203c02fac0569c596da50fb41b01cc2c308b3ea05a8017082ebfd2fa03f13db05406630ebfdbee970d4902ad4e3079c06f066ddbd4e97f317b31b0a99b9bdc033627298f02777e2202662e460fa27e1c9e4f838bee7a22aa706b79dd3f94f42868f089e7d96f64b960777462b451019e908ebc6b177f5f87223c729a034d2c4e2d57f55dbc8de3d5970dd547225a88067b1727117f4474c9de972b90be57a00c70ce6b6a72d530321732bdbcabab75fef110f8ede8901a150f587dc28a1c49b6cdbdb626fe41bf9196aaaa2f246ef174e0a57311d77593af7ed70e38f140714d02ef9d26fa388377a02ea9e17b4d7ad741e4cb924b9691fc9d99e2da6187a27b6e3e59e9f08eaf6a96f87df391fad0ce70997f00cd0e2325197a63db92126fd361cce8ae0c661f3bf0d8497caa37efd1ce6b7f3afbb936a15417e3088d5f392fa3c4adb94b822eaa65184d357d9aeb05b993c53517c608fbfbd330b1bf2c05d891d8b34fd93370e7a994e5ec0fe07ee0828a1741306f0ae689917865d3092a1e06279779a82a1994e08f910ca2de49e19d6753556e15048d77a9c08dae95cda7b165f1f50e855abc339070d33d1598929952aa91676a73b0d9de241cc407cbbabdd9104f808c6cde5bc6256b79532cb534e23c8cadeb1e55f0a49df953cb3dca9100e99c0f355d13af4e077111258ea2cb1b47959c5023c8afe0a71b3ce87925f9a7215be149b1d5ec97182a4521f91636cc115be96d6e095d10e47adb3ed5992a7e4f40a9d10eade0cc8a31c662ef0ca98475e3465aa6efe371ed8960ecb2c5c8a33e0efaaff2e7c071be5322d48c16f5e8a859e807a5f68bee99929279dd91f8b24674411a719cbc411687ec71952fabeb517abbbbd7cfdb265a8bbe35e5ff70473fc744bf25d64ce456cfdddc72e30490e2846e43e8c278e47d373e44f131e1e6df7d8451e675d3a4195a121fd5621fb0a577031c6bfd412c83ff6750f32a989b6c76cd770b15c518770d27c4c0a9bd1ec93b13e30fb4c1976ec9f21b28b8d6fb5533ea3d00ae8e0a479f8388d5d1d8d4d3b7d5a36e70802642ee7567b6cab7195b69739fd3424bdfbee44b43e0218b4c837800f393dec739865cb17f4c4fa5a51b981e0148c1005a85eccf96a1589eb42d2974cba2eb5f1a54ff52b0ddf701de9d30edc6ae848a848200957bd68d68d713e1970feb868df42a9028691c4cb56b8f960552a7147ae6258bd959dada8583453897fe123f98301a903fab58c4ae33ba02a590c0a3beb0f22babef3386a828ed0e2c83e1437e38233dffb9e25d2f355e2a8fce6333722dfd50fc3c6acdcbca00ab4d51cf03d91dd094ff74892f155af20f83fa33c3953c3a80dac7928747be12efa92e687130d2ece3f306b3fb7af984e439656550389485db82bd94ba7094a24ecefd66666d01866ff0349ea21fce2e4ecad91a285c4de00869ee17b202ce4a06890038e53a5a8750d8e589a7f79e55e3ab7c31b4a2365b9919521e15bdcf20568a8c198e94e7a0266cc46d0cf9b5b0ab1160c0afdb0325d888068b3e58c9285e2998342cebea94ece19618cc1fa20aac7bfa6c82dc50b11a2cf584b727cd28a87a055dc0621f9b2e8e034cc65815d543e43895c8a89562ee8628a79bd6f274147655b9c7d75efaf12ffa1c883b3e65274b45df3b7fe99723df23f0ac35ed41b14eb2b9a16349dd2f54796b9996a9b2f9e7799d0c5fc6d71d78ed46c06ffd6a6b59bf23de4d0cca8e6ee31ee5d33e36e1fd964faefebe9cd482cf0d6d44f7279362718c93899367fea4203c06eb9c45e3985f9bb68335ca3c6cc5d48ea9b981575425a5d972118c08d326c87ddc30d3502f852032375bc1ec914b0e53ef25d1ad50ab111b9aac40a655c101b42be6cbb41325305b05b04ed7a327a31afa247798e3b9e8e197a54441c58230e117c2d443e5e9e9d7e418b93c292491e25ae19c3770f82836a0ac1eec1f30c3e25e82223da215d36e64821ad719e7ccd64b3eb9e297fe4cae051a83b0ec0e7daa8e65ef203a25a5346e61f2677d4900bdc1c78a80e35bde4ba23299fe690715cab2ae9437fbb63fd4c6158d43b3ccc157276014056ccc9e3d95bfc14f467b44c23ba4a1074992a6649b12bc7d525f134b0d7ed1604e7281cd43af36fe542796c914c079686ec07d424e395e44a46b30e0dad760d1b88c4b72b3958fd024019d05ccc2ed6c4abf126150d9d75135bef2af4895eadd15761f98c63261bf3d9156f19cbc6c2d6e557232ee5b7d4d2d1bf13c64c960b73938f08a0f6fd264dec686da56fc3473f935fbbe859bbdd2180fa9a786d981db794dfce16ddf753cae60becbf22ba0b620b469913210a40a99663db27411f400fb8b99d68452b8ae355f3fbe9f5ad73d77b771702441b4b7c81d4df603ba7bce62cccdaff90d5cca0a60ce1aa227c466484086dda5263e7cd3af1504d6179b8257e92eea006c11abe262fdf87bb7e364a1fd6f12a7c625c47fd5f92021b7a4c71aea10149c20ca730d0fd5e39ddac8fcf686511cae60cd5c61dc4af13df34a2f0fb852efff1ebad295ae0ebe40da27fdc8f2d14592bc4496c5d62dcd89a88cbd008ad6724614824f8390aeebecf674e97fb925793189aa5579afd8c6e25c69639f97fb538c443e45dece9d71aa960f143acfbabf4b06e02e021809fd01d90572e780e4783f2d8d119b7c4217516b747a70729490901e0e08b781c9224ac13a1693092f727a955050915b0f652dfb6edb9263fd6e1a0962661b7d84f9223d6092e890217428a7d8c663d0674ce35f64c5e0fe4565ca27a93613d678a803ac999233711dfaa42aa546ec1dc067d91b16788e74b52865b1af9411f50809018f1a916b4cbd561196b46a29a3d9a591c848a1f03ad1d05d516a44da0830573e08ab6cccb5f5a75fe2fb68b7551758c99e49087183c097820cf8144b951a71da02e74260b6cbcd7bc0cd9a686bba1536dc1b61e6db876c704565de0ccdb42e49c00a9101021d1741dddfbe31d236ca789e139f9f65e6571d93a9b61bca308b1f7894b4ca2aae133288ed4e811f2d20d1242c1e6f5f246fcbd16b7f0f0376b3b9243142777c13db0eef4815eb3934f4a38c55fcdcea5337272260f679faf825b730c4e983b0693f1c849110bde0a08abfd21d28765695517a47f80d44a82f8585bc8edc9a132e183fde35e3bf2f5b82a9cc24317e527d4376af1a133fae7b257b758a27b0c61a39cd1c207e0d80f1943bdf4e0a1cccbaafac4bf76ac091957277f17a6ca99e623348f23c89a1f259ba5651d8b74db6e8b9c9192e2c0e383c7ed2853fe52432801cb77a825f60d6efafb9cfafb864e7dbe9f1c906219efffe2907bf3bdf0bb100d3211b52a0f8803402b4471c6de56450a9287e7bb9d2ef494b1735713fcf4d72385f12558b2b0cc704750995f4cce749fcb0de2638f09b9faff4d507048fb0ab2867b70ba4d21c9f8194c3068df522bae8cbb613fbc49f1a918b62578d7e5225694fe3f9b7ed11199684116acb9f3d9e8ee0ec4e66026b5c4cb00392b95c92cc8b9e77f82c4033e87bdffad6d7be597e0e33adbbedc7e39f7f8afe90a19e7d3b382936f28c3049d1a168da27eafd9493976e85a58b2369f1ca7349e7a23f953f80524b714b7533b83735d5a0fa1e9c0a7589dbbf812d973417c84292b56a5e5a5bd135c9af81fcf6759fdd67fff65e639beb9e47bc972cb9c6d70549fe928531614225ecdeec75c502a72d51858c277ff194ecddf6d1bb35f86ef38acc6dabb0c74ec9002925c55db69a960757e5b30d7c8d4fe2f4b4eeead69661c115df5a621b64311e3cc43f942474f8e54b80dd9237e0b363e5df0ee9daa4e36c9b3794540b548183afddd3469e4b53b0702e783914e7470108ec85bf1fe0f69f3edc9134eaf1ddbfdd09b756ab48171d8ebfdc63d4ffdfcedaca518f46737e4713c0c43aa8a83137df9b0ccf31fefc5979b9d894f938852044eff7edf6e09986bfc1cf37e8d5a1847c41fa18889aa468d8f52edc8d910c274ff18c136657203e429d980a4acaf4d899e523c5ee3903c1b778775686175b937245c548a91900d72f995afe259815a7988d00728966faccf6844753acab39039341c4ad7c8954a14b17a3729f233e1aed040dddcd96638801e6fd9bd149aae27a0ad7c88576e3aeca75ebe45123ccccf1edac1f0e9c24cb7c9eac9c56f4aeb74c8f7db357f643987848aaca0b62230cd49a9d1c8aaa53aafeee3c768350a8ca257f35e96fd8f7406e3d3f784fe3ac80b8963304bce600cb95be3dc54e16bcf8d3603455cd9baf40a93726934f934d93bc1d034185c9dad88ae09d958795ba4751ca64f60954aa7870565d1281ad285ff5493ac2df6710e59fecfea174ce251553a3fed88bd37d0825c297ae7a690cb0971d47a5d189278eed2c22779bf646600309600a2c9a828dd264a78a476d6934c591b098d1588dc93edc09319d6b139c40d7fb14bed0d98d3c733affdc5a4b9ec2c909d470d827569dd4e3502e9f394f77b5685eb0a3376137eb0c5cfd8c824af3bafade0e8e4aff53971befe6a4747b943c338b66a34959e38e0f7859975074e879f273092216c9a312b438c7bd2c852efb0e0bd5653b9e771614a83822741ae40ea05677998b897c4b425c61473f6ea80d5a409b4030e6217f5a09979b55eea967b0a36c7275edf5e7c81527e883193c770d229d94a7870b6ceccc5b10ed4553c996afc79d9399907b5386841e2101de3322d4c0a18cfa0b10a7abbe0275ab32f7d379ef8d08994df71abc77fac62c6401965ddcb9d3f8986d71ab65b313d3f665fe48f96f613c6f891669e749ed3ec9738aa41aa39b0262fa9e75db043537e6388e1a3a26f474e90bc46a0ae4550f4c6bba2bc5bb0ba095dae56ebe4111245d84fca98c7bb1a88294c9ab9196c3a2fbcd534a77880214c81f872f0e7637c0b864fdab90fba3870eb93ce2706336e5459423a401b11eecfdb471bc2ff8917019b664f90f34a9910e5e9c15c5ea85930d1df2a83fbaf81bbfaedf24c8df5170ace0ba43af98c973cd6ac07458fab74d927109bb646f5fa4be1eb6bdd31e0e40ddb5f1b011098a3dd74d8bc670df013b05fdebc68bce5b39e4313143c9f98cfb96201d2064cef15c67412da951aa326f35d8140923adbf8301d47fe86468e2f4a9866fb40cd48cf134236e9703e7dbb4012998c6d7dfb6672ece1f385ba6c85f2644849dc4590df88d9e7fce0044acc00ae9323a119e1b5cf3fa192110c780a692a42ee04715086e0b1116cf405db7f9f69cd1e52fd93597a56821f91a7c5cdf037dffa684879b2b9364fd3d0b4a2eb1e1f79a67d4f2b9501fb85272866609ceaaa238f68636275aef89236493c0b336a4995c5418e3ea69368d345757c6c95f3d4c3f88508ac48234031faa70dc6c1bddb61fa90179b50fe39f4346284384779f77344d7b782557f92e18726f3d2b713d9cd1c795ea49a8628e6d9c5eb741e1abb74d24976c4a34b82edb1e0f4c2f931522dd561ecae2fa72ad2e48aea06fe42c8a270dd3a822c94724f50e9c8ca3636cf86bec359ee750042eb7f30a5b9309b5f5a79e4097553af4f50ade509da9efd13a258ec4ae0fa5db3731c28372c7e2bc6d9c68f39f970c2064c2e40afad756a57d5c8b54d20e1de26416cf1a3894eb25c277b8cc1442e8a0fb35b6de41bcee50298f435bd58a540fb20d424603eb1e942cb16d49cc020b5deda6c661d24c437af2f39ff08b789a23dce49ae0be1103ff4c43df1272bed0534dd006d34fc10f3481c0ca7f24093eb318995bb5baddbee94e4e7052d2e97c970dfba76c4ca39d3845798270bd7386f2baa16f92b1ac4f1a5831ce5efc5c07a269e0902352d94781acf4b386e69531298fbbabfcd60ad5d785556a1fa63ec2e6dd2df11454e1e31ed0779e9619e9cd972f7eb810e32ab25dfc9fde18bf6a80344864c1583973c184acd5e1f62907869dee4450906a07738e0c24235d51ba9202cc1d96e85e58818cd6b7f10ce912f584b40d7467b41ada011b44a33640a1093c242bf7a7f9742886f11de00baa763a5cdb677d51ddfe48b502407349dacb6e9b59d6b411dbeb05091f144a17baf042695b702e9ee0d0cd74287e1638c266e1c61bacf1b6f2c058b021e49d6ce2de4f9543002e814372df3939b6b77efde1df66fe80f9058df84bdc048bae7bcc2ea28d22c7f6d7d790108c05b575f6ad150d510c5af0be634fbdc4e49c61a2afe7fc915869dbb2814250f2ffab4943add8715b29861e3beb52d7c81550fa9a6ddeff3a0a97678e48cef9cd535b3a95c03d5ba03a7617e1d536c967bef27d8b502a9efb629eba56224bcb2abc6c80825e0a16712f03dae087ae202fa9d8a859c268ad477d14760388e0759dc1ee87f1f711d367abc0c18337cc2171bd1bf6f4c8ed5318decc4d2665c86bce0790c60f2fb4a70e39444a61604ca212630743d0ce85d8a189931a7026be14d78f9785f231accb1d729b02a0b4ef972109f87b8f91ddbf4c3f9b2a4c316782ecdb74bb1d1bfbf241cf4e9dcc7f4e172cfb53b2c0cac1dc380a84f26c3b949f22b55c27d4fec8c985ba2ba0cbfdc9210f03df971163389e16f502ded8803a251768974d972144ddeb9fff3b9936ec91e0b61173ed75b2c325ec7d662625e958d99b989afeb288bcf62d4819add6d41376d45253be5491394238d797901841694951ff7ab7ebfc0c89ae5df9a4def888a58d2d2d8bcedac624c06e1c950fff6f859e2e1d60a62b133021b813c7d7cbebb1fbb22a05763c1b10dd9d1afe8fe5d30111a03e17f4273fbe868eb7cf2b5951290792d7dff7c55d5b170856ef7f8b2376c7eec4236e9accf3d26e09208da12ab6d8207538a2c99ee4b008262dd1a1cbfdb98382e6ec041f7b5575d3af0bef61fb1a745a042791a1d6df7862387dc755c880605e0fd5b79965ffc01fd0709ebdec6bf8acc44c76958b45d0e172332adaf31c2531b35f610e3436b5cd4b0348f66c98ee86ef894e7474c51479407b9f40f5c5cdcf50fe2022e45cb120441acbe1a0f19f0878f70477ae41c9b4a222f33ff6bb4c4bb1de7948b78137c0db9db5db98f655847b2ce227b2abc95a3a499e669bcb4b4dfc7af96cb89465417f091663b2ff0f66fcd55bc1ad39dba0c0d137503a63102e318bd5cf54706e90203ae15cc4223c7e27b156a1e7c1592ef5088acd3ed027a15bdc14c871dc1f3f34e608dfe56181295e9be9e0d225bb61dea65e5c28d661aec59c1263d2d91f7b63808778c65fee0d5a0c2084a34c064553e7110052f9a978baecba68ad7814bd3ed60da048f775dd0028bdf77797ef22d5ea636ffbf440a5deee9f414b72df0e7153759de469dfafa7c895ea1c602e824c03ca0d3e4bf8cdc64643ad5d85af7893a92d023298f63aa884b15038fddc3ef425280799de29b53ca43e90108161369a2c0ef912e2bca1d9b65d4750edb97eb9db7bdbd9e06e6cfef6ceec2f8a9451fdf5ac0bade18d7f7419acb9fac947c0c377a362f8b0faf687cb4bfbb30856569dc8d4161818aa480fc69784b4eb21b3980450a87e8eb6f964de3bcfe4c9cd59d54aca4016817a7105fd021492304680f6383386ffd29e7618b0ed48430e58aaafa26042a59fc6f24395a1b2afc4080a4044c22b2f616cecaa21ef05ddad307200b1c3fad0ede73d6b0d4731a7237227068f25cc293246a9d710c71923e061657c6b1845263c4fb9f5f519a450cf23460303eb7ad89caf917f729ecf7fa7edb7ae83392ba5ef7b8628eca0bde237557eb4e7915e2fc1573eb48908da3f75e768cf20d62f36c4ceb1647201e74a3982f496ce7c70b1f499b106cc191e48b9a0c9225761d0db6aeaf2735958813e8ccd42baf0917f797485a053abad4546b942eb1365a371657614856f167a0f4a7b7d0a9c99e1b8780d0c5ccd56c84e0369bfb713567758baec2dee104cd7daef905c7682a1780ebda3e4ca7e5380cc5853e9f3c846cc626318ee3d4f93a50143eb46a2ae19a8668b81d9bb099a4dcc4b439403fd9d4a4c77d3256daf197fd36254de8c2111f4b56e678fad67c5cb09f2a3edb606c934fdba890796a50aca93dffa6054bdcb187493b5a93708b839e4508e8e53af58a071df6a13c1077b0172490ac5e577027a36934d439e489e838a24fde882ceab087f659b5d4ea823192dc705699929c7eaa33c8b422717364588c176c52101c3e6c53c072cfcaa4bdd555a86f07270dece75698cf9d718acdb99e20522827d83833b09bb8cb5b08df0c2a06425d473075f497fbab29699fb8b0e356b32f9305e3c1abf01a91af35c9bb0110123caee216ce88d1cbc4cec84098e5dc4fe","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
