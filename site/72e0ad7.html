<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe11bb7d9c4c492797635897650482e67f77ef7e4f83b6b89f0531cfbb987b220b219d083841aa35d76ccdf4b957115149a506f97efeae7c4fc5341ea6848ed7420c37018c8d4b64c03afea8a6ce8024a8b26a3b251370e29d0e556c585a8889da1d2167428b35dc3d5c3b5e9fc69626facae8389815f532db2e05d77252adaa6dd9649eba5f3541d11a70361f6652fa38a8f768d5bdcccf7268064d1ca128d2a5a9b611fcdcedec6e0834e3ff565277ddec80686120099aef4c0b9466986be5ac7755b84719dc56a132304fb322900f087fd32275177d762d5c9e73b231f2535f7d643479ef26be1e963d2d5afbe870d1e3432b7f732eb4a299ceafada430cf7da565548fc27d28383191d3958c480250b0d2bdd90cae5e88e344f54870a6f6e352c9993770832b88ca061c16d7e0b838eb1e1d976602bea3fafb2e08c8fb246b53d55d25d89a006b3ed5ed903a2a6799203ee9d2d9319083f4af051c95c923801edb17d12206e016eba9bd9a9d756d37505fb4593cd2b7d7376d6d151df601c825c887782f3477538028f904efe0747db526da4ef273168608525f4b0799a4f1d331ad3c365730bf0aa7bbd4c279e080a3309cac8f1df2297ab5564d7f47e243e61f7c3eb3fd40ea37f85941c0651b2f810a879d8ba4bb48cb0fe2daf98cebfb5d7211091d87ebe1c468f12ab5ec081bb98ee9b84dde149febbcf1d039f18ca783f0cf7c988405d0d2896be009748db2fbcec13551681e3e23e02e13222b335a97732d9634ff3e195e81dde3bf8773d668c1afccce280feaa4ba8fa69c513c0d981b7cfdb7177ddfbde7ab257dc0e9361f403c684d2cdcb646b5f75f3633beb41cc862587f0aaea91453659e9960d8e8899c0cd969ea99eb7bd295000b8d66ad2d8c89f95b9d221f2f7ed3fa29f20b95680f43a8823027dfc0ce27701e3d2c0ead8be94b352ce2340f63dc1cb8e4fadf27e12efe5e3d6d32f14a2d3b0ad4f1e710d79c0496eb8f0f7a6f927a51d60e3863df21635ab768dbfc1de4370d6b5ec7cba8669d3668188a871b72d13401fbe9a4ed5ab1284e7fe0f60be39b4db726ffaae200719922d51fc97bfb01609818f9cb2fc17b5e2cabdc7046012980d9a3e10d988e68e2175c42464d695d3f4f7aca2f48f460e44dfc15b8e3c002a5fbc08e642383e6175155c2f6b62570f0ff26ce67cbc412f005093e601455e3c8d17318b53413c2189a34ad73daa38ca155094eb032df39ba097d88c3ff2a9398c5d81bb15d3b03fde65c9f3a80701bfdc53cd77483e9df4ef8113384f4e597198dcb7d01486bdf0c5eca0d37fb5f9d227f0eae083896653e5c666bbad3502d1224a217a0a3568d62ff4c54380e0f835c4d87d2f50a9413963a5a4ea18c5efdb9ca0baa2c6c4169c8574ea314956c59b2dceb3682ad5afa1dc627025639e6dd6d12b150e0722dd2cb28a98ddb6ba0621e74456462d92cc8880358e06b3245c902c01ae49ab5e41f4b0876d888b42bc7c7f5eb0d92c8fc624756b31b6953b79c603b7b624aa0e07916b96ee2441566d45617a9623e542eb329aaed96152566f438f37f3737c64d918df7f084b79b5cc576e19af9922de231560d9b23914824f8971635cd85150f5a9a7ca4f2f42f858532fdd570c4dee6742cd1d23f617f26814cf61a35e3cc2d7c1fbdf988f8cdc4c61d654bfdd5136ac5489d0dc8259ddf573e596dcb3d91da492912b8c75d635c689465728e9d7553a4d2ce248e878d40943a2919d36f8d94c4421d54a757f1d2d692dd08c091b39f981f86bf07ae73cb997b740ae2035971c13aaa0f67870188f4b047c6d802a4bc4df3fd6d5d63523dfcea2bfecc8a25b8359b387368727ae62eb4be4388eb17e983a593d77ccef5f0fb1b95e25cb030ac56db4162974f90663b0fee081f48b9db576c102eac62827184e187dada54d0f53b87434a8cc67b359c77da8de09b878772ea42fa99799736a0eb29a90f6ae7a61eee86a4010410f737a6e35bc99bdbf7c3ac7f1fc2e762c7d61b038d21091dadb86f87c7d45a70b7d3dce0ba66bfb0891dfe13eebe6f8e16e579394b2fdc4e686db6b5b504c39325e08be83aa85dd3e8671ad3ea8052c0e6fafeb5446e5180f4b8e1f4905d9c5ac80fd579eda9b8feb9edab0183a3b38238ee6b43d840900f5d76a3839a155ffecbe118edab06414023de1fa8be71ab1bbd265aa06665fd117c5cdeab0e637272827092e53442ed67d248d1071afe29e0197400985cf4f1ba2a14962613a74e9cab0ecb82628266036a7c80d69570c367b3c9c8609b61e920c275039d38b135e690a1af80292258dcffe4133e2ca662f113cf8038f6476c024ff70ceafaa47c7cc8b79b4b93dcb49852b85fb3ab1ea9eea8431cc1ece0dd9072e33fb1143d42345db6e90e5d19f4fe5f2ed60498d0713cf9032236bb9bc775d29b3a01722d2993922f7e52f0b4f6aff9cf0a57aa8116ea1b6b214dba5afda39211570834b2e1d27f2bec5b569ac0510ead8de9211296db4c27da789b7b01bbb65fd62ae4165ac2a932ff0b405a966177f29f5f193c0afd567962ef05d9d5dcea38d1d97733a2e9dc3ae40d237cbffaae3233ae2c35fe7931e3e845aa17cb62f74453efcddd5b1e4cbfd80e7d26ff06cbcd3a432cbed9c53b649334e4fdbfe4905e92a55cc00803951095838e3f46f9b181b2858e295b2c040fbd8d945616b09cbba44210577a68dc0d0ffa2450a59e1ecac9902adec7c2918721ba14c672a4fa3d78033564a2a10ada2c52b8f9e27d6c9f632ebd0b1edc41f82ee9e93da30d85161199670468e1546bd64d4f92dfb3b0c6f23cbeb524589f9f84962254fec5e8f9cd3df1df35e17f291e86efb071d068fa699cc7849b24ba9a7b7d80837ea0d8b5f5e189cd1e8ac294613779d6d6b98b0b17ab28ff39cec2ee7d6040b76ce66cca4737788d977943433754df624650832dd9c5b9f2bec357cb3d625fda4eb32191991e906e64652fe4816749ccda29bc448aaab9198cef743df77fe11a0a3baecdf7eeaed4c70cacf3a89873d1588e20a756c461b95879796171da02db82e6574c794399179e6e32b102b23eeb334fba17acd054d83569c7cd4938fa357d37e6a596e1b438dcb6f68531d074a6c068dc18b7c3b3a881b22b9e7f5d0d2902e7a3b74e880f0ba9b854975338c6337f7106d85c4f8144000db0326aca37316fc15c25db077bcf49ea38ad8ef78c2cfe9a6828103691fdfaf143b89de9f58f01ba72b625d60e87198553cadf00fde0aac55f182985e47b4be1d9873503d9bdc4e518c2d88a383e827cd1d4649f9a8d761c5d2edadc4d761058fd049f1d29ac3fa5ce0a396cd8f32bbb802d96464866c1dbee3d43e8210cc63890332582a1cd85f485b840625b15ae230f2304742f3b68f8182b45ad1a4967b36df48ef83efe8cebbf485ca0dcd2285810fde221f2c967a53434aeb1666e33518da70b8d300718254133afcae5cbbf9eb54d3f1999cd25cf6f743ec3812db535cd1989dca4cf0fbe2056703db799346fee17ee38b64394dbed7aedf9d6ab44ccdd4f333f1b3ce5d2effd53661d60968296d5f3059baa5454036f3e76eeb126509d406afc857a212e0c7ed855a6ad412c955f1bf7c7ff7b2c6e6265447db9972e04873a9afbb4368d564dbd2b17603c70aadfc17732bbfc827e18c982a70069865c1601a36c14066f4d95fbac776f43f56f573141d535af729f4aa77a67a62a4dee0df92fbfa31630350b3464e1845049933e8c65de6f1e5b4fd28f657b379c5f82699b0999bda41ff65cbc657cdc0bf731ae843f73b5e3272bce5a4b6cdcea9cd70f12a3b5005119cac6c169f87c6a563e3c54e2e99f8f45b84d315450fd85edfa658c49db59f8d81b21ff5d1e459bbf09c5b6857c4f4f34f626a15700c5115afbbe4f275ffc7cffa1e37d92dd93eadf044e47296b4859112ba41bf41de594ce19fe321af0913893aed20dc4f42aecdf2f55b4207df5cbcf1d2ea98d1a11c1ef40c93928deab73bb8188f7307e8f3badf5a35ffad4858546ff5c5e0e50a0dbc399db7ee1d3fbaf2d3bf940c687c2bcf780e232c3e5ad97de8c90e6a75665ea94f97c491fb95a5b88b64a34f41fff2b11d3a1b94bb399131bbd3feffc64e067451293d2c3c2012e109ffb6d48bb765f66dea6bb804e171d19f6909360332e85a5b94c459d3e6fb2e05110643d078a6167e168a92eeff2eb5e89a9e9e691080acec9c195a0305916f6f039e234b137da5d9004ccd90e5c761ec183926db18760b0bb96667c38ac05b2375e637886a2199e7e575417a883dc1cfa45d6af82e04f279a7cf12eb7d1eba2a4620e5995c1a439bf05f28b69b672389c4b2be448fc87d04e42196c55a023c451799d78e6fadc5e1a3dd0973790d270e8b6d37cd85009bae8a1e8802433db8a47b76d1eb65c3386a2d8887d255430c74b8d454f5e3f97388dfc9db9230beb4aa71f1688b2cbdaa4ce2fb99426051aa96e50e90ca22b12cf98828c99bdcdab56254d1d6bbb70dba2ac120d496147467c53bf98a23befd6fd757cbd5f963eebcde0575e1c58ab1dc3327f9ebb21ab4df08d2669de2ab96e061d0b9efb3d54f70bf1df0745b1b1cc25857dbb4dba4b150cb29818c116cabec9fe170023d14d15bb3e06514ae2faf1fdb99b56e1505d23284c78a236b6d8e7a7241a48e3271014831e9a9baca4f7dad52699be800cc512758f2f746e9179b8a1a3630e0a5a334c9da053df6a4d80e515f4016caaa51549405e326bded7aa3f912af734ace79cda403168f01c5c286cc55cf0eb7f9183a72ac20f19296c2585ce3f74148d37ad1b97c797c9337252cf7206111268b6bf0579263ca2515edfd67eee90a06e59baa028127037ad75ae9c65651a7f9c001f10a565095581b34f3f9bebf1f15e981f604df0f6c9c1a48f0d914e185f0944df38e60dd53b7c201399ad39b823bf3d58bb4d84584b750a83fe1933afbe241e0c6a1e21099885e645c6031ee83704b4719d8c8ac10af727b94173334fbd2c6900c33325fdd92b746146982935435d5eb91036d22c046f35d9e9cb61622c3f23f58b7f3ffbdf0b9dde777fa52f7df869cf3122f2e99184d3a00fc57bc24fd71454c4d0736325e33d04683d2e763c4b86c557ff1371e47929e76a985a6930187b0e466972b7dbd9e775b6ee3df01ca5ed6229a7a14d60febe965535b0fa27d944d58a04bcced2b76373141ac71d9639c8161f987ecf2e7ed54662ae7951f64fb03b22b69642e2762780103eab52c1753c3fa5f341838fd4c4013c30dc316df634b091c576c6550bc7b29a6de430fbf94f71082c72e49229cf8ac7f87787795ad73556e10d93372efd4550900ec91bb41673748a18fd80aaa7181159edbbec00e3ca5710c3a304f6b91c28bfd507fe28c3fd0f54a77432892c980ef18169b7934e9857581a307a899179a379218beb70d7b11c8d3d38f4cd58705aa18496f08de6ecab2c21799a7452d5ef42b1d9c3bb717dbb826b2275b930e5d6e046e2d41d7e9e0a5649481894839144f000ab1261083dd574bccb25dfb865a09cc7722b0134b47894a3469387cb21e70fb28e4c7b24f43958c9f6d687aaaf9d43b005dcc676a6092359ddff20ec01e56ebe4dff33637f3abf8e30a35998c9ad84e0d59856ca1be3aca4f7544d74de6f24ad21c459decc2cda99fafd0fe750ca9e791da02e875f223f7c3008ca4cc02bc52c9776ad44f9c200c0bb1705ef2538789120bb6eb1a9f62da2f16e73eea6e121bec675585125d50831b1422d90e434b003a257a8be3f34e2a28e008ff65a50f288c97e983bbebdab1d7a924cd32fbc7fc1b8a380d95013b25f8a19dc6200b7427b277029c9f6fb571e874fd8a96fd638fdea2fa32d135d61d3f528c34b9d004f3896ee176b614c60bd238b9f2bf8f2a0e81f6748466763cf97e0e2ca8081dc67e26264607e07b401f418865709a586309f1dea43ff746580ddb5df192004a3f746e8d3d4002940312467724bd73a70a955c58db432118caa275bd07b962ee6780e90fc3e103ff7a604fc074efbb627dea1dcb6c61178550952f96d78c70f411b66991b9ce01c5295249f96a50df4be675e096cf4e694709ab59b3bf0909573903d0cc1d6b34ae943f320c90c5cfa7fb844c5e1c97cfc1cee0f2601c1726355bdc0683df9fd3eb502ed5666937ef79fa297d11b1ef3294c0bce502163d7604c1d184c2fcc3fa69161e6912026de93be3f194cdf96f16f981313ab5426eef989e9adeb00f91e942986e8b22761244bfec60b239c64506734f01b28aa4de4fc2741983c585bde1b5ea4bb0de4ba6ef053ce2307748dce45c001d051e5023377cf2c9b222a052e279fe53a908cfef99d55341f3344b3232edb5fabd423a374a98e5eaa86a4aa0ebfacd2bb7fb9ec23e563bc2d68e50c79946780ed6014a2edb53cfab9dcad6d54c31276deb89d18a73d36fd9c6871b1dcec382eb764d60e63912a412efddd4762a5a03b2f2094902cc3bb35fd942f4f0678a4433fb04c82f5e779cf9d20ae45f85879c2dc727f4308744feaf58cc9cf681b722db54a40c653315c52986b3663eaceca2ff634665b50da15dce97e5869806db9f7d8ad84e19e177543cde1bf3589bf29420cd450e4a1685a402f00cef5b520099b99814f8c36adebf8d6277cab9ffc5effbe1b74f96cfff55614e6dcf0a574787ce37b87300b4f29d5a0a6f8b28db9a6dfbdc77365350fe9bedd25f77fd9254e8f332c7d200a87ca4db2bce8bbb348c58215c73ec09e92f4ab5c196ec3bd08fb3d367f4f5eadeeb7c201f0216f66e426f13055aff6ae8c990f208822ba904596be17a95946a801ace091d3bb204f2ed13bd19f80e93ffd57920e08820f5a33a263b9683fcb313fa8940c50e1f24934ed4919b98cb7240d59e3e807304afb79fd64e5b01b8b261eca14028a0e99012cc0613f424722d57ddad181b2356f241c9c9103c945a099111525b37690f8d0270b1aa3e3c2fcaa7f15fff6871f4ad7ecfc02389fe8f4b15a9402a668b0ad40f8aeb7114821eda842447a64c1aa1c6c543c29fdf6acc704b7b4d411169b3137ad2c720b2f319575d8979a524ef7f1cc53579e2b9e2e855c35b4306ce0fd991dba31e615c5f6adbcb7600bd2bc6cd32d7d2e63816d5999b8566707589223afc5be73a522ffc5647d74c03f659bf7df7ac984eb65c3601b105ef3443b9058315ffa36f62c4d831337325dd4da3b2a83522bef2257b02440186f2de4fa0cfff9bc8e7f73c7b7a3c324f900dadb19fd4d33055438c1fc825b1771c11c9a2de93ecf6f0eddcbafb3df22d0a390a4ea7ad31f1918ab9788230bd8550d1b384821cb4198d0b9709390a9065804a926c64c31245508582930a71f068b9b7623b56559643dece876baa252432ebea124e8aa39da22143f7b84f4e83c9894a75a6b14582421acf3a61ad7d0f4a47c88c44d376a03acdeb76190575b2cfb8c16098f4eb8ed5c4f6c4127ba05cfbe0d8450973afb1e6ac5b76d18359ab4814c4e553f1ac24581a4c2e40d30058af57c900be1be7c620e8d4df36ca09638aad1fd012dff3f01436a0a59f6d3c50a0e25a6a9e8eadcb6b94e7f55cdf7c15478f4980dc9a570b3d8c276668bc041640893ce38994e7a41c6fa2c5628225cf46773d478ca6b1be632e19087a5f9d15b6e608e618d48f50e9e2cb6bf768c8d14e52a176d1dac47ab867533719bb7d02459b3de98230a47a2c39e5c5f882b27a021bc2c8189c9b8661e28981bebe1f2eb1ea4d0c50f100ecb48aba204871f88dc0260d400a46111c6d650faf555bde194258917c095920e6b7c81dcc20aa511134506a655bc9bc2f6810152983806da4d8f2c8a174da67b15480d5d448b69dcbc7805cb8485a4434416e337f48536aea1a068183fe0377d22a179090aa4e5dbb8bb49bbaee9f9e5e115a6850b72fc9bff80430e1a431dbad088f023ce2423b87e6eead085867ecfa337d9febd784babf15a4ab92f773e368bcc89fb9c90945fec0189c02bf8198140f8dd5b08dad31b84275f6ec959ec750610698ba3814f3e5471afc6ac7726982518d9f69be9c8634833cf99663ce712255338380be1d7ac1e32904fdad8d60e5b5f79acd90c1b1a8f70937ae82a2bdba65cabd66118814721effa097edf526afe8a6eb2bb2ce2d3526a445ac34f97a875bf08154a01edfcca7380a0660352afa0aac8264c20576cfcb8f0d15cb59f46809b29ddf380f6634a36b3988427f333e1f95c34bfc1adb3f2d8d3daabe13b69a91d5351824cad2d09b7635691f96588dbdb65391fad87354bc1b6c8bf516b1baa21bea92cb7e94359ea43f96d68d06cf9c91316dc81090cf6d3325f45a80c95f9f2aa649192df03a6748b6ac19d94ebc3d134bada0d0a15206bb98de45c7c1f4cdb6a83265fad3a10f1db39ec70789d4914577b33ec16df7fbe9d03c249f3200a650baa5a1aa22660db5cc58c9db586ed00e099f1ee754122e03c430029ba26207529742fafba15d6579768996fdfd103090f5015ea8d9a02ac87d4c47dda816624313e1b4a111ed00645e3b8b1c4b5d0e7bdcb0026756106f8314c502ba8e21a9854ced33c4aa279ad9586ff883a74a660b87ce7ee7cf91a6eb27be7b15679683e8be852047eb99b4e7b80c2d0c7e1dfb36d62620fbfc1bcb1ac6e6d8106c003ccb207ad8919381d3dda733057db27f550fae71f2a71ee8bcb6561cad45d9398255339706d6f854d8b962cb805c94bc2db8490d9f9f57377b56398bddee4caf3a0d0cf2fd8ace45f6c247ee2886ec556fdceedfef5cb5e25c2b6f75a92be0a697583d5399fbf3f57ffb1110f4fd538a37e96b4263d4b74dc197c40711a144432f21fca40d8f899a5aaa474b1259054f47fb7b345711713d60e2eb79472e781a5eae141d920c9b9a5e095c20545129b3cf30fc4ccc7ea6ecb0a4dce8d5b3aee286b7dc7e7e69baa78e0eed672667288f6434dac32f22dd6532a4b177617d77fdc75efccb46109e5467cad40e00806fd65fe7301fb12aa78b6bde05f443993e3be3ea65d8803e3fa15052c73b0f50638fff98c4fea7f0c6220d9f80364621b542d8bbca192a9fc6bcdd060b9fb8d16290a7543942ff29164aae8dfee554e0e170015926d31e18f0e8cbe066772a3c9e125010cf6aecd8147754d2e8dc285f70f54f35ff8651848f3a437198951daa852e7099b1e4c14c07948e8b6dd80af053df971e5a73d64331e3ca799679d17204bef79719007091e1248917bc2daed3228db4c7f5e2f11f1f93aea3a8fbcc5f87d870337a371819c6b6b5fcb897a748c8694da95f716169e4af8b38dbf1e004d7a377a2c225e69884466194083d38dddddb026eaf5ddbb476b85db835da09eb7a59ca1004da3792fea0d089196d9609d99614b14a6b18d177e2199a0317f84e500c161533725c3eb3fb31cbf937a2617a68465d6a88dad2370c91805f1b8031cab77ae510362038c824bc8ea53ca596f8a544d0bd1b6475759a7971f77472f55853764128e2185434131efc667584ad9676d2b1b26739d25b8fd4930257f297a2db4bba01a40ae31a3979d8c64e3962b62d66e8d5a5ffd99be421ecbb8eeed9f4ec45e7668eea0bd428cb933a47a73c40e6290ef61e5898171adc1baacfe01885b6888d583674fdf4bf4b2815f35a9b661e0480851c032eccff08d47b55cb1cd166733f089167a930d7a2559a8dabc362cdc39e809335f2da3501a7ec115bb75acc4c69c2a1ec840c01dd7cef6f37da60cd493f4f1850e71bcc3f1f2a041e33a625201cd2a927d1d0fe7b7de95db76edffca46fe47de83ca54e6b00375f900882fbad486eeb9b719a65583ec575db158abbb852700e05a3636684271b24446851fd31bdd19cfa894d4bf453b591c0a9cfcd2af9186bbd915b13f43e8b9c953a3047c51afa820637cf57b9c59ae0d1c0b427ad61efd87877172a4bee62e8b1262d37bdbc998c49fef9118d120d2d1ec514999df8a12f063bf0affc469e75cd51ee01a1da1bf55b20a4d838a015dc86198fe48b21b63f58e8e418b06aced20747f43779067743ed1b7b0e77248513d12c8b3b310c975db5731a1f0299ab44e6b69f12540cebadacc70cf5652641c536d384dd501b0c7abc72f0e8821592274325fc98d7038200c0bca2a1100195952dbd520b765dddf85a5af7f916f38d8476a792aabf301dbaf73df4ef9fb3fb52e362cbc40bd9e5708c1d4236502b9a896c423141c4a4811a1295026c8be8eb0fda26166a2f807d95555ed4ec39a1c3dea302dd01b7c7dcf8a231bb7f45cb1a79c29499aa790aa510c2e2eab39cb9453c9073e53a490751bef01b36d5a778057e83ac81f64396aa1df0da6992964c328b9e2aafc19596b0b900a9991e4c80b032b222ee8d727eb80153311ffdb1003dfe9ad432a60f96c43e37a7a7141fcbba16db7f8f1b5e0384b2defc9f1eb09a2f3a6d18d1c4de696ab78e8427c12a5f75ee7624e062d5aa1d01ffce305386c43edce6fb9fd306a97af1848ceafeb4c70accd24f43381b78ccc2c72115df45df9baf427f80f7280e95e9b095a3bc92ac52b2286f6c01200c7e648b24476901ffe25776ec5772f31f97030e6db642584709c94f5ac66a97f55749022af5132dfabf9ea050761c8df0e83ac77118865f007ee29ca59d3772cf02f4bb49b5980b792d9933ac567a016e17a0a8242c75e3edb5a54f531cce7208f00929721e9f3884593b972f4a29a4470bdf5b3feee9462f3c22c16239cf04849e552a785b87d115b44c8e7a15b5adf3bc07c32ace93fa9cadfa22808e8c9de2e1b662e69b0861963df61ebfa8a4df0dc37f8ea52be0112bc79eada415bf28bcd79d4bfec44e40c7f8efdc81e83716eb2fc8c06d44f288d306db4fcae98081ad79cde42d92f81289e95580e9db832fca9eec95b66ef1fb00c9b69bbf2bac3dcfbfe5a192d8d55161001583c34ae85d9db94d22c1ee89aa28cbebb14547cc19e24922af91eff4828626c040b2b2133996ec457cc15812868d4563160c2c30975f7e6d1b2614e87b37a006c625adffb100ee6844c3e3483d56b1b236c58ccbdf13483750633cf66f18f840d19933b64fca633f31bb767c99e98e9dfb31f29c3e187b72d52c0bb8253ea04ebe001bf44e0c3de649e9c85b669e5a4a0d301dae4edea235a3a50861362138f923391d9670f95e4a8dd334e758f4674bbb624908662d5d7be29fe2d0702853d4b1e2f60b59dfe106e0ae60b5e25c4b71c06c016f249e361f79c9ffa6bedecbbcf1db7f2e86169515d667b2b89f65f8b652ec381d11b3601e6e45dad7f9100a6b26ba9356baec470bb1af9e100df1f575e39923f8f48d8cc6c9b4843400cf8eda25193393125b030aba6deea35237eb6da8ce036b1ea70a7184464394fbacf0d00b2d08c1fe18645a5fa59203a66f3af8bbf48a88b762794c02ff479e13dfda9e72d85931d34346b9b1320bbfa8a5cab4d5fc9762f174189c47f36379b05cb88b9a730442711c95eba8b4575ff15e2ba22102749fcdd4fe0e5ecf33ed472db6be1ec15616ab1219484b30bab36da7c54276fd55f768edb527231a9fdebbb5ce93a717d4c6d2f2d5b58f0275f857f282eb27cc825273739899ea71646ee1fb318a48f533761435ca15e03e7e882f4d06af00da9c9be207926d7d2991afe50c1a8bbdaf454e6c90d517a71678837974c32b15b03b10ed0315a3ff03fed59fdf36d0460e6c62a31f713eecbcc40a5294aa036fc1964d05ad716a82368af24ce7c7a2fc01a9b9d5364c06527a5122d67e386f1e2138361c0e6f3f06294b17bd9e0c8467f4da7f294126723085e5e206ae33b70c754370c0e109a00393bdecb1cb3837f468875b68c569a2671c600d9189e5336c7d998e0df5479450d757a1ff66bbb1a1e624c2f04fd7bd9feceaa62794d0c665e5aad427377c2a77e28c90b179b36d0afb05194d8590fd23cdc00efd4ae09706b3e1e5d77195723015d961594ad84e2a157eabae016af389d10eb6aa6794f07ce8dddd5fb0f61aee96684ed038ef077ca40c72088547847bab0b212ee568908b7c847a618f50bcacc3d1b488e7327af07247d8811c7c0c8d1fe00aeb15cbc730c856ab6bd9e3e948a44880a59b13230a61cb770238937a45b0b42cffdbe0ac890d2d52650859017f5b920033202042567b4217852438f17bd36764073cfe207ee229ca2f8886bfc8446dc47123382e052421759a3b6e9224d714dcfd0907659cb0349dcd6b3499bd9bd396faaac0232f2dc79354a286db10ac809dd2e969db90b77a79a8adf9527332cf5b440fee3c0c43996afe60a79337da5120f2e7c04f220814ce88a517a71d07bfc68e5439edce265c0a617427cb90cff7e5bc9cd0d0a6d195c2ddb08c6d2f883ea67833e974519ac01b3ee9f2fb001f1594b13817de87ef60765bfd36e881500078dab86eb66aeab3e67e45830b3e7452fc7889e8e97a4430b616ddc512d9dc313d4394cec992671d2475cc4ef8f7087cd32d1b6db33498e2ff011f1a2cf431534e0e6637c9b467536d76f68a08e53dedd65e267a45fe76133f7e55efa00de45e06af447f9542052f04dc4e97b8246609f830011af3deb6c2ce1cfe95c9f7e414da48ad4dfa0a0ae85abd0fe2ce46dbae7679f8450254eddbcfae8a4f7c6a3444a1248f95ec97822810710e3186d5fa37f7138c83d7b3416498ca4209d72bd8953f8d68451095ef8436d776fe8d8669fc5b1bc9e7004b1bd5a7b5fceeb47b9ffedec32cb8e3f9947dc4370919f9c227bff6511917378c168cbecdd3476a7bf9bc3d83b9734cee3220c4a5412078904d26f8efef752533236b4ef07dc092b5d0cb54423aabbafce7ec58afe79dcf5a62bd415266ce9259da78afb8529e8f48e67709810c937c0840922c2f49c3d8e63f41920245c4a908a65508f90eed1bee88dc4bf0af9133b42dbdb61d7bfe65029a771dd9780760de9d6f039c8c74df41a88df82e1e64197441f44a6d5012cb192ecb8dda7540db064e93d0ac87e50659b211c83dc59cfa634d3c66f5a96de1daa982e8552a33f64d8b9564184585408bcc69c4156092d25020d9a05a7b8016ca18158fe2d2bc7fb4c3439dc","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
