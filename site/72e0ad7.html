<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e636157994b0114b3427d5392d1ed12ed95c20192e3326002932736e00cafbc1e7acd3086fd9914556908858c428699ae99a498568e525fa6458e339cc4f2b752009d258205baa4b39661f526bcb10116c7514c688d42f60c37e6e25fbc7f0c3504d84a2b72a4b230b148f719d7411051893f84a471858fedffd8bdb6be93108948fc78fbfefeeb98663c78d5206aeb664d9639d28b1daf8a89b5d6bbb129556eac9e77a2a17f0200ceb5cf7ecea86114046a8b61d195e405c1f8437f63302ecefe9e737f14d7258c4512a58b2c2f814dca2baffe39f80a72448f551eeebb494689bacd9183308acf4f6caeacd74e03652db4cd8495843bef0e53a0e5dff9cb60e9854b9a5bb0614f8126194aa168f1dccef3570f8badb20eb6e66faf8c5e364a283376f3fa7f1ab33d6fc313ea668aa76f2facf99353ba653d19aa28afc63561a9367bc41aebfb1183fe4eaa80806e0e9d64a031f80d62bd622bd089ee38a8c5991c538336eec665b78e55c935d017a8fe85d894aecbdf043c8b294525114feb450c00845398f66cdf02020fbce45ac36da82d51c604456bb3d853cbefe698ec6b6bf15aea9d2a1c503d6d7c817c9b584b8b41ca4c3b9fb3817fef27238753804acd66bd62e4904a8ad875b8cfc14dd2fd510d5c7de60e7424f4f9d8c7828516cc97e2f9f18481638caa942ba949df8728effb74eea824ced0a1845fbf297babf76d522411f27077152df41b4c86d00ed6dfc63b4b633a688116d137a70818ef8106432481df97fe6d378f62dc32933ff257dea3e83fd519b74ba2665824c22ef7ab96a19a88a7a41d712f3c64345afcae33f8b77310891f9b3dc10a9aaea84f91fae68471628f1e2c985bb4d196b13ef4c1a3dc0e13f8d14f862cc0873da30af4e60a4c6023455026986718c0387dfd0fe8e4784b3a67fefe3f8900c1e9061789418781404d69c97c942897f71e36e8eac7db3557585ee7051b3dc8241617bc4b68c849c34a3d4afa4142264e3d92aeb02f6c7381e637c536b62de3ff50e81660d791fc9a50fb9bc53394c2db9f10d07d1ddcf24b4f286c57ee4dc1a7c131eb98300dddf82febb059a39769ffd1f0173b2ee18687143200e81a9740bf7ea8eb86a964f105da72726986e1f35d79aa8d8df77cdff41992c3eb7085f321dd63d3674a10d5bfb6dd6220ef66286ea2be9a2f5bbe93232c94aa415eb25e859c4cda7f16a999263701c2417b0d934257099dfca07cc0d0295f7c7b2ab9dedcb9a4fae11d2eab6f46da7427f7934c0b29d06b37104a6326f4eaf67149473afa006da50dae0ca2b74fd3f938ebac7f398c4a0afc56c71e020cf1826cc77d8e1397bfbe2cf25a03f48a9c0c4916906322914f135bb61463d62a1b28269d46866135ba99d6f64be2cdf0374eca8f7dfdbab042a3735d9f01d1bd29cb6117a5de2dd65530006243007420f017c6dbdd187f6a0b4a5d7b4ea6954b464a6b66e7e94e7cbcc00b5a3e865515d8b58ee8477cba2939ba7fc2631dc558680efb9602fe94231c78a0ca40a3289b6a0374abce4a70fdf59348beeaea69861c2056d1f6d10f4d412aa8473e5831f69f16a9579d7241ba35fc22dfac3eac5722d177c5748890b786c1fffdf003481cd59e81909a3395f299f6975a5c4bf6854c9502528667d03cf425c63d5c34353ea0240985519224adc12968a4a1de9c63c402885a79b355afe0ee545d9fd2e354dee744a20027e8eb5ada4e585ffd63746fea15f6182a4a7217be7a82e57121d8769bf7c1e95bf53f5ca5fade325e5cfbd2b17fc1570247011fee8c44d30179878fae1789d1f51387bd3d0194796a7f04bfde665ec548d0db850465d22fafa3450f8da6cf60e2f3f17ffdd9783471533d4507fb050c90ffa936a0eea331913aaab35bdbe74b872b47cccc92c7b807e9ef13245533f3a25c32c84ca9f1f6d879f9c1caf046d67417679c33dfee5f317670995eae72ac62529500b903eab25aed0382d8ff501cb2957a444346aa4e187bdcfa5011bf68ab7fc39f98b341cf269a8a5e5067be7ea03248f83193d357e18c4b0dc8db10be503892a7f11cda6068111783578e91693d60d1c86cc5a74b5c3f57756d69073ffdd5fe28d0076ec372f6250e975d76e18bbbf863bbaabaf4701987bf14600feeb0bffde580aeba99503666953361fcc32f7a512d41b923a3ef00565d06f81a0ff78d52df9fd2fa9233a751622c761f8e7e0e08a15144b0810d7b9b5564a173ffe76f95a8a7c406f68a1e1e924d7c4e1c5288b310330bd0789b48f2a346d0d9b91027a9c5b2d233ab5beac49079c44483a6d73e96bc63f913b37a27977b0813d1dad20916904535ec65a75f2d1b8eb9353f34e3de4ff056527e7e2b546d810ca1732859669f3d928a245c63cfa0560bbf72773f569d7da0f8ac8fbe515d680ae63878f0d8ad84b39bc32e2933a1e79be0356337d014aad63fcd7a4aef1abf6e04fa4f34f2789053bed33df80f47543b2c85331505515a1c44fd1925db163e407c11b3551909241bec5e07351cb6315f9b01dec3a2d2063cd9ec471aec94bea05fa19b32b56f3838cf94b4d93848021f74ae75d4eeda167e64e3ca3975087cab8c4041c54b288a69185d0f0f949f22d37924bfb36092dff287b36a2d71c628e81b78d2556ac8f4d807aee5851aeb2603b3937eb60dd72695ae095c48b57a707ca8b5b6c98b144ee00b10ed3d3481f7041c2de0054fc845b08934e5303698d3aaf9ff8b845efd35ca3f857e4a176502cd600696e8ec7f88d484e8eefeb1e6daf7b124106b6ee1483c001bed55486e4c2d57712b554b4b828a0176d97ebaab6738a4c83e3188392b3142e32104dc18305cbb07263ca4bb118fd340a39d014ad3c6479d779d62f8fcaf8b74d07458b70fd5118fef7078503cb4c81f6b77576e185a7adb045d7b895359d2670b87c43e58e9090014b05b52e736020c96e7f0c2673be0c5f45428ffb382a3e5c35925201ae4bf921961b22d1d7d5f16c77b91ca84c423d6e7c13f5ba35591ab89a0bcad16d81691cb412244fc18f3fa2bee56df62fa7aaab1de697805d911632851a481d5615258321f214e10cbb78410754a0e2cf67c2a59480044558b1b37e2ebe2f4073b8bec47bc27ed5280d90ea6ce58076b54e8aa39b4d5b7c408382b6971d07ee7525f6c2689b5c6adb450714dbaa7c11aeeebe663700f3c6e678fb7294f63fa3d2002f714d5850e7faae349cb78e1e02206be33911feef62f4e6dcf613e1bf62bababfae61879208635db10038df6600cd4cf522f50de58a921ee0261ba8915a683440d09cf49d0a9bf9fd9cce261d42b3d1413c152313f67355e8e9299140a6bddeb73aa0087dae8dabfedc829c846b3e420fba5c442b4e05c43b1b084604a94a2a860832fda62a17a7084b858435fb37446ebb5b318e6c238f4b120d585bc8d978039e4e60bc0e4970efef964bd611432c87566644313c426859b9a751f058fcb26c1df663f35e28176c9bb10a958bbb0b976b2cc308421d9ee974a1f79d1b303ee8e3e493b503419ddaf85589f527c88eaa9cbfc5b30dcf9c25a7775cb05a0c8ef5ca5b9c720220a84b04cef756f32ea7f9e09eaf28ca5cb1be5dd18614fecb0337e26406dd2c8da0488104acc1ced598d5f9f85e2ef33e7ff6a902ea66ef8529d1da3aef280e2a65e1fa49c7324606b186fddd3496dd284a1d0431664b185a9814a8c60de52b493f6192204a17cfa7929f6447fff1fb7fe4b3e0af5d25e6fe68605459efbff286e482060fce25a06d06d985537405d50afdd0646bff9a399252bbb44270bce54ffc8ab846949a274e58a86fac60fd57517179044f89c9e972c588e00d6fba14a7a7f40d47011958cae032230871202f69c77a30b7e288582669fa34a29532ab2b382a800a969be625911f82b7bd539428b183d5a37234e9d781ef304d793b4d5d47111aed5609db435af4c5eb5cdaddc87b42244538b98336b5a17405b01846a3ff4aad51691228aca329b8f2f148816152dbe46f7fc9d06f14ca1b3c1c15c38a083566a5ba95fe36d97390903931d7102bc717fb5988a1d37b1f62a7afea01a6349c34a7674b9f1d7f9268f5d0c4c282d5b30137d960cd9bc70a56df1b80d2c32cf1b132222943be68513f39f853a3f309d27e1450bbac87dfc3a666482c0958b4f3d52c85d03f7e47ac6c48a32a502f53b65719c0065ce381c5c2f2071fcf5642df767aaf988c4b78152f9f125c39850bf88c62d7ddc1643cbd737a58f17d275e593e79e7649976180394926cc7844b03fb0b104f57859fcd58ccd91fc87028045b4e28243154a110a5b886a3e687a5eee1dcf0484d8603c9e30217422999af72b945cfe6941d85e876a19cb662c6474454fdf3c84106cc3585ee149e489d7bdf2044f0c57d2aa91c761d175b30f2de04bd49c9d3461b944dfe298f366fb5f093c9423bbd066202c0af1b7cad62852d972d26baeb6981d1926ef2feacf0e0c375ac39139fa63243ec1d0390232a281351de77d7ad15f911c51d3a7579eeb6a1a922ecfc97a46be5687cfff04b3e4e6cbe283055faffc257fbbfcea1665b709f5f2f07c2581d9732ee3861d73d4d0d2f4eedb72575031ba4d1dc231eb47086545294ff2413998c9800d44251fcf03f6e5b1a3f5667e01f680eb87ff9cf8963594b4dfd69500c2d7466b0d5e3c259eac6c8ed1cca13485be1a334cec8b144836da967d646bc543540682ef2ec6b92d423b31d6b6edce34f352a57159b828b9e8a200911d51bf3c8fb5b798ce3fe0d0cc70504885ff33ef16202f132d9417c1d6bb0d2dacc2804a09cc4cc2cdfc0a1744e3a5980f8ad1e1335d2ab6c207e205f50f029d2e1ae35ae1cee008d0d326c1c0d14d72c10378d99337b8d829a3d1dee32ee37bb109481e1fa4ff04a08b1b7a8298051337054ca65976e35038ace450fc394d8c1e003d17831bd1e5a9a31aff63e82c7434aa6d82aadb1ccd5399991b7f2ac6178f3ed7958d82e71dd09c0cc6b9e43bf9a0bb9ed2c6c4873d133fdc9be42bea792659a32a52409f22662d397400da211c75f28ec459df94a58565d78745530c7c0dc7edb4b149fe1cc1ef378786cdd83d17032e885b6e701a01eccfefc4b85e51885c700e9e0d51ab2a36e6067d6c4c21de13a2395c10b767930bba0ff9011a5a1ac96cad84b07bea33bf65d33a46a344a058bdd96bf70a265f37024e19bac262ac1b659c2ed78c2f3df066a184d50eb57f797bc8193cbf07616128934801d854dc029cbc1118572e060c1196e3e42521aac51d037831d94e455cde4e7666195a30122dc5b629c2c83f3d5cbeae9a2e423dcc4c9ddf52dd2c72054a31100031d50c94077c2482d3da153f2407388a858dcab312e7771ffacfa7a89d4af9bcb2120074bd7156238f0d4dcfd4dc2e7ff2781b161961f481526249db4679adfe54af8cb739e2afac42255bf21284deb467c7b4d68120c22a1e97060f2dc9633267c8323db9a3a7d934db62d9ac644124d5bd530687a934787646d5d5093ded42930ecbf1221176946de22abf4596e07721fea1238fd4e87712f1d01c988273dab2ff31c109236a9147a0e652480c2c83f2512c2fa29ec8d7aa18c6585171ef47816cefd376aa9c752766a31d5f5b22e71a248d5f4582baee82ad383f828968d214aef7ebd7f87c03b1db65bdacb9aa3dcb5a09692549cb94486a2d69a27a11c992a57ef0066e5787f7547f90e1a7c18804e24d5ca1978af9b7022a3be73a731541ff1823a328026c0d5de677fc72424440520f9c7af5338cf39de214c73c310caede0531e18d9a47c846753ca0f249abdcfb1a6e55bc65b7673eb6cdf1ccf352db2291add223291e117ff880f663eaae305ea7bd852ca6f4ec607763121565fb16fb771536da6f711037fbf04c3ab8d55991727f5c17e0dac099026a18de34104f0e5c37f7b97c0427efb55d993f1113512799037fe2b467e9bbbdedb95615bfb07c8c2e4a62a148d5dad76081f134c829a9c8513b71f034f0a6d99e069dbf895564167f99bdfd939f5bb08ba15084a97cbc572b4d552a975c8c30ccfc371e8303490d279eaadd5b74fe8c0eb27216b468dae4f2c1028d4fde0d516f971ceff5452405d3d43d1a5ed1a835b23d941dd8ae5c071c0dec9e757c0017e6bc0257d1903615d026a599668f8a3e4a653dba01078288255078c6df5629ee6ed1cd72ae269b5bf82d824ea0e2f3c4ca1fda025ea0b135a485f19936138251b571fbb0ac7083f028eab8500ebbefb1e95eca21d23dfcd2483f8ec8925894be9b597899cc8aecea23fb8e7021758737afaa628ebeb877eb3d4ea3032575df94fb7851d5bea7f2a634538216eab6b7af3f7d23a105fe9df2b1e7c69c07b69051496f8ad2311a10f0d3b85dc2ce44231e595a16d51865a9c650ca28b7a6d27018b0739961b6a06c86d20b702d577ac58ffc965d68c3ec1c7b3e4186c8e2c56c52090a91447a1d9ac7b21fc9008673050d7cc53caadeb5a4359736643c90c38c462e13f98a1e0dccc64e32bfa022b3489cd6c509cebbddaeccb1058cf97a816febdbe344a33d17f814c908d34ab24f59a959de87e6fde978cec8354932af423bf9bcd69db894c9c9264e8541871167ef567835deb9ea10bcfb5e43a7c033b3a4ed8cdae1eb20b468adf9680f3d56b71262f3c8392d5e60cc064b37c3c9510a0b6fd3f7116bb157bb75b90f11d120d9a7d929939701542277017982ea2835771c52af878fc35e4518fe41f8d687a15c7b2d1148b82c8803ffc04dccc1dcc1684cf83228622601ca42fa1be29de923d5143536dcafd50f5951085cc56d7b9fefc4410566a09f8414109dd24efd88913c0a6a1cc10e272bbc5ea83b396711bf676644b9fc16d84e95826e8a66b5fad326634316b52e6318498b0f30fc5e2c836c94329cc9136838d0a6fbd451ef16b8e8d1bc6a6ffed92e21fe3ae13366f4d11dd33b8e2a79763efd9e123fbf0dfeeefa68f0cc6a2d699bcf447f7a2dd7d9d38cb663d16e1bfc29e6f37add33d22d81a6249808ed282268ab4b4ce1a40a7cf7bdb40e77a782cf8b37c0be496a4943395eae186fbe2f51e146e0930ef6d4bba9be122d79cffea0d13dffefcc75aa12bb54a84ec3224386770efd3146ca41e6fbb8c09e82f7627286d0643f9883fe648c857222672bc7c77a9cd10586a17f3fa8260fd96500166b740726da978fbe84628efa556826e40e38214520cd0f46e594a0eee3d9c67b9b8585650d5b1945e9dfd2a2f77857cb256c233216325c7c7587134b47c73e14e1f37d262726640c3e12219aaa163c9569832fe45c392ae4f843f1ba3a2b3fb08d00b4d5a891546945c81cf252dd757e86fa5377974a0e072b98b5bf6b4979742e1f2c903b275666aa18837bc76bb2428b57bf2f5b3293e4cdfca30f52ae973ac6383c2a2f8217ce904c191bc5527d1d3d5cfc530f8af0720be00f31c26ee296daf0771f47b26e31180eb58737f2412d477eb95ac0eabe3ebd0abf7d206c1bf6b16426ce7ff8890ff350ac8c3786403b14a70aacc1b4b3682b573681c2647a205b65d147f609497dbd7ad5d998ea57cc5d2ca97cf104bb412efdcfdd5b0a0a92dabaae54033b7f2d5f1e7060d91174e90011102109547711259d46ac05af3eecf5a19911fd558de5e664ae185d34d01fdd8ad14c32a0fed3bbd5609c92bd0778a17ec5a3b5705f324511e4627ab1159f85173dd7a6ec2b21e2a841216aad848644df5f483b32007de0afc1c2b3c7c8b1aa6ec3ec20a1685cae5a0e49c891c3635baef4fb3713021d19f3bb22e7b1b5588cfd32e22eff591dc48e2dbb611f2fdcdb117cf96b3dcd681f825af2a838e266ff0dec0c00f2ae91ba742d069d32ad2f9e6f17984fae72ee1ff0c150669efb1cf28aba68c417fa8be75dbd77076c4a2c7d41bd881d81b485f1804006c047a5bfae3ed5d60b917092986277ce9d0261544d623b1dfe78f8b07163cbf26884650b791e10cc9394871a5ec5d169932c2ed45a656dec30fbc556ab5e0e8236b34307971b040bfce3e188b971c58e48ae6d4f8ca438bda5883440c57acf3fa9adfa1ebe1081c8ab0d3756788ba29bc2cd8e1d64642bb69593300f4aa37f35afee6a3b5686307224b4f667b9f95387e0aeaae00ffbf70685e5028b53efbadc6c96a42d6a802bdba3df99cb2a10498200b2744ee21c64af65b9b38c7a38d5fb43c858f0150f8524e220aae7b512d85117ed175cc55c45d828e1b37aeee3ee722c5511c01b6e1301cb20e22af336b35504c460617da3949334958a91ba03bf2dd3775c1b1569694bdfca1e1d3aa280113b6db4f6af6d5c1bfeabaa1c796b46ab512cd7a13b7d1afbd2eb728db8f154e13043edae5ef8bb1378d72ad6e58215b433d18eca8fea73a1b92266b895f2569fe9cece962ff5f4787007e190a31c92250fa1bbaac50b197bc01c09a0297ca3b8467e93fe1c83cba2dfee6409387d434b8042160b80489837e3ee405a592fcb56f246cc9f56f5d1e679969152401566e483926f4f5a696afdd7e0ffe217c039ac508baad244e596441927ddd978ea6377c0757077b2e75749de2eb662a20436a43c31f8183cdf23bad33834693af069f37ccead525c0ed1ce2e3e90dea641d431b0b6cd4bcf3b9badfea73cbd8b1d64fd0a8919664906f4a0a9186bed87e6878f83e1b2a36373914d531b4ff4f4dcb2ed93dd1d68ac9e43fbedd11f6accfe097fb16a040156ca46a168426332d0298d6af74dc469469b4d782c9c4b919a3196e1f8926c3932041a98537d34ca52a618ea6e3f05baa2d94c75399c08136604ebe0524df8b9398dd31352e45ea3aa300a6a0bfbb70bc41c4432e3a1442d83c764959e4772fb516d95e1674d5733cf082822ee1ef2d0b1095d949ed5ec23121dc9ea86b32a560351310b11028aed20360d57817362ddb1b6332b6aff7c90aa916ecf20da0734ac999a7c2c1c35941e6774af1b40bdffbfb02b5afb7526dbde5f96b8b85f5278d058eda91aa5cccd938b25376c554f9c6591c4b2a7e6de2e5497db43f5010f3f88b1b7f5d25ed3550c39242e8ffed476b3227a5b047a7824ed8d6a653dc9ae8cc908a6b906e38db30927dd14eaf85f9f0f75c8a35c85326534253ca67eaeba78ceaeef1f6d1271154e58a4028902902f838bb0395368e8a709cc7ec5c0de3bafb5631add4e2f1d60b07df445f3e93f924a0f2d6f29351853191485ef20e129cc5786e09ed4803a18192698a91250f97a83d5faa53c98113156705a5bed4ed845105bd643b93ec58996b309ec6354badb6df11c3987f59055b997912398d4afb3842efc2e0143f433fbea72792a7aad8f1d89437d306e786d1cf9bc17df4712bf03a6d17faafc70f3e34944662293e44523f5779f87977b3eb3ff89f0d7bb58c0131a8ab51ed9c61e64bfd0a1c9a7fa42aa3f714f50fca14a8ed2aefbaa183b0d3dff0f50e603b642e2177118dae4368bd0b7a13ab501fcddd0832966bdbd1fcb37a17e7f5f4bfaaa568dfaef5e4dd3023cb3f56963db20a222f5efc404f28996efcc8997ad65b8c4e217328e4e322b3521c9b9617b3957bc3ae53748475654c2c5484c379514b577e969fdf33e7fa7a45b5db111af0a5afa44631ee9e7fe8ed799e8e913a3e0e5651484468a6d331041506721fd27212a583a891fd408d0075f4b01d602823b3c30bd31073c2a5a96059ee5da6960c011c6dceaf6be0e41cb18a3e8e2402308cd5760d728793474d7e9b728787476cb0c6d4dbdb487549759c94c12f7e348031c61e99e063626f8111edc349367f836d2d415a8b058c833a30437b1a16c4f1bef133ff408a551b0efebba55330457e4b8fbbf6eca1cefd3b053823d94a52dc4b7c5c6e0a951e8002ec539ab6b0a87aa65811c79f146216adbd605d8888d60144baa2f1c0a86a0a093c06449870a7838b1e42d13a331a6a334053adc4ccdcae8be184caf8f643bbec49c79d6171d19b2a5b4011693e21fcdb2babc95f2129e2775c1ed46bb634ec8357482166e7b0597665ac763ea6130a5437da60f7255538513aa716ce7a7094d00df1abdc1918b234354014679b8983e4e5ab0572a6c5d3212339ba5cc6a1b78d39bd904c84ef9728ed8fb44aa455a89cff5d5d68aecc38206b6657df0f823cc1d1f6aaa8cd84dc9315e43d17ec2e83e9bf3a296defe9e5796f731216aec8baa82614651eacc08b1784820e134748cb5bbaaf760a1ec3c0525f948894110de470c3a8962f0d88778a529d4ace433cf465b78692e1e94992dfedec114ed7aee351f50581a109c2d2b91dde5e12cd77d83dd58cb068345a1282a4b5780e6477260db32b4f4af179e6f723c768158815ebd39c69f6ae9e4e7ea2abf63375c18881d096fb1d4d201a33dde83bee9b80236baf6c5b4f3bf9db22508b92b2003341e391b308782e33d5b49567b9177c6857a0dcc0d8e4240376c382e59b101ae52cf2667b81146c14f3950a5f6dd19da1f16d162e8318955daabe4aaf7a5c6dcfe772994ac0e12e439d57e8084d960988349d0b1c9a104271b2f1743871f1b0bee8847e7acf794ecdb9867787fbdfde9ccd1854ac4e293f0f8854929fabc2416a05d1d45b9bd87acb9c0acf383612bb4bbf2e2bb2d8af7da5de404667f3f5c55ed7df85ddba1ca66d3d62ae4d6a8d168cc6c207dabf221336059ea7fd57f19cd36ede772b775c52721929f0f493d22c918149201856b65a31dbf61d7f9d4c37893771808f6bc8f9802ff7b7a40799bcfb7ffbd6dca59526c91dac82c8f48c969074c60ec4981c55f14ce93186aeb8d4f65482e050d64ea67cdc96b2eef6e7780cc13b2fe96d93563ffc089b0605489c6b05e95048a3e3948e43b4b0cfb34fd75671e1312ad6ae0a66591d4462fd6099dc24114c0862693b3bc7edc0961f75111c75fc91d910f3fa97ef8945a1b782138199da9ff5fce3e62d5b888872e6b40b51ec34a5e3e641bd86aa74bd74c9f2e218fe4aeef8515318342dc67ad4a2dc0807c22d240889f364596111cecb50e6df3cef556438d7d25238523480228541ba4c47003620306f258231ef2420267a7045c6f6254b9e626185adf81a9e32647b34e9d4e260539b0d86b14530302dd5889e26a79a00384488366ba5a5c1a53357f0585f3144fdc269e0244d1d394ae110ed4260983cb67ff306eb3f0fb9bc60b0ebbf0abf749f823f26302d98bf2463daaf46a270885ae5d008439cf9f79f259064683ace61c61fae895f8ff44f8446d77ba43b3a20be3c951e9486e1725e109dc86351c519dd0d0abd9f26294975c507edfe8c0e31155c90f868800c0911afb8ed2e2cebead854ad3d1c8c9bc8e607668e43ac6b2472519eb88907a0466edb36e0a55c06d83bad8eaab7bb21f174cfc4cab4aca57da59428ef530f05441a7ac49c000e37c72e655db75aee940576a3b324af2b52e2ad563074b490d2e7e74dd65388fea199b1f146cff11ad10446ae1de55dd87b85d38013b12d6961b9648dc070c0dd540ac0199c4ea4a193ff9040865d4ed55f2c4c8f27af9d57152597df5f0a2a53c2e77f18bd5333f91b00a1a75c2df1c3b9e73880bfe415547b2ff16f2b607e0dacf12e44f4861b8692c7fcd9736d5a55f1b7c48c53cfe2ddc646971765bb0b5f4a75f4c0a196b4ab3c0d3200a354ec17f45cd1329464f61bbfc95394da5c580f5f318a2d9ce8d006eaebc970bbbecc55c521f1e98fd7358199a915b1275dcbf2eff34e8e8129c1993711a15f2b6fdf8f7a6a5db1bb3d030dea9c595a32fa80ccb709dc017ad40f835e4888193709d98c0849608c5e550e09828adf184f671a7c0d721292acbfcedd28f5ffbed90238195f56b0a939580e238f3c115aa585ae918c74c0902de909671ec91bccb063ee7bd84bed723037e900e972edcc9c29963b7e0af90353e7485ebbeb5dc37ce10cae3d1c386ccb97c1869588eeb5c8a49b4ddc4766bc3d14e152f7e8a84e448a49337e21e59633cf6713254993ebdf3c58f0967b8e2dcb991a9f7e2036eb850e870ba3f916aaafb674af28727b00ecdd7109810e302b3a1ea7b5f17e5ec08f4f140a33529ad8c321c7f9de929f4e6c149ecf794fba6b63b8795c75b74f2e63c1d47d5bb35e59fb003f65f9b05c6f7621f6e2cbe9cb4480e0a97c17d38518ebaf6332066148cfcc76c5bd8dda44bf182b4281929d426f23e3be60d2ee77bd16deb240fd6f4b4588018a2dd79587f3e7d8aca27d612e75f76b5ef591fb085d795b741901337f90299b2c9437e2745cd5c5d82e4ae24e7ae4cd949e5169f42ce5ec1579d5142c8f5b631e03c49451516c54c4e860f1b266e997082513aff61ebe3c961c2f4889a442dbe707dbc6b4e165ace9aaf10e555ecc60498e46cbe68a779a896ba81993a2458e517129d5baf455e96afd5a308bcb18ba17636a634f66c8937a6827436185cd164da6175d52921374eb74d9e6db5c0ecbd6caa154a488836c696d55795ea195a800771b4e32912a70f1a64bd4d1eba7ccbae5f2105932a155d6179896ac7dd9efd0213d3ee84025c60829ffdb4dae464b86d9897f69939a298b97e8d39f91ab0dbc76a00646e7f4ed1d89b85c2c6e208b0e3eeb89c45ec6229ddd3fac7e520bd1fbe2ee6d68e3287e3b45cce27b22fc8c0367a7039234d9a13a860a72a8a2ae71aee95b2be345dba5af90e2f83d3dd2a7e1d41397837376e84f5ca59d7330797ba3eb018913b9606f85d7bdba7d422dd40adac0f043db96f476226bc8dbc781fbae8ba1745f1d529ce66855fdefc6fc34df3e4f0ba9e198da61e61ede6b016f8c0f96aac9bbc20992317fee6244263b15e1f71ae10b7c8560993dfed6a5d8d3f2d32e2cd75328ea188601356be766759dc732e15b9975884562c0e9c917d164edd5dff9a465f5df394eb4e6ed22225376fa7ab0718e5f872c8365d53ac5af0e3c6fee18952b78ef5c070d70e699d2b49f7519b4d3ab93f6dead7b962d14f34e9ae85fa0177f24d3b4d158862273db7d056e52bf48edd841fa265c665cf8f57027b8488cf165c11a1d8b9bef643d70f46043da180a0e9d66ab81493199183b008105bb219844022f2ab0c48b024e9e224232671c13a2a211fb0589108","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
