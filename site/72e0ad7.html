<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13433e480c984fcaffc5605b28c5101011c3c4a31930859776df0d6d21f91c79dc03207bd4368396b2a6036fc0bfacdeca2bbe5e093699c5cf0cef4907f5dec115c7e4fd856e766681c478554b773c2023fb8949a1f851c0b2c4108d4317341aa8fd371a9ee9ab3429db6f9c9bf49fe8fa9d13d9facbdd9764acc3e10b3f73fecb583c469d35ea46a95791f56ecd8b11f759a4afb2dac0b8a5cc42350be457d796d6dc8c3737a464d7ce039eaf138a62cf4f251333c6bcb3eae9a754ddc6519e8e0afb1c182f452e48db2c81c87eb52eb865770d5b045341c969829b40e611801947a097e5a00370cfdaad572352838741c19dcaaa93ae75d8d742735b4246c52e11ffab4ba478e267f2988ad45e4f7d6b15696ef696aa2a6836ea1d3f9ad2cf20539f22f999cdd96dceec5e9ff97c646e46c62787acf1dc6290fed5bebb47683b37950f0699fe81c721960b68db99c9a8997184f4d75451e525c14073d05572c4055d3d5cdf418f2d1d4bc5029293037d18b05b301ab2da3709c1a7babd6428da0f7c2a8703c33cc43b576e9ce86013d15c35ccbb39a800241c4ed218d862e03028afac3ecaf954f286913525adb4aedab55fd3879f83f2e0861505d98b09af6899b2bcb3613199979e43b674b7cae91480f682031e31faa4053f95b6e049910bb43fbe42afe3c9905eeef19624fe27f886c718e40acc8bfe3585b6bd709a462ded486e82359bbd63cfc22564730a30fae5ee0cdebef92da20f610865cabddf7f04a22c7de6cd7fb66262f40cfc05063415aef32c8cd2c44bdb3e4649d2bf31228c603824e2cc57d97a3640b74363bca51251bb7b46ab5f96e6258759fd421722dab8c9b68f62a7de2111666c0d316ea792445570271849e1bc28e65e3b160f27de31ff1b960cdaa7a2d4201dda3b6b06fe2a230d434badc2aeaed2e4dae7fcdd25366ff840f50813593952c2128e49eb6189dc9d0109635b5f9abe3c36b082f1a10ab59bf627abc4e546ff97ef9bcd09868bbcb47ca8d299ff67f88d8f98506b05f6967c23e6dc3c645e477da798347b142fc3532089f2b7680e934b8ebb11a3b5973295fbcd66276674c33eead819e39a2493274f20924cf9a8656d055bcffe4b32b539d1b1e54250f2ae9a22708d9bd45d14fe5be474b06261b26fb6c85c4ad5414a1ad81413ab8d3f50ae155ef66d2d933cdf1732ab33c60b8fdab077357694387b4fdd766e0dfa9cde15df801332649df90646159e89f5ecac65e4bbf645849e0f2dec8171fcb736a1e37654eb45f19c249587c7d2bfcd5c6fc599f577d85fe41531230f411394eb3520a393a970837cf267a81b9fa25cd98bf477bc6f2c1aaaf8c799bfc85da7cdfa257873c447ba2fb993ecee4c690657f6e4933406737daf74b02f6938772d8b6f0f14d63052cd2fded64b5cb59e249e306eb820022343ae948e9b50408a335447fd7e7b98683dca83be811cfbf1522a09e745638a3aa2173599a04c694fd6c30bb767603c973d0b1b76d2384bf8daf428c5e18efb4733ed2df6f224c0e388f985530610cc9ebfdbe299f3c7549e34d1222fffb5bdd04fc8207386e9a50caf87e1a4bddd2801aac43a2753fedd1527e2cce26a05de347f9e5fc7680639bcb9cd8ee7c8eaa855ee9f984f8fabb2300269b0204b69c4d0fa3ac85dabdc37a56d9e3cc4625dffdc0f3905b502275b2f91e195f04e1b3d5d77c13ad7615b2c2c36d0e1e8c58afadba2eb28c434880ac7b34fc01e13687441790d82e3453a875b277f7d205a21d99b45c9ec988b644114bae3e0e6fe9e6dc64c56e7290df87a0de7eec518e9f0097dc1954bb57fe08ef022c767e6c518e726ffc899af378e288a9610ad9a6ca9b9324cb836dadcad41287afc46c26d6af3b648274df66f574d3e07a260d56e49ed15f4c7e191472b2bd09afbdc7fed19e1b561785181f6deb58d968a4b6e51009c41858ac3c45b2770e867cb2974fd5487b16bc99ded9bade98aedf0cb3e90b8d80bfb8692ae27569af4c52cf3f45a0aedfe04a54bc6253905f1da541a4500cca4611ee3d52196a8396558f9f75c307fb23631c9826eea8009b0e46f766d20da25415878cdcb28cdd4febc348249874b477dd17ae48996d22bd84b5c9666af1d3b749fee54b29df419fcbd4f819f58612a8f7bfa59106b3f00cda251814dc614d82ab9d9d875f708677d9faa2633c00696747fca307857e199f8046e04030c93439d5f48b71518633061bba817afaf0d56ab6d6e211a537535d3c0b57dfc24d02c9865947c23aeaf4d4ebf2c0df322fc032724735e7b2d2ce77f11455b87a57edfa27cf20fe4e677c3c9d65087f9bace947fc7c3e3a9c2a9da4346c1be4bc338f897748afd8a1d48fa6b9c30b23e7f8421ef1dcc7b708a5251fd4ce65f13699bce33f7bcd37f507f50eff39c957774bd11cf8a50a2a2b7287816216cb7272958855742e3baa9d053496c492903e97e777605633b247da165573d4e43b3cdaced0e9877a59c22f9e24a082e7bbc14e252afe8e03f1f9e0f0023c9e3bcff187e282764dc801ced9822b9206ddee7e0b9603f9539252207ef069f2713f8db0d4bb6b68322eb354def33deb4c5b6627dd027f2a150af2370e8b9afbf64d1183e3872703f188be1489d43b9d1d83317579239f7aa32a187ffa0fa8c17d0bc713f98fe8dc9b46a60f4d5c359370fc5c464dfc117404af2a8dcee892df25138c039df75101efcb5abf4875d52d3d238b5ecfc53e3a30f33ea935cd4867744141f50c652ca9364310dbed8b0712761481263663db8a45848698f90e67e50295a2f64bac07c5b50fa20beaea6d0ba5ec964369c9474dd3f11ae383e53dd9a82744a44f2812bd2820d0f19364fe9f7e012678474432fe6a56e295aa270d93084facc6ed8fc0f43b6ced1ed9470e82894cb1f74d61750154013645d8a9d6a3a55360e35f0d403dfb69bb92837ac2470fe7daae4e4f3d620e4b2a46d01bc3da19a14b006bb186f97bae3e6aee2bbd684750f5b0a7bde1c18c121c35e345313ebe5a33150122f96c3693d9e6f73d2369ca55ad34a8cfb8242c9c428cbbf297215f6317a5ae318ed8141b7da1d83f1b072f2a62d06db48342633e36090f2f32c22a680be1f0033ab34aaa470f60f08834eddbe369367dc5163273d6eed97c54342cdfb0bc3558da0a2dcd43b5f5b60a78642278e39cd6d17ca9b8fb1815dc3f9bfd493f9094bd7a23d875beb7d486470db68451db4b01500dfd620d678b2bfac0a86c26fa30edba8e632a5cfcc82f29a7c7e0a07628523299df86d9f82fa194e69a58b059812d848cf0b066f53d17433c3e74c8d245fe7751958e2c242498194928f73de88315f561af091b1e593d1ffc2600fe0133c736d8c24fee78b2c4bbae21eaf951f33b2d0a40874093a6c3e990e2b918b0e582dfc885253fcf68741d6c51db3dce8d7acb52c4f57eabb4f5b17908be20f04bb2984627600e5e988ad59b727e5f966a6f11769a41cef81baf05e67a120bf003d3623f7c9d74964481a2d00f5903b445a517fc78820b74524ff1a7c9772a49f8a3bdf6f148abdbfd975ee161246a9bb9921e9b87091010e1738468a179ff9959832853b820557c6428c8df0e7457ee32b5ae15b907f8816ff1f31155283e41ac9c06849aeecb48f7bdcbe153b448837003d6f26a9a19fc1225f44ed3f647bf09dd0e2dd86ac0a5d397a748fb900cc1198c52ad413402b0a3f161d1a6e1af2c18c04ef2698753ca1e1be0a35438834f20111e659e9ff67f449e7cb028a969029e2e3bd8077bcd199205113b70523243944abcb5ef1be850a47ffc12be666e1c7945fd3710608c8bc6e5b3aa91515bd510f2c716ecaa386c966dd6391a5e2f681d497942755075838b4555e479b3e70f34353a72fcbdb7e49a7f8e7cd8c823b982939a862baec9792d3c3ed21e3e522a360f0382d250be90fd2b22cf7c40a53ebf96365f7deddb4ea0d9c37d0055c09ca862c21be60c819fa6df5ad11ffaa433c989903d8a50a4f3c1b9d6bbb63dd75fc9e5d6a8cba0edfab60b868f999a3caa9b948d2b0225db68c462cd67ac72092821d58e86eb3d01c55f2ba3a3c00cc160e62dcf6344b3493b654e30b18c3a33392459895f75e887d6e2c3261ea6c08d42d34a975e0962f073177755c49cc5f78d1452704527a640d725eeedeb0227d7fc92d12b901b23f73102f8b33890a980863cb1076c905bf04d1864e5128c1693a4c50facdfab65f647503312bf946513c506a6cd283c0ef83202a23509cdd1158c8813799395d8c5a41b9f1031b822f5b7fccb2cecfc650127f1317a54854894e75b13e777f7e22256f483c53b7d93f814e6d380dad21d2371d9a37a8e34f4deabe1b96e985c6c806b9a5569361802f96df0482a048353db3c055eac47edb43b650917b7c86024bee9e20362c929f1fdf4d3bb37d7dc06fc76c11049b28d7fc0fbc4443abac3f45b12c4f2a582cf3b034dfc3b614184e829453c063b02cf0747e579e61f8427ca624ec3d7c7101a9d959828a32358fd62d44af0fd04bf7051a92afa8c0250f16ac36f8451a86d38bd6082ec674a23a7d2be26d6d9697e645ad04ff4610876411e02b9fb29b3ecfbd72affc457b4f4def362a14e7a43cd0b0a88020db9334d19f00321500c04d0d3cb8c8380084baa920f607b337636ea5a15a11bdbd990578fb8855e3d9759ede7f16390492a776f6a9d5d384d977b2144664602f8cf746d12dbbb441d5eea8e033b7791947a22ab88b6646e34c2b372471ce23bc57ae0a9f6fb74ec824a7ba6f846e3fe38e4b3fb05ebe0773bd796aa0a51d74b45c2d61db47b8a89039a12c3e39837c287f38567b8b0884fc0a9202ba93a2c8268c6f814551b7aa9959088fef3d8640066ba0c6c50014ebe3f5b7c4758884f39144b4bbbd1beadf7bc3a8233fb1b302d608ca7f70a2c8c09ed16af68ecb9d35457e5d192bed126d3a1e65754733643a0320010605cb2bc4c96d36ad6df86bb1ca8f699ee302589ec52751f812f9b53d531e617707e978fdf49604e19e869f989efeb0623cfce6d20c307cfe80e11d0aaa2c77df8159048f5619115329367951c336b1d8a302baa2ce3dc296b57f6f823e402e944f37ccae1bd244808bc8649dd55ff6411b20d4b9c7033ec84298a7a793eca6d254df82d2e41e23e4935c5bf76e6ef122989221e56acff498107b0b166752db0ee7bd7863516a310c708f8491cea77586c366778556d015bfdfa25af1cebba569699fc6c063bc4c7e68fbd3fb57d31d0dff8113683626bb4f44f22ab77c82a18fdb031d9d9fdae077afbacdf446f0f170308aca4548032d8c76fd8aae350414b3c5221a081234c8248b13ab49bd29cbbdc027637b126daa0f6b0e133688b5bfde5f5b6cfee9ccef030f2348e5230a6d3a095236000130e60f8e9eafad3a3c9b829d4fc5e568a457da05e6ac1b67d02273a40ea627deb0e919d45902fbab65d4f64ec30afb42eccdc86c694da9ee4a231edcdff9b4f78902f6e328448cc2b68c0a4ef157fbb3892360edc1ab4407539695c753194ec14603b75288c6cdea2f6eb1a125b540dc947e782f3c3f2fb2d1a1f27f09e56b16c4f5de0abf5a9a8701d23feae636aa75f7999c571df7112a1ed295ac5e96c68c5a04f1d0cf238fa685585047a2b97361b265da31520d401572eda090a76edf5d722bddfa2a59963ad6f82e3e11cda8d1ada4ab49bdf3c8f9a654ff01ccae15ddef8f045f1877a11bbee9513353a48b81dba88b97af10193dc99de13d1a88a88f5904ada8338ace1c142cc51f4bda3bc164ee57cbb2fed4ddb107030e2002462671565185886bb814bb63e408c2fa24627a989968bbc04a72455aa6bad64bc2f2f4c15e32d098f074e8051c19017dd07bff5ed992dcd8004367bccb043e72018e749ace9855dc69c34a64968d3c0d4e30d4019b39edc860a4953c156a595e7758b1c1a95b309d6e33588041127a6cc563753ef1c665eaecd299a2839e7347b843f673d44114510ff6a05cde25cd5f21e7d66ee1496d4ea690eef087af5f4013e7de81cde57c0dfc52f56e9a570e08d26f2ae9e64b09753ed6a08f28ee49b47ba301ef294195370de1057c0541fd2f88818d3182a75e8bf977d024479b2293752bc45bc3ec5c17366d71fe1369a2093caba5944ff434cdfaf823f80cf6b0a4548dafea004182193ddb9d347f6bbce8f1a1b65eccdc868256861b60ac73f381c52ef7f5ab12717912d4e014b89118ae8c6f16d6a1bb352c13d279e3b080fd07b16848850cb2c58c66ad27b86c4d9d7a8cdb83f010402ed17ae53f0c7304a5c5b87912b2bc4fe6eee8a273b4e86acd8112aca478141a2fdccb17049551b476f053e04b861497469ea9410c1d7bf44d698e9bccfe3f885fb662ec6720ecf7d555c773ca30c61cf99cbfd9162499546d85addd1ca9acc51d2bfd834318f1b78fbc9e0bdafe84cd9d7c651d82ccd775333b23238ac24e964c0614c7b718fff2624fe35082c0e65c34b061d071b6e67935b7eb6ef068f3cd8332bd6c96c06e7c6205684af83ab979cc80b19b185131237c5f708aa99d46046e3e3788d46aff56949c1f7f982a1a1a7fe8fafb98bbbfc69166b38371dbc1db67ccb617ebc16a8c054bc3dbc7769ae25a38483c757a83db2cfd8f1425428fda8ac9566f86b51c6b65355a18d0dee403f8523c0fc977cdd75183b6b864bc55aeda283c54cbf8da7968e7b462bdc4c9727c7ac7f653577acffce1fb855ac7d7596e86022b5cb62d22ffab1a65a285d73b7029e46b989d3eacb1d5113465e7f30fd96cdc3405869baa189c3482cf3a9e64c394b6eeb4c70a888fa1982fb924c724a7d63a878434e219eb00de3ac16a44bf72117cd534ab0f26d499bc97f03878535821f5a6674bc9fb05df9fba0773a4c5b50a1d781076319758907de67f0ea7c89585efcae1fbba9509ef00e7db7aff09379e733aaef99bd9a0bce31d56d799047a777512722560647375ff0df31909859d159a7de36966f05596b7159285cb502a5054f550e58ea42a26e5265f9a676617c3ba487d259962ef1734f6b23f43895dfc704b27ee4d8f90d2c7a9c0554df5c2115a04be68675717fc0240a29ce18b35bff420c48efbe2170e083d9a51899961edb729617e821ded81e4bd4ee7843ae6bc9b787e7d616c6d2921b7220810e250aace05b2a83af41fd93af636422b1c0fe250119f1bfe813f2d7dc6f707ec94cba78d35b94e7704e4ba90aad9cf21ecfd26a32025e43269f2019bcdade97fef4d54c85ee8c2474f53b6c86faa057034a8725bdb57fddd741926e5b12d8727b5358c616f2159fc740543e8f3d36cd51eb5973a35ee9377e8e334be9a0c049ba4932d038389025185c2e03ea4d80ee9cfbd767310e6a3c701aedd80c76878d99c16ed4ff45c8e78b2e68e1d478393759acd9a66800af4f5c646e46de9180a4dd1bc54ea95c11a4a6ee6ec2938574ace952ebe446588361cbf712e6e746b08764dbe694d78822fbb969daf9bce600d5b63d17e51edf0e8468bf28098b3c4573f718335b8f3b09a7921098aab440ba8dde29acafaa280f105bbd7d613787ffe29abf707ed62d64d53ecd1f8d6c34ff2b3294637df186f51f04925f3caccb56f80d7c3b26dcec249e639fbcc1fe6d5b21c005a930da086332c7bf66948980534dcaaad57310e2c5d6ecae42c3b719d095ff7ffacc6e1643aa9d22f33ef90af61d85bff84711d6f9dc2f845c95638fafd44cb81040df21be0c6e1c7deac3fdc49fe0cf0116d64f9c06164a2640072ec7bf0e7b9aa922e0673511c51902534e20af5ed8aea89918ade9dbe3c1662491711f93dbbca783b0b74fe40ccb1065a4c31adec54d36de4dfb8f9fea15b6c21c0097b022daea8b030ce33b0bde644c3196d098b6f732a6c10d5636fdb1d7e040a055f2ad8d3736508799477b05ef9b3a5079a579b2294c2a74453b4d96cbc516da7526fa0c46e2b05f32d59ec96ade40bf990f331095f69871ff91ebce5f7f80ac0ec5f8094a5d3e596e0efe861ebd08d624ac1a7889a15d97cc778ed1459c1a820767de626c5cef9b1eb5ee94a697fc57aff64dec7fa5ba5eb3f6bd24ddbd70a82670d0f4df7c0c22c2e3f7fd13bc0c89d1676c12525dd290d9674de66bcda2760ab1dcd031deb2f44b6681c6c3427c8b5b502ee58e70fcb08003bcce3ac93bd02709275e9d292ebd3814d8545d3fb41e130550a6fc5ccd2366c5cbf7356cd14cbf38a33af7238a43b9edc27ebf4ae213c04818c648a66765915e577e417654a451012cbeae2e378c27083ff74605d4031fb93bcb9543cfa596f3f1ce8b5dde9ce05529bb54270642fc570f555443e9df3e574370055c316958a9cb1838877328d8eb76dc0c361ce531f73a9235fadce7d64f01784dacc7e3f13c99415903c567a7f01434d439f1c86820c839c957b5fc67e9901d65f36f336dba8df7915021aab43b328422e693beecb967b802bdfc7a9a81526ab33a0ce88f63e4611a8ab37764b523626587a089431b8a224f0ac8d3a25cd05b1c7df7867e936df82b9e251e82ac1161702ecf973b9bfc238b69c6aafb283b9b7c3004d5adf5807d7ccacad088ef1d148e92af63060d6161e5edca7b87c2ea37502c65738b7b8d0ddae9d8182b516bce2b3ace97625bfe87c3f781d68067767107ab57c554899e9beff65e80842c72768d57cb3165445d9ad9409fb3474dec095805280c12a9d3a867c21a499ab133a3411e2363a47439b1ebfdadc387d4a4beb4e708de3fed6df289d56e9db5c77619fce70a52ad9413c6ae7379b89b7254c32c8c9968698991fb7264fb63038a07f3c099f457c8f0ed4c7ace926301664551f909ccade9ce80500bec90ca78963332a510b926136b5acf6ed07021b5645f7c6da43c74c4f4438626e97490d7060a3de08206942ab1bacbf11f364225b7d7bbb78eca503eb6ee1659654fe69709728b866c81317d44902abb81d397d8e89dc11322cea10085297f7908455446e695b8e227eab8d8d6f98dc3eadc66c7801f29b144f9c70c7706670489ebc96e977112758e4d3fd90fd42ffb9a5f2bbd9526cc18c5142c0f75d3da8e1a37868fcf5855968c0ff127cb4ef6878488ec22e65138e255236486363cc57eec8359c4a95b5fb05e37dc9625159086833e8514071021d53c70756c8424055bc0afa38b13a99b23feddb59d5f3e694f8fbb985322914a801445646ef31b3992a61ca294044d671cb3622be6baa24426be85d61b41de18df1bbaae66e43229cc49f7cf200b82a361bbca2ed6a355ea86c16a93a804ab2e25b011b83c93f140d129054d20b1b58cdd542a921b16881cdda97dcc8d168d1d40e3658c2014edf643d04bca72015a8988499a7ee4bb7e9fd055ba1c02d0f9bbcc2225701d4f11054ffcaaefae3982ed6b26824324d21bcd299c0762d80f93842d78e11ef7f36f577de94933025f8b963e5ace4efa60a31415b993b54e179a4f9bf9ca22fddb9239615e925db6b6840e9b44c943ad32c0b629fd7416fa938d1ce82744d70661f844a2de0f9997e23fc17d082292ffb4dc1e9fc3b5e586b6b4a4dda67f6c37525b25e52cfac7a5a3e024e53791467c23064525d07215d266772ae1fdd3cecdada14cc9f5fcb5cf4942c7a564e0dfb1f562e2a2ef28ee7acf1a491c947b90f2553b54e7391170c2affabe514f9549635037257510ba817d588792f79cd1d1e0c1de747122d07b8344473ee31383fbfb77349048414bd05e36b6a7fe5f863a6349f66345faf8951909bea5474ebaeed67e0d8574a5624ca38872780528afb8c114a21475220509aac184263ca403e8a7dfba49c794128a6e8966b8214413d81cdb959b1b7612d200065e51d81a1ade995abdcccb7bef06f137fbad16ffdb7adecc57f1abec784d0bbcc203caff9f1259335243e0cd6ec72dfce45cbb96d39baaa021ff005bd8bf194f9bd18ec4597bd1365db3cd7c8fabc147d84f80b62f5fa585e980e1284dd19449ab163786c5f0a3d43eb1ef679962d44de3f6d5c7d6cb47953c1bd13efb3055dc484f832a3c3682fd985339eec10d744f1842cefbc1eb5350bcfb68d8424650b91925c7927837b4846958a1fb27d40de98a47cf6fcae48a410e16c438246a6dc722e5c37cf882f35045f1f40736eefe542e9a04e87117ef09d72d9eba16a065796fd56ad8a3f6599d4a2d572f9f12eae380484b6f295daf8fbe6e5e3a80ae442de78db652504624bec517ae7d37487f416034e703ec0d92a8c2b83361b1c360f3411a042764e814dd88fd16e6a4c75bb536a3f71105368c0234de97295e15da9c5aeaed702ba93f507c5ecd4249658e4a85d6cbcc4ea0c5eee8701e7eec71050eb5e7f47b700b80f06f7f64289957fa49c961e2b97dd02a14e49525117691e7e3d090654a9a061706fd251f30fa8623aa6775efad07cf19b580172602f8c350d2e0272c31a660e0b380b9e9f7e5e81fe874c548d45d6e8d2400cef956429aa4ef8981b525cf08e985cd7e07990273ab991d8f23fab49807e590de1fa5fe1fed18253845a5ea7d6f2123957cf43f99f75fc5621485348a6d5b67e9007fb5accfe809ca93b9d3e31e5bc86f02e6d5d6caa79304f6e69f80293e8cea0a51dc704b2bacaab80fe0c64ff94be41b6718b8f78b729081c9fa37f9569ca46b0bcbe0089d02decdd8e7a22d407134f8a07430d405681ca173ba9c1f34e4184d6897a94f912094fbf15e627b254b30fa7e0cbdcfd5aaf180d7f80c8f70f808cb8923dd121bb642bc879aafad9fd5201751a6420b4f814a5cfbe24b7f3e948fced4258f664831910cc38cf6c09d8cc19bc31680f7c67473f4a9ab59c51fcaa5597668de34f05023643a33fd320de8f851baebb36b7487fad6eea0072ed978db078ae89e2abdc265a0f4789b03410e8d1a5156306474cbcfc2caf8c1af0e8d8a481f76595047f2491ab28508c4027971c51ec5756dce45b646151618af8ca732fbbfa2388634e0382597e3cd8f5437c6ff44465fcc66a0c9de1f01179a07a555d206ae45186f2d64904bc1833f9f9da61a0360b0e84c70f17bcfea91217cb2ee499ba32bbbc888081b8bcfa44f895c73fd1df96ac2a8a0de34621bce1e3a1c14607480ca5d40a9635b6226bbddce66cfb9be99ba2c82ec210e70891ed71006925e120f8dd750c501b9fcb6a83e63c0920b859ac1613557501cbdbe5143f5ad1e6f5406bcc27006bfb20740a58afd7a39a2a0527b365be09e065e81b1960de13b41e927a37b35849ef00dad50d485377322bb0fe2bcb2c20414461bbf061cbeeba1e0ce14d08adbd29befaffb90b9be8c241237256aa6faae8423c6dc430550be5d77584e647d8e31963a2c2e9c659032c10defbf4decc02dea0bb7a8edb3b3d60dee25507ba0b30140090fdc7825b1b34ebe227189383aa33960f74d3144989dfd8718c747997d6c191fa149c0ed296f16f4bc6c2020ef3d7bf8561e0aaf719ee0e066b917fac6c9d8c05f324e6dd78cace4980803bc1ec11949cb7593c75c14056874d2ce3fc1e23724162a8ff2000a2407ddc360126cff096383eb167a29bfc71d677592bc3e633512fc6eecafbbc25e1f5ed94efd36423c5e8c3436540ffde0c44ccfffbfaf2f89e342b0af65eec4eb3e529ace07b53fca5f5b7722c3767556311dd6fc58aad9f294adaff2d66b199da9b3dfbbf27dd86a445ca8e94e1c3f6917b5524834ad89bd6aff1c4cf53ffe3647053c1441d5202675212dba0876455a0ee469727b28bd732d82a00ffa9879d815025e8e1d44e8bf12b21c958dbc7c49a3310e27eb8ddc9ea1ea5a6f044061cd398d94e9c4c303629cefd6803c2edb8aae35b33f9ddb578224089757774c7d478261ff1343b97c68fd1c06095a6686449983bd4fc48c3afafeec1559890215a3f79e6358bb37799b9c619f15a06b3cfcb0648822b0150f5da01ce96a02b4e233e19e475d6f8577426844b7ed9aa55a7a52babb0f86bb6a73a53ed73b46fae945aa92c3db10fcfccfd174f9830c910149c69e92274ef1f404892c89869cad95da9b3aa144a1b04b74ce39b1c1aea1c13a2eecda6868c78834af2dc120c9be063c50215b4c98936743ecf546653a940caa95dc79c27d4369ed501ccc7f844b1b0b3c598b1dd54f09052a71af0fdc6736e521264d311a97ac00d7330e6164e6715af359514c2f310c2f640f665c9d6d6a3a8dce642836d022f46083eda9fe0400c74223f60c28ddd7fefa5ee73e86f5e1c71e4f9c6ca77b2427de6737b19fca430a485d57f96899db518f1ff578d4f43e1c76f4e984786e4a4c81099697f4bc910a6e457ba9cc4836dfd5554d89992908517f8d20ffbc93491ddbac7eeabd53a5c16dcdd0001b36165b058e2a3fbcd1f2f47fe23dc967d114bd2cc32672aa492c85f03252043bd140e4008b961aa25a3e1345ee79ddfce5e35a592f242633058bfb5a88d359f6ab09f77a45dcaf6df4eddafac4010a7b773752fd82c7b070f56af1b236c98e84beb571c600a4a643e74d5b21facb36a4b6fbcc3377c2c65c30c3db74fc0f4d2940ec5263607ef1105dbb0678ab3c80193e808156ef318a185d4ffae5e6ec2338691dd1ee52865470a16774b43bd8fdf58e2d94b4073fee6336211a9d51216ae07b9427dfa850054563765f302c696d2543b3833653a7cc3827d4d4a50210dae92817aced4607cb336b8c3beb55313201ed53168286193150caab433e5e21231fd4e504735cd917b3dd2ea43fd2d29edf1f2fb728308aca0cf508bc2d093f74dcd0a8219514455920e1f36d168af1c6fd94d7db5ca21b44a04b6ffef583fa95f0d7ead7b053a2ce3c91c6f0e1ad461630b9e74e8f48c52218811eaa7242d2ff2e280317c5d625ca68ff532201ca0559251918f67e5596e03f5f7bc37f290615ccaec832a33d75815a64b4cb407ba9787dadd4a310281df5b9648bdcef9b0ac95bafbe5f842be4b5702f8371ce8872c6ca93013e8a532768bf5e5252426a759918c155011bfff2411e8e9424fc91d56f690de10fedf01d38d6ae52e94d5388ea52b4d2ee78cd162e4197c89b0e1ba822cce696535b705f709f14991c638fdab1c025dbc44e5b27303","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
