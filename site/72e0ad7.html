<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c560a0f5bb9f10b80277be134c558db0f9ae81c8d596175896f1dd9fe0f90b089b35a2517c722d4e9ee981a750301d8842170b4c8398da1f2b36e4bca68e2693f91fcfc8afb4fbfd4ac9c46409a07a5ca5128cbe28aa5b61d93f3862353e27598febd6185c19ae48d7d86770f78f438c1ca7ac3f03461f19999a14c35df8ec529216b9293bd220329024a8fa80b7ebd186c14407c6f4c76f71085f894db0a85bb43d2487deffba0d889bc095e79067b51aad575a2185f201f746a8cc32bbbbff6d7e5cf08e711cf6ccc111a2d8b8dab3f424c83a6ea60312260258f1a39c2861a790cdf0d3cba02957dfb4723080fad297716ebc5a1d6e40832eeb9a83bcd4652693d68c656daf95031b9b46450d4d0e6563cd41ad955ad8147e6120237d6961cdd174901e9e3bbc6850e9886192d9db0698ede8f3e96dad1343b069ca34980c1710cca8e2faa95faa9851abe27b7ace9090dfcc4b9e0097712165b3484e006eda05053e6fcd9890663c552560577ce386cbd3c9fb02da4c06cfd9c3828b105c906e1786db3660b6dd77bf6edb9223eac4b5687a9c8cbb32648d7c13a1dd04e87d03dcc2ac967d71b2109d254001681dcab277202ac4f85a65547b8a081cfe83a382a7d26abefbd4da37c99569bbf29aa7616c75cf8d58a5bdbff08fd05662ae55836e96439bb468a65a4700669f637ac94701fcfdc4320c7ff808b16ddb6041dffe926fd28f6fb7d762c4471cfba1703270d1d3cbf9b08a103f3e0e3dbc3c80aab25af8fd6a61132d0ae271a3a9b609e43ef154ba8dbc194a233eecc54f6bd5a429b8c568f8a231514b105ade199b0c2c17ca7b2f8e0e98b9690866840364d94b5c31798903d1f751686b093f2a969b529edeb1e4583067ae2a462dd8c6e45c05f68efc96335caf4de4ae4497034051a258639004f91aaee5e9894bfb72de9795ae9d9062d1584126e0043f3bfdb78fc4e7204df722d37d9ee227580a09991a7d35488fb0e1e319f3b81686005a307528b06669e3918552b530c04abee9fe4c9925b3fd63ef7ac0d584cb9e5bbb5d5e62aa6beb8499703e5d5896b2038db10393cb234d425032ffd3a080a045e2097ffe4f73f06c1290f520bb8d7b039f551776b093530ba688006a8b0e8fa64e9a4db4576672ef6bf252ff0794e3c1fa9477d197a664340580d624f006a871e9f35ce46b623941746913883e64904e5fb0e38611d42698d4676d461946ee481d02d950f44bc6df2c8abb73dcaaee1d71d045e261f875c0f865bf37e317968281794f662233868fbc2dcc6b88b53846d7e69c6f5375de8ed47114c325c132303756bf2f1b2327136d8bce6fe51047a888eae4f55dac3d8e56a373f5fb257440c8cf562b6d5f661ebc37da480c92266304e2b07fe1406602f6458e5b1f02606077d1aed04c08491cf8f22cf651997ccb416107f1a2ccd7d2452796b99a26f156693369a946356ad67c80fcebbdc00209d60f753ce69cbc8f8efe1c318cb993a8751048682859524bbe848f014a4b388a0a6c11b760f65d4745128a7d95064af3c7a9e357680d66101fe7f699bcb82b891b206a69940a5252eed074874c0b2b0a5bf5b2ce3cde4dc5cc3681acfe39d7d3f11eb6c1fdb076b0d40f0c3d20fdabc374df40dde12cd8d49301f63126b9607b59eed54c1feef318fee1e04ffa0873e2171244b9e07d7aab61c227cb5deab2c6918d6ec12ef8b59ee06f5efb7803fd775afa2bec00048d75c0efa6a981635844b4c41369ec3f8908f6ec816f5bc9e9fbea48950129ce82a7eedc207685d6cbf1c29ae2129dc138768b8ea25bbce74f06ad91e5384ee1e570dd814af89a4f1899cd7fa56ed1d9834b1dbe7792d9f3f09fd17cef23bbdbd152792edc365225bdadf560969f9ef7fd8b26a8f39829fad493c97d85773a6b99e9ed6b6c4a6eacf950d997cb887393a531961000d4b169b1c54d053a54f1b48630cc7a06d96dc8535f70396ff8be1f31168c111c6a0806ec0fa4eb85c2eb468c951461a5de094ffb2a08969ad2f4aaff2f1e3558f66a41f23a24787203598c8af111536839d5a8a9ff76f4b2c7f436a18ad9474823040f3795c1dd38cb0f873a2a14c50ab9590abe967df5867e42279e013b4c8068b613f5a1804470143e799a432bf5be7205705dbb366d92e28237abd8204a3743591dc59f30e0e9fb7b161a748d4bd5ae251cf5d205f4d8b04ed7607dc11c1e246269a98527d9e22fe9714630a5d3a85dc0a22f4b1db9fa5a295bfa08a0acfbeeb76642262aa7c853767dff82dd6fac51445ef47d8e4c11878b77eb13ea46b02f13bd4c7222ad47ec5de4a15f6fa5263a3153c05ea3a8056b5e975c1f6077cafa7af3efaa8379724895af6604b8e8696c877eb938b6854d08ddd2fe0470160be91f2648655d388a6708b996e57759061397de2832bd3959f7d6502443667f8b2a9394af7173cfba2a1b46115df3160b99ef221338dc6c8152fa429f80cf3382d1bb3233c42f66b2a7d27af64e89e48b35d9f958b56a56af78cc21d57204a57e18298e892e715df25b4be2f7c910b4981f56bf885492b484d899e5e4f9a3506fd55d1bdebe74d641810225c57e2d885340fd64c593e774e394de28612e2212b127ad25c70630f380a7766da69ae266198de55db6db0ab3c3dab783b2300dc56cc32ec608f48ebf97e7950689bfc68b9e80d7f7ee7c94d744ebe4296fe7956f519c070ce095c7c430c4064e42619dcc9ac1e2613f7a9659d771719d3bd94f0806359db0a50c8549d4985213fa432d1b7df965a43153ed6de68cf39fe3f43ebc57c8a8e1603415182c45a6e6de5146d6d60361a673e17769e0f3139b33bf66c25f9adc71b9fdcba2e8ae2b3a67778329ee43f72a6bc9c231834adc346cd6b071805bea7e4f683592bfb7e1fbcff868d5b64400ff006903a2f16df7cb847a0d9dde0789712812df6197470f7a1ce60490aeb7dac97bd7185db6e3d8d25bcd8001c6aa5d786ac5679db05d2240be72ad41f412f86de68e9c477398a1bbb589ec54c943272e1180f55ec6a17315d83329533508a9f33ab6d193f90bbe79386ac20fb9f85190fc4b9734889aa4ffcd6cba5da1b4ce20e2b5da0e0e41ea255f6832706462e2eb97379c92b08c5c3b4cf844534bbdea775016ccabb15ad18dc461ee659433decd5981e5fdcc7de8c72ae6ea3b439132575db59569b77cccb548da0bd08c44babdf8581e862e184afd4b5e22943fe1691892f8573b67289c8ed325b829bcc770ad29bd4f22876f8b4b9c89d1e3754ceaf456182dc8697b21301caef5d543dc52c4e1325f91b3a6b822136a3cc772b90dab065c4d1b61cbe9eaea58077181aa49208e879dd551f16212175c55ee24658b1c8c1944fb71b859d0f971b3ad51ac00641828895f5c581dcfad7850b06310d21ede708ac55df77dc9d519feff1e2c3fedb075f7761141e18bec3c5c0190136e10c67592a26c20b68bfc95a4f50457983ea22d23584d8441266edcc3311c8500e39466c6726f6270a46eb9c321470f60fd8af59bd865813ceb8c52e2d424fcf7be32eb0f13152abca7fc28abcf7efa4d70add92c168700e361dd558251e62c7c5c53162be92077c159dafa7789f614bd55ef191af76fa14ba61ccca321f1c285f8affcb57d505dda635044834dbb30f602611d1b4fd9dc426fbaecf52bb0151f00c2b79a16ec916b80846f8176387b2acb16c02e2a3e65ed4c308bd4aeb433df3e721e8821913bd28fe05ad4995430704e58ac07bae6b9ef1a78ac44d3fdd69c74fd69459e3affc2af30e9c930ec9ee9c9fb1b69d912e302e6b84fe325ea39f0877ec7a93b35b97fbd2313c531f0ffe8324a8eb9e1852e14f23b18a7160360af192da52777617969a6820886db676146e4e3d662e16c2fa86197429869c93c626bf2a2ed6e942d9700a9c357e41ff6f3d5ef556362e0d7c4293dd6be09bb0ccd6869a76125b72cf501cf31ef7c9b6f30c955df899c040503a431eb34d41a5e587f235a496f0e5b7db4eb3edf2fa24828f874d96a46aca08f471e64cb75243df3ffac660a01ef01b1f8dc5c13b2b603eab25a0980b4a440c69ebb13862f8fcdf25493fdd8e79bd64040b4134a86878bb48e7f57c51c637c94db7929695a5bf5a6b16e86e04745e212cd191e6a1a8940d4d6e65bc658317453e9a32cf5a8d9eb0383c2afd734467d27c350c12896b1d7436f116172fd0018bd5fcbec1468847cb15ba606eaf43d2c02f7ebce23ae210bea099a6b6b6491d99955832d9eb0a19bdb062fce23a6403bc0cb4fbb41023d5609877d55b0c2555ca3950fec9a8bf1fbbac08ec4d1833ddf59fbc521425fb21cd4431f3ad3ff17bd2801b07168b7065b8e47f522147cd54d2eb23fae0c25daee0fe4d7bc64c42d1a15ad4226725e227783a9d3d8f177e115cab1c09accc92c4b49f549380bc8897505d99b9c45344d84dc0f45acdd2a2c54f9f1f9799816a7af30fa8f9d6291ad505475f022efa727ef6affc89822bc011afe3ab8960acad4ca760b25fc154637fffa6f353ce7dcec6b485ca769473e5686fa92de56c0b33565e2deb29c56ed58811be7f4dd41d47e5ee394774ea2ab88c066f6539bdb446b2d47055decb1a5875ff018695d9eaa1660ddb9740c307db1ddf884ec1fa2c3cc351e9bf45ac593d22847e7f304eab43fb7a79e2ac1d8938d951efccf581cec83f065da5d19981fcee30494483bb06be3c9876a6b9a090e4ecf5c7bb133d146a3528ab5869bb89eb50a6f855b6b855b242bdbb3a304ad4a82e79b4987f72ceb934d25c70a81794e3fd3cee973df7bde36fc224f0a958c4efa9703cef654bddb9d9f001cd7d1272b241ca4bfe1cd321d487f8bdd8496fa4afca0a9e9e2efd9fcf85d326a9daf428f5ee0692f00b68816d7a0b9dddafe8e7cebc4943936fdec880fda117384c14756b1ca862b949a7d184d433bbf05976f8e813eabb880807c3d3142e6de2e2cf517fb2862fb26bd607a9e0d0b681259dd1a577d69730d25581fe615ae0ac79dd6aa32caf778f26a9ecfbb86a4d35e0675ea1efaadb452a999e2db06470736dea991026e0e0df964b6c3341f81cd13651d1e37653755a0e4aa1e12805f3cbcce21ecb03a35fd309dd23670f05b8745ebb430ccdf03922d888ee5b6c6464033d816dbdb47aee8c2a23f12973370db6b3fb4db275234b8b649aab3bad506ad1c3582a3800341620f59e51ff444c4b51bc5c96dc9743273a46ed1cf80489149ac6c482c0bad92bea9c6a30467f5bad5344544025444a1acd41c6226f73be1246a84bb012313e5934bd3aa5efb133f15c9e399ecabd0474bcfac2621ddc74c5a4600388f1a33dc2c556e2b5c3c32fe1f6a8a4d2e6b2213b572cc975771c370a9b4fef8af4aca920fa1418c28d80697e28879e0d5589877c2d7c268eab4be291323b5a651000290869ae7cac0f5924c20a98912fd661858e3b85fcf76b9e69633612842f3816f02ecf9b71ec9fd78c902ed5e4b061172b8a6e3f90737381fd0844de2840955ff87b728258e5dece05fe380432aa174fa6cb2cf4b69a80f3c7891c985712d04c7b4997f1b6cdb087da8779a599ba0a40ca0b9a42abca92ce3e924d0249fecb6a4c076046547c055921341a4c247488a23892d033c4d847c871974d484add408fa921590abc9c022f679327e4f735dc5817cfb14a9c8f8d097cd7b543f5d5ef7e5e17bed4a73296f8b21f872e78a7fc7e80c631b8abc395d4676630aa380f5bb041882a4deeb15dda1e904eb1de08bae40b143c9c9c6e7789a11ab3291c1a6b982b70096e19dbe13676e935121a2a19cf027549d85474ea644f0f09a1b6cb577e2492397590d8011cdfd3417cdd43d51d81ada2482a13d23737c15a320e8b583b52fa150528624355dc33b404a4eb0132f593be1187cca313d44e8413481e19b6accb551df761351c4667fca111c3d484e8d7173783c119665b23f947feddd880aa395ef3f21000a759fdca4c8e98b35609aec322ebf3ad8cb04bf132a9a2b5c11ba8ba1c0aa1ece3abdc61d1d20177ffe54b51fffb67915db280f2e54aa1f231ab6699987d1b32aa129341530d2eb9b819b7f17308cef873c35502a60c46945a4d39fd614875440984b124cb25a5e2f20afa3ffc74cf18ff206e016e248db6ad01d5081918824e51b81fc91116871555e2a471d5c0a0736b89b0dad55f78847bf73676a711f9e98744dd722e6279329cccb54eaa65f6087b3f2a8b5a1d3c503d7055231c908d828d149f9967a58b6a31f3a272ec18d34c35965d9272d4fe77ef0e5bce4e341c187865d11b5013832b163809943dd9a1d61d347195c3cc4dc0d36787eda131929fb856941ffed925ba7a6ed657fc748ad6ebd2536b2764dbaaf289563153507db05349aec5598c5a3ae7be2e1547972926bd39e2c87f11addc7effdabfb9e0083a71ffcb33ecf013a8b0bb2919fd23e17ca44585e6469897e4fe303245f07fe8df3e6383d19cae90dd8e057b285e1674482c2592999fc9350bfed62878d7ba4bf17ae96f35e40923cdd2e5042f8210d78dc4c24afb0cd4eee7bbd86d1a1e883a4d2824eda07c6794f37778888fca7ec992d53511ba094b48808d591cfeed66fafbed274d91af5f6957c06c6f6e1f8f9d2d402bb5e0d014c14c8f31b3b516ddfab2416859a322aadba751732ee94edf0f5b9348997acb9113bd64d0eca4b6fe15c3b46e6d4f1b8889a53baa966afb2191138452c33cdee413a3e8542d260978f9b334959c6df21a687bff9030a51f8f0641d400945be7a6eb42a15858f4a83f0d1b138b3261f91ded64b7d40def78fa06ca0a25f7aa1fb56d5ddb99c1a75b410b102bebd4e3ae0963ecc3a0d819eb3d3c3153bb302af4643663b7c4c095f126899f6a8766e25fa82353647a3858da267907e9c3b0fc599a1a4093674fa2b029b569934622d5db28d7cd565622ef670fc129e1db44493b3268f65a8b4dfca223f14eb1e132f5dd2dc1ebb716d84789902857c0abe31ab2390cedfdf0d98898f48cd6b0e3994f926f19b7adc4755c4e2f6f6453ce82dcf9c9d6af630dd1dc04c1e017e1ffc2d6ccb4ac9f0df79965b999724d99a8b85e842caa5801166cf44cbbe7244260e2f8cca197d6968f0f7044841d9f8d33a6ababac91d790321ffd37adbdc3f7386c001b62c44fbc25e2b280b780eda1de8c0a23a7df0690df23109a3ec506eed78cde3bc76f3f9b8bb413004b80212350a88d792d1845ae23af802a7f4beb4941d46ec6cec6bf0f2e59f0535c0a467b3cae06491d12eb4aa444fc33fa8b49bc633eac1bca0f6f5558da1698a864e60c3c1808f27bbf087f4d615346d4e1321e150f9ab36388afc2f13555a76c90c1bc2afde62ee6ccecaa7f3ab01a7bf42e440897e70fe095b8ebe317603c039ef69ca9ce7bf4113a292fb9ac790f8658e05d841704678acb375ef112cda35e433607d0dbc12f9ef102bb18a2c5f5949e0000264dd521cdc970c1e81e748a365c4a502c59239b0c06bed4db8301532298d062ab99e32373f77f42ae1c42fdfaff5ebd3b0f1b0ca82c99052f2729a4e939ca35f059bef39d655b67cf38aaa1fee532706276665c837626cbb01ca86be62e0b05f3b352b545592c98b4022702f4198f8821ce76aa524c9854a73af5430f1418e41205bdf12136479af8a24db02aef648a8eb26016dcd97eb818fcdaaf7ca14b999b8237ca47653e2185aa64451cb3ebd9b8409c00504a3d85f278856ce3fd254c5ff11b916641acdc641ea52f235c80c3465f4556181f105db38db72ddcb24c1695685980362cdcac91f75f155feb3c2164bb2878600d5c82b7c2fb5070f142cb9585cbfe2dc8ddb9561ebdfd5b8209edb8839a10dd7b37d4f1af339c1fa190c2ed6635bad8f3aa787fce467ded1e77dc8de709b4545c27e21412784b27ddd6c16dabc4d5e023c334f3f98e7805a4872cc24403e3d4c96cbd50e30cd4105eb456f29ea02d933703df1c63622972ab01298f207b7e22a27fed7cd8b66a180f1f697952f10bc0119a87dfb6fce221bd3c64aaee8c1277dae687256261a1b7b05deca37123fae6973445b6acc9fd858d8ecfac299451dd070b4da74be4ef6af5fb657bda67ee443e2ac0ebd510c66e0594b16eeb989b5bac129e754da9e5de6a2d028428af058ff6674ad0acb26835c6785cfd68859c282135f3747ab14c19dc62580a6d5f282cdc833e998e5cad006eaacdd93d4684a04baf0f10961bb9416497ae4166752b8d3d4daa3bf401c57063c5c12302102b7ebe1680a6bc2187c8f5f5f278b11ddab2bc12802d043a3d55176cdd9f8ee232e599b93dc36d870cc5308c8c15180d05bb110709ac4763d3416843479554283d8df926b755793079ea986997e5477c8129ffb18fec82c5209558792376320b146eb11addbc26c63323b1883b4739aaf3a4900bf241b1277754cd4ede8997ca7f712c83c0eefc9b88cb4c20ede9c225a9f992200b9442bbf0e8a519ffdeff92f1df879af0fe4f6ff6f41f607b793b9c5925b68f138d13083a57064e70673ec7339b04fbe83da6ac35609c65e596dfae81e8f79c9118a5fa3a809e0b563572451621eaddbdc9d563d562d8f7c86acd53f0237553a03b1cf7be8326f7fa6a57c8f8aceadec3fabb0f91905dee831e4e72ba2af249d51422a0806c558826234c82c5147bd8b675d1050bac271a89c3513e8aaaba2aa7e37bc3613a5384ad4e7d95364753f01e923aa8364c316133175bc56ead8ac7e6c7df9e605491702d0de497010cb1e27489ff71fab6d1f250ca9b60afa423e75c60454def535b9e4992e836b6616addb297830e7f0af0b652fc7e507d8a98091daf0174b95cfa6883faaceafe9f34ab9f36d5e03219a950139d5295cf65b361ea3a44ae02fcbcb019d62d890ccc5acf41a7db2461f92f43d0eebae6d051b3cb9c517e50ebcb46e2f00588d1ea30e3e98e7a64a1cb2bb3b9ba4c8dda7b121d9903d3f58b875e63dc2062634a4a129f0666e8643a51aad531ae4a0ec65d9e10ac3fcf743bee23582e44cb3d86957b7b0fcc65e7c905e30bcd87f3d5fd89e34b278ee467a5175958d25d15926525817c42e6abf84edf0999f9bf6fc0bd732ac1dfbed8d1e619b471f1998eb43ca63f98366fd3030fc1a109817b4c424cb9b21539ad7e1c9dc376cda024fc216bb0bdf40a082aae1cdc69aa9becfb2533374d1cb2680a902dfbdd8a479f7e3f8991ab5bcfecaa6c7f6daa589d056c5344cadc1250a0fc419d2ce07188c8dedf9ab7dd6f22b1e2aef47f141850949e37b72e8505f0300298d3287a89b5afb347dec6995098f5d6c920469bcce642ee90c34ba1f532b3a043c1bbfe9dff606eb30b739a55ac2fe09da5975e02b3719a54a1425eca1e1b79100775d7a32e68ee2e2beb517d5e20c2d6d530817c73c6fe15cec2857e726e2d5d8984975369fea933a1112f8432cda08030d8541fb65f12f18d5b47156e053dff4751d024088dd04c19fbdfe79a14b7294a8de9aa9e56754bbf41b90a006c6006237403937a71a3c8dd0b2f310db01a156db4832049c7f6e4f81380d473292e64cec758c33ebf5b198b533981f43ffa8bbcf4d7ad3df7f6d78a68c82285b47670e18f26a17ab9d5beb15f702aadbacfeaf2510277362e7092a1eba3a0cd096e36f3b0378f10b05491088cff4cd57521be05ead46fd7275afc920c5ece1023ffaefc59d539165db0bf78dd9185122498e2bb8b4bd45d174e2a4aae296de7ea799ce03eef09e5918ca207ffbae948370f60729e3a13bc49c3a360d9cdedb44fe87fd6363c913ca2b91bc2aa8414febcc79cf05441cc3e173c548d0a6619227389266a58189893c7b9c06420844ed1516bfbfbe117b2ac1cf5415e47de1703f079df9d6d23d50e5c9b25ff8eed01392af6aabba43fd67579bcd645e99c46341c3caa3ac70c1d125c369875f494a5c87abe803d985e26cc8bce006cbf2705e0daea773cc17e5eb6454193622cf725ee2edc22b62963a67addd64da6f0924f5ecec36507049f5af1735315c82e81ffeecb92114e090238a9a1aa42e047dbfc55ba4bc2cb9de561d322eac587beb2aeaa977a20d19a345eb40bc61b0add104ab24a4ebed43519eb2c9caefc286df455a985787c42bb92f720696fd101c6a5f6fd276d505c6193b00bc88609982c99c76e41c4d965b5d42ef5ac40d0cd02d59955a4cd188c65d5b35a32a792f7071cb193ad81aaf21111ca4fac2ec7f68fd3ec23a88b0f9a4c023410ce66d5c826a40f2c5541e73c0db4a78c973199e99f17fd248403255ea0c460a9d3639da3320951159a640362a0778c2c61495e2cb2fde6c91736d9461317184c9cd4debe425e2ba6eeb38272fd3476c686bf80485347d5f86da508d47ad87c7241a0a92e89c9a60f16a6d1bae36718a0f964dfd2534e83c5a6fbac66dc6b69524e3914d7fc5367d568e52c8a87dde513de2b1e7edd218d66f6594711517c40077aecfa4f79f7bbaf64e5f17ef10b966f6c031317a940bdbd59e57f05406d055e0c297d79e9219f66f1f595b76fe5f62678f88b9531f0d30372bb210f2ba10e1de35ee3d98db9f02064da576845b3da9891c3a0eb374680b6286694c41234053a81504fd8a2bfed8a76d663e9f41185451b274a72aef70eab8b727ceca13a93966f45ee2a2efb5dc8007a87e6614a1d7bc794ed6ffcc6c379b9db287ae33fcf9d7920805650f71269d2b13e60c90e39a1f563180521ea46d452efb85a8e8e7d1480addd4fa015f05dcf6a9a54150becaf41a37f78d1cf344195f12392a7e203fe14aceebc00c4aa994cc0ace1b162646ec47d02e8faa09905898ab20771978ee03d15ccaac253ed7204a3fc3b881afd107975a72610a2f90d11612806488b197dcbe21bbb5c9d3301de7a0418102b159caabe8aad2a0e1c33b72ca6f848a0ce7fd7578840ec9ab5ff0bfd6924f37580b42491d0f5b2ec7f506183b43a3803bb472f27c7cd3088dd25403db5ac38a4c326697d36cb18bb62af1565604b852d3ed63f99375e75e803f0c91d3cfe021432f9eff598c0a95b89c02d1d8cb3716dfea50c5d5865554e975b8509602ea87bf8c9d5bf5c2c189f38fa3040c60dbeb3eace8a13f6d1d032aa947809556625a3934982e96e70327894a17408eca6be79ed377b9b6122b53172a50d8cc714317915aa07b4aea0e971fdd6bf0ef26cd8dab13e1a94e5b4f521d797f9664c92e0fe43283d4bff01b04ef06ff3044af42b0259bcef34945f519e6b11b3d4220d304adde2d39f99e8543447f3709570273a437a72139461b9898a172528385f9d94c7e05885f7b8189decf7fb95cac9560b749713562003f30935b7022e92982c8340f88c1761237efb0c730262d3456d3e5fd816362eac08189ecb7d9e24aa7890d8c27de3fbc6bbecff1de0deae7610f7a2613e62be1a085a2124d620d6ea5a01a225e73b6253a55e16a166b7eeadda6571b52ef1799fed9346ccf3c98292a757c1513cb0e08436b73d3662ff141361a9fd24b14758ddeafa2560a5509e265fe5eb18f446f33330ac22e8b469dcf9ad15d88b5c9bf76301769466a74ce8b3bd456a0d82823fbcf364d3309aaf16446a28e96d7b2baf3fe0e2f0a84acc0db653b9f1e87549ebd27f37347c249202a6d0c89a75ab985986ae5c94ea4d63aa4c331ce477b010a0bd0400872c1ca9d03b2062f85e72f3d550380091a7a58a7047e7e2289a5f13ddf03797297b883f9c4ea92669c10a27718b8a49e807d382c60b42ec55578c1cc330b91b2db3f7bf1d164ef5ec3b6c4bb304e1e6c09dff8ef39a7dac0a65ec01a9b62c7252d128c81f029f627c3011575b210bc0b1f88a3ab46481f03cfe33a2bf3840824688c41a8eb5f6202575c879af929a46f62202194bf7c755ce648a078e071a22300acbc53fbd94f62e2fee4003af9958a6e424cee343b42d2887fecfc1ac9d6b174a5ec319d3e266e3f14f28024e7abad502dceafbcc616e90a643eed651a1512c5ad290855cd49610cd52943840c3bbe7f1519e44a51e09125bf286bb9659231139c10c42c86625186f7237b0c67b3afba2bb3646a6d33c3f77c1e75a8d89101923ed057b33274e1682decafa4d36c40a49d0c586dcd2ab19b46d916d5cb210d09d22063e776da952059661be75f5698cd69d8c48358c8d5168f75c7c04587ed45fdc59bbcc937b4c8123a574a6ed72ccc39fe5df18fe3b88c37c5b0da5268bd479128ceb70ffe19b7317b2bc442e5cf0c9f46e77504637fb90e4a7094c6bc2cea24a6c1c8637fd4cac224a4d016842c3b1876bea7ec1151980a51d6cc12b3503dc1df12eaaae6caad4431c4d110f2139227cd17be4e6fd48f3901c913dcef1718a3475bd20ca3f020e599e32117f36c34a291fc5d2f7906bacc0429e61ef50120feba5993997f26009c92b17ac7a01d50af0a24c48e44ca255d46c4ae8edfbeac7960495e2d0724e8f355335fdcda724d11ae04d0d7bd55ce16268af68a409e61318a3823be90a56ebe7d35e9d8300454323b45282eeb9fe7ff12d9afc899cd2e746729bac11d36b60aa792171896fea2cd9120a37f311e16f5ba284338c7ebccd7a0585f151ddcc0dab248ded91debfdf574ff9a592667902c4a5b916592b5b43d16176ada31749f09ad9530617e4c043345ecc39ef6fa052d88349dfe1746eb5fcf0fd5a7bd0df02df3c8ca695d55bacdde1d6a226b68a9ce7189eb954b87abfb10a2647e9e30eb44196fcb350421477d98124e411d0272f2bce14d1875e8e5240eea1de0fad4bc25d7c5d6f2d237c0b4b70013d60435bc56ff3af13bc3f570cfa121ce25d20a16fec5bdd3e2e36b0c7fc53463abaad01e999933140a504b89f130555c87aefeee881750bd90a2016770af69d2a41dff9ac8425ae9ce7251212c37be12ee161d79f1bf5f23f7786c7ad171887dfe03abd3b322d737c4d6ed21aeef9533a569ba72734f496c2e4e2725d523dca605796624fa77f557e39f7b8c107e0d716f9d21b190afb957b8bd6822c2c6b5df73c0ec4b034e2be7c399f50b3b6ee5dfe3f807fc137ed45562a0e7fc6992a381e49ee6d0d6b8856bdebcaa558ea74089a7b9ee86f6e47d1b1c38587644e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
