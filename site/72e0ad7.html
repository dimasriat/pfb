<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee4450f7c256b5612fb306ac3a615f4c9391b758f99e0fcf45e0b7e171dbb634a828854e9123ef082731107f82b440b3580cb591d8a58505d50d9017ca182ad078d028cf47b7bccae44e0d4036c8feefb03546a36b5f63ea3dca00aa706706a228f65e7d17d1e73fb62f8dcecfa72463c4524cf8256cdd2db62540cbea23557938e7709bece62ace97f1249e973a8c605861ac21effc16e3dfaa7b20b349213f98f5761988170dfd73d897f53f4b5060cd3863aa9e462f0e896ba2b4883231ef3a9468968ed06fc5db17cb6620a49c3af2e0cdc011a1482e8487f2310c3b590c94fa6923b9c1153d7efc08e9f588e15b925cfba92086fb74ae712a963c5ba658edda471f4820ec3568ed570af7974ea2c26281502106eb23b75aca4de4d6e4527e6ac1663274357b18a86a53175880d3ee20f35670f979f198f8015cf61a24002ff6a72976ab449b5fa471e3bd16adb95f064a00d90bbabd8c1f77a0e095bc6b68bceb75be5afab31e2234be0ac2b0864b8b15328e1e4edfe98c6d398c678110d8b1dcf628e112948066910c704c8e7a93dc254019639fec04efa85b31eac4830c0e6a868dacc83ac4d23e1ccdc727487c1575859ef2b51406890df3a49f72abf010650287a9df22741ecdba6d5d2deaf6fc0de8cd62b1d3c23eb9d1792c191885572ea1138e00b43d0bc5599b37c8ac8760d8f4bccc2c8aeccf7cb6f70820a4ea0f1484f64d08e05f601fe09700f4998aa617eda8fa0363775b52a8c09e74e7585f4353fdc588b0d38cbbfdc0440c4da1112c8ede0c296efd1571e840ea8202923c59bf346e551bf7598d58a335e43ffc5baa69d87d1a6711f5302b5f53186afa90e76016cd6e1d49cdfdf3394243b937c4190b4b41109265892330b73504dbb712c238ed05004379ab95ee52bc84712295172dcab0fcccc02826c139c5239d04bdcf8fb0d82d4fef98666e1af6cbc4a1fc734b71dd0f1657dfd5f0e029c43a08a827518a5636c595e1a0cb49b4c422b997c2eff2dc7bd1e4e8dd5e4b16b7ca80be9fc9117fda5a73cad9d9dd47916f5af17c5172dc2f60dd69b98fdaa8b59dcb0378ae9f53bd864ee491ec13102f07447d1b758c0c812f6eab8954cbee6e30991df3cef6a5943e2520334fd88b3763e057b832c361b16d4cb93f34eb307a29c495240c9329a5de5a1b76dc3559a9506be564590f0abcce04eb13177743a05df7ca2f04d81d5fda0c6ce6455f407add660328aeb39751275cc36bb840f676e3ee565a426f22debb1d42108150c7c9fc3925ba1c24e51ce91a9611d73b0666c071f53339b10584eeff934da8b8ca1c37d823c6feaef34eb8e1b4aaab5a6a9a1654e8c128481e5b8c83858f392754cfb79f185abb2e22c28eac2fb5947a0e11f72da9a07fed3b9cc6ab3dcbe04b7b475fa86dfc8348565d8add57e9fb9012f55cf836b5c14bdcd9bb639810fa08de579375c33529d14b4706d95a654d689858644ffbf3227f63b43692cfbae2b5cdf6dc285e3ef892d855684c8d92c44de3d54433cd83bf270da0d8d8c634272c0898ac95fa08af698ff0f3703101609dfe0aab863a3eb3452dc45427c65e965adcefb8046a201486e0e22e2148c03edbe27e56ee8c380ad1f1140e93468cda776be8264e233c98e8825e01abec9401c1a2d70ebebb5f229ba8d6f0df60747f01219191ca1cd9936cc81941f58e97d3cbafd54ee49ae198848ae8ab382b5c11be8783049226f0f88b9c5b273cc7f246efccd4bc1c9fd8c8ec2d2f06e77cb0fd0ab0219061130728b9bbd8e86ec0e3a7f2cb6d378393221c1a5de8f98bef6bfbc8ed35ce3e82bb5319c6e281eebec2d6615bbd71ce531246e7f9d2bd2177b3dadc4b4b1df001e285a2723970b5972c6f55ae198c893cf83f4756f69c7c9e78215c31f40c9fbeb976ca838dc0575f3eeff2628156090881812a2827f434079f05e3408ae4e6db1a13d65619047906dcdb8ed043fc1404dbd7b2fdd091cf682aee5aba9327ef25473d4e85fdd3db34e017e6804ff92edfca3d88225e3f3998965bddc6b74d69eaf6caac9df28a467d8cd0f335dbd80e21ccdd6ccfd98da18f5810a3f0ce54491f2066dfcaccaa999d13154edce500775dedd3ff004cd417892e4561a56afa0477a59b98f16f0d6df31271ee97efaa453ef3e19c31e21896d53d042ff05e0b77ebabead9ff36c4f38f2991983fb396225a85591d390510b06e2231e825a5e21645bdd3ef4972554831f99a363a86c8a0765708ea9fcf5d643f685278cc465f217a81074e2436442f947cdb0dc0f2c675566ac47d25b4bd8d56adc0bfdc4ada117ff17933e09bf91305aa943111dc3d8a872a29a109d3b43c733ee18598714ac96e09cc4a503a93e9a32ff21631771208d98aef48d55ac2d1ff5db45547acbcd7b933dab007c87839fefb2d141cadaf4c2cd94f837eba688865e998b699e34bf311548bb8aa3b06d8cb3029d16eb8f31ea8aa9bef55151b211f8c8f58809700da02ce8ca1f556894dd9163ce52b7f9dcc71cf2a38f883d9f471e997f41d8e7985a374839a972e036110f9ef0d98c647729e6767c55c85799e21f706983697772422a76c43e9458c324b99bcb48e4e3123ceecc3bc10b3be6685423ace74fc9d8ce6b31a8f38bbeebe0bcb1da64cca95e4cceb638f734b19691a97754515359344facc3ff4c019aa03bc886948cb454c63791ee403e559272e27d1546f8c9bf527a5d9d036ed1708ddc73cd87fcdb072be473318ec23e080319532e8a8a3a4849e90306b70cea632ae71f3915b7a8ecfd30d7e1e014e1a0cb03d790c43a9d05d5289a99f9f31865a879e50e37ac065f18e74bd81038836bd744fcd7c31fc4e0dce37648b0815b72bf4e6b0242c03c10868b8c011d63694bc9e173e9f48fa78771fb201cee44b3716e36c864ea2945ff85b34106a34a2b979ce8ca7eb538fad14d5e4f02618f0af868802da11971ab5fcb658a1efd80f6270e3ae50aa745495ce651bf9e853097072f7b96f6e36532b8c29a36378d3814c78d6113de9587d0b054d31cf86d6d7f991ade48597db2360ec6b5265719f69ca6aeab12c8d5232deace828adc5cf4b92b0365c26ce89db67c22bc1728220723372ad63eede01f25ea2cf47c3158aa5eb5d49faad74b3e9d8095f37637e3396156a17e858e6afec1ab4358a2155cb80fd7ffd2d5c07d033fba43a5d94339aa5aacb2f7727b13371a5817b0de0cbfb65a26ad96f2d9718babcb665e69fe858fdf1dec594bdc8fde0c6de029d3a47b440650fa4fa11b694eebf69db1ea2011486206795c528b3de7715c22a2d6922cc1928147e6e4dfb7a6a4299e3e253d75f7292d3bd135273cd30d696200275e156ea5b5ed4edc1dfffab0a5ccb20334edd0029a7c56abbbd7d67e57a61917d0cba89e44e9fbce941740ee00ff0ef098f2a0d9786e1abc4670b6ceff1c667a4897e64e1bf7ddccdbea84b75598a30a84e2b0ba1256b75b942fc295899a071cbde37176f7e17a6f1b0bb248090f4ff5c91b7d19250a160066aecf259ed1aa9a428ec3edad82a7feab796f325d06bfe1e5a0f3727c7c038bcb42c330f9c254e7d2715838441031791e1ef1d6a79bbc5ae66e65bf70ff5842d91093af30ed206138c1aa1942662db1fb08831fcf4cbb12cf9cb4fe955e62b3866200917e08c9f98b2db4c31df9e84e131285a1124d0ddbe31ec91feb2c39b8250d3a3cc6681a2ac1d8212fbbfb64ee5bc323ef11369cd5fb8d368665e4a607fd2b1e8443ea05781d2e3c41e3f6ee72ded95b5ea06b0cf31371cb29929eab7113b99b4bb4847b1a51d8a78ee3b0e343bac88ae35a2905422d59e1e1843b35e9a4230045c5ee6065f357becf8cccbd1c592bb3eb465b89ab78595970957c9a249f8071c9019a53a10cdd47791dd9875552b53287f445224d845997f1ce71e50b6c3b3347241fb6c0c87c400601e92f022595500653917743c5f16f8afd000d0b3e2ef06080603cdbec31d54265da254baa4f79ad1718145fa45bd544090232c78d63b97749e6c493d75dba621bdd83229602b219479fa230827d8b551236ce4ca7ee6181f72d4df796b1ec5c6cd154e63fa927136bdfbed3723aae9c09f5a9ed5952c3b53e5c82b1a24cef546e0c1f764b98e50c69b668244a7fde7bb816acac7d882f5093a034cf7cef93b0715de1c983cb00e26a8d783d3bfcadc45c78f84596e67d5c330eb68819051b875f627026be598ebfd6d29f58fec1874b6744ee778dfb377d0a31a11e14d995cf5250225761aef9e406ca643b3d6577d31d15fc938009ee5412b01e0af99d8bde53d835192837f85940938d6206402de117377299267f6b8f04177c11ddaacca048610b10114b3a01968482530e0d5cdedd4de477fbc16b4e2eba61051a0596b6688bbc83c368ddf0012532aee9e80cce36c3f0ef79e043cc5e3c04cc8f6bba163075ed4111f3896005fdbb60d0294d115dea791e2d992dd9dca793a855a6b3406010aba87e4b735d88e4abf5a8a40ea4dbb68cf41a1c1543b11920eae05f8d328f3fe65723025a27589531fd4b9cbb22ccf17468e57f69a6c860287d128789ebb70c75f7816ccd07c2fa3725207ceb197f8f84e56913410cc309a0dec029b99a7f3f6ad89b895fdf5bc09f5faf0af3a99bbe385151f561a9b707481e867030a895a672ce612577c69cb53b5596b71be496fedf7ac3bd505bc83cf9b0eb9da8995666d7fdbcf0f0dbde23d437b50c7b3487a5324c9597701beedbccd17c1d877b9aacc7cfde349a925ae43cf63b16aee65072aedb062a7d851e4ca0da305dc3fb192191f394b33221de84d229e69922da4e8e402b85811292df97122e8a68423a34a1c99bbae60ddb4fb7375ee771fa9fa629d2a29a53f55ae24ca752e20614d59f9850333c64ab83bb77b52a5eb2315969b6d793be5179fe085880daa7dc0a8b8f06b2764a27b7dd5b2116d049b1432614e192ee5119ee75ce06c1fa4312f6a47f7909658321f3a5c1be59faff6c622e0abcbd7f7b7d0ecde8af3e3c8c4b6dcff01806568334d4e7100563fb31dd675b79375d8a15e62bbc3c19230e465d093ffdf4e72fccc172cf0ddfafa5f5f16a319821c556539135b7a01b9840623f5353af5e99ef6d727536ba21939cda4b9955d080ccb85eccd08b50dcc7a66d17744c201c9161432fa958aa4d41d565e3403422c7896df0c16eab0422351730ce4a6fe857c7e9e251f13ba200850ee342213cfbe0e540911cdb5efc8cd96460d5a76ff9f700b27cc6a77fb22a21c06391a78bc901ef88dcc9c1fa7a95827b5b38894a4e986d0d32ee27c23d7df05eafdb279611be22db31ea2e2059c4f1d741d7bf7a9c2ea1f73bccdbbee9296d86e154cf187c2073bdcd952e8db4fc49338e1efd0cc1e9c4364c8913c12cd8bc125da74be4ea64044588ffafb4df05c9a2dceeebd9b9cfade4b240041db5e8430629fb1197d2655644e308d051e2977a125f2f2ca0149366ac1972fb7a1820cabadbc8aa46633a14b39b3b01f85323972e01cdb988260938aed22d4228d928257f4b5701ca187293b53347835219412ce251b9112d5cb6850882240df86775f6f220d3d27eefd35d88a45ed8ded6971c6d7e1178f439f764e251622bf146c53518ace0e11ddcae38243e3c855637015b4bf16da8860f29ad649cc25185c84fe4f517460cd2c6461e0aa1c448a472ce425a3018ab5774e1618ff24149904e35bdf10248fefd9528dac1dbb9bd1599872ea79ee3b88cc33417e3911918c230f2a48e5b1a8ef8e70c9c6f079ae8fbbd204dfa4f887226df231e2bc606c346887182385f26a31701f23cc56e4922e304e7e875a8f2da98ace8456c053c8c30e8db584378332abddcf2801890c23f5d03018a46784595f00d6ce0135d2c43d285bb93dce5e69c1eabb54ef4f55c97c72585ad50ae9b925f97c663a9d413b8122abce5ff103bc3ee9b443bdb0fb7a48e21d31f73e292b8fd8fa878d5ffa1c79bd6dbde196d06f8e63b506107e60e4ae2da8c5fe633d1a501299b748f13dbcfcc0c7ee4fbc6977a2044d65d6d238fa8b446d6903e8f00565086da0959f52380c8b85185c6b11dc4c40d3997b8f37b2d980a2ac7cf7a3ef3e55de63720e2ab505317efb70aeb34004f7aa2114771397df6b6cf2c22e1287f88e886b07e390ac4d085afe4c433d5e35f41d30356d8cd3594066d94a7e024869bee104274fe7099ea4bf9de5b2f0a31f607a758e13c553051616a0a3022c9f2de30bb3ef318d6c1c06148ab33bea83b514e6a1f7e043625fb807143ef1b084c5f9a8677ccb2cb62ad6541092d1eab5a35bed8f906a07714cf760ca9d68bdb75aff229e0d75152fb79e11d8ccb354f1e1e35278952a6c49c6d8584c8afdd09713de31f4e89d455043f2aea104f6aa61c64f7a98c009e16fd04d4bab0068700ed1b93b819bef1f17139b85370d843c4eead7d7c3fd8c858f820fabb6f9864faf65b57488c67028db0971bfba20b4275f87948553aa506742d4e9e00b99d209001805d541217ab33702fccaf8111628f6d3c196ac4422b60e32dddc8ce2983cd9f840167ff1f00a8b9da7e96830a1c0fe018767fcab1c80b38133f355a34880d5e401e48f06ab1087ec75c0b1ce09652a0f21ebe00a8b1cc09b4d0fa29752f60b58d51fde2e5788b30eef7a7c0cc63a584914e9dfeb1e142b4e7ba480c2c0cd7051fc95c3544992b53ef5bb69bc0d903c0a15f774b583956b241cd215aa63715cacff8d495f4710f897338d594c452da0c3c1a283ab38f0ecf00e2f3392f84da8c965f6e11df5a603d711a9da06fdea2f44251e248e7c45c1b10fa9616d119402e7b52bc5c90271a4bd95ed1e5e4931f5dcc3ce7d8693efe8e2cc379ecc6ec2b1e1d245370d1c5777f58e741ff64b639d30e6a7ef3a08607b8fcece5d9ca7724ed45616a198ab5ad73dc25d096ee80b100a9ffb8a7df0505546375701f47eaf6686f0734358912a9aa98ec9a883342bddf00087f0bf551a850b298d25e4053e0d745035240e51c8d50f383e6c5cf7dc339f48ee26bdf2a343baf55bd7b69c998feeaf81297fb981f1a194f11044b11e2d04d2b751efe9bd984cb1b7e3cddee878886a11ca1d7a96aebb607b5c91929d577cefd002c3e52cae85aa509a2091c349ed1d26684a07e1b2e1f57fdfdccb9d6e191e57d763134e3cc0b65778ad1ec653f54acca42cf907c7225908890c21b5472e25f7bdb9a9b5340bbcb052a9bcb0f675e3b8e083c9cd996db40602befc938f8f08684e03a3453822d1e6a54c7f82cc2d75b345f7782b8c9939bae2553800630472777f28756c3a11d22d3b0361595913fa46153c6ca2e7cd49692a15e6ceab04d2c939189409aa24f6082606fa9a45202e19398b1ca1fc65610b2882432fb12c5d173647de10b58997975e707fa3109479456f8bea9e4e4af78decc8039a20140e8bcf7040b4a261050273e0699db5caddcbbd31bf1c31d33c9729e6f3daa595a09e55fcb1d188f31ace2e16de3be028e62198246d88196ef0e086b3f5de54001fd37f88b6d75f88b9fc5deea8ecf27ce11cee2d0b96cef5c420eceee664171855c89163dfe80d4b2f3c968f33d59e040c9beced63629361e5ed188d4c9a64eb7db70fd0c75f13eefa506b419cbbc3fbb794f47178e8b4c09a65ea2643e2011da35a293cfe5023708606b0dc6b8667766346f44f67e979dc62ca1d2d91cc0926df4d514b865916f77f33e46c94b6fb79afb0a1360332c2fecc91edcb1d56bb0c43a335506bf25b5840d40fa61382d6c071ddd84e8e2c0b9f864dbc41d4c82441dfd83a9262565d64fdd6e18ef8e521bad9e16d480706f08e25001511c658a47ecfd85264af8ff47cb9abeff25ae5e52222d5ef966c9e60013a30f6791c206af6fa2cacdcff1821a79ed2fa42a7015f662a5ff52be954215d61ee36e4d0acfbd17e0ba7ba72cddb8662dd5598b8985880ed487eb58eadcea38fd79540589f37b4049cfdb8fa77e94f3ab5d58b5294e8bb1d50fb3223452001428a80626ec2988320b7b35339ea8005157d911738e6801d75a21fd40de2bda2a029cfaebe12c66268bf45e8cd4c4c5023c84ab18b9abbc57bd9571ee00567df601ede8c7802b48bb51fbfc90efa3bfff3cfc84567c9220e645b969b967f45915ac4fe5180c99b159244daec6d3a9242081a0aacd471de6aa148f6795814bdb62839d55ca854512b637611a6f421eae2cbf61af098afd0225cc68dcfcab7c3ae37677f49e75729c6dbb2af9b518b408b5142581b96de02d1a483cb4ef9705ee85fc61dd79f4e7afec2fcf11a3bad292222d6f965ad873c4c2ff6e38e6b430905c99d70bded46818bc23cce2cd5ecc5ba81195d4ecac1f37ba925f5ccabad1211d2eaa3952e53264cd9ef0d4384c8fd2bd41152ebfaf10903b4e5fb71e4b86719aea8ef5edd6d50b057d63626c0216c104d7469fa16334f059d857fe8185fb07d168659068d17fb92e50e4f1a8458d151c46c27aff1562c1738c5f8c42dfb085dcffe6561611e9b6c870eab9fac729bd3361185be6d7304ee9d55e7a4c5e77e2ac1fee3903ad4b33fba958ff2cc563e63e77d07a0eb5d93609958dce5f5ead795613d3d223e0b3a32d4c387ce88f6ee5f419fe6edaf7b8835365e0391f290fc6062e40a0d6ee237e52f937df6ea05bd650054a6b7fe1ae8fbe746fea28842892d67b39934193c558db74f97c577e019e8f6cc551d2f9fbf1058848219381a9256ca1b15fde7e6c3747e0d132cd4d2d77d6935b2c81e956047834958c898ef173f6c64c9f28ce3d79d8edf9888d845e5abd9bb4d181dfb6f247564edf3193a8e3dadf52ec86ca699d44b2aea34d35c908db90881102bd19ae0c0691a86eaba527407b011f0c7b4681aa469b4598651e367746d2f9c0b69ea3998c26eff0869a0025c8124f4cb752e6ebbe26bf175492ef1c32b9f2cda0a202c8108d603e44d20dfdb3ba7bde464c74e7e0961ad880c15dbc73e99759fbf6e9a07b6bce5019b790c5a2548e4ae94285b5948bd67b8f5a3a8d9c2138616bbf91a04a8b0cfa4af561b824690fdd24eff07f24c9a54421b964f8b5106900aa840db23eff1800aa366bc996ba70faa40962647f3e789931aef2fe7e1f8e6c29c63f2a7836d305a1b03a0b0e8ffac425a4fce319c88d45fd6ba1f10b0260d05975b6cba6947d95b315760012b0331963c28c7de43f233ed59530ede79bfabc498e417023a17adff649765c2dc35e3797ba866927165eb2167af1d6662e3be14c1538576213d8e66e0f665ee9379eb94eab70957bfe35642a9a7e3d5cbd0f328954509375bcc69821085b7ffde4453f8410819340be50c9f0e73a77ccf714bc68040e2436115910cd3008a0d2e56fd50e206399e421ff7b831735d5d41b88ad0a4e812ac4e7b936660b6612df8d5bb33791b7a1a37184e7a30b47a27eabaad4e8e8531501c896c573db45b424204440bc0ec089cd63db18318ce31c190367089a954702ca74eb9ee5e2cc1f7637fae32a3873f1dc6370dd484e89f5e187c2b3a3a179feaaac05559baa6057ce98e6c934cd42b55eacc6c9f2a61abfd21b6851d7a7e33eccbc5d4f7016b90c31839e6b2aa0d635d5fc9bb46d8f3daed2bff69279072b8e3ce6afffe7c149678cff8ac7fbc2f77dd935d189b45ab33911281c3724c0787c46ea6beef3585c34db50013c996fbb3a28071caff7d4efd3bdb03787cf536077484fab3ffd98dc70420890840b976e7a8770e97f1e16d8987df68895169f3c7b7d946f43272e24265b8ac8d4c49a86b0c522ca010997c6a535818964d71785dc0a9e880b84ca093b6f23c43a1eda15c1bd3cdd5041af93bf5c83f1254b5fa104fc754302a859f72027661c3055beaf3ab3f596ef3f7c664384e1a75697a7111b0588ecb6c22ef12e9cd767c52ac88030a2f218a636dabfca4fae2d4a9fe5acccd956cf58f37e1335b58804e67d642bef657304865d07e4b7e758f75a7140cd2650b06211b577c3c38215f6e8f747f2d7490f878b7aaaeadd3aeb43fefb1ce3fe8011f5950d9f2b00d3e8f7388060975967de2459c7977799acd69ad29e8c791102e362e2270a3125be80e2a0eab15380c03156c7e3d80ea744969184031b023dc0a27547987c609f21f63ea9b697464b4d8984c9f9e2b58d8eb1026c120fafa75d43dd78ca7870f58a5e282478621519e1b51a1f37c7639a6c437061c3b054785c648a64c6010ac8caa92a7450fb7877facb8f313289e14f03368b3bcea1f7560b1093a7b03ce22c572633f723f44224ef2daebefb48c0212527cfb96887ffa407decb8c4a6142dd8c93da4f385732eb7424d09d5959725455e1933ba9cf1e7cecb8fa7af3d94bd93212a96d7cf1ef440860dbb22e206e60b34e9f3808769f05c8020865a362d8f76e2ba8d620f6083d27061fb3ebc9aff118cb127e64fad16ddc61545e83436cf75d7249073d69fabff47dfbb7d904912f7aa784057578e63ddbf27db9cc7bd0da3d75df24c829f89fc00db35543b1555af37e2793ba52b011e6e432339546fd909f79ecfbc8fab4965a5828fa7fd1292e649ed3249278bb726193263066da6be9371b48a24a33e271873466d30dcd8ff20092d7038be6178f42fc5196ff58d2a41daed3dc96a2da84455925b0d852fff432f17f3c65b94e16b5f2265ddbca6b2c6e612e2de87dc0bc60c44044e9ea98c94a63d39d9a2592cef8d5c257300dcf02aee788efd8dfec1a49de988846afcb5c26738f523cdfb51c07106856335bdf4cb7299dd08b44cbcdc3045ecf736ee53f73edd6956d30d80368e189356aa7804a7390e1aa0b5963c1e2fab66709beded7853051351588abdf3ed9deae3c8bb79ca5cea51471612e15475775c55d0389d523d09633ce18f3a5be8d8760d9cdd72f27dcb80e400c013fe5ba150972cb6a879bdf89253460f914c6ce1101be6d0e2b627e96f7b69fb930407ef0ef240137ae914bf033ac2bd62ad8ab0506ecaf4dac2dd5e1f3049ee4b82fa2b806b08a499b88d0de41b22b4bfde98efbf5facd0b58ccc0c6f2e5a9ff7c240e469d6b7f1bdda6dfeb62173c43a1a449a2ecb77f15f8e33f80768a4adf1a97bb3fcb30aeead091421822c0068f81aa390f7650a7764c15da3eb9d63b0477fb5034c8ed5e3b358796e9872f08283a2a79013b27cdb4ce81fadb72958d6c35e37dab485777ac34cf31e9265150a9a3371fb930aff4971223312cefe785c4765b9c0f6148970e92dd70abfcb7265e94c1aaddfe0de8de3dcf641b10c064a1bdb3c46f6ef586312639177278c183e7f39a55ca0027205273c9f87d9ac7443bef86ac547382d19de21f4bfb17c8b028f7ce2fb0cd1a6f1d6cf70d9ab08afdcfa0127d023d3a9e3284e21132dab03d89aa3d14e58cf8864fd42a8ff3b847787657253acc1cdaac2b6348c59aa05f0061b7f127c02bfdf820a249f54c322cea375eb30da397124baf89534fe13be842933f1f0ccfcf3cfef04cf67eb2ea8948779ae82f0a852396e8b6f3639cee6b9cc83983526745fb5da064aa049e8922791fc1dde3a40759391ee21f877bcaa9b405f29ae9d10282415de4f12573c1e92bdca20c7eb1fb2b065288b3b86e045fb8ca2c8f1d9ef012c019ae9e33521c06449e5cd4c0e1f295b10aef13e4e8e856eb1ce584feb51ed6182ab58607557c6ae5f916eb39856ec5b76d51ae78eb95800d327964a536ec08e46d456259623f3ca89639bed4fe1ebf083ef1c639c9efb61eb1db5da579f08064a641566479a7eac1171babde423be76769e063f4ef61671d4e61ab3a39635c679a48be446f4b0f0da283a9090788d77cd62695a251baa456456049de0c6cb2517d54d2ffbc12774cf8597e24bcb03bdd68e7b0b49d3dd0e9373a08fafddea5d2201155ba4d58f53a96e71e7f9084533ccca5697db22bbe6306bc8312d512205fd9bbaea44b64b7032009a639dbc6fa1a989decbf6b4643a3d4e1f93f783bd4bb1779a9124dc22da98599d90ae241f5f1cfe8a0d26d5fa7f0c018cfd98860809e0c6c85163b48b01436f19eb66b940662c6d1ef8cc468593d7509104a2990b0e7644fbab988ab5602a0d9d6039f44151d960441f054c3a30e292c40772b2d91efba1fe864ecc367ad7621d4036d172c93c34b9aed30ea71a8c14bd372edd60a4813d17027dbe377acc1ca72fe72bf1ba341b0b8717f91193fb8ec391e9e98a00bc43c7933775ee4dfd77f1fa60cf5c70350c44a609549716d2e30512c75473bf72e56425a4dbabcd5460a249cb898aabb774cad5b3612e3da94f16652922eb0a9bbeeaa5bc671fdef853ba8fd2c086b7cc5267b9db8c748ccdad34546497c79e55ed9cd32569a6b760cbbcfdfef0147029a57b2ccf42fab96ef339621c23bbfbf823c84b1cc4b960aaf7fb961cacb61f5f9f7955c9c70c81050932de7cccc6b89f5deae1f653669d6fcf3d118a1f933ab429d714f02b7681e411368f6395d77ce81b67420c67b576369dfddb53dbc9ad6a0864f22fa80944c9ff82e6fc7257a4d9f4f7046653e2e73b25d1f79278b4c032abcae1df156d136a65fdd6358da47bf2fc15fe62899e1d13b5ac466911016222c07d8cb7d574a1dcbeaec16b8470045013eb76b332ddeb481d6d042e79b7dc5e0535ea8b5257d991e15b684527e460de2c544b13c9289e52669c6d6b3cdc175dac2578fed65a1a8ebf4ad6613cd6099eb3c7832d1929c923344379b954401cc9e3779af0b974d767e626d2f16f12315f303a1a24211def171270a0200116145825ac016259d8963cb257de1579d72ae191a241d87fa3aeb30ead3d460bb04eaf4e01150430af52f28ad5bb6436ee1d77e4d54abca7e64eb5fb348167dd0a146c18c9397d4d783683c47ac9e720b007529d778cf67ba4f5bb9e778c7eb2dda779e31c8418887621fcfdf181a0f90b2caa30673319b672a7e7ad12ebff20beb3b19360c2bb7ab6a8b2ed133e168de358083b31f26f3cf0eb2408ea480e6faffe62c630e66e7f52901a2394d5c7e6a394d4e68f81b4a5deaafba6c1c3bf337e747b69078966a03459289d13272eac73f6dd61e3f367dc68f1a3a4d6b8177a85385f62f095","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
