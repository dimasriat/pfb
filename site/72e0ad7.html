<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93ace7694c694207e1c3b85f80b8499937e2c0e9eccc8bb3843b474674e54893c6e2a89b70269f676d09c1150786c38499dfbeb2ebd2a68caeb58d92705b9d4d5ee0b0b5aecbb66655fd85346545f7e151acbfb219162c1f5bd4179030faa73ae1272da8407899402daa3cad037abc1e678659c6d3c1deeba73f1a3d444caa9b90c308fc8a9c2056bc2509486d664dfde836c1cd5a00d18412659dfce58a92e0d6e36ed71776c6df533c76101f0662fde1f05435f066b218f58c14a9998654f03e45e4c0b593c614e793e55d816799277d43d5beb26b976280bbbc60d86480de0d00e08a8580f2fd6181e9fc0a5f1659ca60f7ccbefa463add71105c9a0c3a2703d5dff6ee58a232ef2fc554df0f02f6331f8dc14d2cceceff0282eb0ece759979484b37a1843c55494a0c878ef4837874d471dfce2edcd1e577df1a2f59591766cd30b1880c5896d71433a6bbafff5b4e188ecff19510f272eb696bad42d7a6100c5eeb326d3390b7f175968051b2773aa6b69907a0f2731dfce0a49165219d01fbe8b71d7eb09437e47ae0c7358df95247ec27bb0e6f5f50c142f05849e41ecdfd45e757f1fb368245e2be40bdd87c32b763e40045be6858f89fab41c62360032bbf6d8a8c9f44f4abd5b09ff597767646be9b9dccebbf9d0b36a41c61358da0e3a8d013932ae6358d9d23d73f7f3f53c90e558eac450711f6d38d9ee84eb1df03ebbb640e037b76f1c250ac8b4f8e5c4ae55c2c596a90eecb6cb3b982b5f9cda4c7e53b0bfdddf25bf58efb9508edb30696f8f50f5f031d4cfccdf95573eeaad89daedd5efece7c46730a8f72af79311a785958c24960d62b73ae7cd2edcaff9c676bf92b49db18b84062ebf57c2094ff260333424a2901f818769752ded5a6a143c3242432849b2e7d73a25b1e67b73bfbc0b538f97d2a170c360a60496e7883be8abe62ab75af032ed3b9f2f2998792e7a172bfea28f89cc5e3b1acc35d4eb7682bdaeffc85893fd236fb023a57ef8b53578dc927b45564be06bd79e06f0d83bb38d5a6c23e3cc4e5a2ec6813d5650ed2af5587e0146161dc133f06dd6f78c4cb082dac32b9ce46cb8954bde87d280c4649457a6e29ca4ae3d7d1eb94382b5c7ca6f6ba2cb9ed85abf20079f32bc9fad2a4a6e87cdb2af1a0acbaeea5435e090f444747757e5792c295cd51926d0e94ff35fd145fdcfb09b4f70eb1e761348a35e60a9b9f2b1f43033138761efb6e529c36e31d8530386a0a01a18a1c143d59c5b23c5fd858e2be6d1540dc996dca448a825a212eaf91b43b8e185ee8874fcda8fc5188cec7eb16f96810299c3051595f69a95bdaff6d231c98d35fc0367ad901183af96cb4b355c242f023f1df9b854351203901a402f0b878f401dd92e731a75e05c567e89a7b7cb3cd51e0a533f69b50e6e0781a96697771d59502e54d275d2298c96e01fbd9e320445f5caae77e8bf1d6dc99819cce702e4948b6cbdd701d6f051d2a86c5e999a0c6e20065592d49466957bd65e7f6ddd1b5addab97b9c37bff1459c6a3ee9d47c98cb5a58b7416e51eb086874c81df7890298177591eaeedbf50d7756c0b48b882ba25eec9580ab8b0a1037d3ac28ffc4c2102c1dc73ce61a5c73e373b6b973596634b5fee3c87df59d3e2cd0feb9488b8a7221df4210e7a84cc7dd97ab7bdf4688ffb127a023960f1d94b11238ffd3b379d5328147938969c10917b989bd341ac6482832a79826f7dea0292e0a9aa5f0bcefa93d7595babab79c2aef17089958b6dcff87efad93972fb192d8c88388f126ef8c1baeee99efaa2fd8027b52c2dc2c439b947f9e0b4de4785d1a5886f22735c2d6c6a00e194c237a84522d281151071a7ab1730ecc978c7837498ba9dd5b2de71bfc44383efbb6b1e6a57b17c6bdfac76beac1e920312b49823e04951be8c651ddb09dcb17602f930bae59344f367950001096e38832771cd72ce033ea87aa4d0e7baadb6809601a8fb54d9396357ce044793a43071df33a83b2ab5c09b72f55447ceb7c60133349554e8085dc7c55956977667decd49a98bb9133560eff6590ac76bab7920fa713d2f2dfad0c4d77941f4bfd91f0d35ea1dff636f8ddfbd78dd3157332563fd78b40aa55596b33c43ed825dea46406510fda3428e31afc1c2a86539579dc1f8bf47d5be97a9a5a9aa5fbe3884a3627b71cbbc0a1600da688449309463633cce6512b1d65547ae57dd24743a70542aa19fe658dcc035e79b488818d36547fc84bb3af07117f9ac663e5bb81241c9f552c215449d7bfd127403148b9001b41cb8117a157f66507223244c7b3b3ebb3dcc5e6c2ab8d2c12e28ae4f371bc998a2e5542a10bfb6980eefe3c18590ddddbced4ed238f7b874888b4f99a07be433b342536c67e180fe688bc68f1add96e67083e2fbd58efb6f23ccf6aae9e82dd52d0a908308cc1ea54b1bf00a7d364a0079e71cd7c487e1d2e951f0a99669b4563259e8f09252a752215869f48f288286944829167aa5662a1909fae7bfde8e41705b2416a9066624b3e2b505fb35c11bccae2de7f00f06202ed483944b2b044cfd0d6b693c3c9e5f5d3a2397c3b795400f9b0a787939deb72dfbe733cc95fde8482e7faa1722505ddfce4814dc2b89dc8a3f1291fd17c8f757e5967608adcb6cd776bdaadfca3b899da12daf8b7ca264ab0d29312941abb34db3569188d4e68c576a6088d5c8c34be47d9908cb3748acac86135833a76b4ba58c24a436ed266ac306027657013db3928adc400f30ff64fe5da01d2611ac6dd239895baec666cf07bfa24b9e6281b09493d72ec3b2d8d994563b5bd9b37539ff8bc207f4c63e0c3d69e34aef9948446696f6fbf91c9226b229cbd4db79dc20143d5f5f18824f1184c0dab4bc78e47b9ebf3e50947a562e2b2bec0ac54286f690f8194db6a64af5a70b5e70d633df2b9d241d8de4c2ab551cedb93443a2638a4cc1ab798d512b4e965a8d1a0915394d70dcb023d04755cad741933ed85ca08a211eb42578aafc7399cbb96ddb1872e0ae2a7a866dbe88dd764330b0b356552bc6a6788413eaa61f9f57645399863c8914ba3ae2d45df118ee04ff0d8a030305af664cb622fbb9f0bd96db58edb8a17db80b889230950f7620b37e7383dddc175d6eff74ce6cd0310deebd486324d37127e7156cfb22ec2063e3d51cb75bd76960b44f9e10110b9fef98dc5a2bac092e62dbdebda386fac1b709730a5633d040aa5b0c6f4f17e43ce3052df82a5d75cb685a36f713bb321d1ab808cf18f1cf7a309cc0501a43649a7124fc9f2fc631ab1a67e54129325b8a633d951341cb8a5b70b655bd0c647634efc83521ab0e8830aeff4be8564a3e6a7c5664e371739052ee8e032e979852551ff1c3b724b2a18b126b703bf93a1b75da299ae99642495aab48e7dab504023ab312cbbf01455265c5f694ecda73cc6fa9546f183854859c4f52e91126e17030b413dfb3bf5b7d0b1006c8c86e6d768a0952152ebe83bc5805fcb46c542d9fa0afb2593a68bf03888807940233313ea131b1be3a1d6107cd16d9e1cb973426f963560e8ec0cd317e09a909d0230fa3af845b18131fcfb1e88aba3e93e9526682a9880082807868f40732eb007e37e2023a6ec56ff52f58526b891a76b8a14304d540b23104b7d04ac6ea09365b847334f0da71a3551f81d4552f2a7724eba151a199790f176a86d0578c4ef1cf747ad1b1569b7f61fc5b8090bd0c3bdc7018e3630858143f82b052a98f2c4f03c6770f306baa58bbdc51f9e3d31a1593acb3685b4363324cc9a3009663aa3621c9582ff8762c9fef28012a9681f7ddafcb2be7acc5824d58a03b4250bf6e75121085500b65c0f5fd172185599e1f06f8242c2bd921500858574f3288d228bd1b41894e184837352bc2571daab5a90d04c2415bd7dfc5c19548abeed6bff6628de9f3fb44abc6cb9615e1fecc053811a89d3ed25c6df3d4cca5f23c0ffc863ae9447137dff2e296a8bdef95871b3492a5b4d1234bfde52b2e936785ab0fb003fdc906e2e93e7fde26c7b38e9da548de9051428afcd9c47f0bada0782e14bd66c8effc2f7c287fa67e0877b4b684fccd326733717ff1e86e69f97ef4abbb8581f16072c151fce48708e4af3c14838d18660f49d0c5a6b95ed35e2bb50ac66b1560a58a3029b9c7fe2d3aff1843712db184ce4a3d11b185488ba9c10b6ec92802108567ae29e9cf97c7264163193cf28b5ec226f7ad0178b508c4498ae6043cb16f5ddf07df4b49cba914b618b9cbb640fab10915f326f06fab5cacb55fdd9d325c3796a574cd69f4a7b4e0a82b5bf60e098158d56985a7b8b9ac2efdc40944d24be23fcc6f06ab6ca8bc7b1bea4d78e42c6a504c58dfa2c9927f9cc8a1ae3c7c4d23ce90c5f4e74bfe08dac31c82fa420778e6f2b48fac8e94bf291276043cc15d6769129b4ccf34687fb3d815c1b4cbb91c484f860737a4781cf7716424d506e449ee40255bef18555db019d74b24bf05fc4f7d1cb963e93727f465c7105bcab857412aa9d5c270c5a3523a5051585dcd27442d5ae28e89878272b5420de80ddf2cbc400cd1ba44c9ea0aaa8aeaf6203ff37301383ed3f44ced3229d8630f5937330ac8bd356d544aa944c70b3e8c98d76902f2a275c1dca514b7fa495424c59647981e52333486c4145d439bf0f828e114b70f592a8f2604d06b518944759a378767f4d629fcbf219cec595fbddd8f5aa2b03269256c4a4359c862559b775cd0c2d3b5ec2105174271617b61ae2e0dfc2fbd517b12a4fc91cb38701c3ecc4efc013c3fe594a4e820e5f9fdbc66591578c3e0695fe47bc299fdac11c2178d60770605af85744cd8bbd1db299ceb07fd257f02099f33431cc3ecc3322a65a7d1b1a0c47a9a36db93a0e3462d11f56336c00c04d2e84af898ddfc1ed0c7f38d2099efde2a028e6d6c27916447778cb3a171ab4ea3e70c2aba131fe1be495092f999d086e161794af8d43775523e241189db760603aae16285b2a990a5a10168383bee25b2b2adb9db2c6111d9dd568f00f1271a4cc62491862886be0867738bd25ba7448c263ae4ec9931ed1f65aff0c52e22b19356ae38a2e34966186ad127a7cd90db588cb65b41676277c82c9819791bad0065e0c7e3e17ed5ec7f4470bac8d861274495bd6d3a70ff9fc276714b1ca28ccf0601ba9d537d09827e42797d34105648c7a2111ff677b226183c7f7f4ebb7fc7756c9989a3896a3826c11f3270e4c3c79c33e2c5b05cdb2bc306525ebbc54015997f47fe1a9576490bd60a334b4afe9988bdfb3f3933141ca78c8e3b0338722d2832d89f3d7ca9700556e35c69401a39e8877813e094a5968e2a211f4e5f1f944bb496554cbb5756633debb7202875e03059d18c5a5a1b6d70ccc26520e3a6ffa3a61dfda0a1932c7ef4e0ceef504c89005076ebaf0cc1520ae748640bc4f99d6cfeff678ecdb4a872546f6c11c397f7cb7d04b3275ac95036cfe96bab889a2b4d5bd3ccf29d8468e18ff4c50151bbfb28003f97819a05ff2c8674b7bd7501121f72876020856c9f58a50ae59a904bc83c94ec2b228d67c37ffd18e4ab7cb8e270f7a35fb3612269931537abb55d080bf3d696e0e68cd04ee674c6fcd6a530cd762fc9504a3c0ef2ebbdb35d75bc38a341d67b6d05028b506cb480affde67f9b53bc246b5d1492e685248c4cc760179964f90705dd78b4bb9ec45aa9aa1219a51f08c5b23fa05fa2c5a7ae64415911795d006e44ddb4cfcbfb7fc3e970b2c267e45852a4471da45c536300ebff885bbd71d6c921c89f3cc508353a8a7987a6f792840507315a74e8442c310a815aa4fdc50030c1259051f247f6a0202c8bb6498f07d30637ca739bca56f2029cc4a9490cc686e6cb3877e03815f6101a8a1f2b241d9ca55f743d2ecd3ecc986cef0de2ed22494d1c613cf164daa4c564c391ae21cad8176cd16c4e67f0b3aede9b1baa959bf26b0a12d8cd877839d278f2b002e033de404c343af10fe45b43097dca679a9c59af2dfa9fde640f43e37b112b2f0d4f3e309407cb02bfe7251ffefe367a5f50b7230e3d60b6831a43ca9439a66266b04cd76e2550be763a5b82af9f18fc7e220898e002419d612908d29dd2e57d8e96a0e53614403be7ad9c7b3b180d1152932dba99a75b98f791d9acd26554c1d4aab362c9f393d333ed2f4c7535daa6b49c75513599100e78f3c671fccbdd0f16c044b8ec823fc91a23dcd640f6b4ea4e5498830812f5d1137330efd3c599fa0373610195aad1f27cddfca5b6adfc6d1ab78a284ccd479d504af6403f5c32c3d3131184472f0464fa861d596b2263b6ed486764b37e941db1de35d8a18fb48f37025388786b59a6127c16669a15a0c9647567e3485124d5746c45a9c26890987749e5becdfb2420dfb08847c3503a2145a513669c8a824ad21e19f72754d6dccddfa0d63d2dba0b078255c5af4f1ccf53773424e4511d8792475667a35be9aebd50ba4182be92722b250b654fb4c8c311983f8d974c69937f8b6f60d5c569aab7dda4f2f6534a96d707d868408120360fb8d79ae3d37ea0d0456c040e113d06bcd3d44f05cbbde7737224cad9de93dbbc28c64cbd7740c88a70d9c4fe317d586032547e58f3c8d175b51a9dc395df71528325c591d844318ca656205ddf7e73dcd0139bd2eb24fe6b34f0853699e066985b93392c8c3ac2b6f0f0b05222f0db637b992dca7e9628e637ed40eecbe993f1f00b3acbe6b80ad8fa431dbb3e5f7783944b96b91bbcfbbc6fe996c439732075c08cf5826a73cc9034eaae99322a2f7a076bd1159bbe6bfed0689b337b033760d98f3bc64bf43fceeda59071ac217d53eda69f12d2e7f6b7133eeb7ca41e4f7cd908dde5ab83c7758dd94e8ea6ecda085c335ff2b6894fa9d94b48542f65057062eef360a13dd01351070be78de9b75a901927d9cd99f4696095ae029b60f93fc17d2c05fc2c80c83980c5b9d86fa20087f2687451b6db24fef55f9dccd0cecd7beec3c6992438ad331919779b4b456e7f4654bd7b2c7e4caafcec2d680b8e13ff7ef8612742e139e6af0e3e0eee37bf8e9cfd87850dd4ce8c2b7ca94459d8b311528579d52c7e07dced9e984e57753ca17305db9e9b29728ecebd898e0dda420258e54a3d704b74ffb11207497a7fd5aa3273a039eb88fcc373cab79f37b2d868d73fc82589fcc5543d49cc10669372e6835dde2c4da9f650bc84f0cb3650413a782211d3c36a613b96315db7d8e3aab0f890bfc7d9d0233ce6777c2c86f48747506c084adffd3a1778b866cb1e72199e457e21a83bb1b92f073fa0224b2432204c6230b2340f9141d9d21a143d5909f278494aa87d00c531db78ba56bf768ea3b57aa711fb179939088cdf0d548de123324d586c9448b738943d532dd01bdeaaae9e26d3c3909cd4f1d6e6cbb5a3c12bcb3fd96632b90cf63df47ed4050206a6b9861260ad6e8cbc4da1f41e71e2a64967db3908740fafcb03ffa32b8c0e332ab13b595b5b9cf9575797afec14e8dd5c991553a03d82e99869a01e3ec860ccfd97506e6fe0acc922450e5c791ee50e009566195794abf9178e27dd3ca81e25dc67040129010232e0c236f74b4e0b28940ac10db9f04f97db0893463ad5bdd3159c4dc24c2e5679a28032865e9599c22a79e10f3a8b8819c0c399cf8de0d9a9c6fede3074f69951a2166157a1d318c6409a7e2d80c1f61000732bcd5dda3f44a7fe09e38d078f16dc4a0aba945b88e3c3d9d29dedf1028f2431e4caf96e9e706039dd31e6cab5e68001c1faef1370e7ebb94d738334cfcf91222b915bed42cbba3026ca17a361cdb45cf26842c8ce14e432605b7c10f65c00edbc469f4e2ff6830f369c1b34d22a82c75589db9f7fad15826caaec1f28be78ca54029ee0651134fb8dc92779b5d311620756f6d820135c6e29bfa50abc9f381ab030bc5ae98aa5394a92046b0884892200962253eab9cd9a696defe41ac213f32bc2aa54b121e1f4c0ab2257aa85b7834d88dbc61269b05a26bbe0a0977071e7d1aed9690e1326ffaa4b3ea854c066e11b3bcc9c65dcf77f4e7cdc2516a098d9df0cf3601796e21161d1db7e668eeecc8a88d69c815997302bcf00788a484daa7aaa926a93dc622fc0949f5fb8924a1c037034f1641a2ceabec1106697cdf377ddf4b5f804dcc0ee2007d15241043aa848653b02480a0214fd33ca80650bdf911404788fe54a7be48ba473a6fac942e1fd18a9f042870610d67e36a6d9175333256e6af0ba0cd31ec2c024117d53d997beb7a649b95d51678df50830c04ba7d9764a80a72105114dd37186a53d9e0cbc4b70f7efc5de41f8981a5d01f30868e124cadaee7fea5c799bdd5ca2f14e090945e78c309769a3ade61b29d13b19cc61071f3a9109c88f5099c853dc2ff0b6fff52ddddf59081995d53e84e41d698540d0e002d38c31b71fe0cb71bf17f876bc09548e827a1a736ad66bbab31cdf5f61d25db8bded3f193a49d0437b92b857c96b76defce3574039359ef330257c243073032a92b9cad221b3de9db3f91d2bd0108d8609d16595a777963f34289725afba947b9f3eac73762c46003bef3ecb9ebc023ec358ef5a85e7964d0f1f32638613965aed0c598a53bf71c34e4e9e84e51e564e8ff52e1e4296624499fd465e98ea159b6898cd5d9406840b41213096135e8eecd3324fb4f882cba32c96e952483f70cf6fc67b1c85614167c38ca85d8c1c7a2f38c12716e2b7b2b7cec57ec5ab97e45ea0e95560f0f1d0b68caed749f32d3012216d45fdab341b91eeb5eb262817b27d64e96b7884d3d681f7a24105d6b371bb00573875abb615a48662ff459833d26ac8087bd9347e26d6238fb13881d5ae848e848bae7800c9ff723b60d0be5ec76762acababffdad72f7f0345063acc757e5b8a6780946f8b8fca993a0993ba1034682fa137f441eedc2e94f168fcf4a6bf5f83c9c513c7ce67f50249c1dbbd51d295bdea6caf7a9251fc0de3160b8287cc1868daef69507cfb3a14e2807783dbb86874e689854d534ad491c1f01970d794021c01be6541dd3a5073c0b1e1a00c8fe0c53ea537d2163be576f1dfeef32e7a3864318da4fc531e64c1ef846ec481ad6cbffa127c2a4bb731c4376aeb5de19849d6a8a604ded7d39b394b129e817abd3fd0b704db211833d54120036555e02ff5164a3bb51048fb30c49177c667e93c3e2f65ff7ee3b2f448a5b17a048a21c926466d09414f71fa376bb318c6ae93d2ecaacd8803f0ad03c93611553b896c75ad6dd6c0645fb57f0b1c39b87f99424004252f31b8b4155789af1f83e965e53345af2cf99badefbf6e7df6ffb7fe8d7eedd628f084dc793ad6cd22b43773e8274035f4b310d08e48fe1a9ede2158da2f510b3eb6b3c8b00dd50468ef088ce89bb22c5977cd7b8b817a09551a68151a0e479cfa88ef1026658cc022e13b8c636f7579e76bcc7049af8150c5de5b5b7aba667d94cd24be6699884fd168ca3958ef52871891fd9655a468a97ea06eeb428323fee8a6547cb7e44f387da7d36d53f7b3cc037104af2753df33bedb93b0e5029f48493080e43de0900419e22b677e302d3fdf16bbb2999e1db1d9d1e474d32c95ad21bedddc503a0bdf8980511013d143dc6ddd14d4d3329c587a47e885598411ea470167a13915f973e8a10a8b4af293418b897d9974734f534bcd31bcf1369d964796df912b1f1a2625eb25da4cd2558f50a837f4453fa7588e05c625875c58812d46132479b57c2ea962ba68b1b844388999877a81e123fb7752f57cbf6756b96f6a2019bc127dafa5139dffc2323ccda8ca22eea52be2888ae3ba954f70d51c8261ad415dcd2260dd51a5724711e1865d198ea67dcd25c569428d30237b313b0fc1f08435de7c9f12f78d2157d04c088fc57d0e15fe0269bc84baccb8f058e83f00828465ba454a636166880cbf8c3a6c7c7af143d7cc23df5f1f14f74231ae048c9387b7634992dc3bce210cdbf65164b3f1ee0b185361bd6aa284247c25e1f06626a3e5ee627e6666f60eee0e880ea2a762ae0ca4085a1daa3cf6f85fd99572f440b0f35c8c2794ae8445145324f51c7efbd0fc15b4223733bbdb50fabcd771107e62dcceb494cc69e900dfd91cf59c43bf16d8f2cea0378be7e4c29ef7cea3e042e9a14da35c52acebd03b9b82a34ce1134eefd14749fb4fa360d73384cdf0fe6088c88fb60ba5b4a20c8d030f91aaaef47fec7f74c7d4408f0a2fd437dd5eec2ef20f8712f1a38ad392eb230adbd64513d90a36cc7c03ed9e804ce9da213f87dab66c6c31863d8ed18ce23fb98e50848aa2a304588158ed37ebb03a0380203e96e7e2a2b5ae770fe8c7df4744fb218114fd13c63a62a3bb07b84dd2f2dce3b814519eb02cd8cdcacf24ffedbf7d6420a7352ae780645ee56252d860915aa13945bc1cb01f48586b84c4ba4e433881d2305803e27ebd475fe4c9789fff4737c1af56aaaff44a05b103379337b0b95655aab95e072ea3c7be6d69a370c58f31b4e50219b61f1befd724048fdf00be0ab64a70bd741ef3ebe23529c6c75e50d09edce358140019f6b1cab34fbd241ab86908d967e2fec32dca0b937873c3c9a4e068f4b26c9b1c2f60762e07ec8601514719e5c9328c113a88b79e03515299786d40ff4d72add3d3ff5c7376ad08afb3407d439ccfd2c016e7cc63eebcf55a8cbd67e0aa0f6efc49cd7d4d5423bbcb4733c45e418665503c3eebce510ec3bf6cc997241190e619e96a7800e36a19a65cf32c7cae6d513fdb0166cc2376b31bef6bbf34de028ff8ab381dce0c4b3d720ac8cff8737a5f67e7a288c56cf2cfe4b5181152b563aa4a5f8e18d5bb8b1a95621d35a0738834e3dcd5f229354245af00bef6905352cb055760f29051c89e9b238eabdfa977a845fd204c6ee0eae709c273f13f415417680f23d8cedcbf234e4b3b56bae081ce0f66797da5b48ce292f7920952b78d72b26e36602943c73d410649d296a66028a851f4ef310e89bb167f471b98c7238c5f05f4b8836a7169b1a538464198333476cef3882e5cc96d777dd5395302813a0778545270c39264c92331a69393cabbafab1221c6adcf7f921187a5b09f80661b79f2a9fbfc38a05da1b4304cc8e679a4178f58446fb8cad3192ef926982e4ca8261127501f86660cf3cebc3a558f9a8a1b6599a26c95389e346960e302e8e6b984d631b388c2c4fcf727992482112c3efe3b7cdef85de963492bd8e138d76b1f7c959c50bd39ba39a12828965a0553ab76de51b7aaa4396d40be1915effcce4a8651ca6b3e4e06dc2fb8df6cafa907f6da7db8c2bb4521f3338c018462de08ca8e88a2804c580ca6efaa6a945f0178a7baa1845587e43d21d6829e074731f682d00a66472e8020a3c71cc67b4349c72be6a2385cfb086fb47dc7a61f7870cca4f02f488d59acbe58d986f3c33a33c3604379afb65d05c7ebca431e8c3a64cdd7fba6508e68571b36f4dd80e74cbf50a8b87d8faaad1bd722306b844f618dd4cd165cc1fd883ceddede1e578260f9242090b50e01f344551586a5ea917cb80df8de7c683658dd391351946bc5c0e48d46b598545d40ab0d44e5f9c15727ed8f9980c8d448ede7bf467f0e14e2d68e7c3213d28f5dd339f9149817010661d292cc15e7283b3af2e6a851f704752476850e06776b75fb05264d229475e31f4a5b59997158c039ee4785328e668875a5e33576bf6c18e8f47009d4e90aa192177c832d36dd9d6104fe1e6d69daabfdc874072b1765111d5cfb1bade9589c33eeb26648cb7555b4237b822f59474715001d0461aaf037799241551583ce35cea3c17e6159f581db3dd88ce5859f841ddcd24936aa0047d19896dad640e546f499894ab29bf4da2ecd2b85c9357514bfc97b5851d3dc1a3ee4b51c5371554b920ba1a246d30c8667c965e43b49fba51929418ad057a4c3b6b4493b9b7ccaf1104ae97fa4a5a6a646009be81afd0e4054c4382351ce8c4b9760a8376b7807217556999afba9c3b5d1d12f8708444147a8aed9d0e8a4d55ed79ff29cec324b71336995c8723102d5458e688e918105bdfc0bd08547fec4c89ceca3a0d226b1d48fa37035ee02b4ab873dca4901190fcbc99ec48456943b37733e1269e0cce9b1028a7b775462389d4d2258372777e389fef9affc19fcd7d6864fe0121f6c1c48e54470d760d1275a6bbcb907b3219473468a71407dd074675ab6c8e17ce619b0b425f4ee38a9c55e0ffde0c7249bb93accc3f0e843d4855ad315e5ad57c14c836988695a69d4997b503b77963e296ee57a8d50a66fec77a59c8495b676cb1ea47528184c9e045bd2349ed1d5beecb5f3a28522545b711e443ac729bda60a426cda4767348f008380f77ba9ed29c754b00ecf3fc884e5a418dd25a1303c779bc0b92716838634859669649cac953e7c24266692386b8ad69f23ebf42fe41fcc9933a85a976c510a3d200e6d6e976af168401213bf64e617f11be8e31c4150f8543ae397210cfe1a05475d586095ae60cbc4d830d9c470b310f38945c00c2c3761187d6f96c05744a5e38b793c23ff290c356e1d148a7e44b1a2893a52c37d268ed5632fccbd8f921e199c49f87d4dabbca64c90460614aad41104a88c41f1b4c41ac93c0a82cec8d59fda3c06d5d9ab754beeb220598f322bba3193d91aea9159e0ca21efd13e97ac1e5cb8aec7471daf1f0f35e393e566f64d2118b4e9bf0fb7ace33ebc30705b7524650411517f8ddb7ac8c537c09208843c52973355b6ede9ef27db7b2bbae4a2dc2a8b122398d7842a0f94b23f09f9612fad3ee25aad43bc375a1a517288626d179dd8164f3a6fab7c9ae8f2acfaa8589a4b193ff5dd66e3295412cb3ca2af8515aef7a98981cd39ba25f000ba5b88bf4adc3f33fa152643cea4febfaa1585eaf3daf69b59756244d6292bc5accc33e2baefe724d085c57f957a4da12a575ba9123b2e6bc8532ead7cea8020eaa66ac87edd157fb2770ca9f78b6baa9ba406a1a3413dc4930688b0592dee9c85a0e39716d8261f9f8ef2e5d03b66eb9476c9d51967783310930ca4942c5b33357bda3be8037","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
