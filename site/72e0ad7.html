<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bf1f9eb589b66914e59a332dc62125bc29a1d38ab409309729ba6163ec7ec58a2edb9a69e308a699fbfeea2618ffa74b9b637b1a6c7a2d4b5c3b62b25ce0f7ad1fef91559dd19cb0fff05381328b651c0d14e8a5a7ae47649f66a4554805a5183e563d757e6e58c3523e45fb3d48ae30795ee211201f4b3e2157fe058a27bfb0d9141eaffc795744c0db5450dff452d6036fab7e0aa3e4622349688c6bf8fa0c47a3aa8e2a293d432ece0a73a51a027621963e2b58a4ee52ce5b7791e3babe65f10af4d086f5af6c0545e3a4957d354ee91f6f6843b432bf1b49167825c2d2350e4629a73e2bb2e2a205d3f8fd87082236b59aea5651bfa398198f90d6ed243536b96e7030f169e03504e08dc7bd69a1695d33319c6e4b4991922546e438d5656aace9ac89919b2823db5611fc6c65ad597bd4765023ff1bf1df3d9c55659443f4ae049a776f69c535878a7f6c3d096e927e2c9443f6476c5f5fa49ee1f0e52f6bfe00607c49aa0a3c1b7edea8941cc5399008331c08589975f51003e253ab19e2ba1c4e17ee5e396461d39dd15a48de328bfbb3697c8f45a02dcc643dc9fd05c9c1d0821d7b3236d64860219362b07bee435a2c7ad59f073c71420cc7b012f65d20086bd46a4a6ed3a3f6c62e1ce3e7ca0a8ae7d838e06dcfe80ccc1a35dc541cf0abe79430e1f1b042faaea8057e86ac8aba5beb4cf0bf1a70a11add63b1a534fb40393dc4b61da0987a77faccefdcf421c154d757936be7c31869c563eb9612c8765e5ccd717c0644c468bf019662ab989c5c71a26cd9ac027830ed1fe596e6b2cb9884ad237087c26eb5aba3688de08f17833a253aabe79ec48cff7a99292d3915c0bd69774bbf654e37b944d6b1ec06d24650935761e3177da60ec4a9dcf4a1f7ecb348e1ab242be5f0ba9770f7fb822073a91aad25622d8061b202f913f65d48de331f7b90e6f499f77fde881e52787eaed78fd66ea33aa2b8cc1e2e24551b6137dae3bfbefb381d279f7909aa71bd0e0683681ce5d35085449ce9cb20d0c5e5eb1b971591918734281bf66c260e4e55932ac37a50123a1474d8b7bcac832d8a7fe137bda494e5037a78e2e18541390906d6c82b33eef4e0dfac8ef6b7d90606d95f15c872cc7659848afbcd4138d62a116870b9d5670be14271fc50b6014889264b0545e7efa4ab98abcdbebc08faaff2e661867fa53424b05b38e4c9b55e9a504d52077274d59800b434825db7030ce2b09f515b8c5ce81352f0226341e5f805a7d7354560fe6b88fd5fe022fa8aa8a4aefe030379ee699631b31dc4e78508e71d0e99c76e2b50164b73db589f8c23489a167092b1029fb15e143906e0f088338faaf64c7954d183a867bfe8edf3078524f8660d5db529b4978f24118a9104f8a91d4c5612cc539fbdd1c79dd6b99df7cd6628f00fdbf0872b61d3ab8077beebf3c09fd08edb6f2b1b5b29fea8ad289b7351e38db7e7be1462158c0a42e03b02e58714d41fde8fdf65ba0a7d8f5a32b316804191312ee4703c43769232f74c80ee7e24a53f73ad3b707a00a03e83c55047221fa6727c17abb5e20ce9d99eb177f9b772a4d804b707276dfaaf0f351551135c6900c969864304d588e15242599aa57548d4dc8e424b868ecf4222290f4a20c366cb6183154c0027d41b6aa6700bc96f1ccde387deb767975661cf0db646a48222eef835727ad7aa48976fe0a8169ecb7aeab3426ec6957d6f56cd731932c4d1f8fdcc940b0e2a9e3bcef6ef58feb3f1109911cfd91321a6096686e3496a75ea50e073f0251e8461df466d7e51f9613afee2475b6a3ce19110fa8382ba8793fb738a41d37e33587a2b6d38fc483d522aa9ff120f3331d7d61b59afd228e242d22c8e6d4b318f21990eaaa70141334673647019bd48c285189709a8a6528ce08f6f2daee2f9fdeb6c68a60d71699dad4fbc852bac18c9c1f883e922103d2efb12a43a16aeb0e3a09ee0722c67133372aaa602e751b9d521f6bd4897bb4854bca83d90d2ae3f62a4eaf04994ba1a2b4d56a93cf46e37f8ec935759c8da2e3f11c728a396d9cae8160d9785d85603535414c0fc1d52b7f682a50763f5840df5446c44084ba8c5a0e98df64d5caed1bc88ce34b57f65551d80584b3153ad4d1e410d3ee6d7bcf254ff8bf9601e19065dd2f3133e1ead02394d0a59018ba2d15377f90117504b62ca769f6a882d2f41767531337063b5c6a51a76f907bdae71d81161c59e9b92ec1de9c9828a87eba01479ae43776452c8788175f456b7b3caf17496fc806e0367f29a7e0db41d1a92c6a8a207ccae0131d562aee04e1d89e99b681801cf86062b8ba6a627d139ff1508d24fb148d98f93edd981777b5171763b92215ec047462178b5018deb08b2d315bea0ba30d64babce3c0916b85bffb88f53553f1a3b6bdfdc7d36aa19905ae0eb492f3868ceedce5115f4de8f12790847f6e1b619e68d7ffc91e1b3fead28836345802d313817d91fa6c97a568934d3336d5ec3b79d3bad292ad029ddda06a4c9ddb0ebddb310c3dc3b87d5f48eb902ab81e84aed55a76382c8762ac195b4fc13671f17a6acc7a2591e3a0341ba4370c5d57d8bfb3a92e03fa9ed3b933a1528a7c8a67c2d4612837091015149a3316c8b8aa4b565af932b4df6d0479c9a245a5d144da0d62b9379f80300a20e6cc18b2ecd304d22b98daaaf4deb6a3da5612b97b1d5e4040603311f2e521db670450a5f656f4604ed59231b8c62033dc018692de7f154209a77bfb167a9044a2cc9d5204b85deca73931ce4da9d79cabb4ed59ee785f69d9b99cb41e7e48b4eff0212379232409001fd8df32aea1cbdd5c0a0b9167c3c48e2c7f1e428697cc2aa858447fe2a1fd6ec6a7e41839ffbf71a4e7fe5eeee7de1141fe33913c70d3b544142da6dbcdc6c37bcb24ea98bd1f61ab5050f72d23538bd98a2d9ae4d42ade280a6a91cc816b79168f705794479bbe31219aa06542424783204e2220eca607c3125ff42e1e7877bb58b1275876eea7c4d8c7aea398332085ff1ffe1d4b85245c329498ead9bc2ca5655788ad40b834509b5479be1e87ecc3304cb08b12f7c13881d9f935395ad94e2d627e9174e70d8a6fd4b4aa6590c71f4fae756de385ee1d8ce03dca46e4abbd55cc4e40a775b113052ee6c91d965f06d8ed43fea8d194c8287182d0082cd9188d49baaf4eb1347d3dedc03ac3a195d51a97a765ecceeb382d195594fe283bf361182c49bd98e33f304d86da7df290afe03d60ad913fe6cd7bbee26a0d5f1a005bcc3631b58b6749fab96204a1a464a0573cd4fd260c04e30f3cd18c2cbb39ff716ae88d8a8d2daba18f86c2dd31e1340b00e9413a7effdab78b967c0feb9d05161b784e97096f7bd835d8729253094f9dc10b12773375b5ae57a5b486c9db602a07ebdf5b3f7c025e26130268d5d21c045cec77aba24348b1427be4587defb22cc8f379e58ad5af0325991fd8f93fac9ae1ec783dab8d451305459591e9709e097637c914b1d80d594c44c48be579b1e0b29df97b8c9def7aac7ad0924322a7f5c51cc340c01539c0ccea9ad4e75d2e122a3e0c56393eebc93e07ad697433cb4f907a4c9966c5c4d971f38fcde326f66f4733746402a460c18af7bf506bc49e603468873b6f1b5ba53db546371f367de062b57fc2996ec55527ff52dc65b29b43d88aa62422058d509d772af577f61eb259d8f845f874b40b3d6338c52ce0b157dc76e32df627e6f66aa3732c25c26474db7074a77aef4f961e8eb05db74215fabf6c5cf3db848eb5830e0ebeea9139d7983d0bae178620ae2bd5d766abd8b101bec4a046917585e3cb12746cdb0944f3da1c76de46b461ff6523beddf1c07e15e5cbd66c3b34c3f164ef7fb46dc8cc82ceeaa22a2ab8297c01d5db04fdb6d6b89ad744aa3b7c7d90b21407e0eceeb7ae43e548aa45f7c22ce60c4ef52fa661148daea2badd2cc1fcbb297fac9b1a19cee2c821d8e2c3bd6bd9c568e1fb697a928f21237bd462bf29cf453097ea45bdbd5e9d39c5880d9112640bb436d230e3d646df0e1ceb48d3eb49e251a7614aa4f95bca9a75ea89323ba847c0ab9a4acaedae446275cb9772b9bd145b68eb1c326926e7c955ed511983e0f034ed27571c41feecf5185e844e3546da7aa2c8a53f6d76fa7c0b0575bde8328df1faba3b80e3031ba3a93f9bc20afa5ef22c4ca4a8f3eeda79e7bae672d41b479d5621d4e277d23959af938e0063b45c4d1f50c53f167d914b671ce921335af676bb349769055265d9078410c64775a4e82fde3e0ff3f6817643719b296a71c87d8f78191435e48c5bac7476d2c669a62652fdc22b20fc4f5e188d96425fa8fce1cc5f08db9701d1e2d2ab0d139c002503109577dee0430e4d6d3128235a4fc5e14b6ff62948d585293dd19cf5de3e0aaf710a965014be4cf7ebc890b0650ddce44c76ec5687422837fe865907380876ca64a285ce9dcdad8f5474d6a8b20fbd11906b2a251594bdd3f55bb5253f00d2f35d75759e456f92eb221c62ca6711dd3221853e21afbb1cd990120a378c6d8c3628ba4183a8b1e187d19acc373d11ea94382d2000dccd16381bd9941fc8bfc461fe9d3f985eda957147dbd92b4967755cc1c622e4afba7a90009a81e4015d6358b0eea76a832182d94800e31cb9ab3e9e74f00e487585a98b3d1eac1b0bb9c9010eb5a52b1610cba8c5afe148309bf65d4826346270a5b88ec3b37b5be4991c3d39b698d85ad4a2255aff810cde16e762a355059cb6d67aad39ac66a4d85fdb50f6c34cbe14182c6545b249385ff463860d2d46c390690d2e60291232ecdac94a6973d8598ca35ea92b606b2c2174d3dbe13c93cb87461041a8517a84d480e361f0073b25d659f8247857c6f1273e76b916d2327ed518fba1da26284b41b841b1ec430ae620cf987eed176d907e8183ddd4acbcd6ab08d9788bc595724005bcad24c053c86a30eac46dbee719ee9971bbfe931bbf541806bf7d0eb4325fdf2a8bbc240888092480bf294c8747175f04f774ead4b574cc1d7e9f37a7ef77ccc5859318d7bfa8c57350ed30ce3b66ab83b9e9d81c97610c6d05c52e29be6b76b15fb4a04ef39f9497c609f91b123fc083dea76e5f49fbd441befade6d7f23c378eb3c9041740f9ecda9e132e6e050e9df07aa5394d24509ffcdff9ce5292299d377eba378a7d6dc5f0f4c1e3bc0cfb35579190d333527f639d79e0dd4acc76ecd184d6e0f7cb2faced2cf3c1d5848696009893f3d921ad59735740374e63dd6ea2b5f6d8c72aab6b94a25bb460eeb771e738a7712db5d040b596669266bbb713ed8084c2baf802bae8ab323bd76f0a41a8522da23ca3b13be5a0b77ec0a8c3e555c002030c84d3b2f414f580749b434a12f1c38f3f07fb2aeeeeb2939d2555ae9ec64249f45ecd16f143b4bbee94d7c3def07697442685e4abe49efeac546b079665651c931e320ba12949945c71d3a8d20dec1e4fd343bd309460bbbbcb18e8550ba0a2fa5d145a713185bbd9cab94ca610e1b57fa34e56ed8684881b4e1146e45e046bff63bf9eaf264121539f873a77e9ae16644e794f75f6a513d3d0611371326d2ab27cf9245f5ecfc0a01f739e28f359767cc541a7cdb72628e81fae4a051583c78f8adb56f1359a9b163d9691331ec980a34df6ea816e2b588130cd43442f78244e026975dca4cf009dfd8ba5b7038d5f99b13fcddf3ebcca01d55fc61e28a2e4929d9043c13158ed47746136e3419c0e586fa97bd3e84303075de0ea70a6495709cc50e384c7bc34f94dd33688df3ed10ed5cc1d6b6e38b155ccd4d9f04d86f06ed463544782048fbd1d594fb115822300f30c1a1539f5d71e5cfb1d016801b35d6ea0a152d6931eb281673b103f0ef643f5806de1186b5fb97e9f05fb6d1ed8cfd4dd2dd57ec0f66f7877e545fa2069dd9899f4c769b326cafa8ac51b4648a4c5cda3e3487f20a8d3ba6845e2f85bdc1151bf1608451dd1c9a671489ca6fe151179976fcb324babf6ea337764587aa5f86b00b0eb55ec335a05f21c7401cdd27e48ac7bbbd27958cb58c431ada0c2881a0ae27b9834f664fa84ed4c82e0326c1f4046f75e8595b85c1c67f3e43133ae93337570f53bcf942142e6712903309c9ec382b9b8910203b96b2ec2a00be05d780e926eca49cd2e2d6f01a5222cf2e12be304260f4014ea287f868b154685be6afaae7411fb52f67b93f6e343444f4351171e5682c508695c6992655087d7692d61789df6264fb75e5c5cbe1395ba6a241d156e9a1e202bcb9525f1711f7a773f693f7f12f5d336f67ab32d72bfc462dcaa5483f3dce458b49313e5ec61e43149c99a18d54bae74d30ab3f9d30460933ef01874c5dc0b751ccd12d6f859a6faa039d0fc97b5fe741e500fd5776e65389b771293d21274423d8d036bb82221bef08144edd1ee5618fab14f35d5a7e1cd0af12143895519691177cdd51f2ca7bb0659e565fc13557c7ea48ae040f8fed2d6954ac913b965b3fd1242523cce7074521edaca2df6555cf5829ac0c89dc3031907bce9b6d36926cbfeb486143a05e57d77af512c5a7260cc3971fcdc252a5a2ae6fb46dd2cacda714f59cd26f30eaa1465049015f9e300d9ba37e88c3af58a47a80e3e70f04bb6e9fe651303a24470853a24f26b10392be8bafff9a2551d73895c73a1ac09fa779cdf9e0508134163a3d08be9eae676070f5de910ba4965f950c18e57e39087773bf12828823592c5ff66d7f250dcaaafea947616effc8ca33254f040ab458b3b4e897eccc0f9d2d3602137b66ed066b303916d7cca7d148765d0a631b83d9022c570660449d6f4822ac5f4d1d870bf5476043436b316617bd84488632de0ba5d562ce78500720c7c4b6e6203d3570b8359269982c0e20a7723e4679611251cc7c0551c2f1ade6d806fd8969b99cc277d7eaa96d60e872e3c0d07ca045c867715ec3f483fce2dcd0f4bba71a0ecc2b355520a8ae8d029efaa6785ffa75b1504e569d59cd5b427a1aa29016cb0c014b6c733325a46bd39adb61da1730a913166f5195dfb53f2be4cffc117e0c1575ec438ca96c2e8fe2c27853c4a567b1f8993e7b801790e55ff1ae5eec78b0d58cea58465404be14db4f78c4f4139bb119a1e1700d3ae78f753470011a62c9e750f0408b543dc56642f2bf65be6c34a44d2a6b252b8b33913e7bb6bc59a1566ad907157c51dfa51dc8397f43505c1f9edf690b0e4f67181a413ba14405187437c48c037371681f00c12b9970e651a92ac554b5045c224b633b74a56a5ce9565ca14ccdbfe1f9eee0b25a1423d04167db61a45faeb7c67a716fd2228f3a625fcfa2ea8ead6a224181b4662064c140a1446b3c5a1d8d11e93d03092961fe940a01034479ec21809f93620d433b9ac64c465cddddf65ee7c3b7ec380641c136e1da5cdba2cc60cb6404e84e3cb36275148c1839e079f3894645eb5ce14d9614974f954b965f6b99c4f5a2f7173138bb86e8a5e88cafd51677019263a54d67dc6a2ac1cb2fc8ca5767d494bbd98fedb8ee32d3119fc4e5f63b7ad0fafb3ea77f26d7f018f89c8e24da2bebb4dfb5a57cb0354bf786acd9485a417073a2ceb9dc61fd4be5a51d02ff8ddbb0d1fa9905dee541d45a140ecf53d69653fc08fb37e7ca95da2138d017d9092621726e0d01d0ea993b8ffdb708cba8befa404eaa2436c40532c9d2b44c63706d14db30447e2c1c11d41cc8bfcad3b7e113639c07d27cdfdebc4e6e813d0fcadc7e501e2931a481413e99b973387d90012c49d0cf73b9b240b820bcae06e7b92a8d05393f396920ede0aa9c00cb4ea89aa6983eb3ca8cb51d7366f6476a9fc96128627a5d6cc2e721a3e4ccb088143dcc2eac495d9ca61a3cd8a999d563da637e5de6abfffee109114d2c6fc6a74ab8611c6b2329142e41964389a639c4a5a2233f07d4207d6639a0c82cef414f66301636d594e0e3366b3836ff9a08752625be952b226082453b6ba2dea49c3431bb1765b9c02e6a30ca857e29d9291fa340d9641f00b11c1fb684b80d8fff2aa42fc68149cbf34f0ac89410cbfd94daf993bf7cf34b0332f19028b7a08e3b2b50e626e7caa5f316fafea616c0c55f31f88fd435c5fba87c3f586d8b1038d68e901162777a28b6b6199ca8dec7fc4e08d8cbcfcf7c5368069ae11f745afc81aa49a4ab464380d3d6f949ec72f598a7a6c9b17df2c8a171deb972c52a251281d555b74583b24efb2dcd8d267cd4a30643ab4924b05b550ed2c590495a4eb1a0a0f5ac03d3c539d4f83f8e29de4f7e861b5fa93159f69ebfabc8eb98c6deff0273a8f8924944d84893dec2b3e607c048c3512dd0dd712c58838ee314ea63880507c37505dd53e0088fa591164790acd914c9c004688e2a612556f2ca2a152475b22aca7d9f273149a33f1b9e83f30b5fe95ae292b7924497cb4dd65b4af9ef3f8b42ca5a62d2e5d6da22ba89cdbcaff6d689bf79a2c5a720b95753fe2a2ea8efb474ef9fc447239b27fd1235029fa7687cf27642760bb04d83da96ab72921a9f0dd79f20058775662fb84e8ad8ccd35d083a10738379c383492b60bb21958b35c7e74051d4650948d964cec57e67aa5a47d25a11dd0b96870973343d028ff23f53c5ccb0ef7fed5799de531eb3bab7708c7944b4a4feaa240f5b62e5d5bb614193ff58bad9d35d930454dca1e759a3af095892b2e959f14ff664f774acca73db0b6b93614abdc1aa1290ff917d976f80b82a869c37086521f52eae027efe75464394fb3544ffaef17da75e55e91cddfcada3df9a6a31582630fbb68af4b2781ef95a25a2991120133cbcf43fe5247532e2bd40e24700df1f63947d6495b444ffa80acf0fad1c1afc05b25beb09201774d78c3278a47604e13006a72ac7db1fccd6a779439717aa34d80a40523b0688e733ac37cd6e3c97903c71c8469036303eedf68e8785595681e86ec9cd6b2b7830b42310d144fe84607f2ee8c6cb07c37db805e546bd02eef9c43560e50891fa7c1c3df254ce441ebad461ee1c3513d1b7330b5812db9be8c221e5e83016d13905ff452e72ebd9a9023b5f4790f7cf0bd8d5a05416313db6b2d6bac3be1b3241b3a7d8cc6768ec25658bd7b485b83c02edc271d35305c714a01446fde2f7a6edf9f39174b47a3f4960ebf2c12261d48385be9f1b89395ef0eae26b270bccf4907a59368f972a26ed91e392bdf3ef9405ad6ddaee18fbd9e9facf8debacdd962cfcf5fb63fe1837bf47b8610f0ffa07395a1a7fed73d62d7fefff3c727e6f4dcd69b3fe0b1413a4ba581f39e2658f754585cf64d1975ba73374d6a34fcaa48990026b7621e96555af0221df894f2a0f7a720b4408d8eb64de6e3870ceb2b4c62aecab8485a56c1528893405d62694f4b980594cf99df4ef968e9d918ff2497beb2cc57c971455ff83d048a6e241d77307b07b61153676c8017af8e09159976e3c7978a32801f0e8940a806e697f8af6659152c451194d51c7e0988fed563f9bd762322bcbb6258454d9d42932f0144bddab42cf988519d3536fa8b70177ddd54e23a92b91c0d469169d6f7ebb2e8c3dc01d6e013f023596174fe692e0e034ea1612450d0b401b78d2b1ae293592a230e3d65bc95bef6e512dc921c66652627b573823f5baf7cb12f78505028fb0e9b50e62f8979dd90a62135d3dc945cc6ad3cfd98f9f97ea293bf5cd8a56a65b3de69a899be97e4259bd60007bd6583bcbba85baa1f811099bd822fb75a1a3e8f4e40d0633070436a7d86083dbabf0a82e3537bf599cea9d995ccf275d8927e7f58170869aa20665c07566eddd63b8cedd4087c0f2992367c6ee67202e9715f89e0be54c0bbc3b9182f2a92d33f9b71fa623c33070c63a447ffc9df26cc2151cfca0b5dbed578ff5ee9697407b20022226d2eab320e1e60e5c921f1b685b3b29a3642f9a8805fde0635640b6da55e249eb2409a202a2198db55fdd1937462cf45c0cc4ef739368cdaff97aa1272577c0f00d1c6f20a723a1db27c0f10ce793967c242ca09ab69f7a3c8d283e0007b2891701e847e41eb7a3358eb10e7f95941c133739405d68e20b806ac2b820e6e41f351814eca4d890b42d1d311a3fec1c0c57a1ade31b0b43b26fb55e19f7732c3fe04e5fb7b244cf33de68dcaaaad7485a3d922464dae8c350e4ffb7b309ed5619e44c8cd67a173825be0ee600e1cb7f9edcf369d98629eb95fdc7dfbdc51106c276ed23ea2051f504491a69fce291a5a7c49fe01965350823e7f789b895847f77af53688da858fd29862d05a2f5080d166a3e6b427fff75fedb7b7b6a96636a347033434496a352172cddbc26f5246ebf9724c05d3ea1d3d94d593d662596f14140b9f088bd5f5debcc8a4e015954d66eaab525ec17b86b0df5c42cf87362888bf919f74cd28ef2e24bccd0637d9d649247ccc57119f3bb8e6da0a88dc5c83a54f487d379ad67901a08a3eb23fa3b8b0731ad1da29f4a8029b681769ff853880b5f3d48c74c94adee64b0416dcebca5e1e6b6c0c701560eddaa5b3754a5a245655f59c7252a19c74fb5a4e8fe830c69e1fc9d3501d71886874559b0c3f74d87e927074074df1fb80351c0368893ba63ba2dbedae1dc834ed70544fb7ccd385a8ede118a7249d2a3bb39548a9c418a8adb43780c936e55da29421d2440ef1250ea78021a1a847de601244d80e94c6199587dab596e95fd3418c865465b47a08af946d45b7b2269291e679a6bfbd2bd90610ccddf859b93e7f4119e9f3902616cd3a7f4966d1c3c78d5de3d3c0a49efedd1948df0739a27fb1a97ab23f19b38dbe05b42f1631d11a57b58743e4d89e527186a9e50997015756cb2a9bf84563166610fc1b6e9c0820a27989a8e9973bd452a686f3353fe4234d401265d8ff011552082701b0301939c1fceb78c7138997e0fe5668769b2160fd8d2fa41578db823417a494855ba8c8d55e5f5b8570a9ebc2f6c9d848109ee1d881fbcef049c041daf34a695794367085903123bb19d3f4bfb6ff5f88e45be087f359f31c8b7d032d7b443e1d93a16ad731a78a800c75755724177fa37b8be8c85d85555c7020bec1b5d8dc8c1b5fa5ee1970484ea13770cf8fecd9db8a89b22c40bfa400dc74a5d9ff05df1ab9e17051e02667ec4e1d8b282e4c0b2e3989453e0a839076c84bee2b26a770655db7eed0b65e58518112ade1c3c343c36cdb66dbb964b1e6c7f7b77f5f673298133ba13b7a9a041e9d2f2684c3134ddae45844881f8ccd23e5205cda4bb1545ce26f777b46e5c530b39c235089814320a349e746eb9f9bb08b9a69759224764ee5acec7a480790713a414652c1c02191dad988d87711e0698e7be7b4e87ba594fa23f75da08d7cf34c38c640126a2be40f3c5547278071fb78b386dd40736626e73e59882ad1b54d3c7caa1eddfaff1b75296356bec5fc7e902bed8bcc7e5d5b10e26a14ac04dd00905889af399b82c7f2e92915755ec6dabfcca8dbefbbc5cd4bddbe78b79d174a676dabb8203ce03e3160608d498f83a648d3f183f301b4ea68711150f13c68ab05935a9e791dee7bb6dbbf5d291e41781ef991c58617949e3e0dfda15e5f41278ba7bdc6491da157a8dc0e3efd94af1e5ce8ec194e13e2e566b460c0d360648a4bf49e62fbeec1ed041043ac30b0389e9a101d0ce7c45bfa4a3dd54e9f035df1584b5d32b8b81000ec12b2a7d54245f5e7a7a5c1f0d0801454b6bfc89b01b40eca38723fbef674c0072fcb2cf0c91beb905eaf0c7e844dd03778fa6a4cbae59e740a706ea5dcd48e9aa9f868753e4a34ba66b18050ea281098e8062ad0f43734485b30b4007588b1dea71be7211bffa4fe92fe7cb01541ac8af77884eea6e2665d12df9cb15f84cc959a0cf2b3aef8526166dbb5b90cfa32e930a3ee104e38af64f826130122a129f500676a1cac9b2edab0d1bc82c2103f3202ec1653df9ebe066b9bd4a630f6977bcd446b55ee5db044e913f5d43a3956caa057bb4124d1a5eb4286ff862c66c4a197aabc3a0660eb3533a9cd893f0c803d7851bc3f7bfe821c7467db1f4b7988ecb02d32b4d114db9fb89e34768e7bc9677b8b5e644bfeec094286b21a62f1c1bb5490a037454e94a8662183cc19e6e2b23563a5aaea8e292ab4580e6e002edde201d26579b539ea09f338411f78deb09c3b71be61cc2321c50eadf2a226ffc76b626d55a24b1c860b13dbe028a51f28c3f8edebaf50605b16abe4899ed4d963d45a1e69277437cb2ac955cf4bb34c12cef61c83c8b51f33ff54e1b3417fb24f3cb46693e60c5f7415da3911b4cde37b85f66587133a965b50c38f353a776ad49de35cd36e68692c7371fce74918fa52eaa5962f1ee9b56e8c97ac48d1343719025aa690c17dfcba64a9ead2fd2f67bd92f944827903c123cf07a04ca934ce44e211b42f99b4232090f8a77dafc5ea8b03181cb377edfbf00a62d35934e73e860cc14150e4d160768c42d9a83fa4539723c980574feec951c7e0b6e9464c9d81f477813ebadd108e62cd2a5b0fc72435a8cd49c39242339ed2b6147ad6a4b97ab0820108736e39449ec4e76abe35a86c4c46164c55c15f71d13add61b6f6c531c42ad37ff9f33d1f9f4e39a9db02f69365c94b987197a2a2ad74dd1cb4174c9eefcd198024396074ab9ea6f54c2b0f5531522843c62dab04edd4e445e82326ab30e08b86bb049fe5e052110babee2c9bf4b5566cd6c6926087e5dadbf6d891ecde5041c75abe2d3b9d49ad3e8734f7e802c64a757e84e5fb84eb5b59aa5dcc8e3a22066f03c79ef741c2d0dd7b02c396a9c2d3b38e33395e9d42e5877bd7b0b83ebe420a1a246ae852ddf89d4ebff2d7870882329901c7eb9acb0724856f9ad767ba82a8f2f357a1dff2dc2cede31b512ba160df6f657b449a457b0ce58a88a09a1bc9fa6f0e252c613e9867ba7112ada683612605d6531c06411db7c6c1bac4bf3318b3a777020707b7f4832ec973dcdba7a31bcc4a3b1181e90278400164bd647acbb4cd2c868c8a9864836b0a0e7412b1a17d23da89264a37270fe9b3d79aa9ee093b6f51cf34968747aace37872818e6c99beee23be3ab2881180d9101b","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
