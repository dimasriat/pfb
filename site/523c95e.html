<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2e893288bbabcec145c2cb60a651d403ee38961073f2811b0313883a3b75cfd528db93bf0d35fc6e721d113602dfd51f049c6b42dfd8ee4bdc5f18af66359b7a519e2aea298094972accc289ea4d2a3fb6b3bdc601954abbd1f7ba319f20b0c29baae80deebda074b48d855c534f9c8322402323b69672a83ee7c39c8c4767ad4c4205f8d6c2c6ef3502119ec0d591f5aef08bd4590c1a75a3df857ae145a970061f268d8301ad823ae0a4e21aace715f820000d09f249916f32c26dc20286f1e5a818da4740a538f69137f0bbcb87b7f2c6a47ecec48dc818ba51a80828b152a7c1ad6c0e3e2f7638fe7914e6723916abc861cf134f6e0547cc6c1bbd48d682a0efcf6896a6f9d3c3194e1f7eeca0962eb5c7fb9f27503e9bee4f7058dd81ce7540324d507e02f36fef7a642bec247cf5c2a02dca309fe3fe69c99fa1d81f68cc3a1af933e66c6de0087f655cc4c59d5490622e8c204ec62d9ee0513e0d3f0e73d4d37ae901f5d6f4b303a7daa1106c33ceb18bf263a5a3f361f4a5f1f5c33b704d67b0ec3b0687a1a0a854ab05c443823ec9a3cafe9e6eb3c2cc0f80b24500c6e73e79faa698c5a45cae0689e51e7d3ba61fbbc3ec5576b2fb57cf2d6dcfe464dc41f4e0ef24bb14a78d057751e738aad8157d3d88fd5cd329dfd771a14e97acb86ec2d1c57c14515915439c8b7b2d92dc58cb50fcde9efdf943a3cc757fdc75686bb43be2177d7bf831611878d3bf52ef5f375709beb065a91c3aaf0c944ad3c26d3e511a8473aba8c0c72b214e3d4da258fc2265bd61370ebfeb3779359f52a4bd79f6ef785ed23a2e1de684e82367ac9774bf7713c0ed33fb71cc7f80bb9cc9f500a8ba1e59aa2d57b769dfc19eb86c6289167f7be0122cc5292632a189c518fdb0b4f0776fa8dd70a1fef8af5e5afd3c0d298af421c3a4b5c9490c1c0bc183a9c263443707645001921ebcc4ee20d376fd2b0cc78e748f1755b064c7c0cc79252cef0fc77db74c1d057518cd98cf08341df81cfd9741634ad7710def4953ee639fd909c2d195a9a754742a61d94b593a5fcce6305786c4b3f5a8ff29c3e0eedb5ba81e5720eb69e42adbb27e23d66a8c1340773b759fe701f9f8e4d747859577c75b9f8f029839ab4ad0699fe0a494b8d44361861dd35f69c4e7c19c15f53fd0a3e2c3c4d800af0ba371b917cf6b2f6c845144adc89bb298b4444607ce02761f32747d3738313be5bfff53850d395ab550eca03da9b7018d00062a7a73b735ae81c3207f141bae0a280291a4046de6982eb5d79a4496a10af6856a2c0f5d9a21cf91eaed28f740d352ccf561e8706a8677b8e6795a3766cecb59cc7bf585974e2f19d2a4157c1438a5ffbc85385945680c72cb261adc542294938cecb8e425d8acbdb86ca5292967009fcd693844b4b5aa382f357c58dd96748042d5a86e65b2ba53aa376a6edc2fe25c742bead81cca316023ad71bdd27af44b78dcd77ffd249437a52e748e822292e7267b2ccf9ebd41e7ee334ff33c9bdcbdcba7e8b8626b0f7b7951a8c6820a1d041d82954ea2308283a3cc6fd788e205d2ee3e719c3bc6d3bcee06726bc2d7ebecd932bba58e50217b10c143e468895d9683071e7fbb08b28e24aa6b3264a753b934f7e496b593a6d2f84a5e9bd03aed4c4fa64f9bf39fa603b834267c9e970b1fa50951fee37e6352ca09d7a31fbe1bdf534bdda2430ea5e5b9d5bbe6e6af24988ead5c3d5d3d14f30038674613a944e4b065a58bf0ea876becfecd94fbe45017c07f3731dd1fa61b52e90aacd6be07445ff15798234798d19f74eeb90396fb52feabb9480c40621d6880302d157c4bb3899d5dfc25e4e4c4a3719530f019c56460934e0bf71f80baf4749cd4de4326f31af84ac93eff2e88fc045ffa6fe51529606070e4546b407654a59f0e25c8115bab98aad38bf914d09aade3625b476afff53bee1fdfdf193e7f56139e44b80516fe8734335df0666831aafc28b4586c273951af19bbd53c83480f15343be497245586793f00301a95c3ed6d1960882bc8c835e4887d50fb496faf7b68f7f69979f9bbc4dcf7b063888f9172076e042da4776efb8078b42e5b6c14037edc7021a6b02cfb38e653d02c28c9f14936651d0ee0001804399a5b95293f7ae7a33a616c53d61e349f0ed8524d9b3af63b8ece73ba9db0a782a4396ab7d0d1156c3f8e8894076bad7d3e69bfb4c4a3df5d2448fe7185d0ad692e7c1a8f92b1f3fd8a0ef33a00056eff1bac535530fba7fb7154223761267b5fa6059daf4776257dd98ccf19b3d1ccd8b8b3be7be105665a013009441b3468ec67308323ad11d2fa19c5c9c7efb3972602c43327c8d5752f8aa173d54c77838398864b8f043b56a06c1529128343da3b55761bd4056d06ad85b1689aac0dd06baacf667acefa3a61eb8f5b8dff03fcecbd7809e0f9d4db84db4670d3e52b67d02e8143c2810abed7353895b92f150dcc4e0fb2fdc1e7422a9029b14326be22a61cbe5cbe2e54858e67b4f2747b9bce4e8e32ed52fb00f88025c1dd81b8d6b015e99db11d2708190054ec6887125c7ca9f686e12c4582e23fba81135252ee9bc5e0c56d34e763a78d090c28227bf63ba3de1373e52f84f77b50c5411d77ef80af39200ea966936d7cb4476cdec43e928cd2749b0f8f39999cff04c88d14b4f2cd11cdcc93997ed47f2a13c03a66b5ce83d6ea87c806e60144f91bb939f523783ae44e4401e195ef37a213f62dfc499016d4e22d140c652a755b26df1f61d490d060842897b2bc1f210f7843328ed516b5350c75eabfaeced2a70039f6a8632877df6ff4660cbc98a10cc80ff463f693ff9452dd78e84c3bf1a4dfbef2300c869fcf7ad8f62b0eddafafbcca06ddbbbb3826c5f4d0543502ff209684383eada050818eb18ce83426d7888ad551b41256cee6adf16f399669be0b4acd8acab0f513ea43aca4da2f4a6a2c4127ad3b75d7e6505cfcd98a38ea18f6d7a710a9bdee1c06b0f6261fcaeb219e568f5a0243951822816439cb085a3c60f1c95f6aac8149da26469bcad884cb3e281e65e45eca9229c4a421028c319d6ffc324a1caa4fa7beff7ee259ec660ce802ee932f867695928a1d6756af5bcf373a0a22199556881b58ee1b7e96ecf7f1a529460f04a3eeed137ae16e5abd420bfcdefe7502322988df942f6b987aca08a7940f008b2f76d2f4d7f64be9577465bb530fcb5c180ae4299d3d3522f0a0dae95ce5263fa5f50c31989325b956da45c8b6429ea3a17cba985dca9995114e266ea3e5bb4cba90e04c1e95f6440938e483e642ba38c4eb05a19a746bf79350c12492b3063ebc1e1d952f727f05abbe44e7063561dc1c42d47942b13e08d2069bc519720683003cc9cc884f71d1edf9eca8e9e897f7b4a79b7c7dba9c3754f714361f76892adcce735e4f2771cf1fd9f52c34fef625357575dde0e06ba19b850e0f046a9700326851243b5111b0955b6e2a45b033774651646408b9f2f87165287f19131a53c7b151a7237baf0f1cbb8378a0860c9f306e53c71ba1766e69ea0ed21a7adfe99685f49466a95259f1d26eb75fe3f84f38172264e3103b6bcbf2e0347ec11153078d9a65f046f967479fed05ebcc2943680de311c1e27051501b988bbd134003e5d05e0a1794a3274a9fe7b25661cb8b4045614dc30a2f1cc211e89e1613164ac5289ff4e87a52836604b000de1c532be2582a4ff0865d83608b7c9239452326dad48233286a6cfe3fb3faf32527f85f5a3a860494f8d2831a5c64c9160ff680d7922d3b5a5e6ca569ba8d51bc621fbf37ff05fd604f716e5c9f39b56362e3eb90c2e3f3f9b8ad8fc7071a8278adb94c77a1cfad43af6744dc59f528758315f6b13d6d4a07218f6f841fd24806af0ce884f90dd4554fd58841d67a3c9b01566ab6d92c8256d79300686043e71a54fa8bb779052285accf725e80f16f293d6039a9c5f0feb542845c69cb05cf704e7070ae5424bb4aee64c11879cd1ecb344ba4bd7ead68bcb585391f77301aa5b16a5c990a905516c1d4d2f0aaa0c4669374d89b820f407178b851164f9f9f1ab1c3db0222b8ea6d71451a1d229987b55613c336923f8172edb0f396db9468ad827f155618c9d5739b8afb4d625b3ecc6aeba7d5564281f11adc06dc0f4122b4a92ee4df475508bf777c0a2ed473f9fe09e33dc64af6b914a7f8a4db60bcc03b105000c91441437590a188467f256756767fbe06b98b0f540334668d8aff61ca40589e66467f721a17fec373d5f107775f87f4353b0adfec32ef3721cefcd430d33a9d6579258780e625199e619748589b6ea4c1ebc9d015461b110dd52968faefbc22cfef3aa99f7021a460cb766f971d4fa52a2c7ae8ecc05fd477caeb5a345a86c78b8b0a90ae9bf680e6220ee2ae5555feee580aa0e408c057fb36ee92c0aa85fb30edbf481f3b405c0e1a1e2582e1222ab9191d86d5f7f924e4086e14e20ede4351a80445cea1f4f5f6ce2775720ee379519e16ab7e9c1c847450bcefaf5d336daa0963b7f671dd47dc260a298b3fe0a2bffeedf2e630996e0a0a11064205891936da7c0c4eff1e9e0303ac160ac18806ba6cf7c6f95af703b11321d11ca5c4f8621c7819232f6d9f1d7c08f8336c5aea430536f994d51aa3962ec1a21f200c973a60454402dd3109f4e97db43a1d05fd20ab45e5f9e7b28e035dc2cb3ddccf969d76e88fe8a49819022a2547e0d12b2c3302231456f6c179351d7280cb327fe438cf65fb512d1997a5e0b10b252bff1cdd962deb852f9f5d2b87372ae008bb45efb8e9b00ee8b4378dda5322da74e315b20b5231fdd26c57bc014cd1e74d31b575635fafd29e48cb1faffda5d91c6db79c07cb8247b9ce46f2c807201067310db848abd6d78893780a3ea1d5730a8f17989ca5b8a8ae61fa44e878adf6b5a232ae5c9e7a4c7c423f38243025d7bcd9497551c7ec1abbb75870108b847f8b6e53cf38ce1f99f33b4a63fee810edc9fc7dd10398a6599a31510c4f36df5d51d544b00dc3ecd0b5110868d9af461bfd9d9a567b6031e11d0251b18b1ca2a0c084228533da31305ef35c1de1f0c591d3899e412a44a84e0d3dd4bad420bf05f3fc09e5d12d3c6df3c920dc19dd028747bbd52e28d2d5a2e8e9417424ff4ae044f0515a694d5f1f76cd59539e72765f1ff116371154183d176c3118573f985a94034955667b7dae8944db6d9b135f55f20924b8af95e074b209dbc90c21a6451e9bf66cccc59611ab0be59b5db5271ab11e8f4d75532456ed718caeff69c834dfadc59c0ad8a58745ddf64bb258b88b2c12122c438b51ee8eb146456b509ecd15b61d0106727ff380b50d0818c056d45e4e638838669629e0a6deddf985f94f665769e1da810a8f82ff79f1116332ff7033883fcae8c3de9b1e22448af81ef031a0c87a7eb16d051e341ff99bf199e56a8200431d45bbb9e793404fda8e712db92c86a87087885359fad77d1bb65001a9491caeca51a402b763117c44915e1f8800d1cb635cb788c9c7ecb6559ccf7f18d05d1a51161df0cd6d198d3e75b3e8b6a050a5c4925e2f1b843fc9e168737d9d1efcebdb9c768bc542ba6d13422468ede3097c6234f09b3ea8c83bfa89a9e2fa4f8cae84f5b62229ea84c1af1f261273ea2c5109abeec53a6ec117f2eaa83ef6d69bbf182f5ad93c6e662508d9fb3537468d88ecd051d8ea0018207d8ec68a35b85afa5111c82bd368b2905c47260497136dae71be35c77eae47c5071a65a1b3897ba228451a094031867b343934b85fde939fc97e12eaf1e456d7982cbd62314bd4977c217478debb6a593b255cd9dc0a9549954f63919d462f7cca18260a3696d5a333486af8a23d7bac89737334e289109194eb00337eb96d3d4b80e548e4a5c3de304610bdb36973c6ed04faae0c6abad0cf786867be95cbf315255c1791ebf190f7e47510fe7cafbc0ba0c7b39b4fd9957d1a86c1598c925d9ac81f86caf78897b9b1e32778dd16e929e108af84ba992cffebaa5a40d3a2e13cb44c0c6d06ec011b4ff25e886e636315175500ad0c501e7b953ff236c2666afa30a570f7e8e3f64de944bbb79b075a45cb8379a65d13984ac8660333882540bce85958f9d2bbc264044a7e3bd05591922a26b09f13fc445add80666f6d68cca94fbb4f7b1411b9fcf60885944f0bc4c259bbebb13039524b0edaa339dd0e6aca5824241eea92cd1927d751a2ca3afe4404a77dc15310be94eaecd0a512d9822cd9be2117ff795425e0d2be531d60611ab73b979627e5944a53b6bb400c068291b215fce574734760705d3a00688e22a28d92f387e18faeb4509dc9262e8a721dde8871046c7b49fbf12d073b9ec21c2e3a6c4d5cc88678d0ab2088aeac53540619bb848dd41e1801becd9382689b4871212c5e6e8e247c06f3fa68a800a5ae0f41889d2ae21a84999f56f915a23479a077b92b722f98dc34ad379b35fc4e6e04a0ed24932949e1e6b4355bf841cc96c411f6f1ee80f0f81159b98be29bd0f88e88a78aedf42329a3e9e2ef05f7f7152ffa765b3defb9b90d8418d144d79dbd35705b15cbab6997009ffbfac1aba831fddad4cf906a9bd3fd52867dd29cbd4d3f39d30874bbfc8e6e506170913a3e16880f4bfd0516c84428dd293b0b193d8d8c480d1b17efb8db9fc151bf740fff93355bcfe9d39df30945a29cffe55e6ab1911e22f5b69d7b8aa1637b1732670657b57fa29d5ed3e38320901dda568eddd887927f3c275da25d5594305451a84c7e54a4bad5ef0a7c705c838fffb2456902b8475894b6a970c837746aaa43be7fecde2716e46b112c62cdbf12bdbbf0fd3f396db919a26ab3219a3e37966f5308cc5552658dc3ae66a1bb716a8184218ed999033fcf9d3c3de32e40144e45820669ca352e4efa331dbad85c26e9e7e1715e1d153a27aaa68141b7144c05893ee415e617044dff6ef362b795afc431f246a1b16bf9b56a9b565d6b929fe2c0baab0a68e41bd00f5f5d87bcb87145fb6100fa6ddf9b56ff0b0c089a54b4f2ff663f03fd66b77adef57fafe962d6d4c95a495b9d109b49e5c92e2281b3fc8f469f33936e11ee790acf900f29aadc3822d1ba3a3d7e5f638a7cd4b405cf810039f75c7cc9f7b33751bd1e23e6dc73b4052a7fd8065fde8431b10970c29bc2ac10065fece0a50c128fbeb24245300a49e572f39acb51080529dae0ed1f1de6679471cd90ea9812da059130f742f9d4c82892f83e1b9b60da0b12fc084276ce483ed5145ff3b2f325f234afdc7b83833c30fec2b699b577236d25880def6a9b1eac6332c1e7e175f75fb7b516664f95e184df50eb1ba6f6ca1a5d6c956f4844ed012a8b09573575416ad0cb77b43d8e9405be84c39941a98ba5d2e52d29a28ac75c46fd999e211f808d88a38332b2149df1eb1af793500808d4fc2a7ef8c0c284203b828b9afab0b293b5bcc38c75677166635f6ae4c7b674d64e78dc219bb4ee96cbbd638d9bb27bdb6b19bfe3ad5ce8d479758bc682fe6d123a7aefacb64b300c5cd8ffcccbe4758e5576306434e7106921d796ebf7296b15bd31d8ed992aa08eb63c32b51bcc5785d0ffa1ce5fdb029e85e73e72d81d0d23443b608b66c08313fba224c646923345d7c5920b382893cb7223e763d284e05c4753a1d02cabd7f1d6616fa6e26c154bcf7b0a386bf3ef6a3d0071457e0270b595799bdd0d96e5b13d04be2e22864da064a3b6e5af8ac1d4587206e2c384604cfa1b41043882bdbe4382a6ea98d382f2135de057e3ab5ef3702756346999fded6abc475ebc68c465b8257cb4ae11acb3f3dafa27c2f3820add9def55ad99863b551bad29a8af50556ceafa2604a7e840926feb324b49dccf3e94822fb9b27954cc28f4e1c117dfd8afb0258d7f2336a8da6706b667c1846ebec8e167893f7efb914fd69c29a77300ccc0c73ebf61636347563b76be74edf76e65827215916f09b231115545eb933192926f8d591d9579e00964ed6368524026949dff0f0a40921d1b162af90212cd354ffb6c5883b0f814d38462be13687f4b5a469fa15ecc5b88f5494e068e7396efe4176dd4ffba965022635635d2609f2d381afdd6866bd6a3945b227a7961e30a8705ebdaf600deeff0d77debf292cfc88207612be187ecda568d222b1e0c7d78657f1c8eb12e86d7b9fa045fd3d4c9413f9f7657db30c5f137ffc77e482f620c3e156a0ffd04c376676eb489f5a6b74fe56dc3b52d286f4ef8012b7152f302635477a277d1c37a4ccc1f85a6406d0a541003fbc95323bd0b9b24f8f05da300332c5a4b96bee06e73f8eca664ee615fb82845d9c3a37042a8affee9dc3a96abc634a61b978f6c0d4d6b6b4f041cfdd5ad3e647ee85ead04533f560742d226bffef6d91bb36e57dd13b8ee77c6473fdcef3680b434a3c87c69ff7c71225ebb1cc371435492cc3f05dce3ec86759e391c4e44948a505cf8406ddd50a5c9fd6e4934b1824316a21fe0d077ed053e9d4caedb61ea0d9873f6cdd39d30a421424820d8ac7bd0a8a1676fa683627bdcf4c257057b02f8d022756c13ad7e2ffb9ebbb7d8dc1bf971ce39378106a4845e355d18a075ffa95ecf6dc24297d4d05c8337f95f8e51428d5b91598dff2fdcc16192eeab0e00059fa34fe0eeea0c3dfdb862ae72593909c4e196af871581f9d20b04cd0e8dfbebe3fedf2ad09a204316e6f08dbc8bac41c88ef181592982981916e72693a96d9790fe4c2fa77e6b738f93e7ddee9dd596221cf90a0bb2859cee8319502332ceeccfc9b38b47783fa42f47fee02ef6691fa753284ae480ad9669e41c13492f511ecfe39554eb23baefc185b361e4bf7f474d65949c87b7988b84370ca759605cbc2ac5d75c86a5377b3d721ebb19bcb409ab0e5fdf0641eb652976f8e6dcfdd2bfc879df3eb45889636b4155c18af5ea6c52a5b872b532ff9cdcbd95ddfe3d3df09c6af49e4a719f8d366ee0abe7fb4c9ffe2eaa6d7e686bf30f1785c84f0b62187297e471824f7bbef68d11dc36062cbecee3246fa2e8178927ee9f1ad0278df2f1b46f9daaf662c5ee17907e5f3a503a9f0299c1635ab259a35de167715c39a7cceb24034f4b2c1cb1bc8c24e9b9a34524767cac7c2427ebf7dfab0af96e4635eabbd3c891f65b8c1e9f5e62f7433e74b8c3d8188480302aac2a5aec21581ea23313e9cb902ed2ed1fc97bd9691506e51f5648795e2b3f0a4e51fc6ef499d03895e71d2b3e0adca7f3484c823147c98436e77ddad3b4bbde4b9208033cdebc5e0b9d6f59735e0ef73dfd1313b2962ef9512afeea9ed0029e9a05559147f9d3165de6040580a3125b55269e03d778357bef12a06aac5272869aa39bb2c690ad243e54ff19d24fbc1ef7d9ea50380ee88096b92699e84db5493e9f540d8a595bcbea401c580d5a2b16cbd957b461d6945489feeb4cbb3775c483e79a34cdcf1d1269a8866e2010fc72efc1158e078066811010a8bc7502c849b0c72a6c803be066a88ba1d9458ff368ed915127f61918f0233b13709bee90cfe3a29055409ee630871ec20e7132672fd39fbf0257096e74865f39174fcc063ac215993e6432b04ec9ac68f3861271af6ed7b3c71d36c6454eef653a8421b242dff384abd3837355aa7dfc83ee2af4797217d9df430b845c1ba99ea1558966dcb8db5993cdd908fec2628624e9dc21d211f927f3a6daa57511e55324840a5972a3c5e69593dccad8412777d238f4425f62ce746a8c2b29f6a28df60e62e74888f5231aac361be3d80c8c6051b0db2f6d79969d7586904f24af608068a1f7c75595e7d53181770c8f358caef7fff2d4380c92dd78181bf96d55aab19e474145c5b2ed2775cdf37fe013341a208204f4d4bede9b950ebce396bf8b33d168acf27efac29712694f7d48ee8512c40ae0813c66df81b87732312f38d70c5164138268040290b82c939bb86531e8bea8bd7065caf8837907109d64e37dff03bd1b3ae798ddba9cba7e01849fc7778a64adddfca4b1e06432a3c6042eb28fb0ac601a763862e7b505b698857f74c3b388b55ac79355ff862ee9712a41f56ab641140e132a0ce59b9dd135a06356d2c00324494c72ed8bb7b037f2a94dfc251ee19250d1a15d05faa3030ca6589abf5be10de0082ab3bba325d1f40d5635e78d638188f63ef81c3d55d438d3b64bcf7d196c293f0bbf783d4957313383eaa0ac7f38b3c1302202b98991eee3b9a41d808178af93a2728b8357e0a3512bdee2b3b08c0f9f44f25281eaf54ddffed4feff0e3dfe5966cd0f2bedcb595502aff401148b9af8b9a58fae9405e2d807ee0af8cbc45aa14904c035c9882b554ab368865c94b2d4f542a3d4ea743a040f7b3aed6569422f1c017c92fc8cab4123299c909f44f7a493e1d5d514d767fa55b373968b64b6bf79a0f341887e5282b8998992e4ecf812d2133cfe7f20c2f5b2bb8ec4e4da049567c4beef21bd1a81166b4dcd25ba91478c990dcd7482bdd5319e008bcb21378e088f1e73525cfd368543f8368ee0159051f9d1439c65436fb4e5c86ee1c369c7282a7180e16116d6220de5de7da6f814f02f9063c9e01db29676dcba89578b1b505af4b853da6b40d39847e4b38ffd34d82dd14087b4b122cc3d71a777082f1f9dbdfc994f855a4727955eef7d853169ebbf64985d61dd2d2aec1edc69d030e2a4f5cee84fde6ee0fb58045a2ac440b4dc54fa23b9b23cebbde03b9a569d4e96d9d06ae99abc9abb0514033ceafb8634f8d875b310a7c2dca5925f2be0ab4f59949260c3673d79d7b016595053b50c6096d4eb609d1f898adf80a136717b0be8658548ac06e358cbe54bab6047acd760a16d935f14d13eb0cf4ba9d16166ac35160392ea799e5523ea4d63cd46407aff979ea92371dadb09669e2b6be6f4642366f38282267883b0c7c3b7fc0e5b55961deeca8ecd40bc00b023ed766ca8aee244dc74f8c457433825c10d596b1c66be3309279f5130f6d7a262496eaca68aee72f82cfdf4213fe73ff94d773d7d9e84b71fa7e216b0ac8646cb37655a307a861c5d49e21c9cbfc0db4f028fde6d7a8b01856044722b6725f00498546178208fd99a412e9f0282a1ddab7e6975a21a7633aad76632606debf68df07697fd5a6cc60fa0a2b1914c6b125863d51180a401db233d4e8cd070549745e4c27c5ed3a491cf1b0a0ee1b2176d51e801ae1d5d69e47b51b6f7d5c773db0f5085ae4e1c66fc2dde03a0ea2778a3cb4ef0376593b3a01844f1a70e7eb7d96e3046037b39e5dddc5386b35a1789dc66a726409e2ca9a7cd0dba49f4c9c78db2f1ba45c7f0f4f9d510ea30faad08ac43e75a0ce235230b817604993f3228696afdf915d1e180ecc4f68277153fb25acb7efb934c8ce8017936ba4234ee46c98bfcb94af975855ac0031b9adc6136744583c78ed2b6a6326038997cfc1c43856181c9d4f4a86003b1d6e29fea08cc137716eee2adfd2ffbc98e2606bce551bdf9da06955247a3920d8cd492f4365cf0fb785d9ecbf42e2d9489b8a08c59a771507620b06afc81bae863c2cc0ecefe8443aa969051b57f85efb516a1c5870d8f58d44c474a0330613e139fd361a029c2e97663874dbc63eec90f6f73891d0907ebed134d5e823f4f5f022656b761f7d581c1f22560395c0bb288ed55818b40c5867cd72617944f17e5bb064481b2abd790168c6aec759324808a18e86e501c19179fca12eb2a1ebeb7f4b79c82eab2fa5b562df3464c7c8e521117c1dbde4b19ba77668e6fce04ad62cbf8498bc9c0a1d17b049f529f6740a10e82e021cce996409f9f8df0a6ea543b7b0bac07b44d6c9028908591496c111da09b4abce0977d79ec41cae2714408e8f07634becff063208ec60b7e92fa5299fe636c7707bb57ec8436707c814c6ee4aa791c4fbc2ee43b5b082451ba2f0880d3e0e4dba1aed85ac3f4ac7c33268482fa5ac8e123a972361957fb1ddede681adc3cb36e3db0ffc7e98c29ee01b9e7b2bc313cc6118e3adc8b1078924a41599917a40fd0ae9905e0b5c21b07180a7b1259dfe2a02abddcff450aa0b7e5763fe4e5f977fdda7697b4144eadd0630c6bd2aa44f667203f07688bdeff5dfc3faabf075664e313262255341afce9b7edb4ac953997e56ab44b31fa78fbb3f56801002eb31e226968b16c345d51c1d8a9adf3720e922fcf2b4a26964c152925670a3fd5e6a9674f383a7b6e3ce69c627729897c88090bc25d2cd2bba3e5dc4f206993d76559bb1da0852424a7bf2ba31af43544b7ed121c070147e38c30ce905a651de222ba44dba3d4b9b5be36ec99a13f2ec959efd701b9ead266039e3d81a04bd08403e574e1916dea9f999056e4baa696d7961724d710ea8d231e2f74829cf64b0f466f18ea9b812c5573f9bf9a9e739f35cb7d5b6b70aeac4f43305441b67c7a4e7e7ff9e5de020e965b81439aea9c33338b2478fce837e1c0ae2f0a0e636e619ba0dd9360a8a939e873c5c1d82f27726d2b52e61b714f058a4b5417da5c7097e7c67848656be961e58584daa0ed6ed8dc0994f1ab273f0b987c28bcd9d1754d5693522c45c056d13c4f21884fc3188af790c511cc2c71e3b4e15956158138a7c6d48238167e6e0e1250687d65ea7c5eafbacb83c2baf6741d8abdcd0db80d124ff411ef8eda9f0533c6c69915bb803c9aac22673c46dc100b34dc5d4552c4fc30aa5c7d9c2162b9915d1a7cf6454739bd1714b3364ec5195c8036edb8a60b2c3a2f4267d6c89c3010985a6e4238012ae8ea8cf50c0304e1ca7208c6668b809286f8b562571ed487b9d8049ed9ef38785369206e33344c6973fea4742e72560781f14a4a4bf08dc69dbd6b24fac531aea9bc4eefcb98b3eb1fc3ad6becb2ce6778e154972dc383deee9146d2b36c02926248e2d7bf87d56e3c012ba89779e45fcf4737b5a22db5aac0d7dc17f535dd070eba610bc89512adf46b77c3db783048954c84639a959fa66e36770f1760b6c758a68d653a3f3143cf77c0b5e70117f6f68bc8493f1ab9f0987f4eceddcff9d01f3fc76c51709bab804d32c045c2ab764ff17396f4a7c57dfee533aafd486fa3ff4a7b360733e96d16e43ebb5b76e16145bdd11b22664ad7635d44751620990506e874c54ae9760d1f649d761199a8c2877f22063184e899bccf5938c32f1f195b49938da9c60273087cbb57ad885bd9dca12880de6186592482b43458f54eebd9d7f726349a279fa7c0d56b54f2bd585bd26476a77260d9bec1603af8336fb3e151a671b6b2a5345fcbfeb6706c277f4cc833bace9835f509021f4068c8a0eaa844f7a172102b6a476d3b2b7bb68fe5bd42def33686e7190daad224d7e1cad38aabc0fb43fbae4a64c0afd4c23ddd902813362e052d33b044661880c075c03a7543ac0b08e345b20875437f4bd759432647f6a4c10871b5e81541b9077e96f1d94edbb3f5805d95408a24a22fb0a8c3e29ccf00b7560e596c597de9b9ab2712873064fb7269d9678b2eabdabad356a0b7410702965533614fba11fa6330272a15ab1222257b4fc6f5b9f40d672a48f2b54dbaea8e619f59be7960c8edc157d1387cee8f5375036ffc8edc11301b8fe85c2b7d143057e169c2c44e202d4f24dfc9a2805430de4c070dca4547ead3032e926688adefe198964835cae9931dfac73a304edd1817f6557bf4c3f13c81199af8f7755e067a9cb92cda6233ec58d9e466252160d6f8fba469bc206ec654bca784ba6626b98cbde07f6eb076ddb0ef00b15e22c147be2b940bfd072e3277bb7c43711bfaec7e63b00b908ae3421ed4e8c014e3a432dba12c73e0bd7bc1f211d90dc863b882e5c221b41ac3736bc61e5cfa5443b1fb8c05f4009697e8510036ab42a43b8bf94969d1a263c9805251099681c2e6a6998e75d2609c6e46f4e54af5d583f97222d730cab01d49a1900523ee25e293e39292ee197ac522e45307b820617e4b2d166e073a441ffd4d4dc0f96d3b94431ac7f6bf3bf05e44d4eae90e1b5cb7681e4122929674a677f134dbfc406a9b7be758eea51ca677197e75c58a7f65ebeaf12b2f40240eea32507aba6446b662974202ac23bf4041eed9ecdc362c50f7b4f1549c37574769074a4a14464ac7cc0a596778e643700337e03e549c86de206afee69a41832ad8932d6c29390080a6d817887e3dfd8b40af9efd7320122c356d1b50cf1c9c629b8735fc408b908657cce92afdb7854bd68fd877ab26be238d8006d74984a0fe64b7c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
