<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0eeeaa01c184911d28a6bb5ed14d906cfd2a59b0c8434b17807c982e4d41499f53dbdd982fc8d64b645e11fcc64c5c418383f265a7a0f800c11e2e14d1169e865a389a9ca1eef4f9c4a2837d692fc652bcd1b2b40221ac66f984fc3245a57221e3e9a3f46632c0cbb15c0895a67504a2a8ca6ca2d3d038fdcaa6b366c585e3cc790a99540aa1326d688c9f649301392f96bfd9adfcd679fd3c14006bf2c002309d11fc6ce621bdb09f9d05c1811124bb77fd44398d15906624586f60169ffdb6399d681e00d9eedae803d490a94e814528e20cf474e739e9fe4f139b227d764b781dc0fe3752e947c6d18e4748076e92e1b76ecba5815d085e162c7051509b658174ff9c544fe49b8de9d88d4b85d5b817454af4a1df8898b3ec4d4d22fb96181bd26e1b029a03c515cd780f995d05ca7dae5857c2be40cb49c75538a51af31d11f3106e54fbccc1da9e8f6da2502d23ce4a66ed187116095e888bab51c176ff41f49a95e62fe1bc387f4214093452b748ce33521eb4b5f7cb165ee6518e376af2270f7500b0145aab3c1f48ed736c89898b6183195e0c2bc2e319824d0e70dda0982755e787a28cf0e9ba53122b1c57bfa69a457639fd65c5c133729bdf57442d0587beea5943ac5f6f7e5650ea0a995eb389e464e5b0e81401ae2f9c56c5c96822d079a4673e876ef8451aed97f5f5f0b4dc12c4df7f43b4fea619bf5fc038d9be50b6f4e1e117564cd7680be9d3c39f12acf3e4e409bf06bec589b708c9a09bac19d1dd6f0e4fe2c9296089953cdf5ebfc088c04977a14eb179711792fbbff2d730edbd968c4c0838f582b313fa4d4ff6b50dee5557cac90fb6c478166d3dca6e71a39bec7fda42152db8cb1b54e6b4e97169ae565e7ab6bfeea59ca9c06cb012c9a939343cd842bfd75a41f3397f21fa8d01d5a8db175076200d9a236cb2373677066aa2d1ab4b61cda04bb7ffbd76559bd9c33a84402ea59355a7548c0515ef7edd87cc02cef0c9eda5ea20d09011ea1086c83a1e209ec188acbd21bf0a9181fd1ad780e9cf37366f7d16063de822b9303c4104a39ee05daa22356ff01cb75ef9bdb9f8b0928c299a8689841d75d47e90151a2c93867f73ff23836fab225b8ab4a571e58834ecc56f10357ef13e25449fdc8384bd50b4cb9db89ff1132f4e53ae2e8cca1cf6d8332ee9d49d2ec2c39d282856ad6551e150782a0d0c04a691c621688889a95760290c23fb7555c7bb7acd57525b6e3cf3ac95ca11ba8c71b58735a86eec4fc98c4ad37a1d551e8b7ed31067fb37c5a5ff07b61436c477e0ba54c8ffbf4ae8fcf31c84c70b7f28e4c779577d31f5a0517a4705957e51d4e1a5249bb511227aacacba58b14dead15eb0e3f1594995139ad22e47e22a69d1d28cc7087bf12206074514013a4e9a9deff27b724924faa1936b55b3e64f7df9d9c033d7afb77fc39e26c1306614a1df3873d16031a9052a71c66494248fd08f41c7d63f9f4ae6bc7fccedaf8145b96b8e7cb97a244d5781f4831f96defd665df705b918737b0780a654d6d59c14d0f97cd15e30b51afbd7ba71c3c50ad2b0cc288c4827501feff240be7435c2e6828f0c92190fbb31724a3d70d00193f1650fc724b8922b147bcc5e611490481b97b841e3b371b9b8b4352bab4a7fa9456b08f2eb0aa8fbbde2348037afd577a8ccb0891fea42dd83c1620c38edcc2fea35c2fd527ea45ace1d96995ec7317554e16ec4775e41014081ab06d8ef751f0aaf0b3ed0cd2ce1f59d26124825382f9e13a3a6e9e730fdc409e2dcd56acd2e561cd892079dba4d5ede8088c8fa30c91be119b63060cdeb2038efe451b0b0c079e1bba6c6f70e2c4791fe6dc14ee04172986628f5ea1570ffaf308bc0bdc98e64171ebb749b01c4a8bcf5322f26720f97be235218055b2378784b373c3830995655f2792b05f45aa745f4a385956e67faed30ee18ca1b408db10905d49fa0a7e2108e1a5e7c5d7f0c7cc04b075e4020ad940146b31ddef555a6f8601b622ee4703a7acb0c22303b8f45da9329780fc6cd8004c5da8498d1654261ce3315986f87b3b02eb39eb72b5f9cac2df6f356325dbb885f7c7b179798c285d32963a1cec47e65b2f5999df3b37e506a110e23fefad4acc439d076c9ae9a1decd80bef675fdd6e88f99c697731dae73bc56c50969383961221ab3fc3274520777cfd490406b2f68705ad484d09415d9cf3abc53865c3f04d8f7221fc5cf63b6995cec7ca81a2ec5b7b606022d78b014f2ffd43f01a576c093a6ed788b00752c4628ea634d665757ab5e0536d88b71987902e72ee0aea1c3deeb393bc986652862d82e6e2b0e0c0ae89ac7d307cb40f531183f385f9dc05b7aff042bc854a4f6260845b70f4db4bd2dc1fee248e521e19225953665debffec3c43ef07232a62c34906a9bc794e8bee4fc1e325b75ff6a3277f8326463b6298b9d0991ed18d5350d95ee7d983edf5b3688ea8d0f7b851fd9c45ac9e0660df8731050244a960605439307459bd41fd669b9e64a4b01ae82b4410697df8ac483a376a73020ade551246c39fb7d6849882fe69c7f66754dd62a9fc1161c15fb81337ed45c034cc32ad88dc749f78071852c8216a982968546951c0fe7f9f0e3826bf6bba564e2a9934f5500cdf7672a835c4d6232b14248eac491408e196c008ddbe633c8f862be4d01e42880cea6072123bfe9e76050eeabb2a60d895cd9e69fa69638901295c15302abc0b9384f92c7c8ab91fab60460abdc493d47098ac2ba92eef74fc0ebf4281812455e9f197333023d9dcdf1d7cc6167f8c2dc35bf8f52407336719266e08b5cf216a78537bd5143b09898d56c71aeeccb2a4f1017fca45a4794b53656e7de2f0afd9a2cb603dde734ac51f85f99d48c23da1313f934d6f58cfb47b87506d66aec0a4bb2c635a8fc8e6cd687262cccfdf89f924c8b06cefea15c86c38c1404c6db9f1d27bc666520beeb95f9dd670de548b7f66a0ed930abf9064cd56d1729fd68767abcb1e7bc83622490d49b779356d9f7334e2521a93cf98f7226ef257fdbb788e331c7fa92404933da296440f2b673e10c3d280f87c03ae3aec6d4edc0c945cc3d7c59865aadc080ea0c1ec1bfccc7a4a68073c947e235ded09e111a2c38fc6937093fd9944894f3ef4326efddc9b076ddfc1cbfbb3cacc27dde6278e27d02f08aaf86eb19772ed0a6767cdd88dd719d0584ab1dbe65fd50c852ef9bbca02483a00a739110619ddfa1b0b286f025adf5c4ad87a157adb2bd21a50d13dc8079ea8a82e3b5facac321dd1c3b9b7db5befb3e73df793784c682d419bbb9c4ad2a041f9308588a1742e6a65cebec920df90d01d1b23fa86d2cecb9b94ce2c80450f97d6ceee57327cb0f3e1d549275094760719e82d522e3fef75260e91aa30dfa08c10b6085cdffaa8dd4b53f341f4705e412e2504423647259fe89b0ab05b76cb306e0daef71bc8eada214fe261c1f9fd49f45907c57b1dc281ae0cc75a4f865ce6575a083dbf0b21e73e06f00a9ffe933e0139276b79343fc158ab54d4a210e074984fde77bdf6b873459b653565baca8d53b12e0f88b023e769d7a9c85ec92b62c1d2816d58210407815a148eeefebd35040098fc21cf571aeff1678ae3b33f36d725c3d0dccf0dd374fa26a8f94b2ba7c79fd14323cabff03fb9e1edf637db5b54f88193136a605bae473e78b1350d71031f3353f3280178ed2f476f4baa76714d0ea811c08ebb8d5f6f6c35fd76c9e95cee162de9cc5904b69622dd1ed702d775b5e0bcefde290d8bf1cd5ce68d311a526cf9b0107ae173ce841a7a4aa665cacb74d21ddcbf8db6c72100a892bd83ff4b2706cc4ced54469cffd5ba13a6cc53925a32f2e4d60ddde6febe2ab078168806bd8efe398c11cde77db23ec63bc354ab2eb203745af6ac1b70777173f981f7a13196dfd178f7bf08a87047ff543119f95edd9734e2affc914650254208d0700ff2a9b26976f1de0ebfc2efea25b0c240fc92b1274e88d6386afc5d9413f08174abd174c25a49e2b9fd4fdc700946f240c7de87198eeade13ddb66d3df7b2793ab57e1c3082944ba38587c979719316070cf835bacef1a3d9f05a8251d51905efb0e751ec89e2a9a2cadcb12df270eb18ba65ce573891ea5baaae2cb350bb72e6cb564af9f25235cf6eeb754c89960043c19b2285cab9ecaffc7b7dd6b852de1864035f89dd69c43ffd15be1be018a1f4a2d06ff114ad0f2bfb708aa14397b4cfde17283e0c1317e3dc3d169d24f07a8e31b998e27caa7659256381e396403c2ddba50c5c9928f5c5eb5c77a80e162a50a965390a5df5cd6c629b976f030b622b4508f87dbad9e94e3e79bcb94c4e10d667e339bcb33f740dfddbd62894df31aee959c72df3dd8ef3e770394a77b642106cf31c1beeee509115f6581be28fa18290506e57db77eea8917b43d0d5d8ccda6f64f7ef91357259ff753ebd2de89317491021497446d62f0b0bfc521fac42a13ec8e587b6918a88b1336f3150204917d11bd77103ea226fcb7b310f7258f09ba1a503d4cf5481cb82067e5985e26cbdd91515924bfd539cb23e4a677c39d15054055d75e1d7a35349171a061352888cda0174d0491ae1fe65ffb9442cb35a6c41675b80803b814e97477e60e5ac115dff691193298d4dfc026055d7ba1b70d474210aadfb95d7dee2bfb7a0ca7c4aaeadc96d168c07041d9503122ca9f9355038beebdbce8ef765cde673e043e0b89420ff0cfd26c152b82cf8a5c4f70ef0d917bc70444f7bc121d6c12e2e57f81c42eda513b93fb12b14fe39cd8c4f0608657a018816a68be5ef2977a4fcd555e9063b3ad0ba44ea08af9bb051481a2f5681a0b3c15fe1a9a147188e7c6035dd5aa8b52ca80bf07b1558df707889de01dd706558b07072d5b055b2457abf91236295119e70b3d1b56720fbc9d0f3de64607ee1f2e76e24d6001ffd519d6ea464705fcff5e2c29abebaaf9e49afd34be424d5442211be88e0c0ebe2b5339fda0b6407ab2f6dc92a03179f89976d1b5c174f07cc2d7e102e9cdf1c1f3ddd5a53ab6658ec4a881bb410846f3b79788aac7410f13792c7344a8a0bae28bef6b62f47213c9b9887e5df063b039ef5686606a0680a9411633f1c7474dbc26d49e04dc23f3c90371224206145d2e1def19c71c31f7e038030fa7bcb8f4391a85c9f7c93e8f31d2b963e2dccc6e89118e8c6630d4ebb0f45dfe8d0c6cf0c24a4e9b2809437feb7aee28e8e5aa256e010dcbaf1fcff066b5c33076f932b53e2fec886d70260c1a416452aea53653e790e339e7814eb5e7c37e96622407b2afcb8eb22bfe0b3956379fa2170e1ba314f37b08e493b5c422011d5a74824986368aebbb370e540c1a66f1517803356ed6c21d2dbb3e486955506955e628b05ca97a21468b8f717ab22e8b0d4e49e92fdac779a3582def210af86b2cba5498ef5038aef82e1bb5a3bddf06163c818663643d41f27dcf5e8258b0163c0b86307da676a083a26ebf568fd6fa66270916b1f22ea502cb5b8547aef7bf95db3f097b8381aaa416b142ddd420f2eff220f4e51b03c3ef8fbc93ce4a447c02166c451b7e5d14444a480065a2fdc8373149599d3580244bfb5f2dfb2b6060cf35afa7da00595b126067f9af729f98ff6c4814128fb627ac1537cf79d83c922cf673be18249a84fa4298b560d0d91c4b552028dbdba89d4269c6ec8338ac2d2f4e391e276fc729191236612ee2d001ecbd0f8273759f4ba9f6ef826c0f9d06c6612cd52884082710616f8c45f69ac2bee8b2d916f253729318a6bf8b8132d6272b17209fc59e98684cf96639d165a16573e7c18a2f855a1332d8839c6ccf4eae7ffd92223964992f29386765a52892b8286fa1c6cf80e34f7128ef4384dfae8a46f013d5b04cc2f65c9e1c7a79bab12983fc483307c3400034a619df3b7e2ed64fa7c48cd99835fc9ae07bd9b3bb6bc17d0d337ebcd644c0d7aece3e9bd6a917f7f0190e55819143da0bd892fc5323918d65b0eca2cc272a9a447f33dd83880186e2e82c31fed9e5ccc6950015fd8379776e2c3905c0983ac45c7dbee649cbad88c5fee9862f2870c0fe0f90897afdabdfd8ceb09a5ae64e85a2e3474c009ed2143f5a0b9a5171eec4d60e565f46d0e738cc101677737f4f23b764644540ca9e70e955f8819a40506d214352acb21fb2a63fe597dfaed25f114c3313eb0046d70cdeb1fd77393f036e7297209cab88492bf5900fd39957a51d3be6b0efd709455a01469bcd90a80faf4c897ca436419b639e44d691bb9d8c596042abe013f54bb4c8777003a92019ec46f4375d41de1b4f2765b97d20d476e64950bf6b536c91bd289310bfb1e6c7c3c813b5030e2c17eb6d567e2ce14cfcd2f8de71c13193574c45a5ac84f675fddbcf5d76bff753ccbafb55e22d4f0b6f58a3ac1c23cc3bc4682ea7eabb740c21df3c5f9652d209f8650911900696aee43586425db8d9f8548b81a989a68a3c2efd379fb431aae42bf44541316806aa4711ab613b52ab180aa6eb6f3f080aae969503a7117333d79bd23f184cc1a52c14f2cb67c9c421cdb741d1db6d2dbbd59d7cf83862691f5ae5c1cd3c04ad6ff031415b5f08755474cbc05fb649656882d12e9831a8418957e673d9d6fa4e760bb612530156a5147dccdb71c4814527937c52fa1e44e4cb68a187fc1c00c51ec55806b3193be3ccff650e9c373dc980e3fe4e5085a915375123a304aea1a4ea0195364173612cd1c205eba16e93f656effc2e9fa85a6fc4d8ee5d469db50101a9a0889b527b6fcc5ea31a19940e50b94b3087d401ff84c716c6c4dd228e1464b15561360c84f00c3ad2b21b70b95544df1f578b07a5a6f56462f9fbbcd26dc61be5e2fe11906950fd207ad5a11abac9f260835ec76aa08f4dcfe705021586ec59a9b21bac32faf2d8b90a1e29a32a38f35063b7adbf1957b7550f3b9bcf45df217985a8bdbffa84257f3f7b3d49b3260a7f1b9efd9dcada44e718fe217cd879c91e427c08dfa6dc2d3e232f82cc90b8abd4f4e571c560189b4c7ed2cdc187f4517ca803d0ed82d2fdba473049dfa3ba47df88809c286a2235e8933c2729965cdc095a3593383fb363fcca13c659f398dd71f1aa897936d524e7f2e2f5408527dba86a65a0ae011cf78e92d2a8ff99e18e89edd044f531bb05fde0e3a0b7acf5f1bbd83e81c18792369ee3ec4c966cb1467fc120bcedc6235be435b1a645c891bf0d09e91f31871d177bc1c16f87be713542218785df2a2b6e109dc9d866d9c126c1adcd2b399e32ca06cb4c9ca21be269a71dd045d7609364679e019fba2215ea45d2e4ae5b4d701d67bb3388e47bc1d0f1c69e56562c6cfeae47ea66f9b36a4e41df5e8a99757a53601057e9e24894b595f0fbf784ddef37cb328267d10529f498a1f0429638806e8fc422d22194ada829b3e54f6d2ba991171355b3651a705b9f9bcd36f848dffd4dadb15887f0806a9d4b5fb479d689019b37b6dd6e4024ca1970d3584c2f9e2f4d2dd2c2a089f7a49e8d7fa2a15031c761871883f71ac0cd77f26e4c31bf6a019de922af26aa62aae108a1af7c8dd04178d2af4ab91c0e6dcf5094f88f39fa22de1448e8705c5a794b43e92cd60cff6c8cc2f69da3f63da8c35218199df454102a734d41e81aca03a6e80f74237ed531638aaa1c66e397f6be79a19e88645c334405dc02d7f03ffecb62ab8f86e8f49049a933031b1afa7303c32e1903598e1e4cee8d0dfc8747cc2a32efeff725171b7c5847d50d0a5d02dace31bea99f0d14cb2f1679ceba9108421df60f8dd5265371460055c7bfa51291485cbc9e7bcb45cea55ff8fda7992e55aa198a2d50f48e6aba30351da4d77986bd9742d17013553b05e7f6873ffe0d2e5b193abe9d89e0dde6c1cdc05abbb5eab415fc6c6486aef09f3ad20f9830add41bf82f18257502b976365bdbfcde1f436d738ab12928b8869f757b9b0c67ae4802f7a52f1dc84afe519e86c58767497d5373660f23dc93177a9429150ad9386a4c63e8f3e652a36f48bab44e917a7914be5e89666633dea1a4fbc36f83934868008ba00e479642fd259cf0e15ba72e50af18907e6a12196d335e0de9ae2e0cadf0c8a3a8cd1cf24fa76880513dbc070ad399a4a41c074c317f0526036778d216111d67baa26e5f01baa5791b4ae477c85134113db20909f7a6ccc443929e4ec3feb562a7725c40dc6203669d04fcaf74dcb56e3ef0dbadea30cfaa6fc59197cb486dd36e4483caef77098de76e9fdedd4ebe6754cc0cf2549490b5baeb7c7b9c027d68dc02a1a7afc0226063243a1b6ac9206dd28dd657194fd8e6d5d1afc35cbc80c362258c731b78045e80d8baf786dbeeb36f53bc335f6b1000ff180f0ac01b533048560fad359d9e07af6f132aa0c3d31cffd25b3ff2ff46826873b6a72a317e13220436ebf1dd471130746578df2698043191aacfb7cf732918c340406d7c1e4bab57e47452a80838dffcf37ad79e21342c7cb05b83afced55d35a58987f5c3e771c5e43aa73a9c47d2372b73e98c9e53fea1bfeb99a4369f03fa3a162e2884ae986caf28b950c347d26a25c56cf12d494ef59ed9aceecf3e63777769f0a56eed020ce372dffdcfd8a22127c9e3d6a403e208e9143fe373052cdddb06cc0ad0dd97e6aa3f9b734479d06fe752b2407b55688e69f42d69a71b8fdb92d97d35ee5a0c3b82713fbfffd7167d16cdb9416643124dff9d3dce6f2ae7515d671c9491fd42a8a32720939a267b45c1951875a22bc214e823ecec8c74cfbfddac0998d509cd7806a43839253b68f3641f68e3d4e11562115f35d45f764b96d94661b28aee7b0783f5ebcb34d79c670cb90018f7cf5ef5a88b8fea2b808ae4fd08b89356d79ad85cc1486483833d5f93bc2bcae5ce5d03ddccf3e53ed428a901f456a11d9c7076db0dd56c4b60d749f9abf4ad4a5d4a59f45582c415c874e54e7f25ded1995559fde46514bedc5062d76472b7d1e355cbfc9cc360c8747b251323ca505e161054f3b0dfb2bc53f537a09f58d01fcc89e139931d673fbd17a292cb6ee9c9603153eb725ecdda630d4b3a50a9e8e43771852ed67d864cdca04f0e4991dcd1770f7ed3862f7e2855aafb6cae4014f5cb96d91f155c0d260a47a36d66924a514354f5b3b1c069717304345e3bbe4436c7ca2577f39e612f91c7dfe83bb8270a70a64d388084c822a5c6d5b7dd5773964723b94fba5dc3a7cc62910c9295a0e144ff4d2f680041df21b1873d80c8811380fedd223a7c3325b13cef22c8832f4b9149106bf367a646ca02e715be556514070f8e5cff5b9797f58a5b1ff3d15d8d63b5c16f4365bf94ede17ebef166762efc12f8b68dbeabd8f75a73813bf44464086e524c904940441e12e5525b4b59f8f01f126e75951dbc2d9c04fa27f7fabf636e5d36cd7702553f9a4242af8df241bb2c9a3e23f22c0ca1dd9955721330f9e61912285e953cbc7fe48cfab655522ce3761b466458cfebee24401befb0ecb25f660c530cb4eb28d2ccb1a876d12e91ad5585c45b0a12b5a5eeaf9d131e366b7df1d280b34c34cc8a500a05146530c3428ce1f2e2b1358cec5fa27bba010ff0f4bcab5baa048834bc3dcd9941fce78f154bfcaa53c7634314732559a09a33f7d70caabd4b27ed939265b1ebf3aebe1ee6d4276eff0777a51672eda99991369d0d180090ad8ac606108f3b459e01c409c80fa624c41b7578dbd38cf1dc0d287c374336252fcbcfe84f4b877a0c44260a8ba4ff8c2ea6c22ac703582e0c19caefd5d08acdb2be3df7164882d3c7d46eb0cc121b45b7f1576cfefd826d0b0e5c8544a465880277210b2c00ba6d41076aebbb96215f32453221692d0268e46dff72c419f487d959a39202f7e9ac3a8e715c589ac1d4aacbde74b9a12a6b76b26039fd7a141aa71081179315a4c51e9c7027ee65eba2ae907215e1fe7e9048fd6632dc03f7ef385ede916b327dc503684255264309176b9b7d92dd89a15b106497ddd3545b1350d7888d7fbd2dd388f9750d94575c25797d0b8f0f346d18509b9fa0f6a785996e40a0441a8219208c3a91f79706918e724e9336f26f40a91ea10ddfedd24e433d4f7a13d4b7f33b0241eae46b2f6aec52270ca9185b4ac4b4757c43af4811f5bed334a24b7f105e26410c0a26b6bdb90acdd10cb6588e3167cc1557a87b88fe129a146a17fe084ff400d1b598c18a8b44749e9ec2b6a4e3dfed22c18a5cf392d60d83e59ee5452a49311ed0b9059b213b0a1b0bd3ae0dc49c43cd8e2d4740a918a6d497abc06003b6210477db82eb17d6112f8eadc34e4ad6d188949f2f14760b4b1ee9af243535604cad042f94fe760aa2ed4487917cae76e2a1999f67aaba712f1f08e0102679b0ab55d8184a96d6930e37aa0091bcc96e68651b1191f153212f953505013986d2481d4562677de8db4013d8dac03058f02fe6d0e89211d9224d12116e09df1314638f4df590cf99c7ceb3eb805089aaf82e2477fdecd4ffdff52244fe8d754b7c456dbc5aff0fa09b09539617b6f196794ac5aae0577b86d9ced2a80ae21b2b92b2a239973c3a4e5cef833097d45ba4e2d15bb60c8e695efb2dfb05307b6ee892d88784c0697f61c7b0f9ec0c58db8b41482db7d40b4f73262d457982c323a2a2490af4bf1ba37f3c2195459f42f1a24ba1257c4dec2c5a2d3cc4b6f3793db72a12c513ab26deea29a532f77917ebe19df7ad7e8520167cb43c643eea73b65a0a2a52db3dfae45a22f9bdd0819851439e797032eeaa65318573a388393c5511e5a89c3efac4ff978281e8d52daccc52fc6370c8d4139f2946089dd9803ba9096082b2e5ed393dac4a83f694138ce039455880c9d7992fc56ed9f0cfdf3cdbac11a8ce54c0a569f44a4a0733b381e7e9f5b0580fe046b4b2dbec4481527cb0eddfcf784fab9d4aea8fcfee7e786ceee3bf1189f59b6ecde60c8136416486141d807713f7d014cef2cd139588173295dc04155ff75a7456b339cc3c78236854fddc4b8bb651a544acc585ae9991eef674bbcfb07b99bac50610a9d1107e166ddc11a334852770107237152a20da943eb24b951dec07d2bd1e2c2c74d44b2cb938a241213d1582b2bba14368891c49a4d7525d6d8765aba42bcf7922447117507b7da4151ac746006f26ca8368c8866c7a9e17b5d60a876a2327299ddcd5087b142b03e153800b84761ecac5ad05d9fba4a2c4f311302aff26bf012127fe8baf7a02b54c9fbbde659348b14967f9e4f42f16d534fca0b91b6942788dc1e96609749a48518eed475e5fa53d1e342b228f0184a7f2c776e9088da50dd8534e82793f876c26671bcb2362700631044c02393110a6e20518f1be2c3c60ddb7b5d57373439b85bec86bf10ad6fc092ef2afc8ea629ed20827fa8bfde108d875b9c0d8389cff8b6828808dd3caf6067b218df97266f2c9ebaf107b811d671c9441c869a7148b12d8c012f3349f8a9ffe10e6306ae99971589a711b7a71099252bf1a88c35830fc053b4e0ca2cebaba35357e65160a9ba089df5a27cf46d440ff9583c5b314d43f0f5f4ebc0b58aea44b436b300ed84e365d8806b06d502e2bb951863f2d3772f71fbcaeb270256610580babfc0878b9c831d520f21be184efa452cb61f4f9ffd88ec46f2137265e7b01d9b081ee2e723c8098a42f607ba50d42766fe41d70c845894f974e5bb0bf7fb8754126a4034b4f8bc14d9d191a67517769d1252cb84c67b1829fce8fd43032b15868f0ce8a990e626657fcd64d94787376cdc906edcbac78ee399c55fe2ce31366241ac4145544107551ccb9cfdcd429c88f37e31c23b2ebd32e319e7121118585dc9f22756685b6c1dadd5b455a6269bca90c8e15734836a8fc05be06c88c86dcd58faf095eec1bd042f42bbd199f9db4b142304b14c4a530f8140e5e12987fdeeb316876d57654b8abb94a5384714d9821d5a188b8d670f6062c2b8f2044102af854c940a30b6bc637a5414e84bf6b080b6d5f239306bca99de1c14feb51c9489d9ecff34dff029907886bfd67074b63c3f5efee93468a024e890177af26fff2553cad150063548e1b83d65a42e30c147fc3578b887d91ec4d10f9b7c3e38e28966cf3c673dfa94d342a22333efd9116cde0306f6b22cea163cc196643f40b2c196b9492d79eb86ecd64de6090aa156ec4555231f19ed1e63b09fb181246633951a038b095fc7673bb3d596320d77e83faf3aeb12287a57f27bfc37de14375a5f1d3df579111f0100bfa4b34f7e493b127ebacec9bc1249ab909f9cf500eb19e7e90fac4f8580118de18d931a393a6c627a402ebd114a1e33ca847db81e467ad280d417fc660692ec7db98f1143e87dbaaf863179b2f01191b801aba0596a9db2759c9edce3c96da46fcf3a0bd5a1eacf4d4c163b154ad03eb0c1b7def227261ba9404cbbf1a5f0b51d3eed981a7b8de3a291ce8846e930cc0ec2e3a9810a518e15336568ae74014e2470e80c75","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
