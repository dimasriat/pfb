<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91e55efc1ba1eedc33e58c6a7a96c93c3d93d00ad1761eae1d0cb4fdcf94e36b61db24f6f21b98d8be23c3084ce4fcfc7c2e1ed3f03c33d705c8da9c773907cd6dbaca613660e1b922f284bfaf0ca83eeae59f81453c8244f4a6e0e6f94afddaf6848cfcb5bb8348f48bf36dd4493cd4797bb3faa2d9c70d08bc1bea16f2b8ee929c32b0d9f0a1d060eab498fb8997078f55fdf1e1f6fc556f6395752f2835f686bf5db7fe22ad309e798d6e5ffc29cb38c3ca252e20425b3be457e8cae4522f5a262e5037b5b9a34b07662fce2ac2878113bdb16a74653fcff23810ee39bc6c24cd37b273ee28a2a0b32fe765a78c600cb50bb38d5c32256b818c5a7018f7d6d5befbf51e3bd61cfa417c9baf0eb17ef22447b978058d1e03668fcd718de14c81815dc5f28e224423046c7257d3099953ebc43fbadb69727d4ac75470364112cd4d40c074d56b87cb785b6e7fc0e81eed9e6055b4e16591ae06b1d17a41ec6b74a563d21d98759468ad471aab620282526f047fc1e12d070741876b289c4efef81cc8bd2806ea61ba042506e0e367b8313713eb5117ea0c645a413b3150ca1601e75b27be49025db99c97dae77790007ba7bc85a289fab6cdc1d557056bea999450907da5f228d23b90cbf4fcfd4842043f94d84d5daaa3b52c8a054b27249bceead3ae0f3d4db71812c2b66cac7de9660d2df76319b6dfb71bd7b38465358fd9d6c2188a004d7e3dbc42890be03074662768b475598cfdc227225e78d0914c115fcc17808d8e5a68f702e610f1ad8de2e8a03d7de89e687391d2ff26a65e45979d56ef30a744dc2b228f2f2bbfc51bb995a0db58e995a4354e31326df05055ee6af696e05b27f4e3a6713cd51fc786c14837d39a405196ab984ef8dc01cd0b3a617cac617a45e4f183d073d114cf08bb884e6f165a620a5e8f6abfd651849e9108055441e20be5f902abd272fe87b360b96dc5eabfbcacfaeeb3e8c6c1cd9f1fcee009453503d6bcaf6aaeb45586d8290e6d6ea32b3788e3ec4655173f22dbf0ff2924817f17c6e3ae77b3da5fe347a22ed0768cecb47cd063672d2833312fd0155b4e7208e808a1295377c2e10de007e2306ad6ecf5a1be341d22de05f7c203230d00349db39e50cf758f67f780ce8fc26294c50da50007a74fad9799daa77c0bdc0a134f55bdaa02c8d1f83eff94e359e7c2a44b6799c5b7c94abb2d85f12c9cc4f3ab3202d339384eea2d987f3da19e1ac4f89068d6abec44056781f0ac6304d2f973a66271857867a3f6c795601c6c1bd482c782b16d29f8de213de9c2fa717cdf699caf1b072748f973d9cc106dc46a9adf890b4c880073c3d58a8dc1a93d71d83aa7ad69bc0896b7b1570496aee537fd9a36dd40c10d65d458d106fcfff8229a8dde9811d81bd096b844d699070a4e3a7f95cb96563df11176404ab3bfd2977dfeb9a45f93bd01243956a71c7fcacc79ffbc7a8c372302066935a0312394fcedbd78e68621f671930861c0622f5ffbf84bd3484608f499f1736b5d75b816484eb4d5a19adac1fe10604543225cb65968b38db1ebe957654e98229c996bd5f90aafcb2686d44edb888cfa0c6d11719a6cac6a3399067a450bf8166962e8a9889ae8c5f1501ac144120507d5be9e5f63b63238c372c5734b3c70c41e6cad1ff645640f4d0c143c55d74d78f48a7f5416bfd5db7e1733e1272a12aebc6869ab73a688c9c81f387d7754f5c0a3c5c1f13aa1637855b125aab917d4aa3018c9e048c8dc63a9f97e3ac69b54a0bdf73c22da92acce5006c1057b3c9cfe1e160b2ab8b1d084b565035f7b71c56b09e81326991c47b366f0f88750bab7172cd5b95b7d28e9588a720edb3ea73043711ae3f8e3d948bc6a1553cc200e645eca45d9b20af55c960f9d2c8bcd6f5ff46dadf8f8b88c38d79987d45cf02ff963f4530cb95ce8b0f448ca6834d1774e0195f56cb7dee822f4f77a34894803e87993e3652c67347db284bc62d87a4d5b97c962866747fe991744c61c0da6075d22a1673912b8e2d64c3f4abedba19a82d832ace87956ba3efc918c7a46c790800cddcda57c575f813ba78aef770f9d8006bd4d7c366a560fb663c047c3a68f3721fd9a19ddbe56fe6d12d4d9c9ccc92474f5bd9b846c1d22ca2db10f1f735c128ead563122e0e6e661866a8f1d52956d9d5e72b94e7ff9b31ef9f162c09b9eacfa42775f1f44e4960b3141866992f529c3e885f6730dddf631e9993f625b84624f53a5627734b1bf989133e36e317798e4d7b498e66b6694f54ca631a9feb617c0bc8b9254b418feb74eb70c11aeb1a7186b82682701d5fa788bdaa1e361027d6751df3fedd72d37ad79e30a8d54932f67c1b58bc3a2e7fde8c52cf3f890a345661e57a1263f8bef4d71808d76c2e6b6683e7c8d5177439ed1245828a0051b1150cc4f5a6fb61fc2d1153b7d0fc6c62ddb2d635b81fb90bbb3fe2810c0a770cf710d27b6c8f0a389eb0b8dcc56f7470918f8b67303cf83cb528367a7110c490399010bcef911b282b8b61b72b0ba5d7f2c3a24b81f4b072822250c062b06e5a6e941158114768343c12d6ef12e32784fc7fbd1bf2b49cf0200fa5a9a2d99a08edaaae141a173e1b879330453ecd0cddac5ca4c65be75dd69cd066d615fc50184663bd504c5aa9ed5051e9151dd262f9ac505bd448d5a499c3d3604a5d4bf7026bbff897ec16a12d4aad9b891ec80c180b41de18b3a706a152aad69b13d4c123be74a4f3a62b9a172806ed2deaa91a918aea17059876db8dc7b951efe42d1e72bf40b08da42c197cc12d3454158010c17663bb105490192ce2fc7c3af0a55f2bc0260badcd9e50fcac865586d00f58f73d414adf6176ecd7a634f48f8491f906b72301248be440456cc6af022c1c3bd3a121609fb4cb283f6d9da823dbf62ba9571b42d34ab4de933845a3d27473e21bb4e7ae66df2b20dd4a8ff5cc3acf335265559ad9157c7615d7c5f331d894cffb4c38fc7e0218176369a64b948fdc3075845190a230e2aa29bde833a08b3679815a7707bea51b653aafab159da8032b0aa77349b3858074dad7ea0d8278d75cd8216108719dfb1453eea6bff5a8175bee65c12a66819f95caf8fe13a8016b4d8f3cda10899cccdcfcb7dc398c79dd61a1dc52b823d68a2309c18e4f3844521b4e66131ea1f2df09b745c072a2616345e8748f5c64be6b6b4e93733ebbcc35f31202a9a150a2d94db0b62dffda3021ced8f9fa27251ebbcbe8559b4d02c3dde1b3a98b33f32a90c891a4f11c1b3634805b1bf11b6ec18c9e98d29f699f8675706546b41fca84ef986f5e64ddac99e13fb2e357f5979dbb349da81219d3e1d6e658efa42e4fb76c8c18f5c469c77d496da35d088cd815f5361399f68e4cce7669df04b65234c423a331927d7f2e1aaa5cc16807000946fae9c8e75693d3878872a1ebe87cd4b561b91c5deef1d287620745007901c8dbfd27a4d2a4076786b8addd533ad6c9c93ec9732779bae361e3d3a592750b984f5d339abf0c1aa33a2a9b032887857c36ff1667e3b982369017127b5634541cbb7aa8f1d9eacba5c5a9de893873f3aa56f71eddd4ed585447ee91c4e0c380ce2bcc545f55062d750d36b1465b4abbd411f25b544cce9fdbc8d421e66974bdd14cef726bf2e6ebe4972bcca3f9b1fc94cff499545b1855dcf2be67fada0afa1c7ad47ca0f9ba606fcb67048dc60daa5a8bb54a244235bd66340b5b64ede0a9c2b9b1f8d24d11b23bf6438c755112ad328d83843a36608a8762a29f5675a9f4bb48562d57506fd24e88e1b334742dd538a59788ca472e56965be3dda6665d4d14c7255b490d10e710dabd848ce6743dd430a2a4119b73ba2c9a35e1124a255658ab3b1f0924393a63987181add596cb9a3e891bfb15c69142848142be3051a0ec2611701a3b3e19ddcb9af0b7a010327f71d0b0925a33d52757b65abeea3b7f281e616318a4e237c789766ada0657b56920ede0fe1581a2e162dd58aeb6fd95adc6d90ae415c4edb3f439929dba76269168219b3c411c74bb1e96656f2fa8d4a08c3b27b3b53cabbac4e9e45fa68a7f3f359ff8d7f0c857a5067d978d3b0da232635f71dc7ac06baeabaa05b1d7a26d813c2d415707aec1a1b7ca15d279f24bcaac123b239a617909543f1488038d76950d13251c54ade0b18f6ea6e923433c20f787a472b6bc395c7352a7adc49f76130ef94daf0af3b56142ccfbbd394e38f2f38892622a7ac06a1ec4cd8fd5093226bb7bc80ade65f23fad6f4cc663ca3c1504ac561d651a6754ddab9df28ba3afe1eafc3d8ec14e6e404d6cf0e90e9cc98c22536f5433091072c3b43332d303b03fc64741e23ae3f3157171f56af86ae281a992a2faa42427af64618f8d33b6c7ee3345d178c56b84aacadbda7146e9d02878dc958f67c17a5b0d055002a746204ba2e1fd971ae6b4c098c1b8f49bab10f6061d9f7b867f2f53af82a9319fdd02b0dd0cbd2f2762d7a25c3b2f77cf58ca0c1e9e2b0bfed4fdc7422a375cb95c0e9b51b566ff30b3ed687ac574b0bd31e2ee7323a58efdd742fdf28c2bfecbd1a5da82bdc9a13dcf1b6a2b123816cc2db75de04c26065a5111b9b6a24ac23064a7369a24d988d9556c01d0d93482ad8845482376e342a867fdea07eb9bd8310a3f59d79803a84266cef7e881b87ccf76ac1e1dc32612d18ea2ea86006e746b5721b84c2dc15ed961bd185a2e7fcdadbeb628545628d3580a819637a8c31de92ba161473e82d5198c98566abb1e44d98f0da59a6a91c040b86f8b77d733a8abcb73d27e8d50f9a7c579f147733c4c6a60d5fadd25f519ed1f8b2522d76825b25deff9222fd3dd1ba49777e40bc35d52e4408dbef695433b30786abbda23a1169fb571bbc632bb101d830e74458f517da46864bbf7bd703655b9182d72b9ed950ee968c0f32277c52a7a03db763c1fc242448be84b752e92162d84a6f05d6a6af6ccd16f7c3f1a800cfecaba5805e16f68e97c2737174afd6ee96be68daef2e956372b0b9764d884e04968891fac03e041c1e276dd3b634f33a00fdc9f228cb36ef19ce52927137173a6ce6623e779aef221c9ad7acc4ce195e53d2d02c0f44f5ba7e6b26a7473dfc0455a4a998d6a75673b3015c30c9dab0c87d49e9689ee81f0ac03b0ea7324fac503f63bf4a117a8f2678eaa0549db1b97278dfe8c46228de5128d7afb03b30ccad0265c70b77f1bc29551a4702e3e6e66f9ce5fe288979d8a0c21063725fe6551d86e504f0c60fec00bf1034c2aed5cfe1a6dd54d760241f06ffdeacc868e9086427f5e831c7fecbbc27de4d52527f307c81799ca8f3bf4b5bcaa0fd431063e8d66679c72ad24a57b26cbb4bdbe61d9a93900385b9ba07fb34dbcca658e7ae54802e53029119515d19e1f140b56e7f018c71925f36351553d97844229d464689e7152c07dabf97bbd9535182163c318b78e0dfbba855439a4edc8d071c898e492306cb9fad273755ea2850c94c476373ac1830b51030f57f9e7a31705a766dc68edecfa3860e05f899a32f8919c9ea5f3874b47bc4a8b806aa081e46ef2d96cf143375ecada2a600274501d9a29be1af4aa7dab251db8b1bfb548f04d985b813a93e58038f378f86dc33edfc08b45d27ee5c6b7c49d9632faf8fc8eb6696c7fe4ad7a2c36f8582b94879490f8ed56f55c8d14c75c0b545a033a43f6921f7429ccf509b5961eca60762139919372045379d778770423dfef67be2a93b52da228bfe95052f0935a0266d802cf5a67f1c2243e352d7bc3a058f534a6fc88337f558ee840b44abcfb34fc9052a19fa131bcda5011d16500b61f205b9c741482de0081d84789e91230d62cb2675178c6dce0e4d4d95647f00a8710833074a3bdc92bdfdace20ccbbe1f4565f9f4467d132aa1ea34533ccdfd6d22ce2f46156afe54983954b3a9b064f76a2c4d603d750564f46a3a46212ca5ccd412f15dbf6f456d530b2678ef5e4e6347c435bc1042e5d6653c843a8f76edfff209e4c7bffaa58f37fa4e948e131d794e331f279b49d5576816c71dbe75b6d6e1c2eff3e7b40acaa439ec8e3cb762eeecb2d65ab193894610590868f5ef26034752e84b7d546a3e33a94c360127d3044ed4d1ab7d5b4f2a175eb71453c14c94765d74ea1464873dbd82567307572afa090c522499fcdff21c2a99bde147f1e9147d829dc7d401bd083befccaffc76cf368ccbcb2d226a78a5b1de9f900f0f076f68799284a588b64130a2f9ff41b1c93cdbe3e18dbdf8adb9c956b57794722be6ecff90520a76f2aba42b691f15fee6698c7e15fa745780dcc7dfc626fac3703033aceb7d61f4b40dc783bdfc1f946d0170900120877d831d0c0dd08dd35d85e082384418950b2810070a9516a04e04bf3b5d77ee25b3a02fe5c5def1e4c9e14c0686ed0f7ed03ee93e3b49334adeef26e9ca4ac2dd50bc1caa22955606fd2df95369607a2b1062b04c94c24b4c8d43bde510bafce00267e2966a26d0bc18cb0c4adcc21e0c7edae4b06112f2579514df63cb0b48bf425e17834dd9df95fc72742d9841f97156f7046239d3b12e4af75914d923528f640c2ee4b587161dac7d402137c3f0296c66ab27b4c29a95eba0828044b2d992b716263f3796e6f3f3bc0a656cc7e759c76537886ef0f7a6f17c80852ddf6b6f359fca05d445ab3c377880f93d68d7e13aed60bfcf1692e5b7b7ea4670cb965d55697ff7fab9905e07078c14c95c295882d72f474207a6f575f531912ca56eb2194a6b5311c890d26a02fad972026f252f27e81497ddbb3cf137719d1f9ddfeecd94e4e8c8b5794dd1015aa91aa1ff9ed4b630cab305e77d03d9609f15bbf77c405274ef1927b30f2b8badc8b13ba2c40a189afece2eefa185541fbaacfa5eb3a4e392c4c4c21f164d515f4d2ed09bd42b7a004b373b7834bae962c562c5e08df9bfd187bdd5f2872cf04dcb624ffcbf200605e1bee2f91d8b05c23e2241bc9fef0731eee3385c2b5dd44ec1c0798a6916f4e0c844c9b932caf67a53b03446b159f86ee94e6bf53ececc0d8da7ebcd32d9aeed502431b20c0a5cecf781ecb5d2c1179b2ff6c0c1e57ec870ac1c15f293a547b5db13fb978e7cd5d412269eb0c8c45a9925ada2eb37a0bff43dda0810d80de96388c402da14b88f676075ec887ff14f2db7b24aaffec93b65d74144670e0b91948580afea7ada6fa23089ce04f8ee90fd1f7952f80e6a94e8fbcf42c8140e0cbce1b2a66fb8d8b5c47b12b61df65c0df1bc5b99b90856958227f839d7162b8042e32178a586f7d870767f4b97e8554e9418c1eb703217265900e715540260bc7902f13c7e61c07882cfff4437e2c643234da6d895e03cb9eb3fee1d5c389ea29d2e1cd5fdb4bbaf4f4c359d725ed803a54b01c60b45f954deb8176151c9adaae0876ec90f8c33605771bbd7928ae0f24af6494ecfdc0b2a9ce4e59f88b7af8e2a88254f19ba6c8225550c6dad56ed10c1542694807ca1971a40319cab2d61606c5c77f774e00771a8b3554e43112628ab9bf2b7b93b048a986b9511d48777cfcfac0f27a1f6bc54b6ee220ed135025718154097ebd144875ae5a3cc2c7e79f8aab0e2cc9d0bc83c931cc2e0c4ae22293273791cda3e81da94f4fd6a2034a38c6ce6d3bece95f56978cfb949bc359caa71adfa5ca3f36ec86be85642142c970de2baf220ee2387e9c3a6b2fe35258f8d2a59da02efa4facff199d054e7959a5ca8bdc36589a2615d5a320484fb986140b465c7b1cc21c0a7c30942ab4466a5bae8ebda62d73112cd71c20812cfade5cbb5d5653b3364d3ccd770b76a3140d397c656bc87e6991d36bd409ce86bb47067af204cae7d14a83903bb69347815a167679a12db734e9194392623c3df03237bdefbb9f5df2793142f531757196ec67357578f882015a64d2ca200a63848e2d0742467192ab2b97e47b0e7d8b2416c9523bd35904756fc73fa57fc75c1c9a810ccd12f1dfab0294830233e38425827f700cf8fe989cdd086114ec081b36c2be150863d4df900d4b71e79c2ac46d68a1dbb81172af9b1d48c39abdcc837c7483a5e9ee9aec4eda353b4866b6ad4ec41b09a64630c1407ad99ca653033803dcc6d4c9df626cca4c8874f3b1b5feb3c796c56ef8a3dc908d0388ab6212bf1ca3b215ee38097820442dd92cd9a581057b71bb84da17a98c615f2ec6ade8cccda940f5a3835c31ffbeca27dac927832dd690763d2958d611cb9ffd5d71257825e122a84cc4c8c62015f5728350d2f9914a3ce82f3f2fcf324e698b0a44ab8049fa24fa2a792ba3e269e38aeb1d39b594facc58cf70aca4c7738f48faa03789de1fcca47f41bd3ac7db5892d99a1009e721b64418e95af31f5ceece1a2ce3064e9bfa684864a0a9176cadef035e839f419aad26c1d09d1a7a215c5d01caa363ec41d4dc6379ef5f1f58b5a48c3bf6e9dfdd753d5701e6c599b22faa7862dd9f60c69a998126facd1a4bada78a8e235c3d1dfe63534920e144c4235e90c8582c4595c9ed2d998234ab97faccd992d9d4b73e0fe74312b5fccfd3d92afa8bda7b6750bc559aca65c8b62de8388c746e2279197076931c52393e0cc7fba9c838c6bcc9dc2e1d5e4db8b7e7a6e9992f5dfcd7354de2d8bb8d57fbc40ffa6544a9554dc3edfd49e84cec579393a1066704357ba86818422b5b75568086932b2924cd04865f17fc7c778215e3102b9adc7d23b077bf5c847a158ae316745de5c62e00882ab826351d6080f56b46180fb910c791df2c5f676c9d8ded6893ce7e4e4f02bbd16517725cc89505d34fe7d08839c50dca15ad7884c4016962f45c74afbd60bc62e4631e9d1c2eec1fc677536fbcb908ab2217bffd8fd8b21430cfdde6f438c68c9e396b0365d3b20b40bb955944d27b4245eaf55f191f3bf7d321ffc755cfa7595d761edfd527bbf66a0037d6fb303718e49d38a4c7fec8b072eeb6abdebba1795d100e346fa07107feeec9836ef6b6671dc20cd024081b33c5dbdb05d5b0cddff8648393d970a3190227dd9d90f132dbe2eb0766593d96ef676a8891005f7b908c99d7ccdf88561ff056d9b734344479f46e4984427ae7eca98afb692b755d74c0b2bda3f53b5ca3b09fe6e0c2c78cf6df45cb24750e281a84dde7b2b7c6e2a76df115d8bdd997ef23845bff21f80912f50df2ef34d85eb62fc5fdc1a3a5ea75c89b10bbf913416db5c1a27b97e52170ed8b0891811137edf9b051b2d0cfa2890d3a7a54e9ad445fae78543ac1d2db22e7d911b60990984a024dc72b0618fcc4b97bf3c3cb9d33aa710b6709ec003d7df4b1ba4188a2e9b175d22ad87159372e8ec093d3b1d791a80cee21e4c4db1eb3b9c9017d240cf344088c2a0f90ab74271d5dea52592e91a6d59d5fb30d199f32b6513985ce780c881167765846de3698a628f1e460f4e23bf2292638b38643ca8444b83568e60b8eed8b648b4c391569389c6474460f804ee66ecb109d79d0672401003023c7cdbc197e49ffb567c787d6a4867e74a5831e0e73ae0a3b4f52c71356317b71c8b2561f65ab666897f4fb889b3ca5239af13735b8fd82975cf92153a8284a834d1644a968ea21f609de9ad41db6eb8a122cf841091cec8d9913b42b7ff47119af5ad31e67f0d4f689d8bcaf84ddf7c29bd73b93e20b0b1e21e284df972a6abcc9abac0fbcc91a68916b7012147de5f37b9f0f15dc642436c90de586472e4eb2e674685ea8acf4022bc32ea8e6b5ad6d513bcd712c55c345fe5725185770566a2f55334432dd16f95940b5c68c1531f480bb652b52550d03cd50c9ac284bf09e3b83e0f643364f1904c145ecd479d090f10d691e3778238702033360d3160976d2a0ec358a6bf6843b0b7a1af0f197a978a83788bfd63fedc4a09229b5e0a5ba1dc2e3b983d3fb734213c6136c427d2e600ff484549060269469d5c601a6047be79431aa714bec40c3614fe7441ec438d7a9612ab4acb8f508221ace522e02cd8598090adcd33cad97c0cd64848e4a3cfedc8b3a9bb589f3447fa8ef671eba08436fe1c7f006615649d2a4839ae079d99068df9ad643f7b626ca1f90729c6930449d0b871fac4c67904d729b1eeb9c641f5ee07a624168e54fd6734d324c075d0e5316477b42780170e1ae21d057fc943953838923bfe13fce56fe6a488203856b9c79c19161a61e029ee69f702303bd6ecb33ffe3434c316e21e05d0e8bc4c7254bb1c653a1df1b93d90726360723868dcd02928a756a364cce7e76561b3a406c195999420b7faafedf26577c83e09764779a87690a593c56b5cb0a7bff295326351e27069a73a1505ef06960de1f12faff8eaece5135101d3af85f8dc5831d7e34bf6ddb38792606ec6bfe4f1b4176309e7b6754b3fc491342d719eff1bac279f85f5085ea81db9e478fa1021627c46a04fa87a398b076872e7e12c8614d381f12c0c6780e654f96c233b5015dd14c49f71d9e51b74a5597848730d90f391954aaa1fd0c00d573abd268f08f8b445513bb78d1a07fb06752f3a2df8040c58248a1917245b8da4923cdf210c1ea09d5c28eb11b68194f3e4d4b2a58a981068419a83117f9cec4a518b40cce4d4d4ae64cc7f80303d85dc491340ef126234917edf60d98941d61f106e1608a665e8cc7d368d9cabd3407cbdbbdfc4074c1989613417d57f2b8dbce3f13b0c4965e6f9860dc1bcf2ee038c3012d5456073cc58dc940ba7dbb45fe31f57ec8218814d137bbd4afdaeb562c2a937bbe88de81c7d6f78d8956ef7d52db992f688f1f64838df949c0fc103b8e6785d0f4feea87fb31dbf4718cc290323e799f91986b32346bec4e5f1e6095cf7454279d2c0bcd6b1d444be7ad2ee26e9e94d0d2744bc7c754a02e65a2e878cc30d273486ff6fd717f2f28752b207ee26fc84241da234bc30ffa0562852123c59352254a7fe11ccfb6b4add5ecf344239b57642ce8999e36445b29e405e1b595983d6b8bacca8526b1775ad26bb67276e803fb30b000d3b4c2761754bbdb1c78813f7a5f543e930e0334bcc57f3a19fcf7a1929b2db1f32d6ca29d8ba7280e99753139faaf753e67f950561cb8ae85170763ff61302209afda0998000dba3013c08046a29fd06ccdc44e5ec900131a04658024165e9f5689254135033dcb9b477d371b8d93d2c9dad241f8c7b9d7bfbe1b4c23041ee9bf086254f67daf3edf7ed97d64b7e12594cce32f7e3c9ff354e487ed8ee11cc8e78fe73e03048bc04433b49b48348f9ed0b109b5027512a53b16842c20dbdd7afff68236151a587275e47875c2c2617413be2ce94c765bdc55bc5195445db1b85210eef0e90864c4ae93918933b1d1c9176f9533a6dd1dc43e4e7d3bd4acdac6fc51681818dc5241e0f9dbf138796f2d3701daa5b3f1a1f5375d222c8aaaa11be7ad4b76e42f3cb2f16d7042a2837a07d80f62acf5a6324e03f7b6a1d7015986114901b6541d7bf0163e9f4ad42d394afc3080786d56d4966a04b0022ae7d2530a2090f20daee02e776176f91e0e5d35619754f2d7ade9818530f237539e0c0dc3448bc31a5ec3f89f5005d267bf43f93566582fe79d128423a9233d57769affdd0fbf2a27aa2044df5e978e91200ff9e9c8a5b8e22542f403d8e7c97972876e8edf70728cebabe9a45d434bd26d38261dcd457e2d54e391ab97d4a8a54ebf474cfc33315e7dfe38bdcbe84f88448c2b9b6bb1cc57fb5f71444533fefd68e6d2a497614b4c9ada75a43a88a822ad5c6b2d96fc4635ad07a3fdaf58e092b01a016d66631c7beb3c8c2012831c8ee4cce036dcf960a6c10ab8078bb8a5aefaf28e095a3921396d1b6bf15ee088f0d4fe520d96714e7b58468d672b37a1815921d952c1f71d21e40040c05a25fe59696300d80ce3d951365bc4d23576bc7e9b409af73f1831f8cc861b0d6d14c29d8776de549ccbff31b3948f459620c2b1683b18498e5d4ede92d2a3a27c3b984aad8acedb09ccae0bcf34fd8f7565b2867eb6fec274ce5e0c8d449aca96dbbb172d38fd23549e980c8753e50c39aa6cc2399bd46ec94cd5909e508240f461c029eec3323a4c979ae0f9556b1d070a80b1042af5ec107fa4a366c720a682c852851e514a35e34989d3121a8860a3f1f43f1ff43852389df9cfb118e2ebc8ad4cc7a907a0103f2716940afa04ab95cd9ad3e4064dd5aadd3a8ecd3e18dfb90210481e46cba8686ff0d67e1e211a624158ad72145b1e1e46b6008b51e1958ce1e0d46f982b1b8be07ef631fd7fa880e4c0c83dbfff5b90cf5320ad4bfdbde1eff227714aeb6039e70d1771325c5b3a372af98c19f9c4fd1be78964d85902e1bd443b023fd8b4bfa9ed780ea18f07f4ce4040dd7db58525e5ed39d6e06ad1efaa5fd4d97b3c200ff6d17d5e2cbd74cd9afbeceffc79d25a0378e37fff6c958de7a1028059280336c2509de04f434d287fd9dcef70bb15af6153ce8557d5a223329a033b2321845dffec7aea7331f73df75a39bee360b0b7b1e01e171cd7c71818005d503933d7ea4f90e22844bad2e10893aa1090f0afe9badf3cbd3cdff3df715d10517a10a6595574be542155e669562236a855e93686d6f0ce6369025e0c3fa1b7605cdcf924c6b2e50db9c916f083ec712ad160d904f0cd78a71ffb7a690917f83777806e26ed537033d395b9d3e949bf23d3b31711238939fc690ef9804830053598f1cdaff9bb131a6af7817c676929c4d6ba5fc396faf0caac13e27cd1a26128e72d223f6110ae70168bca54eefd09b4e92b57f26c5d57a81d8536785d869cb89fd2bb499b95979850e28ccb29a70afa8222bf9255544b2c0ee94cba008aa448f50418e45fa348c302b17721201896bdfd5cd8637de7db859321afd3ed460d9f879c7f3eb0c5f1331680ea9b9c585eccb7e07d9e1d6ab38b31955e5052af0c0a1d2dd97fc0470c41391e82144213567bc8dde94a2f4c531b47c27b4df5b72a947f41d38464d81303ba9a20ed5d14c5560de06c433887017375fc211bfba71c802c36fe964c94d1f321691a5a808d2880a949cb9d3aaf8f3d0a566491ab800c49169673beb7fd86c0a514e6713251cf8615aa9d3d826d395359ca74763cf9692e0b14bb619032e5ba8e5cb05d6083fe02b627487d652f4899a1ba0210d77c26a0aa18a92408091b8099630612b2dc7b54cd7b02acd27890eb7137fa65b58cfc6bdaf8428f9e02192486ee32e3cb2fcb3186981d8a4538443311a36ecd438231db71c240c583feb53e41945e023bfddb2c5bb9605acfcb35148edd67c779cee6ce5d4f112714056f423b19a1a4b0dbeb7da34b26c0f2488963d3cc8625aa35fec509fe27ed0828d27db6c31cd2a24d644f8102273b743cd0463a580a768a198a3f929d9900ff0ffa2ae144296d20e1b58f7c5664a0c7b0a1022ec69fbfe6d3de99971e425e5aafbc26b1e5d04138e0d598dc297c5c1811395b42fb4382c45431c03f65069c44acd145e11793f5a05b016ae0496d7933e346babaf217ccf0884b1d8ffe1849a3a592e9d42f8283bf3262faa69565cddd784c7437bd340e98904db9b135886cf2bd1287ab99219cfa6be81e84ae886a98fb1bb454245397d447686eb6fb327647ff15c52b5de1eec98dc2824921ef94c2a17cc3d1f143225b06368fb858fd6369a8ca1050777cdd1bffd2b660cffce184e86f10dbf72be22ec3ad418f301ddaf376b5b99f82bfdc5cbcec74d2f0af54f1c24f3c3e9a16ebc6a3b31a1db11122ee584744895bf0fe8cd370a8b837284fc38488c71d5b6f6c3057cf8867210dd2ffa633ef33a577c0dc430e54fc7f0bcc221f4e0a9ab2b91649f9ddb536f9f9a7db131f8e9c0a9196c3620eb6d4b34f8aa7faf25864a0e132ed58a259a4342b2e380760d5ff8e8a116adb6d47e84fcb371161d02404fc9f72d71bb67a7b485a664ca14aef2ef8f614b347783f5c7ae17c74d8cd459d1f48392e89ccea2d80dc4c2124e3ab3162ed0b02e5ae5f5f4348b1db748b3d62298b65b873363827abbbfb5756c237cd3fac52afac11302ca6d764b253bf596be863e9e0dd6628ba81fd4bf48f7ae48ab94116dea85985bb0c142db59d149c99c63fd8740f2dbba7266cfc74f022b87a0c818b68e2c718f235003b5d5d82f7417a5224eac36e769a6a89deed9e9a250f0e49d19a8a9887aa6480a3d5c0ce58960ef85dcd7112e60a117b8fa61ed5ed16cdab4be41eea4f1d058bb9448feef1ea2cbe98707bd5b5256ca482d8c6e0ecc935e785697cd4780451224a33f6729b06d0c00992d23a09a9d5be44e65faa4274ec0abc1cae0594cdd68dcbf0f7525177e6851c35c2d588431a3c6a980a1d86b1370da454acdeee561398028490f729e63a53033dc62341a35c2417b1218733135af61cad445137949f2034cf9ef7bc4af3273de5e5b1e4f21443eb9e8a4eb3ce607df531daf947e520157fe23da70eb0875c42666fe00b5a6fdacf50bd538ff9e07be83ae40bbc8178fc1b6f187b1d19e7b517998f51f043e67b11424d19348c8f481bee47a564633b2a1107cbc2e3719279d418e504a4f5985b66acd00938a63d4f022926f7907e942bd70a29fb04dfb317785226ff6c6ab193ddc4f99011284bfbc0ffb32b6e33266b6bc4d8ee62936c4d8b9bf61c402d1c7ae2825f634e0ad014df395d1c1553cd2ea3a01475bc749ec9b556a43d06b8155c4dde2cd214b29907ae335595048b9c2778a23b1d4c2a38e3b6618d72f69cca2a24aeba8b582d3f16efa571ec8b3f363c93a88842b6238ac78bbecaba9d9269baa9d5909db3fc8ea54051d8afb045e61b2c63cabb5c0b3db4edba3b06c5e1f247f7c70e3b5cb33bb3c154356b39a0f6496a013803918c6d07635ce24aaeb6b989bb831b7abe1a83632290439cc44664491436d2d5a61720e59d7d6d07f82d7cb68b8e79c915826ebbec4379d643e6111d4bc6ce03943190c9ffe7655dc670920c27b3a14e4a0e8e7485e036dba15f0d38921dd64009d173cbcf2c6727a5374c376c9af5a78d6021313a8e0a59ee11844f1df47facd7edbd857e33753910aedbc29c333a53246debd61e9b3ff47d7f56502da1672b898ed153c80fa512a2a0399b24712a22137f7ff9f7efb949c769293d0c2e03572f2ab49fcb98db23a50ef47ffb97fd232e984f3719ffb44a3aeae15f11739776b244b84b20639a511342883fc45e112bcdf5d6cf42cf8458c9adf4f52e5cddfcd1272da11c4b2564c64798fff6b143e3f6c60c9871d281fda45ece94c297743bbd51fefc2e103dd50e1f24dd9875e4c340feedce052b2eeb0e8c4735b03f81c6b5c67e7d2dbeab4390d4aed8defe480a0687135dcb70e8c47ad518082fc70c35186bee9e3065e0ba226e5773adeafd0cc66189495c1c702ad29bf0f4723877ddf97cc8f5e816dd9d24da4fbf0983b59e41bbd4ca3637335cdfa0e1d44d2806067a843c231284abf47adc3b4b20b6f7338c16c7d4948","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
