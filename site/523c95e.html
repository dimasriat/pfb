<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb5ddd66322703c78f896fdfaf5f1337a7097a5f1ddb0bafbc4bca4a78bc39f10427638d256e11ff9cf407415e2f7740ef7b3945237f55369cd245d23e8172aaefb72f7cf6a0fc28623cf9e07011b7637393c44c9d27e8671e83b2df5b4b801e3057e50f6f8c90bf96e30cca5f24b5b0b7bf0b1fe534e8965f271acfd00d4c59b6e9c5013c9c45b506fc3313fb2c23410d33c3bbc5f8a4243bfc53ac9d1df2fde347a356cb90eb11e380b3665b20e393b2f2af61bc37b081bdea0cb44fdd70b547547b109f4f2482186e3e44b2f19c230c5e8f7b72151ec7d7e9266e0738c524b952755ceec6933392b819a62760f15ac1eeb557f40693bdf694a7265157c0eb3f660267fdfdc231c2aad3de9bd329ffd1ec9c16e0bea40f77e408a73cfad652f41aaf2b2fd9cfbf087e59076d0c7477ab52c9337492857f5af921043489be63af0020db3181070195c6bee1dab9378707151a57e5718ef2ecf70d816425cfd5eed3895be8169b00b2ba1c4b2ab6de3269e4ae95d60944d07d8075eb9a3921b5b3601d0f109b8ba1d6ae42edbdb9c403e4a456baf63d7b8123a1aa0de731e403cd3781e9be55ef49c707f36b244fffa7fa9dc08d12ee5f5373741e167f26af3f5fc04f62559451c386792c80e452959df150dfc73ec9f0df7856b76d9ad6199fad0227cce9e5ae8fca8089f3f143f8575964cdc510193c2e3828613b8f318ad064a84dcf05270529dc5e884f7a61be4c166926b6284fca146798454c7ee801a79fbf52d91bc958ba0a7b1c3ef49060d48f765b92156e2c929e8c232bf904315584bf839bd792a4225896dc3c3378915875e69d31ddb53840e152965810ac42452a489d75c66c186e9f8028eb96ae10ebf938a038e6e96d3cfe6083bcd1d6712c7b7026b8382a22ebb2358d79a39c3347d0865421d42ab1cbbd7a62b31465824d06f4061cbf28d97778ba87499bca0c23ea2588aa7c7ee070c5d451242fdbb836fbeac6dcc7b4c6e677dee37df096bb5155382d69ade20b25297029ab14d285f7a2b580ef5065ac103acfb246943aa519705d86df9b093dde854c65541f242d5606d8b9fa63bf705c196134d804102c94afd1b423c99e4935567d0ea2184ea117e1f79682b62984f149f3dce4474683c130bb198ce9933d9b708958d0616c70150eb8e7d088a0b43704acc0c15f7aceb99ec37dc147b0c79bcc5f4a94ba59ce94fa186393539ab5071231e65584cffe035a2c9be2e4c7ac531161989ad4fab0c382f481ade710d63af410b1bf7617b1b809f30449997a325fd37a900db68536523ed590cbcdc3fad0baf4e14fc2940e17822a1859b5b24654821060dc8a5a932c65c9c6dcc6451fd54885781c610d1df9cc69ccf463722f3369e30f977cb77cd749a3bf71034b7d7024e664bf89daddbb66fdd36b738af7c2f2b42abca65eefd546f61e3e927df0ae81677f16e867ebfa248621f320c5b86b31ec0eeb815e46bbe1f6022ca26db6ff5965064d4cce53711be7758559b557d6ffb88f6a4aab9fe640e0bb67c09cae2e274610a17907ade158e475aabe06f61afe251373f992ecbf12f587b3eb5abe05ec98333a8221e97da28d65685f9e820cab0d8eb4f46734257967f14e8e6068cafec5e375fd0dc2b537e74040bc93e3060a0dc03e6123a7c292e7bb8728fe69617bff5b86878174ee277ed648115e72f374254818ee51395e9f9614d8dcb2e1fb0c8c134f2bd35f7791349dd5edeef3fb4c2ddc536b309c5e0d084e7bc70e6e41606bf58aece75025acf17c2b9dc3dca74f315258e13a4732603a449450f6b14e556f125f62e9c4efb192d79e4e2465acd8dc9c656d3d538d09ac5c09843c7fc500a67590241d6e9d039250ed0cbd28c2064ca6624706486e1f4bd78ee210d90443c30d531e03817461fab55391d658b4b706d3a9c222c5665559d7fa3833f3ef184e4e4d9c010ad85fcf9b85996ea6756464e15fba740d0e0ac43b612fa444dbfd64625bd33f73306c279a662db31ec7511d3a681875bfa93c6720f06b499fbbcd199ef27daa634c90b731dd5ea3cb6be4e09bfb3c5f3433b8e25b1bc781e9d3639baed0924f2c00dfc73c655557fdf751d6872eb8d70e1fbe86211da8ac176c5ae42417cb4d37f7bd5d36aadc233eae289cca427ce54922b13f13743c88a9b4ed1042f5af2fb7d7834037788c80809632313807c2451556fd2c4d9589833210959b058ce6f5e8b9046398b83f7a737d923af85f7e3d0f0b6f40fc284d8134c7fee446c6863448d1eaecfd9327791c7ba01052a29f84e1e00bf6a06c64eeb7adfaa0f650d1f900b77cd08ff290259bbd94f21035cb09cdce6ce02c304df6b24eeff854daab15cc2df3a108d5d63e30cd2c4b55777d94e51bbd7ae7611bca8b1aed0c4fbe24ce6cc81143bba5f5ce0b7791f32e12fb6579fe1db0faba9820e86ca20830c2fb2e88030612ec4be76c5ec568cc1dac7c1e582ef0c2276a0078612b3507fcc141eb1f4d3f17eaad4e9091fb3bf5e6dcfdb190344ad673c6ea2d3b2eeb5ad74e18c55d5c9e7b5a78c14c90086bd7d4cf0d6f535eac5a2caf604476759f2c54c8f8c160339cba56fccbff1378b619028ec476f9ccaf53dd5dc4a59393695830cbbf8cc760c9b63247a1b34366a94e2df62432e341bc20acefda065a17c17b5f472d09d531aaa0f38a664c1ebb071d4bef73fa0d38ae35d93f89f95b069c7d9c320ac278f3f85b67a838fb4c6d70a5117496af3472c5ee1e8294751faee23e0ae9d47900b0f6d7898a83d1aa1502ab7832f99f032805794d2ffd62fe7d38b9259163a4019c17c586a3b5071c282dd600b25c674b8a79e7687430694712ad697e042a196939d4715effb087d8910b9b459a3560a9a539d242e9a1b103dcc65e3f5fdc43f0b96df1799a2a09a1cc8474e853466dcffa9c80d9f8393e73da6720fea99d1467b037b8def2d074a9f0a23b729b82f30f950967ade5bb5b2863b49a2c6a0c471aea3d57a99f5e8fd9ba850cce3cb6da4877b3ac315d320a5e98a1f6703f18bcf986014862cb3da56508a8476b8a8e1a5def1e9ca74a11160c303ceabfe825bcc405e60a3f2984ea7e7d460c147101e35d90a600dd06aab92fc78f9bdad6acf112a8187dabca46646d65b9eb3c9a8f85719b8204eeec996a7edf17d4c527fcb94ed90a6bab2f875d15dbc6d25c663ac0989d39248b50f5f51e7997984300979b8a33b824894a2faa6bbb243056850a8cd26c86a32d7f1cd11ee4c264a6ca950d447b572e197bad89bbb0d60b3fdd84f0bd71cb2d372d0a01af45223e8b701be6952b238878124a2b56f7960c5cdd71aa918591ef42573e00c120133de732aa7f2baf6d07f74bd94f1512c7c695c25f672f3f145e59be3180f76bf11b98e73e8dd11b8857f414e930b6ed45b699fdf03ff5c542e6172e1b40f03a1ea72ae3ae9774f27452792163ca15435703f08484be0e4524fbee4631f77af62b634a57650bc848eeac1677f5f2f116e19713999682f099b1f4203aea2b5d1d643c460b94381627a6799ab5813b69e60c75c11fd1a898049bfa9ae1841ddd59a639791a64f9353dd1414c95f0b59be0e069d47d3ec7d7fff1286be9ce78dbda4d32295baf766148dd3e3f1040bceb7eabe1ae77a61eca8465b4c445318887f969a045dc52346000fdd36724df1dd096ba6a29c0e52c78670dfb5fc450331af08debe407a77023f9ba0b8a18bf1a44d205c12d66b5f2b5c15185f3221be50d95e08509768400fdf62619c390db887d68897541a3f2947b53b2a6040531ef041c31264495096629296ba61d603dc5b33aaa2a16759a1dd12e808c9c3ed0d40d3ad62cadf7264d048e90699673b21b31acd77133418b93b4b30b2b4770b1f53533a5b6d3a1600e77bd6ecf0e0fc8d20f29ece712d5548705f1b70547bde149f415bfbeeffb090eeea962c0951f6ec82be293adfe964f3660d9f16703b217a5402a98c9279f3142773192d0afc99980bb431236ad3df91eed52f6534812e55e776f079f8d5209664b9f4c929364b1ec1fc5382057769b096ea72d9de97b184017bf5c7642fcaae7ad574e0d6590256adca95f545a5841be250551997f14c5ae03690c054a45ce01213cdb432e6f76e686201184d1bb21998a596a26c6b5b19a5ebfabafc2da10d5a53e379e935cfa95e81f011c222b726e2a6b80915b84a447d4501079f25d0853fc72aaa45ded94ee983974b944c913734f80c0754607fd7512f9d93b7dd2b25317aff7391f81fe5729988fbe4b0332624159f83497f7031f9daa72edc559b342bb87b06e2815b65046ba1c0172d52b25372263f6e766f51ad0b74454c41c49f26bba7ac6d405a4728018b3b546d6f8d4de9b9f58060050de1850f81f41cb06cc30eb6c6e2ff3fa8b0f8cd4159cdc8ace97d3bde01decad8ba5e4826e5e642b492a222d1b19d32c2961d3faff157e95a7e96191ee21525424601f41aeaddc6b34c9e4f731fcd493b46bfb560666db5738ae05eeadcbf950a3155f15104c5a6de0ffd2f53c55d89c18636aca2e7738356df3874c2fb120e1a1f8d22ec331610a1f0785b2c0f2a22eb27dcff250bcae18bce5ec5f51b3cd3e945269abb5241e3dd25ef64a605757bdbbf04c0e314a923689d2146c2a118051fdcb346a22a0d3dc352c69a70a4fc513f14f94083ec38ce06fb087ad5e22ee2df437b0dc1e849abb6480c4dd539e430ecab560b54e9528365c7cf31de804342151c68bd8f7e1c3ee33cb11252c365e50da4247181289223afc8165fa47cf0cf5086d374e30660cfdab0b4ab8b8ea476f6c5428cd3c9553d261b58fcdd03f4f8932b1fdfccebdc04a82db9d24bb865ab0e0869fbd2a4e0ae638fd425c3bc38b82e3a3b0fb26c12ea961c470de13ba580f3c035abcaced4a26f1eb5ad2327c67a72913128f11013faf45f0f41fb70f867974b5233f8b1250b0dbad7ed6531ce0d5d51d0b8a25be024f11a5ce1c6f6d20d65ae9940bbab220a7667cef75dd3d54399eb78510b72aea54b2957b4d94b1b997aedd4c58af0f6ac851b0474664ae9471feb79ae09edf4fb8c2ef660ef7ac55b5bac819ff45c36a6b724cdd25203bbfa6cf79e34de2f7aae10c95b5dd4f16e70b5bac52f29ffec7f8ec451d7e0f3d6e0174046d5ea9f7ae18caea9c3fa34c52129a61b534b6bcfbadf62745fb68e7d0ed1bf8d1ea5c10b812dff9af21a1145ee5ee6308747c0bbd1bc54799785929aad0abffb74398f6beed777daa19fbb60bc38dd50b24441c28f9839c5257e571645b4691b24698040154e2006b6b29e45b1b6a1d9eb0c70ae7ae8f5974acc0cb9a2867e423c14984ab62d186dda608eb22d71c7fedc91c1591f30b2b40e6cb3eafdb904f05572608c3d034fcf354382076bb708bfe04217500b3ae53b878062ff7c9ecaee27a31f14db0103625f0ff2858c15fdf5b77747e092b8461298cd7b82e653c757c9245c99cc4d5b83f88a7ac1f34350ea292d841c1db7016bf2a44c98130142394e95cca16ffdc67b5bb9b073a8248b8b89e5057dfc1951d67ef9c007ee357c850797e4b764c10a17869136f6e787cc6d3a4ddc3c3c61339255c3f92c67215aa5b5206a339c3e17c99920674c0a8282299dba5e0cb10a0dcd4c9be9645746343ae42706021eebe6fa76dcbce7c24c483a939c54a569a17534fa842bae2a60d59fa230da6ee079e34096a89af7ad9d193779d456b8a5066861d440889381019ad790d365bc2ab2f42a0e5be7e8d4e6fdfadfce8e074816b76b51f6cd8267f53234bd5afb0ab88e4c0d45c371244d821ab2372c79a7bce84c6544a442fdc27ec54e38d5c789ce749ead99129abcc3bf85a1fa16ea62967078a36e185376bc769eacdda1f44052f653f4562cb8f2aa0476a4768db393c7875440534e3e864838d487ae2ab1b58c0e0a682378a1b2ea2d15707e8756933cb6df6fb1777e6a495b2481d57f6b574a2752964feb92c610330bf6a6b49c96a6611185b242b154d4aa9f625726251bb86f963d1eb85bf07eec6584154f300e77b18ae1cef44075ee5329fe3dc6e9d796ac68ce1ea140021b7d33d1f8c3c3b001eb2558bcaa78224e552d515da50eed05ae7ba64e91cece04cd7f6ef4a197d5094acec2cf3fbc187377b29b8dcebe3257d4f02a09bcaddd76e54b3ba59f051a7d09d49fb9588c9bf79bcebec572b96443bb21749183639dd43048761f0a97024fbb73b9842e206db0e4a9b2e62367b9f9f25a5b80d7c4b7fcbc77a01556634413ff5ae728629483ee42a3b184967fcee052471d5151b501190677cec09240610e0e419f295be0b6b1d8819353b95190baf92b9ef5690d508f4126704b0a5ca861f22d77a013cb4aeba814750787fc93d09477cf00d3211b9a9bcb06c93eaa50744db813227608b08139538d2a3cb28482f393e5ae498db257b19416fe45fb506d65e0bf37a11f6216b7a2375d48573af9af4e8b3e294896af268d9c33cc55e83bd92e4dd0bf258431611a634fc5a8d8c3097b1fdf8ea78320fbdff35ec68e72439c134e6832fe5eaa3ad3ddfca58f87b6f8a525222c410c93afa2ceddf4b3c692060e7ceffd208274ec02658ead25a3f301c357a8876a42790fd1c1ed0bcbba85cf0a5dc6a205fd442ca8edb9c11a80ff49608346909f57b61d57591392b96b867a2c21f5a68d05dee59eaf1004f4d8752421136dc78a74f3f435974f1ad681eae66bbb00dc8bc8f3bcb213a9d36a4044c80abac6df9d88037224cfaa35ed918539ea32de20908c3a6e3d04a73f26178ba79c3ee880cfb57618ea4461eb28e242ffd5269ac0a211b0c7944c10ce1c43f412c41c496e2c1f2efa00da3debf9f8cf654dab908ff371d17d5856957fc45fb2a1245ac1189a3a4db62bf61eb3db8829090f376be1efd6f2d4fe1df8db3130aaada7e15a021158b9f46460dd974b7b5101b4355d6123a7da0181502978fa2f9253bd41b03a73e34682525044e5a6ab01760583c940f9f74d918617f4824e0221397077e9d0f65ca165e8a31d024db00e80945a55c7d9ae7db1ebb3e3e3e3dd4e233a21f2cfd6ec79875b70450eea749d7e9bab31a136fa89565fdfdb06177ad5ffce88bf5c23b74b543db10b84485dd84264dec559ac516252d5733989e04189930d677e4e2cd2c976fc2a96f61fb2e825556b2c97b685203a44f90417774d1f1394504875857a340706ed90fe92f82bc642ad9480bdf8cd493b59c11b9ab922adace0e2cb82cf84dd59110c5e5e33ac7642098ab78b7435ec0ff7483d6b6ba70b2b49e5386614b450ee91d7bf461052454d200663d28cc00f09c3c7a75afa2fd760724030c5a24408e8a893fb2b79bd9cc351346f11185fc61a7caa87cef3b16c7beba2318ec15d5875a7aa619cd08bb5540d4d96ee59836572d9a64ce14bd5f4ad8f8d34b8548260b86523d27cc6f6b6dfdd9d7877c3792142e4bda8b54978c1dba3d532bd660369f93436edb2935827062f414c7c0d45d29aef63eae30085909aeb0c2f016bfd0fd240cd58800580fe9d90c3a8f29f49da1ab4b220a02bd57dd2f4e0f1df5f2ca7af96edd931eb86b2da1afcbcf24b1cb9dec27bf7d3e3cb49e152bd23ab07a386d4c99efab31d30879c89c2942dd43beb223873e8db8a4c6cd5ae58ec45d4c46bf43ef80260fb52ffda85e6bc91cfe0d612157a938a8feba492b1f7311cb86ec8cd8eeedfa0ea6dbe4061f66ec91e1aba063c9e588523186daf5f1cf3c137cf57d01a0d061d98bae7a46867c2051a50d20eeb361e8f216379b613026d150c7cdea9e89c62955a82572f7a378b4e1db8c5097abc08e42040eaa6967a536b7bb24273ca2ae97b6e9fc84e777eb9326eb3bc8c4b9c22ed32bfb8ed36e7958d274935eab7e26b9708c6c9bfe752d0fdf4920fc544e8d9139fb0af1e3ecc672c645a2faf7f4cc02e461a7b104913251c2602f1698656eba4505edd34b78efb74aa460fabccbdc633a0059897d664f237369733c50939daaba849b5c842c4fbd10d9df7fc419261a76817cdfc89600245529d53b32cea822a341b48690af9dedf48e47f07d219501510633d84330de745c0cf8c8ce5f68676c6647ee0ede32d988ffe2081aee3416e031727753baca845e7ba8d1fb41378f3fdf379cc721a73499c0cbdad8e9679e9552765fc13153d67d7832a25a58d4966ec146e0986d39d3b5133c7b156379c1ae09232ac62e4d025449bd9604236b7c2cbb6ae1c5219d31fac7ee2229e78d3f0988b5b9a92a9991fe73b8a86e0094d516738360507da4ef3dd2fbc799f9bc90bcf7a41491d64cfafc86b665b08b1c4b0093e8c4e53f9c84286f4cb0306697310aaad9a7a5e9c1f632bd44ccb599b789e2483e077f5ed0218af326bd1ce760952fc1da521fa19373359648c445f246e0160074c85624d7a53d0dd670b135ec657ae0f7b3301b6bebfbf69a0bcb718a24549f5687fb7b67b77243dd8fdf277e7fb441509618d6269a01fc0563ec1260fb4ac3935bdfb86f4988f7e82650118553963c4c950ced6c96d0afe1da1fc8ac17ae1eb5e8c400b9b7530b0ea5412e39bf62446dd581fc724ea1698246546a3872691f6eaf040fc1aba39d9ebc27aa82dc09b1c661eff7894a4cf8132613c2f5bbf683f7ee9e95e8a332af8f699b20324c81da1fd262146094f575613d8098dbf1b417d2fb468b39b485e935250a0997d7509a17600ecc99ec956d6f6497794f1462af52ba9d5e286c623905c3da060b4403ec4cd7ba863e35ba0a072b6facf40f7a345599e737ae4a93899c4b33fda5b2d0c47f11dcb56e77bf9a5953fe95b1261ee41fca2f8fd489d056c6da18842740db38e1e5998e23a4c1ffff68f83d8ff0d551d34b50c9539bced54f1f5e5f1f7fd6b413df365e8ad857a8d5b56652e32f964e57cdb7eab26b79026df2be158f6479e1cefd5a51c867d443bf6779e94734ccb09876bf3e901fb4d51f93c89da36e0f16a3e01a9021230bc499ae0f0bc89969b31e6e78fd7c4ae5e7c2a78ef8eb52ee8de1f455b1a9d60e68953f819731d549240c46ca574036b53bb19d36cad0d55e394830b7dd706363f0cdef92f7b743c74300182ac2a61cfd9150e6618838f34a84d314ecd580cd118f4a6e9448f3b5bfe311d7fc1a90ad0ce4f178e1a971d5f6ca3fdff66c5f1b6a2022c058df763435f6e50e41726b2f894d8603457c59cafab9efd9b3823b798e302c9cf4039362d05ca6409b2f6ea726130bc0f12fa2ebda40a411d3a4711ba81b5e71fff98532c006f558fe993cf5ce706a217de702ec3ffbc49efb734f32e0574ca50712e7f6d75b329c1ebbf18a5df0d710c822833df43e197b13b05915a048b46726a85e0b4612ee0f9c6646b586bd819b261fed89ff8e97766b7e97d600e82f7a965b47c595ef175729a1bca37ca0a87e44bf6b37d53dc8f0be252c243dde58ddad677c2c39c1ee61ab4332e653f0b936d4957b025b82a545426f9e3f91cf90d97d17c18050363df49a22b6627efa842e4965299fae2ee6dd7c840f0460d5717c4effea0579edbb304aeff3f8997e3ef706f4e4a1d83b5caf88a0249f5c5083992999142e162f1ebd91f298de33953a3b96337d5f7ac7634a5d301375fc084824687bb70cef03a5a7b88ffa4356d80d41cc0d29a688cc43c83ada0b36d250705cc57923cc9183fe4a8fdc118370e1356615adf393d66a3505e03f2d106ace1e33272ec6fdfabd51c38f8a060ab4f2cfde901394934fd410c649b67c289f9c173aa66a7fe0efd7480bc9a5fa2e83722c3d5eb663a21334f00ff3b06928ed1eedcdec9a29ea95522ec0c60de7b21cb60821ce6f7984245707a72e849a5152cc1b5dac64e8fb2a88d244abf52364ad0025f0e2f31fdec4a4694ac7d5535af364e54a01836c38825deac3c6d7d17451429317e2f9f674db0402ff28191c4dced720beafb15b2eb99ffed573094ddc051afb8691582f3f3f7e4552da78779f311df90b9bb7cb956cdaa42a59d1bef718e3f13b6f38c25a6cd6964eeaeaaacdf9365b34c390c4b471080121d48c55a0be346c4dd9a96146b3c94e20968bec9aa61cb05d3894d9f2628160f307631525873fd5736d22bd4e8839a0bf3eee9fd63008ebc5fc9a3e057307debc578cb20d20e9938a530ade130db9504d622e4d4fbce5197a9f790f82bcdb5e9a4df0b11b2afff3e64286069a2850017f7634b72af5365e9f05c89bb9ff70b6a8a2a7a3c56ec835aef575bbfedbdf21f838fa3ffafdaab6d97ed946d45b5c20bf3bac7c36e55cf25ab60977429e03c98b47db4cb27bf3369f273d7d142373c29a994a5a55fed5e44838ed1761fbdc85954d1a9db99d9746636c7e7ffd7cfa11887b0b6a9f0f861070fd1dc49b48d3bc7846de9b762aa0e3cc003163b22860b3edd167a1542ae75f1a92fccade3e84c1810d1435c6b59f9f7fab547f6bf933495233a0ca92a319c6335a32b9092d57247be4de9c4af1e6c544a7af1a974b8897f763b2b9eb1b099f959d1bb6c5510eb422027f7c0b3be41f34679dedfaa1bb9879820081032f841885e496cfeaef4f633cf4b0a6255d212d319b5dcd0f8b0b893753a49324aff3a3a017080c0a13aaf02b1cf5ecd1e6f8f872598b1c06511537477213e7e6f6611299b54a3e53792cfc909642436f53f79f5880b0d8ac3d3fe6ad030bb4f63f96bcf53919936736aafd7120a624580c9fc44bef468a972288fb40f277a7eb139284e7fb156c88d3c673d824a5ca559392c3ebed73336bc295d09992686988e9d2cbdc4359ea55974813e0c20bcf7d2dc0665005776324c3289a7374980bad7b7bd8735de43922c61f6bf4472277ef450e3bc920e1e87cef3f8beef0f55233717f8f1ad34fe281d183ef2f0a0a92ed6162cd6e96c47ad53f233920605ee3d986e627d01bf69c4fe2116393ab020d64bba5f21e3574e6f59eb65a7253736854b5854c63eb80ce909cbd7a3085c2c7b9d8e460713e52bc9a36b34e8ea8d75acf8f22d240f00806c8d282ab6ae5fb5a677dc189dad0b669b690c91d185455acf0dcebe92c4a26ddd18ed6b9fcb4d44b7d0a7181c722f6cae0aac0b39b7b8fcd71241b78ae4af9598b5ca00a5a8fbf1761d07b4d04f654002225db27e1069f86f4c717200742b2166509d2acac4d19007d0e3c8e14fb9eb169c8578d05a4dee8723b10ff9deb969f575fd8cd61948116d260c57f7a52ab22f9816884b641b6cbad304c12cbdafd72b4602a0b7210ece9549acfe6ed37037c0948def92fcd9a0daf214d02f8c55c67e1a1f30f5022d93459fe2993b5230695fc641fa6baee1f1b3208c392b81b629215a6ceaf32d618622bf4e35e69e002ffeaeabd200ca744ace2ef8d00addfba96fc324d4ae1ef69400f319664c23fa1d41c8df7f1e2f61a59f3d88df56a4439e0b8cd280431d492ea6d9c3832c1d7de1917954bd2d2d992f1eee89d1b5395190fb163126e66eceb65ccc9c36049dd0a4f5be4bf064f2fdb52a3cfe979d3d3a52138f227a4e82c9a1967113bd05792414a70cd1e761b20212c1dc2d55d864574b5387a474ea744450b92a805f7019d41061fe579bb20cd24633a0b16e101288cf394c27ea88050aaef7851aa4ba65a437b5d7602300d30b48ddc239b525a6e4764bbe1db31cadaa9ee0ac37c4f6dad7cf6bde912b81fb14c0eac0d6b9f2b17321bcc98096720b032b7b0e30adf162281b1ea42b0ed80ec333b0adae870889c5ea2c177a2919b5e2cea3754b0ec0ad24204764786591a7dc0d93c0e8ad6419d15b2380837644171067ae347f3982559517f96e14c6bce8eae988dd267bcf5cd7fbaa4be7ff48585f9c02f9a9f81b9f4f9e78cd7c9ba08c7e9442ec92e50a6368c3d3c6727157a243b9e4cd84b51b0ef322f3a9d3966c6357ae1911e210d507756b985a62873835e00213437f96b4408af3dc0e11c23a9a0000eb5bb4f082058f311132df9326d60a3c9fa5dba8af1aba97575b401846c49e5d560f9a12b4b361339ac9276f7a1da1fe5d827885566f778e12e0f84515c3125e9e7caaba314f1d185e70f4b3d3e6451fe994e92c2c56c067fbd948c84ad9ad829a89ce3e76f3658c62d1ca610fcacdb5b5bb30a578c1149c5840be826b54d28fed9e58c0726e5b22dedcc914ae1de531f74c4f33a01e9ce4bdfc0de8e7310b04d9f2aa4c1ee670691d78f1d17bd15174f81e82e0865f35e4ced04c57ae32826209fd57d38426e655f717a31c8c2f620e86e3822e7ba43f1f014998b238c6b4d257cde720e205eb1ef675404f6c229c92b994911478099d696c7fa4da81693a03c99cd252b3ba6c6e83d4faf4ba3150aee6f1a60c52cd10c1f0f25502fdb096fae334feedbd4dd8827e91fd9f267bbf6dfc04f3701b7b125375fd9925385626f97505e943aaaf60c55de3b88443e8805b91bca9397f98fbb27c5b01cd7759da19bbd7330ad2a0be527654e66e7e688d93345a4be136b01b2553632b6ffdc22fd9c5c99c398bfa913502c1474ea44fb3a33677da2a782e27a0beb1c77335617f9e1105b541f802e0e00e5a037dc0cf8a4b24c0e9f9e5a2f7c4552ca96ede8e18a3169c29b1b180429780b4dfd7649f70ead6aad0716181263b0600e0daee38a1a1cb6963fc6e53b0f86bdf74fd86a33a982a2560535283ddda26458218f9401a9e718df8fed83a57b2432dba1a699225d1ad0b1ab95260de3c5416086bff06b045091d3079fc4879828d13a98aaac1332d9f9fae2d4f20835b2ae9f8de4021bae1c245a4793a7275b4865368f1f9f5f6d5529ffe80e11052a2117ac3c13784af4366b2f71c0b8f12aed13e598640a5d5671a2a986458e4486f2b73a5d510370cf9c703d5ba430a273846bd230a94ffba3c93ab6973700f1c377ee95473bdee05ea4b80740f26378c61280c528cc93d1c35bd38f2c2fef427fa977667dc3cf8369acece04446e9df3c444419514b2ae8a8854d874a870e7578db3c8e1e536e6d7e70e00a1ebb4f91c261c65d460cb76d011b7bbfe135579079a81ed4bdfb25b0ad63ec4e60d4c3b1c6dd63bac02f8d57794ca1490ff7cf647818b962c1a6582d898c1ce26c379ebbb7a8cbf5a3c38eacffebba4175560be6a729d666ccd53e0bc381b8b84a4540d934ee3ae9a738432c9b391c1c4785f4ef190eb6ef05e682c4c8ab778f5f0f06f5064eacd1684c0bcf53d442fa25b0598a95b5ef9a495de853cb33a14168b2e4655161447b842b17ae68101ddd47c8253a0b641a977f7bb272ba522692aba7df10c742fdb86ba6525bc037449a186194616c4b8879e5aab96cebbe066cb35936f4196b4cc37383da820ecf7b52fd3a5b71db56fa939545f61b5dd2366022dfd9e7d15a1956206448f7e460cd27526283c60d2611183844d12585106d6f160c1a9082f99822de2d86e874ef9a9edacba0118268746aee6ff30c6a3639e240f13f0d3033423ad9365b4e822fb762d843e04b70f26c44d4b7d1fdebb1cedaa7794d63549d3f6032609ccc293d30ff955f9b82988283e1f8d367cef8d1c1221bea1dfc911869bc3c7e1a4d0f5bd05defaf98a2578f36770ab09d85c8d07a17df95b52e6650423c886e46544f6b5b807435aca84ee47a01b380873eddbeba078e71c65a00e20df4e78c154408bb715013fe8a70583c2bd40d9a1f33d731c5550b11c7be78dff63021107fcd68e689ae0af7f35e9e757008702057ef53fb36c2891f87c7a6d40928560b4f4856949f616ec3d44e77cede81b43a35d7246a369f9e4b7718766901f297122192e95b62e8be4285668c2e51f4ca1c3c39d55d682473634e28f106e6590ab3d527b82dd437819a153253ec5165133ca6e06afdc3d9f98bb9708a87d9d63e633630278cf0348fdabc53ca3a7f635f263d451cb881b148032229c27556d07026780ed43f00102394739137b0d55fb1d10309af1fe955bd996598d24cdea6538f0d89ffa4c823c40d6f54b51b79ee1488f06215132ff0c141ff125be9de62f4e823d19df34205ff81c7570e95d099997cab5afb31cc7df4b3cdb1c082ec62d91361751e49beedfe685667a41b52d08eee92f8e0834f868808986192e728f1cec3dc15850cbdb93ffa20a0e08ba4f3b2cb8aa193e0b3936e485897c3a1e2b983a4cf8305f2e19be70a0537984d03dd79d7a2c936ff29a018bb7baf941de9c4ed24e08b24e68f1315e39142cc6aa7986582b175f49ff93ece99ff10b1c84defcbabcd0ddd894b0a5468cfe57b835d6b1f91e9118e698862b09cb67e1b2a58ad507cf7e78aac65b8697c82f78c492192e290bd5e45cd15457b7b20b405dc2e6a6c98989ac3548c70ed9378029d2f7ece403a56c2b39625040155109e402125ca165f5193a004d2814a04727ab12d5ae34e8d800c6ac8465d792c5c27ea4d2f1c0afa82f2fcb9b91de6482b9b1e1b788eff541949b1ce23976f7d10487398abfb093c140c4dc043e671a1e551ba0b570a0a386f52ebb3328477f330930668eb3ea4a525051b74d713c30b0a3f854ca3b7c157ec0365984a9908b0dccf2bdebfa95d7fc80d5cfccfbf25adcc967591e242d37d50c0d01dde4dc18f8b39b3d4f38282fd713fb89f19635f4a1901ff2c5384659a6f38ec07ad7c99b0b7e0f1ce09da32d8aa3a63ff6c76a17af4a0a5d6c576cdbd373e2c70a7e7c4951b56871e251c059bfa620b248544d89cc39554e957b4e49172f8493af8941100dcae93a0bbd05d4528aa406250f1155b674e05b89d234c6dfe9360e56785663cd4fadb302f976dba774a051b8ab64197b8d02cbe8290ba97150811219e8d18aed81a6f767af88e79ecef12ae9b3a5c7e0401ca2b826ed9094e13de44cade5ba07b0306244159f55a735c4ed86463c325095beeaebc0cc6e851017c9f3de6b506c72e4aa166358dd1c803ca26541958aa8181fb4bc16ba2d33b624e13b29d5ee36546df1cba9e22b5bd88f5041f29da10a32af9ed9feb90a3b99140bde61ea1520a93782922c81b3b622cce2e16d85ef88f16e6ccffa1df8b3ed2a4df2d221a376aee6d99e6746fb28c083f811b6e2df8be2fc70f66ed1580c61676098fe0ce375d8e1edbb1293924fcac497548b1f2eb2ad414975474f964e5e2c8f33ff71741a941d39a29a3a536333676e5d8cd9d5cb75a5fbbe0f36d5a23b8d3c75c0deed4799e52f87833b8312f757e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
