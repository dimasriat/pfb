<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"310f8c33610b2e243828bae66f8fe2b04c593a087f904d9cbe958b4414d7690bfc062fae15e76843eda71899f1ee8bfb8436af5c48190b71ac70882b1efb088e45cfb5648e5a65829802d4d85dba684ffa7bdc190b9df6bc37c0bb007cf0d1f5a7ebd8e5174e9352bef1e51a80e0f34ec7254111fa788545d6303c4c7a7bc35980e38fb1bd373ee2a9d144a9b7f85df6afb847033cf98313e89eff9a18135676f989c2fd456e7716674ec7b6035f9330b2fbd8a9011004ac05f878661ca6a74f2f0f7837fba42673de9d4a31c89f8fa5095f35d61bfe401da747fb88477770aa3ca70300c1e880498f81bdd7064f649e6e2b9278ebc0738dade00d32a8d80d6cc268b27d4df956feca4c3a14e1f5f7ec0b24a0c237f7c7d8dbf9dea8a95b9c7b4bb8b49d60d4d266435af87899fd3e92f53f0f6785fec7c33c1274f2dfd8a22ffb18bf3c5f576084a0af0fbc441689f37fd1e966b6fcbd14cc6c0a917e0db06e01890cb7e282dc8d1f40dc810af43983ad2bf0fadf0428e7522cdb7067af87264cd93c2a5c05d5bd79cdbfbab2e1c514273a2d3bc07577c7fd7687d77b6d3eea3d806d9dd60515fc9f62ec167919b1af810bda2114cbaab7cd11ce6bb96d96f1b5226a2782301ec58669d437af6588efaa972cef3c754af53593b80cd6b7b93fc819e0c0e5d6b2384530db4de55ecee7bb413d03054d84585c3dbfcae30d5402e2bb046269ff5432d0cf4c08ab43b75b01754a65860c14e2cf24954d4c77c21c3e8cae546858d99eca0a9607bf1a7047d2dea3766d6c07e6860162c7f99b5899320d95d2edcae037d8f785295adab2cb684fc4a3d5d25529bf4639d178fd65bb2f9fe876547bf0a3012dc2fc39d6b8b807c7ba95e5e5ac0d5b40daf1d8ce3dd9933264b97a029c7a7b0825ab5f5cc5532f7914e9fc22b36f9854d95bf9e49c55a44da8f455b5af2e307055464bb29afefc84054d6727886c503beb49fce9159b0b8e1b69dd339770c1ffc6bfe41e6633f372ce0720d35dd6019688c078344ee4edf05f967c853ed38f4dbad38848bbc44a88847abcff54f88ff5de64cc515197c7296b9ccbd716e839275037f36cc8b7483b832e74ea92055fa36a05cad79a7d44fe0e8d171909d44643d5d3724d2001e926031ba4ee8f8ca1c88adcf86efd77136703c31cb93629c6ea2311fcd9b0b699375b2a57039fe67f017ac4fa43895e8aa5812843a4de0b65ac19d94fb36ac863015f4f7c6360410fe698f6ee2e3ba560ab1a6c08809981576ba471f225041926451cc5dbf64a24cadc469a644ffe4910a5f2a314eaf9d1b7e38c92089e15e0983ecb6c5c096ebab3376bbcf772df1261a09566174e8756c526320fc5db8e3dc6fe84e70a9c6c6cc367fe0e5f0f0dfb677cb789677e047ee64c4232dd7903e7d23d8f1bb6df272fe08a23c98035092a5945e04d28ec6903f58fb7a9fbb4d1c03c8fdb42ebd5057f1153b4229c45b230cfa093b2187e45c71f30254d0f508af4b3fe91fd9c747ce775edc728fe36547c66196c20cde376bfb3bfb9d88a789aaeef9c7fd9723258fdfd6d42a248fde179a0fafdbe7765389c50daa3cdcee97cf265803ede1c1f161e34d455027a80fd831691e314e017a95aa5fb03eaf8c89a841530a3796e47f27c38f21865848e1396eaf20bec8a2c792a6d382365e31f4027d030448e2ecda972d57fda65ef808c519413f09e2628edd1fb900d59eb7bed256379b9e10775ec11dee1b230f31595ffdd2f1e009e70b38407c5164ada8dda3929e7bea5c0ea44b1b36ff9faf095d21365a10a53360a232028432a8a9b92a3f33c2b24e652feeb3504f8dca7f28adbd8f68639905ad8019fe6b03af85f7a7be66a4ac92f1ca4ede1c4a0d188458c840750213b2349dc6a473cb18b6a089724d237a5ddb5825820a5bddf2dc0a37f86b5384fd91bf5b846b7d773f5b40c1862aaeaee0765504b33915e7cfdac6b65ca46c12674197a32d89e142af65ebf52b702cd5ed93a9572b4c2761779db9760c96be977a9fb9ce731c261bd307e2f8e43754842c1ec5b2b93a9401813b83657f889c76a9fcb72d91475a0500d36b9010874f82a27e167cee1d598c9635b2ee07d21edeef146d3a4a62c4e0466e5dc006aa39fac57afaec2eaacf9e6b70fe81482dc7ec99097a48287f7ea1ff6bd473234f986f8105bb29732642bac39578c182dadcfd251b224331545a968959890ba9cfb506d116b3fc304554bd11e758771b80b0260971016fce70df2a149db851d9dd210b233f48988498934d887bb3c6edccf98ef7afdc1e16d2c0db98072338543f6bb94fe380c0bbace719cd0476678c814d3de8e3fe8f8825acbfc209b60cb207964df97031197d647bd23db3161c83d4989d7eb3b3667b18e16389f33de18c214a5b565c37daee78ac44e71a47dd3fc8ade1fdd5026893902a99255a548c4712127f5bb4aeb0c3cfadb31ccdfc4dec3f46ab00c30bd0089136f6471f911f4063fb364a0bfb0f07d6136e459db11d794ba61d1fca0c289f9e3a3d81c12b120bf3c4455ac7169b5c240026bc921a95339a4a2cb2446be3f0a641d2bf357e7c7c7779f625993281587d7ed3ac2892ceaf0c7e2b6f2afb677485941173aebb1dd85a20d0440e42cd09fe6289da65e415576e979ef6e5a5dc427830d1e6244d3d1e510c8eae83a9ebeb573c95b8160a58a89c6105ed90a006e77f0ed41b43602f448e8ad090f7d0f45afe872f665c529ab25cb07eb2c4c7ba02fa5006a8f16c03b54f5fe9be97d77dce9393b4ef0f75745ba4611e59fe2ef9df88d8311f18eda9651e0fee6845340d966cd926df638ab7107139bf6f9a7a04951be3fe2a0454c5c876cef86ded05ebeb4b73ec09f45e7769b23d5e163bafa0cf95f3ad105e7a52ad26135598f3d643ef6f5adb9aa9d6c888c25cb7f8091d48b0efceab7e09a39c9f3c72a03cd62ec96f43c53b139092f3b7aac76fa780478060431e60c7a6c2d4b6659d17e85e49b8f48449e8f76876d160abc5dd288ef1a54cbc6f452b15de7addc09ce36e46f162824ec3407ce1e9cca01cfbf5425c89bd03de6caa7cd710059a6c0edbae8891ac2474fc94d0e4f7b279bb30c47ded460dd329cc767b3fe580ab37dc11e17e51512d35bfe7f92d043bf1a982ec8083fbe64559ea54372ab7e638c87de7517064ed3e62bf0c8ef3f5241c49c8180c58be4fb10a60af6f0e77c6169cc33f0187b8626a31bf7bc5ea710932cd4ad70732ac4d85685ccb0c27c7746c4bc2a3376674c01f6eff3400dd869e510937035b1724f319f4c3567cfd0a182111744f429944a8113b0771a359d69198bdb7c8d538009584a84fb0988c7046a9f410f391c47e35d999449cb1343f950e3b20caa26fa0d17899a24161bc49d0e1ef75bb4903cb4ea6d3e47bdf90875174b6b01d2d90189eea5db556042248cbcea80c07ecb2bb8d044d021e38cae9f2c1aebb580eae57671cd1c5ffe0bf6bec1ff6b5b6e281cbe319726fa20f899b729c7952f2128a049c4d329b462ddd858eb499f66844afe030d61616a7d0943e9b20f260826d833628bf0c44d41cf45566c53e15e302dd5a071915df2b7f636cba20ee20f06b40faa1ac0695005eb6bec09c867f10890b590a8dc5bc9692021596466701ad5eb08d8d80e761a1e20c07c99cfe14927a10752ee83ec9848da542ca3ae48e2c848bde4fd423d7dab3f8227d33bb85630eeb65513ee4b1651d5d236e8cf3558139b74972ad85a0f5509590e03cb832ae11715a413b5741e64776fa5931b13c93f5e776a894e1471e85cc5c172d3fa6b9d940cc8d8bf815479622eca3f3687e015397cce2c5019a92c5ae939d42d3a69ad4fab47c1743da79bf132f6e839226733b0a739467d48d4637716e29fdf50ed7d9b05785e1d2f5653c0dde474c3e6bc121dbc18cc1815e42b2bc289d543951875d0f83948922b0c686f2a33f120249ab972207f8455101a06a6a0040a835bca1306bd8b9828a067664c659e71989e33c56ba269cee02d255af1e3e0e76135cda0c2920e96f1391370ee02248052be62037701c6f5d79227e18904732cf28f6f0090d9ffbaeb1ceae09d4e0ab0e4eb37c95d4b80f4bdde3af7622807fcfe1e415019adffe27bb0711e5a41e911dd1ba499060df82a95631caf28d9ae1221ec31bfe827f50db941edefc4d2a05374e4058de5d75bb1957ad301ba1a3030735549bbe031c6324701dcbd5eea2f4352df6c0721593e4c460e1054fd2d378f3ffbb4acdcca402135b160d6a55781edfa33e2eeae4086035c8567b24550dce9491b70258ee76414fb585744c5915b1c8ed11690d00ec20febd345256fad0404f1451736578961d656fa3016b6bc1e7b21f339d8565bb589e74e99a646726a27d272ff3c731c15c10e5e7018d4e06ee7b8270f73aa3193e65236831b190c4812f9294dd2a61137ae162c912560f490ed55a245874594a0df9877a5a56f642d409adb65e7ea9cb0e25d95716159ab57e4a6e72c33c5083168e22aacc0e4267006c3072af453e89a3ec580a59bef59d56e92829c87504d67e8f8e2f6670e63b6433668650b039186f15ce9c258c81c2b12a0b78b8aa774cc68e1014c8f8ea3d4b54c5a3eece1daacf92fae55fba2afc262dcc25d8293f90ea01650d9867465b4354aaccd8c4f6fcaa14214c6c375247fb6aea395e5cf217a325d19cc6fa412334f841194bae6a6455089b4156f09b12da8f9919183f3b9223463b652d9e0f05c0b6cd4a124ea766e8a80c05c7f563845314dabfb82420fc9fda5f875ab82c2c99979831cad3c071d5826b974d50f3f973642039333af025320958e52f01057a728898b499327675e475bbeb2f8a6088428b26256c7f4e7d44cc2a450117cd893cdc3d2efa982a5cc6289cd86f191a2dc74e441c6bff763fe3ad19afd520aa4b09b579e2381a81a978dd4fa7d49d0d261c81ae6cd140d714aafc11d2370dca46743b6e31d37452f3f43dd4e42de64469b34e423a92128a5c4b600ca912c8a031f8a7ecc75fbe440b011fbd9646ffcd86de82f1df9dab8d9793ff0b6f53eab3b68e61670688e4f85296f6fd338a4413b38561186e151517006f47c8f59f23356cd1cc8035a0bff19815b9b1c2af3d5d41ddc53ee96a4a94c5d3148fb59ec6f2966bd3c89695252ec439348e33eeabd48fa0c15d03758151aa0ffe94fc8660f9cc07b111860558aa6db7061bc9abf10ef49cc3f301b429cbd01d7cf5510fa96102de96ac900f65c685791f758d61b38f930c5d613343d295e0830f98eed887cda87af7ce27cf5e82906e7830e375f9b6c80784411c228caf3c0fbb50241cf5feed1ad8934c60e12cf447393e3b61f3970f8a5915ed500ddfddfe1364c5ee0deca319596a29826de870f25df7f8f9de40e27d1aadc75542b1bd5d4dc56dd4f28641dd6bc415740d3e684ffc48f21d19e3f13a2add320bd4a1993f91b2ca38e5bc4a1bbe58869786fdfde55c168c879af93a7670f7da50a33be377106f6abb6d532a48e9135d4b32a8f6c4142f74515fcce8440824bdadeab3d8168f20239bedd931585c560f489851366e1637237cc7a3b41132c5745425e1e25894b3243cb486c54746b3ac2f2149390d1fb8514e2278475762920bfc6cb9d91a79057d3615b7b976caf450b779b135d66cf93cbcffa34e57ffa65962dfc27e13ebaa6a6c3384920ee0ffa6574fb7f66b338efe1c6513df440e72fd9c3e3c11106c672b64318413d09b3ccbd515ae6b21025ab7ed6c9bbb27df53f43975a4642f211417d584640c46d2ebeff3ba07074d544d15dcad2120d6439ba9f0aa2a02ce50ad1a08b37ce1c67ed68a673f649d7b215ad96e36cbeb607dee919a8da7644bf4a6d91a33aabbdaf49c6c8cd668c7d70af3a357c4cc7a21092804983760e69b6c98bbb509dad119a816485dc7d3f48c8da0741ef6851149362a8ed713bf0727d0dc674e4ee04c7c4acabd18f9575d613ec1d5be22f0fdf4aa7b8509e2f587468802decbdca642f2522433c219ca3e10c7ec5dc61c19c951827bd088260e32f402a610f89045bbe618b85d1a9bfea520c1f78b2cb9127be150651ce76991c89f067456b1809a026d00e0e46c5801c0d7c691a90d7108889781b82f2cda8475ff6c88298148823e0bc8c221ac66b8aec24f501a2a4f1fcfaced08e6d87a3a8a2e0b7d4896c043337e9f72e69e614b27b574bfb9d0269d598c25601402e767fef464aefb49f813c3d8df3b78b189fc35bf45338e4926c9afab2ad13d9b23ec55f7d3d8495c329d3deb164045b2e579907f3d4a90d21db05c1239f9f1a575b8170002b33d9ae16a7e5e29fd9290e95d7f60534e55fbd0b631baa496793efe035d49645a2b1e0732d09285fb68573551f165eecc21687b014f847ca90096d8f6a209cdf45c8fa6d6c116ed7a312083e12bbe232aa25142f6c3201dc33f542a1f333aafcfba37571c236992b4184edf651cfb302cf15294d37cff4ea48ba8a1785f335173a463b6379440fc7853e008765b6c242e4c6484c322d25901798a215a64274504c611f2a6275c97e118f55f6b6ad9f26dfab827db4156894414bf07e0b99c66c84b62046ccf23bf879b22742373f000150efac230adf4c9160039f67fdace3ebcf65a9ce2652821b8a3951e3fb975ac5363f811f1b449ae416134403995043ba081f723a0e551ba6c87764c9d85d7e9f8e117fd45795a77a62f44bee2e47aae5f06760f5c798838b4e5842a17eb045eedee8a26bc7e842defcc5e3f0f9601a24fa9787183d62be8025cddb49fb4fe503f2745eb99a214c9521dad1d91e831859b3bfbcbe10d1c45c520dd786e481796075dedd4f3890b026e0cbd8a5052e11fda7fee8557e938ca5d9cf5c26d4b6f4bd44a50605f8948062069c230a80ec8c0474843353dbc9a88862b895af9c3df695515b8329a489ea19504a1e32d7967bfbe4e89c3996c0647e2a1299c0f4c02172c795a7b0fee6ddf6a55e65cd041586a52349c460abcfd752fc11635e083c3859c9fa983b5832f248b5203eb98d6102b850953759b53d383c830da3ca6328619dd3ce0683bcd83d04fe2aac93b3fb29ba1e632f62cbc930e5973a3976bf4eb588b5f8912ce9326657d7f7d11a1ddad507016aa6988a22be93765883e4740d3bf765ed9e2dbc26f0f3af4b38e4897801288f589d2a9322bf734269d2023ae53bb30d2f082a6e85058f8793c77f284732cf3bcb8f1b4394c0f4a5ead680339a64a60f5bc51cf276a70b679c169c5ef441fef783a9cebcc77f4451214356afe12e393c4d77ef8262bea617c566a915a68eff89bc9d2e3effb61a1800ab98931eddbd29e2c1348add0efef7419a31999ec00c291f9b2e84baaf96d421113c377db60a9363019a89eb37322412c3bd275bdb4fe5c57f9ba4ddd61a14bd7d37bbf59190faa148d17542f20f211dc1a68a6eb00daafeb67bb1c35621c40ce1a5cb8535d8ce3be674977140f0c4dc32aa1ea83d3fbee8182626e60fe463196a3d3572e2942ea5854a3b5b8608ba8109396d482ba2357800f2cba6cde0a9d0512b08e63ec84d1a9e45d51adf6996613593afee62f990697ca63a74046637306ad6c1e265dc20b8fd1927b987a149a197699abb1084da8aa5003101a49b42989896ce1293ae737e25d9f4a08ae539d9faef1d21e0b478308e1cfb81b22402191578bece31f191d5b86c2564369e5b5dac8ae50266a538440b84e400f2d297ca47e422413aa94c3a048da15180f8c619fd5ecf6999f9584476dfb8d485ad4fd321ab4eb970751771bd448e523e4842bdf05dcad705e3afec87af90bb115be231994270d890a260f02dc35c748e9cc9ad23fcb71d3ff7f99860121bf94489bbbdad0618ff051b4b58e6ed0e98a5898b42bcc54617c171ca46e6f74e958d765586c4b5110734559a58646c6426bb9b66090dab4871a3712ec1f52fafa661e2d940f1def7df10a40fb34abd8b8c7547e82091d8d1cd88bea129e826ab51ac1ebdd6502254bb698b95256cff40f2812ce78cd9d832ab7ec09722aa696fb3033c7db9654d841604b257c93f5a873c083ade090ef7bd441eabc81cae5ab84f9e6cc14055b01d8da6f5578853a8f09ac19f15de7a5b8f605c5db7335606770b68975339f585cfac2f296db6af5e98cb5206a4caf148907b0a8eb73b2e5d6e7a88a33676921b613c05774936c4d69e56c6d81b48d13e368f92bfc2798c0546fd82e7b2cbc8e3c6999ba66c7cc95166f423498928aa7614ab97d7fc8fb492bea96ebf7e49b2572015df553fb10fb1df575998553474be3aa6f952e6065348dce32c88ed7679390b26add6e756c37470f5ad1499907cf2ef6f4247d049e2d99da7ede431eee26d8929daf826d47ae23e210593abb39bd2561df91a782afb2573a8bf8bad642897e9f017e2bc6de1ffe79d4dc4ae819aab9945fec6dee5b4c6fd2b0fb0d1e474182986227b14852a3f37ba8228593abfcd276f2021d4807031ba8ef50612086b4eb6939c79491554eafbf774780fc4b84ea4fe3c79c7ce76f1a3a479049f3f47349282a8cbf40c9ddc6520e14082ffe478576d538772c33d8c28c98fc5519f2b54b347bffdb444b3c67bc0a6eaedd98a583fe6c50d4ddcf5451df46d59586c2ff9012ceaecbb86614e124f00ad4823eca46f7bf00b98d9d3471e9728116c24bd2a796e399799335216da8d4c309c3fd6323a2d6fd9ac545fe3fd1244dccd9a0fcf0d8e52ea9b8453e45a8be476c9e9e0f3b478d0b574d0c3399569da99058c5e833bc9ff3a8aa53f8eb36969e71f9e3f30f36ef38828b3e0c879642281d70a93c16ebda29b026511c553cad42c20874ffdcda30f508a902fe7ebfedc60092497af14ed907cf46ba7640f0443f1ec85284e3da12ec903c6c1bb9f09a0b13bce0d551e8a552ff35e77cc9714c5dcc225199d1b0af5e302f6eac2d5a560bd4dc535ea2bc48438e4aabd261aea010772ca489fe4f2c93f01e65cc0ba4eb033979ec1dfd0b4086c289681c829878b346bf25906d7c5370a4fb4b284a9bcd6a38be6e25629d287d75954ce023581be84a0836dec541b6f0d0c388064a2338d0b005a2b28b0c6c4081ff5b32846421312080ff2ae58825cdd6e3b4c14ba1a684b05f1984538d7c68732e71b686f92848ea03bab562b1834df2f6359efc7632f0ed787b8a234e1c85e15abeb8ef8cd939154236a702c8da23d4a130f1ab7ac01c83e962717d659c7365da223a55f2da7c7ddcd41cc9bbeae43c1e1998659d0b0473aafc2dc26832f49616e3f8f265ca9fdf11119ece52691b6ae26f99cac524f3f7d64063b36a17d7b5dfee1bcad36ac79bc63b2f4181afadb2c4e4ec81438505df7eda19016a6b78739d1abe104c5bf315b1bfcc9cf8a6ec072dd19935574b0d58365876a8f9bb651e96827f7a10e6be63b930f93bfb64c0d5fe2dbef9ff4bb83f7401ea7f07edaaaaa61e58ae90f497bf51e9a150abec561748c7c5545e21a8a653bb17680ba21bc4a74161ce3ecad9dc22d19bc7e8f1abff420b1e29a80e940f5a89cf1611dffd52e296d11b0e5e9193376c94f6c1701213ea105330066350140cd1de7a47d3caa37f6d78319541f1e10d301c4203dc13686d6b7ba7cc8e013d35aefa1a9e62931b11ad8103db231c0dcfea9ca00d5cb2b65e86efe1d8670f005e9a50a776901ee93fa174cb1f44ba9ee47bd1e0215303093a8b6a33182a5e2a9632394879cd02dd1d20bf6aa59ac60c9d12f146530a2fefd278931d2381dbe91747f8228453e484d7df94716655f19a4de772951f40c592b2a88197c79484b17de1c4aebd9bec429c572fe3321f39722a3ef7f6cba4cdaf9b3bdf8a137f25ccd3c99f67e4929d0cda2602e27f42bc823ccbf439ffe426ccf23b6dce1b9ad47516a4384c613d3de2440111bce3ca1b2e32e4ff76e6c2f16869e33ac9af332769507ecd140b2e121fe69d763303a2c520e4af92750dc101a40f717550ed9d561757251eec93c0d13937fbf4c23b97aebff5f06f1e7f103452e0e8378840c85cdea795415b048c8e2ac19f1bbefe0deb0c5445e8a2a8e47e72e0b0f94d7f9628e6904aafbba2dfa6d531e623b6624c17e7faeb94447cc2f8af80cfbf5ecfef423a715c24ff1c1ed4e58e1103395c8fb3142555ef6c0eb69a9a1a355c332ff40c9b84bd333755289601e732bb4e98cde521b2aff91323055e4d383913425a589b3866e908388056b340f08df98b3ccfc6d4586796b51b04c65718157e2ee4fcab1d8996c28795b2686101708d896cccb90ca7ac4f077a57e35c1bac65ae96665eab81d2a512c655d46ddf7dfb5c22e83d395d801c86a14f041e648e3a2f72db3bec4b5104b3d835609bcc9009b45af99bc11cce10b53b33057245e39db50370b695fcb5c78d617fbe6ef53e06de478a1b95fc1ce08ab90bed0202ff669c4f56554e5b6b7878c282edbcf905c0562ba8ecc2667efad26874e90e6379b137f3162df0ba26c99e4d65d313df5aa2ce847227b086e73cf930703b3337bf27e5088c6c504f6e6f2ac36b120f46908ce9bffbbe3556f94714c6c9687f11a410efd69614369998f30f9251536b74f8468a81eb9aa75032c1b38e12d75d78ac46f51034c529605c35305403d8bb48ebc5a217ab4170e8271f6cea27c1f909eff6ac39f50c24468cb1730de8121c60a4ad217cbf6346ef4312b305d4ce8482838177f451c3c070950b57df4f5ad6a4217a375be67a5ebe7e4369ef508ae6b6502d8fb66051ab500cc62f18e5e42df2632c7cffe2e33b50d6d20c27f961b4a7c5c46bff648ec658ed825882502b990433f9e9be450c4dcb749151a003ddbe150f051faf9e9f5d15881faf3427d5c536008b7681a3ba94b46e1c1fdd68a751e26fe5db2509778a34168492e75867697d3ea0b1f01482145c9bc93e1633a3afcdaf302747a815f5e565574a8d19b56cbc33809234b748d0893cae97745e6e468379fafff0532cf0828ac71cc275ff2dcb23ed91ce7f0b34c0ef40e7bfa414b7ec2b870e94c39cced5d482a5d3d7975b9cdc0ce1bc064f23d7ee3d90893df947d0ca5f418a13cc9974f2da076a8c5462c54afcc35b2e61638ccff293deca352bff03a5e57bd438ee3a9ea2c9cd0d71b9635845bb2823667510065f85c49368136cf20c2c511f48ad44f21092edd09968de6906a11f92179e73bb0dd75ca200976acbe0ed599d67b1abc771281fca4253b395f302eda2aea844f0e63414afb2f44f3ab9f08df80bf71aae524170d5fda3f9a4e9c45f7ca6f2aecc8d406016438b821821b108c2354d5f2ff3e6802671ddfd7dfc0ace258f61486a579b59666bc87102a09683aa15a50238eadd4efcca2c95187e3ff34bd7ef1ae5264194ceadd8acec6dbbc2bba33a06bd26e6b0490b7e562daa77fae9e3b6e6944f267273acd1d0f54a70105c6d4df84a5a850f87fddc0917cbb98602e5edf746ca0d5d19a2983a185beff7ecda8ed508fec5b54ed2855612ac5941b3f808e3bc89a974c6eb0f23be0eab7757b9679a66e8ecb13224a519e076f17df6679ae7383a45eb9a2923f0de2e38eadfa567d407c3f7b729e2f42cac11a08ed5ca0dbb627c2a10c43097e3050f2f6ab28a8112e639f37a1547d9c183c040c9944086e9cd59d93ebbbe27092ff5b8a0bdb7a3a2f260281943f1158badc73cf45cf4aa88e7d1dc68f4c57c7dbb9347c97a1093f25d68129f86acf2e1d1ff1f67d77e5e6149b82b54947c74148fbcb0200f7828766c0517c725b47cf437237ec63ce660163aaf5651767390008484c24be67e21fbc26f5f67b117e47eebbc26bfd207362e1455c30e6a06cec01472cae961bf415fe64d8d3dbb9dd40c4b81dbeb6b7034f6d08edf2c6aeb110746c9eaf8ff227d6c8e62fc15581c95e70ccfb42fa234380a340a733d6d2c324db7d86e21669899704f875ae1fd3a4a78fa9088ee393cd29d491a4a5747a5f30e7a20c3e93749dcdc7b647a2c52dca48f138c6e2a085e2479d1400fa346d62bd1f106f4df61a869cda63c9b97dc41e0989cd4b30cd67ed6bfb1cbebf3fe04ed61d19ea6caa41734aaa6493f4e1ff311a3f00fc3bcefd1ced0eae701aad383ced7d89ed023bd46571a192887429812e90abcc083b17010cbebe7272e12f382f4155416fe07274f0225b0e1cc733ecf3b10346cc17634e62f3fa811f982fa6b498eb4824482847f5536f7d3b4501d8c405839650b2c104de81c1bc3963bd6f210c571c8f8c30b86c041554d7c25c0e28803e603562b664551261a6df9867fa5a5b55ed75167ceea1eda9a591e2c1e41c9a5dacf472c9d2d44931bc35eb75f10fc763cea7963979f4d82b4f8637b3bb83a3e4243167391aa18eca58fa78949430f13423cb87f01d93960bf91ad91d4f494ebec1009f43db07e400ed560c6fbb922c33b0ed24eaa99de55adb90f9ee28fa98fa6bdde7c1cae5aada30eb03475a5f5a1b0029c4717efb7d8ac0ca8fe65f2360b89a3ea1305b07c19481e9d031b4df1f539e9705390e8eea5b67bff2cf9b69102f841850e93dc6ae1a8f1f1e146d94647798cee61f33a73284f89e03e9071069571e64d4f81b1e57f0ef6a5693274c2f173a9401a44fabf0b0df4e9d71c4ed3740dfc300385dfd646358a514db618cd2fe3887302547157d9792da6031b4ba8c9648b74a6f626248ac2c22ecaa82fb90b84c41ceebeb7c122fb87ea4a3f3afb9029f714629c303a208effd13f85e46373342719cc223533fb064ebb5dfeeb53cb52ffc2e3c0201435bdb8d10279010ba3e00eef47142a437c2f0caf9643ca89e67992e0fc0ff3c0ee4fb4b57688af595d4077119c56bf74028de58fa082214243f78ee6a3d6c3fc8d3c20a5f5c267f74fe9a1577850812b04bb18f20c53502462bfdb936604e857b5047dd198ab27aab5b0c0d4fe5c10a256b0f1eaa510a7013c30c1bfabf3bafee9a69994ec84fb16c822fb5fca400d6ac1966261391883ce2e7add78ded5759dfc5090dc4c1319c457800dc41cc0d4d56e167b46e455d30126c496c0c5a506a161d6499fcf351d117e0621225f4b07f9e59eb9038724436c44eabc419d0ad3c2a2e5193af598ec079e6c32e6232fcd71238c27bb9f3b41ce7bc4c5dba4f84eeca71a4dda1f12004154fccdcc7904e98ed845e1a40ae3bc5f73304c271ae28e581a3a6bc315b6ede7f36a059464284b36075186f2f0bc5bad3440937f5256cf5fbc44f2bfe01862b039a09334019cd02f60ffc01caa4b52a4c9245ba20c93353e1d9eddc8aa65b845e59000f1f51a229969aedbada43e7ed37c472db9f07bb7f97fd8f647db2a43a3f845d944b4a2acde41871dbeabbb4ca1693dfbfee633c9f26c70c2e83bbf680844feab95d1a1a00bbcfe07352b357df4e18d9e166d1ab10a60d69ac132d0de1bbc6715dbd8f7105033a9bbf503a047396c49c8852bccf874f7116e49a5636d5addb9bcf4ca156ab84f1aaa345e0413fa31ec3b7f26ff8c426827f4ee733b464ea5d9dc52a86f172fcaf5af5e09e71b230e39a42b6fa452eb4353fd733d7b210b9f1375b2bd7a07ae11995f64f1ff3b3ffa234cd9698c5e22c9cc7aab5d9467a0d91fb9152a549ced1ac7d52e49b05f37c9110bc0e54c70ddf46223c47f5d6baf495c05c8883eb52bb682702d9c3a00bfa973524134eae4998d5cd4c56756d057f2770b408daf30db29d017053c99a6c5c817da76c9155d6efabac1c454c5809d2725cd7c8197e2a040af9262a6113acb4a67ecc5f8cae73daa5916d619f8b58ba1894153106c35e897de2066b01fddf4ac4855dd38a182ec42c52c0ef4364d323249532dc6bacb18f0b2608b280a970f802ad6841c4c3b728d251e7fc8aa346428337d00185540bda8667ffa7c88567a4351575f1798f547130918cb4c357df64bd66d5a43be10f9080a4c1ecb35e12c10b18c8aca1f95784b60064a4d09418a67d85aa684132f995fc5cdafdde941a736890ff87e099819cd3a8d065414cfe06fa3a16e412687f1626dc40bdf856b077e1d7f4f56fce59d2450e9edc3dc22ac7d45fb968f6dee70c80b3872d2e8db86dc261feb6df95d4f02fc770e8a5953d508bbff36424ae14167f7932b396fd872e82ce3eb83f4788a5dadfedbb715f3c9aea86de1ff78ecd55a4492088264af45be05fb5dc25126b7bcdf53f7ad73ebedcf37bf67b93a3c691015dfe35efc5b3406366b1475733e716533cbeb07c622361d72583f446298aba2a0c4d4222118f3a2d42ed93418b8ca8","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
