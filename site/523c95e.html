<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50ec28a50acae5bf0b277c7c6a57b39f93a42d80eabcf585d6dfb3a42bd8432e332af9d3af23e43f6488c811d5fae5b77ad08571c87c8f3e4d6c92d4ba03c5f01b8247c2e715de7a709d5217b4f263872575b42efebb53d27a5e4b3667d248161633659a28f6d6bc6d340913dec7f258bb085bcb47f0c45a6c3f2085eb784b48533222e2481f38cd4a52faf1563ef8fefe5690bb23c4c0e80203c4290e61d74d75fb482d172e090beb708fa542acb143841d7401cd285eb9727565c775f676dce761fb815bc7d6659b7d0389a7a4cb16436da724b7eab3004c3314b50310c536440de878215df3bd90444770823530098057240e9a35027f7ee6e6ded1c0f2012e220f9c922a3f1f7d4dbbd12374d3f673fac4c45687d206135cfc26e85877a672740fa172eaaf10e6668b8c3d614bab593722ccbdc4d59b510e42fb9cc4c35804047c73ecdc0c2d9cfba0b51e74e46a693c6e21946ed97431264001f59fa415d9a2d910444f7bf67477c994e520fa0b22a13a76ccbc7502c31c594aef537932aca0871d1e6ec729384af9757b4c42cde5bd0f66d82fd0b659982a7212c802c99d8e2a6fd191d10d93a064204d770025a9a93970f72fe46d06c143e7bed4a5907e29da6d6ac06b649f2ff7fcf651e1a2e814493c753369a559de03b870bc92b1b2d3e25ece8ede70c45a1c331506215b1cb30f1fc4fbacec07a1dd5d96fc2b9603cd84c54ffa29d65c26b2ad1d7a2b40fbbe0a0a8d78b61613a90e887099337319504d061f497b05d636a8b27a8933453fd71ec2d9e614ca40eb7470c1bee254dcb3dd56114ac4bb6cd882bdcc2456f06ff04ba0ecb9b4016e4fa60ee7b29148b2a11f7987d1d57f203ec9d02bee7f0bb7360eb61ea6fcf719bfdf26d62437811b814d84ac9758472687a8de65055864685c0a03978185ed1f960e760728bea7787a7da09c6dfea981397b58e98d665758a06d99f9a402fb8282c9c57aae17ebfdb657bbcfa45b32a4c3556a256085efdf3a8883d564b138df34486d7f98f339feb51f5a4ebfb92be345705abf7c9d6d37cc6e5da56ee38b880955c29cf57723c7c0cd2e4b96fdad8950a82665081ec562ebcba5505e7c925d887c3d5083e0132d0c9d6d0f17e02e84fa8faab32394c0d13986e26b6e8c1ef8771232b87cceae2dcd1e0efa925abc7a13a8afd8457a37d330ae8583ee163a6137722acb2a59e13e840c4b8e1972e473d833cf2c1cd827d230df7c014cc12b37955411e76d85ce415c7ae70882a6182b31147dc781d6c029ba83ba7e35440967bf889e4a100a30b00bba85c40bfe542e92536288a396629d015e2c4cc43e1d48b1d25b1e3720fd5cb13ca3b79cc6f5f5f5548c88902eaf8296224943d9a69fe2d8e18bee21225c90db7832d037dc077ad3a566d51ea6e320cc0214ef02120f62fd0ee310052eae55ff8d76d8af574655f8822a628d832103a081f588308fed10d6ea4f4e9c719609f565ef9ab546d91dc75a9d003cc9ac8c41bd4b46bf13ca175b99fd7e2e94e4694b7d51519d769d251256cdd5753164ef76f911ee7f90447bd1d29e2ea888657f7e78732db438b8e226dee3c98c7db697ce5a442f1446b061fa6555fc0f65351b00512b10af0adbfd07023b527d1b63eb9e30450bd1dd6cb242cab9a512e8d4f08bbc6e3827bfff70c5ebe5bc334d952af3aafdef14f045cf33d19e22d08493c2aa88addfcff6ce6537bd0f5baae57ff0175632890491643d7a052c3c6cc560418246686e0c9eb2ea75aca63dfdd37cc3e6dc1058cfddb472b100dc01549769780fe367cc564f1f616f66d2ee43834437e338e04d422bb49da7436bc998831eae702d494c2269ec91b5cffa2a88163dabe7f8f24c732f06a7560659c7e999549fb2943b1fa2ed308c04421a34964646e0a779c9a5db62e6fd408db5ab12c31f3330ea57dd784d264cd47e28eacbbb503e4a5fd519f2486d917830ba430045640697b9addcb622b0447582d506ee44167ef7b66bba136594a61b5db304414f58c78eabc67eb79e6ed1828a09c0c2e53c76509f504f18f112da2bdc9c09015df69a81d4a35a5aeab6f641f6c7eaaaf0e19d83a3be13d8f2a7ba45d87d026dd831fa7bd3339aaedab69dec70a9cee0939aea0987a538e1bb84e8f4d1dcbc62276d2eca214ffa6071cac38d2d3ae2eac6fe3808c428c23ea4473caca88a0476965587e8c0b2146a63603993c3790e96a2ebeafb290152548f3d9dd857d68922060ce71b8193bb8e8efc7c20b697156e68bfa7f374364526a192a5a53f2b90a1f0768eb0db0fac6b507d9d965b08adf0a62723047177b6c70da5b029115bf50b34f90c79cfbf5e2639092fda2b1aa51c7206eff415733581a960e624a81615e30f4b9ea1c1ca09825908a78ebb20b177e87780dbb5f82fe1d9253b03cd10ae22c0ce547688327962f0bc0306bc525104166cd650e780c70b02dddb4403fc1880371c368b89cb6227ba3c777c58dd749f1ea3f595414a368d272e20c6998fe1dca76dd322e6c8e8a3b1c71d85e00af1ca94c0d785604950a50d8dc4670e4fca440b475c87d4f61668f270e15fd781ad5784b8e65bd45c71852f7b80fa672a0a5322fc2f0bd187605d12b0201f5675bd93a1d4611f84b898417b8a88d12f0711dc93df0166600b38b358fa8a80bd3c566bf1f201a99295782509cec371cf10cc6868856de2b4e375ee071bfcbc985e42cce0e16910017840ffeeba7738e9eb1526cddce181f3c3692afbfeac4dbff498a5c22e70a4355b64e3692da42a4e88aa027444cb3b9cd800906a02c21fb0bac28106eba21205a4c3e5815e3813abb5014c29606aa06bed398323c9e0774981967896d24928f8b292d7fc0efeed7019090a3abb720bafd10316c5da7a676bb905c691677d4e81126c1ffa1fd4d5f9532fc5932a6a1d4fe6be84f887ba5ff641f84f861841c80433761f090a0fbd93afd384ac57ea9b6e722dda04b0a5a88b56536b73437bc33ead453feb1c75db0a9972fa724095bbececc50e27350b370221741e9a45e716579e1d1b0729f88b7d3e8bf35186b3fc638ff458e5a7918ed2f1898b6e197027d19a4a5f953b7686322b102a0e6c0f618d669a47b3ec5dd65a8b74277cb6d4ec525986e238aac2c5ad2024ffa28e123f9a75a8e8b22ce4c1d6149632a728a3870b3585c0314cd9f7da9c98ac01da80de78c91bd6b2a755ee43dd33fb67eaf4a57d4ce12864c9f088bcf61e41eea1692782fcf50b3ab4a30fd192d49977d6917d5aeeede8a6d945934873f6f0149cfb178ee7c37362a1a493109ab68ef5291e387b13662f6cf7eee7f907b5030bdc057cb1d797b6ed1cb5a0a6245e09d1790e56154caeae34a4bc2f65726fb92b00a9f4a14cbd6a3c4f769bfb3a47299d9e5618eb70baae558876ad01b4e98aaf1e51a695abb17f88364e4c656140d8dbad74d2744016e6d0a39f8f4ef5711cb9fdc33d9d31e74131c55201fe5313e3b2be675a82bbd0e174b7fcc7ade671e9b4988fd38b86c3daa90d486a899e5eb2a226bea977b4812d5e0f68f4757c58229873e201bc7b62b925ef1396c90ba12afc293040b32ad9a54c59a2482aebb8bf24ebff3bb75941c530edb3a1d52d111691b0bc39e292d935d0573ffba883dc9313a23a6ab5c8ce298a34d16987c0243e459483eecfc458746152f4a7b9761d68a2c16d2070634ea9628602c8e9dfd2a47484f68a1427b1923061a2b4ef0a124afa2af0cf9764a5e0377f9e7effeb3accde09da0e1c23aea11e4cff4edcef636767ca43f872b4ad2af675e4c5853a974b7ace2ed10fde8c8d3f686e96ea13c2aa653825ff043eee4fa05f9b0409b0e9331d00c2bb218b2a9f1cccf85fe17a02e82129b394670cc36a64ebd9a5ae084da09dd94b3bed8f8c3716984f6446d5a73b80fe70f74c7d7dfefc81369e438adfb99030b9a10427576f4981b36fc5d02e2570f3dcce998af480c2c9dfb619f0fc688b5a5e4a656a5a1443ae6764b2f128b7a4fd9940faf92749ed12a3367e0e8b5b9bdd02efc89568167e126b89944800164129442dd5699e53d38742b44c3e5e576dff019359fc1f744c7c5a4702e963905af7d037cc5a96182efc7dbbc51346b4e07af48f9c7d0bc7f1d7b1c7d2764d0be8b9b1bbf40ca235471c9edd2c81aee9a1ada87a00958a1f539673774724285ac08732f4693f2a238fe5fd756d79b584c58d28cfbf91da9f06fa8b29e5adefdd3f07ebc5218105c9de888d4b1f803ec1f1850cabd9b64734b8a4b6286727913a1b9f96dfb2bb7a67e0549072aaa1ba1ef8001c0ab60a04ef8fe3b742cf7ed536ad8f8696baa08b4841a7288aee39167dc673dbc7fc344e6aa3459a42e55d9244fecac21a99b92fe5d952a1079214bc2336d9127f2ca008c9b066b1d5389133c639ac5ee75bf0aff7514a9ec177a2ae2d17805337a3931d65dd156f85cd807085a02cb62afd4447745186435b91abdb36df663fdb2a3f70f12501e3c92a06b7ca75a78c31115892dcb7e2d19e0f7e384a787f80b40d0ab4a32b4b0b6edcd758366c28ba4b60bf24d5242c227b90f4d1851d49a2b21ff29ce11b2b5150f6866dea1d5091e335c861f5c762933b955c5523e3af441d0ada299bb179777ea1b6a4ff93146f2a8cac5468c394002a8ed9543bc5cca543686bfba24c4f55c3678ffe7d81b1f1408ed5557e50bdd3a3f58fdd97ed2651f39d299fca4d55773799d83926a27bba9acf138aafa64c5c57d268db1bfca1bb2acc09d8c13c6d1c8660aa5b742bac49cb65e2122a7783cbd6f121c909a1dde3c5b551de0f00c64b6813378f2a2dc6e563cf3053dfe134c374152abf6e85cba13d5905c75ec7b58a0d9842cfdaab196651d14a5dd42d55fe87959f87131c7b18038f83736556a20d0ec8fc517e74c6a7334568cba5c4c585d110abef7385afe40716da460ed53a5ea874497116240eb633612301dc6bc2d6427c42e573f3fabc3511e1ee6e5cd16baf1f16451ec2a51f11b0c3469228f81264ddd82b16008362614787c0d3cc83c766584cbd49875875b0b128d14321a4cffcd2108f1903ed51ecab51f57d00d2c09a65955b6de4e552d9baae7b5a886268ec712c046b58b9bc3dcf6ef693ff7e30679766b961baaa379a1028c52a80f48603ac1a3de95ed76a43b56e41c2dc7209755e6b7b5dbed86672341e1fe36d0221a5ae3d18f738bc3914b5efc0515c0617d13d2c7a7291f25170104a4735f0a7162eaf5590996a1e3541dc93c77335d867a2af0574486baccb7043bb0433f0b0988d6bf22574a4c300ad1adfa06ef46c006dc15382aeac6223f6e1f61b56b3f9e123331ca3fae58980160c469cdab29d9d804422d18fb275b907bfe9b60f3be6a63d47405d8da0ab709712d23cc41cb3b23c009b02b86b726d04a7fa2cf816223c7788e7fc7cccca00ef02f7b2a1e04655971eb01eae2fe4c2cf2d8f6d29c81f39637404b7d6176e18318d190bfb0830ce94aefc09396b0c945cf99445832a8919aad0e97bec8a4e7cb1fe5b128c06bf6f1d31712cdccb8056581e1a3c910476f309baf550e9fcdb06bc903c61001e8235386f72a959e245a05fc1e29525a429200f6db9748ad7e270081c5f96bb48a183d22e8a8f10d8ce3ba0d55a8d944cc9845c9c0baa080fb852759c72597812769a1a74ebe9db600ec38f44e27b324c69cbf7a7117242605b571a1dab1db4412d6d5030aab2cf7d00514dc309596523648e5c6443897e2d0b0c8bc359f3daab0c7f9c71abf0a365bffe26ee6d0b03762a08f25f58663f84c33573d20957e7e57b5d2d17e8690eb8fcb00af88cca5e083a519928bbca18dfb9d878a281ebc37339407a7e358e136800568cb932e125d3347f66ed7a8246a7cee9b247860866325a029b67c21cb9388fc6ef65637f7b0f81556d4c69c7634e8883e6ff968bdf6d9a8b3d97776585d8bfee0a0ed082f49fdd278290056c3ba2eaf7decee2e25406e7bd7df866f7d06a28f3ff0357cf67eabf2ace38f306aeb90f9aad6364e0c1c680e50ab006ec3a4b5f61c377234c1c794e38c8a338d3a40b8247bdd750236d4e612d1d4c947250af15cd1e3c7c511be31303c957de9f6ce4339ea1f879a7fa39b81c4540ea18f1b8bf009d0aac9314abbc6ce0d31fa0775139ecd69197120f71b422010d2f5bc8dee2ed0ebc14a150e8e3588903f690f5fb593a66d890f511829f7d9e0fe3b34a5fef35b770a56572021dd7f5302f4b7b19accde443452515a548d753e68a1b9468e942a10cad298fa1c78b63980ceeb5272f8566868fdfac73492c627e4193936aceeec16d1fa6b31043913e0ed56d0e45c9b89312aea0e8b73bbefa9216183ea5bebb727f87c102757ff2440e3d803143edfade98ec75c0eb7cb3d342b48ded8dd1f3ad6e51d562909f3ac0379d762538055ef82f983e35383ba2a7a96b26dd60e6d2b9921b34518d33807aa3dbabb6c66140afd997a5780faaf1a51639683e02b22a2b32362656c81a584fd86a7d067a30fae043fbffef55e0eda5f620f085cc0a75717834bff40625da6e289358c824081867f5c38e093ecb4bc140752e1c15a8cf2f4a2245280f0e04bbc8157ddda43fd6ec66781e27d42261119dc20e84d0979638a21f7b015fe06b9b53555db4b76da86d9e0ade55ebf9d7cc254f32c356eb82da819d2ee73887ecad5f742b042077c6267f5f980a175477767c3dc29a745beaa89944ead5e1d75cf9d781e08120e7b609c83c3cbda03c285ba06e9b61b4bc888598980913773cf1c9d61e4778ccc8fc62d96e867ead008bec5a5fe4031a58f928ccefff04d56eb3ba1a7901ba7fd1d67a69fc608525fe20b5db3620ca2c3ad3547c23d07b3f68f68b6ccc0a4051010ae6ef2c91b995af0da6280cec6a85e6baf76043baed3feac9a02cbb81c691a67756a32b24c6bc73e21182a7c877da9fcb5be9143baf645076a2eef17048a3c6daacfd00077198fc376ddc6b7cd8ee566fd4fbca5b76bd378b67b2d82a6af0bfdfdd206fa997212387a8cd03f10cc4f18f4a0438a4ae7bca99bdf864f78a7094a8f7420b22494403491b5eb19906723ddcb30e72d3fbe7a1142f69133f6fcc29b7ca52f9ad65fe99ba1a85207fd2f6e445cb5d3379cb2c8f48d70e1533f4d94cfbb7e55af7e804eafcfb03721b8219dfc1589a191f7fe4a8af5888370fe7d429c278783717769f609623513a85bc17f04b63142368eeb6d3caad1188ae79983f1ee15b4d4ab6c54251a52378070fce9915ab0237406ccfecccf1f0791633b6fe777704a3a1675dca8f7393429eb94fef70406c25167f9e48396d58cf08f220f195005ebd785254a450e3053e07f50242d0c67596780690d5aaf4a813c27cf86e8f86c1ad5a1a56f685f9d20666da9a4296f6b5cafce5884a0d1ba62969189db9e673099ebd68baaf7dbdd624f814481e6f68145281abe099927147285184435734ae8aa0eaf6b6919f39238d58504dba8160324e485fd5f4dc5a7e8821a50b679fca72f79495b3e30d0f6429a168a7ae9a14785a892978bec8476bcea267c7363f8c0eaf719298717e05cd0b1a045f407eceffaea4c5c804c11413650f0088ccd3625447dd9db93f552f9c8756e17a8d19aaf029b069799fdb3dbfc15e5c3298b24fc3644fe76c995afbef0d792937d5dc40acf42d6ca744ee46b507c2ac3189db4c483a0553c5821ae6147e5d2405ea3e71090425de64b5ea7ce888e52564a2fd408f934b95031b0f4646c90dd80651bcdf7bb0ce106ab6c8236fab7713dd80434748befb680ba5b124d42639c413c7cde8634e3b9a3073232053690845f9a53626e14cc24bc5a7b322be581b234e5646934ccd2a957f19a6d4939c72301ae303149d5ebb330ea02a3f65364ca6f4661652b6d9edff3f8e7e68d0914a48bccd3d10a83d79f40c4c6caa00609b546d37f16b1938772d5cfc906f2107a69e42862c5cec0c3b0f82d40669334316274ac9ea5795219b78dd7ad2b3e71500ac0baf8c60fdeb5034ae808572b263a93d5205ce366743009bbe15aa034f9879f0e05ad0fd18d10c4be0bb556ac909854d85daabb020c5b3863237e6da9ab4c2ab3abced84194b28fc230854884adfb3a5b2a324855d92781aca417240d587aac3d127cce0e6472aae94bfe04f329fbad6681838d1389dfe43107f9ae94c1c25822a5f69a8cba6a7226e35d38be1a19779127ba4abb101679f64386a916c2a44cdb2a52f7a1613c80c532b72815692d2e7172adaf9f9f4123e84499ca82f4685e0adaa053fbf0b612482089578c3b7a40ad560ae8a0edea222502b7efa348e7b74d05761168cbb3ef584051c056e176d151b4030a8a8c57584d725cfb04f6ebc2746349d3491a9dab3f02748a2954e3dbc7562d279b169316cc23ed57332ee89e0eee6ec0492d61db1c4947acb2c57e91a5154d0722d927176c547ea1311dfbc3f7c83042b1b44749e5367facb0af516145986ddce9382f82473bb46a17a77bfeb99e934f3a24a4b4f653a5bd2e0b0656fda2729dea607a656d09504ffc556f20676669cf7646dae3658d78471bdbe31e910cc0f601fa824cc03cd9075f8cb08f358a421c8c0548a527f1765dcb7d18f9521b043eb49dedd07c1557b3b4ec10de4be9fabca814797763da4b3716639621b9263973c478cf0a8f315d8d49dd2abc553da3f227c312933a2bbdbbe6ba7babf29805ab569cc006829d4092afd835782395f0fb55ccbc5530e898d39ecc179dd28e8c633f6bff7b9c0217e1745ebbfb81b264ea118ca80ad4ee16bf88f75f5b3220a0448fa6b523936288eaf63ff5cebcdb6e24a67573c9d92550b0b77277014b32d2b6d755c81e36eb604946fa4d12c6a187c5c691836a4a272b6d7f3d70ab558b87d753dd981fa88fc72386f67f2178289d6d1ff0805a63724d85fd56e2b511c0c43a63cbc18504c3087097fe673ca66c2a4747e322bfa65b09369d96ce36eab75f027fe6fe1ca6b2b5786b09734b9db660e60db4c82d5fd8588e450a18c5d4397f3b5ddd04b74b5e11116c7c5998dbfbe04825293328bc1a6329e794e09f412f072c2a63957cecba51201d03f5332f0bce3a793d23445409a8886abf9f3f80738ab363fff879737ffe71ce5fc77cb672a3b0b91e4e4c2592b6ae9a5cf751428eebc054983b723e1fb71441fc552c8ec38772688479d7e5b84e19317b2afc03c93565efecffa36e7113a620da2d0fef286943b3a0e7a59829ab0c2f12622a7ac9357f6c9a112a2650ce04d49ca843bc8121f886828a0a881deb4fd1189d121b48ab6e1201481c35e256e33c7f2a39cce5ca06fef9fbbd0f8e0abc0a729feb713398c1fa6d47fb1d4d5489b99ecee8fca3513ef1a62812f4da2057e41a5ae7fc6464a4c37a2a2996af1218510a26b609fea10f793ea298f66305129fa5607e8d1627c41cefe4d8eb77a35881ca1f59a643fd80beaee6e490e24a818f7de5ae575c57b18df87486e8c93cfa3d5b5e02d9e68b58af062d0279960b23fa0071725fdf375d95422031648889e46d39b30d7647d0e7af8247e00cc19685eab577db1e3867e9b154d68f3a1d66c5e7a39914b32d129ce5837d2cf9326439923870fc75cddd074ad6cd4707286aa0f79562da50b1142418b992d8398228759e0eb1c4071077417c82eb765eb9a4e24790a4289d6fb5f0b8a5019de33068d0e533535057a50b21390a9bcbebddd8feca24257963afbec032eddd5f861ac300b65639ca797eb5520c825614dd8ee4a514106938d27e42206a40eb4d93afde1e1f1a0f34727245b5cd61a455a80d8df71bc7c03006c850a249d1ebfddab22312c6163f50cd5ac3f27d884ab382476a6153e97ebab132caf66ad5864f71f37f07fdd6de9418d80a1c3e9f8ec74c9625ba679f09e5c6288c4194111c2c0d434269d19a5de1e2fb56c6805adb9f33258144e7fcd50bf53b7636b4847ef2d80e86aedb5e459293b9c3e5385fcdfa72e210ca416b2d64ee133b6a6d60b9efa792ba0d269b469396a34169f46396733dcdc2ee6cda942c7c676e6a2293c8a2ef0b6ccf6ea347e5b1112f414aae3992f41863c177c24752bfb31737cf9cd899b140fc66cb4b429325c8cf6bbe4cc8b644f652a40063629c21efbc847d6286bcaa1d4c6d1c1c56f349dd47217910a900de7ad91d1c9bde2db356611d5dee8bc624ef4b214922b8824b06c1b904b64ba59071a1e1df3737bf462381c5e21caf73c806d7181bfb310c36d2fe45894cbdaf676b8a75c587f954f3099fde16868786c8906b0e048c51beb1cd3955bbbbdb91766c76db4fb13d8b2a68a8d1bc6280dc3a9131552e7578d8014130be8e5ee98eb4c0ab88fa69232a95a27ef7af5d5c391ee0ed170c4849ee2445e6e5fc3a16546668099e8ab0d4675d35a92389547c546f01601f998ea1c685c2ba1719599489d99cd980dbd5247bc3893e1b507ae50d7cb9ae3cb5baa0a342fd5248bfef6f38e6900731462032de9295d8dcaa4498f506a97132592dd1ba42f213e7a0d5ae2cfbf909577f2e31b2c57534b0950dd8fc7966203b76dd1a7cc8688650acac14c62285511990e1201af93b7b8cdb383787bdaaef5cdceee637231e4daf049e85c0c514b6471cbe55697e86f0dbc4b5d4b312146149b5afa996f735924db8faa0775ba2789087b2c5e196985375accdd0ef7a05734c9236ff3a0622889da12261b130bea84377031925bfce2dd259dac0f23f9306cc809194ae368eb92ec205b22f02e52c194ea9ba3eedfc55d1ba820defc47e9c8c9832e93918779394fd83e4c548c396a2bf91fe95b308b12b1feb939bfc0bb05fb468d3b3b9beef7fb48a746c902e44869b099ddd6bc39d7e4ac82399e01fa4367b0b66ad7cd72abb7151b2f36ac64a4b047e05e4beaafd4e478539b57ae9aec10beefc9e7372dbe978474e5804e1cc76e8e53b4ef165a4740ee107164d4d311b2a8c958b4e6646488783204bd44840f11d4b00a8a38873f1ab771459eb2d0cf5272282a34afa583240db2b677e53855678636a09358e1da3e9bfa763a6f0be3c7b824018a299e7945500e130d42683dce0203d8948c5ae2d1d11aab5da50bf01137788f892177c5fc6ffbf69adbb9015a91053b4a5eeee15da5e03e444f65539cb4560ddfbd30a06ca6d94ee401392b343aa477378d7444a90b3f0c967dd830caf184bbfc71abc921f75b5864ff9464ef5fb79ecd5f42969df1c99d0f8dbb527af37102bdbb7b31344d8d5aaad51bdc77bd7968ef5205377bd09bd0ce8b258bed86a0f55a61be217287d9e035649070e5706cf8088fa0410b7ab6ce82bcaae0691436e93c6f710512f9a6b989fa2b53ad25afbf2d01187806ee78601d89489c97f86949eb32aac73a51c430423cb1d819bbf2be07b4d402cd764b9f7e54d3aa4d4e164373f350ba74f690b36c003974f6f768ef079292e28d761bc964d368cf66b85a245f1573c5e78b14ed03c7a57f5bb840c2470874821e97878dbdbed5abfd1e396d17e45a76966c60d1d29a6855ace7a84a9d2c5053818ea0a08204fe8752db11e59484aeed0185ef8f7aa72ec7dae2e10a932d630cfe3f543efe491a05abfe8b591c8a6f84bb6b5e982015efe00564d5eb3e30c9b4dfa9edb30a285aad3043c56ddafcd2221e33972d7747bc915655e9ca42e02bca29466c84dd219182486c95f017dfcaea584c72f9650bb0249a896f5db971d4df02a5db8101e90a256cccb28084fd99c20b03c3bbd8a0d164f0451e6cdb2433dee074f8c0f43fd74a850f4d5d5959169ed863a00154be2840ea9e5cbd6ea001a9fae79e901f99c82be9a77fdb81b2263f008510517f8a7e46b2c0c7cd9ead2ba0df9a88ab40b04b604f2123b9cdd3f532960c347e8abb4e64dc75fa1c76d3a94d10a3b56509ea1ff0e18ab57ab7ecc915f060fc54efd843807dd861ce9cd4261f6ae878d9169cac4490680add85e148a7c8f573a7edac2771dc53a45dd833ac9cab1d283df18c2b7450b17e9edfda453c20aa1f312b102159276fdb22abf3cd0e95f05217183b05d4cba31c476f46ecd7a576a09241d50a7c0a7b5fd4263a4c1c258e497c43d9249211df2aa3c9d34fc8440facb29b3aab838e297c043597b7dbe242514e685f1fecd92890f7dc9d89546cb00b07525d392eaf907686da929543c8ccef1c58440df53fb0f15fda2a7207e928d7932377c91fa4ee365f5ad9ffbae126af93af8ce27be073e367434881e193887c02044e45be6a996bd8c8bb8b6b71fbea8280cf65dbd6570dc80f02a763f4128f641b23b348b422e9701c634ed95bbddf2b8680ba8dd5b0b82842f95a15d181817fc178857251aea0f98ee3b7dc19093a3b195846037cfbca02b984ebdae56f47d6e471c54a6a2baee22eae2b4e032909411211a0347ad20cd8aa84f8a7235090d7fb580b3782372b3cdb5f102d617d395f6d28394fc46eea84ba0c1060b623ed562c78ef8ccf3dd3dcada52566360563be5fa28deafd9f9c78b55c04d48affce491ffd35b56306f232b4ac9d","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
