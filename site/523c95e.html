<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb87f2d4b66f785dd71f60a32056e814bd99596845889e46b2ded53b8c6f6d97de076a99a85d4fea496f7967ac577931f9a712e12cb10a5098ee9b1f94aaf38e271e0cb79d512b2447b9ede0b714638c2c9db6b8396da59b3c698ae12a5eab382adfc1e78b012c8231c5769dc64003f513e12be16c2ead0048cbb13735fbb235666e314008600426dc6f9198914a6593b7a201b39d4c7ac43384c09678608274bf963729ffaf72fefc64fec48ba8e69aae4cabbe5b189db12b5a4312e501a89d4197a2ca2a533c819dd174d2906c7cfe2ba223d0e1983736f55d661e787e9f243012ad6fdb5728d77860db774b32b22699d5325480ffc2e801b0076c0d7fb45bb6f57d75211b299d2765bf6013a17e0bcb3d32b092a784d7e063dcb500d282a82d5e99c624d2f5956dd679a0da506cb87d97734983ed288173a31c4b66f1db9d834676473a1e534f83b7f7cc1730c7e7a6f0979754e9f205e6ce939c4e1db5cebb6bd6910b7e6c9e355b7976af2bedb316e64046daacfd314eacc0f2883d73b2e00a3ed8cffdb713f5b6b3d4494041c18b1e56d624bc50c14facd37d94157a927ae3885b756a71f9945fe40681ef3f005790001dae07db4b931d8b5338ac42b284681f43ecaf961f4bf51cc401383d8bb87ce85da50b1df44c500ec75e9665fd3946131c3a39a63bef76ea63d16f9f162afbbd4a9fa060ec8d1b459fc0f3b43286a87cda49147fd69add044715a40f7c7dcf6d56d19b8a1837395e3f42629ba831acdeb16725deeef2faf9918e8d9476d33b6033d355d44bbafc89ed5074409e5d1fe13b59df8752fd62b7bc4b74dac9275ba6a69fd44839bab7ed8c8167fd27d51341303577ea8356f58b2d1af0d3abb88f8bd2a4dcdc42f1dffd1d035944c25c8e454a990a9426770efa60dc1b42567bb930d1973bc78f2fbf53dd9e6465fe42f9e7a8024e631e08cd0f0ddb579adaa57dfd3c971f228dd6f1a77fb154f137810ee386167e42cf1a4175f39dce750c8fca197b424ecde33644b1aecef202a04a282db2814ebcdf657a1632d93703ab9bd58b0cd78c6923dcf828d467e51a697e214d37d255856108f2e471de06e170090c590a3af1b6c8db336d5b72dfbf1175df8997ddf4ffd5adfa0fe14b431b2ddb6d32b1f0a5d207b19ae2247c417922b1c23624911811680da00a95fc75d8e5446cb8971896fa704e63f779481bf99c7b4858c2b23e79e32e8036981d06091f89399611f4a84aa4700148cbba4de13860cb11834c2e1691ef9b4d485b6977ac96902d64de0b22119feeaf6a7e0f37d4d984adfccd7a7841da9461ee9b18e861d491ccdff4194f3224b401bb201262db825c2a0d3d04d1678b4a3ec96aa47a7d2a7a2a6044baa981a2b1027137c0256d465bbe8c5213259f47c380b03873ec4f4aab5091a94b15a201a5ccaa2a0d6f7ccb5d9b18d3301930a8f25bbaa455ee9ceb87c191cdb8bd037fa90fdfa11bc1413fe69a66e9742aca1860c6403dd7d1224da9b0157c08653f13cf6b9e29b7a83a5e1ef3b763640b69527349dde9a028050eee7f2e6c2786799f21fbc85942de8f4ab5c4ea2c8ca7e5a3b0ceae74ea7272912ee63dd1f6edef4b8aa39bc1ff6af82349e772db5398d246befa74ebd3a2e4fe7b32b5a2df84a9c84af7f0e3ba110e13195c9c849f849bc2b781148d522b1f5732f7e22d4df0e15db285c6930372b41de228d434a6bdd2a135bce6896aecb270005e9d68acbe7a5daf7103eb741c0b4dc49f01539bb502a77cec32403b560a89660dca9f796ada8efa6f45f2b562a8384b15c2ad812cf10ba4b0dd79b4ef33b7b5b035e02a25a6aefd6a6802bc903fd01dac1d8b4fa821541587c1b55cfe428cc1a5e6a7166beb7717dfea956b77920344ca2222f4b2ced13923dd8b7372940f3ad91d362f8e4d22ad9e4ace651e38564838cf72434cf1a2c28bb3d7c64508dad747924fd3dd22025bf6c1b782f143ded041f1ff639b9e415567cd0710248bbc0ab72387d47d083325136c3e254f109dbb10fb7dadfd1911d650e2ef920eed4fb55ca90bf4eafafc889c73d2abcc84533c60533bb4b5d187ef6edc2755416f401a46dcdaa4975fa21151beb0b193fd44f14cff6d2c3271cf9b0f675ebfa6af93e3fa8287f5e889fed1ef66fb5393a78fa2f1082257ca4ca4f56914853278a7307e3e59800f18d6fe6e96b0cb28e496e94d8a6e2a4ca3fa734f0d9a60fe0d7a6c8fda85eed8bd6c8aa3abae7af0d3326448d2e95b5619ab15f306ca35da3c22ad4b815f918270540d38d8e333a7629ff1924a66279f253325f144bbcb521738e4ec422901502d21dd38aa8a0a0ca6fb85fe5faa6f6fbdada1b3f43ecc5937e4f575dc82a7291665a128141e19dd68dda58ebe443ed5487509364bcb11ecca29b4186ec1cf8161d149a493b1ea0718a4be5b5d3778285a70a702e135799e3aa6494f25934528e1de18c3c1c59ce70d19e7b8b4603371ee3965e36e4b5dc8aabcd4c9fcea1e8d564167efcb7050c3f193d725794b3d4479fafc39812a25d41c647c9e5e9aa9f923cf2351de7b7db5f0dcb707111922392be9615e9371112453247bf36651486903399bf8ca2e4cbf956baf0aabf88aeaceb2d87c84f633120978295110016bd58451fd18ef414a2d36096ab2397683526106f96d6cc2fc643c4b4c82057116b5c670003a71ac646ef70ede08eb3c0a906eaad64d4be3df72043d946c17d2fe75ee3699b460a364509ff6a1b86010c93ce0afa61656bb2a34ef31f408fd834ee97eee1937c6ae62c521a84939e201cd52cde3541e389e5a7359d48fcb631d9c815e97fea650c160cdc730c0460a085ca800232ca757ae7b6da4b277ffd20edeee0aeb0e60832dbe8ad6d0c2e7af93c9d8d091e60028d9ef745af87d532550c296e8fc5c82cdfa5972471f84d1ddf1058759fd8d9a2dcb3d79b4565879be905dbf89fe57abb505374a363eb1144252368fd81a8c1c3b1b0ca9d5d622e934b7205da65a02b227d6ed76bc452674ebdba791f5ece5f10054fcf45778277002a443e40542ae0b7f2ed38c848e1589dc13b3c0f92c611fd7bc9ea9deee1352f9a8f7ee36446e11a18b7a31ca85ff32a4a162e4d85ab3723a8aeed58181119e057a45f621bb9dc4803ba68d8a610a9a428c1a7e2b104d52d6e7478ad32b3387e1f1424021698183b9f42dd9f1d9e1f868229b884f26d4e2d11819f032403e22fd9371382771089e131206ecec1b067575a8f05d004e1c4a3721f2976c9e2a156cf14c7ff39c87ffd81ed0a9f12d52b9a144ccf4d40ebd8013d37867a1d0e91faf82d0d963295c6b2b16a8a5fe6f7e78be15c63fe39b6a089ee7dd830d11ee2eca77557ecba491307e4a39c2fbbd05226379a29b070f6f5ad05168420c600b2f49f4f4bfc328ba51b2bc74cf5add27f2a6bcf88e4717bfe5db8c960d704e4d87a8da0ebb1f3f940b80bad60ffa009fc7499b33830f0bf8994f3468c337a3ba5e2c1dc0884e99fca5ccbec0b4ee60b7aae52705c84deb07e09472cd866841b5db1f62481002765dfde38f56c7f947633d2e2815b561a2f2b00cb72629166c5331e77c9681ea67de72ccc2c1ba9342771986ba7c55c58733f9d8ec62ea923bfc113aafea8ce2bb0b9c7016f979c93c031b925b4a3135fd3061171276be87095b7a454b428055db53f63d43fce9f614880913c7598b6ee6c663bf9d5d7cd6f9b48f83872f1dd1024bc386916b802467430d1789cbe637b63658271ff7772d7fbb362d7df67469a9a8c2de2ec8c7edc1af6292fbaf2747e005c343123107afa2e0b2092d23a1abc61adbc4c52ae3dc73ac8fd3cedfd4c703bb5d6be2fa3950a9ab1a6052842aa59784d09baa36b5ec3316f6e53e3ba719affd9631daf207503932f5d407fc019a4a53ff83a5f9afb1e2e847914952432201a375e71448c41adbd6dec36f859c7dfb8735da62f7f2a34c00bfe136ac854f39ea7cd8a570c09076d0a864335fa2b342d0660a00aab45e99eed0b4e55cdda78fbc33e1399d5431895437b9ab2229821a1e51194bca43ad67a6b1d79b95a2b9781a523c12741fa2510966b8d4c6d19b281942fcac2c8d405a1c2f89a574db9cfbd3b28217281351cd5eee3265a75f69c39a3e5d419fe2d16c2bebd0d19740711ef053c6b763751902c2f8a5cb462eaa3466b74a6dd4742ed2898424e80775ea67bdc20d5fa5f41d3f90725e4d9249f41620e49afc557381be7cbd462554585d2ac9b2acbc68a9ec53c1f79294f269c608de2bbe4edc3cc50bd408b842a13f7c62e66335d8c110cfe037a6f5c2404261b44f66742349e2954283caee45991dcd0fc6ae89e3f001ac2f4a1f506ba976a95b2ff95af783aff6a4baf2d75991987ad0deb4360ecbba74d4f6f8f1374ae50d21f2985261826677e7128e507c37b382719700891fd3bd46fcda8c2cf6c39e3ec1505747ff54a4187253c1c347dd5829b4c958b4b418ee9cf21acd44d3bf980bbf1260db22e82377c8a7b13c0cf27245f1c07f7a1362be4c0ab6c01ee1e2ac070f66ba8b4ba755386a1d895c70edade0659c2e6fadedd2fe55f370e46f3c643f08f60ab19e561b006d1efcf4a41efd5787d48439226e29160237d2507cc84457354b1980979cabe327bdd407d310e39905bada95259be64840b2281c16c37031ae0349adff16d20c53a21b63db09c6f6c29448cc3644f189d8b39b28b09b68dc27249139dee2cb422bd9645cf9590bac856b233c93050f881fbb4cde4581ea5efa1b3900983035aef7a7194b7a3de5f4ef3ae0a40ada23bb81e655c008e5650521f083217f1f9381b83447f4f8e2ac89b5238b5df1d53d0509432420f1b46c9b764b7b99597fd24be97b1e0a01d733d3e2d6a08cffcaabcab15e0110b3ec56ca44eb5bc5eff2a2a2331ce1bc75e492f29d78b2dd322d362ba25988e5eade7e9c06a077f6c1419f684b797f8d793dfd1c39df798e1c2616eacc63dfb2b51655f4a54308e3014ad82fc6df33202185f5fb286c7763a8942ba9422be90878674e5d6d85cbc8381d9b8efb041a989b5693b1d9886cfc75a24615c192b950b5621d9b2ba1f54335ff705c7a0ae3066e82457c79259b27a27b24c0e624c26d17db853c15887137932e1ad284fd358564669edd4347e71aa08680dd211ec1d9cbb565b4ee3e6d527d667a1f771d3684650d7d20f0de4e0b8793f7c96571f55317a10f15976e943742ba516b0e611827f574f9c3e58b2b8398915a46b56c0f5f25f4969d49acbbda0561b87e812727e04d20c4ddefa87f4b61b9d3bbb524ddd59f8f5672a77abae52352966f37ff8f5248185cb22c436bcade04d1d4fd7b0185b6ec9ab0d2e1cf8960f8ab3db2eeb6b39b62fb901c39ad17be395f96474eeba2e741365eff2deb3076013c66fc9f6cfa6ecaa48d892744964f9f4401b8287ee4b5379f4e0c78b06ad926bc7290c951461373e9754d9d9e3ae57b556be8bf9e52f4690067a503dfd1218266a3aeda505c96dca81c825915ce756eb6017170c4254de0d9b6a466193a5368261f9e811787bc587c31dbce785a93013f4e900344a1367b8722cb4643761bf51dd8abb898b8b6c1fdd9edbeae7c00289ce11a6b5304b599d5a48939cf5a8069f51664fa374db272bc7f46105d172450fb7028ff4903b8674d11e6ae00c38a2d5ad05c61bb126a3683acffc02663cb96aae5f1d8f100f98e3dede22d08936b5bfec148abd7ff650e3a1a46b2095d64a0f5826b263dbb2cb6eb60ddb34d5f34ccc62955084bda5db182699173279084ce06029adb811a529ad79edafcd54a475092bcbd18a0fbd4d0647cc232978c2fdf7344e6afc36c34278c50bc5453b8c8598943e64040add2fa85d8e0414bca5fa289a9432ead6f7991abdfc64c38ede9454206fd5025ec5ceb62cb2d531bcf7b3fc2ae4e27e73ee7c7d13fcde5b252ab7ca7a1604ca366d401959044dcaf4908571f0921fbbde2399d817fdc2b7b6c4a268ca2aa5a5b24df6a3cb7c324cb900a61ac52eaa9e882ff885663e8c306fd7bd60a790e82fa90efb4084bcc0908de68263be545154e8c11299ff3a8745d541db7da0f295e596275a50d57a338959ff471d135270f772cd801105022716042f9e155b43e61819963f968f8e703db3c0123d094cebe8e54274f982670bde68f2c1f12a9cf554f818b4cd990f55f2b0bbae516b7f0588e2fb221f45234006130b8938719b456ac145883aa09bfe3364d5656095053d128c3f96d4444b0a6ee096d0bc0432c38882af87a8ba26031f1a1cfd126a9dad3cf615ea63d60865966a4c2aa3683ab0694e587af93bdb68db32fff60d84e7b2856a10c38960c33bf71ece488dd466d329fbd6ec556b6f281b3312a621a6d0b26ba7b54fc623a5786ab6040d0d0f25f5ea2939b66d9d0e64ebf9de69432ed58f6047c8a1c9ccf77a7705c7898ed4c6d60b950fdff7f452f9fd9ad1b50a1f5b4f7c970da15c0bc57bac04c468bdf4f84d53d74eff531a2bfb678882fa9bd6ed5fd7f752ed8dd7a6f5ce03e5077c5a5ef0c2e7a256ce4bc8b0320be27771a7cb26579d8fe641203bb76035449f1a08530dc250a33f470dcb254e92a9a028884007f2f9bb82541c08cb328cf9d76e45dd5db3f65064448f5cffcfeb71bb6d92f8ceb285f2101782d673ad7239361528a0b9f6594ba8a71bd9bd8027603c29bc031ddd00942afa0c94ae181317ef89fbef89745542b6fa0f65c1d87758b2224d8be87a6179bf1c4411f0def59f96a844c7f10e3dad850c91b84d468d92c9e81479770c5f6ad2069d16853da2264592044d4ee94fe2c107e98eb0c20bb60f07ccd29d06f2c53fc512df11f98d8f6dfb3d6f40be2531dc7d6d0c9562758b99acde1374c58ff132a19b7149a4fd2f41f0668da1bce2c2b6b619d674eff2270b9df6d36b3f666e9dc8499acca8ddec7ac3d202f5c02eabfa610db53fad04fae0476b9e321500d0b004ba01ff6b6fb655a275595b5db7064992de9931724f52e06569cf0a4ffbc1154af45553ce589078a2f5149663806919261a919b2a8fd29c60f1498ff78aa35195bb1754dbaff7bd045a20e270fde6f42605c56d5ef34607b878bdffd66143314b8bf48f2098d4313f3df24172354c0e368021373b4618a890c44147e39dc2dbdcdda522071d077e30d4d5bcc0bdc5139b0960d4e890a77ec22e86577f459472d9b5994c3b4ae19756222ceffdea5d3e10a01712ea9364947200ab76a861a667ed8c2dc83bc4884167458e84d128fac64c46af7d110c1bbaa8d5b746e2fc28718d0cde31a98be780c59a06527b0b7273f02b47abbe5977ca76ec8c64dca34a87cbef38b7899d25346fa8caedbb387407b4739026b035ff9acc1dc64bb332d426b0eadd6b06861f15e9a7b55493887ebb817dd38d71e0ccdf5e46b5a085e5ba733c7b15ae1427ceaf4ac39ff10511facb5343999f248064ed1d4e709340647a2d56909924e2e19cc115dd80dd403a1d5fcb3f5b238a09e20d6ec618849b2b2a2361d5673d1060bd5f9264d7fb0387c5ddb89d65b493b44b8b39858b34022592590014eeae9692d69afc21e9f10581d41c5e33e0f9d0290e81f76683136b88d7a2eb05980a610e98deede9e974c6f81ab43b74643d56d806b37e2f5c7cc6dd039326653d261b231e8ee5b86c4e6f115905bb7862ecf1d9cbfa90262f589915ecf4ce3a5190413f43467d105dffaa2afc2c57e0504a39ed4617a5457b6299166155f67d22d8cefe46fc8c78a6f0ee9e5b95692d663b6ea6bfa30306dc43129b1fc538f34e1f47b0a9453f7ffd654ff77f746a764c0eb239d3add60154e26b53911027c4078a21668f71cf79d8dbd277373f39dcd214a562f9699bf7418f60c27b994a19902aa99ef5e0cfc3b7eba226c6f1bfaf9fabeba95a8b3bde07191047fdef471ae3b380e47da014141f8a50bb7015406c394cfbaf7436da59957ae720c6fc304cf74ab7c3dfcd9abd3c1aa9b092b387c574a71a0a61c38e271ca944202f6661296a5babd7452f553f8e2fa6f2098e2ed4f7336f54116d30ccabf237877ab02781046163a0168b369fb380207e83d9063ee80c8cd11ba8d7fff4018af5de5bc318b55787c975c01c2db02a9421488e8818dda7826a5fa1bee398936d203aa7549c816fa640e101b3384843d7ce01f94d942a599f81cf7bde82c9ae36567037bb972eb216cdb5f76131d2c0487c681869c56d20bbac0a1a2817c4dd5cc63b098e93ad0f6216495ae1ea4fd7381425ad27e5860273efb89369fa87aa2108ea4b139ae3e42296c74dfb1065f29c2e13666b5ee79e2706fdd82a638e791bb5de6a6d6762b81294d8915c89f7a3dd62743e2c462fc48ca003c2023bb9f59b7b7ee99342bceb40bfbdf11a2de8807d34bb91d124929c5b2f1784cb6d2509e26e1fd3ea606fbbcd151d1e4918a090d88194e96f793c65f89898ae17eac1a12493d8f66a6ab69d26f56459f85b6c03d31423bab8d044f83d7b9b4a30c9688441bd14ef85d51fd19f24d694790d03334165acdc9d0b07a8799bf4ace083f42b16659dd83401415b5fd72ce77d3f45257030b3489611ded7b7d167a3d7513f0d672266e1ec53b31baaca48dd144b28e8b2a5c10106d00abdc400fd131a8bb7c8fff1e99448cbf3d5308ab2618f7d9d982931160091c90f9da6fbebd2871b22795dcb5f9cc5cca987e0a7464fb55542628729d4f8f89d3c8011821a528c06e763f20396cd4ef891150cd4088d64e8b3a93ac42e9d3f65d1d547fb22d8e4a8d27c960ede2469c95cee6b22e67033ce081afad5ad1fcf71f816fc67c7aa254fb6e3296a83a196284ba6a297dacfe82e5cc4f07e3a3c94ed431bfe6f884fe5b35107f43883ca3b31ece5b2978a1cf3a0ee4d94e8b1fcdf8e5e5f03b28094af6b4da3487e1e58669937c089191196fe87b754e6a78756d1f028b104e2703693a7ed5e3c235ff0c4b5f2cb158ba343223dd9376b5440d55484c63c696d42849a70fc4a0f2ad93fb286c144dc091a084e74b20b043913754609465dc3e05ebb66afea6d65985b73f4dbe2f5986e3d3d23099ff79b0635fbe872da35da8405d72941a565949e538b1908d958f9a3ed4eaf9677aef86a41635593040c825ae150f7875511614b5100dfb8d3adc3616d99c07c731b64afaaf5023229c94e94f92c58ddfc2564fec9eb0ca71eae8f29750515e0e729f9ca1451e5859bac8d1a15150dd8b85100ae0443d2786a34814cf2705a5378fbd6d120f5fe5134334a3638421f57a38cf43eb7495d116b3a62d2d44a125d9ea3955781d82bc32bb96790dffd1923e6d61cce2b27bf5546cf48b947b25ca63731f2826cbcc680e5f866b50acd1229365f10afffa820ea76093148a900ff13956ea30f5883383c04a019e0f6c66be0a8003d37c4e20b06ae2e2bfd5b1384c8318ea04f82d2186357e0f21eafd036a67cfc43d02ceda9ad10a087cb69b885cd97de770003e4aeb9a110701df9263343e0c44912db837ea3ba325be29bb1a50e2e6af7a780db9c772f6bc0458dc487d9fb9a3f70876d79e49e99285895cd627ad68b28badebd1c7ca5a29d19f02b58c0f3156e4733631594f9f205a53f65404552364cf8e80a74dd19c200d3b1d8e35746aab326355b142655c6e10e10ce8efcbf9337fd310625ae9e81c5f85de22bc7c682a4c2aac8494c5990eea159daa55babf3e7136ffb8d6166e7410de41c15832b9ee9537757c621bf843412d2a105c41d99d3cb895e825c4233ab5766d252487ce5520bb69b9fe9f446ace619dd4d369023ecd6e86850c545ded01eebfb66d8d60f1187bd1cdfafb1dd05e122bb4ac32b9976c576ca0728e5ab2b547a1fee24440fd595f1bc4a015843b092b03634cb78ad7b1e146b4be70c294d864d7d30755bfa679f880d65b9f712f9d00aabf693467e47aae42ee0092beba69143d3b0a162395deb34106d5cdc449adfc9b9255a2821abfa8860395e47502ab017092d088e2f403582444ae14d3dc0f39ef4be2f054839ef62ecf9ad67ea13848a380f40b726a738aa22c02b412a9655de545d4a40cd02a4661d92cd3240a87ac2cee070ce91bc9257a1713ee4be349fc602728c9297fe07d6ef2edcbe453a33009fadb5c7ce63785ba62f15fa9b276bf2edec4dd2568ad338838d929d30b072bae0079289e12a021c2d4dc6b3e1487363d80185b4ad6f0467568bdb9e768fd3ebcd1249c1b630677de6138e9f5a737248bbff1e51a6362fb962d2951e9ef9d4625d2a444cb41705af72822891a826bf9eefde477c1098b395884447f3ef5d3330885381d2d28452ae3cf73c1ec65ec2ba69a7aad89b6ccebdc1019b6b2613a553c8e1613636dcdd1b633c890664668e3ab20795f1b1d9ee57d3e5fbeab3e7761d3cbd6f844d4eb2cedbdb3f20b334c4fde9f67d54a61842c73ccb466bea343b69f13dc6ebfee11f032a32d4f4fcec41b73337a1fd692e034a19a2bb296f707d9e57ee0253552baa05c8e38c0979df451574148c4003639d98b439c07a732b68dbd57560ce62013f02dff92ac56d5df3fa3c6f28501cd783baea26d1b2a666f4c675a909e92bf9fe2231f51ea5ab7f658afa687aa6a34d4065462a5347521cb13f6c9b7154b70edbd77065cc5bd0fb769e9099bc9f24bc5a97d92e3a07424d816c21ef78442961c0b45c01c89ab7b0a73ba969ccd3616cfc990ddc1d5116b8a2c08a337739ce78979bb158cc9b5f818d6212b49b8852c36e55f9f9baa4bd356b1a9106e250b3a265f017fc48d04fc2470235bce48116b8be5d78a97383441ba2514ee27f27f9218f6191f4a42d9f3c563d63052383b053845c4c248e8f929ff4da992b44b4e32ab49b7fb70db459579a0b00c9d0709089764230eea37e174dd0cf3e33cfcfdabd4f3805757bfe9e65058ff8b0b21a2b15949f7fa674b537445adb7a501cad8d525d2b792c2b841245fe26d8d95c753e56cdf5dc243ef7809baf833cd682b7b59b4595b1c181b96e001666fc9f5195768c51431551efc3101223627f649fd0274eae2ddb6bdf1d09c37335685ac7ffc9205bcff9ce74d70ba9c13837560bf2065814e5bf9ff8267bac9b332a517648cfcb30fd4b669569b5441aab65ec6d246bdc352810917a5df6bc55b341c167459cc63109b5462151dd6604e34e3bc1e00c59093056d5bbde810de32d35c071246592518a24c1844591660d3f7663498eb7489c7502359cfd643b8c21b452a0418459856ed5b6abc7614cfafc80b2214f7c9cc1fc747fb9c65f84c644b6c7253a152cf1791b9c7dc2a7c433e9272e8fa42f6c3ed9317aa25d79b57019cb75034646153d58b54d6d7c36808f1f88b988e28197681bef2c5481750b0f6725a54692ecdb80aa6d8a94a3878b7ef5057b8803d015b730cfa4054930822ebd5582d6a05fc1ccbbbccf7c5977f9bc592a747a1aeb0c85f34b505ce6c968dbcabc38e82790c658df102c7c64d935505aea4e080bcef1258a247819b14cc97f754acc29b89a1c41ac1592a58849e92680e2ad4245f1fd410105974fb189b98698b44a4bb8689152e28db48828a08bee4a383812e4d6f8c34831addc688f2606728cb08e660227e57eca7192670e3b839496763ecbcae827a9c83ead84fd0d59897b2ac13ebfd7b26a8f9e683e9a1e4d48916b655ed4e4a041f19564ce919c550d4e91c7cf2e5ea2ce1d005b00e22a2f3917cc97d82f529c6fa65b62a52f0a3296d8b75bc51db85bc253fdaf2c9a4ceb3ef893bbb09647d4a53fb0387e230e3e8f0ed26af54c2bca4751135d9d6302d674d131673a1ad73d6caeb0603ef4be8d43817d209b0a8ae1cb16b31bb0258ced8ffaa155c91452eaaa3ff48489103ce78ca2fb8613c48bbfaf3cc4f79810e2d91a934d925b6c8d8aa4f4445ec8f5451ec5eb53c8f8945b9084e27b71dd852852d99857ebaaf56f2108bef674e0bdbdcf61cdc939444df17175394552c6ab9bbc5bbd9746ff8107b9dbade4a3d8dd74a1ee968e6edf898a389d0c441aab694a0ca15d3a3662e720e28b6d602fc81a139c39537f62e8b40ddebd3b17cf70976a9242e44f114461a8e57cd73ca15de870c48c979d219e65e2cb85694771e161677e2de3636da33838546a9eb1d89c6f3520518b3607a60e114205ebe98867f713167066ce4e6f3d96fd99aa8799f7e095dd90af8a57b02e9021fa9c034a24a31df01d488827c8bc0f9de9e7b88b6deb0664f88c8b05f660491d7430cc1018104359fad44a3e68bd1fed8d00ed1efb95f86dbc7d4059341575a6dd489aed2bdfbb205eab0c46779cc6e2b82be0782f50ce0e39943e336056646f33d0ea8a4df3e67e63dfd7725e9d9cd769a7a97d8387b2b0533482f2c08e9c1696b37b1d184bb383667c92be9a5520dfa909a644184d2d7bb538b73206c13f9aa19185521e0506f32f1e15a43d2b09b48009d8999b3fdc1f56c5b5c52547a686c64bc5d737ea5bcd6120db6a5bcd199c3b4dd540e10e17628260967174eaf618078208c670b7f46f4769a04c566d80aa8651665a94a3c0832746b868de7454e1f2553a50aa7238ad466bfa4167fe189f3b5b88de6e47fcfab61d1c00c6f83d431aa92daa695ddb85f5256cd66ac24fa2c8b41a92d94c5d95180ee6efcc70e34f515882c578268ec608371afc8b6dddb6881fb7f8b9c32f066974c909ae3299f27975903f244bc22619f04b49121e302f070761abca1f848cf52338704cd8b54745c0fed699897820eef11de7d4aa384b3fbf98d5149300c25ddb09fb3ee455fb294dc920bd130c4c975e914483d23471fdbf9ead60b095804f7f41d0fe63ae5858413901947070996689ee9eb27e236ceb7b033597a9eaf00fb19886d7bfb27250aad2626bc62368f5edf87b67464535defee59dbd62752136ec7cd282bdf24e31ac0cc1b9641df9cc29cd84a626500d7ed700af95ddf411e04da6eb0f1b84a8ba13f9e401d92e7ad2f7df104605f9a04dc7fdd38129daa53dc46189ddbe352f0a05fcdb837f1f4d9f65563cbc85f504ecf88d4a5affa4dc9deb2f8a422d55475a48018fc3ecb5431d3657aff3b165685934e2383b2c127c92a3fa2c6330ef3d16b7a3c55065467fc5759abd1db329b121d83b675330eccdb5668ccee1ff8201f14e9e7287eb033c6b5557ac475156f3832a09ec993f1a1e8063e5201c843226c5cc4c1954e64848f1d4ec6bee07033083c7ff8947311430a5b364156f59cb26763992bd62334528168f7767ba342d13e54ba44effa19748b752327a2b7179549aed94b017bd6b9de224381a990ba160ad911c459242073564011326a0eaebecf822afdcbb395d096df6cda58318d91f2d8b68d5c14f32a9b606a9721f404be8c90fb7a39c10cac6801cb1fdd1c19fc92d5539117c1da8131fd13d62dd3184d96ceb6f0ae1425b34bce48c7869ada4d4aef3be0fbb964d623c4ed4857a2576067283c024e13cc34455d9f9e9f2d66dfc126399e9f2bbb203fd930785662d1e23d338233669b77984d054e79d0cac014d4fb7aa874dde241e778cac5cd85a4f8fc23afa2caf8577ddf9ee1201aa3af2b8259ea232a6d88403acab4054cbddf1f906084a50d74fcfa5f4e74579ff0cd1db7e88f3d76730a24895aec3016eb0992948369fc5317b3cf5e2bec9dfbc4f7e31f4c20ac86bbdab01aab83849e0e45e77eef80b04150ff02665d92c296c5809ac7c098ad5b89cc89490d43b0d35d8e708fd054b9bd01f8a5722afcd161c659d041b103c39fd1904441ab01d2c5fe2470dd188b1ab613f5324021284126c87d61d12ae6dabd348ba60f7e6294a18c3f2c605e703ccee17879067773a4016cbe2c14730501a524fd3cb1adcb5f4e2ecc9c504b1d5b3e89456de1fb906248ec3aa200d02d24b7e2de1e116a4f383b7a85f2ab4d407df489f5aaf1ea227f67c5dc28d4bf4435e784c5b0f689886ccd94ecd355898c8603288358858c30e5d459e4b61b14b1320c996e4693f9ef9c35a0ade3b2cfd09671fc9ff6a5e1322d8516158ae9cb743797c9f1a77c5f6a7550ff16d2314b46bd6c5e0009e83badfa0a47548f0fba6531de620c1f388ee89fd2068c469bdb7c923d4ce2e7abf3a37240d8bc0980f3d99ae055a6e5bfbe14ce7698a99653c7652128f2b84c033e37827252c44ab6a5b93afbd509d94d257c36cf32a7308c404cae43f72a67aa0ff8f3d3c2d43dc109b6c0722a05833a077bb56dae24ae44bcf0dc43fa2a706a17ef8ea5a2f32e5b5561251dcef95130a3409895cbb6b380f0f2021ef3aecb4a30bff4a7d7de56bdf61645bf9fbd4150982c8192af66a533541c262d2b460a62482e543cf8aa3619f62a2072927c79a850d4956486ef5181d9a4e84105f61ebe4b0c1a91c6e589554a9af50210a093e30ba32c8e3c6418046e29d1732013ca5fdc7f14bf2178cd12ebaf156c2d3ea514df8e4ebdcedddad1947f690f1b97eb438e02793f3d56a39be856e4eaea261870bc6eb7076c11af168f047da71671d2c40d83a046f0b9a644a7f44faf59a9b8b73cfc7b0609ef5434dcf6141ae103054b7180a6fdd3a90c84c9219cf124dfff1d6a7bfd0fc1665e4912522d7694d53aeeeb27fe47fc94475a343c2ad2430afe6b4043bd6208a991e0253a0b5b6555be473dff918a429d7bda392fc47318f510e27d655edee44a427c3474072ac935129808c351ffd5659b42f05568effc21863d66a1d95e11993806b2cc6ab7aa0e36f1b2865aee2d7d964fa9ddd4e7d494c43cf6a23d8540ace220f96e6ace92ce328e473f067695524fda5bedfb5e50ef07195c07afaa61cf194a4eb5a58d737ef48d12fe396d1cc8d58b475986b9211282e52636c68c326c2c6a6ac236086225bda7303e6f6793f19ca8ab15bb969b08cb7c04aab2e7b6e57652959cc7d30f54325defe90a907093507f946ed32ec281f42c3208f1aabf4116ac4604cd275e925d9b4d35fb42468af4545b297fe88b563a36592145a673f5da931c9f30a237ffcc06374b5132bd5d620d4669aa38c330b54f1207ac968d736dd37ea620cc38f31568892544d5795b7a2b7ba4fca0ce049f267203dc7d0b7d9ef165f9dd71bdbcee11af8e92db708b2c038d592e60e3d59906509c03d9bb8982d7e5eaf5fc3d254cdc8470fe7b91194f21bb8dde7e8f2fe1e2a6160065b3da11b2c1ae891125de9eac205952f2be4210f3546baba8e9f15676110a030ba11d3ba9fbcf814a429c7b1976c3c708c712553c71ebab5cdb90eaa14709f4bae3215d0ae92e02dd92dd0259731c834a97a5b51d38fc76be12e98dd78f2373d035a9fcb88877bfd06f61e64cd20ebed3dafe8275d988b56309704a8aa13439f00fff85044a67591d7989d9334c58fa657a02de6b678784c985b502c97c98a835c03c899c90a787171b1f8d2e8242f5ffd82c7c535aac8e967cb179d9c4402fcc54bb7ec42dd353bb6cb3f6975b62d3a42f5013ba8411ab946360fdafb271bdd77e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
