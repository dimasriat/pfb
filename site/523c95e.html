<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9600d2105a7565fc91d58e28a9d711c2b766226c3845b2f91b9836ccf0305ca3900686f9d9d3b9849f3853e845e585336758935eed59691f126e6d1d85512fe45d6d52d2171690095e5f626b1bd501fc9b09666dc1d20670e0d0266be5166e8e688d3dd3c3f9f8afffaf8b6a81a6968d0e0433a336cf366003506f1586bef22632b1c0fdf786e2dd404d332362e029e2865774a3b10a1f183a7a3435d265ee7a37b988cd8522cf04d04dd92b332295111608705b62e8bab69f82b7ee150c7006fa744fb83056cd0cadf131b59476008b50ec78bcd12b164c536ffefd9ef96b9e89f8cf50bcc4d2eb6fc24f35119971942e1d2a493d58cbd3a44bec4b07951067b4805dfc6481e1c772074b0b779fd3f2f7a697fc896a6ad7c750deda2bcaf9eaae59a307923a2463bc75520369b189df605bcf7d12eeb65a490c125231e29c176414b97a5114807ff35b882f8065786283bbbf03d0f9d29bfb9efdba8498a9d93e3b5e0e5c171ac33e3696bbae7b4dd180f2688b077b1c1c754e9977af22a029950e60c52fad39367c159d363fe46ad8d63b0dfbe024d36864852771633526f488ce0c868e0fdbb40e5d3ecf7469943787fa1aea8df8ddfd876b5326f9b9262ea5f37914be157de9f67fdd29c50e585f01473373e29bcdab3c71786428230c73803aec2774521928eafa2eeab40bd543119702b948e38d1a5b65af1c5d2930fbfc11db6faf33e9f210cd391162d13d22321165215cf0b7d15a8d89b882dc1cc88a29d67478a1ecac4742bdc6542c4522288bb7f788f433128b417837f9d6adf11a361bc40b94af89ecce923f2ea256f489be0cadbb60ae8873648bfc4e7b7213a9964fc667db4e2ccb8fceca2f1f635f5c2f277fb1c4b9b5fd899b0d2dd9217e0b7bccf206cc6493df53fea05d0394051d9c134f6ff728d678202a4628351d4d25d06f91b775d33cfae4243668c2402c80f4e9bfa6baeefc2384df95ca5f869b126a0d389a74996e06cdb63632df42d259df288711479b3dc420694e5a4379c8874cb322ecc368e0b503824791ef2973364e2d41e8a18b527b833ad7b68bffb92574e6cd0e0585cf1a2990f5b9f9f3a872d554114445f4bc149436a16d1c5ee328fa763572cc09b8d3eb6afdfc265f8c78dbbf7e4f6280ec711acfda5d5d87638bf29b45d9a9c03c5fc11f74ce2e414fd1a1360d77900475b8c8651d53f1618d03d1eb976e543f611898844f9acee49c4a6b9ff749f94864d6716ad47da7959608203b76acebdfa9bebd3106fe4b1ae73d5eacaae7912e2660aa0972b43f60e3cfbbe46cfc634f00d889f4642e77afc8f9ff684c1e903a4a54cbd4e829deb14ce5c19e123520f15a8af05d570f33c70b52a3cbe2b8355b2f02d5600c3799160cb40e6183335c16f3a512e4b3cce7a8507aba4946a6eed262e740d79e86aaa7c9bf0f02bcdeee3652004c87f492e53c83f110ccfb9d18fcf16ea6ebe0937c3b39a13b6a936b0f3e6bd28cf6578e2761d5dcb2cf9db4f45571b9e7b65146fa851d29d31f67c1332fffc2d79618aa629ea7a43b367ff9fd3ae0c8478a0df4208e1f785fb7be607fdf82dc4b85e318e029857da889a2ad88b02dd4c6d9d63e559ea3375c9a609e61a9a4c6f88517904fb05d1053816d1e3b16afa5eb2d715143bf6bfc49b6cf03017dd40702b238c8442f87addff38a872d532845cce0f8f8eb5b76d5dae5068bdf52a136a4853fa6a5219cdee547d859caf24ad85fdba36999180f85bd8b8e1ea89d72b778211540342a81b890d1454dddf24a5a93e1074ef9128596ec6e76ebcfd6bffe9974ba10c5fef6cbc913fc4e6b840ef8a9cb862c24268abd35704853eb785f45727fde751574e10942867b94aff2e2378102aa9bb8a4e410ce640bd6abba6db3ecc721bf05e82c5afee02a4c06c881dccfd7cb93655fffd05decf2b6da6d4f9d172782bf57891196ae62a77cc98cc73a336868843b3bed7f2adb7ab6fcd36eaf5a026dfe55cb8bc5b110e73744debf550b0e4b699c03d30e32fb99be37d18c3f0ccfb9bd96df866ce025aeac2ce8177114e1938b751986681650b8c0b66f4071ce81235cf3f34f12ed4854a9d3d62316a37e29674b01b844c5a7045c529744d05568d1c537785a608b33d8454b5c5041aa5556b204033d9e1146365dd6ae672f013c978cd11d21349e59b702e33d778644b14f0ea0b983f98460466849c2c606d199befdd55f884d24b289b3bcd9624830b49b69f265e03a61756475e05517554e83ec6f559c7651991e4ebea23d739ec6343ba47392155122a4d1dcd8814a7c463d8edf5c87ecc9eb941719e499ee026ce0db712000c7a70632717d16c1494e5c48bd4846ba005302c80f7c7059056ad4591078090e5e8dcdd351d83118a2919f2f8cb2fb9971e51506f15d93be5dca1806cd7c241eb20c233a2eff939d804233b4c3cb21715fca2aa0d36fe199eb97233d36ba94e20245644b1b90d1686242c32f51e99fd1003d7f22f8026ea884c8f00b1bfc5201ef39253e89656e8582b01036283cadc3266575d7442f5bc934643b48eec708b6b141a2ab83434d3b341abed505c30ed646f10c7fb288b2c1b42975e034ba0b845ab19ec97f19cafe40dad0411edaf726a9590922b72b6742d20563ea612071ddb4d36946012028643a260264648a59f3181704a4403b743f83d5d0341d9aaa9fef1838e68d98314124221a9a563b51416228a24d914af5adfc8e8630974584245e580fb584880c2292ff713d8a3cdc8f10bd83826bb8deb51431331e6291010605d9022a79880e3cb5c8b4bbcbcf77e30c0e1fc633d79f2e40131fd964736047fa38261a6f2def8263a9eb2ea2f17b5cd1883f3a6cd0353a5784ac483245b8a673abd91c946143c1c36fe0760dc973f6678ff570c67167c3a9e3a5631a6f52e72b443db60ebe3e257f1572e158f178a19f29d42898cd4f28e6a17b3fa18e3da632d363acfd1eb313960b042ba5f1fa2ab4e980f08772df22b3b7d8dc8a6e87722caa27028ceb6d197a2e07c172ed0dbf75cad73a87854783522eb0dffc32b8afc5b9b9df5b9535236c24e26d2b0bbd167667f4b124be15979f9cff47d308bc7844e0b58069e035c3277141651ddb31731e88974690cfd7620b85fca366d568f9f18aaf906b81f73c99699dbdd44ebafeb5814d52bbcbb788d5858fe56bb75de43f60a396caf03ebd4226ef427741329f01a2b28ee63716fb551b6e6be2303733409bde0ff5a962cc8ba39ab249771e5947119ee8b30f8d0f04189b37c22a9d8d06b242110d75e9ea457cd134d2405e914de44e91705265c0286829fbcd42c930057080a47ada32ddc889db4abb531483fce779c269452a9ed5a0695b8d2ebeac8923753a71614cf7cc6a5dc8c952b7190289598587dc686925af1a8e770e05ebe1f2e325f4177feb870fa9bbfc881cbc765f0399d25abf24776e80f0056de1df81c92c615a149af9855587f0ee1306744227266c5cd7a2aada876f3c8945e4745607abcbcc65896abfb6912c139fd126ba60bd01e049897007a5656e8419353bab2cbbd507bb43052b5fcaee2986b950d0e5acec822c111dbef421f4cb3988a15388ac6091a39a9d70edc97e21b64331cf36a8c6cf26aef20b9012015740748752a92dec078e5caff48abefef525eef2f44c074311651334bd9e077356922df8a7aeafc2f4bbacebead7f065457d05a0e82fa56d9ce438a00fa3f30e67502581ee5bd597ba33fd00d4ad7e9cb6e0f1ec71dfe0e7786163265ae7d28392d24023ddc63cf89a6cbb8130d7a5e8eff75f3ff5d0179185430bc9b9dfe7c5ab36125e967e884deb92dd060e5ec5606f3608be5f853afd75d12991ae01ba22dfc97c1bcfd9a5852780e9b316886599ae5bc43a2a7469fc0eb03ce26438bc6758f66db75676e5204a15bb2ba5967152018fc85313f82b6472fc32f293f7d60baacad19491c164fdfc713b93150b7d068c0e9523922a2ab0fd1e281f482d80bc555a1205d8e22e088b6cc75c24a8d5937874229f8761aa5953e6f7ac29f84afd9d83d81dfdaf1f2f70f95761ec9d86d99d3b7581a7fd7c17159947173cf4a2210ba840e29998ad083d96ec709c68b17fbe41292ec059a5b62a5dbeb30650979028fa6af2d4b76791966a4ffc61f7fc92014caa208ab6b04e6a0ffd759e205ff13143fc1b6418634818da903de2b7ccb1b94cea43f8576d72a8a8039fb1ed2a9c14de5b7ae757b6a55cb1c9194e3761b45d476307056ecfd395c9c8b9845ddd2c060e0b109f5b74fd05bb26e35bd65d372b8097005c5cab37eed76c98e7edf2a77b31808b24a595d6686cc68701365743b87fa5e4ac8113007e2d6282eeae075fac032c331696db71cdb331120fe8573ad30cc29332acaa0e0ebd3bc33bca3f020d94b319c16dbc6cb5a055027182e828d8827d2851ce7f42e952d3e53c673a8302f78b5cd9172ebb39ef1436b8030f24e046a908d0600309fa1787ed1b63890bfb3b78575f3a9abc105285407ead424c431b6ce6b52f2228edc0766efcfb1a6abdc19e516163701cc7a5491a7b2b184cff4510dbb00069f0d42e16af5b55908c0a6d3484070632b132cef7c4cbe47b26b000372da12c82c7851beefd346c1ce2819ac4574e9285957b2db0877bb64bb13169f658181c99a32e2bde6eae843428eab096868afab2308beafc85b472a182949cf193420f948c09593330b2631bf88ac28e1762533f5fcebec407076e4a01591ddd4957f0dd47bd66f47adf6e4092323217251c3c825d3b2c2d75f4b5a48581a77af4a2d7d6463608061e19de5283bfc38d70d8446193233e84b27e1b351b521cc7abd57f3a38f69f965738eedabac4e74be4eb0261cc788300a7671b7296a7f3548445cff4d539a10b92006c9fe187fb6db88fca0089fe78e2db1dbb9a025702246055bb023afe989ed46a9dd7ef330f362359840d9b1d3c3a1ed7c8dbb33e6285586de4ff60a9c91fa45b7983148f00c1613beda2fc512ffb73251cac0f8c0dc2328317099e25dc3bdd3d6b8614fb88c83f868898162b3cc105f4b9a08f864e14096c4fa4ad64577ef41f773f851c470ff80f1775e8019da038429db01e48c18e88269d2dd9af750c6e9de3091a65e8c6cbadd762f6176ad17e6a0698cbf8115e7f036734ead7b08cdd64606c170ca5d651e302dac133d5af1498b7201e5f5da8f4f26d134c1dbcc84cbf6480870750403dde045d0a777b0fb3c7c562f5ba84fd4595882637d5a54294d6974f1a4b1d454d8fe5b402e0cd6c521568cfdf2bbe10bdfb1050ccbea9a08f130212cf36b9274d79aa83689eba88654a784203286e790e08c3382f490ca837cf1af7ddcbe9b91752cf06e87c866da8315b85e99115b69a0efd025dd121ed4a0df39670d1ef84bc082a2c8a7102e84cb0fcb11930947364759c0dec0b79ca74c276f18032517965b7b365344551725d5df7a85183074157f1cb194d29b6c2feae7721aeaba8fb95cec9c6f9c1e68c065e86458777d7b302644549492a0ae704c17001a139398e654b3c1a241cc554e7ed722de0584bbc24c3a84230fc5d5c526ed905725715168495c95cf27527da77cbe91df124a64739093a74e8100114caed4040895e8f2ba9f8d60b313f8adefe8cb28584919dec9b53615fba823326546468406900b2ef0800779855adc957fa96eb29dc363f51d83f2530a3d6be6f4df97c21f0344a3536a2a5f9d676e673fdd753663d008b5608b106bb837576c6780f9644261730c59a88a46b5bd9fba1b6118f8bc73f64883a92c616e5042036a0b7a7a6a9701ce3e9b8f5de7682cb6b18784155ec943d1c2c98ad6659f5289eac6b07b84b4b702befbbf0f65893fa65746eaa0b79b4b7672cfca6b66d26ea97d70bb9e6f9ab05460507c801b0c2d095b826db7339f37828596164a32a93296339997233663232c52d3ea6473bd8859ca99773ff3f4e098d073ce7dcd940f7ea49119fbb9d644429b2f5a5cadaf816e8a1ecf4b8a06f22793ae171ef1b27e21519585bcb51cc320314048381bae1daea8ae2fb43e23841e323a8fa5a5e946c3c89f2d7fe5ebcc030c14c0770d98d5dc64c53a907edd436ee1d6cf89743433e67006c524c257fb5f5cc5a62e12f22b28f56eaae91450832d4eccdb58150f41b09924479a91ddc33ee159c25e39a2b70c2ca58af4bbc0f111cade1258b299349c4d4f6ddff37d52b0433293916ae154032cd1068889c9c7329ca3ecdecff4d2e7688f02b08f08ec29b6e677874d86828bf1459113ffa5d2fed12d6284f4db698bb6c2c22d5bf94b72f8b4d098c01f97acfea544b2b432f262be6a4d60bc983a83c05ce252697510fdb0375be41cf11b64c9a46c0a05e6929919232f33d8f9303c84748b74e4b66122399e950fe4cbfac5d24b85b97974650da271fe87b1e929803adab1ac5655b3096b6005becdb915b839fc6553527f3e8d8449a1a28c0bbfa6dd836d4b30c7e8c1c7cedecc6b01cad412b5c8b1f26e39ef7311f95065880f74945bfcaaaf19740acb5fb6c7ba9eb68182a3dc19169a3cb5034491c4b946b529d84f555417317cea076ef3706a077c580ba4f2e2618d65a38833be852fbac6235a9b05a4713f5099e6d01c11cb1b0c98b55754a9af22d569197d0f9248606be4a86e8e9287274b694c7f8fd8f33237f8700635cf6e7cf9cccc587573dcdbb592ea74ddd452ca4b61c34df680af77cf5944d4a0e295da0ab8d39a66a81e7d276187d2c97335e68cf87c18101e8a77ecf0bb0177fc186d578e453618c9f479631405b7f4d738465636937a228da3906d954d20677ca92a8d3637bea34e62b41e3f4ecb456e576593613698bb8846c10d0225dbf3538c5829ee020291419d22db8142c476b513fc324ffbce0b3a5f0a8130ac45ab28b9dcaaf646502ddbaeb485be22b48f51c859612e3de6ebfac6012a655c5b400955bcdd9d5420b5a5221e4875e2390b3318f17f164d7248f44be15391e45256d8348abd6d62d4d9e10c2c5f892cf2a9f55c221fb2c083534c365ac1166d6583153ba1269c0f7a9e4e2f47edb16e3b537c8a2ab4d0cb52e2f7c3f69da0721e2b6d965b71f218f8059428d76346df106b1237086257095e90f727faf9bf2452dbe4d5175c541ade0ed32ff1c57284c8c16ee4db09c0c809a378cb264872caa0ce8afcd34e3511efb4b8285003fc2b3f88bd1e67ae285c906119138061295de1e81fce066afc47daf3f674fc09d980c63abd6261d040ee9869f601b7248d96560b8c346f3714b99b5dab5194bbd78e485826985a570c7362484c60f2a497e2781f479ce352c416be03e8b1dc7ed3790b1ca3958a4c7256e4316b08010fa9ee8a3277faf716c5df305281ec1ee32e927cb8b39d8106f35e51968a0a8a76e2f7c71240dfcd17cc29ff1c6f7f17a13d1ccf7b0af7be57c6ec697dd785001947b8a88a8374948e0334b83f82d62064b0f35b5627df5a0cf2df6a394c9d836fc1cbe7b55e96bd8745dbcd0212041e547ae40485ecfb95001d3612aabdb502aaaf1b77542d1354d4e3ebde81c7bb9071369aa9b1a171d949a71e7b6c29083837d3f3d3320b8effbc179c3c043cfd9d27424eb0c2b4c595932b616b9c6abc88c90015cd0f5821e5c51541ee0f98d1812224f710fc636945b7378634fefd82fe7f27ce5e8707add037174d5991b118d28e9643d5c21df630dfb5c3bb5f459ac00a07781e841cf4e85d1ea91cf62b58266ee63ce03f1f8510b420b509bdaefc6f24b02fc6f638f49b4603f7a4b2c273515a3044c1e1df9537f2706bd74f45568f10a6e846a1a525c6c4aafcaa17e9ad0cb782c67304a920fa2168588bae5d84240ad3c996374cd80e57b8cb6ff4892abb734048deae1bed28b48530d12dade0350d0287e801734f09bec29bcfb55a0ef59f7b3f51521ad1191beb256698133369604f89299ffe0cb7ebe11a9441cc47eadc95f02c0b8c34e6800bf35d5c8e5020d2a6f1daec314926f2940ff4178c0a241b8cf06c05d4e60fb05a317f751ea0aaf28dd2d98a28d4f2f6ab9e675747c28a4f4e4f0f944a8e4afbdec07ac79097dc2070a9960038f1afd0a73a0592179c737ad63477b065519242edc771139b1152e49ab0a4e1ffbd10f1cb5193c925e88521a457dcf33fc621aebaf356183012feb4caf6b08aa155fe3e5cc4a5f5cc9ab9c8e0abc94788960426a76fc81e045220e2569b7eac9babf5cef97b2be328f72ba5fb262410bb293c4932e7ae6bdb18861d1cdd51aea68cf384d2b2ce6b736798e92a47aa9d5f6d17f5965105be6a372d3d9a4df17d8185eaaffe0e8d30403de3ae83f097e0c2074ff996db7681c79e89c96de41c1f15d4e672c412f658522bfe0fc46719d78f288a53792ada1270cc41cd39a441e605bf1462eb454fa8c403d64564381bbc6b12f0a41c6a70235021c5a9c8a9eadb66d5822940b6fadd8f3e752b9326203b64cf4e044a2c1a6668d4ff53879432a1f2cee7bc2a0f83fd4915c63e82423cb9189b621d3329964cc2aafdce96daeba605353d94be234209b23d9fa5beb3303014a4f5f9950695d76438e93c363ba9347e7ab53e717923cca12c1c44d6e9686fbd021433ab9314bc9aa7125bf4c390882b3b2f6519f13cb844c8e270ad1fd05beba082b6d37f2e21b7f48a5d1776e98676046e6bb50e8ad5e15d3861c68ee4c728afed95538183e1b71c3f3dbdbbd5e3522800a8a3c76237c6aaa1d8e7821449b951097386088e77a1cbc7cffb76fcf31a2b5d2abad4595ede4257596eaf1745dd8bc7e2719e26a32ca1036b64a2668be39862dacbd0fa62abc680eda427c128d76f41a9151ff87d0534030b7532d7883a8695897e20a0d7aae4b36dd58758899cdb75dbc1476677aa2f0ddcb50f424b77d6c77c3a5a89728956a2a64d92999a495faca90defaebbe6e9c54c46f2ddf1233a1180f5894985748498cb1b487b0c5e1a96d8809514a8b345c89b28d1142776b478b96734cf8b1f71962190389f235e562dea945e58e8988c0d89640ff5096e9fd8c6cf5e43f2be6b6c30d18009edc54eb5e2d18652837f0b545da875925aad17df12f21550d9b7eb71938a1d4d70da53ba01b5bda4f8dd4a0ecf3cd4b6e7a62290162b030b3bd40cbceff23cb44f0a15b41adde6ef93919d023b2f0814fcb527b028509b0f69a73b2896bd145841d2f54a9769086dc024fad8369bc6a0de7dac4703cd24610264a0bbda7bfd09e0206dc2de6e2a86b6973a4d7fa8e3278b902a1ae8e8a1517dfbe4c4f7d87f99c7c0b685ff6aa0e83514c7af7b6c051b0b8750feb4696f071d91ec2c541ae072be95556fecc759f3af74657cdca8cabe17fba5ec8fbdc9c1db41f5135f46939483935b55c7efd09c23d73ed8f2d66771c41448bc45a1d80836b688d05ab2377799b603b74204d92671a32f2ceefb58ff79e1c6876d8de6f3af8be847031ea2f7b5ed42f7b50aa92d70bbe09febcf6b6d59c647751d211fa059ab68cd4cce9e3c03caa1977ad73369de7b2591825e9b6ca8409c30b2dbf507edc83464b9709a1121fbb8c337f013b8544cb3611336236533cef9c94d26fbd20a64ba3cf27f9a8cb2d67f84f690a75045b0485d7e7c5d94d1656c6dfbc461fe76887d5c869b45e80f45ebac2ec95aa06e8a03209a5f78dca01a8dc794e6063aaae98ee6f749e75f9eb85eb51b62d0be407a7f69f0551bd81cad43f898551ae8e4da7dc66724d5632764beff54699809b143effb752e62e81a7e285959052a1dfec7bc6b97e5ac00f75123b7dbec8a6aac9d51b421171c26f8a7d7cee2dae0b5ad73c1ae009da8381b3b9b5b70f20f823b22b1c14f3d15576b612ca413978c0847ac1a995862de12289d8efdaf3b8319677bb483943826aa1ad5c0fc6d64889ebb67d1e9ac54c369cd88b4297637de15c0cfa59204c2c3949ca6b01d1d288beeb6776726c601973e3d7e4129cd11880dee488809254ab5080c749d531f16f720a4f37b3ea4ab85578a2e4153854986def2d25313f17c58edb9c88820e1911032fc98831696333cc48c4e85117d058a42e39918255ec14956da3a979e442ed9b09d474cb9c621132bdd263d5c16ef48e5133277a450b9f0c73e8c4e5a0d682f73e45db4223fb1f323bf2f63d520b70f47f03e3c7a02293841cc0ddd94c214f0ccdbcb979118b7f1387a0b76b30067dbedc2dc13ace0421da39cff6bea88be59141d881e1bb7f0b2a3672c4091b2e399012db4d86c1bb90ff778178f2160a4785a2abb2c8fb57ff8242ab206e0237a2381a115c3372ebf85da9b2a36c9a19739b4dce80bf6a9723fa3cf7730d80e5414a222bc186e2449c42c3cab75c2575a29d6de39946e485c4634ca852a003ebbcfa735ca17ce0088d08b7ea6ceaa4499f5d2f12ada7bd191e485a441b89a05239f191f130ced00ea681b391b3d471735d2ae6d384cf7329f5ffdfe1028ef7a3e175edf479f30384883b71e7bef895fa7915109a5fd8e97921aa70040ff08f0e818563f537ba82dadf28e7d3d3a5aac17a8e1e033a2919f1262633ca0d76a0eef691e32cca2c17ec0dc20c98ecd9e60ad5989605ddfe66a1f2d940697b63a4f454c312dd96768813b0e841254b78dfc72840817515cef7caf3925f87bb204f69e170f4809b1257f3d8d567ac17fd01c8365762bf1a56a1cd23ee018e5fa48167b842ea564d4094da56f0477d9b5a827759c58b42f651a46eb54175186299bff00454198f33f1a3442bf497a3820755bec5e7bbdc88b7a3f5a98d7665590f579985d95cf3a0b9702d3d2e76abc124b9a21805387ee3c15c08d1597b6b05e9b43afe11b3d89c31eb5bbd4604000be6f76ed17c0ba7be3881e5740b63c3b542611b2f74de36ede9183edc2bdb91fb49b53411d8fcc606d0dda6e96aca66fc8f25f8a63574ac613051e4c4e2119fd568686125de9cc5408b9c853fdd763ca6a39f8d35f4f64c09ab0f87d4d566a4585059f8c4102690b4ad1db71e94584e8f062e6c5c371fdd62b9aa73120f7ca982df49ee6ac5f28af6baefe4823c67e092172964100b7e5dcb11346d06802a1a3b272e5904cf601d1d46e883c0d2cfb83d4a0f6e2b268dce6ea6310fb788f9c6a7bd97aebb2cb1b302cb59c09706f0dfc0d040c8c9504fb8291ac1235a758ea95c1d6492c7c0eb01a91ab06df6c42ebcc2840ca2c028f6d2eeed4490659f877fde076240d3fc8be1f1982a092e2693deffc2d0dd1b5c8c39d845938759a28dea90b2e2b81dc79e362de24df8f9c38c35772ce5bc6e5e32dca796e0e8bce987013e1bfadcfdcad61aec72427e7f43cb20b7940425c45ba9ffa860e320febd736e18057d1d08ee06a00e7918c37246bb76ee544a66f954a6762f7103d114b5753f5a82bd8ac04f834cfc4e8e0c4687e3e9c957892c06d298739e0d4eb42190cc1eff640348fda2666bd523bbbc84e8bfea6f026ccc2bc3bc8c8ba015e56c3843b01abd2324af355e7ef1d9570f6eeea42057e6de37752a4d8af00805cf654de3872d0049d5b98c85de75f6b517e25e438932a62dec5069c57271ae28e11637ec87fec3c6703746a882d7127f3c9b8d36a6e93c4bc8fd85dc359c50c835b191e941ede2a79d070161649695a1b8f25b5613f073d1e09a92673df03aa51f8dc2ddac0cedbdd2dcedb9b7b588f8524fc8dbd01049d24886e2a6da485b06cae8be70135e3137510ec76a0d2ab6f2b8c36c8a21ed60b1d291ac93d440c1d57619bfcd62dd769d940d7e80551ad83e26d45f684288e0eb820ce188c8fe1967c70216a6a949ea1039159661f96d68e176c3b2ba72a0e66f3631e7c1454b3cb67ec596712c788d1b31468866294e63cce561d7cd5ff0a69eed0108c2b679d144a3c6477adeb5cd7e69a39e1335f954f136bd4f39587237a14cb2f5435739214b5229f82b86cdf978b05a89c38f068c9d1816d43780d969889c6b81dda2e05d9f55880a2dd9ec80a2f8193f79c20047299951709aeb2433e005350999a31d18e72b5cd087acf49be3001a19b4dfbf99e53997685e408f475e7fc6d61bee380f95d0f051ef4c535662378c6cea507f4648fc091a79cddb71ade623ffe8624ef0b6fb563698080a1b2c5a95c2e4093b5818c8422efb249d2f9905ad67e5c7067e79ffa54e564d3c620f3bfb9b8f15ea66feb468580ebdb5ac9d9d70623c12ef43c87e684652956b02ec2758f2b42d676db31f5aa177643f5ff795c3e618949477921ebcf35132f9b62828722cfb8ff9dffd099301c0753a8ea42efe2084ec7aa9510b623f52acbf01bf11e9680ab5273a26263c756a25ce65bdfaac1446289b6f06a4ceefe8f4a4442cdfae3196ff435694e385dabf6e286392fe0ef8f33544ce81a09350cf5f787f78ba3164deea3bc03e6e8d4193b946bfadab41622d88e8a5e229911c4608eb13c6b54313c4f3e4a402092a77148948b17736b87a9a828619ddd8544de97a37392e80cd8e886816077c9d2fb0e2eff72ae2f4205bbc7f63002e8d1a3ff33294d756f8f7dfb173d71d5f0c52cf94a72f9459f9907e671a91dfb7fff0b822e6dff0a6d7f3377ee5eba813d9fc0d56759e5b511dfc350758b07b4cd9d1bc9634f227744d7fd701786687f80c6703302ab39abdcef47e543d40b61a171282daba0231149de462bd2457f2e026dbe89143c9fdb8fdeb58ed96c86eec8b22525bfdf936b958f55d21672bbadb220591ead618b32960a23c363fa8e2e372fb253f4484dce738832dc79082b7c3e82daa4be4f01fb8b6c1dca19bd59d2b34b192b91517476528e61341dce3d9515941928fe1cbff15c54031130382401566e0761173140d19caba401a76560a32cf8bd3243931979fed182fdc1faaa9b788b26ad78561dce45f1532623dff41ae4203454e2c7247e7df97b19d656483afddaf2595094c244103e4a77d65b2cd60ad17c64dd7ef562862a5f33052a7d6cb14cce3a229feac7b441efc4d8f9151241790fa511a2b18cf8b87a3b438f3eadd5c1e73b577d08817c0755e4a62c76f2af4348253935865bc45d0253c3d44f24cffaf9f716bc81f57037e2129b38a01ee56d4d18cdc6640f56b00b07439b140321cb698505d1cfa9339cff3b3d67fb706a523d7e051c47e5c4bf03728eb260112123a40c27d942d748472c4da45945679b0ada22dd6fc0849cf979919a21e04738ae8409bb4516b6bfcd9bec52d59488b6dee9563b5a926e920ca2c61a4fbeef98c091a24c3666e9a8da064fb37dd3d655703b443a9705b68ab380b170e8dcee8245c55d0b2f3ad01958e2ce014655a491ef3d5e650984a2643ebd33cc5332c48927740ee043997db2e549ee81364759416fc6b24739eff63eb3b3168c3bff36f3afe2d5cfeef623508964ebb3e4d43365c499cb47f2d3eeb941ea408167aca5ff857727e3bde6c83632b2176f0f025b89f0179088e0f8a457e7c60ab0602a577111eaea61ae3bd721bb6ef4fd575651ff021ade4f6aa8ca7e5fc118f54c8c1120bc007b108c873fddcfa111c44d7208ae2c1b35615cc6fcaeb2023b0f5d7bd704040dde555d1e2e8b8fae84d4928620bbaa92cc2d77ba3e7cea89b4480fd4a3009a36d80a96ace8c4b1254d4fff18226621c3b04c3dfad59d6fb3f195f5423f5f51290298e9008e683b96a4cd8e24abd8c28cf50ea1a2caab5f1530b190e34cd5c3a05445a7dfb6a0d78339de2b313035f2380b268caf3ceef16c16376455376ae776ce66ae6cb641fdf7238b449209979cbc323efc2af7ebd29944c0bfad42c1e37df45b5ee55d5bba46aec8da95869ba82894b486196d2662ff8b85c2489f7694bc816ebf5c628041f6d8e50d71d4984dcb13f3bb2590de559236598494b756f564e8718ebda8360184b99fbabc41365239818b705d64d1363508498df44dd59239424441aff8fce87593f0a011e92bec8cbf694441210278b6ec0d4efbdfff7f4d63883107413dfdbd871619e05f58b3422ce7c47ce81153662676ef000ae9fc479d3a4da0874c4a7f1872765867157ff27ed81ff41140c652a7ceadc687e56e0aa4b506506538397b0a21489197567ddaac46a7f5948146d9f0dac34e7f4acdda525b7bb11f37643eb948195f0223da49bee82d80f54a4a028f02f7788742ce7fe34e6c4fec2c29a8dd891dd0cd838b6a4f3b08b3ae37d569e23ca63f71abccf4cd35a27773a0c6c39f8cb13dac1f67c3e2e7ac6958bb093736685eecc2cf840f2ce1dfeccd345ccc519caa1bca7c5a4dd690c78bfc074745eb21b636db9f5d224b05f265d21e6528d56b6275e2a6133a3e0efdc4f1e86919d5354c1dcfcfc8410cdbafdfac392debf1df9646de94c464ce15c89def9a138a0a31b0db460134f50774bd3403a3bd39fd43c9af3e1b118cfb470b7732f4473dedcc0b1ead306440be85c86647d60156f32a454b61642f7f237d0a6cdebf48488e4c03b5b56dffdb21133d73e288515da25aa02999d70b263464036bc1edae452329fe7c6d316c52d6acf7c7e6e3f5e2374f2bb44dac54c37bf7485a1cd3863dcbeef3d4cd52a20edc8d452f24e0970ed171575df242d6981a3607cb10ef471859af8371de51d5e63325de952b709f13d00291b192551582091002077d24be044eeb1fa4bfc38e27248fbf1811bc8ceac58dca013b93d9f1eef03ef1801002f5510221caa8a4ddd622a11ad2bd3531fdcc1925f86ededa3d01087e04d1ecf94ce11cceffe06d073010faedaac529b2b73b9093ea1020ea7a2ac95a552c4354ca5b93437b3ae490475858133a8c1a4dd2e902ec35db9d48003f5eec707a5de2a701d98b6cc5d343087cdd397f64b2f0828fe47d2ab595ebff2b992e4c8ce0f7ced6f662b4897a02bd7edbe258b15ed35c2dcf559315f87618095697899baefdfddf8353ef9844532f80fe14f3ef7c2067956cfbe62be1ad2c59ede11eb61762536c96de908815a9071b73b89c7cd035d4f2a6f973a38a8df2f72269d96a241292142b13e89108f6c4852777318ef3d6c04b2be50954f50cb8cb801b1416d8f8112107b1434fbd88fcb89f43300f07e24ca8e7569d2f344377b2c3db32a19d6b1e91ff974b2cbe52d0ba2e8aa0ad5aefecef124a9a3289320729a430d9a3d2da5a48b5a7fbb425f58f394c57ec52eac1ecd8a1ef6170c73b2a30d2c02185ab77b4163318a04d5b2cf22c93ae09550be4d7152f73e21b52f3adc4de9c44b51fa76f713769c8d85696e3f5bcf764a4f868c3e35605edd53e894100d5cc76d6ef3920141dfd907fe96100977d1fbad44e9b3a7a4d1121930ceb92599d96e9f7fcb5f001c2168b97926e42e7b911ca44540400e3b41780e52105bfe94916407d0adfdf35fcafb0d804e2bc24e2ac3cd1602bbbadab72dba63df9b3659a6dffc28dab0691cfbf9bfa09ed11dae94d6d1e07327545b186dd254b46310092338acff62f01b4221f4d36971f8e4fc6005ec360c219e89d534110b0f88be26a267f85567d41a36","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
