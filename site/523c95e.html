<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"867b8c728efeb7a9f81518d6caed7b6ffa5dc376d2173558c379ef92c03e7c8dca798f02c586b903c4644a8bdb317ee94f7c527fb3af94cc9dec44c201de9d87ed64c34f042380226c555fa96f51d7955a16394cae9075b628b417dde68b92250f17236b6961f17e1921dfaec0cf6d9a3e482a50009c77217bd34632f13b57d02b48f1f6c2df400c77314fad0146b8c7fae18728d1e38aa722a894edc200b01b308cb1a6a05112db12a443da3a4affd089a34266d1ccfe92e6ec23a91749723799ad2fd15860de3537a8c4a8b869f86f11092c8f3712909733332c64cd6452190d8328354e241a945f3c721b925c950aa417607a5754176b8300e327e223ab2719f6013d6fdf9a3e864dfa695821266b2c2881a17b6ed86b602911b31d205e077eada13904866db7776f875a954242f98138778d03d3f4a67e38db3b2ce100dbd89cc79cf911700951173b9c2a491101ec7b5a4b0738b890fbc3d06aad1d5eb266588ceebeffcf17ae4abf77795394cd0a05d50c8d1d4d66b572b92331953d6b62d927869bfa4d8cdaca520fae25cd14c29647900fa732e1ef9c829a5f523fd3671553002428871b6b0c984f2c590b4a908c2f60b7fba273c8e946ebdccd702a65a0c04470dc9e557bdac4e738da01c02ef01e3294565a3ab6f82dc3a87c4fe73bc2e2d18f1febd9237469d6dac9f712ae9aee689776b34aad335dd0f210d2398c3c259c276f89b6c53c96d54fb62bb8dd3cddd73d15081e1910bcccf426b726c4f13c146252dc65939a5c022e37038bc2a30706a58c9cd04ac9c48b76cb390d88a433493a8f183583c7a7ba5d86adbc38c1356f2a30c87174e44632a70f52bc4c1c899f98dde2659a60de1f847f5d557c3dc34e80d20e40c34381307a9d25f66db7fa481e780a92c8332f471229075777a17b2e73d12b5f2fec3c5cd9b2f7198599f90379b8e8377c9b717a1755d8d1106b6519c7aa45884a6f8972fd5733ed5315feb1aa537092be6075288c10a91356f058a76081dd52a2f6c329e6b0315eaeb8df5f0ec7fadbe4d3e5152fde5c7b47bb4f47f1751f3afe90f16bbcc69cbbcdfaeef258b67c41645aded5b0644fa0d71b3e9b84bd5e613c5a16558bc08aeb8025a054b96eb60cbd3282193d579e41bbef5962c81b588186c9a046f7d23dd2e8d66dd846c1dcf10ef615dfcb7fdd0fbc73ecba7c5d04c977a05aa13cdee23787a94264dc0a794ceba6a8385c3e8c5bfb301382388a3347688d5da118d5d5220d46f04593f458645b2af3e5d84655c2acb07ef0a54df05a9e304398b148f91079d63021b143abc83ba96b4e69a5c85d4ad892e2b1003c41312b5a1428e744830a1631489883ad9516109df3d3204563a2b8c2c9ef1b603704bf96d03caa55cbdc7ee98b87bc1d62b00522c12e3d8f2f911f1ebc00a1ea98ba026a22ad681c31f7fa1cd1a8e5438a3dc254b834104db88ab5b15cfd2457f9a8abd7562c91e697f13ace06866a01ce84f893f5946477e62c33a2b7d17d5d9ed0f99e8dbe1632ca0bf2fb33fdc12859acdd516b0c82c9fb74219a335ef36625747ba43d2a1e53a36ed62a97ca56537d2cd7db2936b75bdd9d528a8e54dc8770e303a0e1794f3e5451d7da1a7caa3750fe5c8b5014c9f8cb159059cd709d6d30bd1d61e9d62ef626eb4e0345d715da2142377e459aec0413123835ce15279457987a2ab3dffccdd888b23d7351d88c4e6cafe8063b06662e5c34c501fc6bf8abb34d493aa012ffeca5d767a4ec46b76022ac0cc972dc7c92b2617b54b77f1f8d13bdd15c4fa50f9ca20b26b4451cae6ebb483dca762cb55aef50da3aadcd65b6fb20ed67eeacdf1faf209d28c65490c424dd39ab6fe6fdc6d2704ca6ae4e00ff39d2f59fbf8fb3c71afaf99bfb83f090a1d187b7d94f8e05a0fa621691f7710855734494f1a891559e8a79f2bdf4f14babe0d94a953a2c0580b902b1142dd8f7494c72c1fe040e0eeb60f579fc41fd40d56e44c8cecef58033d16a435b7807f1c9b7b8ce7d31db33ae8588e57859d7bcea1810facdbd907bbd2b8cadd69456969caa146ce67ac9a81c82367dc76462ef72d46d555b2a4eb134658b0583a7edb08eba208f5c9da126c4a40dd73201b416bb1481700b5ada3fed4f5df3976905aab818a00e58a2530d0d14f119b5d3ba1060f0651846c176885d72b428f5eb4d0ab8c78124ef868891fb305eb86b9f8a6bfde7a41753672f4875c7a1d8e1eb63a1f1712040a67f01f88e6b33e22088928bf41642dab5d2dd038d76ed38faf87c3618beb39bd841efd5467f65537963ff292b028f55c08a19ecab3bed9e776035c2da5399ef686a408190b676be475f218aad5ac1b315ece76471d8fb5d6a3f0f66a296df8c11b236b3fe74106fa454429f3395f3b66aa035627768e6a1dca5db5fdb9ff605a0a867b537ce747a5f39a3f025263c7c9ec97198d1d0ffb3e3a1e8273cc9b0777db424dcbb0ff339824086f18c1d0446ab287fb7d4a62c4270f8e5922809b7467688ef4f3ee2f5c8f1be25cc9d62b9142341b73f94865c1bee9fb8631f33c681a24c86ac1129126756cc1a3c7525266f44950b761940a98ce8aa1df6428a1ed0eb8a03564a8bf03be67dca8cd4ebebcdd31bd2e8470c193dd477ec2ab917a72f96ce73dd399b50eaa49f837acd1d5325fdf8185641f0e856c3311919b4a064a7572cb23040ab29fb17450014f303fc54d162b8841849659dc8a4ee3806013b774619ee56c8bdd5b63b4f96da26adcb99e3a0d1565cce0af82c2b519921cad041e95eef06ac5a90af6e1f2755277474d7e985c5348935d544c8903f5fb24d54dcc62ad4b5c7c3f3bd15075b3d4b8a47910fe37998c273d6d716a4f5a0a279e05a09e5668c63e0d737f97bc446301670e22e2cd4514884f3dbc25c0d321b89e951cffd859c79238f71cea9d316d00ddf66cd4fc1f00e722443bc9c4b298ece59494b7d24f92d1fd59b77c44c81bd17f7d0df52fa25c31726a2643923fd2938cf1be98c9c63417d752c0de7cd32fdbd430f76d4c97f23c03af17134d26136f4a7eb2caf9a2726f647ae81d9086076e15edc3666dbb5a9fb3fe888e2141c3806f782ecc6e400cf5cff6d851f9ca9ea59672aadc70221102de57fe9cab66450efa30c812185829f212ee4ecdd9b83aee1b7b98a8a517d7d30e0d689aa813064b6cc7bc6c7bc388d2da5c36ae5a6d4d40ac7708807f23bdb684ca30191013c7b04773fee75253ef232cefe66d09541e8caeb78005b4109e4c377a61ce928919a64644e25d43a9ae83c30e20cf9e5bd8ec43b7581c5ef5a322129db07ce84f1af4685603e3a3ef5d42aba3391ece94ca1442c64230716796d2319fab7fddff118a724cd0437143ac219f946c329ef311d2e0de2d486eb47dd2cea3e54a6b45f95be430c1b738bf91ccfbe07179a684b7794ee4e7f7c604850fd2210cb7f0d8fcbfb89a3c11b3c8dfc211e3e7eabd56b4f9c7330d48fd3f076da7dfa23b9a004d9074cfeaa28674100b435cf601171a77c2f43d0a22984bab68e68b69bc8faa1fd9d515240b62f41f7126f58241216c3d9f81954235bf10903c91e02e35d71dbd3295bd1152cf77c2483e48c110b2a655fb53c55e8da3c308439f94771fc8177459e2895ee9b559843ccf1551467c44865576af0513a410052a1c4155e640bd4d45431f13f20248d9a48131ada0ef3349d1bb2cf3b390a18fe255cef0e5d548c65f8cf4ef274db5abe3f1e704dd010759406ab76d2c91d72ded46ab5c74021a5fa9cb13d436484fb37960540f39d3ec32247cf151ec67ea13284fc0d56caabd18815f283494cde2478e38ee04c71740a774349d7806913a64db681f2f1162ec5ebeda43e532a206c232021aababa5f844c0f1c05ff628b8289e152903150cd54ad35001ff57dafa72ea35a437993fe9a41e2402d46846661472f8ed5af6ac0ecfe95beb387deaa3de6b519d6b67af584a11a0e437b9b33b83f2e7fbb9f3a6fdb8b9f0ca56b128d3ef9cd74e4d385fccb9777cd8d003f8150279c02cb8bb66ae413d2c51a1518c34b944bd497e8d02397f4378cfd155751112fa9ca1663004cc2b86a21ae8fbe4c3bb7526f75ff920e209d2e2ffab0d3ba78f2147baae0795b78129545593ab05ccdaaf1c4d7c983feed04b6af470999c5dd0f9b7f0a3ac0c38fa6a72779a3cb396e9d97150397479c0f1b9d1570088a69b2e4049f72b4b37f9933a80daee6239acf1fd74eeffc085a2b56c181239f80b325e11da5de85c6ce0782c9613da15ae25357b36e3a1ac6378131fd99a4dc440875cdc8050d87e3412537a60438de197bb51ff179645028eae4dc3f3c6d188c9bdff53586239c0aeab078f70a8726f042e82b467336eb0c73221ae46bea8f71d40f4388d533e516957295fee51c7476fa8d5acf5511f66780b1bc5837cb9416262191886d0d81379f810fac476ea11ff65970663960782365f74829b0c8a087a1cd0408f0159ba8e72a10dd6fb984135d17b57fcdca06eee3f0d2a05446051b71d550a4646151ebb176198595669c8a525d5183b3147336497d44a8ffde803cbfc01e603ff8c582fad4b8b1ef54cc598b812c19c6b3c732f915d35fc893e70260293e84ffd8a1d4965d33df1415ad36d6fe8b24fc70d2194b19eddd556d791520b79ab8ccd24ad009c67b41fadb5ed5ed870ff9c4e5948d5f169b5480adc24d119d0124e70b84312b0f19e145550637fa04a5a29d5fd3d3f31f8c80e1dae4061dcc78df633761e4614879493c7dac0c98272bbfb435c6f0a6c689ad065a83ae14c6bbf5c2ebec824bd38c311ac29e854a5540b02cd1ffc70ac798e08ec140f7e0a02388f62a7b72d3b66464a62356c05fd6e69e127d7ba259e266fbe720136451f66dcea5f19f196edaf295d59d3860cc3911ed00d9b4e3b55215a2d2b82caa9c65be59c21d1da9f961f14e92b0ae4880acfc8ad34677e39c5eec9399783ec6bc31900cea782348719063e914048a6512df9ab83bb499e939ae035b6967fa8def84510ffc56c56a3f9dec732981a1bc07ca8031e434f69383370aed7f8fdc0f19aece0eb164fe817b6ddecedb7f332e31c6dd597797d79b14e59e66cd17b216777631029d65a50a3d60a72f73981e64e2d6aa887e192f8c20734e69ec42701407c07239d2de4c54ff6aab943e46814eb880ed9e716d121400e21c3fca8e6b326a497450e027a3a81abaa6b3e6c7a41d54e4bb748894a142c7902461befc0c71add39bfb898c77321967bd860e7abac6c6581fbf203a8cf0a8a4599e75393020304d5a75563ab1914b5bd3815297823330c227e095aa9da75f18fac2a3322a902f5cb6114512ef570a48569716852d3496406818e469e62d4ee94e5e4772dcd168495419ab1724827626609d140920624b36089a4555d5ac78f39cc4b23b70cb980bcfcff8366e6e1413d0b96689dddc21b274a26dc1370ce3d692daaab8a4aa645605c3513763efe89c65768c129f0b6da7b72bfa2e4e053bf940359b26be02cf593d2ead933b39592216117b413047d8156f51e0c090a0773059c0634427a254b8661af22388fd0bdfbeeda225c31a305e90eac1d86898ed36def23f8e2c077000c2cf6da877643662ceff185713d4ac5ada82ca465c2674d54cb794e88f1f950b4a3fcbd99c9cd225ce468702cb874ded643831ff321480b6fb485f31611a85856c2bae05400a45d7d76d7c8c8d734155032c9a4c01a1d5c36547dd8ab12d919d2836e72a42d355ff854e9c18ef9a6ea18ac2d47af35b9d89e565cb0010d03cde480da0067043c5f10b2e9fc507cb2eb537ddfe56d2e50e8bda6a7af8b3871c6075baf4de43cdf1a8c033d8dc928d7332f8c5c6c77666987f83fbdfed8714d54abc157c384b41351ddea36909148ae415ab3381374c171823a6aa2e8c925b2a169d4d930396bf30cd645d0bce727bdc0aaf340f4a35b15bdfa392cadccb23bb56f16c72e36540db31790ab97b3cae431dfd67d742a55163aa020198b20b7855d63ec01acf42fd101c819e0db2d68de11372b665428b601aca4c9d14f87cdc021429f828f817f075b0907b5384f85796eee519b3f2d51e08df1ce77bf9578b3447e78d2d22ea46bd05983104a8fdece58c9605d8e6c954d3a1de2d33847d9a50b112a9a06d8b1878dca0464acc082327a43892dc949fd9a7c245e3f22049b5d9c9f023668221e9cbb9b112cec9295da6864e0beb48a900114452ddb68b55dd1efdcfe3dd21c23c88f9f1d1e9454a22849af0fe07ae561286286499ef3588fe69ad0109608d503dc10aee2270fcc454beccbb636945b928d8a1bfec9b7a3cea5acb84607cf659a3d14450af3e2ed986742abdec7b8afdef1ad5f88c62fece17c422948b12c528801472be12d42ba392022f705522e4d9627cb4433198262aa166a16b54fab4cef3d0b885d565b96b77cb0a3794f9ffad20e75e694e7ee9820a559e1ed102731fa712758c35b4e46c4cf222e892fedc3f6f83d1207558621275983227299f21c9edc4b674d2e619d8728c5e6d62b5ccf1ab52449957896cba96ccbd843f4e8725a1b68f9f6261e7ec66d9e5dac1dcd195ecb0533e4f1c6798acf4e033fd7665e47446a46d0b87cf650ae61dec96d5cc51e6c70035b12f89a16a3e218794cdad0f5d6df331c779587b9a08b3dc2cbc2cf4757366c6d71e32ba69f58cf12c2e9847989dc51046da550c259a48e33763b42056b2f99056d7d8d2d4fc46f8f73e2d9aadffe6af295cd6eb0a42191add30618547f90ea38d70befb272ba43735bf4e1a850be68e77b5be096282ab19eb9792cd39b293fcd4a1ea09f51f300cb41f0c8724f417b98122dfdab8f0b12c52b044a9e49f83c462aaad8320bcb6acda9f0bbf1b81d1812ce5570791e52effe0c1a7a68bb03281cc6e88f9d9772007a5ae45f567cf80e6376177648126580c0ef84eebc639242ecbd05250163b9fdc4f82a92e195053d422ea702c82cd08b6f673f3aea4d178016da97419970cceee21afd29b76a588bd97b4f5845af9ada8e002a5cdd994c42984e9fbbc63ffe8aba25d5009905931b797cd1e10af113df2e929b83d1ae2e86adfa9af6d81b889ef740eba54d9540657e3c826a6814525746d1bc026d97b1e995cc5278dfeccc8011f45364fe9bdd6c78ed65cb80d17bccb146768731ec1bd18922d346add43cd93928efcd3672d134565a360167966a2b4510f84aa509427fcac83390bec53bc5fda3674bbf6b480815638823356af8a2b154a890c09a6a528971940c4541c94a57393af0e4cd2e3952f81af9652a16cfd19822c81b740009dcc7b0ba666aae52e0e90fc25a81d11e6e9c17fcdc85083472699904d274076eed7d7969ae06a6380d1c5f5d67450915f646b798a197f982d07644f8473fd8dd5cd9a9ea979699ba848910ebab16c28d99d0e0f2325639515fb812bb2a667f0da4b6a39bd88c180afbee12f1242c3a6f72343804899e1618b23ca1323f4473073b77e47f02e15ca4aca87bf11075db9dc5604597cf9a127bcc72f976daf237704624359cb9d9b649ff826bf37f0df1b18ffa8eaa6bd79caf05e8f1ae173b53a465f376ea3a3a921e4384b4e485dd261ca3fe989f89d8a1c8a337eb09cbd5b062031da0bed5bb96131951e33c9f4e70b4198f408e7a69a52fc8241d35e3120ded33d3465ecd63fa9a8c5c0c863a922a29d91f568c9c2c8d666db4935a55993d6155042cf292013fe2a8c1cbb45314f2d5fd41965daba6b348da7d956c052537fc828b1698410c721d99627b9d5ce1659aed1648e311642291608f23d44121f7bccb3f084d756191cd62907d71c90bdf1506d8d8cd1a3db99b1efc0f12a228256e97fc5d4461ecf3c847194207609e6e3b5c12eefedfa6be48c5bf10e0f63de8d43046dd938c002d2258a409c6b0a8991df33a4d804e929c15c828cb8c8fa95d6cc91e93dd6404f66d076565f808b625e6032ee8e25192c0926592696e35ab57c555a78312d528c8a5d17db4dba521346471c1476f0625562d6fbc0c8bfd23a1d5cf0b13bd835563ded15fb73f96f695e3d8a2f0bbdb0a4fbc1e3aa3aaed878009e8dbd864b9d2ecbb1b4749fe6649b36f9e8f2fa52c0c5b0eb8fe3645e806b8bb4dc42865e38b6a4556ef9ed671f8ccd6a3726acc5b81bdc625e84b04711671466bdd1ea725db74d9bcdcd5606d0792a9fbda9e3a8729f416ce954ba953be773fd7749e324bfcb74167fe1a6e3c42ef72414a3966385d65af344d30226448123e7ca058362dab3c9ed5a614c1bf7c38d581e38e510dc6ab3d8aaf6d2bcc7af02e24e1c9e9d295ca9d47462b1b55a0f96508778d954f5510364eb895b4ec26a9ff5f99e88de2ecb830efbb502b74558f0f5bbeffef0103d90bf667bf70f7c5fc256024702b974a0acac73bb90dfdc2831b3788b7979eb2ea0be653e6c74555b0589006e8a0c78842ada24e46c62620e170d43384caeac552a6067b0cb3cf2435ab45bae5d9355e8a6b3471c8d63657006f1501d66eccb5b7e611e91dc467f0b0476bbdfaa3b579436cafbb43966d9735781312c25386257c30d838071dd2cbceb975fb3330d82f34a3851d1b4a97547ef09ba492977f23823120d3f4a3c09482051d31ae976a1d7da92f0119068f7a9b1bbee27a2fe70a9e7dd26958fed0e2ceff3874ac07ba136881afcb19c9df6171cc147aff27f5a45bcfccfb77f44d4cf2d9490c034d801bbd2b4011941b3a84df6134ba33c097278c98d8e46a6e9cf2f30d54384488cb44923b30d410f5955f7b8287086d0acb30746f09aa81e4a8e8d487449ba64eb3bd1feefba716868c71d5db3a6e502311a454bbc7e4722b43def7a0e0ddfb183933a02d570758797af885ef362062cb839016e29d3544d906045d9b50e1fcd3596968d6169926770625551886abfa338fc02c74e63533b1062183ffb17e737d4ab54f1d76abde23208b9e873b56b860a2062b8975b2b4a8aeacea74a12bf075fe72d0f83898230bfa46116c01551f5a4186586733f5bc810495d27b317d68acb7f02a70719ef9ee9a800729b55e393d1244e2ab3ee6b331734866da38d4db5ae32650f38f494b2d7290b6a4055dd735de0a51f10b1908391d5cb34a15d9eb252459759616e48c6ae908c804ab7597716497dda763a354ab280fda01d4f88637d6555d65b692d9f0c04511eb7b05bed38d0f812b299da03b340616be014c3dfd7c8cfb998f13e1a36e7f9f1471aebd0fc913410927fa96bf6a82342a0f0881187810dd0a319cb5dd236e0d0b8d6050ef9f0eead70fb7f1eddcb187e2064b121615e37dfd7ab5020cfe30b4280da57021cb6b97cd1d21e3375befbde65d792477927b3be2ca148c2cb75474d12ef8b5417b308bffcde986263578075f31157998934b54f917d91d35bfd968a18207c147bdbe2d2319e08f1f0e761d99b3651427a96ff2043e7da46803a5416db4938f2f1d869ea31b848ba176eefe08259244c45bdd40fc62e0aee335dd13078160e31b043c07501682ef2ceef9b54aa6a37159b8270dd8311ca5305227f64c5f20be9b9b136ed433f20aee0a9d4b96738c3413c8b1bafc1ef7ff0725958975f1f0cbdfcadd917eb33855ec4d45a46a02d11e37dcda4b1fa047f04f9e0d426ae1f2feff0dbcd5450a4a5cb3b95288b953c82c83c0e458eac18cc88906377417dfdd3065079a1f1641900b6a20ec16a7096c71197a34509231ec64e21161ca44d656cafaa752f4b556533ee5426a2e0560d7bd7cac3d39944b89f5730850caba4161dd5f21791d86f7d2f35fe1b84555e060827bd081ac0a57d375d89be17a35df44de704ca233edf19ec3b71cbe220fa142202a6ceede0998e850bf3944ccd241c7013bc04d64d3b8b9e713d8a9e9f5760973290454049382adb76152d7d52980efa0f5c547908fc835bb43aa342ec3e697d0e1883fcf025fda8809b8949f113190f0e956ddc17ad08769fe4c51fc4c1acda2fc6b83f42e2828f0a378dc0708bebe680bd4b84b1a30c8acbe31f4ca422f5dde3ee85b7f2d36879e42f2698656a49070aeed5f64b43c4db67695fcb103f4b7753f615b541141e386273484e22564291556199d10a12b83dd3862bbd6bd18bddb70aec80b562d356db5051cde59bc0d1feaa813d57e6f515466ff53700007004e5623b073686335a5c3dabced9c7f392a7f5f1009ef9fdd653c13a45abf1d4b5110025e2e6926275ee3b048b4c0eaca734f1a58308d5a0c2db6806cdd6d5fc28a819495a94309232ff2fd1a34e9014fc7eccd10146075db9aaa3df5f777ac2c78f1eab60260a6e00eeba6f6f31a2883656f5a246c92496b5933daaa2e9131d829049b1678b3b9ce174bacd86dc45288441fb1e7dbda04c223718e799b25252f81d87736aa3d92f15cae81f8e12b289599b53b070be8598fe41fcba497b2b4bf5f1da1bacd41748d54c3cfed1bf8a69bb952e9ef273e4ef3686f2e547d2c4aeae871d30b2f702720e9ff11e9115d8a060a8cacbdd8473ec9d7d4ae85af1a379c2368811ca26fdfd12f9dda2967932e1d88851d4bb7f1ec84aeb4050da8c1bcc1062836a99d3b831460a3043c98592a9a1356307219da93c24bf68b431a9f7235ec47ed25fd24e3e6f2d5fa2d85107810a5064ded46237f9f6646d76f2227b942366a8cd3f24230671792aa2f24a15fe5f29c6ab882c05737cf01d967c7f3ea99bc1017e44cb677e2a0ca0ce576a17d4584c2f9dcfa80e88a96b17e2c7f7a0408c224069f73a8375714d57fb6a302f60611f99e7cb16bdb1c612c6bf4c75d5d76d8f18aca07082b6d312977ae59cf7de3a3b21eb01fd052daafd68f10af928650e30f7a8bc6a361d6a50e4b78ae2aaa83472bd9cecbb8ed49960dd93f6c2bf26c143e183698ef5ba7607ba414c04a5e3b6b8b49cf17f02b9b3137f085fc2c187563c08bb48a23357b5d60bfe5dd5c2939d051506200489ea7514b71e28050a861240460e27570f4dcb5bf18af7e352e8779337d74b93378ee2b8b9b7cffd3e803475f651e8327c95ba522354000c2d87f09822d483095b1b3ef3e7774fb05f65efc44919b8ac059bfba60813ab9a45d634854c0be613f1125d04d3bbf2d3a59746f881e405d02021bda2633876c55514c17724c9dff174119e021b6aaa46fe0c4af2143b8f891eef515cf7af1e5d5d96f86972bd4bb59508aa6b023abc655d54e86dae2cc530ca4e9af85ab75912c729d5af37493490939e4f017e46da3fe4b97c8305cac18247911695bdedf82c6cb1715a3a080f4444e517287b2a85f4afbc10caba2e26c781fc244fce4c1be2f64c1a1374bf4352d6fa1e2a1cf7036bd170e0039bba8e20cefb6fc0825adf53350fd1b625059aca260460a1bb3a4b96faefa80a3ece4c87bec142cb810b1f66c11ed80118287d515807eb4a589c6a92c4e411360f8291dd53d8a54e2a3a4e53ec0346e4b81edfb150e94b08aa0040baa9ab93908519253fb5dc546d968af63121143569677bf753782fe277bc640d4a1139293adc6c0a1ae04396cf847b5a74fd451b1b8f31d6a1b6535965947677061eda2fab7fcd64ba2cea3de24171dd5421f579db4b70c0f44d1257d9a9cf902d932e8c9e58f72ed0fe6faaf77d55c315449ed42fed796dfc44de13a18e894fe9c774d155b0c5d4f7999cfdfd815c8f365d2d2ed46f295e217ab69db4ff081d453fb68fe9e99803d0da2a29b61015a50b58817de03a9965ed2dd2a6afb8027fc8e8e2799df49c68eae41beded35f7861f500795bdfbdd654a315baac59ce0a3d043018cd90d6c8552fec8bf4d6f292a6b84b202cbd393f838506d093654a83a01187f7a2a4b0ba8f86735a279378298f06c54ea33aa703f4b9d9ae680ad0ae9fc37c345bef1bcde5f6c2bc1c54f349eb2c69e2413e57f594ce9c5573016b492f601657944b8157764f5cb5994fb4481d927b115082268c7f5cf2cbe8f59726da36fa62d801d55e4fd07a6e227159a7e1123d8d73e134f53ce29f0844ea230fd0f6bd710f1508d0e9d803345eedf457a391c14a434f65ce570c3aa1b1e34a5b0b54290fe76569c17661a8efbbe706fcd83a57ca77621a80d23660e9f0aaf531738c67e738766ba69ec274c3bedc5bddd2d705ff31adc794f4e979d34ec53d47438749e6a940062d6680ad175cab914b24aad64bee726cb658d612fd43209cf4493bffb7b33ee00f30fc6a08cb6bd9842d6b603dfeb35009bf64354e3862405e0df549b7a5c1a90194d829e88d9e45a5357f5f48d0c19f7a6be26652f35b166a3c986ada472ec516b1f3e4fca2db2bbafe10c835e06342dfa0b030f133ec6f0a4980206cc274481242ab206df62ada144020b0b772fdfad33a984e4e6a8ba45f26491199896ad889274110a8d74e1426b6df5dccfa49ccf115cc33a66deb1ec7093902d1f842988c528f42b6f42703a8633abd5928ef914b45057128d9b9ad53e8edc84acf2dd50081d8e49517cdb10e9297f7c520344c7ea40a5e35a9d69b3c7d1d05130079f1f0cd087e47df93f6f58568b7d288254cb89e0a39dc3a863590ca2914bce19056a0bbfb3546cbb82f408ab05aa2584d0a506277b52dfe74e0578a0dbf74de69c26d295f77e00e0bfda527cf078c78adf2c84b524f26b1988e144d357b969d42c86fdb2558bdf0e006e67a12a2e09cda51725dca7452d83a6f564295ee351d2f2260393d7825502275c2098ad60f1f7ea2b8aa4f01e4865abdbea40eaeff25909a6a60af05e1bb33b5b2aa1c95f73674d5a788a915da084828ea471405f560525264e21ca6d88d96a731041400ab8af4132a611e59f654014e6fcc431678b03ae401c8fdba72fa1698df3d91cfcd706221388231d91afe1d23d317c9541dadb7b89e9bad50a7a3b663f70e334cc1cbcf878f725788008b46dc11e4de24c4390ab7f3b552d1cecac1fde7ffa74c10f4ded645621cb47a2dc59ed86f0ee603137d96bf2aab5b87bb9213be010d8d938f24a53523c3673d472ab5ecb627588cda97efc23046c4a48319e38006907ee40aaca1e1e726f4a1545b58ce6d5a51e01017ef5d62687fb411eb5e00d7d3fe24d6258460ccf22c7f567d257228bf060eef2676d7885e18d8ea25b5386d7e2f67a359662fe7bb9b6cb5c49faa886ddd63ad6645b3405cd018f6ea36e8abb44824f7ffd3c63d2248219eb561760e20c93d6df0e922b06318d71e1c62c4e5117a8202a4d10384bddd30a8634e4045d750eb19acb95b199babf2429509b8c0018e90660d003680921475c74f6c620f1ff2c6dd629a4ab32fe7000ab8a55013c2920d019b5d8aa90331b10dcdf6a80a97b53c4f8d1920f6b61e9e2575ba43af7c7a2bec5e8951339fa69254add91aa2d039e5a0f3778f597b7ac2bfff1750fec11e00369474fd586de13fd91b31976fa83862f845eedb79f496e4bcf7ce44e344bc89901b398263f7b9c7653b3e3069c8545cdd939226cd293052030e326241b6aeb43cc63de7167e9a3848a68f1fff5942fa7912a8516435d7136f4892c0e3bf78a3adeb3b8f56e111668263b37c9877195a5cd2ce4a18f2a3b857fc88cfb733370b9614ab4722e1b2da11fae67b0edd36f4715c82982cfd2c841ffc3caeac8fdb4cc23994c8322e4a3de07798229d3a9e86f88e9b12e489de8c0a4c6344a2048a8dcecdbfe2c3c7b7bd6b1ff61161b2ecef1f773e6ed475b9e71de3fc3973a2223048b9aa3f9ba8f3e6b828c36bf8e7e40167c02f7fc3f2ad5a0ae8032a0912ad9906783acbad0ad83c01b9d7491101991254fd877c2575c32027195c346553968f24bb3c097ff5348040e4f08e48f17ced7d599c8cda56d4c85b3bd0862293f21f80d5564f80098801e6ded0d18532ab37506b815183bd0147b38747e4c401319fa1455c5c5930bfc41909656dba96b0365502129226f67a7831d9e84956f2dbaaa440a41f2cc2e6152de2bd716b7e102e8821fcf96571b34117762d8a7541bc2461bc56b494cae9104161980b788e48fda28f445979ebe3871c3de97c4234169d36bcd4a011291cac9c566c5f3b922467505f3956136a98bc7329e28d16f39e60dffc680b625f45476a751c7a0bfd83d3f703609c00e4f0d5aa8aa4847d9eb862cc87f01588f675377020c389bb8a41a1d56340ba1aec598355995edfd0ee8b5142b0383510212aaf5a4c66f969265937b210804ade8ffd6bd570f65bff20728da930244209db2f30aa7749b6d7b2aa25e93676867706cb4cbf3bd83071474199de79bf070fac034c6c6c9f4fc9d5251add56099695ec6ec262777d66e10572a19e6a2a4278aea75f7b3e773f02eb151e8a5799e4021dc3820b39bafa6ba1574605dbefb95d431bc860eabbf0baf90cd23f133938b9a98fe9a52acba95aea29dcd03efb91b508342b1c64b23cb92f90d2836887c78d7c39fe250c07ec71c7e961016e5336f8cb9dc649fda720597ad08b15f801c5458f574f287c2ec84542a8125d96cb704766c4a1d9be69b5b1c2ff10c1e638392aa3002ef96fc3d6a13a1642c9da32ece2d131d467042e2f74d43769224617cfcbeb41b3056f1c3ad7cfc9152efb98bab79bb2ce01c51cd49cdd2a422daa35b8032d5cd7ca0dccf25d2825968b0c22a653fb4065a142ae7ffc368815c35d52f23fd31d566a535168f760f330a18d5dfa036645c00fe7b72e0ad8257a5fd608b9633ac1f295c03156cc2ad9f17408ea7eb7ba092cf142ce8a4dfdc3f9436bb8de39d26ab15f5018354c1dd331ccaf8cf64c7996a6f6aa9a626558fa7a95bbec7d4f068ddcd38123f87e2566325540ecb8720a765b7458cb3aff094e70ef92aec764b4296674cd05a8aa73bf8a65b74dba56d83f3c384720a69d91b093b2e1129cdad5ca33a2e28b0f4ac82c2b5380d18a0e8a19ce0fa776b60624e2159d11e32b3945a8ba7e3f17f6d47cf245ca488b778a88c48188902d9e4e96466dfd35c89af88bbeba8e645a3d2a1e9ed338613de517d4c6c53d59889783ebc7e80dfe41201bc1c68a104c69434f59af93ed7995534b92017b70b01226090b0b8adf0039793236b6f8f9ce07659d1137f5ffb1594726428601c567e5d550e6b1486b308e28bf01147ef8230d18dab2668f4e2443d2905cfaa79e297dacc4e64fd7be3f8133672a03d0d34511f3d9414c69670fdd77d70","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
