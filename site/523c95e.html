<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ee7027c900ba3d308df1bb5a56ab859d52b62aff8400db26a46860966713be517ce6c24e435854f84408866eeba4a1051ab5e532e141c2b02e37a08eda224e6382894547e2bed3412eabccb0b21229b985f30e3a98f9a5f14a69de473ac86ccee34ca01afca7ae05f7d2cdd18f48267553cccd38b5a1261b35939dc3517f92a0d903d14cfca111ddc2142e52a507bbca1f75c42e7b36d34d5964f063bf1f48d3605a8600f09a9109beab941c2938870bd95165c2b502b80542a871770d27d20b7a7c25b33cc749c6a01af298d69faad5ed49202e6f94e8680673b22cde074bd707ce9e750da0eaf29a84a9cde7a297aedeb82ceee04763d071ae7295d06b76db49510b47bdf4586231c5eef2d407810d1d87ee5fa463e2c9c7b102033b549c363ebf903994aaa1bd9cdc47b3dad6e72be7140ea46ca50905dba2322d4dc5e51de04a7a9f0f83e0bf3c76312b74f36321d03dcda12653c00b1da3629bd340cd8a7479c7f9701bd88b883467dc40a0117f712be247ae6531f49583a3cbcf7133e6bb054b3a54402be9abf35e67098ae90c2bd33583e99641ac9b07b66db0ec3190532ceb150bd0ed57571fd26138abb9ed1ba4865d0e1df500276738bd1922b424b184a721400918104d39805acee8756e4c8e29343895b71b58d672136ca52e1b870668c53843337026252851320d6fb08604a7248ebb16a19bee6894b67fb40636ec993bd01cd42787b1896db6c071e9ee8eaad1125b7964407915bb9883bc93d3931f81ea4d41a6c670760e6a9811cba3feadab3173ad2c06aa60bd1fc940b0cbd8eb603005ea70da35f19b7384cc43b542c2eec0f69e80ff284525a069fc530ac80d571edadc49abdf0ef5be7d239e2bdcda50081d933eff7de3f5e30247db8b8978e62b8d4e118547e3c383f991f70a40d41932865d68abe2e83cee5fd816dc30db7c8d563de5809eb3c93592612602914a3884b0b671c342944bd8161a5887daefa766be10529bf86e2956498446a5b9f507e2558f47f29840d928eb8ab6b841ea1823f977e8199581353c10bbda31a0b881f5a48acbda57485e34fc87f54104010fc2163d9f16a7fba99c1570a6700d8a590b4fb03ddb65689306a1b902b6aa5c2b7995d3f5819b1c5075b4b29e888d73c4c421ad32d7bbc3c465efb56e68a4dade55442ed1843cf70192bb86bac2e35a31f2efd86e3b73dbcf37cbeebc7c2ea0b9cb255dd1df5b99ad5c24b3756271743cebeff57f4966a9a17b06f7bb8b0ee8f3362afaa5e2ac8350a85b007ab34db8501304599143d068524b7d996ba453fad232b1c29a53ebf10f03831369ded1bb8893627097cd8868cd89544b30e4df6be14e79fad52b32eb1d8dee41717955d24d1e504893c5a3773fe85b7340d361ee194856142540557fe57d24db557367b3ca62d09d8876dda4944e0d40e566d3507a1e725b3a0dd15e04a9532da361bdf0b5b4a0c079b15af2149ae235532bd88b4f0ce5f5fea7768d4f7f3ffe89bde06e94de426bcfa99b8da6674f0e5f75623735f2fd61b0203f8be10c14743a8a22fd998d79908f3bf9b078e88bc4eb2b265c6875ee5e6ff306e985729deb8ae9fc8fcc38f0b4a8e32ff2525bb9ebab0bdc6b5c746db3c1260a3831a96def97157558a8616e426d52623fc9715bbf83dfb883b0672ab0e97520ceb67d974432dc0044e55e207dc7539c75e971f4f5d1fb230dfe5c56b7be81e5d2ad705327d07e340f50fe454ba142c8c6ca12f657e8511c4a2cac96187f307c51507ef5ef68d519aedce623d2211776a6e4726b9e38c50b73dd55fc3455e477bbe7335671047a3dd96ba756b8ffaba9e14a48aa335596754746d8f21d3ba750c58471a4961f890936b0fb44266acd9aaca1dfc27eefa13269a864411dfe6adc4070a852726612a8119bcfdb8c068d85a9eac079d894534d30586cf587efbfb262eb9d04eead5987ce99bec97338441b8b2b1f3821c705684500be08b4f9df4056383d609c0d2b154ebcfff1c24a4d0a3bdda64cc63ee3e9cf3f3e1c349748e9f415280965cb849e9873198cfe20766c031732b622833a0efb1cb55bdcb0b72cb8066d63aa4ffcce70c2a5d7a4a78290cee8663fbd3ca9042d17df31a24ce55d83d45c3636a2bab68e425a0b98b6818c4e07e98119442caae2b8d75f587bfb9c8641305e5cb2decc620a60a20eab090b95d56f9527ed81545648c2d010e2d3cb28e3bd3e35e3d9080bb17804bae67748a73b1b2c08505d19a71c8690db1e268309b351773b972c944d2ac89fca24d8f5a1f36a512efc908c49a207ada4c46e3e19baab1a69405524e0afd95639c2251d46e245d11557a68935192e2449d514eabc8a2dfc695a713c2dcf6397d98b756d18cbe8d56b2b9bdf5f9589920e7f58e020ffc62534158c12c8524041a7a492626b1a030ec61d39ee89f77baa04ec42a530cf15151e191cccf19bd1fab74e64e4e5a1f57bb9ffe4e333aa89d289a5036e90aa5c317247ce8cdebedaeb21d70e9a5fe0fcd61e227828339bf5e40e3afb3f8192e203480b3c7431da707b01385a432498601aabb2966e05b74dac2762be742a73015462c1f2acb6b4d7251963ee0ae10e5f0b40a8bf415e812606e92630c90b4d483dc7b91ce4f7cc5fe71375c93598537c6f144319a78f60d228eb7048f9931d5ff20eba799df9e77702e51db563843d5c08aa2f538e737bcf23a89e9a89c677ff392c9b22e6237a2f2a00073e75f191fd8f39bf1a9278a61e11e32a4757d0ba3c1cc25b67f7d49e24e40fa701a12e63aab2c9fb2cb148bf74f532518e04a26389e913a62e8ad8f07af18a549944ecd8f8e332b04b5e73c6872d85d9601edcbd825f7b05fefb869daff6424f263cae3f48a3db826ab3d0d368f942486cc8c53468ca23cde18663faa9845319771b8390fbcabd693991736b4ca2c0f9ee6dc0c8791c22302c985f564e5f16063a54c8f5a4307913514c8388a561f3ed821cd3993e55893d637debcbddbe67096af7078111f3e289ad0d5a76943c7903875c124b7f1e3bb872eb97b90bf6638f0f6bc4c61770aaa2655409507b52f79a4c951187322cb1a5ac59eec4edabb93e5d7817f32c57da92fd6326c4016123d2d89534b9e6b877ea22d5f316372afc4f67f026d4f06c510480f9e1b7812279d20abe73ad4ab2720f3b2afea2bff1721b2a8a543d204e7f27bbe7326d914c2b0a207ae38ca155c0519abec1cd6f3a07aff25f526db1fba128873d81c68c1d9a10f5edb75aa1f251ea6b3c428a569873a095eba92b203d3a1e428690a23571d02f8c3ba159fc96e65a160a701fa7f7754984191be0b2c130ff67b9a2f46f13c74c121541193fbd162f64d073b48f16325be767f9e63cf4a18aa5e91288c9ab0cf9828fa7ed2db7ded9c06a79b9f02756dc0cb3b9c9760bef7d22da2ee87f5542be5de7ca1f757fd268599d1ab3baabcca5643596619a4889928b00b7ea008ca2dde3e6507e31bb451fa418b37529365e86f54e04fb6936cfac3ba9ca91a638467e0f49a699c9625d433b84e7ab6b34e9c445442f0a527f28990fb3f37497cd0572b130d30cf95a3c8749372539faee7f2a2d5fef777f817180bfede09ae0fed2b3e3b6c8da0e9c3e597be8ac6fbdeec10d03e5f786bca7e5d4e77e0767cf5be6afffabf72165ea9802d4e74e2fc2e68a3373de12ed30f3b334d1d58c368a1c58b39594b53eb5ecfab4f8b81891cf44f8b142e814b90b501f4663c2dbc6c78f1cab2dafc630e4165530fe0e471a7449c5c5b37f9033d76549daa18ded4dfd9814ac8612195fff865be152e2d01d71a62c40f3099f228117103571cb8fe872880e571f1fbeda63533ad831451a30c7246057cbca5422191e9be280e4b0f94470e8ad3bf85cf861de0fdd29efd459fbcc4d178e2df92767d4f0044cb3d33a7ae639f31263c4621d2f50499e8759d59026f552543a78a4327fa67d3290057965ded8be8c8a7243061071c83f6f4cfeba71c96188f2ce39aa773965c02358021a6b3bee38d6b9e2b4512d8fdc12470280f4389b0bde0f59b9f9c2af07faad6b0f8af69221eb811a32b0c2700908f9d598837a41dcbc14da0c2a6ed85b7f2a7409b6a22417334bcc9766224f271a5514da5b6f7736efdfd74b6a95cde41c316fcee552243bc963233a261982ef0bcbedb1587df5ef62ed9b71d1093d6214527fa673bcfd2a495525512275e3722d01da40f4d6625c206dbab7066b17e328d75b9ddfdca6380cd3f9c79e592e538a26bea41d2e45a3177e8e622e0f6a0e1e703c640233ca0e3d5447c26bfd95949bc77bcabc1325452cf48bf88671a92eada67dac968a4a236c97512ee6b960d3cb86a8d534c5bcc233ef3350bbed66d77bb038a4388d28b79da7b59159a9da9329ab3b39478d5546e2066575cdcdfd25e4c4127ae6fcdc541380a49e966a856bab6e4781873a4cb66340e86b72bc59234bfd2de9515860c394747884003c7915865f9f18ac0ab171c58ba664fcf1fb34e5aed978f5fc06e40f4b8359f6238b409694df5da76fd402e55ed3e2cf2139d215cd81b8d761fdb253f97603c78954f820aa5be788ff22dd5d8ea7a1e153f936542862a61ca93a19a4db0190ee28ff8cae6149aceb2ebca8feabd18e691283fe5a8a7b1b7e0ad4821bedbcf4f65a39191c9aff666f91b8c3b416937d74784d3174bbf597adae280e7ba87437d348225fa60fe671fa520c57f8b228db34c389305cc17278c812d63ae32ae742d55eff42f4872ba5ad4a11ce40452213fc365d98b11e18bb76d6aadd67770a090c94924d88005c3690641c036411444cc86b3f68cdcd96f679418357a3968125fb68dba41f3ec6f405721d8b9de4791689f3ddf93c2afad5cf551a5b822046becc60ddc540961c824a1167bd36bab58c96d111bc3ab748edfa4d8dc31c47cc0113571068dbbc00be5eb486b6f51ed61c6a5ba1a54be173ebeb0876697b62dc586196396712880b2fd1c2656fb6618e9ee5c76226e8f8e3039476050b2eb3a710436f73f42d0e2db74dd95f7240504e367513fe1d9f342ec7290c82704caa6b33be2829f0c2e2da10a360a9655926be10d1311e8cb0aa1777603139a5cb43ef53d783348035b49516f3a23fe4143f18778cb596289e4de7af7694f35262742943f39d864df6aea82e0726ac1853b3bacf93664935c571fa9c15c27228bec09cdd90555f0c511dcf28abf99b6814cb4557e4e082a2e5be15ae493502bd90218fb35f2dc5aa35052f6461a9d6d1905fa645e92c07be9a4f7b2bc4d918e9eb9855a0ab5824c027c6f5f851a343136a3079dc406bdab2a864fe23eb37b7928cdec0144126f22cc7ba724c9d1b4d04cf37e8bae113627a3e88c2ecfe68e6c2112b2e6f1c385f0dbaaf087e09af1ca3a81cc189c2b1f5a303aaa968fae3900951ac4f594bfd14e6020df0e3f9b9e6e80c16b9ba6a6fefa67b47a340099d2bdaeaeb51c0957529fc2acd2b47025292a6aba120e640b5abcc20b423535de11ed21d6b68db0308ebafd0d3eec5535dab4433cb8fcc79a548fc6a680ec68bd49a89b3084f5c1fb818ce7463bb58a0e7403ababb485d55fbe177c9093e235970bf635e7ed16f12ed8e8fc338818ce23b652aea8de3bda66b7a6d2bfbcb3576575270e329d6f017acd0df869d2b7f18ea4acd1472615d69eb58add447f828957b766941d56409a17bec5bb550344cbb7d4aed46049708079e6492c33adf16b895f09914453d6fba1bdddc46d942f86d419e7d7a3420814f01dac2fd79022f9e3409c7a704fa206121981ff47a8105c550ce8c7758aecc847cd86d1cc46e85d8ba0eaf1171d381262e3b12b086089777f06b33b3d9c96c8fab382a365de914ed24bb9f08210d845e13b00751051c20458692730652d9e4ca2acb0d4d5a53fc800fb77f54ef10c4eaf608854c25a0643c89d8fddcd0753704d28b4e455f27e8a07ba4d92f6a9b5bb5acc080a0298f8b24e206b3cfe3679ec07ea7fa9b50b3f67288d61d8f8a886917a7cb6af907ea486ba424b0eb4511996c90ba601bc428e11cc51731e30ee04c415aadcb467f8291e350ce921f65386362e752502ce573540baaa2c43353349702cb6185bc392d7ba1a2e02acfbd679c2c964252bbbdbe9a459b3a193a639f785919daa9b0a98391bcc12542a2a191bf6e1843936823fc6887805ca528810e5f2a3caf06fba6aea164418bc6408485e3ed9cdbb3344561a32e9cbc41c72820bfc9d926c61e3ed17e30fcdb15d3add9e022daf7cf7082b3acb6185d0afabcc4db224e19cc4e852f3949c50fea5ec6acb6c6805bdaf08a0e4b5d5f6fab33c20b0b895bc5931c46016e78450039201fec48bef9c6ad0e086fc587810b6433f34f8511b0a128efbb2f0cf3c2e6a32b8be4d68be5d12d6fe3fb4f037e363253aeb6e50cdbc41f8d9dfb21e214f2e4f1b5ab059608aad80e87c46efcdbfde5dab9cb310107a3f6af5836efe0e65aca002e098ac4b15d4f8f08beda2033e20abe05600513b4a5b09ad4f6a9de7aff1836e97dd198ffab9edcf9e4d6895d5b928f04511c1750c51944645c2613891f088c813f389e520a8952a7951e44aacdd5b99e810e2d37f479dd4d5656209aa090e7e9f822375827a76c3a6dec8ccc172fdb3df6a6b9902a3c6448ec4dd6dadab947a64cd1f100c72893f4ae1e8eb5fe8cbfbc5b6dc2de314c29d6e7b788b8b471e89cfc67da461fe4bb884213588c252cd9c162f1904f5a10694650956d8d18687da898586008031795adfb9dcfc0023d0eafcce6efde1595ae4eca054e1d179a01c8381659723f2e08b0ab27dde224f6b82145e157cbd00374516a7f9eb36c68a11113318afe72cbee1308df130bfa2b16f5b7e2bc3521062026e11ebc38c475582c4a28a45697f701f6dc0183c2fa33ab1da3ec759eaa29f3aeb8cecc11f6844fccf6f83c8eee0163680707fe424ca1ac23896c4d097a46180ff3b60e497172519498b901cad6958df5df5e859efa07a1b4a8bb93172227ebb1736219a20295f3f456c1a21db3c88b75bd868c189e8d0ab5675d4b27f0cee23294e16df1ce0e63043f990c3044aeb4b5e0b957edf171619c88d5ea61f67af7e7b0fbda0f0263b5bb6ac7a6121f60ee506514d06803900be328dee6624be8131d0fe00f52868e405772d4940aa57533f69c1fb0b61ba0f532b6ee36dc041423f0351b38d35cf7a40183d3bea3028a43e116e48154ed50bd420d066295e8d5800f7384152b9e6f7b2368cf2393a7aa826dd1efe576f9617c31c6241a13a41e8e958905228ffea7da0dbea1b409e3836236784e50d0bd2691fee19bff71dd62f0d2f708178b88542c18080415fa7a8501e5d1b8f31176dea079cea8cb4c4b9160d13572597e96d00ec23de6bfcacd2d838dcea9c1b7a8e7e8654c2c9a2075a7232f6c0c7a42acc37cbdceb4f618b15a6c777207bff68b7d13bd75ff37d0f3a3d34b0605bc27e3ca83707a8609f96b1bd63481582d98f94be134236d19a03cd72d43a693c13714516e9b301686ccd23c7cefc82514fc3a1996f8b4f30d8bbfba559b6276f3db0861cd685c22a8f3b1d81d4e313d2215798f324714fad3db0d39727e2b99957ef16f9d00dc31ec214fb343786fa9c900c1d356248505ca4cdbbeab5419dda96267f1f599083b369c1b89bb393d2e0092614e3968e8fcccbd57d56bfeeede7228307dc10a2f814216fc548be5dbec5077f82f2db61a8f87246a0abc1e98270c8abff49e8453933b8e2a234c86f9716b319e9335738fcd167271f030ad46b2db3c6bd7fc1d5638388d92ce8120123a005d4552df930ceba7af8069e8146c025c4c5cba6fb6616b93a93442d5375943e4479848ad4b8c858a250365077540b6296db7e6e61e9f85f072ee129c2805b1be5c80527b4c69cf32ede47a88190fd9d51fd2b163a8766574b3160fa700087d21f973192c92db27b0c86130ae4f02af4821c9522e79f6b51df00e77f59bea7b5dfb28456bff682372568c4fa8b5573f0a88bd57ac6992e49342a9564815cbfa265c1c68d2b6439d9c3ff3f0333db0d03eb9ff7ed0aeb3f9e7dc70bad9c376e356ed42e8d52cde4249b4de4865f3cffd1ef74e5e197f5f5983fffc7df63459b7d319b3049fafec31841df736a55defc745bc217f62d74b59d01ccfc41adc1d3f50c42e05f69018f343813ae729d65d50354435ca5e427e7cbdea54b67b86bda6bdda0a7571bdbd6d18d093802c6ce82806da83581d21f050311d51ecfa730541167a57bba7f35fb9bc5f42d7b4594d584654e9120ffc73681643b9432e7bf13e1c61d4baf9a4d00169c224720a459f43876b88a41430699a8b94d6bafdf6d5173b8a2ad6df7a47fea67477f0f46ebc5b4e3e88d1aa457766945f1d63a03a75ead726d72e709e1ea29de68800bdec93421edd38281937c10a21004620dc02016ff609afeff2fadfe848751a2c604168913fc307c7f104019518652263c5941ddd2bf9eb749bab850575ddd0b040c57db04301651111f02d5a7f5fbcd2d56cbc8e9c5704d1e08100f5a6d69b32e8721d82ff76781e389c8265d3ecae550dba84eec58891a9f87c3524a1d818266efface6d439e56b034845c97e3a503fc84c11ae604f12443cdb4ccd6ddcc12100a0be626ec85ae0ee7f0f524e01150972b1cad6ba37599cf4d20097d5466aa49a33a4840f96ac0b48557f074fd3adec709c24059ef59e2bed0fc470ee117b6b84491e81f4af2b4eafc3040171a7f8764a0b0ea9eb7f884cd28b17b1cbec3b6ebadd0cb12063e403c4d821095de441b1fe946df277554c33fdfcf42b1955db180d4b8a9229f89f63c4ebd2645f465ed36eb7968baf1c262f47b2c7a94c17451da552e6451de3a50088b93347b9a9cf327110d6b965e54a6bfff9a076b2eb55997ac060e163d1d53242af0ec22093dadc6d6477529ce49f8d214022b3075a285c06a8921d813be69aed281d6f291c413733386014232c3e9b908ea33e81c6a45d7fc9c08802fdd52f5b25bb776ac8262fcc72eb02a15598e9989edf76b67e4b55272068d61affcd7b7f967f18927d6c6853f4fc43fe4cd429350f428953ca89ee0f27c1f572e7dcbaf93b87966854ba5b76ad04d7cd3d456b2b35dff882be101bd267620953b4c6fc1384106c96eb83d83079f16732a924d7a32e3c3a1a4fe43505e24a328406a7f92cb4ac7bd8444f7c2f5868202c311c46bf2c294c8177e69c62274dda3c321291363f1c05840c7511957533934c57e945016490c4e8ecb18f58e4b29163d1263192f20e24f42d9b4dd8d66832c86d04a98d503ea495f661e35e8acd638c6e15a5ba322c49f501d24dd0b084e54eaf7fd2d6f74722819f49497cb477088353bb9855cb185c003bc3ab8bb62dd4bbafd722cd3b614ee209d14d0cfcd8f9e0cebd3a178fe7fff8ab2bfe866ff262de6ad722f30070a973d2a71c0ca4b4e63eb9c1f1751b538fedb77cd7b878f7bfa4fa79bf411eace1beaa9da19176e2e0998fad1dcf6124c9ee8106427bb17bcc4906d2004377cca4fe8ceddec445fd80bd53defc4727a209f3ac587db924a686bc62c910a090a9e6f377b731bbbd0ccde75f2b3c0fac39e8472a94be9c4af2d8e5e23ad036f8e7e658bd9f4360f0e00f3cc312bb584789104d5aaa20877cbaa17770bb469d04a609c1b600d7b81404e73dc54f4bedee0523eda12099217dafb034b8b8cc3a66e5dea988f1b59806b1de80d616c8e289ddf6117532f189de8b2a8e3d16f3aa6a7e33b80086c032330cf6627e5c6d28df8de20c13f2ca08de2ad169877f06309c2526e730386b3e04532db5edd3a56deacedfc178e44fd7ba6407ce82eb7f0f2b7674fd8803ce7f1a00266348b3fd3c10e9897c0778651b6f28c3b58414b2091635e2bf88b0c3ecdf70200558b99d2844de234ad8a119cb75c57f22725d81c9dd17f2bd9681cca568db8fef330d9c278a7c8017ce327a5be0de0b4183d5e5f902b4982331a5026bd3d63451d33b9232054ccc199f217ec8043984c600863411af5cbbec77046a71416a0fd7e9cd10833198f1d4c615c2baea35985e1662be7de8bbc8ac913d1957453456195284e5ec2001600774a4c44dde62bb61547208de3e1c88140277ff1640767d1653416cfed6f670e7090c7f8b0ba11f3a2cdcc4443a84594b0345bbfc2c26635f399569ba1f14a818b23dc72e9a7026baef8796e383a076dbd594f5332caea53d538491ecaf2fca57d3294f25b8b325894ceea7203bcff584b144a6af50a97da5f70ab5dceef6c84896bac2960fa0096a81f0fc6cb4190ea2dd9788feeef6173fca12b8ae56de014e4c07be9ee8280deb26fa7111108fe68e787de420368beb6c0df591a80a86b69211f9ea66505a29ffc76ceaf9426d019ef37f2bddd365fc89eddff43fed96bcc7d776e30a4ec0ccf21b956ccecae2ab7ae83d218f8f6f77327b87137d59efbfb3108ed6ba8f395c9b9cfc250ded257966233b5af61e23eaf18c4c342aee41cda10bc7847658d17084ad608a4cdb1717ea9916effa2b6315e872c41cbaec12f21acebd0d2ad5c0e73aeba8b68ec38270427f4015fea3a37d832c774d0bd86bb596cdbd236d02afe46b0ed5159a23c43d628e31df8707ee2087455f7ba0d312b83a5865fafeedab8aff19c6ee21e1004e98118626355f48809c641b0e9035fd5f79513c9d785c892c15e47ecd619376f0b62e8a9bf376543a163799f65fc656dc7be42b0585068db0c8f18f448d9a829a81aff07644f127b8630e265adb452bcb37f6423dcdc5be2a1589047bbfe92f50bf8491f9f8145ceb8444455f3c5bbc68682012f71c0fe753f1b1f85d19e690447497d49eb9ef5251a4fa01981af7212e51db5a132407380e633fcc16507bc3d1fffc2c1f8ac7747175d61b2164a849c21eb245a418e01bf272f76b7f529a4aee57c02c09ecc07b87fef37c45b77611dce354f540cf99734d8a13a5af0f4a9792570a0f9951d9e199eab476bae3fd759e98b1d769964ab0edf28b2209f1e1c4313631a1ca457eec07008042e7d5f9b76c8bd6f23fb43bbbc8222f3ec7205464cbf4cdbc1319414aad33f11950292647750ada60e8f1d94fab99cfe76c385327fe0bcbaca31b42b6260a700a8ab170522c48d0d702c1a05331f3393c88fe7a528f70df095cc518856aef06533c2eb12dadeeb3d03e6ba9501a9c57249b409389bc7e70b2d70f7a7cd9d79441c25a99d2cfcfbd1b53576231fd0b7ab18fa3546a1c90911f4dd2130f2c0c41045bbd55000865cee9a578dd968f05a0b7735157f39db41cc7de609b48a996e1d8799b4b58aada16d0310a9d51dd0bc89a8a539edda32488219a48bee1e10a5701b798e878e0d5c194ea52dfc212befbecb29bd400ad99806b1d66ba3c50634ec1fe66e26a5a0f6cada28389beba12ba688b1e431d689bc863100005f4b83c883eb2a1dd1fb21e179820a29ac18f1bbd8b31593986073882d15b5e7cff079c3f73e87e72bec92009019a002189ebfc56e2058f796ba26dc07c2cec2c5c571a8b458138ab53d9972473cbf46c468e00410ed93bf659c77e9ceccfd660699dbe48b7a6780192cb2d639b9fbc505f0f5b655b4273daba97a8cb8be4401b5a558c338d48b3b41ac85dfea4db1060d6afcec360ecdf19b10ec6f9161e54b39f4a88985f2cf17c49b5e470e72b6732c28e90ed4a157e28daf6c96764e2cab7ba595ac712b00297ea556e10991937f8e5f2d5afb4d724539c4b61d5edbc1f29e35e21928bbcea0b0447919220197fd433e882e3860a0e1061ed5daecaa0f29642710c79a96f79f7bed35d24157870c7a99355cddd2731d459926c2cff932cb66f925f0eb3305bd949bb9857734d4d32428aaa44f3c9237fb9b0ec4e89836016cf843de299032a44b5560c66df67d3175e6ad774046219c3f16b3d5e86fbe10b690ea81fb241656ed57a450cb193ad7bfc53dac938618d54160d5de6992658de3ca3ceba63cfb08d9f5db3f4c33f5577c62cfe54d6b6d38cbd1ebc2b5700879bce13fbb17f4c2d7f62eb175d69ffc263b624a5b7d04562c75c940ec7229498c784510ea710fbb8d3eb517a3f83135851756c202d590ace00683a3b244346a3ba5d474ee3224f3c5f6c5e2b11aa524ae736ac98c73a1bea365eaa3eed7ef446028d16b54c3ee131bf7cca01ba8100295922c2bb7475bdc2fed3bb597ef7ceba827882d866c64fbd2db84f53518ce25f434c42f002d147dd3e88190bef01c5c259d614a641493d0e52eff244153a0d84ff15d8c0e23ba6ac84386a12a5e4024f2f2ee4d694cf7d04813f9bc6421f8670ed0ba20f9a93fa493113cd6635dfae191c180a39d97ca96c748e1cdf80038580445cce23d9c6580af41050b8713c166d3bd657d73c0a4df473230a04493ab7b07b3c4f6d1d96e7cc8994dcc2bad1c493c0dc691b60846f5b499bce42491ac8bd2f22e89099be56c40d677981b5c89b21c8420e968c9a6b93e5f8b20adec3ac0e56f4fa00f8fa3887b3994bed985f56623169c0be6cf018bd286f724628db78f4ad213c22d7b148155c85a4f399f64056964d845457547b549f9820a62e4fc2eab73bb3ef2d0ed546cc99cfb384e93bc2d8fc6d1f52fb6d83a4c3ef5ee9dd4c6ad66981ebc042d8b9a7ba5ff13b6f91053344b0d73452204cdef5cc43191729d12f12af9f7e03f682384c43143aad6dee3f944daee922346e81d3a96062d6ef71f4d65b37ccde9e1b375c82f5a52a32963740cbc055125809385319b1c40f3fc04e26366d7c1da12acbf9e8dde8c409055467461c37ad823dd18561c9f0f4ac5567fcd7835df2cd51e15a1c02024d137a754eb088194e9d95aa87a77a1eaef7588eab5daa513659251b59a4bf94a3fdd1e2377d9b2cb496f323faff7de4ec4688689c80fbbc27654409114bbeaf84a66edaa78e6f8ee5b0b9a50c476874b1aa8bb3157f28e3322ff0a5da716325b8cb4e5237f8df5cbd7bba6cf7cde090f9c73dcd53dbb91b19c2fd815101edf644b938ee42b93f26272823931e23bc9f024e8c1007ee9a7ca5e3503615e6f0c0e475c7200d388c748e8a445e841a8b3b538c47e2562116c0bb1a4b645d22bda1e059b14365d581141e90159f76f13c07c65aff6fac54107723aa227be830fa11bd0257f25ca4cf12ff3bf1d5aa3ec603d5c7f6279842b9bf80b114b43445d93613cb93e6dfaa1527aefb352f16e5e49d9716a8bf527b6fc9c9a0bee616d5f619945276c213ea9979fd90d23da52490df5986f7c66a7c7d51c1aaa854586dfd4823884cfe0533f3c870fa4396ccbe1d645dc827094d81d33697eebb0ceff7421e202e70ecdae32cc1893e4846c2c9098901c570610f0dc38b1d6bc330874558f80d3201a12d66fb234ffb6dd3d0420acfeda50f2e977c313b0ba89827aac9c631b3fe292c52b8e8ddedb0542f910eb5bcbf9c766b30f997d2f656ebb13a3e1ba3eb7d0721e1818921521782354fbe309f4ffef999116d67dd4e817fcbf09adb747c05b388cc79ed5b02c0baf0c8274c7bc77a129dca2a8e7a148fd2f2e3871d10abe369c454b5e68f7dacaa3edb8f1a7054e899d8ff6e7312ad088154c3aa0ad2e4afddd1f7770a65ce97b3a803f398f569b438ba4668d5b3bb7e783a73a285dc94f4f30616bf5cc0b8cd9db1c6fc37dd39c59cd11d803879239386b51d9f138b4234a4e3a2ec77dcc9eb10d9dd59671360bad0f9056436c475d87587501542f24410740b1fa465813f95a54747f344175705272cf67851b3b05cdd3e727cf01d4069f41bddd87ae9ae2d7241c063e0c9e3c8154eb12c467e54b28bd6960d4c2a0cc7b2f44136157590638b1c4049ea8c17d3d5a39a88f9be74dfac2985f954f5e91f0bd4948fa0dc1e8e031379f5c4b32aacb92a17aa4fec797befd83f7012263066107fe5e5e56129ff91ba5ec5e886d0ee64b2abdcc982ce3ebc654c2e4b994c374662b30725a00ade870d379c2fca2ea5d031f954a8c646a2e396b9d75cb6496b9ca4033cd4ec5c30d344393114d9624be897d8b378238433324a0f9f29b0b68faa0c2e78a0be7493d5afa9be42d6f85cdc54d0070bb59e8cb1f5ae13c5096317fc75b6c9811d5e0fc7693eed85e87991f974fd34ca6378def93bf30d9b1bf14bf9b9fca4bd51552ecf4410ac309061aec28f3940c975151b812955cb1fc6b4ae4a95d484fdb9ee8d77e2a2e1bf7650754dd9f5cec389cba32e594096eb84945d17dff817aae7719a3a6f9da231518","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
