<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b91bc99442f435882ab2578691d8a60d900ebcaebf923416e37490b4fa733298237ba993d22ecc381f45b965afebea28d1eb1984a8cbbdf18d41ef9fcf69dd9599447437981ede017c6247f03765aeea80f516b0180c559dc76aea18b8923e17826bcb661b08c88a93389783de9fa6fae69095b511be13389e970b34dbc99f66f28ab7aa081d9ae178c2d61955700484983c722c045b3c7c954e00183e16cf874c5397c86473c1ffd603e6a47e75ae9d085cfec0dcd827bdbf70bee6022b485d56306e7343ace92c351fe4bb4a55dd1fd8a210024122f42c2e3b0a2a9f454766c72d7483d09db5900f8afa4b0c75bafcd8385acf36e04d76a9a2a79092c4e920304df61bc4f4f6093dfcba683e391e31bd03f11e348fe02ad1f5d8855de0b5be6e3d8730ac5113533585824559bd4cd70a324e9c48677878bd3e7d52bc4d98ebcdeaaa706fd0632f6f996d23d0b950caf32902ef6e2c318cb27e8611a5fb1777987bef1b37ab796134c0bd7eb8f47a5e8d2bae673004568c40d94e837db11d508970daaa342ff62058526c119dbe32c5261aa07609085838785ccbd1611a144c62e524590e491b85d5190f354c26ce15ac3ab92717c023537c9a4f2f04c5b90aa36b40f69a249f405b1933141915adc768ef3c02cb8d1f1bd250bf5c540d3f5db8ee73599725868d0f70b53d6463d9391587dc25b399ddc721c150f445b8a4cb399cf898799c5e6c15fd9f3e43142d6aca89c3d36eaf47114ec43f70f5958678a959eff956ce341ec6c8446bf3003f37d76e2936266c282fafdfe4ff97047dbf0b03c2caffe99c239d4e280b88251d534eaeaf21a86745b5b81bcf6dbbd97e428135c1ad6ff262467a633ef48a45a5d79d92b7e1b9d9e0440e64487c104938b7352e69d0696c63d9d03bead3042dc0411fefad62b5032b6bbb70f45dc258fa26eefd9f34f4c782554f603f6bfcc3c809f278bf02a69784241e3fb78790302f08067cb76defac92ac50683df755d155c8f54cf5a36938fed194fe34f016d5a6b41d1a624a85a8014699c9277a79136dfd8ce150e33e8be2d2f9c615cb8eec19e117a9845c8f01bd4c5a311338fdbbb923e753be69ca9cb63637d2f748c11dce606069cccbccf1360f0b3ba323cc4a8376d42ea8275e8ec78b06b87a58bfcf81ba8fafad0c5b3d5804a1a1a3a4fd64d31225d7fd194b58df59b2f3543ecb4d7ffb98c3f897572147f22bd5992d1fac89673ebace99767fb13d876ce90938b1c5c9f61299e62d2e50a4954a258a1fece3623ff04f4c995668093e4eef812237ba493d2d6d54384b66926b2ee9813f358a7dc706bc9797b595f1829f6a3a6364243e9d6dee18a1ed41e195abbf8c6efb6ae2348c4b7464485bb1a319b6199d59ed0c3694448239ba6bc3ab404af2dc8452c76a3babde12149c3711e639695fc6c6d7c11b0aad194048f70a577d9c2065e3f8cd1e61772e498921c19e861ee24c1f01403267d2e45b37ed96754fbee361e498566b003f603b10d6cdc6b221cee4750304a70a8d91ba36cfc48092da389ae3bf98a47e6c32163a389f302c8dc411411d724027aba02b9f38b70c62af7fea761c51dc39d77513810f646b1b850dc9a3b2ad6cd44be3a63ea864df45887e40258ba530bc55a3e7e46ad3881328c6f54ba44c66b7e1f61e01204bf880f3b41c94bda77dbe6993f714a90e6813ca986a30b4246d09d248fa7db4390ecc76a600e3c2cf06cfd095f09b122f462719a3b365cfc07ab67441d4a9b1afaec0060c0876e88a39729c3966cb1ed66c791dc8a21de249e19dc6f91c65936485d582a68da7d490c0766153456422439a1bfc93eed47e5ba7777db77980a54c2e2725936b509d29bce41773fdc98f142912619c855960255c6c1d4ce4ce4ddf491dc680048bd3c3c8da9ac193908dd51bc03a2b1a6cd0ab561f7b800406ca2d00037f0eb3206bbca6953ae721c922cd05772f24e794f317a880a06eaf19fba02a0edfe7cf6a2fa853608c602f11f7723ed2ba4aa37c94f2a710f29e70d35c61f9cd9b0d448bef2f7d9065ff27a2fd7814f7ac57ea29a68da7cfce1430b997958ac6f676f1f2f3f2ab573103dbb25d87e3ed9dededb5bdd6f4a04f7b8181637779c5aeb71b51d03554f3d0537307ee76f72a0b7787d879c3d859ead7702f12ae97c1cbc2975931772bce78c558b0c52332595ca13fbfffab32cdc87edaf3d03c36fd2a317482f3df6b81c6adffe9b6f936bb49f10eb56225a945605e184813c3899157725c8c14eeecceae0cb5c5ded657f6a8ffeba81d4f2c3ff22e0a46ae8d238320fb5f4b1d9c814b1bd5f7c30031b6fa5a0a9dcac35e244858501ece1e6553168678bdf7b999e1f3fd80e16a2f106c2a23e5c8fdb6fd6ddc40942673e73f9c3a065dba7da7bbd8f03f029956fed4f005afeffbd06bd0d710d3947a52d006c4d6a419e832c792e038eaa3883fad04025a533dbb1467eee22bb0f10e1d601462cfb3c2f0d2dac0994027e0af917b320d5d9831695200b8a6f4c6ed65a2fa6d624fbcff25b146cecb83891450f5608a07ec8dbe606882e2299f329a6f0d96e00d32f26ff83c2572fceb489881e81b577632309a2f591d235b8f6427f2a8dc2993017c0121fa20af56e9878b30853f7479b25ad5678d80b4855cd303bdf837ac7f22940e570d9b8042a0757a09e0c9361756bfa7ee0d6dd58accf662f8b6d7d9a0240e48835b9d16119475bc83c510723f63b3d0f346b2fe6a7b0b48c6f6859d39fb1774fb61dc19663453f153502b149bcfa9a48df6e2c68ba89b78f4c66cd609d7c4d3c9c5e74118f76a185d25e6e7d218d5c6b9ba717f9adff2322f1516b95289473844882af830fb496569d24bdf3372f30f32239a8e1eee2153c4cbcd5dae9d5b2f5ad08d1e6aacd6285f5403fe81fcb50190cef9643b24702dc7679d6a8720a79a6073fec002a772448ffce8b2506c9d0936fd4015676e541a0e9d9e767932678ff4cf94639db2f5b61ebbb04fd3babf30402e344fe1a93e916edce1c6de379eaf66f987d79530ff88626cdf2f7747251484be892f1c0f339a5dd4870253486cbc8c1c16533c7bc37bfd881fa2445b2c149453b62bf9bcedc20cdc715693b6169e2cff3b6ee005d8a2c6864f03812482bba4f1b6994bccffe9dd3eed6e1fcd693445105a6cc5865daf487306215b08d3e78644da656b2ed3485377ec515065cd2aabc38901de48c7082ee9451201d8ac032eb09e5cc5f6be72eebad7179ca1ca59f97d7d80bad49e51fafc4e586bbeb4e5ed67030f53c1d434983372d7296fe281a451b20cab6a8abfe4bc0aae76c35cae5a4178de8d5d68fecf949f7f6f290dabf23ea04a92716b747285417fc6b96187dfaa916579c3790bc393513c7acfa03ac0e7f6fcc441647fc1b20ffb678ddebd19cab691da6ec92e61b04723ab9a8fe4331353e64adcd2e37cabaf2dc79c5b92455f6052c63bd72e2d390cff24b768dae24fb12f434279a0148ce48b54d7978509e14990b3e3b32e94c46b561b7a8737298ff08237999c5369087d09bc117bc9a44d0d05730a7e866b56e71b0b52d7e4530c76f59f6bc47148d8883131512bec38bf36814495ca82576137e3e2d47ca6661d6817a7e6d931f8ffebd433cca6e19c77886474272e427f8a8bbab0afda48046f02fff3ee461b1dc9ec661513ae7736029b5c2b697bdfaf4890aff758c4331dfa34a587633059d93ad3ea5be23d2457663a417d6bf139ace795d4afa77b5b53d0b90db56f5821e74ebc609132de2a9e4fe695cb786f2342f360deec691b4e0a0bed093e518b9455a464a57bf22b51289c16cd60fc3d9007d00f7b9a4403fad75d0d6f4d5840b9adc24846fdfca81a7173f15bfdcc803f14cb79c705d6be78c2e3b95d15af9c8739033ee3d23bbe9adfdc3f8b9d63cb0082b7df5952c1fdce685033a071dc4526369e79aba37ee69c99f2a92f99339ad498e4104fcbd90162e770d9885013cc5e8b4acdaa9075c475ce4df311ff5faa54948c32a8fcb1ba3f59d507ab6d64d226d69fff75a7619b0ecc68228e08d57e435dc8747300d71c9a5f2474378163e4ce4dbc3eba78389ea36ef214f0c5d2062d97f0083499789d319ac349d153b1830361c00c02c56c560e8d3ffabc2cf73ae651f311e8f20b43d545b6ea962b9ca1ea479fd8b4124333c7ba7dd99cd60a6ffc0df7245dfeefb4c4b06f7b30f432d299f64f094c8a385fc8ae4e347315ccf63e8b3f82128b6fc2a845015cae0a03c798d555fd0bb4756e315c554eb7b91bc18d50ce9ef457b7d2b96e13ed02b4e17d508c0343c80c2e38ef3c50602d391ffa363e7f4e3a3c6083fe52f2b2bf2974bf1cef89f4efa46efe7e7ec76f80e53e7a20920edc0057fd8971dade0332f1c06fac70f76028b5f919e84b494dad3cb98039cf29229c77fe040b53918d18a8d3ad1d54295d905ddca669873d0a057bf6683bc1a58245a3c1786e4de6283cee4d05b27057f2ca124504139c963e53626027340cd3bc9f4013b1ec39757f6a1216d56811ff4a141d66efb9a6715bc266ae277ebf0ffed6f19b032d335c7cac7ed989ff2acb2d26fc94487b4afd8965a3f1a752641d1866c1102dc6122255be8d8b7d0374b4450c86c32df384dd0eba798818ef51bce2c0ffef914231bcbec920b04811c87fe74b91000b9de5b02e9d617e62ae919ddaa1b3809854c23725c688a794fdafc79b8880dbedfa0092d44f837c34a40ce8a51534f6820ac844c8b98603163c7df1a23105ae31f537d4f1b09261cc2136ee7d068b8c0fa0705d96b0489a2d0e14dea7a35f56e4d3bf1447ec8d0dcdf2fc2afd63022c82072bd4f45458ef4b80c5f5c2c6f8cfdffebf4c12348ab5b489ce605a2f194c9efd4ef4e2576a4677963b91b323554828c1c5b4abfbb641330f84944ecb5449c474bd8f091b71dea66a11fdfec720f7b9d9fb00552b2b15653569bc40f2110bd4467201bffc92b9cbf126ec693d581567de47817d913cb5d24fc0b94c7bd1a17e9bf4d7f02f3b75beb5e9c98bf6a86b3997877c75aa74ad6a77fbf5353f027e6479b4025dbef1a865cc04e499401e34aa1080ba8ebc06877547512e066a75003f5b4526bf477635c8581c2fe1068c3e5e0f77780e33c1cdbca16976cef2eec4443b4688fa22b8831186e5e708f7957e0bcaaf2093c9afa6b154aa334f07ad8779978f3f849f9c70f04f94bd22fa27d1bda6646c8f8833d017b1feea5b7fe0cd0543f0579d81db8032c310a78a55ab642692ed8e3d49f49f7774258464e18d3556697dc75e8b508dd3b1bd9ebdb247f184f650b58c35c01d158ab4e0d27302a13e800115c237d36082b0b6866381959062f75a2049524859fc7777f33765e36ac317049423b45edfe813408a1b5e33bc78778e745c0c8b518b47e8372b839abf1b6beb9ffd3ca5920a00de2c5621a1c0cdf4fcae6c969379ab474b5deb973288d63636a88e0dde6c66dd397539604393d1890da3e6cd2dcbd9e493298026f254f75c3568cd7a60e3166e139411d421a00c725f1998cc768716085c9cee8b337b93e505e08cefd31006e9770c0e435df134665251183c8b4ea7035235cb1997400d5eb446c7b8bd6a07cca19680e69f8be805e3885f7f211ad3509ad990487094e47ff42f325df52d6c1f5f8b49719ce19523c293ea2f54f072256dcabea59f72e44a07a7cbdec6647403034454abac725cd7b4a2c0dcdba9810fc6bccbe733bcd86f134e3eaf49cd2b4182920bd4a57dc050bd7722fb21ac205f681287f6f93ef252b2ccd31c01e96061bd3b91b4bf0d23d48a3b2b6af5c55bc57c1558495740553451389f193c2c30e37a35ee365c091f8de3e0c4b06eb3e936f01ae818fe39d0a8a21d85f2f1ac76e26a6861a342f10b2fbab72ea2b3843ca64f49778e30e43afee9cc3492a4c5dd0709c48bfba5faea08f10c5aa9726c5fbb5fa8fc50f3e13fa90665c20adb896a0ee0f4f013459efdf831ebd17622b7fcc8ae682f2e35516b72e9655039be05b1dc4edf7e730ed3308a0892a0a9afaa2abf90fb91143c555357995d28c2e2e7e8af4b427c69a05ff0d6fcd758f075b39332677c4278e0b119b139f622cbc55788004a70c115cf673e7d675a55db9df6aa055d69d57c4e73ea9228a5b23c439cf2ab085dbce0014e505d4f0a0fd753e0eef3845846295fd6fe45871169882b50c4628c74946df515d827e52944b5880b9fbac9b2a921b23bac8ade84aedee70a40eb120f8893fb5a478a440bb6cb03dd42f3dfeddaa757ae25ec6b0461521897830265a317dd0de3d4eb725b99482816a867b1c35a8d8a0f45a9e2b0df1bd95369de32c435bd46494a8aeb28ca23dcec4fbdc63ebd936dbdd1bfe980d239bd0f3b4c7bcea16bb97c7d88d1b366f096542e95814f03a416a3d861ca7d861ef364371f8610c515e4618d68eb2bd705091be32d9e64855bc3584dcfa87d5ac1c331146fe3e6c422ce89adb4cb732b421ccf8878611246dc7d2c4eef705d593763940be10cae22479ba9d106c2f836db268870aac19a73ace35438d0aa3ef079e83171114ce92c53e172c9471ae861fedfcab4e7bd4c13ac80b70d607dc4c00102aae2488928563090d404c69e6504bbc0da674eefc86d8796c79cf049dff94472c2f139b9bcb2fce78bde29735569eeb9adfb49b58733f074d7a58d1716eb8c9081c27c519c4bbca41e052da745b803fce527c2a8a4100bcc661caa0d6d2813ea76c159d5c15bb09b4af30c105c799b84406a34491bb0e9ca5041682fb0c8d210dc02a01b67520db72d01d7c0e6df891597bbda06b3330325c1a517ae468eb3b456ffd74fc44eef7ea170c127302d231b829b829bb7abe234ac68bd90bb7bac2e402b294b576759e63696afa956a3215b4ecd410ba6620e58879912ab2a5103caa41c27beeb434ca7ba80b6785f03853b557fb395e4e4c2c538094d918cf9ebfd5e66158687d0663c97b1193b56579e053dd0760ab1606ddde2de78dc53408faa30026faa4aee0be8da4cb1ab2a973730f3d89f5870961c1126f97d92040f926d6fe655d3d6a10d1ecfd99f025bf4485873adfb935063ae1b149dde94ba1b8f75b79468fe767b8bb8c84e64a9d24d7da831f5fba6daa3b275ecdcd07a9800ad36fbf84a1874b1fd2e4be613ec3feb7e6e0ef6d8a4509e5caa5942f703c0c63b8ce9464cd0cfbf433dcdc9990d1cf133b292c9c7b6876bb3abc653dcbcf7b1bdd79ff706b1f104ec9b1a2540ec3130ef5123ba4d1c38ce0ab324c74b50ed6dc27924ad6e39095b8e4a89c99731aaba138ee2ca485d2b1e9b177d2b34f85062ef1173c68ffcd3d554ff7fe4b17405725738410565dab947a084c81b8979fa809aa33968662ff22d96cc8fd21798e7a77e35de9ccf5e4e06d260a584935dbb4720c2a1211ecf9c7cd77308b64afbe8276a3e000c53c395e70fe7012c54658866ef08a154d7fd74e5cf4efa2b8db5d3ad3373a9e8836a348462d1bb7a8dc78c53c646c566a66ae4c741dbe45b552f2885044d3074ceba5400b1cce88a7182cf1f2e42aba8580c177073107f9431b19d9bf757c2e7c84b72b0f3f60cd9646895e5ac7ba98d2a68ced4ecd30a8286949aa34824a61d55ff9fa830cdd4b01d2b44b1f38521e298ce43a8e75040630176c588f9a92b02153e13ed3bf71f1f382a2bb65c885503ed045c9aa82c10cbcc3425ef324413761b09851f67d1beb6201c66ab8c0ceaf82a0ed3e19199b4a95faa5d78924ba97f654ee4f23c2e98b0b79dd24875a79492a771a9215f23b7f5a41cdd442ed394a9cfbf4d677d08f6f4bb0be779a34e4553c2ec5169a013daf9c1ebce07484670825bee4c9c52a6188c3910bb0e96462259721cba707d0225f90a420126956fb3189d198a324414f2d3101947d1c20c871f500823c3487ceb022de9f0437f2cbcd9b405d5a047164479554308461682aa7d333b5bc64d9e378ef02066f095c7a534cf49f6738961694b28424d7c7e2b781626c82d961e327ec837ebeadbdbab6eb0b15a18fe272f3c48c0728babbb745fbe73dc4055821b8ad68a577ca0242b7261d3d84047f6892b67bf58f84447bbf8ca64cc455c84fb285a83514c527367528b319ffdcdefab0acff7de02bd6047ec47a661d9ec1d17e6f937fb32f5e938fe3e1e7432c26ace725db415b8c70d9ad7a4f26b28ace01873ad9079c8c143a3aedf3e480ac0da85efb5d0451bf89ac4dd68805ea4cfd657c6b9bd8a4b6b67e2d196f187458aa502da4ba685c0e5f6e18c642167f68de6347b95d138018a98dea8d3499f567597150b1dd6567dc40fab316195fe4324c5a133d7b5c426716615fff2331c9a7fe15cfb8b1797563e8e47edc732279a71af8d0024ff41f63066fbbb81d68100d6093ba0af21685e311abbb745c88bc48ceeb80442ccd51af46d9567e6fd13a4b935bff7da3a00b184a239d6f16b391332733a415b00c09b95327daf13e1bef5943780f67513aae2361ecd27295670ae042a06532d0711677ef78f1d752f15cb366ab1fa6aa1be14c1ba61c809b84fb5484df3143de4e89a2599dbe3d1121cfd3647533396a8dd69b58a928fcc0aae66b444cdcd616bd65b1d18a6e11f759c96e9a07a32206f4df9ef750eb1e8124c1157c6d74c369e1ddf4d884ba2f96b5a1c9ffed0d98db97d28c6fa71c6580ca599436d6a0a512c4140c3fe8dae92aa205299c57d2f5f3478ae67ce3b0b6c18c923135f2b7bd4f690d151122cbe074734c41476b7af4acf46d2cde266acd55f9a33904e3ea8b62aff8b1435c07bbeb0e1f4fcbeed853c1bb8d7cc1acbc2eaf1473068a9244f567cfbd6407fe0d586b37eda64588d0b7c7a46e0f7348fd0320eedc6fb55c3a710bd16838b6482468e2f7ab1d1d1774c5e452fb0633836ececaec1b027dfcf741bca1f6713c91f6c8616ae725158375fd0d6aab5d85b8f69de846fdbfffdee5f0b15758dff7dc7a107d9c823d36c76675ef78d552f95503b824ec769dfc0e259218cacfd1042cb876eb81624cce434c55f03fb22a2a013d85b907a58f9f52231e744690e8f6fc4dcf41a8001fa06521c142bef7ea5147d4ab1fa6f397059a29f51403402f7134a50826ad7b6e0723b372adc67b84fe2b0862358ecc287389238c24091a01c038f75a6236948d8a153cbb86986fef155774b1195badcdd2ff72788afdac6c6a74c3f5dec500e0f03d3dafb61ef3c413268e1424a8dfbf841b2233b6a0d7facc818d14932faf70c03cbcc842743adc220e5b8d4ee95392766c372357dfc38aeae0b0074039f74300502bf94cbce366e386db64c491c7748b62090cfaf6c30301900ba8463ee8c6ae3fcb125a961d59298b8e70e5b70d0e0032cc606f218686d80912dfcd9fae902860014e566889f95abe26f67026a59570ce03663d002a238e32df337132c7ebd4779ef2ddce6424a6620cb69bef64243413cd4dc68c296d917480f365198ca974bbdb0d412ad65095bbd5cc8a45a4d85da9cf2c8b5732e7b0f8873292bbc19133adc398efac8b53be2d410d837a2f0a2b573e1df59e34835b3d7acb8f2be7ecf824e6210a493935cfe601c81c65b64433bf1a56fa2d39f89e299ae72a059c5e27f5158815f29683232876ef0e9aeab2237c7554794fef2e4c1f7a2358e3721f0779b33adf2bc9069b2eab8879229d4a1616ad113ce2345e1ed0a865cecacb9fb2b15661d1879416ac4772cea245c334d5e0350cb230c3c8e4ac980fd88f2b19c72813d99dd1427b078363c2523aec7bdb2cc803e3d245e783db21aefde453dd4e7d5d96545f2630327993f9a74cde83387c408a09a6a76626110b4c41f4a07c43a4661fff117147328b222c95473f33016a8f751c66618f104b97fdf323c021c6893876fe041648393c527070043b5e612976ea98df640281e0556d28ca858b2d50f0d032bafc1be14d453c99116c0570ed7d8a35e3fe89559753edfb56848faf2e7c278a971ae25fbfcf6783473aa3f17edf614736940a49ca01a7be4dffeeab2cf7e2636022dc9d202662c8299aae13bc3f606d5de8a38087a24d1eecdd821768e6335466c4a40b59bba88e7863c1e6a31ebc9a4f224c342a45772996b714cb721c3c3e4bb48bb21671c17d52a49f7db6fac299e86fbd925d4faf443ff06f559923fe756c7e0f5f0a5f4c648402b5345e9bb32e61dd1a1868c52ca63212cc5ea9d618367ac74abbd07eed1ff7eee98d2d411dbb3241af2fb6bfec2949600970dbde6903a48db931a27f4d09501c0f274d4e0c2c5afd2bb93c655406135d24e336d197b4aa4a74aab7f60b957b61a2320c6ee8d51dea3ad7b288e89b501c32aa6849d52d4846233bb347c8047c6c58628dded4690f6233ef7194a283bac1eb7528f7bb2e59a3b2bdec6ab7075737e92d249aadaea8d93737b375d811033559171a34c6c0668f5c09b3f84dda5b9617e1685839c7f3a93e0bf9dcb406db04bb65c00015253479d53d6e9bee2065692f2f4be347d6bd3a33d30f544af6e3b0ba316fd000b76d961ba95e79d7344dd5fcb46310fd2f3bccef2abc01861e4e600efcb732de8065ffe850caf7d58a42970521d93f5bfc9180ff52554e73eed2ac64c5a12085d827db1930c59f6977a7d09899d936962ce32103b47449bd1f00a772da5d8f3dc354eb313ad1a9c0e98aef3ec2e73079913f304efc697845f0d9d54a0bab81865d75bbb4590b7c6396bcb0a32af0b0037595fba125bfb5d77623a57194f0e62fc88e10a5a7f9e76f9d5179d6884e97129835f967aa24adebe33dc3ed07e93172afeaa8b87efa213814b8e550b7ced02d5d99fde031b4c7f85f5e74f29486dc64a3e75f941354c4f44a0aa0e2f51772b038057a166631254947da19ba61fbf4e319ce9aab34f43900d567ca493b0be0919c773192f1109afa84aa3bdf7f0364c9043069d5bbe664e067f314bd0e8ac0ba16e27dd7b914e2b054fa201812282eea59a9eca62ee60c5ae6b9e8b9afc9a5c30e6f22b619cc6b586b1ceeba86c3e6f56c553b373c35d69d61eec6dded7e6802ce41bd802722acecd03b8aec273e6498083a60254b4c32f555ad1281883a58ea350bc89eb3694cc90f93d936a8a7f0083313b4f51de370029bf71475c5c8722931a261bed822244099ecee5e74c30e72882204c2fe0e46c004fa4e147beab3035e6527270f9e54bbf2fe9f452fae21d14f47068aba7057f5794f987b226a96ca7d99394f2a54ab8dcae75c270069b6e99299b3e96bf99c0d815949aed45aeefa87fb3a5646df3e240e36c3d9be3202874558c7581110b657c747f35b5b022baaff54ab3811113387c4102184d1456bbef6d585ed973307e47c23a05575e84ad259dbf9650e164264de7d10b0b439e86d50c17d805ad3a0a7c5d0b60eb1dfa3b8aec5a5556d67c3dc24deaafc2714e5bca2ec868baaf65f9f7f03af8a8b0ec83ae423ed603064b397e7593f52e950a511ac002b4ebae57e57a84231aa16f0506e46918d978bfb4e585f8702dca4b5d69fdadf6fff82b8d1409059039910efd547c816e98ee80430df5befc9254a3cf6537c5bd45fb9cad0ec7ff0a5ef5b750bc777d151da1052278d0603a5162de3bfe1f62a9f1f2435674645c3c03f58af00f0cf0471d8d1b42b4fa44136c07f2a0ec9b78afd6db87fd5d009a35dcb5417c6a086f278d43b565418cd8cde68e1768502880ec313f8595700a2a4d871f9d80f45bcbb6a19e67407b946f6b593f42453d3c080d9e596b32e541942d54a722940bd6740254369ef05fe0376be2be3c399b361bcf663735099b01cbcc5162ffcc388bc53275de4b67c409d891051725e5d52b713b6e5cd1e450b6b291a972393b815151b21df378975d221d701f2c084e70cffdde05b7417da77adfa27752a838fbf84d3d31499b1ad87870b8ae3128e2e8f3a0bbf493fbf4af2bdd51b35de4d05f6cecdb44600ddde76390d7b47bb413269a676057d8550bb4b8b2c483887ab8791db81a3f5d88f8ffb1696c716a9ca8913f644888504b829a10590e1496b92eb63cf013d17b04a3d5dab8ef54b880637ff093e21522b9a31bd25dca81284997e1d3e97216b71057b58ee682466cfc4b2b50b2d2ca7dde89aba7559ed46b9821a5366f5a5b2effda0b06c416fbc672f8b400f24f125d50bbd800861239df175f7eb2875ea3c9eb0508ac64d16b092dbbbcd42c36f58f70ab938ab0fd449240dc97ba81bdfcfb145e52119d2a0ca2842936a61f66690769ae50717bd8d935af23eac3a01cece39849a1faf0409bbc75e0cbf82ae22ed9362cf5063088d52d01b4986c8612e3695fe18e44d9eb4caff9d01838367be152c224a9d224f3ab67b1beb6bda970808f8237e3645bc3f2b02e187d4abbd1e38885b215be0f50c5b2b1b7362dff0a311ab776aad520651a94efc02443b286b34f99a4dfe3392648cb959265bfc3ef2bbc4e39a365ba09cd5972f4f6444bea4c949a76030d0bfa88ee0c54aaacaffe59a804085e2b4861ff7e08e897bbe6d8cdbaf3d53b18f9907f3387fc504043b1b86d03310d86b83caadb5479a6450bd96261de6539e1bcc91810ccdaea1370ab9e860ff17402d66372c5e06ab35fac50177588807eb58436fd6f6b4d369b3054c245686f6ada83814b2a396722b107adb0b1fb3b0c3827071bc2771a7fcdb6eb52da6899daed4fc123ed414d665eb055ca7888bd18e6effe5439482718426784584e3a00f6dee7d87a8266658f50227aa49a5b4893f5409b1bc3160087b7535698043ffa64bdfc4d04a30c936f464b025ca0764629ee994cb1de67005f60bb7cad61c2117def304f5bd6e1d8e59002cf74968fcc2b3ad61120ad786f24fc24254bef27c80da6c22005dceceb75735d3ededdfeb28abe72d69885069d64243b4fafaf1abe72ff471f58fa31b98134d52978cfa3d967c137be00ee44ac554241e2b435ae7c455d6856ff3aa94d6e60e74532ec083033b1c839cfb19f14981ea3f2fbdef88a3ce20a2adb588826a6001b0dbd714826fc4c04b6a5b493863b1c952eed1ae9af92f93c826330ec667e15360b5778c457ef11322043a4096161e6115d9f51635d819d032f8958cd253a56d0468d11993c2d103a7a201afb297ef20ad1c0c2cd5300f9aee4f76428db216773f273a066d76bec607e2e9bbd7a82de8f1ae471c3e151513fc28ee11e06ddf8906819e3c970a0fab1cb66313a72d7b0694d1ed01ff94ead40ccce2d044a0dba9029e46d27714716d3748726a5d0e7776533ae1f0f22216c63758b6d2835617309d300c2e75d7224746a0523c890418f7763d6c9cfb4890839b94017b351cfe4002a06d4c933bba546c10e6f2bdc884d112f217c718528a9f2e7c01281ee9ed01bc021bd0c0978935b325eb70d32bffb08b7990b7ab6461adadcbf2031989fd059a01ebe64ca5a6cbffe36729e91e8fe75c4261479670caefe934cb0a921fa605dc55ffe3bab1229f56ad59f612e0774c10a08b67ee219476146afcc47326496afbeb1924db60aad6b007d350960c55eee34c7042d06b57bcc02260d4bbcc2141dd878688a99a12d4f2bd97724f8ef677a474feddcf390a36d542201ce4ac779a81af742e9c293f101dd8340bd6b8734de8528a035ce9deaa1a73ca0f331a3c6aba2ffd48cf61045edc0f5990cad643d5709a1a4c79e3acc7b5ea34cd21b7a1912b48fccd3edb3ea8bf48e0f4b59ed573afc8a54302c6caddebbf4faab6ac097df0b78f47b249c35699e9f3571cad233e7317582b91ea93870072dfa24495a5d3e6b96a8aa8c10dbe72878b04d0236f4ae8e8c2d591a69a7aa217fa566ba92ddc916783c9d5728534fe3a37caf4e644b42a92ed46dfb1c2620b09cfe95c44df9f66c4bb8439bf6e148e8af275e9c397283989c372d23ec9e96e8b1761fe04fa2ae5dd6eeb3b089178531c32f4f915d21296d4392f3ac3b49fa312eddc743585144044d170f61e90af5b322aaf3e75b1b10d18b0e913a8c4d67e476ef8b6bca1ea67f744703e83388355ae6ac1624839316affff5916f2a23beb9c8a68c456a9a4a0b4f90d81b1f0706bc1548c84aecba0db57d3cff926d9f74c26c178afca9dcdb07c7d92204f6e3f5775188f2f5e4c495d2cc2fa72b426e31e8aec69e56bf54d345dde9b6350df2aade5b8bbb215270b9fc7aa4c35238492b2c6d11231a40310227ba1eae29f71c1af90cedc7363100687337a521671fe8573d752ccf20221b7a6670370aaf0442353b9b7fb5233ca533d036a77b0c38aef5419277b2e16d5baea2856199634f99ba862cc9403dd37645b2eb3387615096d00c60292a6b010e1ccd26b666e52a8311b826aaf1683e3f20ed5bb47bdb1e1bc93fa6dbebed130602be25e9e3aaf3d444e8972a830a932dfd83270e77172e3a897d907f9c7e03de3a57bdd3a0735f2a5b98165cb8aff8113775332658a09549d62d990b7cb0496e284830396ba06363655f919fd913cf38b89215123dfab9ea8dc88d89733accde6e3afb6b4d494d9870514fc6b18c530f6ca7a3a","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
