<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8edc85b974d04633456aec28ee2901f07b0b3a9471030f1f6920060bed4aabf8cea5ff1ebd2edfd55d07ba2b989ab8287e85d23fb74de6d87f1b57f1f7a5c31e5a4047a1b72043119dfa554ceeee98e0d83d7773cf00a0083079a2beb82c4b7b2a066ccdf7adf29a39076000e7ae521b90c86a408eb03ab548e60a756b926e6877bfc96cfb0a9168c6711baac2fa04ff559177f55ce4a0f3ae6a05d6619872acf03660326b793835a5d86180654c174539f4e4938fab30dd210da3537874751f127d86dd6974111bc0aff1744007c50dde24e99766d151b9c1b2124bf594a87dec559553d82cb093e99665c6562f0ba61b1e791e003a1792e298f2df6f62b7555f7af415be91da5a3de8d2656a81932209caad448e394964dba5910715a1148dad792cd2b2e51f22094d871c58aee8ed597f9a340ca805c88e0641e11a946664fd3496e014f79193395619f014234a27030b7b1f36edec44ec34a8178baa3635617592778e25e56049cc8c6c83680fd0aa2cb85a380bb83807a5a9d817e5d123695e563bbf5faacd3e2ddff383f94862425142bce503a518050d87dffe3f4f8303a02a22fef3b58fe8f10eea0589ac7cafac7f5d3ae6ba32a8876406d8481932debd08fa75e776a8c635f3b4440232f7d489fd9d2077b5ca73116bc0ff1807bf6c8e764e19da8092f46b2a523beb0023f4adb00b56fa76c8829d21cc45b43b8237ef32aa8753ae7a5d3677ce99ebad50418aca9a460096d2c73767c74a9890580c99923e63824e898bd0b0d824b38269da722d86b99a2360d218ae9c29f6812c204202d1607f4e6e6f2058e5c7db63773f8a1baf5f3d9fb667c22c81fdb2d112d6a9338955c22b21291e8c4f4f55518322d84d19c4862c887cfe9c74e1b75fadf9ae047c9dc5dae3bc807986820f81514e1e906d6c79dad1727e95d3b78095aa236e5fa25065db17001a43d478864b1128059a696eb8a34196769ea2dc3633b4ea00e29729c92cfef7bbf6313ad186048781a206f925135a4adfabddf3f16d59df1ed956b21bc35841bf1d9877a5a7c2f6ed6cad366e19d743b7c13b0839302fb96bbeea7bcdece6937cbdaf11e89bba7f5a085d8103a020e7437ba188bdbfd2a26c46216015cd58372fe8c690d58b02499502c3989bb319ae538fdcd8ece5dd25bc707e918a52d3a7703af87dea1827419d448f5c7dd60b31563950969e42b0cb0b43de6d8163ee1ae5c34043628479eceb622e93965bd28d66ab0af0505edd3c2269dd43abc612682f211022a97a2f6b2e3d6640f9cafadb6e1d0add8de096940038ee11ca0d0c819d7e30cb50a4acd12aa72b322ce54ddf9f8dc69434452de83057424657ba025196e64b246b2ab1b455beedf313137b07964684b6d7cfa739ae6fb751379e3eb152fa0ffb4d7691f0ef2f81d6be87bc0868881bf634a9be9402ea1989533e092518d3dc46f94db3c76794f69ff21797caf765b289dfcf7da9a509207a02e31cf9b9fe67492b360f6a8bb113b76770f9098b2d19a157c244c48d57dc857a4f318b3943abfb33a7baa1da441ead6d721ecb387c9d44fb71ffa3a7664f549498201ba15a8e2aa7562ff9931481e7daf785c19ca4b7432a605fdb48bd0877a37786c5549306752a9bbe42fd76bc2e605838dbe233ecd2f1daba7e251e97e9c83decd0d2175d4ee5246fb74c3339d52de321f48a239303c92c4b65a6120d85e250baca3be46c97e46f5a6f1fbfd32496991c309f59b86569de24daba5858f88436ae3bbb530573147bb700a3b4fb35dee9ded08c4f528a12ca60cc4b1b17598543f183f81cd468123006ce35d71be265265ec0eb7db31e9b75042d050659b5333aaff33161969c6a0eb10fc3c2ee98e99249020e3629b9f57efaf1e07691997c7b9aca46c1bac6146155b714f221a60419f0723e50029bbb843a1354161b47c8005bfcb33c62be065937f1e8171a1bb3c6310a0c20e5588864e08e9dd67a80fa2ee391163c85496baa5ecd25001ed2fcce3dc0a9346604c2931bd872557e28dead381fce6903ffa5aab9d81e68782571a55d2b6e054b0c9d5167ddce1256934cc131d470ed6af7ac3ebb86d312c6b0765b01c12e37d93cbdf028cb42a1c945c010ed2967209a33a66b04a58e3eb60364ce637b610fd93bd8e1686f19a5d9536941795f158391def8f2bcd3af02ccbc6ebce1636e90a6d10a2bf9fd18ed0192e80f6318e94407a95cf9dc9a22f7a456a41595c034e31f4b3de0002dd21190259b64fb60551890a6d394e7920dd84b815d656bf0b9e32d05931ef32ef02274b2ea10c34b8025662e29b387b6952a4a456ba05634f37b51666fb811bb938a0d92b1edab90145a47fe171851159fd74bc81d33bac9e5aa5666f932593e98dc04259f15fa494e53ed5b34ea45143b31e97fab46d1490b4bb8330d514426f5b926699d37a866b6d3472d1efd91b84d5c1280d61a224eb7900d288d77d2c9f92db59b8337f16795362f156f60da10df7823d6b1237be99d12d5e0a0a06c8448dc58ec0db05c5ffa754e7016b63bd955bcaeaa7dd6eb64e85c2c7dd7f4640d743c53e6023c2d456a768baf2e127870fa61c3959afb7489fde96e8a1e81128fb15dcb6f22e3174e00d6633589127a1cffdd6f1cdafd9530e74fff991bf1fd72a6e02d7f6860bae17f3eeb21235477bb2f74be4bd3db7a4e50e686715526f4e1bc8a9d9424b282822213ed95e6308d22d39d680dff57e064e056a58589831a34186989663acc8efed12759d3d097190ab19cfd9d1144f8ffb764617326a260c652e46c880d42d5816b4b002162914c4f4211948dca14a28028b92531b201627d1d6c69901b3de93df08fe117c78ca841d32b4f26051da263616b08ed6260c67156ccdae5a364fad12a281da274bb4ed9a2a3b2bd0b539056dbe39bc4242f73e5a075cbdc323d22ffd6a42944504740514209515dc51b812720ec9678a75918291eb7a08730dc1a5e753c735aa8edf0ed8b021891bf632da5c5f4c62c8d2bfa7bc04bdae32f01e04ae61ec093253eec0b421c0f64cb59c01b84575e0a6ee1a36d4e06aa41c4cca500a82ee88337b77caabe70b6ca20ea6bda6f5065918d4d533efff021763d86b3e864119b8aaaece28dd39fe96b2e39d6e5bbf75245d25f78485dd44325ecef75d2f299960cfceab500e9cd3521feaa4001c0ce83c3a1c44cb0e2d8864469d6bd0cf3588310792d8d6afcddea849108a7cee285123812e74f052acdc167a6d842611fa1d2e0961a53d4af8156a093fe44f440da35e60a38bd5468eb8ff6e30e536e658e0149c64a9f38d6c4d02943b37f6c63be482fa78c05793fdb89049ee16a1eae3fd943dda91b5dfb04571bc6ed18c658e028fd4e246175fcc7d38892cedeb9ea2646ccde5f1ebc407120573d6609b5aa600276cae65858d427b89d07c26caa31046f09869a9e98061eaf3d314c3cccff1d6d7c3345ff99c837bb095de18ad4f9e22f014b5b0065c21db8892b218558b45f7cc11006a747800c3f829ffccd7c83229c1ff39cb0058c0a3c0802d5ecbaf0875d9da5e36deb842ec72bcad7f29fe326deaf5d1e0d8e1d7593e877f988789bede0557d33b49030cc4a426369010ffdb2a42ce50daf0dc56961ac79e65ad95f102f310c6069da69b488d0f87dd0307eabffe32e2566a786df0c8d57f91acb919c548e26a3e32e91abb124b8e251420565befbcd58d9dc07fbabd9a968ac05be91b4868f2dd44f971409c0c6edd5aacb4f01e71805a8f6b601a07e8ec07819120f42e210ef18d9d5c0598c8df5314d7c74f30e8c3babff1631a3ecc9d039e208d5196f89947cf8d8e7a12f826a19acccd7812192e67cf3109c771a3050344a6ad4eec261006b32578ee36442c08f9d7af36bb138d4b6e46e4ce753dcf436d0806571bc20a0b1dc7d3e074c365eea2e0e43d0f24fb093c5e72d041b0d09eefb037b9a56b182343554f6894861c6894914acca1566d8762b8affd4b5362a874398811a1df72f3fd9d468d6155d0477049160d07bf302ad55c24487c670be88d04e392cb3684c962b32eae14ca902ceabf55f13fee186f4953087d7e8e4a63946cf76694a3a95eddcda432fda22684166a28f835a09275c1001b23c50eb5802fa30339bf330cb2edda071c7d1c5fbbdc3a7b6a06b5842d5e04dfa87172cdbdf17ecd7142143bc00b3dd1bb250bb59bad7a7a768df1dd31ca7b5860b1228244bf2157ebc0fb9cf56d3f8eee2a624a0ecc48688074216e0b487bc26f901d29573b83d287fbf80f4af6004b844accc058d8c3fa0f7d3c1bc49ca845136e290de0a9f5f285e84baff7b5a4aa947e7f7e3f50bfe2c55278d2c4b967583c8b1497340bed69a9eba4b90b73d65bb6c236dfa85ed12935b2414012ec1baca37f0d99de2ca2aed79257678201749c90f213767fb62d44312282dd68b8073de0357326a80c74c35759eeba339a467818cb87ef232820b427b4a564c850901f549c601269e1ea1f8b14ddb0d3d7d4195100027859834dc26ae0bdfae0d04d70aa3d81b1de8a710b1e0bb2b52b837d3b17a517ad813339f601cdb231612724e48512f1311d014e270433d1505d897bc74bedd2580fe5832f3548309ef7a149d3691bc00f4d4195ccae5576e48a20b4aa1b6ca65aa252912d8cd4a701cffbdac2117930e4d43607cc119905cbe6c2c10202eb33714f0dd915f46cf17109032b5163e80312a4fa00152ab3f9efd14fde6197b27408a505cce2a2877d79a27f472ecaa26b3384109bf255f9a30fc93f66481439060a197301336a112532e62e586c4e1739b244d68fe13abf1038f764394b32785c784c2c0bffafeaa8bc0bf77cc9a76c3c9fe9ccfd66f1c936694c05e07cc760d5764078302c214a1817463e85abbe9ebdca645b8d5d24d94ce24eaeef8ed52c5f0168083dc691267f85edce2f1210586ea6254c4dca250a0897e899d164e126b93f233ff7a4923fc2093c3501683f4f593f9a822f0e70d053849dd127a3604408cf54e00af9ddaed5ee39894fff35f622fbaacd3210c0f9061ce1e5444961b84a3a443df72e095af09cee41d7154dae05d048157568a4c876927995a4f045add6af5b363df2fbe0e11bc94c00827d54a35c6fe0cba3209085e1147bb4ca9dafea9f5cbee5cf40a7a516510941a8027fa93a1df8c143102e7f3013d48968eef98b175d91d4390322c14426053cd7e18619a60bb1c235f6feb47338bcbe5ff6b9efad4c7a8b04d4a47bcd1e45dc3b39dd44b2605ff3ba2812bde89aa931c0bfde94dd83f65ed432d81b85a5bd6f66dfc06293b45a804b5308dee1ba43f1412d8eaab22c44f8dbd60caee16637fe061015885e39fb3a00e12e99eebe68ae972d5a768a8d2707f91b27640a8380443ac3cbd92fe277119701436ea26fbf3a0d221af553365af0739d3b9f93d5fdcd8f86ab6480d1d9a91f1308d89d99d137110391292ce6c9ad1a62119e4cbecf704dae48dda96b4c22cb524d1a84110d3446027ae69b6d97a161a2212076f1918ccdbdbda9605ffb20dd17b30df9d1e09d91246319e66593bd02e3a5aac8b9310e781cb81c35ac941ab47b51caf8ff57d71a030096c965d29fea7fa17e79a77c209881d9020f6827ac30e44696f5be0b4d69ed8bac1a324f358781e16fe3621d1b853e4b5a51b93223c89dece026178285f2b4f0a95713897922a353193589376531b205f0ec997ea41db8f43b4cd58bf6568477f52a85a30781e93d01fee5ba3c72ab467ce95085bfca6e9a84fe87a5942ee59c0bcc284c4f2f9ac4f8031bdd9f137ab31afc3ec9d8d06126198ff71da112bb94deacb9f21e7ac9492f42eec9d41f0c92c9bafbca3d2894e99bd912065ef199fbfa62f527e0a7c4b4df746b0bf22c0953e4dd45ddfaea1b614415e7eee86cdee4188f57f042785514b2c5ef94de3261e55157701ff516b134d50eacfe53c8356f3b8c2ec635d3d04636a8fe176dcd130ae7a47e724ef99c9ccd85662d8000ff1e7f1fabcd21074cafcfff6fdcc0d17909281556ce5614c804ee66ec772bbf5daff998787b277b1249800d56072f7b8c4d472cd7f2db4e8f0dfa1fa6f093ca76169268c5fc584c7b1dbefd06bd738506194a38d9ea7eb14d09f512f58889c0498b3214ab90b561dd061006f3ba530010067967fe4002df576b5d0eb4999194bd9c8e82e028e3666c4e68ceceeaf648bf106bdd9f0835b7ed7709b19ba32ad7cfb26709eea3559dd50baa6a149f1a083cddab7025be6efbbd057e451d2acee0f81af54399a56ee59a736b1c088a5ae7be8f9b70f4bd78a128e49e8a8ee7a908602551d2cc22d2e8fd66c345db2c79e6551bdc310383e738f8a6f81f03b33326e4e354712ec9e3255afa1125c15aed2218a07f54fffa50b4d9d577299d363fac3e811efa07260369f893defb45c55ee5c2d3c7a0a6f0a3ca082a5ca33fc7bd6357bb73e86f1c4d6a6c67d3010a7bc0cfe2eeed9fc3576f394cb28a9656e82f650a62159e353752d67171262477d5a50744a249c7f16d86442ff4b1de7bc09da139026a3fb4cb0e39835680fd218fa90c6461c68b2f54a09c10f0791da903a63e52fca3b9fc1c982fae75880c01e379dac58e70cdd099e0afeeace113e938784c3400dc3287c11d1fad0b8ddaef329ab9d09471c423248737db87aaf4a82ccc149b45230e77bff416ba664886d221c993dde04695be5cb935870f68e9bcf41f98a2154b88ae36c22caafac112879ece8ee494e1a023269dc87d58a8b997b64c9b7b77d67aaacefefc9826e9894282032383e8f3deea69b95da56de244783066b0d5d3d6bb38f1be8ed5077f97aacd4567a47b1ff57601bd072fa6cbe39ae8523b7d873e517de871d957828eeb988f8499ddad7d0c471325b73cd194d76a7809bdf6aff78b5201c1bfe88d6f2ab6d50261302f52d94e6e99817aaa321593f227b6e3320db97c4b2c8dbb49a050b7e107a2a988a08830253c53b49fe3383446acb39af30023b7ed5523cb6a99d2f7f79294621c78cca11c3f918f7daf3838eff26ca1cc29cbcd7ea856a5b59677bbb49d17b308babc9e5ba1f87136f2ba767bcb56cb4b47c23d3bd5100a48f2b134a258db127ff036eaeca7978f016ce63ed7bec5728ec0f063e8d16be065e0ae18600b257ac767e85883096ce07c644f6ab615a2a8c275784c4f9c5551324c64cbd2e3a81f4a6fb32209cda4e97276c6f65cf3b929dcda30ea9c90a49d031548671c003fecf81bc2a57c72e5f71a6b113c84ead169e3136bcb74f35cd7a9c608c5a26a197155873a766cf02dae70ad56e1fd5e464d808f8936f5bf7d4884de759c0655a47ea13dd4dabba9673ba1802097210f52fd8bd5bbf223e63f835f545bf0746ccfa0cd7eff1f6798148b5780a405a674a3fb8ea9ecd47b2a6afebc7484346669d2c8d97e0042d51d501ca3f78ab950d0ba7432e1b92a408bbb47661e1628cb39aab31d85ae01d752207296ba38f240a52d89c803412e4ad57adc9d177d4733c30b62e6565a2c5d5bd96b6ba29aa65e3c5980dc5b6724bb8b09ef46ac71e837ddcb0a5408d216b584a9ec237a23966a1219ce787d1931637a9662cd17d1649d8a5b52b35f9e88cba825ae140a8770a4fe8d30f1290ea4554a48dd8db504baf1f7e5eb2404492e0528371b4a200f7f25ea68e7d084f8fb4c81a483c699e6a145fff4bdd8276f9c4f3c798b78be519da4d8cc743397381c86c3b701a7bea79ce9e5d25c4c8e799c124c9aa71547b1b1c0d77378a77191687d9a6f898b8eebe7be9dabd3bc23cc69e735420d428a3ad0a55c88a7ed95fc970f52dcb3ed3c0140917864c987f25382df66a5fdf28db8d4effad3ce5c9184f0fe4cd2284c6add32ce4e8918bb95607a91a3af27f35684e194795b7820b8353d130447998a307bcdca7f2746002a7069680166b84978ba95787cb810b37da3b55a2a4addf740712928baf9240166c5ca19096e5646fb01086389d6c801e6024a4978daae8869d3eefe16332eb8883c07b9eeb93afcc1af5205547b2699df2374b63808532ae8e6cd6e6876db1eee753f1355b6694564f539a48d2cbedf32c0281a41da56d249425e823ca54918587dfc0772a33e97f8a4e24b98bad7498b893332550f6bac827a69e1c869abd665285abc089f9d3812ed3c7e3383dffe777c1947f4e96d13ae99c3d165515477c8c842c62aa0378c9c16bae83799fc4934ba9e121eed9dd741020fb39b49d792e1a9570642143472ca795160bc4d1efa02737e75bf045f406ae6db9d25d4d305f6994d2564a96ebd0b236a04b3be0f011719235e341e4b8eaf49cbcd82c7c39b56c2db6cf29f63a2958ea8f658d240129ad3f1ccdb671e6bce5e8287ccb65117d9d9870e73edb10fc89be45d6c495043f20d368295415f58bf68b4945a3fce323e64c7d19869b51857eac06e11cf1e10dc1a88ac12dced14f5f96265b0444ce09f26d3b08c78b905d52a857525ee84d3730000d08a2ba13a59abddab8933ae8575421cc0497d6c26b6ec8248af4d3ff26ca62928693397ca62fab1466524ac77dd2325bb661bfa457089179e527a253b5fd0e99af7dc6c77cf4ddbb7dfe8321f99211a7b09c04d508a4aecd3006c52261b756ae2c73e9cf2abed0e77948d1c4dd86b230514d5a07cbbb53f921e069deb82338a9d0632702e058b6f7213aa9cccedbc829cd3c61b1052f38f077f894ac000dad48f8619f64d66a6ff750a909b7f03cd5f4963438ea18a762dc0ff09c6f73980c71a1ec36614c400065c3a11fe8d3f3e6b5b802dabe10e94e4aa49b211b79c782676579c589b06751548679a242e96ca2c04b8a1936c7b2ed100bf361de894a9b81ade7bacfbed3154d6dab3d9eb1fe08b0bac561d2bf51243d82ed614403a7781cfd4f5ca163fe63111b988f1ea06be7e92eb8701a19b0beaea69be07b6622b3bbb4ad2fd80b7f4e7539dc037cf027150128c8032fbaa11c7072bf719cabece9375e50dfde67c5be71f8a97c6fd09ec23e497ba978007d63ddc05556e2e96039db4aab67d32e3fbb434944749b747215460ff4bf5ab367518ab8ae0dd3207912abae2108889a864f9ffaa618257afee8011ddf1639d7acdbfc10bb0b6f4d8553b84043551ec0241f2b43d32f36587c364adf96700a98645d9517f427f9d0062aeb1db89648230319804cc6af911e0834952230168791556bee0693af3161e2164f32762e0cd264d2fae4aabbe6931053968fa9b976bb966b27eff26f7a57c67fecc379e1842d6f1b59c3a73661c149eb1067f8c4256b53d0f56fe097a6b92e9746addfbd4f5ea29de5e056126076bc31bee952ab10ba97b446aa9f7cd15e4a373c97f9b6ed14325568cfe62b56ae909c41b23f17231d867292f5a6f2fbf8fe33647562d99135d4f56fe8d60a6530b349fcc0c54b17dd37cee7328d489f0124016f7acab0e1871b1bd3ce0ce96c4758ae87832136cef84016cad16c8ca4be38329b2125ae6ab00e5f3f43dd976f205665fd6ac415345d1d3b8d7f8f48af19be88c275139f45e55ba531f5cddfbaf81c93b4724f2d4d9d9335a3a3ce6097f0c095382bb3c736742b641513ebfebfbda927ca57e74692a1db89952e9ea4371d2ba3bd61ac1a7179a8332d34c069c655ef763f19c2f15ea2b93f25b3024d411ac6d58ce3fcf5a56a7b12fba0cee8c08de0b7bb98a16221cba7970de56bf3850e8c3ffd623b642f225cb5ad29d207f23022d6601076264fabad79105f3aacdc95e8f88bf3e4fed3058ff9409a3898fb9b73f5a652f554c371560d1eb9703fc05121980752dd70937378124924b705e8b00f6070508a460ec30d97b1e4210dba124c01ab761c4435386b0c7d20ba9beacf5a23cb93ebb5acf23c477dbf40e11979a828a02709c1ba64e88e2957c72a70f11af04218cafd76de571865267a8984bd0f31d0ec2e48230c07dceb9f3e4d95f1eb8d77f3b9f073430b58a25c2b1525cd06f32baa0fa22b654b9cc2762646f1b2cbfe4124efc09cb7dd067b74b0d34d146fc86beffdcda6cf92d6a664835a4e18b3728058435cf0228fcfc0a9f5f97ba8b65d63424e50e2f4b2c1fea7f3c89c0a32fb654161dd653c4a888ca17e75fbd827e27cd29441bdc8a0346e6a1335ccdba2901d425763fecc8999c1e8783ff5c3cae20759c261cc6f1d717bec8a0ce8e2abd3c2fb54d7dab7baef1bf4e12b6d6f3dfd33ef3e5f69847921fbc3e3e9c3eb551cd300524e1c0f0bc4302b39b8ac85b4ee7143adc3122946d72e90184072300c653b71a1900bd675b9db67875d580937fbbf5d6c4e1a1d808d534a240e6a01e3a05504ee3fc08b51653b5c8a9a423a4e9f4bd0e0fb02f6b2495e494ddbd77c2618acd7bba559d4a361e7fdc6c8c0bc38710f25c4e49497ad02a0d05778942e8d62fff848eea172a5603328fc2015f6281b54df6c395f253992e74cfcc0593c5e7ca7402ea9fdded996bce6d1cae206a837176632335733b18be7df3be08eec2f70ddff057c51d535b2e0fd58b001c7d5e4107e17438bf9c14c0db5ca3cced83b41699f48d0dd491538019e30ddb724d04d0d834e21ded3bbaa1ef7019fa8028498728875cf865346895f35e71fc9fa9a05aac652b8b68149d18b9cef03f772a2ed93346751de5af63d4af40528ede1d685631afd4b7af3e3bcad4aacf17415b20f5178532e1c55f6cede7b64159ffdb5f75fc150690420e8c0e4392952d4e22dcfc6893b9073e6dffcbc4d2141f0431d361f45b0a7daab74b1b86e5e68381f95e3249404083e35a0f2f07cbba068eedf68daec4a0530221c3fa1a575b88fdd880acdb0ae25dca88d22703d821efe7081d0863c1afc3cb687463a4f96e5bb57add1c9ea0ac7204289b3da519fd76dc5a95064831732856687ad6a8c3b20f24c9b297ec714881591d832855153b4bbb0d9ea66e4d0b4fb36f664519ffcc82b66e1b95609678d667b8a63eb9d33a5154a330e9ba6006355b534bf5f6cd29d94ad9c7e976c4963d4ed366d9803e907ccf253faf9fa81bd49692b3e1315578ce0589c1a69e8e75cbe6f79bd357df8463d5e5446ef155023bcc4f646840a760478d5937bef80a960ec3d2be9390c848d48f49b1063bffb654b0a07fc40b905cfe9be9213869e85c827a9535131a5186bbbe301dcdf987b465843f0f25b8faf72ddc5ea03d4055ffd5214973cae8c7c80ca8c827b8942587e4c8257e2a59242f188e5c0e6927206acc4e59971018b0d1c56170ed328bc41de37e8dbbaf219153201d58510038075d8475cc5aa1c63db92e63a623e9a087e0b4c04bb638cf19000dbe71d897f100a03d5b60d8f4343a49d7eb2c8af3973634c9a2c7c9c85561cee43f4fa04495ff3048ec0a94a0be53677a7bf75e50d989219df128f6a7aadebdb88eae162fe6d66e6f4ad2f076368ef5705b7139b680488cb30c5545cd966ba821d7334ff9d85379c80a5766021102e86cab0f18e0392fd98a31c6a35ce39f406e79e57916ef322fc853dffaed60022ab10e094b3027098af5a4bae0ddaf4f8826d772a1b0fd6e82e39619317f66d792765d38f5ac9a434bf6d62b4fc610edcd426997e3505cff074e19c259d8220b391028c5b89538a477b8c6981a5ad3ecd68b25d11424f70346c5fc6e85d74ddd39ec1cd110e84d47e3ee6e6c6ffd9f1e5cc696f95b6db2b56d03bf54e635fb95c30c5b4625a3dd1ac431c08aa288980f09ae18db05e552c39874c54003ef579beb99403e72f28b6ab002b0b87de9c3ccc36aad1f0eb8711398f57b7eca36734d9caa1f2bb363955bae9c52b9b3984dbab5851c88f4e5d5f11a328f34c99c3840e792d23a79654810bf62b292f7985b70b44d10338d12768dd5892725f8844c1e30b5e878e568b8f288133fe4e7e8035e2297517fc80d5805bcc5ecfc60a394bc31d36943f8f31131173fb7921ad03c77d2b6fb2629a2a1b4a2acfa5480313742f94c0c9f9a9904785733754e9c3b57447a93db085bce5c160ed86053f476bb0a9b2b61b739a9362173b8b71940fb201fe4f346e7f94fab45cde59725bd3c9dd1b408699d511a1e54ca3033a524812862c71d23f6994c21f993f5c0a481ceb33a6ce0cacf4f3929561f5f337fb0635f8536db377dd204f02c3c5dcba07a8de43e1739fc0e8198c17b11e12abbd43b5a325e2fc766190c636c7f4f683126cdf6ace855070322f3c0242a90ba114b9133f078b7510ec9b99d890d99abf9d833edacc3976f83cfdc40cb664c9673ffdbc0a5e017ff39a5ddf637c5be6614967b27e1ffafe5c68cc31832e191155851b99a68faa9c51e4c44ffc53cee27ed7e97ff35c8ec0332a1645ca3be2ee409752bf43add5cb7abd22ecd80336a9735ce06e3986a5c76f89fd3f68d1af84a0558666077caea33263bd1385d01a4eb73a08d37a5cb22452bdd5c18e46833ab2551a51ebcd85dc3b3ff7379f57cd5ce13aabee143ec3292b7bebc844c78ed9a9acd269de0c1d8d0e846149566cff5d356c2b74ef5628ee337fb718d7da24620372f56c067b8286d2666008d5f204edc0312c57404e59d0acd4d1d5df1ed0826baff5001440ae6cd2c22b39f5075413ba39eac5d4ab664d5aac2b4cca3fecb34850c251c68d94f8c9b7dc58fa17f2cb56ec5cd16e2b68195eefec9e5d6bb43cf9cb5e171d4a106ff547f85c13698602d53e19d572ad19917d76d72dfa8daed5880dcca6449a5d68a068adcf5f5561ebc89b243cfcb68e237ef43a5d7bcbac95a6b0cdf9e85dd63cef148fbc0b0160103b2236b0cd7d7c05c8ba253b581398cdbc1476bbcacf2d557d66d7e5f04929cfe713b66da68ef9c196c1150e4f5ce96bf454abfdcbf99c722357f4ea90ac13a72afc4ccef3700451b841383057e4ef84be152c82656eb7374aab2eb713b52078ead993eb892b85f99e45db99e29d4926499057adbdcc0104be64efafee221e6daa79c63b065433f0072bea29d6a68edd2984221632c826a7775bcb4b4e220b1868e670cae3c2f80203dbfe30918534aab4bd7e447b79532205e5ed1fa83ea28968f307bee5a67034cafe8fea36ed01aacd2568e1c092ae2e8ad7556c3f2102a3e75c769fa8c51a909e6bf92d9238ece0515ea1ece4aa887ee00abb4f592a943f49e3830ba03fc90ad1df4b52a8a7a5e3e1b15c2bd1394d85aff5249b3b9257d0cb5d87060b165637c9c296eb021cf903544118c9ac030f829184a916a4505c3133b5270d46f602e7559d837fdb7ee6e2b3ad7b52f0a3249079076d0e2c303d61f40cb8cfcfdacfdcff1ab0bde76577f98f4f06b89578da5bab66c701b8dc1b1dc7f204660b4187f36b754c72a2c093092524178ed9afc47488393e1383059bcffd496772578001c7e8a9f2491e2e7f243874c203b8bf27e350905257bdf396e1406e9c9f18efad73ea900edb24779856f4329c7f73283679557d6f1a969ef98eca04d075b75170c64f682b59de2dbf478a969911456f0805900905cf5bac5c51e0df7a7add400119620cec3d1e22b434f97f65abdc07ede423fc50aa511fe5a2a49082a1f3945b5d223da0b5d2b02f5a70c1f7b6d1977bac5758b65425b1b1f2d46354d529d8a837450270abaf0e1ef754bc51835bab6d84ba91ed972da6c47dc7c9b278ecb4ff812c7d325131adb566ee83b3299163a89819192fb8fbee667a458bca1595b64218eb91f89ce5d69068b12068cae5a31022a141e8ada3af828350ae6d907427a70b4514ceebbd3774263b3f5604650927d01a8aacb0387ac975af0353bf14915a849ee1db80f902d1c486dabe239a80b6ced7f9944b12378b1bd038fc6e7f6ee02c38e691d91f593caa99479e50f28ee32e55f0a85ddb73ccb40c554e83e9bf85f18e374e6bf168862dea067dfc6df8341f227402c9ee76e82e7f45d7d521656b62fb9a80f9068cce3f55fd1ba05717e9fcba39d9e0bbce8d051bf2dd38efff7befcf15f28283ffad988a3151990aa60161f879991e2ac8d9bd7441ed8a1f53dfcbe669436dd6bc0a898581ea7d4b4d98bb6b9ce145578219d7e227980e244697a9a2dd5c453872c70c089df6bab556a008fb11b344b4d6a5e1d889d9902d8875f4fb87139942afa24a6d70fbae0df7ebfe92db0c7aa672ca203dd177a59b926b8dc30558e9a248d6a960193e2b0912913abcafb1e37f95fdcfaa8ba37f03b8fe9032590c5be6bed6be3429fe356fa83f9158902d8dfafcbb1f810deeef40a048a141a49ae1a30e6a99512e18a9b56bebf0fb2da2fe564e795ddde7d87b615e6dbcae8b0d82096b32fad54dd09f0926ce8b7f7523e10d376e04d77c83f45d62ac3cd2f96f36d191f8a5a0584eddf443a8f53fe147c3d82da5fe1f62bfd42576f1796b3b78e2ecd9697c851b5b6588339c796f48c904cc740d107514247501b6bf4cc14bda314ec09705c72b2e79f358d76b5e8d1a5d60c83bf4887de65a166193e8632fd5db38803815c8cb316204f9dfef8f5073f63b7f3e9a6d2d3dbf5b08d91f9e547fca44db4e0e1516eeec6838759b4636332c69689914323d1936","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
