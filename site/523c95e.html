<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b76c3125e83bf4a106c90a4b53ba91d22161d24836b086e80f8707b775fd0bab5e64b6170780d2ea3e771d6a2cfab046bfc02e18b67f26df583f7925a2ddae2857e4a2509a237f1605689e6732bdf0d7967e1eaf6c8e207c1fc456bc4d23ed90318654e95f96b950ba8f0777a05cbb2ae6a7d021435cb28adf1635ffc89cd2883e41188203754fb24de63fcbb5ec9a520d8cf06bb6b5a8d362299da3c93e31788931fc7e4395669b125a84df4eababae1f6d7a48d8f1807a9a16a0593799d87fd2fdaca795f5e12784e8ae71a33fcb8142ee7b4f54292e7335dc605b73c13950918053b94185b874350d70c7e394c19baffe7313a3f20d923f6578bd7242d466dd1b53cd0e43da39f2a63f4b04095c2f20091c7dbd2984f009316ecd5bb5b6b730f69fc9294c0b0629c4e46c556077fc6434b2eb82a38d9cddf19df75c4ba8222493cd9b4d4dcce367a8ebf6a2ab636f12527a195424d7a6c534720f0c7751d885451441bb404710e421533ed80954a07eb273f8bfbfd7202f01cadcc1695e589b12b6b4c39038abb7ee1f3f798b6adac6d2fa15b3ce98153d03b96521d3a4f99b5c7c9ee308747a257afe5e646da5ce4e72656cfa05cdbf7cea7675c8ff0ec52bb3b799ea18dd3aec7ba450c9e7d606d5a11793fdcdfcd71cb132eba04fcc97b8706768861bb8a9f7e4ace82f63ab33dd62280e518655dd52c62420b0aee9c011d138095897736d17fa980be4c1f90d66ba8a70492b94f33afa326bf3f306069c73524cb5a222d4565a25648b77ef9466833e5bf31293c05db5dbe6a85113024d100fd591e9b8150de51be7df3ab14194a11281c983a53980c1ffb7e759f01b62a44c3557dd99b1b26d438054d14e5b2354f6ba1d7e76d756ce386bf2ca27a042791e1888ff65622cddc389663b017f06ccdd52e88bb945999c631b1b440583212f4eb7bc6a10a255a0acb15622c772f8ebbca241f0e76e0554f49a428feabb92689b2643fd22d77ab2817f94bece63f8201fd8212b8162315810735748249485bad98ce369e89096893f2d1bad27ae87ec9751e61a01dec3f8a383e458bf4e94fe3cb645b574fbeb93f17fc9d192de39f899789c73c0a16c130b3a6f5c9f585943f713f4bcd1eebe670b6c9a8b82ccd0d536f2b053a3758c1c951dc4982c8a4109f7076719f49ce0f6d0317adc8b31aeaca7e94df04f2a123dfd91a555fe402504f964d9bdeb702a771d137c6fa2b4bf0cc608b090f7a049cfb25e9987729646c9653715649005fbea7983162e89a31374357efc710eeae7b7bf1304c5300e1d78a104643c785879c2b3db2b97226e7c509d9ae5440cb6783b447433991b33521eea44ff4e85bb8a1a14b72a6f7129bf34176b4cec10f4a2ce1e0c6666e1cbcb41b81686fd7bc270dc527d8b54402b9d399ad2bff5cabd7a388157bcc4bcfa98342624f5284d7ccb2ba29dd3cd991fe34d7ae02ee87012f64349713d66a616fd5abb9d458b32c194742c0e922a1c13131696db07cee75aac5602b5aadeed491645178bec5f750c5b50022287867c4ebfd474b3c592f48b3dc3928e50b74a295cce962607647b277257fd6aa91dfac39bcead1bd561fc2b9392c671a0e634e24ff218a6145353ba0fe01818e7b457d3407fbe276366c764602652adb036102bddf99cd10e4df497e72a81d282d6c60ee8be6c98a986abbf809b74a7b953206be9bd5e690890e5f997cfe86a9a98c5cf439bbf1ce8ba45e9814570630cb4b88227d904635f1f7344843a40721a31e60376b345c0998875c4f5a88564e46278de146225e0f3bc376275d3aa9bf0147282cc9fbaa0ffb30322bd72aaada3c3a44ccc2e77cb1ea2ac09f83f56583dcad7266fec95c90951d141da6396a42545a4125ae8d4b33d9bdd72d5bea87ea09ab84ba2a98828ec8eeadf7c616378ab6e4cce7c5fc7c03c97ea9e68bcc07c08c7b08792211959cba8c4444e674507790ad62374475dd6a8718431188c7af12dc38a6b7a2f51e1fef62afdc8ef155adb9d23f526474206ddc4bac4d9c3ba6e776729682fe07f41c246e79adb2af7e640df64d1601bb919f7671bcf17615ca753561114f8e077dc19f2c58631c51bfcf22a3ea88e1ce89e10538f8aa8910e2f31fe9d9dde5c6f95a02dec25f9301aa372f141fb4e940a6a284738070186bcb6ae87b93761059fa6ee1ca993c513be2fb6ce43f5e37fbb84428a06896a43a655cf42c740cafb78fa3d4ebdb71b486e85f01199a47fd663a387cf3ce699af1932d441b5a997ddf76ba091e328e60a3cdcfc169b9955e819978bc5701aeee8da779d745282cecbe9c720c11ab1fa6f803418d87484fbcfb23ade5d4868d7d3ebc8481a9f15d14b51b5231c8f76282f9d5b9f3d5ddf4f8ce0b4f8e79724997102179c5f7055875e0c0c698cec86e419620270e92f81db30f160db0afdb75d91c677699033a46ed5b53ae26ea203997251ca2d92cf535d6eff31909fe7a9b9b79cbc4c58f4345b6cca74608df1266cef628adec3eb3092c4daf37ca33ee9f26e964db2c8b0d0f886e0e6517895fb161c8b2c50836a983e0cac74c3e7df21fbcee1af6137ac5dd1f7240f8202b431e5d662790b46ef8f0ebadb3bf0336e4f5734d78908fe7cf9e56975bbf843538eb0299fd5002821185dc7cdbe167bcefb6af40ed0c6f1f17430ff28d8e023ee377cdd643107326c3bac0cfa0faea3fa00b4bdaf649c8a60bd7a9f187c2e28a6dcd0de7e43edabc56e5297e335be332853cf755cf8b4c4debf776d01b96b3ecf4a2f0910ba0d6d8483b3d887e761f25ee13b0a2a638d216f9e6096a792d573dd3242e59822eb13af95fd0801cdc4253dcab91a28a961ea3bc01069edb668540c1c65ef98be2bab4e141f0d80fc11c8c1b08568ab797c58641159e77e3169cdfc299c9fcbfeff06985e7a955647dbf8b60f54d02834a55a568dfb3881c53f2094540cb406c04de23745acedcb16e6f1c0ee04bfdfc2917a28d0e05f52ccc7bd468bf25a43fd04b399898ad4682a2f7e17bf31e0cef69abbcac9edd5da269d21ef9de9677c64f6b2310970c305c81a6b1c06f3ebaa9e27c7cbfc0ed06d896bc3eba68ccd7e7d6334131a0022b0184377a6864fdb8285eb5bf5e0a1dcd000dcf6e73808e144b6630b11527fb95513450a848b9cc406da500ba64576916b3500546f1c17e09f730aab4a91773c37536625e99701f5fa0fe3b08ed8429877056dc2ed7aca4b914aa904f103f1a9acb0621247a4e3e736a72536137feb77887d500e396e0f3645ced04ecdbef848c02f065e6a3040a42d8bbabca949f11bdd8bff51fb0255f94affe026380eb9490b40ca0d369b1ab46cb3259c79d79bee67f73b419f69a916a5c8a6d382c3b6fefb92dfd3797a3fc5e49fc980f30e88c03d9756768a4920095d8e02a57874f45411593a8847be9fb82e917530d98c4120eecb2d32257a8b1fc7f3a0c8d8e3cc3feda66b5686c0891977d2a3c0f2a99ad0823a4581895be46a2030dbdfc79bd782b2cc079f090ed66a6835ba4f7d2881509d0cc6805b4aff4a2f869b5d82107beb785869901551780dd914e7661527d46bc05d3e45e8187abd79fd7cd4ef4bea281cdc05c045d2c1b4036be72d80c98768a6b042bba65481f7b7d49a85c97517d7a88d56cc1964627e62df6042b7620d5beb15f2e02b04f3c551061427cea8423e9c6d50444beb44bec5bff7b678d64b397140560548d73b8867bb76c2bcefb61673d4c9ee26720b23772fe87a6320c0bb316cf268a3a6bd134443780fbba63fa4b0f6465a67d56fa4b9a09dfaf8b14715a4d26d250e8c7cbb97107e64331f21aba9b54f3fe2df6ca36a4baa381f10b7b2c362d18b0391e3b582e7c2b5ddf9d46995b4989d9d75766a043b8003421cd004dc8181f7db9f1129a0749df478fce9e3c25c9d395623238929356c30363c091c9bc6b87289005983d0fbc6ff6028c1966eb72c6f630b4717244b83c9ec7c728eae36605f0fc58ceb55a5ffc8d573023e323fa8ee4630479c07f252ac8d6db5360217491d904c21001c856f3752359543ff179db8ae628e7ccd2a70947baccf4c2c8578121466979e11d045f65da36f6ea96f76854c19896baef3be93b636241f74ae81349571b13ee9ccc2e0002744bcfb5e9dc418831cfe808efedc1a1ad4734b3ed210a5585b7a5348db9c0e7cd9a983ee3dd5e4a7281cd5aaedadbbeea8c82cd7a3ca6953e0be1c7a731708162d052619be9207516bde6bb7b2dfaaeca7d537a21676385867fff6e7bbe453c9b0cd42baeb2c0edf662bd433606f4d77fe489e07e8b28e72aee92d687704b290068a6c430c99b24765adb228626819fdf04d0e9384cb2f0a8849e4d405e6c13f794e1fede7181906f983b09173efdfdfc6d5c6c8f37a39169efac6528ab292cd46347b0d0491229cbb926e6c3eaf6db23b72a5382443b597efee9b0c47b8ff80ba7846e2797b04e3fe65d076132f0308ba8745ce0b17386b4d86106f811655eaa2c9b6df3b03d56a97455011b51a67855d6c707d1510b5dff4f32d07d17d479f2dd64e27150387a3549e6c529d85aaf0e773d6800d3958aa5c35f71610e4c828953518039e3e7f37157ef7ab13ab7d3ca6e405544d9e31e1aae2f70f87deecb2730a48abb2d1242c08b684af82211d84a11895d49c7d5f9edff29ff79694fd9155ba107ea381536f9790ec4609ebfa455e8222ad77e484d94a123f11c9efac29d949f442adec28369fda315ccb8ae0333414d83ea16ddbc668e02fe4dc28091f5dac1c6d210922ed66772bc8008ffba1655af680a50af0768d8bcbc62dc53d35c2359e161071ae2cc014c8417f975c14e6cd50464b84b23392801065c99b8edb30e41f57c5d88892a580135c7590890c6aad650c5070e458100e068e9ee6cc86ab6a5b1c6e96e40f18f214fe2b47488ddb7000405f90861973fdf4af0d24c5792aecf0f8625ce0ee0867dc26f495598b47674804cb0d9fca242fd240947e7b3e8f1e6dcec4cf11acba8f0d682f0b7231f64dbff840c4136547bb8052a9279985f571acf555d7a6fdd6fdefc3d5b0d716be47cddc5d6110ec0f6cb41d13b25e73ef866e1984ce0a2b72739e54cc28141b2f21d8dcdea34a93ca263f4dab6af700b451543e223590c87649705751459ae1a0e2f2fc20c5d9ed9772111fc3a9237eef7454777d8e1013ecbb4638029a8b950b0f44d3fedf3bd8d917e2b6ac6deac40273c4784ea2732bc89dcaba04a497c51aa2efee9589002d4bdbbac2b4951c486412485fd2ef236a54c3d51ed5f3c9cebc1d5b6df8fba23c81c71834416cc67735a53e98bd518258e88aa089d488275cdfee4e4a4c136485dd3b494eedd11ca29f5d39e07326534396045e7f4b5a5cc71b8da7bc58c1412dad453920823ab3612103a66e4183a32b5319584291bd1c498a82cd8e5af3a3f79fb7fee19164ac3834c9312490d42755b4dee430822e748e0a2059224b6fb7657a0df509bd14928e57836de872576fd1fb1495ee1b806c23e540a7a6df7d177c97da947686100a9358b0b5ebf5bf7fabeb68ec8eddc78e9c641a75cf38b367eb6dd430f271e98e4513fda65c7fee671e58e4c7fdcc4cb7807d26e07f5bf93d56b06380d83f3adf6bccb844985db97a4617894d625d6ab3c70246048ddc9cf669573a37bf1aef269851278f7056469b8ab303e9ce0aae34a417e849174319b35e395f347fd6ca1651810e58dcea92194d0c321e4ba499a895b68addbe47ee6bbf251a0f7a0b72afa9df796f88a4f13c341cce0ec33d5032b1857666e54eb026395bc2f903fd57fe8123622d0780c08ccd3e5a07efd186213577d0d382df36972cb881024ba61185b0ac27c4dde2ec916dca2d2e2f77516f098a7d4c58590a5c382a56b4120cc29e949c912dc420449de90116266da508429d8407fa405df6cf7ed3bc9811304533e10452f7a27ef5dada71a12f2ad021142f902ff434c9f65cac1eb118191d08a3fb3e2df89023382ff9ea0e7b0b542074be2aebebfc9388a42244b2ab4a64dff73a06a005e505da8fbc0d8d6f8636c9af1e91a8703ab73e3a46078afcae013efa0ad10478d056d11fe8acba5e448fe47a49f625c31a167bc03c2b1da9c82a2f3ed7659ce5678770802c2ba1a703942a7bea02b5c95d32491c3196662ca9969b85779b69b4d31137bc24cf2074a86cdc0ba80ba294a5516e4473416857b4e23e29d3d8e6917da30b61919b803b2bf7af66517610a5ea02caa5e65d00adf31d4a67108ee85aafab09155f554f7d320eb10477b8bf2e2060b77efe0bd228d2473f24e07d205335db4590f8f60ed14c4595c63a8ab1b07d9bc80a1929d232183da34432620a9513b227884f04dea4b973f0d56fac3563832160a214c25eba523f959dca40d82ef136a4bf49cd4fa6b4c0a19c81b666d378b0b140adc4df236bedb8c45677f321ce54bc148e4923dbacf825820d0b10d027d8fe6aa3feea0d4e6d6bd94611e76ae26a8f5e6433b1a91fdf3fbd0d1519f20ae8237b8e0c13beb8f7238c9779b96b70b2c73734c9c1aea2eec91c0e0b8b920f358e974c443f5e84a327d6475df37d92784d16a9bc98212a279c05762b7796e30abd79c89282a1f1db148debae3d896fc63b65672da4815ff709b620d59568639a75e8ecbcfff11c5e5b316705c220e796e49c911c72294c2d9af8aaab4c445dffeb9a96e8b227cddf10a26e21ed1d0dbcf820ae375e3fd1f0f69d3000bd43daff30066c95cc58b5eb6b83ecc4c7e42e9da3992a6c17bc77bdfb7d706dc66ae7110dacd6d1c537fe9c61b2b827ae5484fa1d4cb2f797b632117efc47fcbf97da470d0ffde4f27c98eaf419f73a10a35b181a800c622bcb25ede268f03ea8804e8444c602e01ae445bbe497f87929ae9d233e9c2f75e675cf0f511db6e09a3b681ecbf5fe04c5e062e293c8034dc483d357d701d62350a7300b83f4fa65c81f7ad3da94f0dc69427d2e2d926b1a1f4e52368b34198ef058c142830b30e6cc57d2b3523861974f22f886c04ae1f31c46938436bf4b313bf3f03d8d501b702b190193c78219242ea4fc438e3b77652b71f6e22ba1f8e831b550ba17083e943193d2fd15e3ed2ee2632236545e5ed8d2ab88a04d8b6c9e9ec5ccda673bb183d3c27716ca76ba83948386f33fa53d0c952f64a71f3a93ca5c8e5de00ca5e1b03956c16576c751cec6003e45a94234940fb5e1223b6ae200819b6e5e5f4ff8e7d2ecdcc2f98bab6244cd6f67a3b552d6d73964d50a65702768ed390a86d86305a8c8bf4e5d1695add8cd39e0a06a6c8697e78faef38c3571534c016755ab917edf8d8d91314a4d5b2701f56dd05ed1361417b3525321bef9cc71d74165cb1f58dea164a292da3ec219a2f04a1fb4d6a80532fb8dd60cff3849d0bac897abdd1570c4954c57b391a0e212b348d4fdc3e459196affb5703f58966daa1c9050f2d0a10df03a8f12a3cf96cbf4c5ee2ece81133270364fcdf99dcdb29088bdc7c9f836c2be7473e94c8b85fa9bef4de7db2d7b8e081d7dca94faf800f14b24e50a45c5074e6420e80a04d9805142ddb265afc8cf56ba44b850e5169bcde98c17d5a1a3216d3aa224590329da02e55860e79ca75290a9a6e299da3b220dcc58372d0790b0d7e60f122ce66017f2a5d9919348a19d1dd7605c89206e2c36e357bb76c899469ddba741fcc9f7ac6206085b1fd1b284ce3fae841bab5216ecd83c472f93f20302ce197c3cf3d39b2a368e2ee2878cd41397b5ffd95627a833fc7dd821ea40ce85a25645df07baa6fa611c7646b86df9b938a9b405ce51dadc331460988cbf669f15a2c171465a83ef7eeeb43da88c8be782429104beaa8b0a67ccc01717c7b0dc195ff763ebb3b7668c4ed83fb11ce1fccbe4a975a8551f8d7132eb402099248acf97e48e5c49d9a15c0d2176a933fac67db09659f4244f0f2bdb1b72f68abf6c9650fdcbb7482d54f18d3f717f4051fc3ff72ac4e2d1578947de29c98688701f301edbf484ef7c6671372f7b968962976aa8396cab732c0bada658dc72aff8ad8f86e8a236667ff65c02bd37af2d07f4181777527b3d5642e2276973eaf5a5813da7e1d4a8f7355f2df7a0a88c7d6286b9c16d62aa86efe91b949cc95bcf37103d390712b035c9f4f8c3e76c620a9e2341968d8f7e5788ec784749d5b389c1d142bcb28d14355c81fcf7c2d05872d5d20aef2e4941776aa47d3a58902fe2c4d8686368888699fd5c7103902f043a8839795be8f59a5e0df9549fd340d881250a04c33692820b6f1782b877c4cdff9a9b07aab2c377823f2dba65e2b2e334a467074cb4ea54b4f2b8bec9824726119cca06fe8c08a9010402b197628e47c2c3a28230c48281ad976070f05bb756e56bc807892067c4ac612228f60788e45fd932a6d4869a919aa7baa20b699baa5dd3f8e46c7d3fcdd2c4b1bbda256b77a7f78b92008920706c470b3474254fb3f4034d38ee18fb3d618e719b7d1bea38af09a0f949389f832ee62e6eda93ed8c51ea670f8fb59d8a39f2840d637599f3c3d738ddcbe3f2c5dda2f63a27c011490e6392fc94039dede07e5cc681a93144f762c278aca6f98320574dc62eae0dc17a7c618b4fa40a418478e7c00c38d8807ae2514115346a5b3d768714adfde28738c5d775ab4065e45179249d7635506932f88629a855588798563e919d7a975f31e920a8628e1cd488cd69cdc3511e0a4754779c6f7cbcce49240afa20f42d3ae8d4e3eb51fb6a6c4d58b12f255788d031790af87afef23bf3f18a607e2b25ff9f3282659d2210e93f22c2696c82caa3f9c25e561360f5c068d6adda68ac12c08b95e5b48119f22eb772cfe3314e154a75501ade8336a0f9a0a6a407b6cd63549d895a9304780e75222dad45d17053077d5ede0e05c4178b9e257f4a1c85f8c78cb743a77af49821409a37b3648d792969df83ef21ec34e4226d36b5233ac7774e57e323ed2706270086ad95e2c7fdacdfa9f450843fe36725e38ee30713ce6429797c793aa4f37ff2f184bd2bf08eaa8889fa957e3976b3462bdc15adaefdf3c6c293ca3dd802c3385b78c11143334494a162df8150f3cb0edabe205d81c55ca78b7321ad3a676bc5bbd7564632b986ad785e93e4b8d7edbe8dd9519fab11353e606f30f8e848fbcf70f0677145814990fd7b624ddf66be671d0f738c2f9006cd93cecd92771d0516756810575b90ae4025701d88ce6c2f480bbfd70a94f69890890135b76f6d6cad8cce44cae6301884cc099a3cccd31fe7f4353a0d703f8fee92d1faa373bb4da3c3ff35b7748f445b320addadbf847bda1f5f7cb067244874d1c4df08aea4e86a8107defcd6a6edef6e7b3237311c5f0832bb8a91a34b02ba291ec2bfcd81e5172dd40f1f763c0eae431c6b4c94042d45b63a1678eeb9dd7c5e3af86f8d24763861ce46d351ee3890605986b7d2f217af920341410b13750520dd40d9d8d4466161acfa37b12bba2cc0959f2e2dd25421f4fe2d5d6044cfa2dc4120b180c3d449d4ae53ceb16a7d6c19258fdc1d0d8f4c4e69291ffd2b772ab2ef5b21ac015849ab9341549501c856b378416482e3d916ae5dc95c0ff9361a3ca6f8da9506409ec9192237ca3ac76abda5f03a0f96455c7996e9d4e018746fa0cc08a1aaab9c828e2ded6aa9b0dd00621ddd76b4c1d3b7be5abbdf24e99a21dbe35718bb8e7e9092951235fa46327d4bb34085ae24819d56f2d734ac732a0be13dd8074da5c95ebd3b6fcc604b325b22723fa6ca7ac266179cad43285e08eec5e377d89c9317219d8c3db7ad1323025cc9da200a5e9a891ba2e5e5a32bfeb4b472ea9a2d8687f5baed34b46cf93b29a480ae7a9305e95a154d65bb7cb3e098905ea678a13c432aeee8a6f6012005cb9fc192f29483898a88e09f2a49d47f2119bdc039086d406eacd49455a6dc0c24fe8a751f06c15bc9f6bdcc02abca1f827df7ccb60be4c677b4c42571ee0cecacb322bfe19dd17430f059beec83a6a10babb0b61572cb3f90dad8aa00c6fd2073897fa4b21c73761741f2fa6b6a292f4c3b2909829f2839d8277f7379e7baf1d52c8520d384083ac0aa6bb6c36ccdf6db58da34a5d1a9a0370a2b2671a8dfd9e71d4c80320610eba1491f788f7840ae8127a1d4204c71424f955f8ee2f0f7a9855caa34357417358cd0e84027a20822b3e6619855f37a0109ad423e1d29dfcdeb51a791ddf6b027b90f15642b2a18d324948ef6fed9a99be149cc9fea85827a89a2a314a67cc0332f21fccd4a075664f4659fa149c927feb9d42af1ccab0c2d2492f08bf6eb10eeea07fcd36db0680e8aada3cb422167dff486ff84deb24bb5f969d477b933e9757390940cce1cc94267cb83b0a92811db8695ea91bebfa1b20a9fb43f5729b41bdc5a8133b0f0cb3093a32de1253c817066cd2ec1f26e8e65d8ea8632ca2cc77ae082956fc34df84d5e6dc7fcc937081e0548a82eaaee13c07fb8f19581f4e6a0ac3cbb6675badec3c9173a64857dce7b3c1956168c20139cec350d8857ba7ca568f38cb87ea34f346374107c8813bd9de4cb20b963df1dd16e7ec777dc5714767580a37fbb3a34bdda9f01220f341614bc2cbcf4841b343c59428db000136613aeda237701f4141293da93dfb71b8a267001e668642242a853164270081baf4aba76f35e3c948781f7d80d00571552250645ad0cc6b517ee8008a9b539a2ca1654448052c7ee7e8310549dce01e4d0475162abefbb5508935df6af7b9b37b77838f66e5a51ba6d9865044ab3a8fc18add13e5f07afe342455616ced4f422622ca1a96bcaa5495178eb96bf3d42ada811c9be95357bf0649778101b9d8d93ba380c22218baac23ee983c67e3c261e67effc179cfad2933ff2b82848a5b76cfb25daf1724c82f967621b0e18ea0ae08cf82114e269fe5fb6823d3a7172854f6f47cbbcad212e9f188b69db7f663ad81cbf166497942a18545da08d5c5b9d35a072c1c8b78d19a3ade017a9e501f76058d9ae6507e2ab89837a6c4a60e05e1095b4276f4a042debb466c13da3faaeb14fb3458859f1754f03323644782ed43a736e8eb31026bf7bea98260dd4f67d022b5f32d44b75ad62fed2387646d91da561c37358deedad9fbcc234599389e44fda0fb361311179f61a2ba6f08280c461e318d8f8197a3779e21c92e6a848c5e3337c8e23197e754e15544ac32e619ca893c9ca26f15ececbaaf3cb951e72cfe870a477edcb1205b8e6573a1083bfa286c0091bec7226a2a56d93cf5518451835b1c0b24a4dce68091be3ee4951f6f8cedfa267fd4c15cb58d56f86f6086e471a380acd601c7642ca6f1db3d3e4c630498cc560fe2d8719c4d5778bf74c670f2ad1f24f2359012d6938ea2a500f7caeee5da2715d5b1dd0f13c7d631f6e3922bbce717bf61536d425b88055f427f39f021854b20bfb10a2be55c5571b80fbbb9477268cae04126b03341e685eaeb5533a48ac408fd3134daa184f3eb877d352ba7d34ef5c3526a5fbf50a29c77339dcedad44c13757467336fc025382654c9adad3a06bdebb28f04411d50a285073f2aff329078258d1d955d7a82ff3dcde0dba3a6a1e6dad1a39e05e24650d1ef50291a3a911d40e0381e93851730b7aa2646ac302ce606502ed612a07a989ff54d5a10720fd23d2a8fffc6f7bfa2a7330912b64acc5406576bedff3d004da81e3e00a7bae019dc2b5ddb76ff5e09176d49f820ad87c3af63d256c02cbabec590d5e819d61d85c3accc17d4e54e0636218d7473a955d9e346b47dceb28e563b404fdb82f4ea9bc530edf63100b9e0318c32aa7711e537fd0d6932f3e8b6ec02a00c6bb68d32e4aa961a5081eaf7117f94810f5589b1cec6133183a0dc960b5da3b64784c26fbf5fc118c359810af9aa40e5a9f87faa99ca72ff65f63d95525493247591c642868f47d96ca3dc9e40b77317d549b3ac0911461633416fc597ba94dd9dfc52b0053b9200a64dc5f11f92d93b5c432611e02fdc9e97f282c5d47340ddc3fa7dcdd9243717e15664426dc7df6be0ec6c919adfc642ac7179b3d0b3b6622331adde7f87ad15057617c2095761afd1ad74a32088d7d739e095e16d2635b635727206889704c9feb57f33ced6f792940b3db92b7282795906376d2376cb626f56e7dd965e1d5c9e9f5591c1f15f5b610bca40874eba0fa05912b0d5bc3a138cb4855f8b8f42e3f0521cd06b84ec06346ac0e2e745b2f720b1e4313e83450c6fa0039c4e5ee0507afae9c289498b3cb315f3fb0c8cb7bdc69c26c9a46a2e5e034e13cd9a7c12cfa1dd23096cd2b5544ec5d7104998bda161162607942799aa5af32fe29a97b32aa7dd8280b60901d3a21be145eaee98739c0f8acd3dec6992914e391c441e666792429965ea0efaffeda1bb3c9765666ba220057f5f89bea4aa72ef91a67a71712adb4560775d8527cb6c334c6f31e8d4914e193c57391f753aad747918b8b946ee3284bbade5820da38b9ee1b8f77624b32f565b624024f73f2167a9f4326bc08f9d0931fc364ce17cf0b4dfb865435ecb16a40a5d197178c1f5a17bdbcdb64849a9803a4c51baa8d6d314b2953e231d4ed44af05efda0e7ef15030294f9b5175c94d90bad6d8e55264695461fca5fc8899d05e7659e0ef644b2d773e5d6e3537e3bdcf1fcec3df2812f1a5a63158e52760ac41fb5e4ef8ab0a47a151b7eb5f4b09ff9a5c9a29b5b7e24f8b23a59a013e51e69b36d4c68e8688f9394dd3c52537000cf2a395a77ea8b75d8c9d384e8515f7c89704fab08dc5c16c1436ae9b6e79c72ade2e9d8afaaabe34ab257327f65bb8ca50aeeea93a57d86241b57ecbf76077a32fa6a8b7c2d9c4a2d9722dfa8f5be18536733552260afb60771ea345b122bff09151bc3714f61b789b30b620105862a7c9715ee636a9715146451add6cb42c082b2885d69b3dc07b487088246174e196a8557b55bad10b6f0a942e9cb092edf67f7bee0677cf032065b9e3a77ca292b9c4dc4fb3c3a5d5f3170314c351b92ae049e34236f10f1e79c248d46d9e56e2219419e18ce03d07fb3d1d938e2afe2bd9e87a863ed1ffe04c908c29c7b35090fd5f52b85a8bef39830f95ebf2542b4402d7f5c2701bcc8ae8d74e0e1511108382d10b5776e97b3d9588e92ec9e976e461dcb917dbb7478679639a183b2d6f9d936969f3e7699094558ee205933b94a67c2a097e5300485a6b290aef2ba2c1dcc33e1878f9db9ac468dc74894d480e1384876d67730151abc5701444f7dc19c8c1d4e2fb9fb7b9ffdb1e5fa9eab2cb956191bc0ef24935d1bf612119f7886cffc81085e14355e18a187dfb33b94c9e27bdf15c172653e40e7e0b86582c9e0e2afff3eb0e6a93d45ed4637c3ede5b3b465e29dbfa813dbb1ac205b7eaf7a87847f1ef7f807b43795854f73a6248face23a72dfd214564594e713ba61f59a57157b4de7f494096e628c604ea86f6d0d858c2ac9492eeab8d20a7bd7d6aa276ba620b45a3e720d58da07391579b6dc4c8520ec59eec75c1bbda8d10dd7e856ce06acb7686780cc042f627f685d4cb9636e6dec567391dc46b94b3692b953af14c04dd54b7cd1d15e7cb103651695da60a33d31c85a51b704cc503c4c7dca483573e8befa514f47e9d7689ba5396231ae4ae1375405c70e89aeb196b3ace0cebc81053271f58f87281c348cedc89a5a596fc705d590226abcac4d07324035061af9c1c111aa37773b146b74f00941379f50eb828bdff3c6fde17826ab2feca01488c8e01f0e44b8b78a2f531ad003584674d21135063304c40bb1713ecb4ed324c08cec4a443b5b058580061b372f2bd565f9c89033817d2b85ff2047a374ee58dd2e8dbfeecbebbd740de8023148bacced0db060235ae401852d70ee4f9ff8669dfede6f688d225018726ae44831025bfd912e785408afb2558cbde6599d2a6ed6634d7940f4eaeeace466b28c1afe8018a41f4b281ef9fa3d50430ff97c7462085b14eb4e1df39625019c955a897aa7c2b80fc5620ff04158e7b7834a18c08369e68f5c8209bafb15c9871970545705912228d10b8c4a34acac90a113f1c5c8ab2c9a964fe238f7ff1263d30b16651d948d32c2b8ea7b802ac278c60ec007bb6fef3b84a0575198bcd52c8feb2054d346dddcfd6cd569112b382452e0291b3cec28e77d30a4e148deb672c440ca61d046f24a9e92dbca13a560ab2de142881a6fd59873c8866d5f63d6c8120f375ddc900539a033d6c35dfc600757b8c3c35378d6e52a2467f2c6ee38fc90e04da52e0d1261b0a09c0ce1d50b955e7b3c0821ad31f927f7f34d7b6a0024419e52410270172ddcae7e921057f20368ae05977996507a585486eff54837e3de303bdb98ac31f52e941f191f08ba76e8d25fd61db00d02df00d7a50cbb8322fcb707803a645144a8a983d780ac1f9195fdf5d4cbeeaaea5c8a46cc2c741669f9a7e4bee2c2f37356895a7c5090730272174cb41747f14d2ffb86d8334858e61ddb53f8f82adf3","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
