<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"23c4f80b80a1957e91ec9b56275642c967be68dc9d171b86b911336a94668a7fceffb2e3af55d723bed6b6e649eb3fd3cc65bbd2dbd3de19df9abc1e252a2d999beeaabbfe828374ca6981540c707c53327d15b48f490626580260c8acb50bf491b2cb01ee9e7fe20b2a1e790a5b964e5dd9115b93e3b6405b2851047887df2153de3f1453e59f00cd80f827be1ca21204c783924a6f101fc0d4c3bf964bf17ae27e81459da08e5e93cd8415f4f70daacb9e8f8e1087aed46390078182cf6dedb511b183cea7d89fee9d971fb9598b06b8ebff2425d1e03b64b8fd9c9d43a2bce94878ab833f2ebebd22140f1baf92667c67c393a294cac023c2486e792806a5f2c66cb86a7271dc02739ad327f0d49d9ccaa5d0682aef795ccc67c46a617696edea52ef88588c6eeef0a6bce62d349fe082a87dc62b379b13329f97c85e46fa6089720b3990abfe285b9cf225ae5c95c95c5d29d53f6d7220fc36d20e04f3d409fe32be9457eced7b99566636a7a837394cb0944aae3b7a0b92c7729e213f45f22c0a68d15de4691bf933e4e1d9ec1a055f3f16df472269e6eaf94c7b9f60b5b31a73c90b106da3c6f5f186e191d0d83b74e39647483f4ebd9090c4f58b83e675707cbd97293553d2de351acaed1df75d7b3b9483caca1c33e3b005f2ebbd4b52f33ce998a984dfd77432b073b50af26501c5e9740ca2dc4eb2babd244ed0aaf70e369dabc1334dd45ee7a00f4f929783a50334e35923e70a2390901461d83b2b3f96f1c1a58c6040f148c88ae97ef86c2d8d32fb7aca11284a1ab5770875348b153c10fcffb101b92e4aed5bcaaf3b42e76622d9de03a2f897b56208346c21e9030ccee759dce1b6ad7f93df4a9a46e059165a6a38f6fb3bc6b11ec46c306bbdb2bac9774371a5dd23400186183c14543ce83fb50a4cc24010b8c10d3eb4e0a54d16c489182fab20f8f6e15462960e32b1cf1c8172f3d076df38106fd2fb570de0edb27c1fd35dc30ff561ac7c8fb5a6241c6e312933db7d1dbf0da54c2cdff61748e44e71678cd84dfc5c02628a2e7a9db13f2a909826e278514a4c8c2aa8db698f9101509082a6bcb608ed1181deccd6bcda76a912a03a8c6efbaaf49c58a54f3aaefbf783240141d030b7ea100bc51db67696600afa702a2fe294851b70cfbd364dd09c7c78e6a474d1403070d24e3063f5985c93363ae2f44efccb9f8a32ebc5852d8e051b12de1420b1150c0029c067662495f20a908fe911595f2de39c736c534d8f5aa9cc97625a90dd4192f3f02a7a5fbcee1d40d5dbbd76f6c0d892de5889807e0e170620538206e7cccecadadcfbaacc8fef4d7eec6b19d92860e4c1958363c1182d8aeaccdc0bb6be9b53c203a5367745506d0dfa23876837870415a8f9d21cbf78ed76dfa3255196fefc165bb7558b4dbe25f70d35907ef3f5d0e60d1339aa176817abb134636d0f17aaa02c04b3bcf889e15782b9301b960a547922787612f2252e099d83bf7b4dff365ccee7f6478c42c50d67c84c412765beae43323e9a4af50733e1b994382ad8083ec4c82477762feb6427171141618a11d21f0b38fc31684f9a4b9120468992ef3d7377425262aaf36d9bc6b01b2f4dec19f09671b579eca73129c71cbde63d3bbdd85dd4b70fedb41ec8f8de92829fc257a4d4c6d11b8c6890a4d3636370303d6f0da3af52137514401c64cf645c686f6f7c7c1892ecbbb32348200f6aff84203f77266a22ee95944e50c0d76d724876de8898ce041e4b83cb972a7a250d0af294c240681946de80a5f490a48c920be4bfd3d65f53ba52a8e0849efef2aca5e450a3d229613b229d0a1adc91aed7699f2e1b49144a2d85e5cb4bf2dcad8f1e7e63d114799fbfe235899e2f0a08f41af15e08a74816cc1aa35e800c254db373a36d776b845adda8654662d1e5fca27b855a44fdaa20f92d524e5d094d4c2efc7c53f715b336728da2dd10c085da99a0b33e7e47f776d1a7d93e4d58849d3f9cfbb78a77812aa0f23065875bfa67ad1f7428aa332b73e6709fb326a64da8279964e866999c24d303d57e5e58d3499f6e37d3fdb6c35c8a412b10f38da01f1a7f92ba01aa546df0e7a00b2c7ccfcc098dc27aca84b822fc5622065b05edaa5d88fc6dcff6851f7330946d99b9036e1d69eb15582ba12d2bd967ed80cd52b3ed6c4798ecc9a073f284abd5d58d9b9ba4328765e7ed34e3ce3537a61cb3e4203eaa183171290f1ff5f305950bd7188a23ea8261bfbf1dbb638433c5754d2cbace9468b19304db17cba89f480ba7980f2d79684bb54b0c3aaccd45ed413b4e83b9f5093aa33190be8c2b9f834d8a3bdf599cd0647ec92d76438543c927b18697ce57cc3a3fd0c03d51d82328801ccfd8252150ecfe9bdf109f7eada22de48a6bb514ec9769c61cb5a5b8bbcc19ba4cbce08c883b70ef6d889791345d8cdb0f49d2ffa06052cbe3f20bea5c611260a8dcf04f972c2df9c8cf2d723ceec2037472364f26277a851fbeec6dff12ff6edb1d1d4894c224528ca8aae156ae413083dafadc81ceaf9aa29214dd099d24f55d8e38e28cab8b0cf08c4e4a85151d85b76994deab66de41e84a2ce7a14d90d0d9e2fd2cdb4287e98e650aa1d15f157401a5e72650f4b0773501e324c39e188eafbecf2306202c11a52cab2a48f60dbfc9a052ad89e15c4f32015c2fd8669c4d1281617f87739d8e7f9b2cb220c9c22d961cb6048fd3fe6fc5c41e6accd051b95741923582d67ad51c8d399a9db4d786226d982427611b8765a524c7132e3724d8128801c159d4cb70551b8597db06d15e38f572c19b68d3c8d59d3c1ebc2dd8944a5566a97584cb1d9b664ae974825f92126e70a8200386231ba3860ee709adc4cccb6cc15064b901e33813ba41b07782babf9e329e14dce4b00232253d52b5f4d6958d108d73ad539538de5d2fbe3f1648c2b21df0dbd074c14f5875f7ad9ef4177bd9054adc24838564af198306b752e126c6d683714feee613bc8e69582ac61ee5651069cf3b607e5a1855684d9959034381e10bbe60bc016b876511514246e69cdfb56b285f893aa04a9b43f2b84fae0db9ae342367741c548cdff196b8071f2a58a6161121b11344d59a5816785a5cf33f9dc88af6dbe79c78c7297edb43edfe43d85a8d40ff2defcab774d098ab68342e570dd315f573238aed7851c5f05e981dae4fa94d2063d8071f5f21b5f0fd979a4b24c67ab61b24b42c0375df87b35aea0971ddc02ad6d425b52285d2de138dc962ee75396149a086bb6eef579cb240b078613a3859b2a2abc5b476ecbf09d71679b977aa2827144fbe8d6f7891f5fa3bc077c79fae830782921c72ac3c05e7b26a19145abe5ed47b96738a2a2adc9e8a16e371fcc823d4b522f9defb3b52e9e9311e2912b791a8e3e7e34f97d44fbda01e6218b133acb2c75f265fa0a0222ad8720e3e9a06a8ce5436f4815408c5c85cd1d7d30887e1e9b9efdb5179faaeef9598c5adacb3168e7c5782c7addf4c107eb0439f9c9ec4bda0f2ea1e5784b5c26a4e7d039cb9fb236357de30394da26fa58d7ecba785b0058f8b7f8a1ef7f935fbb8632a4fe14a9f9f6ec1772a67d99073876ee16a228fc6270dc988f6b240c82f7993eaff43d3858f142ca1c1e50efda01401b1522654c489b2061f966a2a11c1bbd1d664cc378eb01642f5a6a78003c0563b115ab51f475f0f3d567f4faeb08c4bdc4d74971349e43931242348c709e25bedaccd48d853bf6d3471c2a40ce4c73aef16b18ddded1d599dca0bd98e2b36daeff3e869de9a02e2fb25776e875b4f661be3a095cb7e8a9f12b9a1cfc6dada730088c5f24e83564affe6f5b0427fa1daae7045e4731c77087374b26f9a108b855b6c803275474bb2141e20a85f8a11c93db59357ecc9fc8ea0b551c87a9b624aa624f2ef84fb61c3198ba8f95f89fc4f927d4047095e0848b75cc765278327c3f4a9b77d4e1ed997aa06b9f36c816e8dd7947137f035d28714ee467a1679dd974e4a9e7ba8afac524bbdbcb87665ac1d521e096b2f697ed91f12c813b0db20febebebbee19caa07d0589f815f2837da4a40b0296257acc6ebbc11fcea7a5cbab1041f88087ec6f7a3adf23d012bdad0bcf554de5c7dc0aea9cbca2cd2cfcedbc36fb36dfb3b0179f8da9097e7aa86a1fc014ac63c5b67fdd49e883bfaa2ad566717367a470acc06169bf81dc154f2242e27c0fd7261f65f1a4755bd9c99b6d4e4bfbcbff97916515b4ee9f24b16e223d152fd9a0ab9eb88131493cd0425f6bf1651abd44cf0e403c84cca5776418de0bdf6608ee6786baa9cd9cc25d7448789f556afaed47126333d5d8bb1cce27b71288678d434206332d5e423683a6114d21068a573a1415183ad26a72fbebfbb4c5c2610507208d0e2737e1d7d163764e935b8d928020b4a278381677c169fcd2d1020d3037752db199cf6ef07c2855b06f56a5f6656b318a80ebd6471672930481a493b84690e700870439be088462c00a334038c9614552ee743aa0bcef6d80eeb14ec184a2db1a0691673cba3be5c66c8b4c6cdf944966a238dc197c7a817ce9ebbd3688c5c169e1ea8af124ce50b42492b83942f88e328173d4a59cbee545a5ab852da0b8899a91663d45d72d5d00f6ac65adad4ab4dbf6ba3d4e3badba2b4c4c9f9522c6c8fb7ad6ddc6c0855de46741d91a78bc7ac81d584cebe79dd24b852686c4af20d8d9eff2c7809a821ec8910d13091d23d629efe0bf8b8c6949f486e128b0783bc3d9ee8cc125aa68f1f0a90b823008c7e81e787adbfbbe74e2f8460ecf23604e25f96a8978ec449ffe75cb06dfd0ec168aed4f093b7a3d4f2d33828618409a63922e01fce3d8ca013133abf8ab79327e26e14b10106ccb6503dc037245e0fc187835323b109efe3c5863caf37becb7a8af59c0538ff85b5cd5f0c592e9ab9981cdb9fc574e5a1fb11aab2efaf0f4ddd91130d2ccbf1d3339633096c9078c288187ad50317b87278b8cbaf4491ba00b280a316a114a156ced234c74464e4036d8b7d3418dbc3afbe06a032d9f26c3ccceba284456908dfc9fd3c3610b93ebc78cdc89829071be0e9b99adf12ef9b8ca62019cb6006d35b3f4d90f2d73e3c76477614c07deb89c7ace931d08b555d0a63a35f30cc262801dfcf12d18c06aae82a7d5c6513082991a2c6c6f6a5a9097cc8a4f61c5c990531796b4b0262562942ed45159bf7f2cf1c8a279e791fee25fdd65fa1ede88e150e1f2e9dca8262c6674a62cc1801ff785cf4be0bb036da5f82e523ce539eea626243b616b9e2c5d4491db08a04586985c106d355ff3cd72a31d4483ff2a18631586265cbbf066925cbcd5b89edefa53580589e0358b4b4554c2c65047ec8168f8c7d27dee9298856278d9f88b71fe7311dcb8da8e4fc63f87134c72095ec31661292e782471162de877418c4f24c4a735ce352791a70daf9b0fd6f119ce0a2e784b4dfddff734d7bd47ab9fc1f140898b69b35a3a36530a04590bd4e3e7aa70871fc3a880b160c910473308fa0d0f3fe40a2d873da6aac4aa9b3da154dd6fdc144801940bf8e8f46d4a31981e692eb1a578cfd728ec789e9478637c81680e11b9c62f5333a7f6ba2c8d1ead0479a0bce80a3a7dd89f8e34b20b6b35ed2805fa429e22e4e4e570b0d9ef0d1dc3a56f4b31c00c95fd01f6114142a6c68f752dc4df902bb17291262e44e46815a390dc07e064c9bfab5ebda48c6d5e33fc10b889d666da12ec94fa18b73024006c9bec3bd607f69d09c9ec203f4de4b610355775301319e0cd699cf652183d8d930fc67107fcc1a99ecd92c49ba3fc34928966bd4fc327b624531315b9ef8758dc9f5ba34041fec488bd4a18598edab79d2c078daaa529831aabec9e32ec693ffcd64bf6427f3296b95af9389186146c1457dcd62b389e5d0ba2fa3f7de13aa3adc8f5bb43f488f5b53bdd2fc0df1671434a5f8d3e94afb0e81768d3f10e50e971a703f72e623ef6b318877725a33bada32b8ec2f3f6bd14296f51f3eacca719daa1d09546755bf5cda817ee6192fac9a03c00afc6b6a47c20e5f7ce6c7d629ee4b8ed5048382f65da5dc41d38965cee9a9159f49ec6094712a1613ecb8f60d4c6d71c87cbc138e7aa95a52f6ee97b1c68a93f2ab362fe5e0e7f026810ed34c980e5caf25ef214022c027990996cabf8188ff96ace1baae46d456cca0fecb4419a72fed0710ed7cff817a176c178cb5157e8983b08ebd429896eb782615b50718559da10aa63ace632e24aa893fb1cf2bf4fb712380775f8def57b9385b11bf3d01213adb550f54326fae125c093bbb57b364bfc1af3966e99c685b44598960edd68361523d2b6c530e9c8d1eafbe24fb03dcffbec5221c1e1008ccb107f8953aed1c7d86c37f2a3ab5d971c662cb2847a468c3ee5c57868027270422ebc2176a58e72f4aa5beb1827120e37d663d408f38a567c7f94da985b1b4d4058d44191e9cfc3f7c834bfaeb9b5b9b104df89062b36b3d299aaabda95921756610d23ede88bd2c01535835b1a3484c74d7b0d89f217ed6226f9d8006c5ce2518e00332eb3dfd3a94deb41b9d93a3aba486dca9b2c1535d26d9e2280aeca09002b65461ee04b74c803cba1e565832c679eadbbf190f06ed0fbb08346f1279b6358c5e8342ef86e25f431536742b6f4410e382f4abd0a9bb59a9435870f42e6b4985459bb1f5ac5229685490d2d742878ed048937a910247b17a4aa4db8044a4488f853ddfa119eae75853b823c9eca848ebb1f1e32471614bb9ff825b34966b895dfad0daa6d4537a79ceb2749f4d2eb29c99de793b0b62b171b9118acd989ec9c32c714051569ff1e4e4333a2b41f00775426c311394fc300f0b8191b8727c110a5761c476ef158b3b9025a88ee3802743b88686556aa47a4eecddc23ae137e1872b278656ce89af1705a6e71e6d4649b99babe8b8770f875fec5e7de2e98c5530da4b2a0a7e865185499b43f65f59a7e6e3804763ee80e5fed52e5bbedc9b44762ad878ba65f3625c07d455171fe3a75c2e357fa13f7d954d104f53b4579d6237d72210081f53240db95506c840a5b44e9fb2832db6bd9ba176e42dc66897084c8be74044fd9dfeef7fe5c0d96e7191d1d17b92e8bab79f60b2784b311def2a9ecae5f5bba055125a20ff67a678be2b660a88cc23ffb153e0932bb0b6c0a3c578e129b64e9df7e942e79021bceabc1efe4dc85e3d64844fa1e97f576a875cf9a86678735b81f03e2b3b5c56e886daf39f848b576e8d918aec3d32fabbfa0bf21d47ec8027628c0782a431c8d7ed90c1b662ac433ff18146223ef71f9263c8f7fb8093d75927fad339b8a7dd5612988ba72e21e8660a1a961c013b77768c0af76aa78c381d77ae707f368b46838771397dc3f4d9d39b4bbd656b1d19b7234604f5697c93ad1dc0448ed25868882cc69fd28dc0f3ecb56cb8da954c3c22df80092cf279e6afd489d08aa419ba440e20fe9288e834fec9a9693920b034eca6990e8369ebe6eab8b89717c6ff889af916a89dd45b92ea2f7ac35656f3d31fc1229fc0d75f56d7ae34c51bfe40810104aff86d4e9e17097b51e73e5e9a6085364bb6899b04cd46e151e5781324586413f21d737b83819dac43dd50b67c0f5f0d6aae7532c367e11afda2bdf161ca3be371cc4330a980344da1795576a8641c80c76a69c61cfb7a04398198b473cc97ca24f3dd38f828c77693b912f8fc2fa0183bc6b0920d2aeb973c72e6b9e67c08619368fb668b5290b098da7045a6f607f2aa19aa9583a3c32bfc3225712e0592ecac35a72f8939a3f157fb6c5000302884c1889bf19ab9f952c564ee4a3a0969ba63fa43fd107e4c84beb44744002db3b752512b63a98d9af28bcc4eb3adca459fa38758172bf05ab9671985d4d4787e9dad49ffb948584b6610f388bc87cae2cd538ebda5950263ab9db0036c19ead85ac0d3d3a8e92c32c1a36d2eec9fbeaa7c56468a11c6c7488c3f1159ccb8bb99406b0873f4b823f673e2a38a314bd458666282eff66248565ae73c6e9d3cec076118bb1fcd111322273a50a28ff8145b3044e56e779450cba8bd4ef841d9f59996c5224c4b6403853c814ff35a96455157a211206d0161aea4ce4b7c0ac6cc874a419bfedc6b2c8c440302df1c27b559e5eb3fb57ae332c407dd90582dfb7701195816415700f9220ed7863dd19c506264c68d4e7800f9734bbcf175fc36c5c671ca717cfb7edf8839c0808bcb8e6fdebd98920449d1252d234208dc3f95984788fe643aa2de3fe6662d099ebfab32801c60c38dae82691c3b5c801779e7b08c09dc9e743e515501edd5578c5c4027583958ceaa4a2f36666abacb6a9c875e64579dd66bb2f15720bb74cec90731dd20921b995c36b51baec5a69c8f5245f3777a573aa2da9c3a9e29209241ee593c62ca3298d3ed2289952cb6b6029d03d1f39b4469d3ad62b6dcdbbe9f3f21419dbccf66b7526b266a5a0f43eaafc3c81dc1693cb8d446be2159aa0cbda29a9a7ac9e747f2718e27b729c5b14b3beb2d40036fe2a997379e93a7ba7a52b4b288f416852f891900ccc149ff0322d209ea5c4984d8d730c500d7c3e31360e30995adf1535b35636d9b5deb8e7a9f7c8542713e0986de54a0254b29b585e256eabde177cc9eaecdc898732eb9efa9162f63763e94a6f76424d76359f8e3e02e4c6d7654eb0305a25c8557fd7b390e4c67d4d0422751002f62b0e40acdf4f9840320782d58f7fd9533749d73f2db8a77139ce019b18274a1d96f46c5315ff5ba882e8779318641bcd906001592fba20791e2e311bb27c98995ef11413808005d8a9b6837867dc2bb54be75332115ffd12ef686d532f16d815c4fa3009a329a01c7f9bd85154692442a70a0259dceb9f7e47640cc5c600704e0d050b2a02553fd6e164828304579b0c3d1a7649bfe2a8edf8c4df3ee2eac15c20438ed09cde53f6d4dfa81687559ed79aeaff554972a3cffd986d52cfdbc8055f49b412d4e7ac1cb273c352fead28332a5c47eb5e19402deb106982403033a5320218279bcefc6d7654ede585dea4b0d935c664da71b8c65fb1652b2e2a0dd1025f6e99507b4e00694d128850b2c449f8237dd6d5b16f41cfafb79e3942dfca9ff57eded8b87bf4fc0fcdeeaaa527ad77c5d7ce8c595a40e302b4485834fd2f2b97d13276097e87b1352c58fb17ede560c7e2ce8356aa85a63aeceddf43210533d4be057c413fef5b236633f5bfca8f70aaa783ebee0744964850629aad99f3dcbf579462dd017d6df9d2a65ef0a6e9e2ba8d357906358ef541c1ebb31c65b6e564bd830962dc1d224acff259fe000159abaa3cf26f4d08caeeb3ec53852729c3434fe0041bf723387202d2e813baf8f9d9da11473cadcf260a9e8374069180e35bccb8e8bb8c37835d2d4d1d1c32a15e97262757a5dcb1054514b0059b824d53a62e3cb29aac04c4df11e58ae5038824f897305491c1839300432bfd7c2cde846f6f7fb3ba260c65631bbcaa595af2a155502dcdfc16ea16d73a2878411c03d2dfd1a67b72a85d2b6e5f9bc70ad6eaf4136deda22e0c60a62e958876f0a1f7c892ae365dfa8bfe6fed84a4a4bef29153f1c507c48fddd462a71648e1592be01b758694723e96e2c19340ad2be16f8c32dd5285ba467a59ed6224531a165f158a7438aacf2606f53f7472ca423130fd313ba80aed4b487a58d7956070f5af115d0e85a05450be7f5d843fbd7d4a1e1d275d736a6b4365b7809dd001740a74f65d1fc3ac3a64ca6ea3803204858d0a8fee0bfe75cdb3a3f185c9085cfddf48fc297e1ef5459b96938c3be578273605dfd1e3bd12eee647dd0fe223fd24a589ad568ebf9018568687813b2ecc911528dc1916bbed3fe98d085e0efa177229c5dabbf7f826a31a7f238fa693ce59f00749a36a7e66b134f9abff402e50f550a8aed0b638197a79345f65f867c10af1798d9fad53db21c78588966dad7b980bc786b98c1d5ae00c09ad1fb6552d6add43b7dee4f9733c886b06cb6c1afe9860c412a7b63ce45139e40272422e4d175ce3e1ce94a38355523202b8f668728052f523a3585a14ec546ed5a2c9ad3d0f2651a1c4d5d346ea4cafbae35a5799489b472e5d08d8aa2182e2562cf64eee9279365e6acddb93b6bc75bd3f3c317e46167a14a0d432ce8ecf730df11d0926faa6a066749f21e19a3252194e06814d6d3206b546e4ff8c5bf2aee8b8dbc59bb9c29b32734a65fb40bcacccb23b56d3f525f28ef744e860ab905a27f4ae7974fa6663a763366c00b1da64cb34970a05aabf747efb0daac24f69f3daa5ac59676d28faeac68ed149ff12da50d22e66764032f75c62e8334b399d9c887e9a09837b85b54bae7cd4f83a909d68746ff356553a964273efe195c924a67c7afdf5a2b303d2be8903fae13e7dafaf634012f687ef5c7f782fd56a68739508d2baacb2ff7f594c59887887aed9ba62efb7bd640d7225dc72f1bdc6255c1117a17442602cd53b652133934e1e4c6e30de73cbab5952fb9fafc399268a1346f35e3a4640289c295f1b29e98316e3025c94f2060a0cec4001172f39ed4c8a2992fb4dbfdcf1dd5b37ec9d3c245e03b5e759e4f6b309ae7de134655a9187527597da7df207bae9d97b46585d497d5e932ceb7c9807fc5d2a47526f45bb5a35e4e2666fa41a33a562546bee9353e4c1231d1a416ef468110856e90f8ae54862b86f869ee00103942984618bf75eb94f1aea4c82a4a2ea086c06e07a1b820c5ad9804ce5ddab61380e7753e7117c9b2c8a27ab739b660359be24d302e4cf9bd2198ff628a7e67cb3657b0c132448524b5cea9389594091128e5aef5abb4ef1ff5bc2e1e15663f120c2661c0dced4f46646b221b16f97389a47c694ceaa7cd8e2c9471e8e867d088513151dab273a0805b8e9c50ad7460edca8c0d8574557a4ae65997361668c0a0eecd8274df68fc7b373b8a088e6cb59895548945cb8d50db1dd6701c59b9626effea1dd9261fa32856db80e2fc60d607e1e9afa73fe98ca7819ca781dc101d46dda758e39e2f8a50f9d65ba330fe2f417fa779dd35c2eff139645538c4867e056975dc816a73e02c11a792857b9c62485225e72dc774102d42d6b1ef83b1e1bd71e29322b3ff3cf6364a839f60757634482ff39ce292efa4627b469b59cf73f6be25a8f4645f4c7961f5b94e7cf0179bbff2a423ca9c222a60839a34307cd294b7a58018a9441d1cfc52c6028d0ac2011376789f5bc17fdc533d2951801f1e0854da4e97fc3ee32ef5bb26601028298198e3cb545eedf8ffb3a02e304350e342ebc99e004393f711539cf659b6882d969de803b6ea37e42e8f3035b6d15b37e373f360a80aef58fd0dc31c9c4a8110724c53c2bd6880d4b6f0e60e00d654b16c6a3d3a6abec7c3314ce48aa7fb6ed2fad4747dd72307fd08ba082d8c814d78393c3a81db24968c16e25dfd5030c476947be291909d2d13080f368c7b890c5574e80605a5621330b59a27bf01620c2e2870de8077ef408f94a33928c8b34bf3461b9f0708948a884cda3b47d8517f274c0e67a1fcf4a2c1da2d752cf4c7156dc2a1edc540a6b7d9c26634a664de332f9a2efecd06cd23ebe2f8fdcf366de2f58c9b74cc66698d6cc19928ac0bf7e65837b62d78604ed0184ac85a814bb98eda6424e5b0c2769001f525bbd212ad44036908ad0e41a5ccf1d0a9ee7ff1b1014b72dea9df482e9521f5c64bfa3c83615bc52591c5e3772da7a3685101a5181857d4b84824bf1ef33ae044a8e44c7a31f65bf4156b2ea966c3c5244475ce660c7847abf28ab41e8ac691b53cb07663bb15fa1fea914136d25048286fe993450a54b88f365fe1127b01dbef2bb8821b960d4644aed9750ec00eddc5d8a2f55ae54b4240d5b0178e3eca28fbda244a5e7a7e0e2cb403bdf0855e016e6a6448a2a597704df1a3c0d176d70d07d6fcfdcac9f8a2d48fa70987206c9c2eb0fd32e3a8601f67ec12e4f82af9d0fc9537e21c91568dae184a61ce0d02c42869ef7a5a14a4a6c09247e51b60ee084186a9796df4791ec96c605e6c35818b590e99577306472a835b35f550593a2e1e273a3962643a43de58a4d25ea98ed73e2f374b715182c4b94255d20ebd393652d21062c550321b6e269ebb94fb42868333aca8c3e9e9097918beddd41ca29d41b33b6204b6d2266feb86c76a389709589796dad91512196dc235e4db6f55733f00efbdf928f285a54e6e535f47e2d15155da93c0b28d7dfe563b1333bfbdb44de2103ae4bf86a7291508db206d0c9ea9accb79621d637f4a0c14953add95694750ddf26ce5e8114259089558331ec307bb059d814249736bb0d97521663e7cd6d4674bb8c7929c7e075491d0d3f0f7b0ddad1f4852b94c2dea392451b30e5260b7a74dad5786a0b9418a84aeefd9c302ec49a7cbf61e1c5fd15d5a0db3bd1353f0a3ce8869ec7caecf8199ad8792bd79fa947e3c216608f1f3b90c8d64a02731365b03ff3a20d6d117714265ab68253e9d40fce8f5919b3cf5ad66bb34a2ec7c9dd9f684064fc6da1b524d57f6b616da0d87f7c7cdc39a4792fdf135dd73400e5b05157d4aac66d93b6dc4b7a0b8d6b90e9fc1e07c8e3d47d22a24effffee088ed03d85738a27407656f5492d3e6405eaf5c9d020fe817d33799dd7cb72f9c12d8cecf12cbfe8377f907142307608eda869b21f579b7e7464803bb17513fd7fb7ce2d4333957d0d22c7b626f1a71c83f577d27c3ed52bc84fac2faeb7514dae68d3147f681226ddf281b1f8672b9c0855961798e74473ca6cf23cd2df42f426ec4eb56608b2a404d7bb7c7861f064a8dd5e883ea9fb0f7d32b5ef9bf1c616fc068e01941942d8177034c101b32a69023ca6df5d3231640d933123513a8077def1c21a9cd48a4e3a10710fbf62b64c08d1a2a1434b6bfdf97e5390fd371e46b7c9d96fb9e7d680a3c4dfa060d3f37ca54a4f2c4ea435f09929ee0b6cbfdf9e2eafcfe4f83add0c16a398c3adf381a3d97e743cf2e660c41876588969a737b52cf8c901a9b4a66a5f159125ae5b8c468cbc64f948efbcc74850ab4f31e9cad5c7c25af4d12fbaf2819a06a0217f6ae556c9b81a7973ef910576cc7006d60866ea3b325aef5c1f8c205dca8a237496d4a91a7f6929129bae49ea3160b7305a0a3009106ee5f80be5d6446644d480dddaec3adf3f5118f07cdaea9a5b5c968b5e548e901eb7ece4b53d079982ec9a8506af49e2bb349f8bab5f117244b716b3023b86a452b656ab11a990384cfa68b1cfa984ea4217e81d87336e3754293b130af5bd88c0aed972b90ebbf9a8b25e9cd32968d0d5ad2ed01ec2b07fb0b597e327a7d63313ca5c4a59375687e4f16636a94109faf9bafa620b0aed895bb20a7b6fb59e8cbbaf7f37c985254dc0587260ba4c346e04e44e3449e9d366398b8be1cc134917e9019c8e2f96915bc54112dbf21bcb62bbc8b823f0d89d4f0e24ab32e7ad4a705fbb64417dbd4982b4a6ee9daf8ca7b74dd6e0b3da6ae67e899f08622ea9287f0076652e07837b71a795bfd2c1949e37dd42a0c987653fa7ed066e0380838634672084ddda1465d6712b7ef35672bd546e015ee10e54c4c858c7ed74fd89e5b55bbd6018c4be6a7853bdf847a2d116aad2c52d2cc674896bc79ef7963a1f490a4b0a9a6ad1447f558e122078c4d156b441ed483730f2b1a9d04f40345d8c8423acf3868b3ab695e0c4332b16da9fbf24104882de2b46d7a62ea307ca8701c0de85f4a2c910f03cfc635cb8297a8512e3043f4ceb83d836fa6b645a80ba4dbedcc08b474cf6549714d3497f0abc322604250c9b11ec9b5131f9392a7a92f7b0f644db7eac09b638f09b77f22c0f113fcd0a2548cfcc898d9d58329ba9d8c9f5957a9b0456a0557a4be2844fad6e421fd01701aa56f30d4598ea9f2c10ffb2593cfecf67659e010a93776467c7a6aad862ed52e06d5c3d608936b8f0c956f34579265365eeec2692cf45e1dac64bcf183525fbbae7b4cd9c4ff0d68ef90db95835b7b948c7427535e8f1c6070d0ff5a988978fa9602d45cc638856322fb9bd7187191f9ca4e8c708193b3472a101ae642cd634e9d03c0c68e913081b3d2ee2b48f465d36f967e7d5e26a901f412b9f51b1dfa42851016a28b6337145b3f283057f223a27442a32373874a88584be3b53a37f02b599b24f112380a115c398dca4c263aec4df2d3b3f4e302e7c45c8aa0bdc384d4d97920ca03aa8c2697ab7e0287f1fc354b9459c983d9c46f382c816d7c01a18d3006351594a2d4cbeecb2990a240ea204f302b5f3404b98c87602bb3b112ceb9803f18cfdd7713c29c5fbb174ffdb47b058f2e9cf99d484d5f10d652ed0e529a967527534532d7533fda3520aa8bcb538263e5b7a3d2cd5be932e69f6ec19d343f0977ad64884d960e40217b813de1c0679fe26c54b0fac79fd10b9bab00dbf664d7ff0be6541cf7eef82ef215421b4fc07122722931a63d500197cfa25c03c0e78dd57bf6a58c5e813cc000dd3c0923053629d8443251e6a6e43d71702e27384284bf4c5aca81f691fbff58355becdadf79896814cbe2598a9762a72e69b4f1700d3be49d04a5110e934c3456582f0a85898877fa36b0e50a9301b300359b3838cf73b72a6a8c13fb3ce75fe8d4841ac7ed98ad4836ecae033c33abbe3eebe87d92e912713ba137a0b03640a3944a8f053d6cd9c2a419cb3e105274b97ab148e6ee0f0d12f5576b7b4009e96d6e4b59ee45027d4fef297d7e1f2ac235e7dae0b11c3a8ada4b64778b317fda7f4678625732ad1d8dc8d54c6738588c598a9b5f92f06d419126edd600a2c9c9e4c5c7730917f292514f684c4420c607fc20718c75807dca7e01c4237a9fe5bd53d4d4d5c47f833ec7f169fcafef86c5bccd9ad5489830268427c3663776bb96771f86daa1a88d1e58b2172aea4b1d7212966e0fe2a4032c2e0efbd1cc86b41d30be2ba23b61faba6217db6c07a8e9fb40a9789278a719b3eccd36c990fa59b07fdf058014868fb57d03e9dc78d5ef5b3d855a15fa9174c47400267db19ebbc4fdec53f6644fae39e0c382216a26d1425f25c7cdc1a57432c354127a0ed6bb3e4e9133289a8ecfe2abaf3c1f2532b01d1b1ba02d0935b01293f372ec78e2e7e4f4318ce4f9c23e44de917c4117c12b17c244dfb5b2c62278403961f0e61b0cecc2e854cdc748b3e3458cf27f59b38dc46274834f09d53d9a2618e9818242482f73fc55cde9692d68183a822474f5e29844c6d2bc5abd4a48aa000c73de9cb76b76ae90ad7ca5ee8885f1f95c2189ef5042e8c298848915208e366cba53c83ad101d0e176d701730b8859d63a8feef4fef9a65a4f7b1ecbc8a3a6d191a7ea7aaa5b815cb2a67cd9f70df0f8f474fdd583c622b4d54a1622533f0f65ab1f3a359ea1304534c67980a82622f21e2da807e13bb446752","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
