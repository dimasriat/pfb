<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"347e8c7e51c94a9eb74c80246ed31b0048e7be2b9d3ebfe12cc8f03c67bf70544fa0c1cf34ee6389808f353548283558da70d860811d5df5248da23a44155e552316f092975b34038824c3eec4cda519eb8371330c00638e26b1f912163a65f65ad77f03bc759a9663148b2d498ea2f309e1dc702ad6493a268911c302a546a63f0bb49357a9537bf5a29912ec7a3ca2c49163d64402d05de115e2dacf7bdc86c5fcb3b5ecb53faa0f9c63ea464ca8f7b43078e17b3ff0ef7f1e6b1b11855d7743bf0ba5985fc17e92cb0a4d926cd1d260a2c053c1e028d9b863d8895d79066f7d52a9a7bf5d5d9bb3817d83c6de8b3443d3de1bd8ad9682d21bf138e3265895092a24b7c6dfaf3bace315388a6176c1f925ba220a8a9c3ef1c0d21ffee7cc857e531d29e39d5506332efe71e6d5a3f08b25d96a8561b8b1f181fdeea72c1a608b0fd387e2859ddfaa2a7e00186b6b5a47e22138f30529953f18555b9c8342f036cb3975354e4fd99952a134bb6a85d7c17f3fbfea3c826f01bda6244857ee1c29ae7eb7292fd97a6efc432b5a36269f274c265fd6c4380939c89d699e584939304dcfb5a1f6c9120ad997c0b98de028dbbfa75c8aa4f52c704a5e3288b8a85b48daf62ac5eac7c8607d6d2a7df049ac29e5aa22df22430c598c94def4abf08fdb9a5531882eaa3192b559ffae6275ae7bceb7d6e8520d9c70c9982c84e4acb5e38a901ad55e90ac278dced3db6fcf89b368c52f79267d05dc7d88566b898fe2f3b62a652ca082c8bf67feb305bd744605cda86f49af783e4b90a46721214844702826573a66b7518c627bdc698c79f5ca58a737795dbab376173bbb9e95e77c74f513d40d7b3e414c4fa011af8dd507fe6085079b2cc56be74f9b312beb4c7e40c35a783716a89bedd925c56c2d6ac7a06b0d0f635da3d36877aa5974d86736448e87b1f3d6e4d6a22f2f7f9a579f28a4c92fbe8b716d872d053a4791d840b63b76f7ebecf0396efa74d8f6af6cfba6804514a7e18d7f164947bd5319ceae695d53bf8e87718edf2ed0e1ca370c841ef399d83d97feeac5e594406fe52818ebdb3f32eaafb8749164394527b59037ea26f5edee5a15750222afb88715d179134be1275e8c633cce537a525945c22cb114f8190c0d9a92cf809c7eb2a8c3c0db7b25364adae9732fbddaf5b0d5c6d6dec03ebf94c2fdae1d8dc7a997d7ef97fa206c59f92c91eca231e7aa41f617e40aaa24edfea4e44df5419ecaab50b7275dc4506085eaf86772f44b7f4b5574ff61adb96a1c148ab2acd5a7488adfee5fbbf5f2fb263f778f7092202fe87bc9a9bbcd5f43c71938408c8b275afa8d280e609f8caebfe3767a3d69ac71b6025e8053227a2e87760c39458a754273c51384d804891efdc8903d662442c3d26f97dc749b3d0573fde80a1e5b99bc86199895153d159415413dfd683e15636ab08f8d09b4b3ea6a66c4bc2e0db690d6e1ba39715d0c6996628543320cd99728cdb3dff91cec8e1714b58c1f99f5c59ec4116331105deae8f16c0033fc80ca4ecec71e333e17f8257e63a63a4abcaf4d8689cdb3f2eb91623644c6e6170b1c853827945682445c7b82fff343bb4327afdaee14208b97af15747f9e64c2f4a17a70bc61253b030f06550ef09cf0d8ec49b419756eb489d3bd4132a68bc546d07d038cd8554f8a25f1d68fe76ddab9d3bb3ef4a4242ac7ad200c9d31523d94c165060690bc15fe79815e4689d7419f8b6f8837624b6a74de230b9f5e9b19a2c5f148ae08471d759f2acab2540f036d8d4ac20684117dfa29be89fd65155c06c7882c66cf4a22f6605d07a624c9473503f66a1db6f977bd987e7617f31d20df97fc3a0299f9d2700c104e7ebc6f2acc2c7add564e46e6df013d7ce7f14eae3f6b648976e69fac82b1357f06c7ff7fb502afe21873930a75cf5c2b9bc3605f2b25ba7156ae4a7dd1d4c3cf7163e27cf1a718d6f27bbc46c494a69bd81a6965d5a24d713ea7deb48a53cdeef7a073a9056b725eea2d8e4af2b3f7aff6e39a73661327856fdde6549974de8fd66b46142cab6d71428d18fa63a6093686c760e136f2f592e6a63b9cff87e7eb6e68795f1137bcf536936d420b42107da4f65a9121820ebe31bf861b3b3b72cde9faff16e3d6913a4ca55bcdcacae425d750cc62a15f35a4bd757741c41bd352412f3d1daeb34aca316472730961dcb932fac759f31fbdcc713343d95f796eca81b2a6a1c18af037db30f36b50b35ade1e4d484e959e565e4b99ae8232925889c9e7447bd42347f422259e036534e4309183bbc9e34d1d45d5615c0e81d724d241ac7ce186b3ce78ababcbf8842a5710aef6f20fd9ad8d55bc50ef60480314b3ac49c9f4a9f4c82b74ea3def1cfbeb72903f8690f31d3d7edce54ce9beb4a4f1e53323da97d7261db6d48f1a851161836f0c7c5dcd40df247d96c2d5ed35b31c4178044c6bf5bf65f35005dfb80c8fc19c42b53d810d65f8cf8cf90b4a3fcaace52401adc3787ee5fd6a5fd85bbffee023afb37bb540c6d1f26661af70da0cf80fe204b0409dbe3b87b5cecac0b243d85651e857cbd801954f60b5acd0e0b2df24504fb0bb815f7ca4353683d35370b94b8925e8ccf40a8c659e9d54c95898df939b8ced04d38af0881fa07fae43277cb189c3af1d8ce33ac7bbf3230dbc0ce3c453f28f4d01e084f5c478b878d60373f5ad78ea4480406b9688a978ca62dc703fc1aacc5d8d0247583cc4c8aa2568c5e2ab124ae656fc4ed816a31fa289ddc2a52532a5f2bc1860977b49699aabab4ad1c2696b6c98cb3e1ebd2ef2f77b7e08447546790eac25f82dc34ba2e22253c02dc527be1b97f7deb78006c1edf033894b3d4e90ebb473860f8fb1a12e07d79b3f14da628cdc8303415c65caf42fe2a8c2734986b58b78dc363d8c90cf107ec470df2f0cb3c19391b00c57b2af07ce59418131e6165ad4db0eb91a0d2eb6e1a4266e77d2207f9dc3497dfeae655c48620b8713b94711e64413ed4f7b5fafef4dcdfaeb30473549940688518b530104284445f403768dae2319760deee1154736656806bee7c47183942b7daf5fa770b7c59343e728f045194bb509945c1a44e59fba4c4f6b8f6fe02f26c05cf710fff7446d6998ad8c0c9a90b0f69b0a209df7d69a453758584d6adbac56e4891fc7838aa904366070d6dea3ae33966e581f3e3ac0fa300643bfe7a793845cfadac304eac4f7aa6ea406ab5d875a7cfbc886ee6f0a3e412360e261b302ef0a15eab81604d2b533831338952f75a1cc15fd36b5e77f6399c9036558c76a7335cf341be86003f516d28b7c102291e194a3650d4da39f232ae8390917740fe2396e4cf4261519e7dfab9c9112dff1638059b28398640642b5199df1fdbc5bf62568ddacf581f719016d374fa6061274f6c69c04512bbac1cb45f27f417e2e6412c4f5d9559b3a46ba73944bf07f09646068dc0ff963a12a971a6e3eeb57d7d3a6ad8374d9ba82f47567e3df1630ed20eb52ed07c78d774457cc2ac8ae92043ec2be8003ce1da2f59d15588f5cc8a5e7231500e42e6c916c6e42c714541ef1c2c50d1eac99ae60c90562c12f29217c47d55c910c77edddd9d6340d9a1be4bac863f7e309587be41c8318b637f83278342ee5fdd878fa3f20605c62df4ba6a6858ccba6eb18863cd69c30b2f273e28566ba3f4821bb9988fed38858bf0e17f37338a64684285078104061838fe1782917ec4deb66d90909f47e74f418d4be02695676d080f040fafe6dc266987c7cad55afc4362726bd110851d1b03e6c8634d83b895017efd5ab287e9db62f3ad5d409b88264095492f73dc667ba182b6b5c482ed302eea182b4362375344413678eff8af26e56c84b2945cf63c5fbe1369e2f702524970123dbc72f6ce490f29fb4da031d42b4d33d7c21330d3fd029726e1e0c681b4033803d09f0a1912d2f09f0a515d0ef4808683b57e22c9f4bff3b164859a7565e50046f820d293329872b95cff9f7f1f6d2fd4b1317e86d7a0c8ca141ccb0458e2d3352d626add873f4c5d546fec636dd79858d67b9155234369b1bda47f630b9c1668efedc5ac0a586a5d8524fbb2bedb67317af41114a8bf32bdb0a780c3b15fa47492af5308202a6649c42e30d9e2ea2933715b799d5f04a80509032e9ab76ae82fe5363407da545353fd02505dfab8121406d21a14e3f2aeca29e6bea2bb6f21cdf71f00e4d8ba2f8a39f17c240b2b5560f816371762ab4f9833207e2dfa1c1ec9839dabf06997b582e8b9492f69cbc560f2a99316aa5d3d21c2ba43c8090441a75b332f3ebb4b1457c900a83070a3d9356c03661511038736c9cb92ec5c711882bb00fe9ca2b4e2610af0c8012ba434e85406965db228ccf837ee423ca88ca0b774f27abf8d39db368ac8267a32c2ad4f56c0d7210516baf4968cf85c553d15ef29ac72d23cbdf32b46e542b8055409a34cfabfc649a6ff1f6d6cdcb94b9b17c21642e81093122290a20d3c0de5fb0213570296b03c2380ce466481521fe7f42b7f953b8bed8db104ed724885b375da852a44eb4857d152eaf8c447b93288e27468a84005764fa7b8873dc3adc34ea5eda92db51e07b6d85c121154cb4306adb034d51038a60e13a81864c9fcb0be2842a1c2151709b3b6c532f21120bf3c8b65e95540155640c8efd3786ebbd89121baee834db84b80789ed26174c5a4cd92ce42f754cb1cc980a3700fc4f8aaae8de2e316b9afb21d9e6d375318a98f4f869f08b13f74bbdfb837b5e52d7de79a7f3f851cbe683abb647cd585eee6907ed50a86fa37dd07ca74cb07a7b73e53c54dc47fd6f3c2beca080d4912b94d6caa2154f95cd6db842ca810cf60346bc72eec06e4c49e70e879a49eca67c97d3679dac7f782e2f25f25fa86f7e04902f6ba0ba1d5b99bb4a8c2f74a858069b18529a71bd1f32574c9d399b0c604c59ff03435ee2a8db40eb1976616a95de6d92e1b4a0202c210eaedbadacce6b39422a45d41fe082d46863dadab4c1292b6832092493d95b599efaa80a51a4c9f96174ecf1e208d772f89ce6adca559d6215121ea2c09f05d8c886665c1f6402a4a2a3beb48ace74195374825fc55f0b3c361f5002474684687f1302778eaf5e29c49a80fb5119eee614d597325be1a187d7eb90e1cf2cde955e2fcec6ef29c39ee1cb886b230060a11d0913a820304da7010a5f700eaf6e4a47b79122e4d4994a14f6eb332fc25e6279944cbe0a653bc5fdd4c5811757891d60719eee47477959c126f5cad074c405cad2c8cf9416ad24bfab072fdbb020b2310270ab33dc445cda23f84ad3890504eb2a04d546805288794cda0cec8e01e9fc9e6ae315e4b035d1e1907e73fcab057064fe3f859f0714a79614a5481ce9ff365812c04078c9a707aa6d88e28ba41b996839e73ab0411771407bee860c0d684d0cf38c80528754903509fdabc953730f53e09d878baa4a59a2e8e325f354c4db1de97b2451c5996778bafd4b96224255ae42adae2e936a426267b9d98a3d1731a60a3df4f65c50905856467e5bdc438a44b7f78c50af75b6997ce1a1785fe435b9cffcdcb5584700b1899328c765f54caec3b70f66e354478529454f1b3828f57c2862fdc34a3f1182d5dd08a67f846e5d70b55e2884e06464a498433a5552e32c9b10a7dcd229928811b152b2baf920c47fecc2e5cd9b0df727960c6bbbea1e90a8b6450f0041ad3dcfd3a5a271774d20ce70ccb74af23da4b40a1344b01cf81f4b1756c1ff425d5c8c764b1a8df81d82742b0f72a9ac2e7249ae78d3dcac921e70aa55d80af5890df85c9a2e16aa0f80f1f910699c12d559f863c8c37795f3228f71cd4b41161b5702946721c6351ece41a6b74ee8d65cf5789140e246211321a22107e9efc557fd15da03bf9a38901db58f0ca5ff1e5dc5297a9b3235531296e3071ab2ba5bc060be17260b0678b79bbd0ac50cee439e1fe0cbc612ed5ddf2402736a7971dbaaa9dc33e5fbadaf9989248520de4223e87de1f7c36f67872636346e896340de09c66cd4bfe8c526db4757693edbac54fecc66cf88be7ca06cec76a78302022459b2430e3db334b39292242b2ca5ced71a21e60c112e35772d2b6fec88890714dd69d8b3604d81b7a7e86058306f8c2c6167a63f1d2c4a8fa60a36d31de2abd955655bcf62e830810e8f553d5ce4fc73ca79ec3f1789faf6be522e634e6becb2db757028450690390748ada9c20bc15c0116c76b23777cf6ce0518529b17e23d754c30fbbbf1a3b8403066d60fece7232905561b84ea8d53dff3d8cc67cfa46314ed6f46e22d60f9078e8e8433da12ed951785beace6aaefda76af8d5b4855b895753214eba0809e0d7330493a07adaa87490ea554a549f3b29a27df1c891aa07613d0a57ebd4173517c3584c7e4fb7c1a178c35c7103f9e037b397e5a2c5e9a10582bdafe357bdf5dbb0dc3d5b753cafdd9ba468be49391a300e29a78b12cc5622d1ae1aac727cf9dfeb89ffe4ff2b687fda69475a6e703e93dc2636e3991fed5bd4ec10062ac895eeb215a87b016838fdf9ada054899d4e2aeca2298156ca5c3adfcbe8448d5732b81a543e9e4954488f062f8e1cef640db9d43f0a4036e0b4ebff17a182a548aa893a5a49e1c06d40fd211484827479f42401f77fc2748d940f2516ac07459c9e1f838f4c0fe43c47709b32f4416375b4e22fbc2e0f6089927ef761130ab195fa2be8aa7e8ca26154722661c08714d362976c06a996358421b4e6dda6dfbad5b8f5aaba5ddcff5d1becb4a959cc96539ca9764e84b6e22869a5a76a848ff605358dd64d2ca36a40619d709d70339426a3265accb5bf43cdeb58df49c6cd37d7149714f08a97a278092301bb686ac3b2762b68efd1701588d85926004dc5e0690378df922ca630a5e2ab111e05da7ddf03ac6c3240e808fcbf7c11b74613cdcf334d86e72c9f69ce86487be50738c3ce996588ed6b3933a4d8a0b0514cf29ba55947a64b8d21da78278ab39297d2676f61983d399950cbab7778aec34b0b71f35d7c696e6f93934c4e5baf096939f807280a0a31fb02d1ce674cfee5e0f36e79c98ccb3b6d7a3d9b045360381453b4799b1e67e109fdd84463f6cb47dc663775581286ca29bcda3e46a6251d6ea1043702797aac3979f59729960ba231350f1fbdafadefdae844017dec9d193f1293559f0423a1213c8b3b79cc2dd3a14133b7c3bcf7685eb29007347c19d6e17a9f2e0ce4af7e2b1bae0fef5491b3a8a934ee315e449e730380740127346f8f2047c69401ec3064f5a29ac3928fa261b913e00e30e74201773e575bf0c16335a1ba4d1eb54a52abb8935f423d4160e281fe35c35e868dbd63be00c3e19997593a11f8849a2ff92f3ab6aff8fd4d8cc09bb2c86bad46ad970dda514e48a7211b90d3dff3dde35383908cfa924e09e64659e86184280ae6354c4a4831067698e6922cc12e86f66d076e7bae13d27449e29fa9ce4013e1ffde6d436e19e79debb0021710a4dff890d767feba27587490ed50f0f01511422e056336a036e01a12298aca2e32ef4f845f951b4df8dbed72dbc8ed00fd9b6458cbb53588b53570611b4a803be522cbe0d613e308183269e03ca0b91feac858028d4f660074e6ce4738ad450de3173a54d805e8f8afb77d5bbebf21d7cd5727e6142b4962b88b27a1d33110b7a84097f0818ac23d38458bde0d5d5bdb6545675f15f0cb13c704fd625fed995bcd03cce5129d6b37d75e0fe5386b49f2c7ef4054a122c20131cc1bff8e2989495d0690acb4ad918f6a5029b71acdf44effa4e92ae290d3827918fb8bbdea1f3bcfa592b31ad776876d8e8aeeb6aa6d67a0dc888977c3d1eaae6a529faf017baaa3ec99d5f7bec49748209dda006592047695a5d423a2b1f12ebab8f1e28810b5eba0fe4f4a79c11704a458bd63eee908998a5e27688bd64194ae6fd5980b53c0728c1e8d41e68fc374d2dd2e5e0b66e88b54d6fb613421841dd7d8395b1167bc369406128c82c5d36c85183b6d87484f7fe69063d53106941069bdaee999b7cd010a81db84f970123a2a13a480ed0f311969a05ef640e66eae535dc879c462ef54009f627207b6fbd2aac7955504bc30b6612420bfb5dfd504554126449e686f67d8ec9cf5749fb1ae029a50e33ada2bae8a694a24213946a66f17699c465fb2779a1a539bc08e07d6145ed703166e1e3154c2b5132542bd675048ab3002896eaa841507755ada5fa8d325036ccd826c2d7380102f47e7ba58b409da6750cf21c5efdd680269143d3ce63fbbe49740469aba9796273cc8824f097683d1a0464284432616b41f7608a090607a51db56ce1e9726108babe5195bc281e6e0f50b1d8f6da0069a8572ee45d38a4d0a9167fabc69b4dec9d7d0edcf365e4959881b97e5d90ee434b070ea7c747b4b392b4750c49bd413844562c9ff35a06eca5fb79cb72eb147da80f50e22e87de9b9519b6070219a68bdb317152f366a7313e37b064438bfe38b1b47a04bb42395348d51712e84cee67b5f0eb5956434ee6e0ee6b9dd8fe730ea9983c4cf40758f4679e13156027b96592b66c49a43e30eb93df1580b4399694be0a67319cc04cf58cbbd822ed474e9171d950e39c0931e3e117b8c94f6193ffa2e76ddb11962f70065d6c92dc5df050bdc113b73a223a966c8412ce715a64f998f503f0c426bd63a5df04c183003c623f0202d4d0a1103a59285068e8e99676e976c2340f854ce4492e0175cd5547e36fc04db1031e23cdcd42e3ba89eac7acd4efc1be4019bd1c5d501eaeb87aeb764764810adf46b31c40f2fdd0ef52cf2008f3c8984663aa41a8c62b78471a4201164c05426558c8b20524c69f543acb77c9f962661b527cd9718f4cfa7c69358903c1abff724abef7703c1f9541e26ac35154e4b6d52949e05b18dabfa9a743ee6c6c73fea99ec5d2bb647fc37dfd5dffd66d6370285f53b1790c5c42b27cc4d930d47f3ce53db94215b939370622db22b2f200a97ccb988b5e5c134deac8a50c46c4666db24cfa40ec65c7030667aac5cfdbedc3e13972a508616d7149911e2487b3673f15831afe8fe7715c384bc83b2b03e699a2dfc2b6e6063a151990cb0ca3af237215f8eed45a54d6fbcb6cbefdec7a64b7cec89450741f84633d20c786f7042dfd16697be5d6cc098a9fd293e8e84446cfb04bb56a39c03bceac60cff763e8da6bd4902b151eab3a7ad93c66ccfdf02f91d34d4acaf3ec227b1a4e91b7cc0145f73d3bee3b329cb93ab371609ed8297eff8bf05aa91be56d416254c43eba340dd4bb45cc92a6f8bfc89395252720ac2c829dcd33fb86be12c4488c8f386858a0f521155bf7c21dd52cf6c9778e71d26bbb5b607923d0f76290e0a10c3b24271925e9dfbc83c427519c2d14392732b752a46ffed85ed3d61ecc2adf2683bd1fa2b60928a0e917b0f7c50da14b585a9194f8aca362952041740479158849fdebb0a7f885d624b8d5c1e00de0c9fdc985c17dc274ebf29b9720e9bf726d0b1a70b1174d602d8d25b4ca028d20d27edab2b5634553e7004c02c7c9482dae6d33d0118a677d6610cc406dbcbae0a3279ec2d01736de3ac6d91586a8ac2e89361f03f00080fc5c1300494f4e2ab3253b4f45a9fcc7c37372bcf7f6b85dfd694ad7d5155e02b0a5f468417268a5c4a5e687891e3290fae78fafcf793777e24a87a52c4e826552a35fbdddd197b4345e9cb5aba349008682d82ac2bb1a15f0ae66175217b31a3e098fa11ac084a7870497d8b51e94159b9b23904deccfa4ddda333a22b5eef25ea89cb5b2bae2918a6f0b7842f97ba0daa36b791daf1d71c0b9427c75b5ae813400ba4bd51a1819e072c1be67372788ae8e93b795540d41aff7299bed970b296fb7b8ffbe79357e6e92db37fd844ef445f1d920957c2691b0d4bdc1b742ad5c2fff737b256627d224e6a97c179f97c7d5ecca26ab9b6d2a500d4cbeaf3ec3b0b8d3ee970b2608e6046a0c5bf157ed4abdc695b731625f9b42a09e7a083a42be67b2a88af8a80103cbc0ec44cc6df2e4f7b05deccaad283254b673d2b5a8941ff1a7c8182a6e057ceda05236b9d5449f5104d58e8baee361c5420c85a56339b2abdbc3e8fbb721a1f93945f9356bd3f05cd8ae8414275e7240d7e87f1ad7c49d3d358c3c4cedbe7c7699d0867d6bce97dc452bb37fd76e8279987e0800eee8875115cc831e59e7975fce3b3df456be73a167ab8a0898510e659ff409e14f08738529d63b2413b7846bb3a3a9d93fce68cc6fb2cc08393e02e9edd9ea6f908512757e43556abc3951c374424a75d61d9e50fab8c36ea6f4437d45e2492b50c0957351489805d03695cc316adc5b366f8893cc92c7653499398cd30137e31df4c2b3ae68bb0219b0ec740368e793f25821bdb63b6952b43d27a1a40d87aadf023986644f57d9259553fc26b043c047c61d10874d8792fd30a14dd2b058672cfd5527de678453296964aae62883f0587bdc51610c999ed91efe8e7f011783b88a9c9c6c407e64a1272a83e140fc819388172b1364656ac247ada7de4c9579fe880e0e46755cb4abcd8a2cb791660e6b60b6c3c4c0fb6931859246d42e092e3b19ac2314db62841d44e72a1d69607bf0da570e8dce8b796dcc52952738fd973a62c5809d47a12aec16913c32a8e42b7aaff6531eff56c456ad3d97f69f1b8ea8a1c799ef3fa46bba543eff89ce6273e895b3c911f014fec5666245aa0194b3fb0beb9d06d5047253c076088e8525df0cc9ae4895a67e6ccc3c3d10978203539c1072566eed691b5967b041cbd1b187571b82e34deec03d080a6301e9a9d0372b4d09669b3db543e0ca85298664a1eb6b171c4bb22ff7b84ce211a81624fe321e48b671424a769dbddd0bd0f3c9a40e9910dfca45863fe7f1d8b04bb6f9552dae8a76f63fdc69dc611385cff33c195f088d142a94d9c03778075f13a6e21a0086ac5ecd12738a96b4ad7843df765ef61611a5d91b0fbd0be3eec3f3a1f57d712cec6976ef8831a5dfe3ba0eddf754ba0fe238671ad2e757697616934c5f8609bacd71c523aa22ad176c9917daaf1b03cf361727d2ad501ae67aa13dec7f0126554d9dbba08c644de3fdae89ad7648606e2afdbef3c75805dfaeddc1984a1e3bd89806661bc6e4cd1a49e6cb4bab2b0a185af9b80502c62950dd89595f6d5583f7555ae953351087e8abe844a8ff281e3d30c09c8bf49b00d6af571f357056c5507102b95830fa4b27cc1b8ccfe33f3b25de93b6f5cb1323ecec60bb6f1874bcac4b1ae435da5c43deb58b8dc7724e5d8a4f744656c68a92c7cca23e0ffc4b70e9bdc7b50f26830154245be730949476f426b1b0b8a4d4c1d20751dbb3236d4148fb9f2a80c835ab645ef33f711be272ae2198c5e870a649fbd6a8eab19e691066c993a33cee5b118a54165d5b539891e770f0231d5bee994b085a2648b3da9f79547110d5371b4c6712c586f4bdc2d08b692031fa66234972c2a6cfc35d14c8361820ca2354b488ffb9687625a4da30d96f828a355e753e9adbe64ac080020d3148710402be5e1e339cddd2d10bc6b50e1ea2aa2d24c920980f53be26fc5818d35ef9bf3e99daf5c6133cd3d1186961f6e44da5639bb01fd405c18540945e2df9c3ad986bf22b52e74395cd61ddc0f12614d5cbd525c4773a9eea8e9694885ce006fba0e452beb66284929225b4cc1df304682417d61cb7f3783d93be4e2ee67f2c3ce4937f46ddcf9fb8ac821983a51334996493b0ff96e13b959f81d9aac92a5523c0e3c8e16dcc1769311f5b34764f7d16c854939cb1b57b16b7f16347ae1d8ee9d1216a44a3e3f9dbe40542fee25427a5a531d0f79fcbf5278c57d031f272058438410e42ae74ec8ae79082c9e825adde3c8bbe253b8a71d6e793e86fdd8299944e096fb3e28ecde3ca428d58f66c20cb730651ff694565716e02943bc5380511488a98b32ed19af005030ed6474f5e59e01d1da7fabd433a9eac57fb6dfd39d9e58f8d1c5116600b58f87179f45a0aa9648741b14f18a0d8a2c8f1364565d135e289a9e38b8326f2758e83b2aa20ec63671b42309bb1e80d666e23e35eadfa7c39641e53a1649680e5100714f272ee05a2f502e6143ecce83377d15aa4ce3056eb0d48a69f80c01b676aa9904129404602038aec7f7375771916139bc542c41695842826410ca119718d9b43ad39b8f7ebe92ea39e50c08c8d9596a229cdedd8892d1e1efbaf98c0105fe3871878cf7a4b5810e1ec859278b1903bd01c0eb1dd55ca3d0c1b0fafea8ac0609a791b7a31fe94dfc56c48f85cb850bd9eba2b1057d6da797a4faba32396e331da2690011c0b308d5582a1422f0b9922dad32a8bd634ebc27f534aa12592be044e2372eaf91824a3e6fe46687524a1e1a43131d84f9515ad4910150f1b03a479f68d13dc7eca3166b19c336afbf175f09cd21a45109ccadaaadff611e5d8a5a1e7374673dca123779b28a8b51c9fd82c99ecb9","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
