<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a60fbb1920810f47de1d7f8bf3e197213078027d8684c0cefdd389dfe84e117e0f992043d6c09fd74c4e7f8455ef9fd43131bcf7c751901f1b6fa2b293fa5b6f8f621f67021be462dbd180dad5477216a17aae6e3157e1ff1ca69bfacf47dbf0ef14d924dbc330f1efe04778d76e24be9a97f78b2881d5de0b5128e9ed17d86ea45fc81dd3dda36948127025bd570f969e0f982fb7028c0e2fd071a8b602823879e5d2fb23ce9e47d1e4c0bee4ee4d8444689bc26b07550d1d20cb02dcc1970cf85b7e6a625a870391784cd891eba301f66aa5d1dff0bc961156e3a963b0a3c01891b157daf53524712679e890be13679765d3137b2822189d4338de3c035a03b3041bc79b19413fa3b4b191e3312ede0a3d6e3adc4bb0f78f1d60fa9177e1917784b9ea612a054ca650903a318de012b630088a17133c9ec0ddb325edaf87130320df825569a3a138fd827379090c3e87ec36c129f9794c398ab6f43456332b710bfcaca344f2151b14091f22e1f78ede777a8978dbdd3f9331dbb043f564401004e9cc4d4157a25f0312a3d4e01cad0d1761bbf82d0aa46712ed1d5e32a02fc1398d47901e537ec581e691be4301a7f7770eb480fb7aa9b7ed8b59e2615a2d7fdfc6a62c0991e588ed74a9db9da716639b5fe7c8190334e155b3a36d0bdd3d7c26e51112f8f12215b11c6b37e1d775cf84a24a9eb833aa3028555705941a7ddc225ce3fba44157dab30add6ddc99f67592b758f23d6df3d19fed787923501c0dc8ac9aba4f3f0dee932dfd29331659e69c1e161f2fa7e6e53764f129fa40083c47c51ff959a24f2ea85b9039165881e83e64d3eae951c0bfaae67e869bb15d3441a5d1ce28305044c2af9b6a3d2085355c7af1aeb20512668e6846fd7685032fc01234647e34bfbdbe2d2b097f21ef8cd6e8727fe2fd923f6181c3678a9e6853922732053bdf9fd9f0ee87322a3b38ae38519eafabfa7311453709030d9efc9ea37f69646031a17c4925d18f7df5d04c8e535de7d87f202327d0e82056025cd506cba6d2b6dfc110fdc201c16703e7ad42008bd7e135446d142e7e505e1c881f3bc89e2466aba5e80d5542ca45af5eadc3b65d8223da4a964d4476ec5687d2b95b519810b3e1d75323612bfe4517fd49c1ef4e5543e2cf6b3631bd0c9b3bf98881851d23ab93fc0d2d0f32215e251b31239fc43c2b8182ba1d3898fcc7c656fa41ead134b79f9489db1bb4fbb615673a2c169bafd09cb0cbd645203e75c0347ceb03c7220abab9fa6816117669d4e04e054aa92095f9a0f30fdb1d46ed18b4511fd1ee7f094105e65362de278f52016b4552385ace084dde29856f0045a81fba69a8debce9dd33911e6894ddb0b7ccfc46955ab18e09353ba4d165c3390a781b5bf2490f87e3fe6ced14bb25e3f66f3b0dd8f87b37230faf686d7a4378f694b02cb41bf086e0d0f62c3a35cecd1b09d0ba3aad713636e86b05d4e85b0c1d86ea0cab3db6235480ac51c5c49340ca8f277caef21ce2db64246f1a2ae7642f4de39c8700c0e0338480afdbbf6c5242e4d3068734d5c6124c05ed77aa1b8f21938fad02953dc182e7dc24cd0c691f56a51ab24d59e2badf6ef636c296eb8c4903ce3761329ce16df7e1a3ff0dda93bfe540ac7db31bc1759c86b472e573e01e09f002b169ac7402fd26d264a4ea70bbe0007bfaf9cea1947773e4b899853bf04ebfeb008afaac53c40c72de74b23d04b250665589d032d46b80f4ec5b8f0294b13c5681462b6c0659625c8a04200591ad9375cfb74ef517a9faaa45c1dbd0fe37493ad5f065bdb9e3ab4e5a53e6a393c41ac4841bb94c4b31a495658d760bfc8203f4b8b427a499aa146a9863473e791494e9232082c32211726ef058ad9218f8efef0956ffe5d2639a5813ef532acd16ab223711b0c75ad1b0ad66cfc71d2a2d4d39433e4ffb55cff6375caceebac250e112e63b03bf7d265759f72725a4f3476074cab9b54439eaeabc5fdbe35e0781cbae0e752ddbfec40dea7088fef8c332b0174c73fdf4684bb8f7fa7c7dbe576571ce1aa3ffa2e63909472d1020f5447a0c77df1f8fcd33cb0b1f6bda14d3302a4279f6514a03c67b797cd4a5e6807ac88f0049bea8dd33074c7b7bbf4fbd0b8be52fb28fc030f044764924e7c24c267d88c407e17f72e853b3bb1365eade6181ec8c3323b9442b3265f0f6faad190013301210b8197bdf9fa243cf8368ee1cc3485036bc376822304fab6e2d49ff00a321702cef4ac12ef8fef5d7029cd34b4bbe679a7c7898017a30898d548f041f1943fb8aa17cdb97d42154ab833ad301b5740fea8ec34fcaed0175ba5f104b66c79cce8a33299398b25b9bddcd940910f0e0d8e1c3462c1f7626ffc5f4254baea88c98e4650e8d6dadfcab17033d200a3a6eddcf12ca22e17eca4215287695832d9f5409372530ced22beb9dbec07b2cb2439723b4ea21e2ed3045ce9cafe429ff9c78ab755eda4b98efae5b913005fdc52f31ebfed0a1c7f3ba46ffe80bcd3e599eb217293affaf942bd3e0d06709075afe1b996717ac3662e607cfa5584b44b3b4cc4d46f13c57612c9d3cbd39469e0ce2147c61b676585ce1b6521c74b21eda5260905718905088b17818a8c04d1a0a87b44ce0ff5c2b0537d04217090f17e0fe79a52d4a74d1d80c56ced23e98462092fc5dd1c648865623093a82dab76f74bcafb783b22ddad468dd9829a20e10a76bbad3a0d8cb347dce70f90286e92982c05f6076993835dd610c6ee32c2358053bae0702dcacb761c43c8d87ef7940b656aa53921f47e0fd686baf90a3791f4d3e760d1633512e33e467008ffc4822a1f78be592d0c883b2841b80e8026b69ae2f0db46d487c678335a8f373653a74720d751f071fa6fced416d9bb84c96ae482e8ac7d2d5475838ef7080361ecab29173ac2a087ce6a985d9f6f49fd13600f85bf7f7c7b9c263669b6b8685a25788eccecf34ed2006dbfed65837e287a0a642084a3e2b69ec691501840d6d0b8cab7628209dc04245d2256136c21a313db883de81ef4cd61b92469be9d4caaa78e65e1495eeb7143d4b6902ee18c9a26743e92f229d6825ded9d56a7752dcb67ede9d88da78599e96ec8fb1d68cb4fa7d682250423bf64843dd7efb870dd5b85a3c438d40692c3e7264802da7f58ccd0acb96806c82101040453c7df91c7c2f03e1026ed2abe133ce526b5cf49b5576136d73b56ca6a31b310e68fcef56b5c7710e007dce5c1f63d46032d75bbfb70b073562c6486d15c9b24317c719e8a0942c9ecc937c4532de9a2c942d949ea98d795f6efd2508784f2b1904812d449d024e2ff6eb011987079cc40b736df1707192071f70429f593c4236b629515d5b7d4b04760f3571af29f283e160607736daa8d5fafea3875d8a00a57e735f36d5c66435c3b66b946ff6ceccf136662346959b4927f9dc16a647d743a8318f3a3fdba29c9e2e9615d3c534ae2c838e012effe9fa1bef9eb1dd2900af92b9219a85b44be62ecee0a3a267b3873b1a9a06d442e206d4e9a1e9c0733f15fd6bdc09be74de729ff7509149fa8d382833bcd984821b24bb96d05691bab027ca2f13ff46cd4a99fca3173d9b4a78e95ae5893b55161b62d1e0d61ed97e4a533444f5e8b05a9e80132c207031d2adcef991be7ff9ef141269822144a9a5b1ee23f445f4be084079877a9757460b70800cf00101372babbea7ac2a19a7be7a34443f550f367efb77fd733cd9c107644f361f2f69eda4255e5c357a26278973ebc4b725a955fba864eb27a4d26453c16f97a8d6a9aa057a516b21748c6baea6a65fc3d8ffb676cff2cb3a77f7136bd0f3a83c2990c8609a9d47802ee048d2207085d3fe9d1f3a4d61201f58439f33a8b6d7881f38a991d845589565c028f97e6f6816bd5480e8cac4e4b31da03510888a81c3e59ee562a36bcc38f7df2bf9a84ade0b87a2091c7fbf8ac9f1d65b39462b1fa15d501f311f325ecd686b6c825095aad0be48943e7d545a1c8b1f79683e0d37bbc0dbca4127b910545cb8f8d6c7d90b03e5021ca0afbe16dbbdb780c5fcc92a84db193e128f5b66a2f5953539f69b0d590e191282607e2db7306ba51637afa268dd1bd2d94bb7e43c691e0548ceb459fe1d33bc7333430fb22fb45683c0de78d0bab2de8abd1090ef6125816124ea0b889cac186018ac22ba5508d3b5dc19e1209b81a9c8071c45924b7a5e28c8a37092eec6339b613247342565ac08d59949d1db6721e2705667be1958fc5d04dfb5e690b970aa31eef51f2646bc08bd8a2255f3a284b3c6a145b7434c4d17e2a9d5c3dc438be34392498e90c4e4054a599cb9b67ca533dcc6b3e54cb4828411ff2542e3fa46e21b75922d6fc2fe7b7a440a9b33c1ac280622f8df8db7836082acfc42cf6b657d8609c785ddb157d262e5dee15f0ce39cf6f1f72f6ffb922d86e01e102f8a68cf011a8974e042d7b7d6e2e37bc8e8e86e3b0259821117cae372d761b1cd64c414ea5e473bb415a803c25c0c4e3fe47e52229d9eb79715fdcd76bef56cc5931b9d375d9ab189b5441b9cf328f8bb497394b6e86bce4dea7c6bd076862c50345aaa1642762944fcb6d30b9b1cfef4fc1387195106e2a1cdd5532cae55b63b0f33692c0dbde3d646a705cba7013e114a71bf8f43b1c8c70750b3920b1dd56c6342ce8413a70091a10e581403dc78c19f8dd9c0063e538a51f61fa26a3fa720272d2a39d60f2030fdcc4ea4e8c93aceec94e162fde0dd16a030379a17a45d2d5ecd71822e74b5caccd34050319d6c83c80d3147af204de8b36c8938344ec2c1447fa346e58603d798f65c36652785c07e961348b27358853dcaa3212eb13c3856e2606e13bb634fc0f480c3a8fb694f6760afcccd615a21ad03767c4eae515dafb031db22b2b537b5e0651b6403077312d26e3cd08d0b8116537920fc3f2263d2dd804f88e78dcfa8012a832e97d6065a111b7a0d4f36b7ccbe411e20477494a0367f083dc9b2a3093694fc670d77c1f0fff31830150083418595c0bf9e6fcd8d6b2b79e1cab990d8d5db356ce70962f24a9b2bd422e0b645e55b1c42486ad7f733651b986fb964995a4c2c4f51d4e330f1a393e36ae95d1d50db414206b772f282a5734f9ab1b91290ec220b102c8b2408ef95f667aa79ebfa5d002f8ebef604bc4273739d426088bbed646a9a54f325d0d98ce13eb0615c0b322d841e42339a80bb16a5b89dc96f989a02c8243a828947c6bfec7ac53b20c0820b9f3c61038accccd42a679f7c3990450ac2aad0dc96011618e08c23e2acd157bd320a26fe3025aa5f795881e64b6f02b092b81a0499b3ff7162549f0a318b294613eb81a253e8c68e4b67d91fa123875c07f5d977a8ee801ca40a2f2c7152e41f9a538405590db2590cee2af739c70fc4659c1f54ab56a352cddc6ffab33baaf98d31d592e118660d457a9e5632e1b88b76b33b424d212dc84ce5cbb80ed8fab304eaed01e3f65f1373ee10824e274789996ea173adeb24e9d6b07af32e68e98f06d965a42a0aa731939143821881c6279db660b406cfd84f1096b74aa643279a85359244d91fc3ea55adf50225f5dd401ee006e2c140ea27ced8974dd41fa47d2bf4f0d11c10bb5d08a9bd4cc0132167a0da5b4062388120d1a1f363a6055612df234785085f49048a2624ed8c75593bf3b64249d8eeeccbb47065f4696ad96b1d76144d6a764f36118e2c33828108286010a426daba8ee7fdbbd4ac2920d4f8e8160835ee2ac9a46886746fa73396c60f3bc70f7ff8906a1b2ff0a35516515ddafc93a5ef87ddbb87dc8d1ff8e9521aaf00a1d5adbe3702fdeff5807c1f7b7518979802bbc623eca29c72230f0a6e1271fff16afd9e8099c2331752bbb35b847a60b7e4a654a79069d4e6faf1911051665484963abe525238b5897944fdaf223d24d3480aaf05c883f65061f4cb0e2a758c179fc14935ab406f1a5bedcdb00eb3fca13261e3695f4cbbece693d09ce2c55fa0524d2844e2afe15d40622070b97448aab9a2ba5facda8b5430d3219a57cd6632f62e5f23fac5c9642b3996eb002f39441fef1e8a6f8e000a6199192c551d7a868312cacdd143354e65947132aba4b632579ca24a0e511e00d2235d2bb444d65a148c0988f055214d113312c787843c32f35f5a5e29e88499aa4bf8ef5c5183d5921aa50ca5623ebdc7fd82153ad35772f44ab77c0fddd4828a02081faf3defdb4b58ea6257f7387b3cb70f45493ea0e2774cf6b367a72990309284efec64132809a19bc90bb3a2859a9aa3776b14b55ab9a4ee58599c2dd90ca39ce57081dd86cdd2796e2a590a5857c20cd4a4f8c52bf2680af47edc414abf709bf17317902b48d64e990d165862978412d80a7da51ab7be120f141f686289e58449ec237a6907015e7dc6443b499d2874996c00efc2c411cc4e1fed6dfd2d2cc6380f56c77d89a4ecac60dd66e3d88e0bd40d03fa8ce17316fdf2344c3ea73f573c3821742951a77910ba2573ebee13200bfce4bed3591d8cf991f2557a20aac2f140bcc2dcd6a82d05c2c44c8b7764119c3b492efe272e427ca417b33f064661f34d571de33b743a7221f150e5165fd3751e6b2f078fe031169e56f01ac519652c4fa0b88c48f4cb76d3e3c9acbcb909380498db8a34b8f423cf60ddc156ed16e1f3fd6bfe7b6029b3744ef39ecb1ad9f19767cf4e6188d4794c9090767410740517171cbb4b0b468518e5c934cfd4b94edffdf7c4a146d13bcd1ee933024a185cc46715714ddafe24966b8636c3ae0f79ee13e12000e2b82060f7ce76c3b08c034aa4867c82e7790b9637cd6620a03a62611d244597f4267ea8b075369d89b65f00dc84dfebccd66302d2449ce50360cceed4b90005f863f007803d2c42d40b82c736528ed51726f7398d7470026636707ce84a6f595adbb3187dcac65c5ba692374f1bc15ba35b267bee083d1e607f070ae85cb9189de0bb054172c5d63874ae50b06d911d81915d6a083b72a62066fcb270457e87fdb77b52b80e32413372c9b807f68a889489030365a1c969161761ba9a94fa4b4771b2c67644effd60fff8596eedcea9c52eb9df2791bb5d41c88147af7502695e368cb4b8cf94bea27816108980d9f4a654a34bdaa0f22bf3eb1d904d3a4e892ec1b42fe8312825f85b35c28aab57f438f441daedf4926f90fb245f637948a6842cd803b8f29f3a0e2e1c1a8dd7d46e4d7a17156a1f43692e1aca7132b787470678887e9d1a541603464c4629b92d0eb3a9f58c34022eb9c898ca888ae7e3ece5860b22a1fea318a699d235666903ce3ae5267c58aae1b771832cbb6f48a4e6c1e3dd020aca9ac70013e4cdc8b2b214622b66512fb12ea63b86f8c8b30e242a31046600fbb9b766c19f1ef5cb017434a9543d9fbdc7f368696b8fd3face530a5986d511344c93397fde7ac43e5390afec86e024898627743d9328b2b62e3fb5d817b6e5816a33068bd500b666a9dad75298e61a5909e847225c4c0c6ad5388e7b2eaad6d791685bd2e5eb28101cee0e35a45b116dd06f3a43b51c9e132282653044af2b0554001c94eb7c711231a4da2747709e5fa455a624266fdce7f23e6736993ba6a9c26d8fa9e0d917951d9456b5026e20cd50b22df1c6d15e93200c399693271a6e1701dcf80bc4e61b5a6cdfc87d083f6158b97d9fcb7749b367e8dcf66d6f461bf6a345138a087077c33cd8bb24068ac73058e257d258cebf742e6c47aefa102552378d7e1f85c1cfab0d9f1d9ab14223e70a8a40b0a34d3c873f7ef0d8e52ea319c82bb833534c0412145146ad46dcaec0390e498201eb0bfaecefcbe1f792c69494d568232d36ff083f1a32e40e8c54dcfeef307a384862fa3191ad04420ee0218bc3124dc560634bdba2e4661c848a3da6e24a39df420c132f6ef35eaa71732d6095b2d0cb14cac5700c3731308a2ced4a0f14306fc69f700584f785e5fc1d7cf55372bc87502afd792e69d08f2a70c9d394b38ca0663ceb3d4a284de95b7c377e31a78a8e5c8332e9102cff82d31988c4b9935623a1eedd08216524a2221553d83ff6fa6fd39cecee8dd09ff67c03757c2003ea730ec90cd1cd3e21f7c9484be22222a435961880d00cdca8094a25aba1fbe22955b8c81b2a57f285d689e8954744fb749d280b089f90f66567a478990ab89ef26529ac08f0b9406614aed249eb5a19733bf2a53b53f717b24b9681a3ffc55d3cece4b2608bf001b808292ebba1ab79020928857ac2e3df3dd713b00c799eaebc39d9f5c65972c0367723b42734bcd0d8deea9ef290e770aa9a0fd3ba441f39dd648d9e1a8e274734b10bba5a3a8d8e665d0cc0d8cf494bde3901a4b755e0a3352feec8f7e632f594645c7bb0f64c6fbbb88e13504f94d0b47a6887e899e105aebf9697559c4144a48c57d1656ea9d354c04bca458eeb32804e81515618977118f9c2ebe7828cdf55e7bfd44e167db122c785f4f250caece3674e92eba1e21d1d82dc6ba6230e4658ffcf13dfeae6c7fd37a0148d15a937ad731e9d1e063002c906f38d941a0f0806b333bea5b8fe36aef7d8c7d3009434a3cd4ac766e9c4c6326fef0b9812e67778110c6d25e46854e87ddfd271e9e7bf6c325a890d3709e3f86a8709aab3aaa244384c82d965793783dd422ef9b4aa44dbdcc7011c5cdb072d3b863b36782895adcd7d801959128ad274d5d31bcc7993fe9015fbb1b6b7ec1dc4ebcc97c3fd7c8c74e9d9423f6e20f5492431663df7d0b532bafee3937a17e57b698f5eeae3e812528a0fc71fa1d08653c30c7da2b186cba56cb2fddf77d9a74d41686b785113ad7a8d88e0c970fde52e7bb3925ab2a826385458d0435113a77dc8cbb6c01b4bc9e4647b565dabf2f999d1d7aea40a34b7061c98fafab5c9e49c0de88d1ea7ab1651d2bc8c4d49d2bf4809211b8b25a149141340139d41cf2f56c81bb100eb8005d351fe4efe8a81e20fef1d2c441e4dd949363c7c0a3af6b90c7a48cb0013bddc8b84eead11ff2b25b42cc28565524d04426e976a34eaf885747de01714d259200ef091f93299759bb1eab0766207c3b798449e0ad87db2f3e7620c7d5ea570dafaaa91798b49c5f02aa472187821ac9d8c92580ece57aa29042fb4e62028086caf810b33d106e600735787f65abc887633aee4429b07f06f622c156d709f1b60e92cc6faa1ecc6ac799b71d96f77d830191e073f4448a61af144bd5906a4cecc7d6bdd87a1042ab48e2e946cc0a14b8d2f46113c8e86a2ba7f1ca7e385305866ae852f2c9055d66cc7fb6f9c737f04f4786865ca256956317b6be15cab8b3b0603cf2a4c745fab3938c6a21414daf2edf7808430bf2aff4795a2ec52656b1a0b5f00be451c301ac44279bde0450a7c5a8da0cfd56f8f3b9caa69f45ee289a4d9481b60b7c0181217a1bf1a4003465f99eb0d4dc24d23f35c9af5f8f9ca4a187b8014f8cab1c6827d10ac10a72238cc448fa910f84537aa9c8489b92574d3dbf7e2030ca00c97a26934c078039051f462a5caa79cbbf2f35ae273e485235c0db0a9e52e956ab15b79b54741bb063e3ec222ae47afda219e0f9e77fa46155f38ae8b21e49125d22cff4a02730eb628f9bc9df07441e2ff741dac329f07a244f268fdaf19e681a91514e46f196d2d4d7efe933dc268accd7d43367a0a3e0b123347ca966393f96ca6f2cc166e0197cfe6ec0ad4b1a0c534bc0ae22f585f5e1884f3a0415ac753504eb949b3c585bf5815cce2ba9f8bd800d0520d917519742fd626e93be703c5844b23ff3cff97a2712de6471741bc88b2d32c8fbbc448fac0948d3d457c348d5793357e7e96e3421756ed5f438472dc77a99a8752a4d239b41ed27433ca9ff7e160090c1c4c6b9286a82fa577474f155b4261e87a0d79cc32e9a4254a41c3fbba7b43c579478016e41c89dc00ce501ed76fe67d2e268a6f7f954e24bc106fb201769943e7db96c2b8ba3ae62f474f84839f0a229a585287dc4eb0628639962615806ed6378c1df483d5f15a0ed4d8ce8b2945bb36b6c71ba0164e20edd965fe5cc0567bec48e1c6bdba822db600bdcafbaa55ba150906c681e1ba34bdf411898a4f39fe36080583c868734fcf2d493e40d11dea992f3cf44b602041119cf3bcdb7768b97785753df2392b0c4075789982be20c72a0b6da81ccdb6982014ffd7dca9da60effc9614ed6d388b9d4bac6fd816ac54ea0521cb0a28d71a45dd59e82dfd4ed8f76c9c0cc5b97e83f9e523d6f571527a37177ec7339c2cc2c98b141f6017648814a3405cf48ea8bbeff0f1214c86fc41a3549fffdcea8790d79eaa212b5f805464f3a03ae91154344430965677b49c77951f08b5899579935493d8f9c3f79291ec3f227c822d68c376364eceab40da82080faeb0ae2293bea4dbf7ef5a802e2ece8da2aeecca1d7f8246833a123fdee7752b93f400faa6792b26f738d9f4deaca033fa7b3de4f830468d2afe5020e580d9ed448c5fe9632a5151e214d57265d02bb8503379cf153d2f4e02e7e5abd6d94ba7e1b0ee04081bc807c164733bca8d1944cbf10825b2688ed7953f62b4452708b7354d38b2d289c95e65dce36f89dc0b703bacd53099b15ca3c2819de30dd5f93a947beabd6fcd7463d9b95e81d45a3acf3bb70ea28ef51cd4167219d2a3b9206ac3d1d2e0c6609a103787b0ddcd56ad9bbe534cf78f95c4cb981b4a635b0149255ebd3a9372b2c89b07629e35b66472c9bee5e85fcaea2fc17f1b78d66ab4fca627f074d7833461cbefef9e0c4623adf3ea66efbb0340b27b73986e61214125cec67c01d407227758ad11c141278ec197fa53102aa54d1e26155b7c8ed1e93fce99b415c82fc8b86503c7a2d7a7131a8f37173af846cf344479e205e60448ba005f5145cc3dc8b42b80a59bfaf75557fcd80c65135233ffc680fc1473445a0f6e86500cba8bc06d14ca67dd9ac24a2fb7aa6c59b8cb2ef90d889d37860217622d5af7165a11ceca3861105445cbd9ffa97b425c921d3e6a4a37d4e8505d059369a6083c1b1c52365ecf8564360b02d48675af2f9bcd86c415dd487ae3387b24d1be26082d03cd96b6a111daa767b7d9e654793efa2ce4ad01ee377eec06a92e3d9ea5587c79d59ba0f132344212c5ad4de606dd2b85758907b3f73dc1344b9dd97283353c47d9ea802854a789a62269c4c76a0e8be49c8d0e8a4a4b82441fe9b811c9a8498a07c3b546eb86c5e06ab8e089ce02cd66d670225e25e3d08785df4fc22a55e797781c476bec28ed8260a302ac8f897e567485997d2953aa1e48e807419acceb1dda2ec169162f0d85c84eecbc18e3d12a58d1bdffa95e78f4efde8b085fdc77489f8de1d874157caf8a0a039f00f70313e3fa94ebf96b463659040fd5fdf81caa06cc6427e03b02b5c1885a004a946bdb9b899802a1ce28596d6b4d9e987761b2901b0ddca844d5fef02eaa90ecf1a84295f83622640246fd5929d5f246cb2a3dcbd8c994f0f16d2a6b4c66ce651b8057fd5b58057160780c3c6f9a6c556db926d7ba2ee70db395885d1949c5f3269aee5d4c8495fe9f36bbfc5a19379bbf622818e7b3a8ee39861fb2ea56ed5a79f40c51791249c25dba75b8a44921c195caacc348dc58a9ef0428b382ce88eee5f1718ae6279681cb8fb4150826cfed4e8d50011c856dc280b06d5f5d7a9b55a1e2d5b23bc321f90debc7ec8cfdcad4389e5ed6f47e8c8e4957f7af3e77052d9016b27dc7a30829fc3519b57e43c738b2b2a4318cc66ff033e1eb382e558f477058083d826d9938325adfecda2c3cb76bc9d61c6906f2630203d508f4611415ac717c4c45cee176c09f92f862b63e620bf7629df5950e0b4428c8ec55bff04668f386eaa97e927e59d089fccd257a33153ccc0cdce488efb9ef00aab623471d1e27b7b1d25638a11b2b4f74400e1133ad9058a8f349d4e6b8b6a12766636669f85834b5200ee8b1f1902d149e99d8451af35ee410e93c274870b6d91eb565003db43e752e3a212af17f58b698ea92b55db186ffdfec90a73466c2cc8e1567090f7e0f8ad387dda48f240a12e75b4287b9a17193793e3d9b0bfe0a4275363cef8c2beeab28506cbe93a92e99d0d5bcc3bec6f290f4ad0c29af8cdbc9e60a79f3472ec839a41ebfbde170154776d910d3d86fcd8909d0ab9a2026dc2bbb953e087da079b5a22173ac4e5f5ddaf90acc838904b561da1190978c42ff86b7bacd3c35d9cb88083292780fd0713c767ee4b8936a9f13d41c763b9ca591448bf91fcd217347d9715a8b423c83b94b14e0a3c6fdc2c98be862d2accbd5179824f7831a06bc6d90147a6fde7f45229ecf908660842a3fdbb9bb12f16c00cd84b494a10833ad9bb8d28bb2fe5ee1bbe2276237c1a4693d213cacf6e0e96226977c4d82043c2e5dd61b6f3b391ae8f4daea451c9e3a688d55f16335dd42feb8b85b7e66c3b52604dfeeb88bcb412a49bd6cd0b047ef164c3b7911391e4a68aa144344179427a70f8dba5dbcdeafca1507b11c815b97aa05cfec4afebbcbf617347ae8bb36292697832c18d7fc50efb1b08b9179fdfa1b70af6a59827875907c256c6837393160846f484b113bef1724aa63838310fec02623d2d507de4a0de026ed4f4c2f46e6fec81abdf824de4b35e33fef093dd4d23a5abb41e5bc683ad2eee54d50842dc40c1a59083ef7ad49396c9a25a31ebcf0ce128316e9b84931a03ecd1c25446fdf1394301e5f609ee2400f0a266f3b8a42beac56954b2a41eb83f9336836c630b8bbaf9f70ca8f865aa641c2974ff272f407719b9de3d565cedd8e8fcc5298c36126e5b100b3d644904f5f3b9a2f91412b4103ddb036f1ac204c3adfbce95598b3c03806d1ca392da7185bfa031cd595f455a95e849322da4799ce58c179220d0fb26e8e2de50da949e3d7f5879eff84f8fbbd81d7ab4a635e15ce9a733b50db87ecc81c73237d4abc9afaed5f4f89c4a47d364deedd6eaf685b699c04d99d0a621d05dcc78066dafbfbfef5834b29a87da31f25bd4f2fa27e4c23568454b8db5eddffd2befff486a2f9c5e7e4abf80b072df9c6d7689ba96c754c129533a7476a7767f93bce1ca6e14d59b52a131cb0a80074cac80017659c3a6f8399c7febfd7beed665e0692b1e4ee313cb60d5e1da20b15cde4cfec025aec7f9c6757abe9a28496b60b82037fb0d03ea08069db8fae4a1e19c9a8c5877c4841aa3dd46b7070d2ed08eb705b5a8bee944da6f8e2e177f1170a2564712b9766882f8454ac515e8b00c0a943441943b16e3765971365c93000c9787fd0461b97593f0fb3a87e4bd2431ef95aa4b42d1cf24b5dea53d30ef6171f7b89bc6ac36e961a4438ead1914c5cd1558ade31a8ec6b81442df26bd00a4f1fc5965d83617e37ab6b11bb3c3d1b421a16a0dbb8cb3392ea575f8bb024d4d316b750329b01ce22ea17862372509c2552595bc5bb39e14b863f326d3ea0cb99f70df35f8ff7867e56d393c98d2bb5e552850e8486bf75bf5bfdf686c606bf9f1cebaf5be90134a011ab33de975a38b89ca919b3683402c9c3c0ac5f39314f6ce692c911c190e94a520c7b87bab3031a12823a362a34944629c65f99824250a0771383174dafc8af73bebc8e2f20d7c1057643bba6712cf40578d11f94a40c74b00e97ebaf4fe39abb103f72da2d04509034a84080d1a980e6f927ef64846266cf95a35e6f47712326e92b87123559f159cb0220738403fc67c7cb3bdafaa219db09b12f2fb0ad7a3477e6f862d926e666b3f76503645e973f6e50f7b0dcc9fee97c88beb584e9bd60013dd563dffe4d1c8b450fb89af88ca5968ae870d5654604c2bb7b0b9fe5645ff666b22c8ac80298251b85364e87b945823d4f3fa72ecc315b621e5a89ddb0e8228088e23e88f3fd895e546dac674eacc3e1cf64c3bfce578c47b429b9ec4d42a01c147c8e36e86765eedd0c71524ad014a0d5444bb4a04f4da024aba8e0483b92bd8d95635138d643bc687f535f7b6c770ed6869ff16fa0cd22e165257930c063cd7c759e5f2167586b8888d56009d849c528f71258b8e89322b28af1006e7c0f46fb4fa87bc6bce09e9f3e89aa8111b6d6b34accc8dcd18c60bc300c66e07765cf7b0dee42b90be983b3fc483d9c38aeeafc4b7b15afc00cc58b763d985df67661b3274c90588e129110cf1bfbb70f02790eed9aff386ef0f073a07af31eca27258ee35f3ce0ca48cf04911ed32b3223db58b747845660466","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
