<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b507c659bb3f092516282c29a2382d59e670b53b2acc70ecb2ee4d0c26bc825e368d2abc24ef27658d59e49eb3d8fa47f5ac00cd672620d9db100bbf90d922695f3e74d5290ca248f8dcc73491f3b691405fe391feec050b8851d8f9b82f967470d917c991326701fee33906fb267993234fa43cc1a5b691d6f947bc909ed34d8dc3518693f91f93e99e2725b3f58f3b3aadbe724d88b375d18a87591ad0c0ab9c1aa011df3ceb2bd07100a33fa74a31930dc8402494232c58e7024d0d2634f4932d9287284dfbb23279e9b1257e6d38262e947e0e73d56387d96e1c0492448e03270e4d4830005387887eb4e7b0154036d4be93bdf326b0e60fd7bf9e30999cacbdaa3a69ba427695b34c987697b841a95b82c4e5a4e9938ef86767f55767630618fa58f5f992a084b547e1014dba50128aa52c8cdbf0c1bef26aecded838ce4a180a4d835351a3a6e1a71b04fb3da6a64e12c79a8e0f27a38220d42e1c67d81315994767e9063c3638c97a205f27f77fc5f49ac146da8f1abfe411446ff7a1beb3806d4247c31d96eb3c95a3efc6a9115686ec63414112a435b79db8134972ad73b09b5a6197eb6d5eb756633db03a8a7b2f98b5bf9b4b1eba2c419073ea2f487f44c91d551026552871e2afaafbce4d90ea6c0e753f7b17afc39ed1d375faa0020eed8d8b5b4cf83c986a9431f35eebf9a888d9b1f00713b4d20efb25e3f4f8b044a9411ecac13e343a43a48739c319b39c0c99c4ef397d9d3301efea6366d2af552b8271af03da935b8d1997a64aef67a8662ac8f11176b3f9fa1e0ec98662385378bace63a251c67531f52a733326a02ea2129a45321d16e6d4a96745797d463c3bafac188f74bd4474ac2a26f73c1d94c10eb1ebf6d2e521804b6149991c3610f30e54a24634600f71d294c70841a86da4e5b1e74547c8a6d01867f0bd4695910306504f06b803b3936c878bba3dfc66cd53ca3d8fa6e19cc40beb71f8696361b078fe812c829e939384912a06c27fe4211578ec18fb90d0171f6ba7de4e379ab655b7ad5e1c9d4f7dabbc6f8aa06f173997f8721b81e4bd2141e708d977972733c05835b977030a17fee2696c1ddb16b532cc09028b4d3928b45e2113943db25341a2929b674d572dd0d97172286e454016c9aa7b4c350d7604122ff448d6a5961d23b1a8ade8492694bcf0c4b8367231783d617c50e292fdd1cac436cc8f36ad917b40cc8f308c79ec9012430c6b2541168625f8822d3706b04c4b6de1650f03bace343247265f0e054b2c550a908507a233255207b5ec24725af230044c3a8f1f02ba7c3cb46a6fd926c0c95e26c40cdc5a02111bd02c14a125f8d1f575287d6c3e4afdc0594267810921fccc380d3bea2230ab32c30408a2a17d26e0c552815ff27197a2b6a4fa9974c150fc6b7b24eb152c5e35c5f3c8cc1d4cab439482e61a3d51fbaa51a4aeae02d8a5645323f4e94879d3625119b92adee6af3045dcff08548fcdedf31f17d3d10351d83a6928eb381239449ba0db0500b8a63908265e62018aa6ebf65936cba7aefc046556ea606ec554ea25f07f65577e9da2f20e245ce8f8e919ae86cff184cc2c6ebabd88f08a7965bdfc3aacc4b6d178778a5142f0ffdf24e80af9706fd0b6c2aa3c7ad8300085457f65afdb4812e06d15cb5dc2cd9c46ffc71b85848b83ce3fdf5376471bc58626d15c2fb29ee81939dafb776c0e41e00e83c0abe4bd00858a457177c202752a02661426bafa91e8c3b49f7dc250f45ce55ea689a1f86432962ac9af7da902d226db5b410801af62d72d1d946e3813215075b1121cfbf4d1901397580659145b904da781a077dc2f802ec5598092330f9a815d27c353b698ac41209b368d93c3743a72fd1a96762620ca55a57c1d7c3bcc23ee40dc8fb3c0b8053d959e4e1fcb17fa4402edcdb3d348b65a0d03ee838fd3be04a4e5d251089939cf14b6e4315141aa0721a08d78e605f53cefb659048572d55f824c2496c21ca397d7b88a812d56e820cbb4de072f6735e357ab1542024d43a046f0bebcadcd03837c84aedbfa562d365744227de572f268faacfcb29b0d3823a719f12321d818ef7644d33cddd32ed67ca5d7582553b1206f16cf49b89c308cf6239447977f02b4f0dee6c9096573e5f90fb06a384b2ef0b5104807eb0ac07dc915040ba7e4101ee037b1b9c0856d3d463cae2c1a1415a75ae504e359f313a2e4a15dbdf434dd3f42976bc8dcefc00c7015569bb29bf72977b557a203e271b6e01573867a0073f21cbced883dfcf6e3fc3a6cf747c8336605ea902f3eba372cb9d00ba683dade81698c8aa03a51051ea93ac553a86cec9573873248f7a75ce7e6f223aa3a39bc1d9558fa4f5e96b3646bf845613060c249c3194decfd34a21e79dac4ba5774e73e2723eb7ad7b29aff322ffa61d1610659c0ccff47f83d44b96ea1ab575702a445e7155376bdc8813f37cce9b7974f12988de09504dd9ec5224c3dd0c2155913fc0e735c16060ba66f373add68784b01ed30808ace0885a40252ebc9875dc39d4607b74099d648e13e0803da662cdec51445fce7baa64cae1a17882e576f0e1322b6532f06447456e4663be23b2a1200c0b890ef6c53398f1f34da56227b6332283ddfba38542a6990c1b7146882bac2f5a1d42caa04ac039e0e9e7227b0a5d9e80f17aee94147dab32c5ee8ec47f0633ddabb933a5e71232f5b12157895295b1890b9efdf4310a1301162ed401d4a1bd3416297c8446b6d6dbfdbb959cacd9d71e2e960e28cad1610a91e9f933888db60faef9c46bcf43f8f44bc28a3097b36e8acb334f2417b39591dac220c4c867584a9c04a39c61cd604bc4c401878e8fdc68b75b27f41b01878a4987113f5461bc00bf66ac55c8eb5d080df3ca427202e91e00be16bc12a98e1f376fe69de1e1c93af9763573ac35991f0babba504e155e91c9cbe65cb9138735b854d24262be00bf585b828ddad49b914816c80a452ccc0dd7a34b181bf60237769056cf4ff57d5f4b60e52f1581c6e312ff4dea99a5b23e565bba8e428ab86ef65100d18736df739d84b4263629ed5e97f4f6304ca52da11b42cb38c536ec1bcf730a90a479c3680783e3123a8202676babb16273375365ae9f8d851980d09bc58454522f48185cd1abc26e541157faf50d8fdfc559752c82af4840b2f015c84ae0f684ce942f419d7b70f99844a315fc862c61e4d899d01786cf419b1d1ef0d971611d74c0f746d24689e29c44a200c739378054194d7a0f41c444a83a2abd0d690e9bb902cfae3504983bddaa957f82dfe3cb6385657a359146456f9d1769252f15ec37f180655bcf2e1fbc0e452f8bf81d997000636d5d9c44875edbbd779182cef0423fa2919a489aaa84916f99f7a4e4799ed9d0fa5aa144c1f5a90e5edccd30451a579293dcf41c0e58f9dd5ea857de410136ea3c74be650d0b00175e83a3bfc73dd61ed16d615e536b44086a3cbebe45b730b79ae9195cc8062bcb5980971d63b89a0323f24894f22f2e594ee06a62249fe44dce02ad0ff3fc80779dc574639b5b1334a88912255ade26038d8ef37f7a5608d6de4973d8bea250efdb4cd81067d63ae50c4ece9bbe3ec88b45f9129b8481fece5f4402e2d23b2ab5676e8ecfb56d0c4a028194b826c755d740787a2a8570bd47ff645f6e909db057b1e835f6a2c6d12887a4f174d5df4c275b76cdf1617c20bb1ab88f9b1e287e293c2de77654e64e2ac5578dff379e478fbc806bcfbba94ec6b8af12a48f3ccfda19e6afda732c07b8fd5ecaa227f1326dfa7c9c6bfac8e022b977399a066fd54a4f0d73b04151c236292d0110d45a3b0bd714a4fd63b0faf49847ffbc0aff0da0a7f7b26c9f10a27daea99444489aebe43cf4e95541e992ce85d00eb42a1961eca1fa356b539bf82a15f5560856f7eb7ebd370ab3a6f5838129a49e9457ec011b652fe45ce7e6862d490ead166ee1957e9362f35207d4814c4c96853b134cdbbe66b44c2a341368bb78557c18627aa775d1d1a75eb189a34d91accb61a76ef314eaff7305b351deb9846fa6c793a5874b54f9abef36b9a69b78939975b5ed4e126fb91aa6b563023ef05d41ba09ed21cc5f2ecfa246d153e5a3d26d1a3cbe23d7c2c175566c5898d14321502e6d9d9f2cdab45cf93699165b40abdbedfb35364bd7f80145e116b1d3ddd792eb6682868c0976a83429cc01099ab6c4507feae6e218a9d34478921356be7d5055cb91c6c81a7225d6c93bf0a87c8348c1c58698a7616d0711cd4a7602c2d87db700354e9c722663b8642dca51ce17c6791f735dda9c597460b41cec9b321ceaa349519981d4566b6b63dcbccfd9e715d62068124127d41f76017ca175b35d8af8c259ccd4be8dca12e6f9ef84b852c6d0ba4097585910c8ecf430d9b472aecf416baa4b49689844cf09c38eeafffc470ffad7cdc591fc440169d62cd20a16983c6b0d3a900489b6568ce53fc57b461650a957fd64c96a6cd2cb3ee1e5e9157d2d5af8ad2a1d68f827f1d3452f57a4e200f89a24d2beefa89fc2d6f16cff5f1ec62355fefca8fc82705247ad4397ab8932b8f7f3f46104094c6768dbe5edb98218a35da648629339fe692e34e173b3e41b3404f97390973356fc7b522e7e0e468c0a01718902d51f0a49b0510124b06068cc2072260aa727d9052447391a7ebab3afe95f8d0241c9aedfb6764ac55cd211f999b5628f3a942cb84ca40568def1ce6226dd88209f8253c6a2b719c2be83bf9f7fe901ccfdab8563cb5a7e79b913c6fdd521d882676cdc00d7f93fd04d2517fc304b28e26e51cf8545f0bd8c2c9ebb8936a0507f3b96480cb08a242042507357351f2064b3d05bafe87ff8439d45a325d5b112049d9dfac882daed193aa35e0bf830d78bdd94a6369ca3522550cb9db0f085fe7440f18f48215f06d375f06aa68bfafdb2045eb2e6220647bceb7325414bbeca55278d41923ba007694c26e9928396d6304287e9cffe41d8d6314682ba3a9421e1817293e11813faaa43d2f9af8b49bb9991e39c37e3c59e5e6f6f79cb891296406c610a5d14083fee5d0c75ba1d8e30e32635a4bc20ebc1be5cb4f9c8e634fda9646363045416ba9a0ac107829f23e0536e0a073d7ee1dd8711c69345f738566c8dfb417b0a5d4705622b23d94bf821d1fdf8e6477b7193c66c95fadf4dde3ecbcdd25bed9f4a84d3b0c167cf52051834849868cb72a276f99ac99d8992c4b775626ea13b9a9ff7b92984fd36bc516a6b79f1deab09597f1f154e97299dc50184afc7867786d9798267b06b54841f12edd24a82d30c46017d2d06b1db12770c40e15cae45d014e0d0cce76cd54c87cc219502e57646af40d388e708d59e4a677f2804bfb2dbc06e2834bd6c324e78769e18ba1a8b1714dd757b17b5e8de12dbe22ed4e03033f71790b8df475dbdd3686f82a582561d7e309a4208529ede4636bf5004fc88a1c929304df2b32625bcff3be3015098cbd69364f09aa40c6f2f5603d3f9f7a7976ad2b94c641d7df81867d7b919e92efdd18e03bcbe0b45623869fb7b20b9c98202d6689a7c4b7db165d668613a140a994a7027d1d61f668720f91a68f2f2940bc90dd433782e057203c0660e3c4241c562585a6563f6bff76714d204507a34cf5112e675fa5f00b99dcc073bacd6c199a1eb0f240c967d3094e24b62ac8608fc1a7373432e1f96e16da1d716960e34ae1590d24b0fa98c5930d5e780a8cacf4ef5c4b83b3dfe9c10f14c64bf10d3c3dedca83c9f37e89996d4a7b92de702082c817d43d6f6a9508d13050b823f5a7d98eda2ce78732bc683fc609d8426e78b189c78d8ca1e6e0641686f8d29dc020faa86098844a09d6d9a2c93aaa8579b58217b0c7c16b0b1e1a3449334e31033c98f419c4d2391e962cd733e6a09ce3d6dd94bf86822309cbbe65c29f4efe95ee210e48ee5ef79d0ccc634047d63ee29d9c3256b7e5f027674ef3ceb5d834b7178d90ab599a5329407a59592e8dc87247db8ace7b7b4bc3a3c6d08107e50bba6a898c3950ab8511f2422bccd54250c169852a78756767e8704a4a371408ad8e042e449cdacc9b46449631edfe99ec941cc202bd5cb831b68ec24c4367920eb348d7339ba8e0c6d280696e8d79acb9a53063347f253f9837743974962d08c5186bc55c1f4bbf3e1bfd72119d5617327ace6adf9d39c40ab1532a83eef6f67b4096f22636af04c2586d28576c40b3115d88aafb2f749ace9c9cef6203d2779e899cacd8922d6c88d418342a36828def5c2d0405fce76a92decbfd201f49674f93d69cd8ed3fcf31082fb4ed957a8bf1f7f3ee4f9a61913c3327b0f7f163c5b2cf0b3729a9afd7d0975d8d09140b0fdaa8353c147defe58c78ab89e601d1ff0e8c11b36556e0adeeb0aebc844961419b1fedfce4a59c11b1333aa487d540a40acfae79a1006af0760c36b398052387642958544c5d052e5abfc6b9e1364833eeb841561bbbefc1926939525a1ac1e544eb1d077548b2e74cad7e23fe06c57e9f7ebbdc2176b6dd0151ef203d3e01ebab38bfc7a8fefd5ce49321d75495d940ba0c70626946ce9926ff45550804c37db2e468197183faf35ee3bf3ae5e489d28e3090b0284c7b3633f2541bca41e03e01b1de88941aaff554262ed8fcb73fbf64aba1da9ae3bc6e0bf6d15491e419918ebc3df89a9cfd9e2b9d0360c7fe1d5f7b993713d873f0203e9e96e0a4c7e598e3f7550eba89c972dfb81f729421c6ad06a5a4df3288f98af5cacc0afc4dc167ea0847bc4d3131000598b876a330233ed905718f53f4bb059bd3ab56198464d50c8ae5ee2ee462886b11c3d7b49d17a83932a9eaed0f0f51cb9535162ac9203b7e6011346e181273022add738a89ad00e88b55ac2391de3f3880e6c3374e18cc72fb47df16c27d6435714f716338b973428f0cbd308052304bb8555986169820eb8815c4d34e8d983622a607b229b803a80f1928a032b8572625d8f6f43dd0445da1df6338e13ba6f6742b2095965cc455d18b37ee4c47df66f1f9d9f8b0f5cdfc4f9e3f655a245109453f5690fc45c1b82f9f8e1f6c2bbc273c4628296466b883b4c59c200d2035fc52d7139fffcd2b2c6f4b89d7b07e75ac9566eb62f90ba2dde18cca3860ff67b2c510baf79232bc94fa6199ea2777df4836392cd0a5588f41b638b84a4a178897bd0c2f217e491025e454a0a9dc134f74d6c9fc75279dbd4ac55f03b722c9283147fa0cebde2efd2066688b1a180849887bf887bac71c75339c247bf1050cdbe9651beccaca08226981391ebc39f0d595b65f72b8dd77f14d9b637365b78adc2ad686e9dee9ef5de2775fd13beb869906509deb814e90035c6f05a1223fa13145a1b02bccd8ac94c1f6e0bb673b3dc66b6ceb3b50555fe4f36ae672c4bbc391f3d724ca67ce622e967870f85c1fcba4f68e3e5ed30b2374ac9f6cfc46098f385c8f9d92289d506b5b8171a40e42a1b3bbcfe7eca9af7d89c6b16c44edf47acef74cceabfd10712f8bb4a81852b7d2d01244b3b7bce1215d6dcf7e841e3be3a61bd42e919f6d99483806d65f960ac2ffaf41d6c5f8dfbd227a0f84abf0b7fa5612b56eebdab7d3c80528bca3a624412900bb607de4440c22b0227c037d00ff44e25b1fd5a965aa23e0a3a0fb881052bf990b5ea403f2596862b2f46148bffa12397c5c6e53a874f82be719e37d6b4fd29ae948e2a5d643d592ea51c64e9c262971b3be8bc3da41fed6578fbc8abbac74b6809fee599b7fdafc27eb1ee03bd9924d7a1eead2613392fc96c9fed8b1713833379bd479b622bac9e88539edf3dc805568d3ba531f4c886353d8428d8df951dcc755053d9b80f08898c8a816cba952ebc0d9f3d547c926b47a2781ea44875fee66ba3f3f24efe45997f1aed185d23c2b90ec53d8623453b74e220cea9b81b416fcb346efc7db13bef745cd9833ff84e8e1b249249f303c5f9de3c1de39c9b75e7bcd7eb951b01a95e03c529ec49296e0531f25200b050f0e1c1417d78cca23d69ee75a198beaeb6ff64f60c181e7de7be699d62ccbd9cb0e5cc642a38ae2b73af6af406ff59f79fb830b07ddbb398d8b219149bd38b50fea931d2ce4f43b8d2d75fca54672d004aded34f1d55f4b711c8ad8a0eb1d8f8667e4542cfd7b18bfa794f54fdb5dc58210746f67b53e4c447ad35ef7f7cd71207702acb074a2a359ea4d2e32193b0a98b7d05372da2555e0d557408f167c61ae5520c5a05845218ba78844991ed3ca3df5028805ee26c2de3858c813cd498c7e29766baca4d47ac07a6c24083f7e4db37cf8d301df1cea9d1e4b285165e4c60252a5e1102dcf7aed37c79bad771f388c78688c5dacaf3d93f10ecbff1dcb71d293801843a46dbc843e076f0e2776d7df531d1e0ebda1ded7e68bdddf8d96ec6a241aca16c2851165678bec05a423a4bd965efbd68b2e5f99a2cd3963ff774608b628a76268aeba5ae020c05dae687dad4a81b3c4b21ce7508917da84f2b42b4c18221025e53095d322e201a9623271c7ae1081600facb78502bb2cd0c0a8280c58d3ec51d070be67bed5bc12dcb459a483e5e9adf3eb038ef1ec8b547856e4735185a1e296c13a52d7d74cb6f1e172430c37ec3198307697f69c91475a0412d7e2024ea898f4cbba1387b42b8619acd8af248ed1272495dd2058f189282ae7bb0dd5f49a93ff6d0d6ef089ceebdf00ea17554451af87e8b2ee289ebc82be76f86a856f4eb58d89c44d8385788e6e2d14b26f4066f380c82d3b6e1f0d5c62e5d6c83dfd62dbda38a13270215bd8419f3bc3ba074b3da07d7e5b28e092c1c3081691547fa6fecc1a6c0156413419718f338e392c16a118c7fceba5f0ebde22c991a6b5410b71bd47c95477c75316087b83a43dbabe63c8ee4d2855bc8601eaa48571d74f46c64e0765ad336bf38e485a0dee625a2d939047a13e70735bd43971821b66e39f3d5ae945f13ddb09037db1046468eb697b3e8fec4d120df1764f4e18f1084133cf7feecebb85d3d8566538b283ebea025c94949f18b91049884f222fb90600e305ec12cd6af3b24986aed2c55252c0109cb0adb31ec2f9cb000ebb02d3e89cfdd5f13ce8805d10270ece294e313947248c23ef3fc4dd6963be998a8d5571192e887b84197809a7cb0ff4cd8f19bf9c0f095f3f9d693eef58e020bc28986e4a01202b63ba98c44659dad7f5b252c83d2790b5d3975c42927f9c13b1b3c3168c7870e82eaf0f221ef7f762282847c4c0139efc3557451bc261a9f48e6e046132b3c2a5963e93f47aef4760f0d260d6e62aab82384b3fb890fd685da78eee782560ad0cf00f9e1f1a30c975209e588d914f97da0e5e2a808e9c0d7dc64cab77da828e9fd6cf7fe7cf7e32dcfe64ad2c13ead806f0d053d8420e6dd6efba97409a5ffd043a4ea0db6ac5cd15733c2d2f021d498a1fbdab6856196cf373e1cc04edec4f74eaa569b52c4ff3242e34b465deb5674272e01151f86c22f6470bf8f1e3b0bf3c730b8c2203e2c84879b69aa86ab76c53d890e2bd2a4f8ecd224bd8205630372170a82d0c7bbc3d15bdfc6935f655767873a7dc01b816ed265d35906c15a9443715b17b7da344f8a73ec0c51ffe75e173d255cb5c296f2a713a5da96d6ace10f3cb436f4c01225b42925068d3e3dc33ace31a11107311dcebbdbfe8416120d0a450fa732b44aa2d891bac4a323f2ab7acd5006b5d6d5c26881372adce5844842c2cd4ce5c2a475ff6fecb9a860c9f649e60499ab0ef1d63474b96876995bc55bb745d8df5e03e3b7675924bbc50e64a58478ca85d481f67bc07b876a653f325d023ffadbeeffda85cf5c4373f92fcb1b094a44d108589ec52c55d57244a5b610f619977975154a4e29db0feb7bdb9f150e464fa5597916bd45bac48639a8d5e36a2fc1d7f4e5d912487a02c219d2c45d8080ef8ec131857ff237b61f89010f19e50127d027b6f4bfd92175123e38508dba5ed4044e0d0b93a754c17fe6997f830213a41edf77496a1b68ff091d56b05156f7d33215d853594e8f3656e6b5573872917e10ff5a4ca84b2791d60967ad6f9c7538bb1950be3159f2055c16d42e2210b6fe92a5522b9f03eaec695e11c6455639d8f3bd15c8b9be7882c06f0cd9b6d6200b7b1310f4fb44c70d7c26023a9e20f48daeb5b417a058e1980b3902c27ce4544d6f2323bcf7b01f49756f23b26e7ea60b74b67ba609143d6882b9a51d1457ed197e10e14ed769b4e0fefd1f763033cc8ba41a678f843e2ba16bdcd5b4638117f4327a85ae0da31bc32bc741e289795047c1a8da7ab3b9b482d7b910e5a94fd54c656e6a31f2d5e5369c69b0c8ec4801cdcfa30a8fd48df9a5babe0c17d52c6a4be09bd1b6896eedbedec66c25763cbf9b34d5c8e716b5680341e857e6bc37ca63d1430aa96bed4694007097dc2bfb589119f0ff304e6f1b1d2ee8ce7f187e378bbfe0e1128d4944b6d2830e20d346186874c447c466e4c8c645ff6c7b5777f77cad98355d21c655a13587fd03025366f3f07d5aa090f67a2c718d3c27a9a6b9148fa710949495f4ab5dcc9d22efce291e5319791f69a7102636a2ff0b3996bddc5f91acb5b1e6a85df4f032deb358ddc6fc92218a7af67021c43d3c19bd987af6b94ab4369bc874e8f3c32009a11e657cdc0d872fb958c3cc41b2ac5e8c11ec2c8e2a7edb097c3ed395ca33cae79e47dfcf19dc3d211bc08f7fea5e2525bc0c0738bc15ba2b9ff4aa1dc17eba862d086aa7b5cab4b2d9023bd81d57cb26b9edf6315ea482dc9239ab7de43f56f0b508cf622057de0bda7c605389adf18390a77767d43a2b4934d360a5075a41cc4330b5240ec2210cfab8e7675afac84786c96003f9026fc6ef14727f7898b605174f9763caa1c276ff04b2309610957e2254c566f4b9ae7c82163341b74a63a6ce263ff4d30952bcec4448c8954e8482f4295d9f366ca66e6c68e9ac2a64c6fa8a06e28b7ae53ea894318bac7acf2d52bdcb1ba6c28b6706e80a684e5523ec4ce9b7c0f6d68a6f2421a1f05ef576787de35cc5c1ae80efcf5e3a8b341928d717855f2d40b93774d113c39109b4c23e5d4f8a841cf9ce1a4d1ff6d0c108b8aed0e0663574580024e309699cbf30c6947ba705230a03a608aab8401efa1d8ab648f9120965e85e6f7d2db1199a02d32f4816ce00c9bbde48c847c7d9907324e4473f479f92f2572b1fc969bb3bb3071efa62fcbb0d25dcc4358c76af32a1fc0c08c03276f2dc83591214ba071939a37a3e9b751efc1aba7394e3ca898ebcc6f0aee06d1b533e14e9d148b73f0ab025d1afae5a30f6dcc67ffd8b2e5eb05ceba3a6c788b8f1f94fcfdfd9ea64a949834723b5edcc2f751d2a6ecb887609cb390edeffd45712415c79c22eab700f765f95517e41a7f15afdd6063fa44bb5828288cb1b14396d31d943e878711f293185ab7929651d60f4d0565661a7f57da9103a19062092f013f4a7fb4955f2cd23d5b89183f7a0f3074467ee1da273cc63d12d9c2776a4c0e99086214822f4362f516bea30b9d7d40b0f64ca46661ed845a9c93ac8445250bd272bddf7db2a387851f5e9f25d0086b76b29a1947371b88fe6715543f6dc0c58040b07d071c296fbc7767322f520fe7651224d567ef56de1750d2af4ae0c14d8a5923835ea7f1d9ab5cec29aedbd3645620e12727daf16f02332ba37b9d4e28c9bc756502139449e59f529945af053e5033750377be2e9b7fe13d3af9f49edf66f9b684695b43722de7360e4a2336015433faf32d609f2138eeca6038e347f007793a79426b96afe423754a79230a6e41cb12edbe41f9ada48cdc1928b3296bb145cb1607f619b646d7045b75fbdc6a72c4e65f8d1b526c85849b69d2bf6ed4898b74f0ff5b95cbd4a570e63bfe80ca4642528004ae8d37467ab80880f99cedb05d8e25eb3d053b7623dab02817b81fd39c87719541eadbadd4bb2cf078fc881a81678a678853c9f704521ad992b21093c1b2c13063dc696a7d6a09882c74b3bc25953846f02987d5753160a76cf8ef5d642722b7c42a2db3b95d2350b330ea98f2b109f1a9061b3e7b3fa5573f7ed6316ee9bf52a96faa0bc7fadd52af399ff81b76c8f27c133e7fc260d9d2a8baa07f26303c20f9216d2031ab6eb93d725fde642f061a5ae55c8366074163ee1dd7096786a4cc6c097d0612ca94f1ab3f446fa53fba00a94c9e67e0d16426deb71229527811b38cd84306a7c862bee41a34e7aa53f1a9f545b6644c640cf522aa1515d964c3e8a79f6e5bf8828a6d44ca11ab06ce9c7ce916edc169c8ccbdedfb2bac947e97458ea14db5f2f2eb0de2e1b1b3da89f2832cae254096aaf19dbe463cbcfd628c5f4feb2a0dffe270cda445fd97c4b832a41487538383eed430c681adda2c31cbc330fb2d3581c1119d5338e25425a4a571eb5885ad103e95c7346247c167bf2ca2a07a393956df2be9379d5a63a049674f3b81383aa38bbcbebbbf73b5af2c6338717a2ae20b72cf9748c99bc62095807a5b1b9b8ba074db32bb71117ff8b0e8100d8ce80fa7f077aefce001b14dac6198b904377a6e79209ab217417db4ff254f4746ab99bd2c9cbb4143128fbc106b3a872c06ec09ffbc3ab50f4f34f67e9212c05f554dc6407d17d576a45b2e0949ac642698b167a4a2ef71e121b4441766b3c71deb8ba0bce51b7fd56263d7e987cfdab956db349e84742c3d29a0bbc4de56950d119216a9e4d474f569834759c056d8e60c7a0595db8fce533c5e906a560fd0d5900f1ea111116450d87fdcc74bacfc885018b635210828ca1f156b149e1ecd53d3a31972df6da27ce851d8a9504c82e2089a86413001cce682c2c989785bffe083b6fd21734e30a7dc9fa1ca74321b17edf82cea5c38a30263157964b890f2aff894ec8946ed2eb40e4d35ed3235f5d8fb6242464716c444f12826a95b1968c9bc964bcbfd0516378ff3e1bf82466debf4ef03a6a06a602c38a33cafe0f0cfc9027c51fdd21a5640b7020e9feb30edc890400cbf72bc6d7ce3224ce750ddfc11aee60b481aaeb309bd903ebd3208a96c0333a181807c1f3564bbddd2823c7054e6e232fa8a32828f920e42c46740b2e0ab068d5ec97fb9dbfbf36092916c4463631579506b2ee04379ad80436b3cb46d1eb547c5e799eccfd84fff6a178313e3f04f51a45deb772c0933f01ed7e9fc82694590d8dc3ab1a896016be793ba25bb893e5dcd7719d83c773c8d944bf9539385d239cb0210215fe7b73519b5df410e68a211e0e543fe27d51ddce513d429adb08d34282fbfce7011f9ec9d1ad757ca8451d94033b8b0028bf26a02bd7db24810838cd81f51dc79922fb84adfdc6c7e6f65b4d6be2a4624ff6cfba7e1bf436a31406304a60be98c701a5ac523feefa2c581ea462c7d9946018ffdb9f80026ab8182a18ce3eb5406477e9a1f3162760c2be0544856cfdc137c852fe9cd77777635c7fa2a5fa6ed061f443aba9f3610486f465fef8c94db365e649acb7c2a8db06cdb3cfb28c41f084ca6ed08c6569fcb5257e61bea9506fc6c79e15c01f14c1374392c6f47dd0441bf14dc637e8ecb3d55af55c21c989053a7183714eec85d0ebcc1c67a9407d7b2611c78b90d86624acda89fcfd9e4dca34a49515ec4345834be57efeaa607fd3de09f9a932b241b363d0a636b8246d1ce92dec3f819c6790d7ae93badb2d7dc976444c32b64f63e219d8a9eed9a99a903a810dc2903be65aa07788e9e68e0b5528e17bffa7df1c87175426260f8ce551eeb9a1478ab4391ddaf8aac7ff59fa37b30db89a3ad6bf88afe6cd6c67ba42dc85938f69dfe0958813d830488dc574f9808f15f6e8e5e44fcc2d3f273b9c6d005b27b759c0edf94754b14d387aa00a2c8626d6cbceb30cd28528eb7011a91f53907d2cb1e39ceaaf102fb5f19ff6e6bbd4a91b88e47fbed4108b558111bbdd81c253d3d5a3e45d4831b74759d1cff744e5484081808bd097c2b3bf5dbb295f3c83e2f46d2c2eeed6b9e1485d43b3d255e19c52f63dd3539b8a78b757225db752a0b689de788731122bf0d3bff7acad352f753dffc750a5882ef13cf1cc7b2af73e1d656f4a519227215594f892e06e8fcbeb1e2af77cefd484b5a8178a69d5f3dcd6a085ad7ec454960b9e96a2ff9fc7cd9fa43e810bedcd115e360d1bb8d680cc99460764d39751380a40eed3f8d31476964424e240927a524c7715884b0776a6bfaebeaf95dc722ddc07651caa56524fc45d58362e5ea3828a8f8d025773447ceb788bb1b5451497048ad8a73a889301287f87dacaab2146487b4b6d721ddbff6bd2fb892c5c1127e1c37b17182ceead5e4f6076d423cc10a729203ca71066d7c3c40fd9e88d17b2e66e6d7154db7a72f74722126f2cc29041ad98683594ec96f27d0e7f5008654998a10eb7260a1882cd74f61709299d362b7e97bf18ab827651726c69875bfb89917090612bf1cd8f7ffc8663e565ca948a953be5e5755f58389b4459e79605cadbadcee88ba1d76da39a60509eec5cc3d72a2dc21efdf0f85d315fd0957e98c7dbea0ab96795ecfb17be7b6c1d26fe6e6b63a4d833ae6fcdecf1cc869454456888b8e0cdbdb16084ae08c44a36acd64a79787f4cfc5818183330636246bbda1abfe9fb1cb4a3f4b7acce009acfffbe1631d1e68517848e0e84bfb164827be73d0c53b1b54074db48609b27ba551e101c3c977729686545eb99cedce8d0106da8924dc2f3d6b2b1eaa133eb72325849e5375d19a31cd1e6fd64c3e1f3cd855ba071a598aa8356eb55e66a0e7cb89138547a06b30642589a6e31069dbfae80d95cbfd71f01abee6a919d5b3604a3dea16e966152b5d9af912e87512d8f17f449597177e7f70af54ec82b57b58a79d631bb3f2c53597a4e295db5591dbb57bd32d918487ab85300776c794d05d4c07867dd67165c872a97ff2bcd1a579dff2cb760dabe1366dce6c0e4b294257140916988e8c253b8f32a76123164af4f9bbfed59a0c239ef1fdb88e7c18bf1784cb1567d981762edf1ce49c213abb37a31b8145a4b2596ead4172dec8da5c26a890340cf5dbfa8e5fc2e48102e18b42611bbb1e7bb6337d6e59b50887202218fbe35042e3bba4989f48531419113c3128af7c079351e26485767d5ac9b8c410938ef81e7f0827f2634c16baa387e13b4ee4f651877fdcfdfd8a67a75c44890981c78dbca04bcc33e4e988ab2c227bc7a5c2ff22168460b18cd8811d55a09c03c08fbe43aca6fd37f51142fa1d4672b2cceaaece5b63de808f484835435d9c37aa088490340a8a2fcd108553d149a11683164edc731a67e31a8d8152db687e33a581f77a3ed4fb2e439d553a54f3f1c2ff0a0123fbe005eb909e515e95322e58b1bbd543c9582d45a89cfbfdcb0fe2a68703ff0151d5dce91458e1a89af25c078900b1668da253e7138023f77979d0891d4170ffd130bdb","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
