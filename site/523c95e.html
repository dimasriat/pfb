<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d193dc5c36f003c7a30c2e0a43694c18cee9e491ae4f015f10d236bb983c82b46889dd656bdc68a712c0d409368024f1f3de9debafabfc9e20804061a628836e9eeca58187d4966547606a83876e2871ed2b49862cdf525175e2be8f9435422364773cdcaaa2fb7106b9558f69ce82a7e230999d6ac221c189532c516c43d36c89f78e64ceb0c902456f22533390ef48e1f5aa7c7d63d4f4cc95ae06473e7c855501850ae766bc5cda602bfd98f267fe3d672c38699eff33fe00a5873f432386720bb8a00d518393b1b1e1bb9246fab780f2be0451e8662de8865051a4ad8c369bbff5cf39b882271516770f3d03da14beeabf468021b5fb5cf54d1bc883fba0b5346b27379b804a33f9693df5736d4cc4214522c90da04a6c0ca0ca5d939ad0962a0169066b9fa367bcc5fff46f2bc7d2c1bae86003c31bebb5a023c3a4421b33f59713e96cbb8cd5795bfec2cdff291c0a00924d5a5574e7c12aa606cc6937ee863ff9b33e0e76e700be9a7e7793e0c4053ec3582711dd8531408df06bffc1d19496372874725edfe24e10dd5ccb2394c76d1fb60ec248b6de3798bb768952b7571f7b3bcf785002f7b569f7b4d06b50aaded424341dcffbff4d81d3cbd902d86f9f31159c53d831966f18df4cea09e009dd7bd2804f496225987bfc7a76a1f112c6f5e50595a0abe127fc899a638e0004d58c2af340bf482ef6f74b1482c9cb28809ad8a90b93e35808bc9ed6da87ce5899347be7c4f5b7b859ea68ae85cab30741497358aaa9ed822a28d71643bc96a75768d68730f5de203fd7cb4e85b202c6edc4449f88c740f6967b148f9fcf23732d3db4db21213150705f46b892e234c770d548bfb47cd4993d751d46a866d77d29597844ca575c4de06f0a0cd315339436e47fbdf52d3ee9d070e3a50dc06404a0b904a51303259b23861e0f613407b19b623fabccb05ce42107b6aba59255740c300ed855021d0182bcdd6f703b4c3b01f50767cbf8e8e3925ecf35f2a3708eefc84b0d9ca5ce63c0fb9a36f06315132522dabd4723d8fa897a122b73c72d59a4ebad0e4b8c2f96c97b3f574d9936bfcb8001afc151428e3cc2b584dfe31272a34e82f1d5ca9be8bf7eedfafbfe8575404e50270c66497b857969675e5a28266f6f20c56f0e26fa39de028c2a730e6019040bacf1f5d3acac028b631cf531c91a0b0de17db03265ee75a466de99eb43a5c7693479512fcbe472459e8500a2a2fed74fa70a12185dee0470d4dd8036f0fe4b6987f50a61810225011e86555372633093e8d5991e5a633404078244c58f1182cb793d8edb3635a163af6cb6c49c92f3c0447bf9a76d632a034b6633edb78b787cca78c727867d004767b4277a1feec9a8049367d1590673ca87aed54a73034afc676ac93f716ffc6dfc44ef047ede50dc5c2819528ce5af7f4125104d9b1cfe7b078a1966a9d84afcb3fbda759d787781b09202508b538c984c3887edb05ef681e3e509276625b8b4e0486210e5d705673ae48198b03f96c9b49e7c5e12e2a11f3830ad704a2b16d4fb533e690a1f47c77ac1c1ff9dee83362182cb6c27322319bcffc63a8e4ccc6d3358704e6119811e72b0e966e65f3da19a42cad8de3efd5a9252d97994ffc1ce1f0637f6a5c878940dfb5f8b1abacbc67ae0c879f657a8d62c1db0aba689463d09794af4066ee923a6ed571c6bd0b8dd62bff5463268cd3131d2e9d820e57e358d7f7c92d81916096e105924e8a5d199f88f43baf464f649ea92d9c9c38b522404885d216a40dc9551f02bd822aa2fcf73a38dac441d20da5da4e6a1596888828e99e6fdeffa11a7fcdd3929102a1e6f4489ba0f164736542248d2c6d09beb5c44aded4b2ccf9602fea10a8b8b32dc468d4527c640eef31d6038e39930a8de550a6654c974faf1f3e35a4628b989f6e27afa9bbee665966e864d1972808cb2e737f2a15d2888c3c582a7cbf0bfe5a7ad9368c2b9405245aa588046a8efaa68e4466b5fb9437e3a3d46433c6358f224ca78d5a090cf027c99f868efa8f54b23dced70a945b1c41ea23189421dcdeec12303a0934b6ef692e52ba2b3b49d687f20cbfe13c7f80eac4b021c8be3ee6981a41fc50fe7bbb0781e708c692fe5724d2543569a3a06f54ca913c231d52203765237b17ce6f06e80fd1bd8e32ac4f38ff63921cb7f8bc407167f7219c08f9c8e8a45b3876a3b49ab1f67b4dd099edb53bc1239f8f4932c66f7926f7f729499e02e2dffd33bb1ed39d4b2f638edf43d79efb339efcf1aef47fff468fe3de410a51922ba764a225be1f4bdc70c9a94a671f562c32b90aa861cd4b5f627b7252d0b70f40a5f0a75e6e0407c20258067c0f9ac4850d221d7d1c6fc461ccac5252487d8003bfad164d45731517234315865f6601ca6ab0328d3062f86502eed9f565ac322394112ae3f7ffa34dc75a5d0db225e29553c5949f75755d400491f0f7a247b04b9fcece90a2fa525a7f06b507c31dc789ca9df0d8f5888e61577d947acc9dba950eda43dfaafc8ba84c95bb6febc2b0d0341e73623dc030876c4cc0da6b04dd3ae8c82654bad584b9ac34ca72b44910a83cd8a5c06f1eb23315db4dd933dd8dada87a10b972d05e2e715212ea33c3ff86c28fc811577382b0b095f1f89d07dd760ab8def6fe426720751d2997e3cf85e214c28334d644c0d40bc6923f0f5fdbfe136ae7474d1e065a697480f8a256e7286a0f15a156d94ad1699389ef380e731e78f87487e6e7849061d94e529e4116e0baf0c75ac3e7d1296ece7cf8d22fe1dad171470399303a5e805f2ae917995900f47b0850776ac2fc6b6e678b9f78607ffdb9a38a153f25eb4afb1d16bbd099efbd4f63db70b5565ead029a46436407004a42098761e3fcd4fdf91f4596dda1129d9c5a7cbf6743670533459ca0289a82146fe28f0c277b3ae0a93cb5d6b2998e849c2929a476882648514e486ebcaf7917be3d25218da24df82687b7f10f29c6b0132558211e1388e8eb51275350afd220591b93ba380aa4fb4c6b52ad409fb4e5b4fd2c8c08ce74603e5b48c0b1d8f54923ee7e8af2e38c9170981609610284fc9f8fb6df9cf633ef67b11bfb89982af19bc3bbd8e1dc6a34bb1f32e9e042a6ec4b6f212cfc0d7101bc875789e5cc6c491ea59fba2f2f9751c6e05c2fb5b391690c74fb072259735c9e278b4a15993accdec6a4779e00d1bab2beb59e52feb1acb51376f9111923ce0429d8bd6e11f740161ff096b2a8824f53752488f5fc3c88a36aa8d5dbeb4687a725a9b3786be2e934c6838734e801f2467ebf5e9c5cb5beb78980a23f3ffb28d4b3eb2d6dd400bf653ce46edbc8670dd47eff8a2a5db1bbc799fdb20f8a377c9b9fd90e714866c3c6a9173d838a02de1da3599dac29ad1b28968db1463d23e90285d94e7a81c19e26ede787a536700b88e5e7fe06ace5c49dc621a2b6a1a9979f3e523c1386b40917451259ba3925e0496e2119a89c5a8e4b3d287e271f0d67a86c65f12e6ca858f1c6096223e9cfd2b2076b17dcd174d95a3c024ef4e463ab2d2eb8b4dfbbd1430f0d34a710cf6d29c14a235c1cc3a46ee5c8f72c561bc2a3de666a02375f2d4214794b9c8ba75600b6c45fc01cbbfc99923a8cd6a1bf1dfd4442376b993a45b876676a827d669bfda27af6102f18b5509b5b68d51c46ac4888a08ce6b08b01f10b6efefd64e250bb67eaaf716cb503cad752f410321bb6b02a86ac4d87e06a35ba41a875cd43d654f9693135b14a0dbfe401cc87e19600d45e63fc4a354b71d241c327bdcc357b730de1d75e966fcb360c05c238282d7e42c00067fa7d42d297161b00fe040ea7bcb2c1797559cb196fe7725af4de45c10f82169a68d203c5508dd3f92c02bd57c89a855533dab840faeec27896514c39b14b3029f9a0e7dc67d4235088d72fe8e3c23529d362a3eb9088d96bbd5ea6f8644c3f0f0c832ef5833bda9c93689862e1b98f3cb71b87c359482d58b88c09e5210127fe9e96f25475f047f346e3560895cd5bc9920f69ca1e7348ddc5b6539c1d900025a9ace7f2a81548d0e0521ff2e3e484fef9a4a8b1c16aa71ab5e9843305952145c2957f9356b9f0b26839b561a43004a26433aa56b97d4a6dd71b58c29c1253785131dfb4bd5f9348da718a6d6bb6349d45781fad104527ad95000ff2546cfe2a723d9aea0bdbca516248fdab1a9458c860a7316f7398b4edd2d4d978fe73fa23e48e2dfc8f31bd4997f7a0641527d09f0c0a698627baad25f892ceb3d82c4ea02d6a896180527fffed8466c457e7e7a78a69adb651fb19d9f35f4c96a6eaa2b66898ddbdbed36e8ed9daa0dcc6d8d292ef8822abd4dca3025c520c05f7e227272244c72372249ae380b02c4d8515297a54a2532ac511f6ab46e03160bb2ff7e05f1b8d28e40936603a071fa2e00992446ad211046e22673330d6cc8ad8d490fb01002cb7f3e9542cb439c42274d94c096b6b72dd37d6f138362bccc07991844f27be3c048532161a32b3cda36ebaa1dc8aa7f03ff7f1e91f9bf508dd5f8c5fdd8be556fe11cbdb1991039f0dedda41a0f51c07ebed8de3ead9d480ea6d3a0d09a227758078368c31d89e2a3b19ba3e0a5d02b071c61f15e124cf7cb70cf875c91520914fe94348cc68015706919b69a97c34625774775131253917627a470428412733c26ba6c92ad42c9bd93be35a7a0477295c349620b8a2c157f59ed132dd186fc2cab9269003c8dc276f0e0cc0be3ca4fb62ec9c4eb35f1c3aedb63b3244ef93dc2e87c2342da99145b66d8641c089c763692041743555f7a05ba9e2c39e637a16be8456ed39b8436c76aac35a4608aada635eaf236262f4592c65b13576c18b8f80c3dcf412d310682b4120c4b9876bdc66ceecc30b2ca338998c806499fef1a4d643dc01484792f4cf7c7c8454d0727873005f441554a980b601112b5182f7d1e4d65d86f3cca246c454f388483f845574b604e10f5430ef95e181aa48df3ee3069789a7d2f81a0d01af8335d1b09da850be774d76ccde3bd2175d93cd9248a7f5adf6036554d9cbe1e2ca1b347e5b0f39235231a28b9a4e0f44609a5b7fa498bc71116507cb36e7a44be90d7c44ef82c2e03d9b4c0db115cf78403d646af674b1b76724409250da3df7de4cd9e2995540ebc26cf47df8d89cf5236cc74c12140359032d6365d0c967fb93fab56a2080cb8307f813ce77a94fe6bc9c4e407619cb0e8b965b03412ae9a7c3f3e42d335b2a81e05db351ca96b51b61a367e9a9f219672a7e9ef02237c25af011e381c03b4fb4bf0d2650bbfab1c88200fc418d778a7501b817f81efeef57598cb991546442ab607e1fe579bf743dea01f2f20427487e8ef2d3502a3de06c4e6bfb03040be483cc2423609c481f73fdc0ab0a0f24e212a624ea76f6a7f4f9405e2b7dbe6efd643bdf9fdcc39b75886fc15c62830ee412a2c4672b8d29130926ef2914cb9107853a94811235d6834a517f126d01c06d26654b7b67b417286d00f4ce42cb125966da3d12dba87bcd816769bd89edddae3f9736c6f4f428fddf634ac5d0a192f83d0037f08814d7102e9cf49b9d86fe22fa2e683d6d823db95d9ed2a714e68f4b89a0b34f552a01c4a78fd456423f5431c6e6ca6a084c764dd795d83a8bb738fa6e3993125487c24d14aff4a40a6f6c7047b2c2e963b69c6e98e41829713e39f10486113f8a9881f311da3e873e1f1ac99d20837446f47af6e8629453fe54fc3fe07c73f90961fc13cf8fe4d9e6359621865be520e52d534af291aea03d6c4414cb5996d3344ac691b890ef9967a4876c6302d7df03c3073e39a405dc3f23904bb89c5f296fab7e4d6e9354c3a673a73819afdd53a322059da77e3e73642e5d9230fcde5efaa39f31ba4844a471abea808c21940fe787c1f8bc0150dc26429ab99228067f13ee3e9c2872bab2957d744466285f59c67569587d8a7cb8ce110694cd946e40dd78b904c4299874d929b42899ab651da682b47468665d4ccfe58f853e8c91789005d5d542eb46265f3b2d92754578564d9b58d9a337984acc205b9ea448b59ba1bba0a391245b9b6c86ba3237556ee3da43b14ab09d8d472b30cdb994fdbea04d5fbeb559e8d66cdc5c04a3352bced97bc7e4f11a67bc76f35398637cffe66296f0df03af178e5d14a9bb9ef19c81da103cc829fa634b50b65b033ddf3b4b92e4da17170bf7c437c2b972a547734e3783659d4d4716ee9f0fe0085492055c8d3bcb9b48c281b79ceb59a797b1d1094b44b4c99019875a57ed6644b1f0019d122b2e4e5b760db870b000772d1c23ebeb465a95152fcdf6f2b74b70c1e2441e1135e1e15e8c89a919d0cc11311e069eeb581725d37af0b5722f3d840c1ea16f67a944f49f3e17ee18128d147d763d18dc505efb2cfdc657fa97fa3cffdf1a98ecbda16674cced4afb951e781158c897936b02d8bfc18ff601a60b785370bd7df6faa00b3462aac6990e7e5d33e63be14b28ce595ddd0998c5341ff7d83172caf1da74f6301f0115ad9c5b961ee6b8efa219aa26c4eabde148cc09519ef2f4ff7032ac9532c314ca01d4331a2e9a51f27a892010a5f32db9c3eb6282414fd31799027f139f6b69f6efc653835313d5ef32bf22e22df0ed6cffcb1aebda001f07c9798b1dd863ec1fb94ba8174545f4bd786e286843e1b77d99d512fe7e4b3f981b8b86c0e4962189e024397014b246683db1c09ab382b4bcef2515017641bf8ea65fa5893a1b80f4d4d8d6e70a28fbd3bf25eaac0e1a7d980ef89302ee9485dc6d189d4ce8dc6b19c24180db861feb60ac131679fe8468b50ef2d41be648f28165d9b245422f8cf6723d267b995b039ff44799b7c8e9c81ba25fc14ba243207a3021cc8266fbe45d1db9ffeac0fc6092cf8b0043f99ea3e259723eea25621573a31f33d11f0fc22d9e1277a6eb847d5476641791e77b71d8a17640eb2161da4b98f19283f6aba8d8eb571cfb6add26998d18ce1adba53e53953c482681077bf588a716ff4a43bed616d1680c5ffa4dc4aa2931184f2c5ce1bdcf5ff30a4732325869b267a5ee943f1b47a072f49e77c46ce7aac9699202565435d59c7a16da968d10e0ee3528b92205397c43eb6679aa19962e64ec7776dedc71219c739a795adabef27ad50909fbff5c4beb98ed2af3c8837633a1578d941daea9c5f191675413e00adc94fe2053540d86f7e481cc3ebbaced6a982e2cb2502d94e18794608779af9b093b86cf3983f780fe10de95ead730f064b33b1f7ba96b63d3248d704ed01847cb837bd9271dc97089a92bb1bd63d0b12ae27366a490dffd28661337170dede93af9eb21db04a05b4ed97ba0054e7bc56e65483dd3bfe504f237fc27e1f1c3d3aaa73f6d1f3bf3fa1cacdab47c69f64c951142b701da1b371e72d1e2b4b397488b0da629e71dfcb7a24b81e628406b85ea2beff8f334344346b1b982d894bf8a8a7381b537ace6e65ed8fced4a7d7b642959b4a8aa46fe4965ed4134f50d3dd6262367e8a99fafdbe8dabed560b85d64ea34e4c7c730b47b050d7baf53e82cbe49778401a342860c0562ad2077b4189e8abbc9f0f9206a189ac40c9fe8344e3953c8fe7cae4756e864e4f181d22d293f84fe128bed01f3430577c53b29f09ddd36e64a81a798075f089cbb3417dce73e55d8c411331df3d7a5f55ed8610669295046a42722103e155663422408c5959cfc55919b900313d29c2707495f484cb9c1b693d6e82634a11955fc1af59be7fa2d5a5da4dfaa9347569b556d6158a11b961b6bca57535b18c7bfcd5d78b334da5a2c03e8faa6f28c785d13feda879781649bff1dd3c1467e927bc8a3f46a365ef3137ced597ae835e518118baef227d37a4936e155d62a787366942ab8120b58f62b1de3beec8234cde44fa36820ef01c201a88235090fcb8c41ac3fde20d1a3e1f028ae7b9ef80e4df3a00f29fccc1ff7e9d2b2ca9dc2b87cff413f78df1f34f1a0968747a96c93e58939f0b6a0ccb7944576aded54fca5a70bea79764b4ec86cba7ed2048bef58e922718c3d6cad2cf9510f227669de53771e23ca923f5bd8fe12e15a0cf09f8043b07574ada912b175c5f7f0b77aa5b98fe5a7a32a6a490085003b1d981b710140f9949586540de697d948e04e14534be6e172833ff4aad6f88c2f969778758641f91419475aa4ac2b4fd9eed5484e4d1b94639452b12c84d35564f5c2969279a3cb75d98923e507e228217caba3d3b9f984aa947f14829d255e2dffd00ae7e0bad0adc6f8276adad0e278a996f8c5e55d06dffa39ec115540402cc2e19534912511d437213aa21c96ea70984af25ad0002da3471410cc661c08e2210c0a47ece56d96a9a895101fcd8772ec61b8264065b01a7e7c4cbba587943454d9cc1575e430c50f5d24613055ab6256d6fc9308976af2bc013a4d7ee5d0014c8ca00b9c3f8eb221443254f0e154d3c72c3acce3bbdba533958b77118b43394f0d1a8bddec900686e7abde6a47225be23b48a20ec6cb6aad3f1ee9710b7ff4d8dc1af89845595c547ab9550fa91e1a6f486d11070ccb43bdb3a1fd32e0a4e31d097cbdd5106d9ad66704d1cd1ca21e64dff69581dab9af12b9f3e34ebe5e02b0a2cdc5814444d11acd1fdf13de1007c6e496e4d15f034dca4cffbd1c030b19c267a59675165011e19c0fbae06488c6e13b13e11ae8905c1cbc7516814b05b8bb3773168b35f8507a30d1ef4685016cf2c8de061e3516c555bc2bf4db722dbc73fd5db22d12c8115d95b52c683885fa6323c974b1b108990c05ade94294a7738ea024e242e0a200ab79cab3070180994bfacae06b44c91a60eba4f03998e6105343279f165407f371b118b4b7818eb5d37d06517be52f44cc73f23c334ee30d225b485cb965517f31bf4a139c78db503efd8d12823dbe805bec626a4a7df2fdb6d04da611583f11edc4a2dd99488556bd347d2ddae2f19dc2731a9263ad350b7655155211572e9b8ebbb6eb25242ee0345d15f3eaf74145a004be7a652f6f2193374b92dbe5edb2e87a4031e773e7cfe092eb5238b2fcec7cf61e3948607c4ca4b3ac09903879f738bd1d73d3c0419d3f6e6d117ca3188a8f64c58ec488dd0128d33305510f11aabad5d904bb8fd5c89ce6e2547148145b8c13fb627e7917c6aeec595759effc2a978cf8952a551479bb9d12acd77dc88022fe4e22af765660211acd014aa8b30a0169b1766970f4d951b7350ad9089e23671fb466b186dd50853fae3dc36c0a48129051aae70c6987ccb993d17546cce7d93f839095659ee8364169d41ace370bc94220e142ed24ef11f03faf8bb0a7ac995c1bb602fa306fb413435137f1065e2f2cbab41b6c88b3c1b5c7790ff3282dfdcedfc2088d43df3e455902c3e172122b2f0748b379d7369fe37152901ba18acaeb1abda23bdc7228394740bce57d3631d75ee55be232aa655d220bf32d3ba0bc12112429b68b0b4e9e7448040ee67284fe655ec102c645de76ab9f9c2de30d49d4226e7d0b1608a14d55733b1b7c51c8531608072da1d4e54c9da402d1c421dd79c8af61235a052a1dcec27182ceab5f423fdb06dbce84fa3e2958eae1458f5cbf7e6c6fc5f14821a53d803d4db53ccb16229d78f68b42e060949a7ad732afe2ebf1b30e833c6da60ca7ba8c922f16eb37b565d3c71f5b1371e1082e34b83b095f9924706002d5ffaca52b4b01234a1794862c46ecfaf0d66670af8128c0a4ad3c1ef3c5c36c1e7b88aab6aa9a1945ecf183c530c08542399246c17cb1141d6889d6e5a249863a2ca0d0852d25b777c079ee348068d3b4a366bb1eb1e0b92de63accfb287bb9f8314673f6ed23eaf449762a1cea8433ac9f6baaf2ef226efde3d21b86f23185d9e19e35fbe3357d993a4f0c61e9be5c1c6ea720263c9c4f881de7b8a75a4ed1bc37b3f8ed2f61d7b6155a24804d9a8408f2cf1514f2cef336ec66bf2f8e2630610bb1b775070dfe40aec553cded527707e0234622c3c09ac15c66296acfd4ed15609e404425db3d6cab1609944bce2a3ae17d613029bd474dc7ece651771af26386723d3895f7b6dd9d5542b54c15925a93b8a725042be0b827d0de439d57cf5c288fee943334c9952cdfc1b4df306a4529b30b625a9875758ce97bb6640ac690cfb49cb134cf3faae656ee3cb879bb6b299cdf3d30050cbdb54ce543c50fc2a56e76bfb51fb1a09212dacdc52ef19021f811f986c667c0ffac61e3d5f76c7492515c21917523abe9943b5a3846d9c77c37033e88c9dd083bce54cd1618af8cdee91acce42ff6eaa45cc3dd7ae4a76f079320264148ad5b418b095bba999ddf27bec799fb25761df53e617d13c685f69eeac924de9aeb2d39c126c857db86bb7ba30814515394c7c11753c6ca665456556ddd7429ce2df45efb7eb3c3ab9b5657501fe682ac9b80588f8f2ad4362852fec4335588cdd240ce867a34a343fb01238402c1659d2f9dae163aecfb89b3f03af7a32bc4cee205466e4193d608e61438198315805750c7661d2194c9180046e4f46b13e92bedc7211cf4bbf3ceed1e08d1ba0a0197c156affedc38ef2fb93f9b16024a3b68936717d674ec6643bd224adf03f3600e2418226614b3faaf6f9d781768b2d17785c686beb38eda9c79a72c47d19e207061bc84d1d04b5568e0aa0cd14c7b8655af0dce0330a4a1cc3e5a13e233a8ee2fdea40da040a9112db682ba3a4da060292e1a43091d3e3fccb3a487ee2be2e6e4b96884cf34050473412bde9cd9121646272ad9012cf636f4c26a330f3f06e41e1cf7c6c89dec07d850606ca8a8933aa85356302c600ce6e4439ad1473fb35a78fdd31ac3fb43092a7bd29ac5e1f79e4807ea45817eef91f25f76d119677b4d6b11647b9e1edb6c8985c28a3016fadaaacb525645dae43f8e209516075f8b55708c5eb0268c882a25577527285ec7ee5dd5d212a1846ddb905d279586abf5a66070c50d9be38e91933cb4d1820fa0d408105e114f4dfe7843e763f326db2d5a327f2405ca108dd06ab42a00d6f095e55033186ddd67105d1f5ab38353c80ba1e25b6e0e7f4675e6854cac2f4b77658ee263473a8c11c0ef4f3735b35e0b2a80a9f0af39e34a992b558c4c92e1f4b789c70c44fe89bf27d83e45cc1a75a125780adff1097fc777f0c8dcb433925f17ddfac99b89e7b18987e21e193342af8239907fc7e5b41273d32457976ca1bcc078ca3e8c439568462e5240cc0037dff9614a3e5302d4cb4043f9895efb4912ecb5d8fd42c80cf779fc1d28315530c4332ce4784db2a937f66fc4ca90e716f8d446e4f960327eea094c09dd7bcc76878b67e89f0b8f2ab5fd2d00ec41ef3e95aac9ac0286e28b63339af25fcc38505ca88f9120a0e5f97bc64e3283d025d72e3fa3499f814e5fdba1a6d80a61fba4a85ea1df688832476918118b40aed93f152f79f0eaa94f0d80c9d3b0dbb61216cbfc9fc4da9cf9695b3de36ef24efe180481594a359f3319ec0f30edae869350c14eb130ef2ccbf20668877a3618c5e53cfcabf8e2a1bc2ae3ab85af04e175cb065bdab1660931399ec62f55a9542122cdb3a797976da50872d4aaf14d06cf2d989a14200b2dd0d07f880190a96798054c82b64a02361b9af500a0f24686f811ab6124d8dc7a0b48ce9a2c19d23374f32fb2915ca5bde031cfa179a797f48de1dc4e54519c349379248dfc53924ebdc8501a88bb5bc7961a86ab9b3d30eeb7c17fc21524b69be2bab5ab0cd7088e535c854c88c2f8982f958bf946af8169ebae7d43b94746622ae39a829c0164a63dd67d8412d1492472ca4a56f75fcc822fe9255c1a2a6f1b13d8a379a987178cc1ae6b242fd4e09c9f9d134486bcbd0851c850d31a381223fc3d06eaf1ce2c31d1a141ce060ec086286c41b3fc77e123e9ac46ea5f4ebcfcdc9a94164bb7e8b569af99e4ea66901866d44b81af70c5463ebdff4da3f1618289345d46811111a3da97829deb59b26a4511f3cfcfb8126b658d9c8433a8fbc55bf8706d607364a7e29a33cd6ebb3515d62ac10746e3887b4eb12c4503a6984a43b4625d0d6056c2e9754c2be9c37307f516df587020503bfa83dd944d658a1d471b08e9e511d3d75e14a8be37be119bece92108bc40c11b9521367aa4efe11fd9bfa3c8ffb144ca1958c2823d08641f144ea1b9938c2f8bf2b36a76fd519dd0a7a63681f03e3d07715aa830012f5b0ac4b76ca2f404b05c0ac3005c6ee9e9668f185add2de843a3201ea443c5c542c994e16cd2e048aebd00a770ef99d9e3592115d920f83fae1c0993939181887d7f43ce8fc66ffcb67aaf3a39728f29e7feef0b10b213e0bc98c12c4a39534f5062a99505378fdc9ef2f9f782c8bc6054aa0a6197aa4169834d7f72fa2de3a5b78262cdfbad4b4cd388cdf9fa5b4401a437d5a8c607cff45414ef276cd36b02d9fcbd4e35398438ae93d408d0fcdf086ce59e9374474034a5c62447fb17305c2491340d77f40ccec6821493c275fcad4f5a138","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
