<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a7585306feb8438e5437ffd950230a62c0190d934c6d4756e25cddbc2e963a7c29cf95740089152095290880912d2b5da77b346d75ae9073c712fd0f2c4ecd93b0fd13591407db33a7227358ebfc338d09f29264d59b4fdb849675f68e07324921ca2c786e23716b0b195dc778c3c4cbc7796477f6f9df0ce55e2d50468279ab7ed84aac6f8b44aa4bc1e03bfa6adb52dc2e3fbfafec72a29f4e14d1c8b5607dea2d6cc7f2e9e2e08f21cafd869a74f1d9ead340f091e051c3d455827cec92aa9cbe0f97ceb5910f8b8bc05e82f29c72a55b3f42d23d905890948f78a6ae5972a67dd4761a33e6300b83998bce9b1edabe2004bd047acf291ef2fde10a0b75019513924c78eb6ffc7a274ae5e349771dd4b8114c2e8cba66e1a1d9c03e4bd2fca1d1bef45add256f923a326dcaa5c8d4122bf8e192c0d1f15964bbae81f699e974a91b1e337f83da49bf21e7452dfb9d7f2123ea7ccacf4365da2c63cbade8ff796211f7ebf63ad8674ea8c3f3fd07453af4edfd100fb14bbe48e554a4520f658a1df574273b861ad6d2bb309aa40cbc7cedc9206f6753685804853adb132f41f73b2d81504ecb8400d3f827029b733a066cdcb8cf1a699a9411657331c841a404c3a66e42c201bed05477e9f9dc854ce7e169213aa6febdeac70d8583a400133246c6e6b79e92d9ab215998e76d555ca68a18a54707246ec9637cc446c9b571f66f45aa5d8a7df7afbdff4bfe9145afe3efd5fd16e619ca570db3407c7dd13e87baffd60474c1b9a538df34dc6abcdaea07b528e0cdfb933c1a287b13676a985124b619e9ff3fe8834bdcfcb753733c020e400c7a8cf80b30f1810f4f295b148463f37ef42ce66d93e3d9fc5886246832169bea681aab22bbe7a1843df60ad5d6c11c260c12867a33eed146ae6bb16a06d1cd9c3eac2a80a6447a18d4cbf5f4fefff91a9d0d2f5b28730d4cf9d3cecd1b80780b5ba5c13987ef5be25244c8d8cdbbe7557b135e08c6cf2ecde8f55753ceb71c3caf654eda221ac7f7e01632c9e2a372fa74e0e42be044df62eee66e8516e36fbcb05a647ca28bd85d34d0caac9a5bd743b48e4c08904b850599087ea9472722c1c3a8367070dabd6ae75f27d850348cefe79bfe002dfeff4d2fe4e91485e4e75e9790ade282543fa2d3c9d8db6ea4c2a3b173e11332f43007a8e198cb7c71a9d19c0ce503a250a733c6ca76dadf6b4a29208b8747b8beb27caca666d4e70892075fd435855a570f6131a1706f3b75e6f2d796e43faacdf8ceafe78a4c4a14755d8fc3e279f70f977fe7960506cb3f7de7ce7e685b8dc570e350e0bd4ae874d23f025572895ebf46f1efa10406021fe0f53a712b32040878d9e631db108d577ddc9a25695bd41185f3afa9362dcfe4a808dcba265eb48cc0ab687d730e38d626f39ac6775c97c358b6b99a798f4e6128f946cbb2eb52f1ff5f14b19db4a90f7e11a0b7abd9e89f314de4ea1a8724fe6d3c4867ca0000098c74727d7d23e1b37ebd8e5d89416335d28fc22822067c5e6d75518145a02a0beeac90613d38db05e80dbe210fd2ef5f7e9205dc7c3ba03faef32508cad8934fbcb5e361f84f59e4dbb4a46e78409410c6aba944684e37e0c391fa43c91cc7b65ee9b248778c4a01cb741973447c809588bbbdac7f6eab1ef239a6143211a28a6e0c2504301a60dc5ab3373c51be1cbea7c106b607e77ee3b65586e3585c428aaf976609439a242d8d4b91935ef285de0d0e4f017c6993d6f62451e5aac206f62f332d9a9ebfd9a0c72dfb32bf5e8fc54b0c8d1c44554704de6ce8c8232f4061828848f12e58ff1b41229b0dbe541fa8dd09e8fda341224f1f4a7dbe1bc9bfb38b39f5362b155db00ef04792d268279b8ec2c02e8b876efdd8202679d9bd9bc8dbf996b7b49e1cf5d49b90ad0041c3535d8fda4aa9e5190475a5e8c2cbcdf39ae6750081c86220c88350133ea6f624ad4522c17a59227a221870de88e7bf67b5befca557d93f744fe155a18d978c02f5dc559887892e8dab9e192cbda28622aa8156cb352e936ea9b71e0fefbb8465913863918f6ca81548b600dab9d2a530492f0cd80d7cc8ea94d58c3798b7996577c47d34a2c6d89ba59b3d30b20863ae0e81adc9bcf2c1542e41c81fb880fc1838485dd3bf5ee54948bee8d622e7ae38fcc3df59ae53168b7a57bf0fd788d4d4e6fe12c852e27e7414e34d32beb35eee8adca47fd50c413243e358a1cc75f792e6df931dff731d238792504d577d6cdf42399766a0f69fe6acbff1b3a030dc2decac609584e3e9b2649020d33676b81c33e9e8f4f322dbe15610570ae02afa833026c9b937555b834e332ec524c345ce70e1bd4375428eacb8bbea30a828d7b74f5af053060b7b7e9213f389eb1111035137d05e7daed844ffdc88d4dcc24394755b10759d58e924be007d48127f2490a3cb4a796e372fe95ac49f912aef547e0bd42838db94f44acf18144eb75b5176fe5cf572db59eb6956398f0ff4f4e21f69a10ae85564963b05c122aa095531ecb92ecc19644afdfe797d282a77e1c52c398a28033e70dfdcf498ad6e6ad9ff5601a237810f3478950f207217a0dc57137454d4e64df462792aff27edab010d2c3a6da2092821273f3c7917aff8df09eba6ec4d36c1a0f7364b34dbd9a588d3957f7adb06baeb85c0c18d125a97b7e6b017b9c240c1d1dff5513f197d8805382bf7b968727003b2a118c936f07a26f1a56f31997493cf5d66da955f66c328cef680f1692cc17cae30b19452f24e24d3780db6f4d48c3c6579d1ffe99d6b7501fa0541e65e58c0cddfa6c32c5b9741de19fc8af3a2d2396f5dea5fd9186541f1b7f971f50e18ae35a07a980af8d06e3412779127378f45e14899a2ff8103bef465e187819253f29372cca23cec8df58e4088c63574adee369490932e3f64b56022aad6f493906cc6f4aa5cb8641c5ccd8a457ca64295b25e4ee5202056eb4731baa1870c14a32a31d7844c1e669e46efbd384ff6c9070846db9b427c65a08f701d6ca8933e4326db44ee10537f9cd37a994c27666065a2a5ba1b6163a0d4e6dc5e5c64e4903f7d45df5db12a2eeba25ce72e53c5a8407eea409b33ebc8233bdf157b19fda0657c84c533cd9105b8cc0ffbdd97363fc6ddb1bfd31d7a69dfee6cf3006785f6266c54279962aa77ca78a568b67083ab17b7fbcd95424cd20eafcf857b6fe2baa4d556cd57c3930610a30d14bf4d583ba7102182082a0114292c3efaf7fa76f50636f6092757bf12b11c5375e780bb5a112ccf09067d71dd014ff59daef285a585bb6f743a3e1e28010429ae16894f42de5f5441e71b7e4d1c27a8df8b1ccb13fc3f590e017602b239ab84c835392c3656e8c9156fa210879edae6e427e04f27cba15d729c3f9ef9521843920a7dfcae77e4738be2e36d851de74cd275b964e8b5860418e9b5020e34d03b5093d8a521df6f09fd13fe7e3b0b9be9825f690805cba07cd4e298eb52ee9ea0a6d36b83cf3daa9680bab9c546d1c3abdcb2aefd5cd6e20d8320991f22ada1292e8dae156e08106587fa54d268be2e3c5b396fc778890de9074951a5045f7c09b4f12209560ec68a6f315f97c802c55f006d19ea4829d2ed67cefba54e85a74b88ca8307f5062b4c139d9090694ef47d0487980bac80f4e5e47c527626a4cd03a2fb7fea373cd8b8c339430769be1d42c43750446a351e55236482d796c0d558d763314ca21c51a15ddcdb3b1e96708e8071aded0dc671e0f9e18a5a663afcd576b95268255fe67851ae1566a76393eb63bca22c1e32de4dea89c035fa4fa5d3dc7789ab82fa0298ef13eefb68ca4e25fe71ac84f59b1e1bddf408af9b1faada0e3d19529ce8375d29221f894c7b4c049550fa4b72c19ef081ea1db6db729c56fc4b1f583dc0e522b19a17ecbdaec4798ebd9b2528938b8100cab1ef7bcdede83e0fc11ef8c7e73d335689c82fecef28a0bc403ea3f17f8b131dd0e9d8a3b4d76e5faf287cb10ed394ceda5c082dd3f7d3aeabb04bafcf481b7d0abb5abaccf3a78fac6629d69d60ef49e6f774ec771ff4a91b94c6d14de6f1ee1e9b01c9733df47076d926bd978a3797adfba5e9e771aee62d887b44820b4919dd8ff8ad4a1ca047b63ba5c5fa05e5634451f6d726ad692eddec02be14896a4c9ba7fe2e967b41914a4ec8c4bbcc4f0eb1282d74c3cc256a1b6000354d689ba34090bee71afe53f04a024245549d4d78f117389117ef3b4eb18e36d36b77ba5faa482f7baee2f2f7d8177675dc8db1a5fd063bbf216d496cf8c29ede2cfb010fee84576c761dfcde83b45ea68b993569df917710de24ed6cd4b70cff0da3e80f4440df9aebca33358086d31712ab5128a697f9a7b6fb697b0004e369579c42104bec20bebd50375bbfd8e6846e3659dc622e560f26724953394f9ea468f7af6623f2deeee982cb9190577451617c1b6306eaa814cfa96f0ad2bbece4089548aedc41e94eaf972940df08b7cb2fc87e3c38d9af14f133bd26cf5d2310b913d58ffa40feaf7b9e1a3483af2f3db0df0e6669ac1da8b60f9837fb982a2eac285885bec4e5e5cd08a8c1980147771943722f0e9fdb15b009c92a8c29ab16beedbba24c4ddc60a46783640b9840196fa42aba1860ffed597efd9fcfc707abdb44096aef2f6f293470a13cece31777c5b4828baef5fba6930b64935c38c1d0dbf633919dadfa6423ad85322485309a37f82c56954dc2f69dadfb77d3ee2def5cacce748e2f4e77447f53ba597abc922263bff351fca173b27bf2deca4411ff905283cf5200801f10a88aba041ce4c81322c3d5e0e81e44e36e77e4366586a57bf610f90f3d04821a401480f70aa577918b174ae35ab01a0d6bcdabc045570e95b3e693c802521ce2c42787931d9a342b22eb85f7b39da85eae72d1f352d7c64c91744a0ecc7ab13110223b12cd60516b39e3fa2dc1a3453e0bb1f6a6730e09b21ae1dca1add6d990e0d2cd783f6e28bf3d883fb4246b810beb264568ac55d17e5d0f187a8389f5a5d1537f567a062fa0e7c0e64c0a74348292215db591e9eec5aea45a677e537df717f8ae96d066546c0f558ac3cfd1cac0345501421530b142e918db3d1b1311d1c61b48d8b11c17ab4ddaec289441f78f13bec8e7951d7f1b8f950b6601bcaed05f2b88f6e2972c15594acfabb153e41aa33915b7fabd44e810a7762bbb61777afb0a341e46416800172d34f6e1ba7bc4e7cff24cb4600136dcc6e01000dc9efd6a91324357e3910d884b2c295eff91c47721e77652a6f512bcfb06fc4df9dca4ab2285e5dda104c9c908b00c464a17f64d9ae8c4310dfd9cf3d289d192393884bb74bb9c30a67517d6fed50170d6ac4dced9645850a610596fc97e03d5273afa3ee38ae81e246c4f23c849d5da0db1576b302fe5a565b48a651fc1b5a834fad98c1e7f6430fd4d86eb704225dbbc769393b1ee6b4e67379c4ff1128e50d973dd1385c0c717e73337135298c82d730bebf538d90d5e3ccbdf8b4e6a1c02828e817ccd941950ed8feae212362eab54a271580441c29cb03263f0de928eb96500172ebea66c424878a034e89466d6780347d121e2fa54a7dd5b8e477379b2f46128182c0616939e43e7e2c190073fb714afa585f3cb8ca90ae5377b61461c0d392c472f55e6a77fec6b6706779c6684081ab62e03ed418a35feaa1464d97e5d8062fad8d2fe5aa5a0641c82808acc0fa4b4b5e63b44fbe6b0a67def30ebe5c8a422bffc649f217969085f7724341747622a4c309c3acd7d04254448402272608151bb97b8e51d40475fe1ed0998f49807f0bd76eb52537cc30b590e676fb12a4781b472fe19605e6fd016dba3b760856f26dcf36066e57746d746d01c48171730444dbe4fa6d792d13377f6074d5fe67f7987d8d018f7675223116247e927eafc527c9afef5f3a557b87a3450eb3f9adae1fb6be473902dd8166ef1d58654cc8c73bb9042bcf42c7d2a28d560b5b1508ecc35c10dbb65f0cb2374c5521ef2d64aec037004460964f1262736179c053233d3fe54dc6d0af0b920e237581dd4dadd530cee4c9fd5ee6e16eb8bb06a6eb0639e416c8182dd495db54f05edc338582a4536829369ec0f1fdf7ee99046db0941e96138e72a5a6011f3be7e08b8f457a60a3325b358cf3b59f457e5722975698c414d1de96d130b8d93947c0ecc21bba69e27c6fe54444487b82563ec034bccef0855fb7fbaef65ec51b6623921c11717570be2214fabb9b12a1b77d353f5e69488b3061c62bcfd0c093eda3645528b7c7050d55e222653f43779b3fa5fd171aa4f05203aa83fe92b6db8892acd5235d9eb6d6dae5840d4192891e9a47a53f9af6a93f17a8e9effa6634d97824ae898caf6d8d83cc2aa27d94f4697e24ed8ff6239460b6436d03fb4c89d15dd5a92740988fce46d16304323d1799db372a1c98f63ac4b3a341ab0448f0583553bfd97692b1f67afa1c034d52874b541bdaabedd7e2a986e7ce20f81c4205f78a145ef4a3fd3e42600c235a0190633e4b30727f7bf9ae65289815c223d7b64803f470b95f937eaf30aaa906687d540f0ffe8785b7ce080a2efbe29045aed948351583d2259036f191edfe19235d1718ffab2e291f22d1e34be25e218cd12399339c7837dea48ea01318067b4fd3752fe769e148c7123ba09536424b0c6c29782abc23a64b3f211b1b46c527b0496e6f637b15aa7fe673a5fbdf93be31a2bd58df3f47b336213a674a00ab9f3ce7e451d0b5263e506994b15aaa996b63584ccab46cb0baed5a92c21a21197271061a244f8091b5b45e00393ac8d5046d7dc7b6490f217d9deb15d603bbfbbd54745da945d123ebf6e64f3a0eb284f583dc641b101bcd5609597a7e86c22e083cbb7fbe97f57462e945cdc9e78f9d4c085fe64f178bb1f5814603fb8eb181f506ebba3528de976e4acde6549eae57aac64c1b8079f0c70322f5c206533266a85b52efa54b6e28dd0b07f6e560d5979dc05fc46ec680f2d856943ea962f044c52ea54808f50afc475ae69fa2874a9836c5622276dfbc863e164953318b4e2b5433ff6db3597f3ed548d0e8671f4c5c8553bf6cc1c8ce028516147346c48136fbb3087dc868df877fb91c2915cfc501d278c59c492d7ebcb835fe6a405f627d4ad7e747c53036f8bff8fbf625aabca2895c1c68649bfffb1a6784c41d33242b6cd3a94023c9afadd8ad01ce4709d6b5218fd12eb6a5abe931b6c1d42efdee4a64668d8e7bf7d1dc6bf2ca0c4fd7d6a71a26e7ae85ec6ab9086d52d3073b2e00de18a496b7e4bb42bb1d55f1d97bc8c365f3383cd6740211166b7c7ee2c2c8e776ecf1066c59e671fc9122a9533866371a09b14d816b8e766e7535647469d24a2af47936ba3e6b18ff346a8355cb180190cdc4e0021cca0da5eb764516a9bd497ab384b56f0c9233b31b6ea3f66606f0d71b93298850eae8c46046f43403542744fa983e91ce4f06cefc521cd75bd03a042a585baa3b318ffc5df2f4dc9509622abece25d0532d9ccbb531fc398775cc03a25e066265d6e4cd6155d46cadb7788c615ec265216e8d2d8ea8d5eb52ae607f073f5d0aba01344758bd45ace82cce6b17f5e767404bb14401e03c99d438827f70b15f3b62f03ee6575bf8111be8967c68c1d4097d52285acb823dfa0f481b998663a1798d7cb7b0cfabedfe417766cabfe46082b2decd50d362f701830dabc0b2f5162f28900312012fb07d1df2ba4ac4f34563133cd1985bdc9bb90159de74629857891c3095b4fe84048e3c83a5812dec70a04268673b3a7b7a607662d5a6e5e8bb807ad2040ee93555ed3593161bc05c0227b4558ab8fca5919e34f088ce25848798b4024ef6b5a037c9a20393c13cb8c87e4b2993511f61a89a61ee25a5e456543510101408fc301bcf65dd720a9e36ab881a3602ded026c54e99f323972eabb89fa076bd49b90478454740f5d41900ed956ea5dce09ee447c11f489119f609d89a0b546414dd471e6cdf5271f6530e1d7c4ef9a1b271de73c9670773313e468f0e872190a3472814f3ba2a6081b8c55b1c0620abd798ea7efbc7702b0850e5ecbea8761008a4ca1b381ba45795159679d2f9f63b4e72a46d7e236daf73c3739621cb1476e19fe326d70113141859ca67add60b06d344b7555ea732967cfbd287870f97f9d87f6c337acd11c896ea5cf7886cd40d80dd8d2242e7ff45600604ca7351e9f8d3267a186df493cf77d5abe412ab47b0fdcc2d38c2a134987cc5dbe416d1b8fd5d728d7d4916074c15ad99c64773a7c050398287f68e9337a7e471cf6f4b1b1f6bb6278af18072209d7a2b1640477d9a0331c049b0107cd0ee0e4a275b1b028289a99e45ad7e62f54612b03dd1410b8fe58d0972c9b2a9540e06ee0cdf50e69469f114f9413fe779606ab724a57fa863e7725888b531f84f43922176b815065e11a7862551945cbd1eec89c3781ba4ec0d802daa0390fee14c2dd66e2a61dc2615bffb1d66f6909821179f032315418f43fc1b7afc8c0ac0098ecd12279309ba44d8f4bfd0c5444c8fe62c706539ab60962d8c2ff1df04ffcdefbd742eb31f85006e25abf62bcef182f837674a79d619213504511d02a48e84ef69fe5aa79419d9cbb93339c0f8fd6ae3389378a166210cc8beaa76253251f224dc6e2fc504cb46e336237b4ea3a0ff1348731c00a41bb9b2ee4516b33b9845830880f3acee76b456e8aba2fffeae6995e2b9218c8c6d77114c638d43cbeb69d20d91cb27e9294221f988df4e6ff148d68dffd7227f8937edbf2a479ed2153c412c229177240bc8a45ce8c120505fde164a634c87410debe01f97f924f76a8c294a3649b0735075ea3dc1086f7639376c67a5f8c292cb1614235aef5c5d0145dafa8acd8f4a5bb1129688f67ac356419efdb7f3a9f2c6f3c18c12003d332fd83c68e1abe23ffd6501009b517a55ba62fac18e21ad87775291dcd2a3a78772afcafd2b7714b587b5a1afdfbeec21ae57c703ce1539a76d522aa880b3cda6e0d6d063b1fd8bab48ef9d488ee80acdd604aac0d3c05f89555f46643486801dcb3b4aadd012cc0d58d6965808717f3666cb262f903691df40b6e49f0f8f6c9ef73eadfde3f4e63eb05c8e328cdcaf0a6bc257cb8890f796a8e3bc6b476a870af780368583cf4dc3dea2a7b4405961b770341953933bef0319c4a28adc5729a256f062ed876c9162e4395213451e76d6329b56dc1cff7a3a578267095529477bb32ef220705b51749e6e47194d48bd5affff48e85fae9936e9cde40dc5bd677f4742a69412ddebac47bfb564d9bba9f5f0741a9f1281b4e6badd708129171ee079d6caecc296e4d44f76c258ba8ced3193c6e09b2a860833c8e2cf052678432bb06da2fcdd34d530151aff8255a00ba0b8c501edc56a56ebfb3d9794175fc379be59570377a9d44c2ea9eaaf31c2bc507fcdf007d90d838d38d779e800fc6609f346b6f8711b19098854c99e18cb1009b07b5e5699e50415f13155020e6b5a0ab5260eec78a77b759d007461e648eac39625c63b0f3e6cf38cc4dd40eb2538c53cfd27d12fb891d4a4e3b048f1e9693a56f397112de8df942048d5dd68ceac75797a881b3328016f75914671a8bb677d6456edb8b9b21826129b523beff03cbb483c040a2fc3c853d3ac8e895eb0147c68d47cb9c94792c286d99b68bb27945b0fd996d269f367eecacd1cc0907391493e6656e270a9ca9a1fbbf3ff60cb30c5875ac376fce81ceec2977f99b120dacc58b328237066dbc887dcb5d32afea5c67721af3907732fd67918a3bdbfd545014318bb8884d237b3df5d4b12df9412c1d41d6255b709d74d0a8e8206ab985e678e2455a58180074e4535ad9fb82bbbba98e9adc912721e963f3b17efe7ea51bc3c1b6a55b6cc12667b446fea0a44f971559db6a30d7eed68834ade5b1c754c3e1239ad5fbf7a475a155aae39532c89c8f8c993f22fe6642c71dc8aeedad98c71c4b12abb97656dc409ca439b055c041fcbdfab5cddfaf2fe7c837fc2ed306940728e9c9f77a58b7f3fe9ba0347c96344989aa7054a93208420227e157526033c5dd75b9c1325d2842590f15967a3211d35b82f49580ced7c739fcbd9e42ab2a8250f59038196ae563380e414dc69c060f7c101b1da947cdb261fdfb475072517dedede349b232ee9f83c2bbd5606d3fcbc89187be03869a2380929bd5dd627a9f2eeb6c86136a0b3b6e9651a390ed102e8f9718d326ebf22069d8e36df3462b7d2ad376d41581d2f034cb058a873881ed4fedf5c2ffddbeff2f959441050f538b4f9d523d734db3158a3c8b6bfc557ec5859cfe27826f43d600aced1f361f84037584b4412c8c532ce8d0bf0ce51f991647b52054e9e8cfb1868257b5d25779d5ddafd768602883e9a5f47520b42696e154da73ed03169b8437d79f9daa948d2d9968298243e572ce0e3f09e7556616b93d7dbbb118119d8dd37ffcff36f3dee4d907621d727222d129a02d305889b4950c288f10721bd2b6368837834aaabd16c77176e0de94491000196f190bb1c4a0ddf42663baa125cd62e650cde7b427ff8ec3fadf66de053e45f3a7042b82fef70aeef653ecb3ec6e6c803e8e1a619375062394bc1d6f67836e38ad3583c3564477b520ca9228e289a7fc275bc9649c17ba0d4c8fcdfe456f20d97da3b15a20250b5b3e496a9467d3d16f82e878904ed64137fda633f58bdf3fd30d6b803e6d6804c47daea10be3faaa67bb800ca2b8fce30fc43f99246528d615f108f0ffabaa2c6bffc35d83c747f59a97fee746fe6fbb0587c93e1cd676b9df03afc7546e325492ab296175378254176e83c29e58dc038559fa57ffc2f5bc0f9b5918653d757a121c67ae6fe9b04a6fb58fa752cfd0abd9026005d438f0a7aeb5e2f561e727a90a19478d613426e66449b972134ebad77cbb47797f9d76f2f9aef36797de2b20200f9061cf1de3c8d29ca0f1acf46b505c066ca856f7cf7dfc85d1d5ceac19ba60997b9a892cedeb77172375c03dfc6a4eabf67dea7160e1993fb38e6f24e7d9c5a4cf22ff532b27f0f23982dd33ed202c2c610d0d7584513cde26e629009418e0bc25458ed651b400499e5153d83cfa39d19bbe1fa411374e8187d28a4defcfe947d736b954b2416433b78ea2eed5a90e208259269bf302163242d6b5f307021344a94e2c7ad3fe57b7852430e3a37bb7ca6aa7f45c16d749048d0c21f350fe19333bb37169bc800baf5783b1f03e2b4618be1afe571d88587bf253a937a2ad7d1643b0f2b8c9ffb3d6816f772df8a64476cca17d0bf374a10c811bee842ca12714694e4329b7c6c7a97cbed6d16661ffcb09fb56b5c81797dc217ec084b32766127ddeac102d3ec1be31cdcefd31cbeb001757dff857802d108eb7897b1364b2c30e6ea07a5cdb84f0fab2b65d08ab048bc80f14b2eb6158626ad1093a67a1fc55fa13caf57763081816d4c2820111db5d1c96d66e66ad734c61639cb2072037ec9b5a5aaafafe5e758c604149e35280e21d9a26a6790ffa55eded57d2d8393c1504261ea80b6bc7cae0a6b822f66fe692c0c5599a25dd3293c01cc1fc6aeb9fe98d9adbf448bd531d68aa116f42a6664744b88486bef8ad1decd26aa36f8420ee93dcd4d79204e4447c778f80f0ba6020d15e245fac3e64dc2c63c65456a4997d75e586beed597df95b0886748ab49632d553c908fd042831469acbeae578d69c77ae00655e2c1732e39ebce7bbc5c3c7b20e247ae7c4640da83b586b7639d1b0b3b14f44c0b3383137959e7c8402e5738f9414ec37e824d30a14d2113139c7ab94bfbac0ad895e34bdcdc87a29804899c46a264907e3b716458067bbc57a54be845e280a7a1961d5048994f3006996910a21204e19c8c1f6c188f5ceba4b7ca96d97aa515f3ed7d1ebd3dee24eeb28fb0f1ebfa8db220528df6df10219f94dd876a114a6c9efa4a5b09e62d386f78d92e2500f5fc25cfc00ad97c8acdbf1e73b9ddc3b4178c34a59d2ef57f976d046312a7e57ab41f2015dfcddae3fa3864b49b0f4dad801859fa16a75889b4e63ca11b191a474e3a5345222008048c7a42fa2b4989294dd8eef6f96f426e688282dc3eb476bae2bff90c486330aba3e14a35cde1b1bac589ae6f0fbc49dc63d39533b63bf6f99020bcee1af8debe610460f751ec6a3bbe1d2e7ba43e9528031229a3a72e8c11744ddd13f3671552dd198e46682cc9f09a87da2af08bff6909b0e4964cc47fc8be4b939eb53b1c6569e63742fd419c683e7744d199ec87bf9f1fd66e9d07ef842c0e49ace883954ebaa40435008e8eef96dd203d46a7b126b7f95857ca84d3d64c351b1f71cb88d3ab0300ea112299f0f43302246f9294248cbecdd53abb1485ed032a7fcbe1ed0224949275b8ac4d66476962f5a205c6953bd59bc1b2015221c68f772e9af3dcfdec5e48195881a4a08ce2bd50d0394c75553fa002a4c0c859cc105fb0dae697f774598075e5","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
