<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c81e8e47250011314f630a541b2feb41093f732100ee1663fc7902e1a070ef8196f833977ba86d730b774efb9d8702e1e57917655bce35993c4ef7c288371bd404b2ef6c8f1749d214c41c9875f4d63f01fd580db3abf3026b9bd663c25e532848890ef09a2f0f94bdf817bb5690c376e524439390b4f1b66fff992c8d37c2da5e7fe0f35444e6f433bc146cf671e626c016569fd6e4ced79a359b7a468b7690b3eb1c359d9d9c55dbfbb976b8fc8f84f958f775ac4633bd6aaf4678d6ca4e2d9aff0ef34cfe7d1fa63c8aee0a9725200a7b171b25f93667771b4d4946f5ad5a9af657df789f7ecadaf8e3814aede3830b37972763c072fd79f92459d2cdc5748f2090b5df7ee78ec0126e0092ebba7a4f6c67f2d8877e1b1d6c0df50d4a151c8e767d1fd672282497ea26f31b12c2b1457298f06d473520fd860cd930acf2bc1bb3fbebcd5669e8739a010a1bda562865e4abb7d7fc290b92a05bace310bce39e2281d294f4659ba483efa85b9a41b66f773282e4e0b4d3f07ae9361ebcd1654725958b5a6edc67b88a07b0da83ce86f34c018aaf4e35bfaaa5488e9223360ca3f34ca28d80434d7b7f04a1d5199461dab3649201925043d5007d6a5272abc6b3ba6a758a5c35cc4531a2698eeefe007a539c67f2abd58cde1b9dce93ce6cdb3b47e0c91ff0b6380da98a906adb45ef9c0f7cd043b78e3eb2390bf06eacb6d67ed9693f2ba7c729c78e68b7551df85efa921dec0994766710de145103af2b5a3998dd55a98ab15ac6145ae12151d1e919d5c7058e5ac3f93fec0250948d27750b134c8f2313b3887518d445125141fe5f04383b4617690c4cb2dc86ac045060489d71d43c2d97ebc7ed26fded55d6734c50471fd37c21c142dcd96e356a5c2eb46c6cc62fae48ad056624a886d408e663fb944ee828c09c0e79c798b02ad1e794c86dd4fb492685e55d1cebb5dd6b32e3a495c794cb742cf9296384f1b4b1f332194ff780ab26f2c8ba78e4b4e7f5c769e960d9eb5b39b8d2967f641303f5176cd4708a4e5a45f9243d609df60e9a9875e0c5dc4825f26b51a2afeb8e946ef2cc56fc0870962a31e48af5f3f1da9b192c2bb9b11d71a2c67fb78988acd20ea87898889ba395bb0f3fdf37120fdde6468c565e0c9373b1bd9566a025a82daa5b62a864e7936d41188a3a91ce8059db9d58e4c516e2c6347c1117da5d6ae167885e1cbb10224a62a07d4ce41ee4a3e07f9156af83a4712ca8924605fb2df4b084eceed960d26904a035f3e54f1b7820be6d56bb307253151797c4051e7853b4028882136f59151c2cfd8bb0c3f6d89a0396233ce34b03374bd9894c54ebe6aca70874984b14a94f1e9628757fb0ea1efcbd7ac1738f8e7cb34d9750dd3f85c5f2e15c9e73eee7a4790c1beb393fd7a228554720594d3471c2e8a32f6c64422e7079ede41c8f76c9ce31aa32c7c56dd285a34b62a86ccbb3553155f9ef90edb283308b1949609730bb712ef1675a7000f17698a89fb1eb4cbac451d869609c54040634c9ab94b987bb7777752d5e44cca84b51c9bf2edf2022eebce07f2ae1be6f0ddf074c26d88780e1df946792dec70c5d88d1d9e64091faf8684557036fe89bddbd1ca1cf6d6b96c105e81615e0434f982e2b1f20e3d5fdb1bfdfc91d99bde7f118341713c8b21adeeae900e280f5fd260de959533943a0fd77f6b96f326b5dee15fd5840c141e9d7e642b621b6c5769b3bc8d014e38080262fa8bebaf04fae3e7b76f173a8578c274a963b98390df06e990acb95f81549f9c38a9d162041b41027fc080af9c95acbe91b84a4e3f06270a7cce6c2b0fea25ee2b74dd8451f2cca4dfd85b633772046f014beb45db70978c879874725731ee2d82075671f49f4eb09c7da02551e651a6a4cd62dcb7f912c922645d365de5f7abf021dec7c56f68b59d7158a26370232c0bafb436c2cfdbcc3113288daf2ba7c79f815dd5708796aa06cca839105d91b3563411562436fde74dc1ca1c6998920ad3d95d9fdaa1ab99be442232ac4e66575ae2636eabe0d58c2613ed9e97e1af3098588c7080cd1b0920c553f9e8a96f633c59e57e8726657c882319801dce9364787de5e52bd715d7d63f87d84d641bafa5c491634e1c43a8bdb901c15b28204fa7b37aaeed73cd9192a427cacfcc6c3611d40b0d78e3303fe77273bcbf05e3904b285dc8729711cae8a911a7d311fbdf9800fefb22e558ab7d52e1d7da375716b3217cfc3459bad03f108582de2fb9cbdf3c1d9b6570faac6f87aab76ad7951d40b3fbba1732631952c5d44230ae99c84a189f14a850630736915b391c7be7346d066ce39d674d0f77b8bb1aad259fa8837ebce40788d515accd909fbaa17229481151b1669f80a1ddf513e6a16616a40592845872bb0661518b272d886b315921fa858b3f28fbcf06aa24590c0cb456315aebad814defe3bdc7385992cdad957f2b18a0248ab38d59e1001d4755dfb2402bee994bdae2f136ca7cfdab4d11a9b6d23e02cea8424fcf81a3a79928bf77f8512373916e41ca90aaf33e1d93bc9f9d5f532e1ee41463680923237b245cde2c58a87cb227e797844435cdb85e85a4fc46cae2a0e9053ed8d89a6880be3709a18505ba1e89d2cfbbcf8e853defa01943a0fc56c14319b40ba210271eb0412f79224ce04b08c5b37156a355e86963f9a0bfdfaad55b0a37a6a63a017dc18edeef88b31a4c61a036958a0fe490a27dc3d7cac8f96976fc77f4758b08cdf1c2a3293f158f9e4a2ba226071f0269e4ad01fe2af4dd18a72fbd40a5a6cc1eb494f4dec61d7ce960e7ba403a55a1c8677c1448ab77e327e4304457a5e9e77987781eb997d27cc982c0bd8467c046ea2df978db0d777f5490b47e04bb180e77d20788def99be6969da62e834c68bdd6f8f4ef2915e093d414b483e735a2f8af9d4692195bbcb0bd91c8b87d68b9e22f4464f4cbe74eb2f8f407e5a4bee604114eba383eb991a10868fd19d512101523185d593d3c59c0d728a65bc83416c17dcc054c625a0c055aca421ca8adc851d8e060fb4aa63d5d618693dfd5e29f8395639a390f956f15e29b9dd50a30d37cd544e12f316bb293a3c3eaf07c11c1a9e4e59605fb14ce77c67926d3aa3572e119deda26f2a89481b130c887e228c1515a93dd35534439633962c8147083ff765d76216c212b10c5ef8f340a6444312260afa2112eb7b7fd0481362cdb667e0cc7f4f5ece49d3ff2618a40fc34cfab5ed918b146a9fca559d73ca6bb6d2472cb70121604bffe26df116f8e1a9747b2951408881300de1234cc0e3c5fbc6b7652066d3a0a91ee7a2dedf467fee11c4470f79d5c98d4290d595b8327198d55649390a6b9c9990d0af224c8d7c09fef18177768bb9cca721835cea9285a312f6a729620a7f09db8c59dd2763557347e1291e87401f2a04bd9f6558372a145d0706485b6b52b5ca3fb4853f0f01dc629c271a4dc8460e30456488c90386f3fdd0ba5306ec74ed886900ec2bf000f38d8f6ef7cc1b706de36556e708d8cca1151262dc76eb4219aa5a3da0626eac2383ea36130e071a47c217e9e3a1822aee374febb7d815b29d6e0fedecef0f31a478564f8d544b8f08b23372d068aa031f3d388487fedcf570e3b3c2c0f9662c349069cfb32088aa54aec4a91e3959d77f3ba50bf26c4404e2ec806b4533b102c211ba89b54b81366c35808cd66671d11ac86472b721990b27b8452dec29f78bc0accea0897897e4e4706189bbe63e269e18104c795e8877c696592c04290d1a5179b29cfd875c50d0b1e3001ff057baaad746e4814b436b9cc727804944a0c61c081f245ab9e135728d4d9d306b4e6f50df73e941a8c17fb5b3ab039ee82807e2bf0daa6599a8873b1cea6b725b7b88ed35bba66865c6a61ba319059ddd8bd32415b73229609041a17b8c62c5cff2d371cd448631c89bfba5427339f199d84051888b35f7e9e4e586b2f9e1e6fbb4b44b8adbe774e572d98495442b2435d6437e7cce9cc2eb0a242516d1608c5408c8b0f42eecede034eb38f3096a5c0f231d7c7436e3fa64dfb86eb8231c29bc3c8687b8f8dd58c28074a3731891bc144365e806b9f995c151dacdc3d3374c2e9a05cdc4f8b16da1fa6a38688965e1b6b9988daad6cd9f8c4c456b26534619e8aa6d6a9a10fd5a1a84312ddb12f45207fa6b7165b31a85fcdd5e4804f32ef3e8843c512b4feddad5aa1641e8121e570556d7532c28ee2c6102beb24d3c7e5eafbf3200e5ce5e30d66c9ff423dc7bcbe12209903c3115e25d6480cb75d0fe7dcde6928e116620abe213c32773ea42433d49addb52660aa5a3102a990477603bb1b2e614b84181e335b35f2227ebe4468a77bdc49202058f1d18d6c80dface2e378daeb4d7e6455c0568ddeb0c8cbd0bbe35e75d7d72978e4f657f8ff9d9e049ffb1bf1362f0218920f035f7b9b70a8459403723b5ac8649cf84694c212dfcc2218d6d9042f78c1bbe3cdb322ed930b9415948d20b60e4f2d71547e2d96e4dfd58db2ada70b937efd0b94e1e315d241a5c96c5911e08b5841118a64dea6b796d8b613a8963ea90a0e23a9bd82a3e63bdfba5c72e0f9b793dc815d7678188b648e9d71636f15ef96c50f8e491c65f0bbf37ef5137ad4258d551501570b64e50c286f8c0058f0e911fe2e16c2eb079b6e135a9b968bca6c1244c774e5942ef57cd16a2d2010b8b0a4533fcc994649365c73ec2d804fbc560fb5b408d5a76f108c0b60c1500a932574b7f4cb87c4b2b64ad4f77ffa6f388eb793b5c2f2e7f2368746d4bf1d9779e3e10d256d4b40ffb4d518d27a012dd4c85acfc0c4e9f7e992d3fecc105f112404b7374af7223be46c73fddf92cd5fdb6597b2eecaee6ff7a5125c8127f585eff0212c41f980630cb5ae54dcfacb0b2666b620a52ca3b5576e4d3b994a74fe20acda001744ae58649fd2b2fe5baac5a4d0ab2c5a8a4e983b70b881937ea1bbad38b5d0cda52995a1914bb49c5d2be422c6430c711642daffa2358bb3879a00f0f84a4e37c2597af75846664c32efe8bcb4bad9ead10a6b61a5fa93b258598cc93f143ceadac6c52e87b004929976e246cff1b1db29074ccb081f6ca36c8eec909e727d33ae41cfd7d2cbec92ba653d233e2971f42a3488a04ac8fa59bd87c9df15eab63c889be82f863baaa5b91ee5e95adbb2ccaf875667daf5ee49466eb1358c2c56364c455a12eff7e88693f8a576f5ea7d6be57cce3665f3145c2b7c4c1cc717c393967d10834caa11959b39c8f4abdb4ef6446ff7e36905945de12dfadcbdcf75f659d587485b228406a9e1da29bd3e0d3fc9b124e82888333520a13ebcfb5983d7c9483fd526b71359641f062dd0bb3de0e12c9afc6640761d70b8d731c49f5eaa668f7096efb1389d94366def71fa7e9a9f5c533e8c1abd23e40e543acb4519e69743477fc404c2ad5af9064904a2c9ff80b867ac1e3ef78d20deebf48504b8c15933e8d0a9ac3024d842556b49a94cbc9b253ec077c04286de5dcccf8c1ef6a7358cc908cc515e64fb658e79c44a926649b14b03ce424ae402b9d46089d585623adf586d1ab23a0c64e31527bc8eda0180c5b388efc2782368afe7e4d3761352d2aaf06b0713f43f17bd83f368c57aa4031103f55ca660f37dc2dee483f36925114c604deb6eeb68ab738f6bbfbd313f24ea3e071b1278f37ff552b4113c197f212b18e8b5edd3f3d7a0478fd725a8f81d9828f5deb0f16d4d977ea344d709527cd2e938bf32eb60a732119803f9b5246988d3e9296097fe0ef889ffda6d37fe89509195dc59dd28beefa44dc8ce8a219d6781141e7d683d4512892c4ad241606d8a0dbfaff61425153479eacc94797ffed44bfe5ce9e2641aba425bb594ca30c00b7bb72613532f38da506c55ef4d16d2f46693b9d69c02d439a9b62eec198a8f16b415599b46ee4fae2e270ba5f8d8a62cab7c32aa9aab1bd61dbefa752a9a2d160345a6a38ca44d2c002a46b4c029570fe95bdd88e6585ba3433cb8d3badd64b17ed9fa98cce723a71183055d2f84d7462db6f851bc41270cd3e311421a22df01bb57ec289f9da10e02bd05be5a40082eed82e23e579b321de2c9dcae928f3d45b5efa37585232e6f354574ad18bd6650f0856605f4f23407221d70b3a3c171d5757a72e4045e3c415040c794afcc76f3817454ba1b765c252da41eba2c486dd7b561475abdb761615058c79d0f6f499ce9e96a34dbe765c876376abbd86798bad6ee8189b103c7ebcf9edf741731fab6e6cf56ec242de14d50be621068867a2047802c5207d54e8eea8ddd14823b464d73760165952b0b5f93d4aec0a06d99021b574f116044d79c07095fcd7594842346c2cb6daebaadadda7c094df3090048b3023f183628d8f1fc07582b4d445360d35ff6449060bdf1bb44cad533af9608abebdc83a18119afe831477528b64b377f07356b0599f52e76df16144b94f668998c374c6d422c6cd0d897f2e0fa68823d3f2b716a95655990145df1897fa921e811c38ace5033869a24deaba25cdfa5abf79492fb785ad0aa56d84e58d26c89abdf4a3923caa03b9f19496b9def3365bd7c513c4cb0340e84875862cc868504962a9751c2c068afaaf4be9c7a26c281f096471fef160877dbd637f8a9a8897845e99c3913d321fb25a213f3a9e0eaef930d820745040a47c1a5db0529ab07223f8f916f8629aa2d27abac0d505a7772edf2e8b9c0ac23c1ff92f8dead68471e2b7b7542d12fd08702280387c6bd3b641e21e02d8f1335ceb74717517a80dfc0d106ec199f7ed2dc01e382fc7958d016b84da82e6e707d3b4174f09a31464c581f41404f205fa7e9385c22f6f069b2d29fa8ed31d1e2ed89dd6f067bf7a20a0336905dbce3fb08fa36dcbb754bd8fdc0e9f7d27b29d5a1ff72ba837caac148e775fe41d2843b4227e8dd99379c6549891cc31128ac57a0db472bd92cbe6958c15404f31428f4b9e4c76a53afbce72dc18011f82ab54032fb4191d29bd27979dfaf3306bb3df6a2717391c3c89e076d4db85810b7727d42bf7f3142785af71bc02db7c6985152bffcbe50553c4a71033f63920fa3205a6ea656109331f38ec8a53f6fa0fb9b4977a38ffbee0fe4f4cf2fe0020b319e2ea8bc3e2a0ccf15c91a64e1441b3226bbf002887924343c25e2ccaa124e8fc9f2193f64702a6501a8a8cb0202a729c59df81a4b2cfe1567a8a9a8a313a737a0f505a3dd494d74640d334c645fd0e85bf5effb36f3b1152a877c1a3aac3f5e3578ff671ebbee713c71615c62a2f8f0b13916d390ed5d7b98dc729c50498016923f09290a56dd20974e79b083c84544c599887c1138742f769b777fa640b1b70781097c51842e622f1f4a0a5591eef223e917406529d3064b3bdf98deff150892bb633f2a910bd9ae8c303bd38cf8ccc01cb5dc295558ae6134428b5faa262db06297469401fb12fa7f79d5af52b3230a7b113d4e4865d02b8dfb34eeaa7bd3899c34c31375f4d8134448a77996da0c77e60199bde228cb895b71e703d5aa8bdc4ca7b0cd5f23a68af6105ccf936d1ac3ad7326bff51e85dfb0f27b8d483ecac3bc1a00f358f6c730afed6fab92758c7be87f6bb2b0f52ad8334cd5e3626ed6e5e7b0ea29ef1f41a3d70cb94ac0e3a73fb324b2984a6c4bdf6fc100b829aa432225f323deb3056cf7c4518030d353ab3bcef20f88e1f0948bbc245a6583820aba2b16aa94f581d9237538c2a628053f623403f823a6e012068a1f236fdce43beab4c3b8f1bde40d74b156e5f5b1cd6da09e9d93768f975d7383c1f662953ff3b24c278c978be5d8059655aab9a84f677e76b387166576f06135b6e79381aeee06bf04d10c3922cbe12f57b521970085db02797eb633b771cf0c980c1545e5aa44075b9b12c67b613516637a7dbc0389fd200714bb6ee550e8598216bed56783d457482c7834570f8e02528c591535272bda7f7ee86cb63235cb01a5c012f26cf78390454526056df870cb6dc01461e979a4a676240c9cac9f8e59540883394e39c2f7ee923c5dc6ac2ce386865d71dfa8748b5ca78c865a8ec31273aced52508035a0e0d6e46650aad00316212349cd0f94b2f286e15b664fda3611cebc01f33007cf45ee1abcf7e1d310af131ebcf5d03610579be57bafab668875bf9c167a0b056b627b0b59a6d6ade60db14a719a7d0e4fd0b903c7ca74e708c2a03c0638bea7a0218393bc1f250361076ebeb3d9306c948d4e7b157a8e9d2e947274786beea0dd0da576009a6633db554ba44216e4760d83745a4f88e5076380795ac64f4e3d2f29a6d894e37e304160e68b3de8cad4bd12f554d5e1ee4d2ac44bec41eb034afeb2ee1429f5b171f3b466cb3b59860ef5b375b6f7581f334cdd95ffc6b31bbb5fd11339bf8dff4d5bb8151b791de367dff0f600bb223a506dadc6aadd2832d066e3373470472bf626c78697abccadc5973d33e1bda2618d617111e6afb3b303f96a58c7aafd53f1535f0e753bb803829e0f836891c78818d4963ee93b66c6425118b55a71982e52d74b9a479b394c3b5783ce808b9805368d5ce58c4f13eee16481d191a1fafb8dc2365ea615017f8c8ddb9c6db58066c32f02963f133fe55d75b9cd4b38a16ce35910ae1599f868ee400554901721feef970c18841f1c6abe086882ed6d776761ec21f497d3261ff83ed2d9e56d96dff9f5e1420b310e2f234ae51708f60bf7ff13b6b326e8cd23b982f9b95c100391be69cfe11972859baa538b431c790fdddc87674c4abeb678e2f42e30c885367b71033c595fa96e1c951e190893925a6cb037fd392d343ea770c07b7062b935bdb4918df43385c38fd051fcc52dda5045801df3436abeb982f47ac6866f1ac32762b5506d3ff53ffc56ff4631743596bc349797b710f6fce972708d32721f94dfddc3e77e42eec9b111636bdadccd0781a0757159a838877f160006ae54bf13009760a086c48c3955d41967194ef72a5b3bf7bacc78df841c5a992735b61f5654b93484d4465b53ac64f706ece4e70ff5419dc181c21af67827f72d77bd5d26e4effa957082af4f57c603bdfcb9308a2a7eace8e9058bc36567f4d025fd3223cb720cfa5a1a2567c8d0e4bd7452ac7a038d45d3c5431e2298a876647a36502fbfd38240648716c76c4352e0a08dad89687ad54c521caadc979ac223a693665af9a74b05cd9a4297364844cd076db7f9ce308a1b4589f7c017fea3819ba19367b0a7c2c5b87d473b7818cdb3d0d638625d236ab661a28fdc9fe8ac3d09d438ca9193a271c5b17467f80e976f0ece94c145bb8aedccc48d3b79fd1e63245503408e582e2cc48084bfbafd070da574f8ed9a68faf1c79ddceea15e696a884f0b208d232578e21f6e5bd0a77dcae4c86b702ac7dfac4b40a1493afd46dd6a3973209d357848f21fdb2bb49cf09d8d51bbd4259a04810a815684bddc839cef8a824c35e3a2a5538a685d471a313b4251bd8c5a26d30cc08a68a7259fe3a4c5acf8bd8be110036990b168835160044a43d97d45bfd152e4b964cb848de18834dc0f82dceb27395e8dc908bcb4302bf76525cfb5f3809dc19aa252b07174b18a510cbd69aafed1d56a7894796026fa552bc600e5a390e0838ea7f01f880de0273ce49af2e5c8524542c4b37a2609e5959707d94e46770c57d535a589c0c88bed22209c83c6d6b1221fb2a81cd65df326cb8a08b3309f515417dc8c40447e8323281c05767103753f3296d5828ad5224efde237205a5807a571ed90471130887cc27fa5f86c10082cab6772449982be0176f937fefebd9bbb00e3acd602b18996d90e0c5900e15667f6d217174fa7946b6db48cdf6ec2d6fb159bd3ade4e8d7c0f77147a872a5c8af38690426da7c2aa6b83bb64bfe2bf9558f4327fb965459b620d1b9dcb1bab4cbac9467790f0e609ccf152c86376ec2686a180a2431db23dbbf632645768e1de6b5622a85ad87c71a787ed8ceb10ff1b2b84cca5ab564ed6ed6e07980f7362f4320e8a26a01d6f589881968fee273fa2f1a7d6b023173625fbff5048afa2ae70462b01929e90b5df605b69ed5be43215c9a937388077d1fad87e4c189eaf4c7ee25e7293974f14f24267ca45d9cbe6cdc4ef13fa946bcff4d14d61db2a5ad7749f87708462e942aae7ba3fb4a891b1a506aaaeff464954a7cfc61d3018f6790eaa6e365a9af2a9fa9f109a51bb3b2cca2be760c174cc0ccdbd236258e4822e187dd187919b0a5f03375a2ed67cec81a24ccc4a490e477f6dac8ed26a9310032773a4120e40af1606290909d052d0fb239d6f6e6c8019ff29a55557eb69b70799478f786ddd5e171f24844d161dc5076d98a2fde06548e35ff5a0cfba2e74d539c57e779cb46dabc6a421bc5baece824cacf0acb691ab2a51e3b4983c96be9e4eec7c8b6dff2c0b4dcdd72a6ef1b1dc430ae67cbb7a715633aa83200adf1778a49679ffa5de8129e34ff44bbe855847bfec4d1b6547299f1ca745a7fa3eec16747e36379ed9acfee49429682383cc488e4a58a70a845e83f60c7a418d2b031749ef63b8603aacb21e437c1c438f839d7997973c12b730f2ae260d083bb577d0ad4558340aa2b003ac6559ca8ada73310df77b20b176cbfd58fe0d07817b2cd4c81e03503d98c9ba74adb96339b43967f17637571e61567d4f22eabcab317f9ab735e521bccdeb7d106e96ff19973438418ce1f89ac49d9d4726c1593e33352610a58d1fd1f7493114d3934453c9f00b058fceae7dc1ac9634073d534176f55fb84ec70d30acd0843ced4d53bce4d4e74d722b927d64f251ed01bb183324d2017fbf0715c0c52c87c2906fb8623b39558d8166fb35fb9bfc1064223d21f9b7d560b534a5c3ce2a7b5cca362a65a400da398c43c19600550c60fd221b9e00092e883ea6711e05a9c4b073e80ec0f7572876ecb3ba8c84d71b6b1809e6fce1dca42b357f54135003fd193b8f3c9e07b4c9eadf05795ca429e35d762ad160f11f3814492a9e506297be3400164450741dee73ece9028807cfe46c0e5f9e72fb9b5113ce8a2b657b69c8dfb0a4aef9597ef6d10e63a69571dfb8ad1786c99d490eb217cea39bff4e97f1343a49afbce633674c53f8e00e29f4e175fd824345ab7d1d1cadcfe3fb7b7a7602f6ccd3f38f8cbc1c96825a03be206d944ebe96fca5de5c30bd7049719f329203c474ff14c94620e3836529b43fe745baf484df013ea493fdab117b689af2ba478ea3790ff665fb17c7f79379cd58467a59f97365c68db3df8d530ece5c56d8573492e644d67929d40cbf864de5b49402c084bd8338a1e1a5c22e63383014b2cdf0c8aabe24e989eb40cfbe1728c76a25630943f7bd5d466f5eabc3d952a995eda02f4436fc8f161bbf6d5706bd4a337c1b4a8659ba78b42ce2df5e00b59366f995025c6480dc2a7af019950df85afc91b5c049fdceb88019e1497cfc67d1b401c99cf1135f8682954a0bfc7e024ff49da500c34136d25d17331ef74bec89beb900996ee3ea66487f74e87b8272e1a4e251317d5f8a7a03480462d5122591f9f79398630dbb21d69f088aa7000fe50530769fe5caf233845dc35aa3e67efd4e51ed20832a84117e41630036de25da9fb8e9eb4c9b9ec05018bf7b883d53427687a7cc70dd2114ca80937415d0fbdb15a2c0c976501625991c6e92636f1b6358a3921437fbcdbc5cf05ffaf853f399430b0fccac350d649513342edfd66b27ba606e88de45bc30b4f556b15602ea83b743c0511c9a43ae6dd0f93499a4676e9ca739c140bf9c0902a682d9781e20c9c03a8345ac90ee6e5aae0b69a38621c103a2898b31f09d7fed0ea738f1ead88b325cdbf2c3fb426387a412c2895ad68a3ad67418f40e4ce743e9bd58d3a5fb73a37c9ca1e9bf52979d29b344896b92a7541cf6e33faac350e427a02a6e7035c4f4d8f2218a0c351984232a6e57716570aac37a5a533e80ecf78895744391be3a99c1a325f2ce2944b559d9b92fa38d277d1b957878103f910b0811e761bc0c64c4aa034ed290ae8070cbde15fb5ee80eebe2f966cda6800bccc8aaba986084ad3be9195391f21f3719e02e7d98b7e79f21a442f155347be3f0bcd3f0f672c7149b33b7ef01be0d07093343a5669ecf93a79ae77f92727045ea7db101646278ce8cad4f61924609cae079f71e110f7670ff1168111b6a8ab820cc11a947c69e2aee3a3cab31379e6160f44a0b919515d4f783276bb4afa40fd940857badff9c7ae2a57052adddade77a4c3da37bcdaced2c7ba203f20619c1a3a68fbf2f99b29baa99c6b455e719eadd05e272e644a9f4b85280a883be3510cdfabbda1a5ea00e6b9d83d71806356781aa72f0419167088644f7e62d54617acfcbdbfa873b57fee5ef3f19f6e4867ab489988ff46f296b578590b5628e5713e50f10c1db873aca264482472c9066675f9f9fff7d2e5a301c7898bf1aac8546c80dff3807db9a5773ada9b8201f9a6ebe19521a3e5fe710e6328141ffa1fbfdaedcb44b53f08e44e79df30fd3600df7fb5559cc5af34f8b8e920c301443d62366e33eb13725d3e9f64a9588af93b5d41dd7671d806bf7080617c40f3dee65a8d7a6a94602270e83e215fff40354117863b66597572dce2963997ca9d58cc5e1ac1d445d127502a46ea121ba4e2a4c841e5024d8be477d5fc4f69b4ed9cacd66b2f087ec59ba65701f796d2625960cbe2f3e0724c165926211ca088390454cd1531654cdea5e04737f4b98b7e8de3a04ee4827524e467cd737002fc43d907a2593e6ad303492fe245cd6af90a608e3bd0f2aff30e6b48b56930f4e675aad39b6790ec0eb3850dfb0770e595593df9f86513515c5f8c2407af3a644d959eab8c6398cbf29cd9f527c61319f6ba977e01884a428f274ed09e4c7761a310487fd4d2e065ebf7a0444b244bb8afa3aa88b2d60c36debbd8b2c82a0cdae5665cff3389aa613dc4782c0708c5ba3135f0fcddff9f7af597755856d124cc6503d41f68630832b0ef067a0cc71eba7a71944bfcf3269e1cbe697aa56b78abbfb5aac674298a743f0b141bd6b66bbccdc6d16b33d780abbcc747b15762ba17315bf2a2d9a388aa2498c6a63a442110cb5e472a7b50aa36e6dd36c0097fc5de1433f6b2ca7578d3688d3ac0eec1b2a8aae872257d720f9048616604bdea97285a245da04d1b283a35b86163c54c56610840bd08bccd8c3752ae5d556c1c60cfc705771d972d042c2829bcb44510fea194ab7c8bd912b00e858689dcdb81d6c70b57a39c4285aa98b216d84620ce38326bc4f8ee0863acfce3f84b28b1bdd0403076a89e8298ec62f552688e7239506a285e2a050dc4ec90e2e0da4e5aba8db0f49aecbc0db8df32e7640d709088b7c609b8181d88e25be46c03f3b8e8bd3aa655819ef917c948a536a54ac84b765f91a8d445e21a831c0109482a0ced638c2b9a856e2ec05871db9db304f90cf4f814e08517cabd7962f677c3a173118019c89928c136fd0faca6149c695d704b85a4e7333621a99da44eae7fe402df79909f6aaaf6b561b15bf3c607da3511ef6546dd0b8e2e402914fe637d1849bd0954b2d2105ffe077ba0d09488ea6e02d6bf0d875641ebfe8c6d754b88f55ee6c6433683221e7cbb28cbf75cce864f60493bbb671b6579227b61ea340391a59a244b024ab3b48bd7e284b1b44d57176c06e054cac40ecadf2a40052a2f09668d9ea6c554dbf43afe8c605d64620dffd471bca10a7e0a7df735d49865bfebc8a5cde357bd9c947d8a426e8f8a2ada45e97bd248a8c8a6b5359a2dc19fc2b0acf3539a5c1a1880ca1c3fbb03993d260f4eeffa51b26af106518524b98e96c6c19f469ceff0a1613b9f1d75f808b4039b65a0c058907d56cf7d6fa9d9792a4d9f06b2c6ae093754fdedc60f7c2c83432c2c97f4b7c6dc1d92e9cce9c16fbb40d335c1e60d73cb64b6cde64b06eb0b5cf4699fe1b5a2d7aeee32c81870c20f8935369c348ffd84edff71d8a85bd47fe1845a6657ee69b734e53f62cbbfb9d00094aefc69ef29e709055ed49a03fd01a22eb49c962b041f2f2a48695b87b497093b01c8278d2361cb360e59d7b9e9c1a1d1f75c6212195144fe90648551cdbc237b9296eb46091b362a1986df754ba83dc4f18a5dffdaaf3c3c99c95c63cb4abc7a1bec09a3db866ea28c2d214bf864e6fab4ee297cf68d5a23c5c42cf6e4eab49e6ab1d9af2b6f1dd33f6e11eddb0e86458e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
