<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77e8d7ef5d08154e9cade7f15fc5eb01f9bb0f851d028297c4eb7fe6330fecf4925195fa075b8e0b8fa44ab662b141872f32fe5456ab571ba43eebd168dc6170ba7f9e1041e6cbd930d7ac0c754aaa99bb94af717a046c154e648a0fc5a7db44cc7a71a4caf76c8104fce5fa9db03a99fc44bbcfe269d4c04c0e22fd5e06d2e62142044731ce385cfe8286df77edc6cc92095f9b3a9f5af78a4da9b8d008a8d346ca8396371de2814f45262bc084935e159efbbb30fb45228cad4282e49affebad98a994997410a6244ba6ce9b5bc2e31cd55dfa270dc9513740a701c12150092e8142b73e0696a884cbc1cdfb57496464cceac4a68de5b6170ccae58cfd3fd1d5784d5561c8cb63b8a2c2fc5d6e3cf721ef4d55c0f41ac7d40c81ef207c09bb650b556285527979c7cf614ebe53762c7f06ecd4d955e30782263501b3d9620656692cd3875d27b3ad8ad703a03ee4d1a83b421463a661c925ff7ca4c4245324025e5e29a3e5dbc934e7922f66ea7db0fc37202ba3cb5e7e58ec57d1fb093ba7b317268bdfd0de65f4cc7489d853a7c3d3937730b4d4b868feaf50964748abca859af40f98a03cff6ec60a3f7ca5cc8a8c0a7f2796bf8828116f8fedf55a68b399bcfe5821862783cf4ba110ca1e06d91b84776cb7082589ad3fe69abef92fd3d6e873ace4f96506adea7edc2b89740d0747ee0373059d5c2c049ab292b0e257fc6cd2f3fc6d94e62bfa9e0d78e73f06a08a17d325512333263b7daf39c43627fc61ef67d225c25137fd3354ddc7939d5078fcd0d77f9b6d03e58d4edced2ea96198d1e1872b88af3119de37379e59b5da35d9dc876a57973eeb8538573bcc0b26b5de754b6da6a2753f8c0386ce13e9174349007dbcb38ca1b8b89f1bfd501ad8c06bb0a45cf93d181b2d7abadff842188cd2da7cdfd0cd5d6fd47510c39d3d960e422a8a485ae81d99607118b30268fdc3c578cd49a18e2ea93041aa61fe407d19ae4f037f848c461fb8004b0c94411fa1b80cb330b1e7cb05892596bd545b7342839f4551283eaf72f594e33389b5c5752617c82c118f1ec1bcab49ed1ec6ab5ecb69c1c361a5341fb4ed6fb91b16eba48aa8fa84ae4024bdd76c802852c1f5d46ea7d393f3c5d5278af37357695f5d0917764ee3b06e53d416ed7e198abf5b404f2ce57213be679d902d7d7d1dd073df84ebeff1a7242186025881df581fec8816c1a32fa9fb3da8dfbd0e480511e80001286f05e626f34ddb884269188bb3c200af5e07abf5038ec8d402d7faf7ffec45fc7b62b5bf066eb145db8d566263b506e1911c74342c4f0118211b0bb7f73c899c608e6161ae66af9d293b11a173804b13b417eeb96679039c0513cf72d2755cc805a2a3ec1449d9c64b2309208193627cb7a1fc6e4fbee35a087883e3164ad8eb1d164a53e3e11748ec9d428f9a3f381b6cbffb8cf223dc754e0bf9d3569c46f60901d04245fc4caac64c6c9a908f5e1e901de61033753856598c53582d9e6fe977f21b4000795148a03f15e677e302ea517d6296ca46f089c1cf2b36388f9c73f58b5fb86ffc90ca237a28e545d0a1d1a4f037f18caa3c9a10f1914f7f65f0222de7dae628884ac9519aef11de6f329e0164745b0b7e8936f548bd0ced8e32802b6ab07ba7b6f6cf7620d5e71ab786ab6d9ba51fc774846178538871f1283925acaac5ce157ece95b768fda42d139efbfd6ed1ecac59e029e18c24bb8bc440a90cd45475f980d90f03fe7aa682a635343bbb9740c1289a2bfb1a1b17219d1677a1c5dc76b878181f3e402998a4f1ae3f4f70d4bde2d1a8b182984635e9b888ec10dab9f1905f2e7cbc02804d1a475c4fe65f140124afeea363295e3f648213627dc920a6e6da6d7fc3068d83c6d0f1be5d6e99497748d3aecaf964c2a423286a33a731f0229a340623332eae1312b9664871e57b63b6bff712381606e729b08caef5750dc5b44828be81e998c984250e0ee23c43b8ca05f33e20e696350f5d429bc9718be994d5ea4c387f6822c542f0df3dee0864396b3676428730e4ebde8f418f3fc75f2e2d252d677b10795a45fc15b2ba48f1138a8169df7f4a8e022d60fbebe38d1508280229ec30f61c86dcde41f5eec2d5ed42741b616e976325ab404007f2de181dabd5cec6cf4fbd4e8a19150c58a83202d8e0711a2582b696b66ed083d5e7c47296ba35d36484de717f14e294157f80303a0da617df1d90b0e476b67f111323074a0e8b190a63422f073fd5ba951917bf8bb806bc5491d0fa81891cf7bf0d8c69316b10f8af0925382f5792d2bd089418450abf560fd2bb991dd00beb1f28e7e285507dcac5d82026f9349f31c19ae3e1fe2bb54339c4cd658b85b035d2a50bb7e49b8d45cd49993627a43cdb37baf2214d9b9bc7289de345fcab529d76b0984cf1df2805e0c8919ac4898d3f16424c4bc89e17aa57ba3418fa0d3390bedcd1983571d72cc43c6996941b33d66e8aa0a2728d6d7fd3d0569d0dfd4d4fa554fdf4d0d567b1ef600e0d3d7787d06932e85de3ee5f977763fa0dcf28fc22a7b29b5958e777a8b1e77f8fe007aa1485522fe7d845a1e9ecb1b61dc5ffedd9eacffe346ceaef5da7c4fc527a5d86ebee5241e8b363277e4b12b3f5abf44ad567b49e388ce793290b1cf10c323c7be8d843339e2834a1cf9997780319a208d000c8acc95947171a78c7f8102faa6a51f2a2d5ecc2b102af0519acaf596e42b17f081bebbc953fd93225a3f827f931e812597a3b7a96b0d03fa88a935d726451eea870ff894d9ccdf08b33d2205e0b0d0ca294282fc674161a6d458216990db7df346c76611d4c13d85b90dc59c434e73943c994b0dedd108e7d1b7477998f853ba6c6dc3a0e5e3884ca7bcc37b36cf27cfb6b8d3e9de3da2776c795bfa3254d798050f0a0dce3b9cda136a6e0e4a12254703bf2e048e4a457ca3ff0092e4fd57c2433211a1cac41e00d1464c399bc86ec3425720405cf36d97291968ae805f6233040c34997d440a45556ddeb8ac977be8997b1551f7b22d30aa2af9bb355effaa638b52c7ac6aca972bc18e76278e4412de3ff9f2529e09bd97ab5c5a41169f83c0961204e7fd008caf8ab76f11899dbe31b1acbf1450fb572721264a46815586301cf9e622108664e6714766fb2c7666d1ecdef68c205b62a7ba27b901b676f7927c1701b2475259a33897ab9b76e0eb59ef0d98c32649d8e65faa5ca3a37019d1be080f30ab92bd3f000c66fb92f29f256f18c485ebb93bd2d0d1295f9b611253bcf1bed96db1b3c3bc01c13fbcdb82869ff749f523f6ba5bfb12d48184eda41d24b81a51d3075ec3865be4d06f25721f1498cb9698e7a38032c6a087d74358ec8f693be4c64abe5a65c704010905d1cd578fb7ea6a03a70a2d92c2813675aeac85fde6c4e97b945f1684d110d2194b34861118611015ef13e9a70d27d4c12705e7e2839fb6bbf943eecde1607fe737199902bc1b177bb1f0ec1559a8200055b44c115b34bd40a6fb559ee19454dc9f9b9adbaa0b0c825855739ca5e2d6372631d77c82c4ca1eab92ddb2c37afc6166438cc6f1cbf4ce9b5a0b8e5f55d8bacd42d4bcdb5502cdd7740f7c3c659436e2dcd9c7f95ef3e6e9ffc3d4e8565328646644a1c67f02a028ee321964500f316c5de37252af51be799e6d32079fcce45043a29e84aa61c6bcda79778b40a3fabe61044c7578d6b962a3c3bc2592bb06cf1364ad305739d207eb66949a8c422d231506d95b0758244076643f83be238491b7ab64404c29a630e3aa3e941b2d54f3cde4a55277f64ec11345fae0e2b6403532650b0100194736c0c3580f7c7aebdfb70ee8616a55f1865284355e330812c78113b60412e7606f8f2d3ba686b0dd3b03b647e868451bd80e116d432078727d1e5f9f09f8af02d8b6984b8c3f1638f2f48f7762f5aa18e478b89488c681f690cc73df2bebe68a3f811fb6c0918798a33c9c7869c8fe1bb34a80f187d4fa0924cbaa8fe31e48a3dbeb2dcc741fca3528f7696015b0ed5a69c6d4f83f752c75ca87b9d6fc6bd04f0bcbbde868ff3f6cf386d2c0678712e83a98a9286a170082c892c61ce2fe50d96d50a47201d0054619c1eefbd16e97f4302a539875645545c6293ed845055d10d3971dcc8444c3ad6e48dffdfd888d423ef6add8b8079a9689027ad10b6c63648e71a53fb71ee9344c6e30ccfa1323c331cd5995718e81995c5e940a04bc18c33f5f48e720be5434db570167933e99e6d1586c7786bfb87da09fd70e90b8dea2ba0c0864b7d180306c16c9030e63deb164757bb478d234fc610e3a408c8016f4a7aee84895d9172271ad03c17429f3185be3e81a134305fccb9d69e3d27525fe747d0d79d16321888f4a7d5657b3f6e86e2b475aaa0d43b0bc7900d5b0f3f438724c85d4d3cdd7ee34fc2fc91720de26c88e617f20adc8d57cdecea621072714307ad94952c2796ca3a67c23db7349cb78e08fa82e5105e97cd26a4b5170a8a13ca341f2be39b1c40b254a278746fa158dca4a42d10839fb6b4fdd2be4bc5d817ea8bdafc767b05e81782ab1a588fff7d976ffc2b2231f76171033f7958463204cc7016b7387d81b1e77364435543aafef7117b422cdcea31d81562dcc20e9eac20621f5eb02e2d5cb43ad4c2ec57bb45fbd6488829bd9be772e121da59690d405f2b0818c5048a5ec308fcd8a5027783311338ea969264fa9261d05ac55e3248125f13b5d28be816a590908b667a6c21d4d9796b08712daa1076e869b7d81643a3e3ee455658c078c637ddec27ba7591632bb3d2aee3e53bcad6860ca81ca33c6aadcc82bdf587f328c1d5d252f3d96e99d94d73e44a8de285242766303e4be4e59950ab41303543b3d6c4f04d1132bac7b4b56352ea275e8ced2ef722f7faa9545c8bb66515a9fb13d03583abf506fa342cf8e6c51f9e0985d55c309cbc2549998156ea8f7a05dec31b8bd54d763193d4d08003eda2d6524705702b69664821891a2e8afa7a62b2cef4241fc89f8207b48f8e1dc91ccb6c0df149094d8a26aca9146ff5993c38d88b4c0ed8b035402b0aeb139df37b694995b8aa58b4e6538f2cb57151d2e0dd4734eb30ae8430d384208936b5897e928afcae23a794c5ca2b88e58158703ec1260dfa34c4f077aa85baa64055423228bd3aba28b52a8b7ca9431969c60b955f75984f16e138d50709d5a22b765812466d689e7f49ac03321804df03e788ee047e0bd3e1d91fedfc147e5439a813949ca7519ad1c645f5fd64d1bc3c7683ea14f9ef98176819f43c0c931857f640a2d9a1a177702a38347146c7e5b276eedc54ae25bbc8867a5ccabda5c728a58a29300bb9406039f3039891ea8b088d049695a2cd6135c9ee31452052a2d8858d935ffbe11c3802512d1c05422f0612531175e1bfccb5969cedc7fb4cb7824eb105b2bcdd6f90c4b0fbb0b68152b8606e73136e10215da7b5a2ed7165154c3c017b189dd7c37e901eeb94808dd35bdc11df12ef1a0a2ffba413fe2747e00a09fc1c4a65df6662200679c0c09125a6da9caf6b62402cbff309a275f4dd68398b1899bfa97650a8d286af45b56bef0abe58c6d5d0e1947e985c5f9d053344be76bc889b08938198f0e759374db762b456ec6bfb2ff3c93d08a9b1cc3d0f11281cf7243802cada754a655c74c815edd192e73b32c106fd9aa5de1630a95f18e968af9bddc6666e472be4a613427eaf21e4cb746378c4b82f9a37496f85dc41683645186d60faadfb97dd923a02a23cdc6938a0beba5913a4406345ac9eec5c37893cb09746a8303074f8de3fdd9f0caa019ec08d88e09d94e8a2354e60c34fd02b5fd6e36b6a4dec3254ab03554fbce37bce381b6bd27097686090570cbc82c41ade4e44ab41d81a490e77a52a0bb1fb7ac0ce99590426ff62fd9d33eed13f48571c70dee72c1ab318c01475273e987bea0c6c837b0a0a92ad4bc486f6f9d04c57c0c54d57bed51178c2cbe77af679d2647691f6c22b21443e71e50bcc83fab85ddb5b1734103de742558125ebe878b2f248995ee30004ef3b138d296c534f7031f2b56ada11b68b0f7d8048f1382bf4b19fdf19842e0ded318893b486366674eb936b7d78a81872be8ca1f00047e07857e6728c503edeec5573ff4a6d34ed3513f11fcf5125b3ad197011ebda073c4d1211a5809df93af72e9e0a80bf8e36b3e9370bbcf92b33eb6bd234f40a1c9af68cb0f583c81caec50cbf66ea8c0f143e3b5687485ed764bb9c9943c7821e9885c12304f0e3f739cc6007fdea96364f95bf67e1ebf09b995cf11951e498c99cc621dbd1cdcfaba04edc6508f3f20bf6ebcaae1721f7fc1527a4f225e71f98a5aacd1494eb8d57899466feca30001638df9cdb464a2425902f9cd180f1d7ed9ca0b7fbc65825719aaac4e59ef5db99ae1fcad12d0ca3f0b97e4610581e7f776ad85347ed3fe62b6a9c60d548a83685658d301e699d1ec685b9ff5ab391dfbb77f7b540388a9063030f5275537b5e502fb9c28b2e2aff978e583c753c260eda251862fc8f3fc456505673b7eaf8bd3aaf1d5391923099a90933714baf304dbf07f47b8f1c8be500b53635921ca5f46686f617e65ae5d0f63d8baff49cf21a5c57cc0b8ea9dd5dea989452e98b833fa1eba3f9bbc6f0770b5b1d6202c834c1ccda6fbb9360626f43cb7c42077153eae9494cd27aaf65bd735b5235c14b64d1435405a798637508076d31f5f38bce3fa30bc7dee74a4cea55fd1446923287d2b916e59bb5c1f5849042f82b3da355763974a22d644c21199e37d8540958b0c0310782e00500ec8b4f650256b34a37f1469f6affb046c4001c58739f5e68f1a9ed054ea51455ac76c1da5378457902799c7748181853b0a5e462b77f6562112c9b399ec9548f65736207173a352c8de1e53d087c11646679c29bf8a190334e4db16fe87babcda061cfff41ea9aa3e54e91b21e2a8a99bbacbc5bf951f62e76da80d7e2d2647d1a87559bd66b6229397c0d8c2e65387d1899eabde3d87a0b3d59b69a713d036843a8f91bc301a9151067d9b8d3ef205612307126a88170211dc6ffe5e8820e70f58336fe92c55bd13ccdfd1f82ede984e8ab1dad35c8f81a743d44a3c0f268b4c341ba4f50c9146eb759e067fc117565ac291eed8eaab0e1707d0ccbed2dcf6911fbad9a99f1de77ac61a6199723a76ab030bfacb37e28294bf2f8ca03811076bf55d168037a97afc1f89d69b1d31fbe183ded2828f25900b90976307d16e0d95868267e690576c3ad3f28daef4940d66e8c87bb2cf66481fcb2a1feb701b63cdd2e3a3166e9b9248dced4c5fa7f3aaa6d10bec6a1a0a00393b725afce778673f88ef3ea3a11574a3cde621430ac35a73ffc06c4ff53540649c14633ad07ce210e931e07a7aa24cc2be90af447f81c6750d84741400adab4b8972f0b9855d706a947c77b5665ec5ade35d448a7e9cc7871b15c528f7a3d6d288da66addd876938f752d519e2f6b45db1407a197ae4c14e314aca8274d93fb6b1d0c51bc0c466f40e037f8394f79a9bc41256368647b978e6fc5e76877df67c6d0771125c576f5baf5d85e34175734534270e3186cba1c4455e2d5c58973c7417e3b678d9d8a613eeaaca7cac04b9d539815a41ee30815c9dcf5ee2614b1547601dd0f9dadda1f6bb2e7e0a32a18918040cf4e5048cddb35af0661891af0374ca19f2b71c4a5b9fb27877dbd80ea89fc08dc4f2f06f365e4d37111907339522452297fbcfe45fc33e64cbace736c7ff58a6a1c524bdf96b89e5b78a6f0954a0ab381a92f9aa52a7338689fd26d8b3baa2277f1df237f1abc710e0961f7bd727d8c02408f9c5732211d2402a8d6a431664613d088de22b9bb30e0884a7ff5186a7a2018b0ebe2f71c7b7891b43d41a697eb65852ddf8f312072510f514bd9dd8b419a8a7fdf2ad780c61cfdffb1bb761a0385505620369871d71fd35d46fad84c97e1dae7e4adaccaf751141f81700e3f237ba278f5fd7cd9a061763cf3b54b979d281bb2da06ea551092942fc12ccaa4307d38b032cc361beb285381e466f50191424a7d6c7699d6d4b7e5528d6fb96e528b87a02888e7395c96d82bf043ab802cc9cb09c4a1d643903dc3025c3f347f910b89d6618dfa47791875fdb19c30dcda474fcab6c9f1ad1004ed830481c5f17469482f616678ce8e4fc6c82060ee15615df8f645d55ec40310bfa4fbc4169877e570f98ad5c030310e5ea7075f43400f2cf63ba222312db7e54c511ccf85bccccadc0d632a1eccdc5586c735cac5e7bed3c9aa3a61c5cb789bda1e61c7b579be3cc7d52a4ce47283830e0a971c39ea75cc1b74ff8a96eb09be04f9bf88087955c35bed5cd1e575c668edcc45cd4378978304e91334c73c65533374a5a12f739f04462fa853776190051d696cfb5ec3bb8940809591b791b010391932c09800463589553fa4c758295b092e0e9f815731d40050d1d328f70dadf5128a3a2074551a6d0f01fe0cc931d4ad6e3c2db8cc209444a701ce2e6b02dcb1d43d840c2d0467ad02af21a0f7048877e9083580abbb30df29c5302b8399349a748f9533fb3fc0f18a2bf6f1116636096cf414f39664b360c820bdd72dd4cf5ab6078acc7abcf5d828280fb743a367e5692dda139a944b47d9efb9505b2e64c0bc8dff2875a26716f8e9c5f5158114429c8126bef55d11a5872bccadb54c4246c3b588f751e5ccdb4af320b386bb198437488c1158c04254e58dbe80ec5f86c05bc4b66add8c60636969b46c90c1eca8bc7cfc3a6d2cd3a5d20ea263a501b050e49a97d13c8fcf6a5cb06ed42008081ea336837e660b68258b447f6b81ec6ce8cc6345538544ffe8ab42d8cb84310400ddc8e440cf76cda673c9529bb21b548a8a1fd7b87050e0b8ed9a12c293a82e53ae68dfd9421821be3cc77938336abfbafbfc59be6e4a11006db341c001b31495ef6c589bc663facd03be846b670d97a674eb92e2cee91164e1eb53116d34ff56766cfbafa0b65e362d306f2e2741fab8bc33374586bfbb9acdcaaa1b341c6928dd89465a5c8018b64b2d32425e9f93e6d8d2d4b448a5ce139b14e748d19f9f71c128bd5ee3e3fddd5ceb28086179f0d46e3ccd3dd8912dafd0bcd2b3977a2c562b77c7d2ce4acb89f60085c2804c92ed5ea62f42f619e2e6dedf1e0a6c2c2d23705a7239a25fecdb5cdb7ed2490e301fb166e07c4056db9dfc94ccf1ab5b99d351adf6e4628077e9776ddfe2da42d731996768d41925efa7a78321932a6c9d93d9478106b09ec763742ad81f427ccb91517555d95f38078091c72f7a54080a31006f0e4fe0c72afdb6c858e156ead261e8681bc2c720394f2b3a252efd2663ba68b85353aa0f414918e0eee70b2d6769fff135e472949c2817a0e7fd25e9782c156513f788b93711961c34d800a18f490b58f331409aa553410f980e44835490cd9d563c200cf4f58c4d812c63ce91dea1a756948ff045fd2ebd7da18f9e8b6c6629a6a67ea1485f46a870360ea9bc2b75cbf6defbfa21bd07680857326ccc16af3cd9761a4a0848273ad861ebcbf69d6e8d4807b38a1efa7f2e4ba32d5705951ee8709d9dda6dc360aecb6a00385bca34e3d25b788bce81753836e3548a61824484e19a546932696a13fa061e5a20f3cd095eb0dba73e276f1193ceedb055e5bd1cd301c49600c4dfb8dca66fd903629a6d33f901f095cd6f6c00db310b35d6077aacbd0971a84f37f048bd437cc6be1fc42649b6953d41781f2d8d86fd1e8e1eb4e1468ef25fa1d160107d22ce872c4f2cfe7adaed6dc20afabaa44bb9d670b667dadd1b7db95fd9fc0ffa6c6f812bf83be20713df07b546657ddc6b492cbb7a1d4e2c5a9c2d38e105d83c70bb270369fd75e2bae4a2318745f2939e0db6c94913e788dd938dc15c1136e11fc062600b335363c61db8eb68a2b5d7c46fe1b97c20166d90382ee74ae6b0534a95bec43472210770945b6f23f8f1f2f15e1399eb1587125bee36c38346dac84bbe19ba2ccdee2bfd3ebc6a7c31e617ca1c4066152fbe5b32eb4b0d62a62982cf50d9da223e73bdab6cd33ab6c58fca1b065fd19c8f708d3d9bf4a92b4f044c6ed37fd28608a17f21284bf50783d1acab6a2467760a6210da921ed70ab7a67971e48baeca7d3868d7ad058a3cd719eb58582ac105d76343a76ed734d6b3c18dc16528fd1a608d1fd5440e23b586e1116c2504e7e3e8c0af3a3146b068b24d855098474b93afad0b142b35f5e3954b83c0668b91f7e83f254864258473850442beba2e32df346276410762ca2c7ce6b7520bc910e64be76e95e448bcde39d290d43ff58a5ef768f43fcc70830411220926bbacf9a6befe8a0ac33b01dda4069ef3bbdbad06d7874c5e8a9693d66a556ca8b937acde007c04a2789d330a2534850b82fd4d15e5eed060bdc4bb80f597ec598666316e90c41f4b7dfcc73dc91a69a22e2ea0e8e35851e84aafe9a8821b5c192efed1fa25c2a1fec66676dad1e17bf7f60cd1a4d67a4357de53928a24faef0a4d20f7d5169e40a58be5e8ffa65921351b9cb3e7fafd39c2abef0b2b104bed3ba359a7b70db8572314a65d520d5d66171a03ddce048e3aa25e5ad1d9ca0c8c9084c86ac34f7d5f5860b2d12403303934af05ae893257f7c090e5cd972fd71d8d5c6f949d1c3e9394928acd27fb84c62ffefb16450153917da0373735b237f5bd4ad41211039e16f1cd9daf95dd2cf00ce10999d6f83b2f405077f792d85cbecf90520b1b09598995be042c442c8f6ee8c881811070e5007bf89f594c4e25261d923d8afefc3e52d5ba1341abea72576bec9f1bd47839c3d324338a4202f9f75a1a2711db04e4c90a6be336d107c6b743bf25e532ff2f7a4b31be8c6b6909f0e3fd7c5d0c8c243aa6a79bc2661a569aad5f749594e86c3ed68fa9a4902d413bdf94a49834acc4d9d3f02f3836f84c27b28bae95f8e726f782e149f686a854dd4bced3d505379d7ca87022884755f7f3b9ce0e8c8e2a925f856b4595755d6d24c56c01e732984d4aa84f5a5c5147984d05d8417a415f45350e2a4eb0b712c21f281fd005f7862dfa0df0b5d637ac27249906739d9021bc77109e83cf6e090875bae21986603029006e20b05079f9d7cabf94a14aeca1dae7cec708f4b9607d71ad22098bf40dcc99f3c396e471f7d542144432e255b7292a767206df87cbdb9de510a5bca2c3d725d4a7037318bac240589641ce7db97dc200107d0a52e4d95aad17adfcbba3a5e7872c06ec7bdb6d174908dd5a6d84afc5e1a707c9126672c9b90e319a98566f6c68b440db479b324a1d22a7fa729e41bc85bf9eb0447dbeadc73c1623011b327a7d9493376b67e03a43140c8a32067fbce317b414ce6dafe5da01c7b6f3650704250efbaf3222d1580683f61a25197cc7e755853b18498e3524a13439ef9f0bf36bfb50a4ccffe7acb3ad28527de15754e522c217a87083a3ce944acf71dac928ae8ed6cbb29e4cedde24f655e0268c739d3e2e4fc2317ce001bd6ebd43a27a08e8b51ac423a9d37689f7dfe9ef7c931276cc900a710f73ad7103e29521b6494a9856fd24d311de6ea88f0dada5644265315685bd27180ca0dde9ca262df296a2d7f5302bc073031da98a9d7af845ad9e9bbe6d957be888b547e4f7709b8fdceb18f5a8af4ae2a77698a410dcd4a280f76afe8617fb159e5ea7d92fba095e759ad88b283759730a85d3e4360dd0474e3a251143d17978ea3c750fcc08faaec054b13151a681db471959ee8cebd5b3791d70a7f9409853a63976bab9358d562b744334021d48ee7090edf2e1cb25fcfa68d2d07e145db4db1ba86517afbccb46bc97adef4cae31eaab4f53c082585a6d18fbaa39cb74c70df6792b727621d7bebf3cc0df1e0a10313a1af79dd6d5e87fd37cd9137fcdfee6414b22bbd98e1619d734066904855ed4b19b5bdac9907931efd13406e8214bea0cd565d75fd286ddff7100cc63d04b9b049464f4f3c1201f1c7218e2b7accf2586e6e902ac2b35be80b4a3a4dfe5c36f8a8cb9a54a803adc66364def87e9449c716cf404d7aadc3898538505b8784b623fcefb604ec8689f4601f07a683d703f69ff9053143be7a83fa4c5fd91756bcbd78894709c3cc5a88c84d09a1a6002ac5570040a0b5399fd9f1e9b1ad49ccf0cd522676431e33a7861a52b76a3c19cb7ee5e2e716bd5edc0617fc79788837e9af4d4826c22b15f8ee21591c7d28fa3792ab472a25ff64cf7cfdba1d590d527dacc0fa0ffd47e934e7d7592fdd938c36f1712a967c5ed275971e29edb10a0a6f3c0815f06167c76572b0bd384a8f02ecfc94f35231b2d5452019efee3682bd7e133235d916b5ec47024c20264190c41e2c10302bb5cd60885b89ab3032a8193a9c9924f3483bc17979ca172e79e195db6b0f1e0924a772e2180969f036dd54a96a5b99c947eeee789b8e2f5920b3de91d518e6db280bdd7c242a9d9c87f6e9640a09634184febfc96677cdf6cbfde17d1ac95a3059d749bd5319ea58cd82bf5a9ae88d7d61a38b37fa3e825c9a87ad1cf1af1a00da2d73b92a7d8618e55e50e536debf1afc9b20a7e2132b41bb8cd3c9a1807afdb680b837c338c71d0a115e693d78711373dc8100309b5d01067a1e6f1d94c4ef4e877b1b93c971cd505736dac3cc9c4f52c9a235693a671ce8e807a5fdd42255b266e3cfc318929eb138922ba8cbe3d6dfb195aa9070d6e6f495109e30b41981c886e0e34218a4ccc1f14619a11ed8bdb4bf8260e1c44d83b0a125f8433bb4447cae61504590476399830f2c5c27ff0178b5993d8b943ce5afbaabfd0620ff1e42456d33e14f2da897e73a258eb672fff7bc89dbc5e578bb075d21971a29db669346f979ced45e5519699b3c3e3af3f37a9ac40ab313a6e0873d8aa3d916ae49ef343cc5e6258b12f2f7b39a112d041a7b89fe6e5444f2fd8f3075fa28acba91fd51268d8752663a437c14b0e0007402b1998c72f07d6ea62a10905a83fe090007e616e68caae545f20d4817dfb014ac48db7fffacc8bd856103eb6524f3ec18536b7bd92792487b93fb5d34f69c81ec7ae4fa52970138c4a50b30bb31b96d86d874ba94107dd4c8950f061dffdd101107eec91cb83b60ea236982826dae6b7a41c2e871c4c8567f8a3e2a0663bf16429417f6843fb7ef0dfa8fd5385394a93c2c36db1293a574e1bdb7a0b0edf3966d2d7442b996daebb000c98726eb909f09df9d2c5e74b5dbc5b01a9dc3d0d806a80da239760fb105e9c30dab2b9f5b82f41c023fad6125828663bf92219b280dc1d4e30e1434badaf31ee383c41bec919a377e93cfa335c4565832def451af1eece2e48f2d90d5b32d7cc7c3589b22b6ad5ba929bc63534a39c8861374cb0f070bcde4553e1913e173a6359ac4ef3a9ce7bf9faa311ba0be9857748c21103470fec3185d5eb8516952deebc785f60e094608e16c1ed93dfbc3e840ba23625c82ca986e57825ec711dfe35bff80eb3b517da89c7607644a1edb09079daf521690efc0575a04402b1b572897e7df2d703188651f8f95d21a1c2da15dfe52314374dc16922eff6a06614baba6375c7f6eea7b2c28bc59241df0453d476f960e8bd0d325644cb08c4adc91b2f33aaa89aa8f7acfa634e46a84ecba0aea67caee6e02783a01528833c113e9f64819d38619fa2da8e7566a9be8399c24a346177c4ccd2880c8367b365c969bfded247ccf3c76145a3903b7f555eefb3cb2239a0fa6eb583d0f289457aa54319a26413c98fbc054c626c571029d401177744886ddc7bdc98c98c6b5b3e2e57665dac71c426695602e0e1ff37fcb44adac919a250a95eb5b7d1c58f15ee8a835366b7b7065b0c52ec66e5bae1742f8f7ec5edbd0cb16ee2a4f5a8c2751745be05f78aa36052456b95d638bde236222bd1e4bcab6e66272a39856a5b77d8bf05bbaabab3782e160d95aa42311d657668d36bd5bf45bb809ac657f731a62f21b72fbe8e8da5d4ff7b4a08adf93b40f16367926bfbab45dc5119025265da0b97859b71a20256816baa9462546b37ecd33aef14cddd9e0edae8caca5c62a50bdfd7bdb89b78da1ccefea659f963cff3ea0e574a2123bf960f294536e421de74faa29c2c6bd6b2c9b62b84dd291eef655ae47931f528cf387fa3a158440d6a16cee456ad62268935e2d1ea14b95636ac42ab9565786df8ca9e4710c60b0628b3a66ba7623af9ac9f8d3193dd3a61fdff2e864b09bb8f3998e1d2e002b02623e3a052863e22f00bf0a2d85ce270611aa14ed55a8eea65f89c0f1a12f7f34e7a2eafeded75418b90cfa972183fbf3b0e6cc549539fb7a1fca89d415cab7210016de6ab7048448c591a171e1900d36860d4aec53239cf8b6e78a0b99ef52294eea65402f89a2f3321fab0d0dd2f201ae655c6a1d8e770c7a3a9ab81383651409cdef6913efd543a99788fcfa11313646af8a8599f5ec19502b49a2ad8af31f8157c84a76275029f6eeda4c4b99d10190950bd41f0","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
