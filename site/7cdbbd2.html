<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54612f8f0f73368d306ef80d5734114e6f10107143d3d095f4258583fa26653a6087eb64fd7509b257eb6992a9974a07a959fd9289684033d02d285f3bc866cc7837dc1a54ebf76d0cc810ccad5653b8849b504a99224fc6ada2eb11c66527702c7b5879af1edc17342f110e082615ab40b28414a6e7fa5bd27607f10cd1d989c850126b862db042e2b3531773a9b072aafed28b12f1d3adf956896d502208eef6b2de8a41a2972df0d3251e0accc1aebcd7143b4c15d5141fa10c9c358f0b6946dedf70793445ee5ac7d98df61f39afe839808bc3761d03d4f6030580ec4b37e660a2c1c005369dfa1fff0c2c03244ec1f7199f01c134b4e9bb4d066492248ebeaacf8892543aa1d17d2b9cd12dadedd374124f5ddf67a1635ed93ebc721967000e20975f97ee1fd75be77bc441d4f30e700030ee2eccea597fef890ed6cd9e7ce5a93dd56839619da004750e12b39567e687083ab9ce962ca0d6c21489669b4e2552b93f0497db5e605afcf15f65c01fb8c9f1fec15145ff141f0732668eb4d30d7116e4f4aca3c13bb92ad93b1058b5d9a14cf8e096e2b94ff07b1ea5854ac452a38b58ae63cbb1ae1cb895b8b2c0537443cdbe343a898c9855f52b0cdc03850967f3ededa0199199f28571a27994b4405e7b44f5916abc10f52911fc5640292f67e4e421fabacf685119081d78fa56413f88d3cd6174a87a93972fbd980329e13362e6a923ee0e401c6257009955795f89d332c5841b59e4c977dc42e83e7d8e59c1e4f88f59cee49b49264609721eba29287abaf9356ee03f606cc560369002fb3cba20ac980c3cca7bd05964c6dd57514f9b095dd6b383a9d9ebc605aa8f801ec76e9485bcd076587c191ec597de896cc8a7fae1e534580637d9b248cdf6315b78bded8e7e4fee531285388993a217954fc1710dce27ba93a4fc2bf70c7bde05289505eb58cec0e5cb37b59717a88ecc287641abe0c7ca73251507f12175d87243f1ff22518caf130b32001859a0f3069522ef772ed4a392e2ab1c2575e0bb14e177bb6107743b41e3eb8133f875b5dcffe05d05fe7c2f7ad7ea21fc7e52170477459e1efc3f505da2dc3008f2cfd7ef091605ab8722cd0cc0a5c96b7b56692581b93b382579d081bfef8e74f8c2ddced43b218c68d12a4c21d045a195d912bf493f9a7d034d01afe3ebdd29aef88b245f6875769744f46ff110ea9cc49d90a59a7fa0e0f43d1ea1851bdd7f8ea81fc8984379d9a03bda558baaf5e6861a25f39edb3ee874e675f7eccab1e7fc4d3e325fffcc0b494e5b402c750522e34af2f9c8a1463ccc15c79cbfc4a130c37e2ab7804df7710d6b176cdb02f239c3145d9cd7379a86ec0158b3fd903d21787e4e75e2ea9fafdb511aee891f3a9238dcbd687475dd765c72c65c631a9cad4929d0fa7c5f42c81d30c6750f0b3899abc94bd9b3d288583bbafa005824b71038ffa70754389855d941e48d6c0d3a50601f036b8a19a37a4204496a840fd37597585131c0e7e23942acb76a14415891ef18d74d37ee32938947b074c5cf7dc9d9807ce58843642e138547a6d6d18704a879da6b3821f603be289a80b60d00d0cd2d23267da6b283b2f68b6daacb86b6c2b1fa22b389f22dcd274f1e16223c89417cbca06227c293db6eb6ddafeac41cb45e48e9919af1a613c231b1f4bc06944c847d4263d3bf22f65ada33b59c75162a2d0889847ba77d89a72752722e4e7baabb35a0e4e817a4ad8e8caadf029858177fe99bce9efeb9c1f1c31006a0e24b8932f7ec6f9bf7ff03867035508130a7837cf1bc4310ccd15669ff8eb4b3c2dd399c9b744e2ab81a66c11482cb5f5ab85d0ea6294f6d96b251c81d946a451138b1684b77f05035d7ffbedf65ab69c6a3de427b603a794d28bae295a8494da9872bcc7882e3c288809e0a99cee43adb16fac9566b2ede6545e3c5120481b2664e2052746c451dfb1461ef132d068ee74740e9a15749c8eed07f664bb110205445d0f409e8291edf381b0af6830885ecee82f436b63fb702867c300aebdc3f5970d08ff56d820b0f95b5ca837e430a4b055df30725ffeec9e9b41921b104e94e20e648c45ff6a7500ff5aac40f0abdeee24e60f2b0ac55bf864b28ba99ded596ad938bc6a845e4e93c9d1fba32acd7ff665617eadf3d4259f90dbb345f23447871efe39cd6debf4be267b6d9839a8b57ebdcdea50efa550dc1288f992948fca9f220156d6f99910a844ef9772e10d6ac53bb262cc064683a58f5f68d731af88596fa11518e5e33dcc8f8f403b6bcb757844cb41e77ede0a712cc3b3c2d2fc58c498f4b1708eb394c4bf7e9270a7a70136ee34592b1bf608ec47a5fa7a463449f8ba8e95718156cf3cc9481ba55d033737819f17000ec8a5e08aca4d8cb0bc08681226b29258590200f631ad712ced6d51e82a14da9d6236424dc93326e383269b1f63b2b7d83a5cdc2c768d76499914f2e9b5ba5049f1a2675c57f3f4e73fe4f6d7844ba75b2176abc45c8335c6757c581d8d1289892c281d350812926b83e0dd4a283bdecbbc9a13771682e89c4a4677163592d691f02311de8b6d9663d57aa10fa5b683e619394eaa6bfee089fba2e74ab0e9ffba2000104de08c21323312cb97b7bc35e88b23c3239ea8db07f45366c9056ac0181ffa9f6b8852140d842be10a3a7a792aef0b6a8ef24936861fc99e3c7893532c4df0488b6585615e1fb02777ba89b6bf45eda92b6cf544cd271253574eebdf1a9124120967b90e9eea62f362df8aa01f9f06ead0144b89449052cda96b2f2d1c510736196275988788292258aa0a435f85390d221055d0ed81d3734fb50be38b2497bf9e768d46a9bead5219a1ca5c00edecabc19896a6f72bfcb4e6cc09f88dd03a323cbaa175cfed8dfd7d5ceaf26d2a33746e488891b2aebb9666cf6b6a86ce25be91df6f1a43efe205ed50e21a28b02c365d0a47350b7a2a2b245587b701fb63036c3de77fa6aeaba9e60dbd62c9cfc04744ea06849f23a4a9247510dec9680c1821aeaae61675cbf5bc6a626b6f25f9efef081d177fd85f614da28e4eb939c59b6ae3c9f959a6b078e68cfc721af5944d8ccc28f112cbac81f0ac1cbdfc5602caf6f35a660899f84c237ddb59b88e8025346c13c8499ff35bcadbd9633c4d6d094f4929198677e974a9e72749a2fbb9e32b686211b62d96abfe20009a7303292708687dba4225c6ba65439ca3b460dc22219f78105f31d29f6d0e2557ffdbf78494b57ff36d447319de5042fd0e51b141fc96e5ceacb41606d746cfeb059734bc27c45bff923d1c7a394f2274cf417d0c37890dcbb9df78772e6de5e859a3ebb5ae302d29aaf7b8a076d4a91c885513af76f2c61f9a754ddd3afadeb7142a3d5343fd656d3c9368193700a31beeb53f1a8cd2e97618854155d4538ccc342cc7f0ee95edd125ee93d6ee35abaf65b0fb67c781d3f4a34748751e121f72fc19c7ee03beb4fbfd2dda33da5245f7543a6381585551a68f32469deffb955b13b1a8955bcdfbb0d169f3481e93b5c10cb2a71847954df52ec636a11b21477323c59c36319de3734dcbe6c452fafd4b3008a01a47c862c6e2564d39fe504fff723aba757ea88940a7f71e86a436ee5ea7f50f0d57bc3d08f0871c8a22b4d5b31b1185c85601c4d72e550cb4f53a28065e55c67f144123f127d2fa3a58f5621dda46a5cd58642107de8187444debd1454b7312b7601d18618b2a793b8fbba6fb6936b09231367c8cff3f61e7fd05acba9aa7ba3d5707e411f639a37db01659a4332030d73a9af52876da8be216f8a48634ca9323b8c00ee7612806e68201deb2e6764463a01f2ffc8c1c525e4e791df2660464eaeadd7bbb8a3218704fbfa267085ed1286390dc782ba132968faff0a93593edb356573d19575f7752018ba2c28854811d4ee8d0520f4b2465d5fa25b65bb6fd44b614b640ea10b8358fa697f7fc088f01541d92ed84fc9e7768e6f4cb493627a454c2969c439a77d3e159651f7c31b4f3cada9a163cc83732cf518a5b07d94dfaf0ad81fe542f3d9e9be62d21bcc43ea1cdec952b02af9c2643ec229ec9ccf8a82991cd15c0af2101567138042063551eb9e7baa17214a6e1ec589b36a49b8f73c473c7bfd522b0fa1c78a640ffb4e8e5f06c9870bb7cbf7b1461dad8652f657210d72e7a93d766dc4d72c00b08a2a2165c912549c2379b28f4908c66b32807f05e7e2fcd4410b114cf18b409ab76012571f636fc90aaeae4faf49a0883e58fe83603e7d19e079ae46698aa8a9b3b97d475ba6f956b15401ae3d093cea8685bcdf4b7988b276e668ea91161832d28388c9f306788850f8517320171da645723bfab38a7de1f7b0439587f5eaa2f1e3cda2807abbc81f064b6adeeb4b2600be379113c4fa48c30b45313172f047ed038b9da0291b5b0b1ea7f1f86acfe5c76d315e22576fed21ffecf92ff9545920ab4d4dceac91e89e0b2fbc2be5f85708647aba523fe1cb34fb0acb59e637ae90d2e934d203334cbdcc7108f266c90523d6fc461470abdbf9f02efb06869a742b4bd357861f27afb9a3984489660b1bcfc5b1da03ffd47268b63640f463a72de4e752c4b0807ae1b4a97172ada2a374434cc138a3b905487505abd74732ff93dba61a771658f0de13010877b7e53679762bf204b8cb2e8f78cb41b0cfeed3ddf8a2bca2465d7bb200e041d3df7a513dff191e35eab3fb03a7e481a13de5e8189a98d5af93e57aa69d6a97b30fd2f797ed9507c6eec7f33ce41b13dfe2e3cf58ed7ffe71dc8fe589171a78ebcc66fc45e9e9e7a10ddc2c8a0780a8ce00297be00e710eda9d55cc3932bdc5b31ebf4113af3b619679ad81bfa8218e9546022503d55484077130b7ae8580f329db7373ded89114a13e7cc2f7868c7968706ddd98bfb343dc46d5e8ccd709158677033b0d2718f906ecb67af4c3f4ad9e68a04845389fee7d70b4aee31f24fe9b20b3e712986f71577df4bfd0e2a90b91cd46f7361058e2b41d7a9757502cbfd6445821f6094e2e8efa653f0b67a898422f753734454c82cb0dd9d50ae393ec2e3f139ea15481fb57bf33ec4f232e5114caf2d520b2c711149caa28793301f40f622bea291df96fb6b88c37909b83eb3e1e2239408adc2c7dbf9915a76ba126f27f9a2a6674cf64d3942e5e0da8ce01f70e679da71ffea825dc292db920edac37988b974a4edd17d0af203b7086fe4e7a261b5c41da8c730f5e3dee048b0938756948048c6a3e157a884f65fc5358688304f53f6bd69c5ba5463f597e1946ef40c9eb293036b699b208ce7b2750996bba5edc82888b46824a35c9377dfa4dabb6851da6d2a7b10fc9fe721cb3fb07fa68302285976ca012fa2315d0e80b721b6fc91c26ff7ddb9d8a66e5cad2f230ef195c67380f5d5c8e19e8da4bf2652be45d8753eb9ac94dc984c4b0602548204c87bcf53eae1c77285b1c2d1df7bd165c4563df0ee92a8894b15e431c2e9eccbfa6d92c3d68c5afa370cd9dcdb8897c3612adf8509bf5b2e3aa82a982390e9d3559d3584e21204dec3d2db95de885caae91bbc1fbacec3d1376180eabf3f2fcb19e524bab3889ff02d0b1170fefc8bfb9a03a05fc7aef8afd2aab0891a9ae43a2b465c447348ad007a3c85acd20be2afe66483087f0a8cccb2d1755751e48fa862f2e051f190a66001888bb418bc2c3cd2c62e1986e8926fc7202d8b1d123e8634e8f2c871a24362c84d3eebbe87d61cca2c53542bc73c37d21a83d84c42e7e2a2ab23fd1fe367883386a44bf5b28ebd3016f51c8875001e25803d7b7420630c2c48a950118a2e1259077fcfe536acd65a8da78c3b772c946c00ca178cc0873ba61a524f9202a76f0e8082057a94d1d1ee05e4a6ca100dfe530920c2633f5579b25b7ed2bee6a6c720e001df82eed1ce6ea9dcba924f1f4fdd9d01f8e3a23bea8352aa97855c59131e9c6ea40f5b57381a92b1f373f0b29dcbfcc59077dcdfde5ca39d54bf42cae55f48be8bfc2e093fb8bf2d341bebcd93ec1705b877aed47f18f7a26720a3b6239fe0212b13f2082c9e041ccd94d15bacaf2a12d2ed442d4f4c1d6f6f164bf3a934ed66d750b612b2099877e9a73b307ab20e9c45d56a7d6747eff6728931d353fa05635974abe37b49718b7dc8362b2b6715a0800ddb769bf2c1b51c7afb3936c4ad6c71d60dce7164024f7e0b960c09f21388afa2fa7c97e13276901a386e7342e33c0b181e5eecffe03af5e3b2e5759fdfe8c9168de89b9bbf2241b6daaf2637ea4c8666a74ede9a3351d202a6e47171ebb246905c557d25c21ad2985de1d9367142bfe8e0f71c780c4d494c7cabc8404d6c3389de5e0a001a120b3ed053cf1dd2fc6e30b668930211c6b9082ab77b60ee9d44618f09b13b7b7c5f6796a03f2ada0fe2b6f7eba66732ad78420ce164bac333e8fcf2c363784925c8a9d61c9af17df11ddc77eb8b5df8ea627fc69f078ce70d9f614c8766a5989d8b353ebe25de6796f19251c00f269c87da8a7f57a7f7cad27ea7493547389596c0778016d0e172eb560c29462e2afcba92ee67008d1616444c66405fa2dbd3ce185a731a49050092e30a15c8fe19549f1af2837a828221ac4a15e2b804545718e2644cc516f90d915545c8824d18e63379c0e17dcb6687da1480cd7e0147825235f2f29aa3c9e8bc6331e42438b40a2436ede25e4b2b11105763d86c9e58a3399c1e1f7d9884b29f49085328fa4c35660d22189e06e991ea26c0ecbf5671a76f53c23b401ddbf7535fffb4e4057366356327f92d00377b58597db71eaaf098fcfcd687cbb27ec91e9b4b1a23bec25cc9eb0c844188c6af29e83f3c1b80f06af2d0ab10d8f793a66c347ba680ea0063387c61238a22182a71a565b8df18db0755c676ba6fd7f9fb4061d27c29a2a739119df3c298726630b7a26a5b9fc826c88a09de7c33d584a60583e41edff5cfb1af556fe21fcafa1697268374b82a81f2809c2bea56b59d2eaf23e50800642cdb1a36dae347c79a54fcf3b79129238bbace31bfeb7ec72b65b26b1d550cb8e13cfd11642394176b030e41c3464032da54d03cf621153e4d8b0ed9e8f4430be4b6f270902ff9135c3cf1b4fb3dd01b68c5179014179c2b332226d7d6ee3187e8c51800ed0e8cd08b986a5554103c332d3ac90544457eab95f9a07b264b7a4b3f0bfd06b4697433f1f1d8dcd0266258ea212692ab5b1593ce541720d6af30d0438aa8f5a98f815041adf82c5b37255c9a4c101166c8e30d0a356958ea17fde42de547802d2de11c7e4ec89644e4442edad21047788381b4c1e73573faa5aeea202ffeaf07fe6c3243199f3974cf1aa70bd8397ea9b2569893d5b3cf8b6c5af569ba6ab6fef5ba141b8d09e0676d82e7866b6f39ec94be973485c9d964afc75809cde1671cd539b4a5e810cd7acfd1c9a3a587680d908a8dc1ac7e19d857e6a2fa00f9148ddfc96824d8be2475ddefe5adba6ba3e640e4f4ad176c492c88d8ecbefac90f0e363297b6038be255bb50c1754f01da166e2c2707e5ba90be82d2b58ca6702f3ecc6a7eb34351b3a8d73f43b3d6c1b083d43d486ce0bba65a41266957459d1480cfe97da1ea1d1ead1daad49723427f2c0a588f3c5470894797ecf514f5358e2da04be0d52fde486e1e8371a605221af70d8d7278ab2296673046eb6882e7602b22c93b77b33546a20822e0d6446f04d077fea2b23fc67bcc460bce7ea611340f0bca84a2a0eafd6508af09ead58cc4df58c9e3548d4cba3a6f5cfb5b6c8710cab4d957f7907927cadbe0aaaa955b6854b054d11050a165a975e227b98b9e290f088cef43f97b7181227db9715becb3b8004beffc82e3ba1851f236b6e7ad4e730769fe8c8ebfaa567cd25fb12ec4c0e5271aa709528633ea44cb608b38fcb4c645b546be792a4ebe2d611ae5b4e372ce22ae30ace678cf1fb09b9bbb5b3d3e86f4384ee336020fe7ac7fb910e0fe83c5fbe4f9fa224f30dd7b0735f6728df2a77634019de5a057e3787a96929b284a125f4082b34b16b306544de4e2329869ea05ef43ac29d9aec8318d038ab52d45561c801f8d1f544bc73727e30519d796ffa9816db339a40dad50b3c2a7c1b3008359956b9a32888c9894939b71228489fcdc45812979b40e16041ac4c2adcf3b51b35be038b57d8815240cd6c219dadf06e7e81f3771d0ef7fb6a5bafa9eb820ee300c1f42fd0ac37e3238079498d4cc26a34b70658ebc09efc6c6f2bab79759b7731c23193cfb995deef3ad9fc742f7411dbf7d790e5c954ee6037f285a8f118d85648959cfd2385dccf7b32f80896cae86f52d1f3dd1236dda9b08ff42255a8a952a74d53d54fabae992592a96ca2a70dda4e556d3d51e2d74fb767e5f8c274bc3517f7aa420c9384914f11017cbe4b5c0762e069ae8ac3d4bfae78b5b7f7ebe9742f60c9a78284b325bcfaf6eb8cc127cb7fae9f5f707c5e9f2a62c629b6fdca7095e489f57aa52e6a5441a8788af9d1583d75166722d60dc923503c85f6f48a651a673b7ec02d347b98d85b5f6a137e875a6c89e274d7e44e7c5524d144570d8d93741b580262818c118002bf482243ebe68b2de6f757fd2f87884332974cc23ba16dd4ffa685227a8c58402cc4560e4ad9a61e067eb93cf233b32e3eb21d0246e26879091f406f5f9bbadba186e1d6c73736afcfbb7c90f9b06024a554d96ae6263c85dcebeb0efde188da8b20c26580b0328865c00711f608f7470e35ac3e9e34e2790f9a8739d0a5e5e4fb97bdaf6f010f89506556f0c257e021818148e80339fbae778d18cf42c49cdd1dfafd45fc17281d253a71e3a6b91937f0970a2c5921e3db1870d4f36cb00881774cea981b4430c185832e7f511adfe13105c6f5200a97cf431d917d094f34baf04f38c670a3c61acbdaf5f4fa95ee8538576cdf793f6ca5011babefccab831f67021e3d4d45c9caed1be2c227524f2ac3fbcda3008ec2f3d3727b5bea06dd09c8741e1a08be26ce93a5c23aafca5ecda9cd0538877443b3b4a85ae7e372a701255f6f13616dcd9761c5ac9c010df6d93424193d59de1c70695005020e9786f25ba93b3d33796c998ade45204e15858c21e092390478ab122fab37820bbca5db38ec73669e628a17920371630ae90ed06ffd469fad7601a43ad2d33b43465bb07dd06920757e8870a51f6d01a8e30abb85c14541760de34d092156b27c7a465abd6ab344d91110a94aead75209b5469b00d5ada6712bf19091288f37df8e6a796fcb164eac02101f34a1b1e185049828b65aaf87a52e012c8f0ec8130ab768b4f371878bafc6f2a9bdb36c9e34b4cef79b32a07790018a6acf4bf44c191b9263036a8665dbb62a290cb608b5b671c64c0926dacc7c9311368701238501f90f308a4a7179c91b09a46cd6cde881426e0bee62b92dcc93a082b804fd1c05b0d566345e0c6a19ccdb34dc0a5bdb751806f0fa6f3ff165c9a261abfef2b59a47af9f4427098a1db9446c16a98cf36ace412514c14e6bf25d0c157fe4063bdfd1c337bf68fdba7e67102b0a8966b4f9ccc462c1752cb20284caf4474bbe4abb2290fa3d9657b5b5281353f1ea08a08190ae390087fad81746c62e2896e8ae1814cad7771eaf44d16cbf04ebea28b7f73784ac0ef7fbf7702249d05ad8c43c65903c033543594d685d966859055c9a3af8bd1f8dc21ab9bc3b2d5db06e13593fc43e49b46e533e5491f1a85e2a33fb31ffcbfab0875272554bdc3f971282284fac0d91b4146a31b14f7a940c856b90900b6087db4f145357be6bed0bf9414a5e362902cebdb871b92379ef71f3cec93fdd09f466170aab37e4d0d9df344b46ec84b2d606d875f739d9f435a7a0f2cf4cd6bc83d8a78ed07753ae44ab02fb5eba7fdb04428186fd943229d73547ec83786a1bb10a1c3a2a4f34cb0415a7348f531948a6c952901e8724b03fa55c1258ed00a8a35d49766cd65970e02396c8ca3403b4032ff9157d8c8257f72c28adc88996ceeb8d33efcc2a2c301c9a97d9ffcaaea0ac0a7bdf004332c7e9bf5372a893a2238cd1012c20f5dbe3fe7a088cbfbbda372338007328bdd9c7924da05e77737ef49e9f158af6b1936348baeb4fec3d38a5b363cd7c01beea759616c7ea1cb9ac22baf2bfde2c30574eb3a2627e6ce1b27e14501e1820b651c8bca8ffc0ec64309a18339b5ccb70b28ef9f42d52df8ec9538f3e6f8198380b725dfc6bd28e5c1b0d6fc78f31c44585a2d1689ad94b7e03c26a10cff535984e6dfe0186508bb699a055c323bdd293e9c06e22344c7cff564137a8d63c73547af9557110a914a4fa8e06db0485369d654f8e06f4d07df30fbbae6003c0c1b162a67158faeea7503cf5962668ef123421576519a20fb5e3bb9b798ab3162a7e54bb0d62faf45747c623917e658071aea7022c77e82aa3d9a606733820e11ed7dce60637b3ba7ccc3b57f650c1ba8e338d60d52ac6b96694565c76d7852b097f9b94435834a52069173a2b150ed1d71f1a21edd8a42270eaad4e40a750849fc87f7b25318aff1bcaed2ba3bad758e901f1a6ea76e749673e2c699a2b4fe8ca34f15745a9526005161cc187801bfdc3a091bbee99469ad1c75b85cd1943a1c4783b8a8d4224acc01e167c6e07a8732d50abad9effc52f731d43a1ccf9049d9bc35e2f6f24814dd68b668b5c8446893d6635445b207d5b263b3ef7171e3a675d4a533704e84002fff826df2f09709c5903618019e6dfb4a83e83d96db16e06792982596278273482be15674c44e62ea285d781d7e42ce6ff293252b40fbab5d1039bd8ffb10cc32665b2ee148b9c0a999e5adfa80d15332bf76fd758e95eb56766064bdb8a0a0642b31ea4225c9f617fc80878e6cd3cf78e75c12a9fcac0b5ee89f1df658ba241e852220d0a6fc73f886446ccdca6e7ddb58238e214e755668139d297305901534be4a2f0766cec43addf0a3015d35cb562d25e68bd68f798ab48874d1fdabf9d1fcbe51b4ad3b1c045dd4d3ce39881c63c6002b2d4360253adb68126e041ba6bb6708ebd26f0e3b5c999da4b4bf2a7d64236441cc9f0f35f9dbcbc7ede9662f1a9bb4dd40c69f7246d836244b0528d709f2af7ce983a3cb80f5a352b176cd07c1c42add00c0fa7be480b61d286a468de0331f1d1045704d67fc8b51d901f067550bf0f6d96e22b483e4c86bf020239095c193a995c2c40612fc8cabaa63752c302053c00a925fc348f9cd9417e1b9349ad15db5152a026105f5e9515e10878b176ea065f5cce29594452d06489b6d884f11493b32744f196baa44d1b4eb9ec5d0dd27d719a5bf6215ef4ee1269d7b1cb1b93b4a1814d9a7a2289cbfa01dbff6a88caf58a5a3c72ae7fbe2eca1476ada2519e0e84f76b64ae63db6959100d6b49597be9cb6881751173101804e14a6b0a1512a86097b63477cb9bda2d282b8d0e2666762ce8f80a3e11c0a6861ec42244aabccbd25d667487a184e093593e318b0a3d516aa8cbf52f32f9dbb99cb0e8744b749c8eb44bf19046921eccd113b1671d5f3bd9dd49c6e7bb3769bc16bef55aa0878c105673ac00caa8e25ffaf19eae35d1ddf64ee678490cd13b6d892e6ae341d0a071f14f66091045251e33a92939e3f0907565bc9e75d9f383139bba7c762cf59dd6a9c2bf01d67717f493b67abaeba953488ba5fa0079547d78a5cf766e89dfa3265a580c20af8605887a042ec5e858c3509757772a3d5a83aa82915919309d8c5becd4dfd9e772bb6d05f84a57c61610d8616b85a07234c689c80222a815959b6b61530734f6bfaa925a66ee467c57552e5a8c375f3df0897bdb30c0cd74017d478925d4570395b9a44d1172b71b15c794725d4956fa80a668dcd072fa9a67810608dcf857bac0a85e40435a73b4e5831c1b0f1ad549202d598abecb8295c4fc8c494cf507696f0f794e5b8f0eca7032c1a68b72da9555802544b7f83ae6fa9f9e253413f4885c068b723d82f7f51fef7bf754001ffdbb99fd0a1256ffb5cccdb6bc84fbfed4817ce757b67bc5383c5604da3f13df15dce25f8897edf549958311c5adbba6ceedc47834b3b332f90879fc182c7f9bb9384f0ac98ff14000f4b04e286d03f7e19961ec14903821ffa014f6a28231e567d6be89ccc13811be1e44f7f4f421364470e282fd2c40153f9e7480949f3372df63d6ebe1f54abb361ba204198edf07d543cfd7f7d5a706653aacc0646f9e16fb1a84a25db2ca40fa50b53b54b567000d1dc9e06f3bb88542cefe4c8f97c50503f264f39ce69b5ca2d274e6e44aa9cfa921e8d58c7a42522273b657b090bef2f936338d0108ac8bfacf70c6a9a9b3bf71db248ab23aa4ee7f0dccb1089254c4193a5d2a92dee4091ebd5602749dc0e0ae927df1c869e4f08f16e262516dc0c346ac3be8c21796b2ffd7bf7a45e6033510c9f96459435e4891eb90efe66b5adb4a01532c81e39beb989e0ac7f08f1d9c2e08d667436435748f212f0c812bda60bee73104d5e9a5da705db9b31e0e6e27e3d917d62a5a42d3bceb49961cf415e253da66311c5ec140de7c7c2feb91b8e3d630b76bde471f6bd36720f6d44cfac573a1177afdd5aa8a148fc729dcdee4466ea0fd4c34a95b5c013f862d8d40b2b1cddbcbe685638e8fcceb12d3c167f104e7736023b79b32f81148aa72cd8cf1010f01666a8cf52fe961aa47d66b45453877e923c96f865088665bb548f95f2b43c32aa9c775e3d095fef39b0bcadaf667403c44f3f64c5c1fbbc05a380ef3f27105efcdf4450f1113f2e4c2a42bfa3c7ec8005cd17f5c6b61a05b06d0b8c60451631b5ce0e351b73c9633b9a79fb6ac0eae7210a4167fd43c27f79a2db8631de948a82c4f8467ce5e80c004fb03fe36d793fd6872d51ad898541e16e5d5150739820ae871ad392fd32ace17b0d1e6ac87067a6ff40dd25b40007556bb1c6b50294190092b9fe194f1b5fb4cd262d3d6a9d16db6a09fc37ee93c7f10723e9e3654fe7cd475f0c7db9f2e1bd3a8755040dc19cbbeadf915e21c5be25b2544f7eb7841618f0c6bce37d8648ad39cc7c523f60aa0cacffd90266fb86c11abbf03deb0bf77b3e39a683569979dc64aab91e7af2263e16e9830d89b1c3a64ac118bb1602ba362ee584bc6969a6af3a05767ad6ed1af35858fd036fd94f98d432d5ab887c45d14cbd9254db952b958617284d674351e3104e400133210a2fdfca5011330cfcf250caf79234862b4ca38535b2cc4a99279cdea8cda9bac9c64f6d86b913402370413c2c8d19fbb0ec847d3f89424a7f9fb90e79f32b2af7d3bcf2dcd8145e974c291048d15ce78b86f234b144b58f2c1e3a761a2af07d74d4c1bbba81302b7ff54c23fd4da2febf2af80d38422bfde2e6adc20791d6599963482877cbd609215e300cc0201199ad72d19864359fec4807b27980b671e9638c4b03c2b4d0e04efd9d4a7183f30fd126d4072ef24ed5cddf93e44cac057a2c78830e890","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
