<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a121d980db9eefb01a07fa72f1cdca603296cca67afd4314569922c0de50550b6e5a0354563b2e9cc68dfa6f6b7c64cf99beb46c6eb1d0c588b15e841d8f948f83e9552d91aac065a07670e7d176c07cc0392fec018bc13ed77d76c8e8d08836b75ea42ca1f351fe0bcac9e0e319d0bbae109cd4d89e59b33f7125bbb0f2c1753bdc73df6e807ba43624d1eb3e146c8f1bf412819fe5f6a63821bc6d5374827f9797882c54d47bce1692d8799b3cc58d528e3651c49d3a3c82ddc7bb3e5852c8389c5c6b164cfa8ebee00350556fef65e9670593c781a19be22c273d3eae37625a1931bcca40c36d4bfd1cd3882311405fcbf22e05421fd176a6c6dd31876e11a94d605a16258d424a96b708870b766489560a3d8fb692d5425e68a2ebb12998351d0cbc5a162486448ff190fb83c8aae4489b78148c88595fa1f6d7fcde5ccd30e7aad434fb6e539c3d0d521c55496eb68e8241dd16592d4eb4f162a90c7c12dedcc230c5443a9865ab7eb0e8a24e35bd9e69c6c577dff041acc0051d42ff2b0ea7e5c86a33aa719d77cc224f8c76ffe8996c4de870090e8510dc1a77692b43c3d7f49f914828b980a12c0a4b14f00e7cbf4dc88a7ba757a4978c71c14f5d70664a18be182b8097d6b9b8d40258f1310323f8d506d029cba35c018fc7b780b36a13fdee43368330126a2c6c90c5a281257ab5d2b35460155c282b229af87602681c92582953b27cb4bf870c375ea2001cb96bde89de6d0541a008038f50aa28f953f8b54ba34c4903ff31f2e95664174df4b52294d35b2b27fca56249f2b2955c387dd52edd3895712b11469a4f87b23823ce0bd5e3680978c7f6af104164cbb6bf6756c21e465f4a1fd4e77262f3d199fe5e26d0130135c720a6f335e488cb49fa8ea45e1effe274aef996020701bf7aca7d4c7a74ad37f63a3a9f76ca130bdc40cdd38718eeb38519f92c7bb5cf06236f0d89617186826829520356c65be6fddf17e0b5895af7dec95b9e162c672036eb8732d088560198a70a095dd0f1399fcf485c5c58338557e451c0548be3fe54a12be5eee1d450fa30801395fb77366af66aaf56050df9ad6a0531c2e1469622189b44329199d84e4ca6541cc8f01e95bcd5ddf2fc7ae372b3bc289c9a05140f6b7ceaabf615794bdba7acf7b92bfb97eb3d5d523a6d6bc7ee6f5d1f22563688d1975b49bf20b661f8bd04e939b2c39afd621a2e51ee550d47e0fcf57f833cb227f8c8be75c480be1b0f21b5d6c232db05da55cc5e7b406a15b9d482f6bd6fff056e88bc7a6f4a57f26e8336d3e5878df69b9fac53c771dbb62f57bbe4c5ed361860d18cda16132289b9a18e177f8767604e69bf798fa35e218d654af95780ec4a96f224f5be071d57caa9557800f8fdcf501c66604120870d64765ab5418396b281ee0348ed04842eda198c8dbda73b22eb43277cf37a0d1337b04e7041ff7289a100905d326c149e9fb18cf438d2625123cf6739a693829fbd9dbf05a9c331919c721580f221c25766eb3cb42ae0a70836512ce79f766ceda997e5ee9514d4b70a9b2bfe3fe5445042c0a509871112cac805d67e0597fb08f5104d3acfb162cb975a6ebb5f9799a1db5da5a3464f14710715941522397183f9c58a81e946e9848b8afe70c3aebdda792e01ccb33ba702e4439713e8ec821b7a1b8107002c9a2818ae4ae49315299b532d6f82d89730177660d570f91c6466bef35792c0a9285d8e9c121f5c514bb6f64c8c0172a7c87fc8e570d61e07199d56558a7e0b5ed773d47f680a9916c2796d29699a7c559674cb532b15fa83489ced24718b310b8700cacaba01d9ae9d0fa07dff96aaee01ca7bfe2514852c6cd575c648365af4287e8cb30e86e201e604056ba50876eca09639795613295760ef494306694ed2dbfffa11917676e301bd76b1b137b72b23fceaa9b9ff944a2451b671812148444f542e9892e1bdd3518e632dfee99eb5da36a969e4113259645ca768f7830eac1ec24dcd4a7d3e3124d965a5d6249e80f08a33c9b4cda6a5ae77f3c528a6a99577f1cf450d9d1ab8805f79700484077e7a49346f610f5dac01b3f60097b14ba20bc74b81103e60a359abe8da339078511a4d1037e99ffcd958373d0c0f8b60231bfec451cea12a0124fd979aa62f97f4645707da0192a37a012233b6f7d966a73ac7dae2410b61c9d58db9f2f8e689cd77a219465d5ccd4435a8d3064deb05be95abe31cc054cd81ea17c127411e852b0fe8280a6784bb898cd7df08ddc85d7dcc81e25248dfce693f7f080735ced223636ee43dfc551ca28f640464119d6ee0c0bb238329ea3869f9e9adeed0128d2d7cf5dc174d8a3182a9d11cd031fa9e2ff0fd1ff93fac1f2f84b333ead0d05cf18f9da934448fbbccf27cf9fd1d89dffd466ecbcc158d2753efd9db6ee0953c140dd8ebdb844e337e0c6b9b6e51be97e53d50543d70c3928c2b7c5689757feb929dd35b64cdc503b7dad98c5025157719fb73bf875225a88d03fd4f29f89b57c7e64e0fcf87c267b4150897cb400397ef74d12a3badb621ddae4ca81fe95ef6497939aa16486e9e03b8b78a40c2641e36250ea289f5c0e92c818f5636b7ece69e15c262bf38266b563b7044b00bf0c562e1a302458b7fc010467268bdf9c8f3ea962b5955a1c3ade2764946fe4cd46bacd9b38c3e7671ec81ef858ae1b7144d6a80544816f6938341151ef4129e683106f3b378960a6e56bca9860da9bb5aa738224e9bec89f46db295eacef393a2dd01114566f7965781d2ff33d7c9faef736d48e298c6664cde52e27ca8083f888f2a246164b530f92a8e7b761cb522a73933872e32d18d478b3e1a61dfe20f77fc0bd25bc4039bef6fbfde21aa5e4ba3e4aa3b590e6ad50b430e6d31764c9c45a13fbc7b105198a70177e27968ded703fc5631a5b372d9e0fe8c1b21567d0399a5d5ebae54e553ec6056e06681478291223ef1aa2f19ca78a4977b9a2cd71a7acad344ae969cb800ad53eb9812ddcac8c8dc955077de87dee5cfebade9149d03e5cc0a93e102c11128192b26a9d4c1d0c51ab9c989fa63b91177e849d5387bbdedfa9593d35e24299a4fe97f5c9c11da348e82a8fc77d12067c558b468df6cb5c45f749e46d01258846b7e8d8b816d220a477031e13f0fee5ce78b65c209fd9203c0ca6c104acf898c5782b85e1d68ae34b8ed1a01bc3fdb1421334caf08bdc1635b2671497c8736b61d9548b8b5d629944fa3d1f037c28a89f0d296fcc15eb6d5e83f9df6fb4f4694aa1df0531ad79f92e3a2e22314e85763523328a4d577e8dab9f962459c0c5094b2892cd4227182b307ffd03c6c0978bdedb41e07ebe9d02724693c62e99311b326db0e271a3c161f0796a40b92a010334ca02fd0946939b0b91b10891837169118a9a28ad98176fc2305d2a21652b6658fe14f5d8dc3ce6156c7a8acc3b14beb9ba27f622c95d53ab9d78e7b7d4e035911787da0bc078c6c20f2013b57cef4c0aa12c96f905338291e95f860b14691ca46ac4bcbd3adc1e7eff5c14e6f2e2aa91429da7a13db94bb84669d6ea4a07832cd2c0b0445924a9fe5716249c1cc7ea79d77b4b1c6de922472e18ffa2d8ffefa64fee3f0e4e5637c14e5de5e457aa01866d44848b7123a684ad88a71c57a29ccdc36ce0260ff5de9560e2a34549b517becb1febe31aeff838259da3550391920ef47edc1e2e5c4849624f3793ba61c09d54a8ce38f8fc92fb856e311dfa5be7d789e590d4e80c295c2377fea45b8928b88a7b9a5cf26c5ab0704b1279caa4e5b9d37756d2baa68bbd72e5586f466b47d09696d0af9f72be18e29efb0f1f2c1cdb2b5686e4188873e985a69dceee9937fd9b4ae8e8dc55fbd1db85704773f7084e972e9742a10b7898b871e3227f8154b4bcb39939a5554373294c26734976f31fe99a1b265c2ffce6a5ec583384c7786c6a7d8a899ae83468b541adc9ab85f7216b0dc4bbe4cee1be74699008ec2d356321032abfde7f82884417f089f680f1b97f8b18fa6637a84b993edd0b5e9ccdc48ac03f41c411883e5fe288e9c916cea1cf961b31cf02682945e2af159944896631e6f0ba2ee6d828172ec159c61c34760d0009f28e59f465f1c0d7e885e4b72ab32fbf9a8171255d7d645c6afbd1f988d762ab1f2af0b68e3ae4bfbda3089262199111845677e436ad1e75b9b80c0bb917e489bf823d19a12e5018daa823f467981a909c43f3afec038486898f9a0ae2f703376cfc375101079ddf1cdaeeaac4cbd2708cdf02c5c7d2948a0f97bd9e550c1a17130e40f1cb8d2f3529dab8b6f86f246057de830648b250784424ae6d7ebe97b449649b7d898e8b2d351027d3ddd94320440f8528a0f69e84d4d8f02ab8c3f22159a2c6fbf068922f6b4e1e59e3ca9b40299cbbc88f495d6d796cc8cb5198edb9e7b3a9b8a581c7c516e1c9db853b35e42826b10b43a65728f3a77b4115d15f19b21422bd70b276d454a9c96b3464a98e8db5c2c35918d88432a89e3d8fb51b08822e5d376dafbdf755324e57f714e35b60953e4f0c6f09af17ad532634540486bc9af9ac7cb8a14dedeac3e963c8e02108508a7379bbd3c68e3f2a6a1510e9cee6e05eba9ee5ec811efb7d1f9cdeae31f05dffe072b55dd94b84b6acde7429a8cac29b7d2634c34b7a97653f14c7332f23568baea00c6f2e2d9a263292e87c682e57e3bc43e8677eefefdb3d450965ab405c05ebd42673eec9107f624204b19e6c29d71383664da7e415c392ad6c491c7f37c1a70a405368c5d0cbc9cabf29d32c65b67a7b530331d67339d02851ea15b13c9eef436cef79a95318b8adf95116b83601410659e2780c976f04e224b2c8edd66633fb86d56173a9f823bc472d9d7089975f9e614ec7a66d9e91f8e79c42f20caa891e4b47464588092b36b01276a63b09006360d0a0b5266b9032ebe075120133159667e8a6152f6f0530bdef9d7961438315795a0133cb4ba86fa044c24f141cca626fdcb9325b8b6456005910aee04b5892bce566cb46ab5c2b043d54b63e3419a5eb74e57571012d8e427c61cbe560f037b6905719e914399e613b056c8753b57a764b6e9e89128ac3da70639b0b856dd5fe3272da17defa7fafb55ea596cf95ccd98e89a2b6e462710cdb1435c0e782c1e36c5b5b400971f198a351bc4aa6a65dfc58a784dcc2e6d53375f2afd261894d1b00c9eee6e5e2d36ca6c894652331b67360c6fec12edd154b65203587607e8cbb16b198fe9e4eef2f295a3d75bbfb4d59bbe4cdecde14913fd8fbbaf2a24090b79e3f022b6108a653026d1c7023448bc92de65b22e7299bc820799df5e4ab97f6349cbdaba378e190287d7c87d19540bc6caaae4f5344b31c01e9f1be5544010de9fb770f53fd28f4f9e4e81408be54d884e619994c97d5c37f4c24396f19df91a828905db1a326e072be8afbc550bf6510943c9801a727af8d4244bb88757f3d3952956af28262f84d2d96cf96c74a57b0943348e4fde012d7a5a6d014ec5d4eca1aaccea2d40e80108a6afaa63fd4783ec42f8b956f6239a980805c84f81e45383693c22e286d7a1c38c2814f768d86f8b0f7233f57882e5a4d9b818a1893d6efcf12240927c447c812722bf63cdf9b176a992bfa0f7f46829437700ede27e2fd9a41604276830141d8b20c2544d751e1b8a2fec0557db93976416696d458f2531f3da3b6fb4a3abcc7e4f570bf253080fdcdd090c80b9af89af5d96da6c92c70f7d752e58f1da777d9f3a8ddd356aa5c7eae758b522c93f83cf3bdda4e1d919e93579c51eb7c8e8e1b713f5305282f41f8e0db1ac45c4adc68884914b1243352df2375f96d70accbdfd04a60358e8ba6948b93dd8285f226f8aea05d8c17322a6e7cb5f4450ee9e3f1afbafa74f539d993645b0b9d3b976595e234cd4760464bbba100ef69e016350774ffd33e817559f51ad7d8ec7d89d6f5ac0270f220b29858e2d202e831162a87c4c82dafdcd4016359e5c1d9f8f5aa98ccf748c084658218b8f45640f6f37fd40a4d76b85f17010edd7d8d4ce5b4d9a9a899b2c57dbd8037d1c70143aabe3330838f4e85978246821e400df6ad9a57fe824c71656a5ff7736488575349053323f19569c49b5388e8af91ff71665dc5590187748ce1dcabdf3901ef01a923b8a6118e9dc96991d59d24caa88af8570c886bb538f8c12f37dd60b26d207a65ba8dadb5bf6ee205c757eb85590bedf051c56bf4f6de23ca6c1d8a9048a7358fbeb751f2fa91f6116eac35184039a02748559f7406ffb6ffa7b810def58ebc68d9cbea5d2532388f863444e82b25b69855dc539207f9a414e86988e888dadfb342c6f4c98b7564ce33c72a670acbf0d862ecb301ee71067e0457783c40458f0034c48f9df4a53798f215a28d6b0ee429ad8b09a2d040d61866462bad5647262538fc4d9abc0a4bf09091e6c5af6850537f59e3bf4efd3bb095ba593905e04745034950bd1f525ff4be5166bc64746e66db12fc652e71ddba6de44e3f3c57da880fd57937e9d3630100846d087d5819090f0f79a8a8709db20866fe030debaf40430434939f7b3b822e540bfd99be5805516b1b0639a637aaf85bc86676a25b621ce625ac0ae065381f3dce6c4517c93921ef5905361471eb7d79b329f5dfffd2c5acc10dd33d67be1ceaf2e5c64674c7b281b8ba1d718d6996ad27cfc43e0b9ab360f0d21fe35017e526a533c4963fd9c8217c59f06dde922f61a9c1fae1eeea76896c007e0187cfc21508504a01ccc7ffcd1f46786c63f38baecee268283ec283dd12c4953ffcc009b790feb4aee7e662cfc60512eedc9ff68ef0a78474425c26717eec0140c634979513bbcd69bbc6b6ef649a286943a7a2ee8a7af089bec6ff3c2c444ded028493b62cc895c01e6c93747028f1ff35c7333dc8aec253d6d2ac26399430e4f0694a436bd003078e5b5511a63166e53491474b1f0695694a649c66c4179d3e4b511525b7329dce8edda28eb1530c6cd01388ab18c90bd71e687b7e7bfa793ef3605d0734e0aa3359732b7671df1c2378f193bd352922cd1eca9100333ac0bc5faf959581b5475136e196ac1267d75b7f33be5a14a70a69be79a82a1d84d0ed71e48f8a5d9309fd76ab5175052875926cc50c5ec4f824136304ac00f8c99a16f1f98305a433c7bb6bc6f79e1ad21095346d18b4d970c52bc857a7f793b9922733b379a972ca843878d32a3cd771da7f318996b1669c3d347ef27540643b5822b584178c814d1ac7a6d06b7c9ec6e499c12143a2c506c0af440067e1eaa6ce32a3f8e7d32e3483505bba9f5059d335603289caa18e5f052f20548bc18d1b762ed4d6506177dae33d391a7f5e1299a6cfef42a081ee9901780d7c6569f699b971d041db9130d5efed0e26066c7968c9bef4fc74e27b6ad55c911245ae76fde02ca67c0e9a70fb65564d97bc8970f0c0ee1e8f63555e708b0c7d5f420d90f96b2537d62faad343ef62166e6cf0a9eaf5c0442e789b27b08bfb4fd80e3c951923381077cb5a1efa7b83b601f57ca630bd1dc5897c20845ddeb4591e7136847bd14e7fdb8c3da46c0442d193fcb0686deae113704b38cc79c4d23310a1e4e049412956b45e1fa58e3476779c88f2f028d3230b952f3ab39d4b0f943f1d456f396c9e5bb58ad37b863c9910a6e4a599c044f878656b4c03b202a6df8e2048d80d5beb0e19d6b6fdf867f967eaedc67476d306327c29b2c441fdfb4b33ef1d3b7a62c965de0ac49725032d6020af4c0452b0faa4e9718671cfbfffeccd8c8e63c99a60fe9d8b12b20ba90f24b47809f630b43b0b74ba69d4277fe2c8dc0ffae0ae9eeca4ab879221adf58be89a940bb9a958b8f6ac1c10870c6995d7c1b242bc22b72af1f8d58041f4840b411f43ea2638e42f5d8665f6e0a38e71d8e557444313ced4edf9237fc56dd24a01f5612bd6b97204a79e685144feca2ac865c73222dffe9c3ef61f2f5613f39dc38449c0021879893bd3dd62688bc727220d61c458d19adf5c45e01a361d8ed8826e896aed999e3dec9793b09bd426e6441fb2e03ff4f963349315e2ea5f7e5b5ea2e79f1c4c3e734f0cafcfb61c0b6a987e8941b55e680acef4900ef8647795dc447830d41cbbcb43ddf03b55c9c7f4c3ccc72d42c57e3b1dfbd1f49c5c3d9546eb5cf8c1a3344a7b64d6fddc2936a68e6674782df7d794f840bb8d3fd3334c2f62603c586f488198ed97ea0203c91c5dc9b1c741c6b2ce843f0dcb1f13e759bf9f2692db68c6f622e08297af8b5345b00bb6cb5d05764f504ce79508143ee2773e3b02fc171a3fccd4cadd79315b6c6246de740ffc1e673c0b48d97279cc738eaf754ad1fce600d02145efd52353fed577e8ed1451a075c632766aee344a287d7fb745093d2e64493f1a2261ff01f1a174370995136bae326364e47d1f58b9bf682c8efb7bfcf31dc50f81d51ed99445404d9de0440ef792712ccc7d555823df4f6f12791277a7e20732a7393958d97d4e2f61ea9ea85c877dd2b21423b6303cd781f8ca2210d549f493f12b75a1a20e460b138bbb26f8d210351af5f3be79ff8926d320ed522b4edc2663de2677280aa83673f299f650a096398d9b11f3ed3302c2fa563d03639c7c93a4e7cd0384d3bfcca2e0adae73d19e9f219ea46eae6b6eac2334bb992686aac5dcac1e20f281bba3cffef6f4793a6f06bb02a1bdccf70bcc4d4198dab93270344eaa2035d00e0ad3c1b3a0b1aaa0d76b79e8b8db548fcf80e6aec197b2014d0e6530ffa650ecd95db1e90f8785658fdd98becba8115d1ac95d7fec04bfc7e06801a38bf83e4d0a1f5f974b339b6d602cc89aa90565c78b3afa2349086932edf67ea3489cf36d92bb7b76027a91f0526d4f25f283dd9c2ae123c6481b07fefcb0d9aa428304bb3d109d0b441ab86ddcdfeb435e66e5bcaacf945254135d8c822dc04106f46e94f03f43a590f61b2aec94f70ed2fd95d449377ed4e49bc625989ae7105a867b32b5a7aecb75a612f6fbeed5ed75430ef3d244f16a1716c5cb0cd3714058e4e56a834afa2a136cdb26830fe38a94186b3fc32d59201f60f98fca26b9bd243242965aef0a46bb32be3856a3ca071bc5bebfc4c61b641db8b086257fa457bf36d7b08b467a5d970a1a2e1aeac5c1507f111298b2764efd5696e12e021b4b50ce2c29e6f13a07798248b8ef26140a169bdffc4b796043f3629c10b0e697ab14a0575cea9e8e356b73dfc7538afca7b40754c86056ab81d6785d4cf0eeae62b4394c2ff061c7d93613db99f0942be67c00c5f06981c99abf8faa4236a29e0013a474f8544a077ebbb11900d4fbb30b687236f03bb501c899b38ddf48597e14ff28e83301c8070e0148e7ecfff7ece37cc8533d0b225a9bd41ad8fcfa0ebc7aaa263d3314ab7a806f12a3faeca2d16cc0f99c951fc8fdfa05ddf09c5ace9f3c7e6cb106b6315085eee95d12b01b76f441d7b7ab96c3a71ce3c855d7080b7b85bb1f11335ed52f2389b72cfdf31dcd857bd3ec36d0fa4096af35b4ff6b30203256fd1a41e0c3c77babd58677cdf9ee4ed6731aeb6f451e4d65b75976f73855a051ba31792d7a8de3833d461aa07eacad1d559064f7790e4ab84de9ff99c736653a984f9ac20b5bbf09493293b895a074dc533a8a4704796dc68436202adefb374df9bcc8657cb22e8122d736ad013d8d70827bab70dfcdc00a9bb5287bf89968b6e038da254183ff1c74d8f0ae6a4c56fff789d7ba3e8fd35a49a5642b5cdc89129a6aa7a08b62c77fc803a64ed589ae47bb433f93c317aaf591cf61fd05c5887b818bacf32aef01f6a491fa4da488c548505b79fb9c25d0eafd8af50c5576be360bb41c1579696034c555c6650163d227ea54ecd5a68032825b6f621eec12a825e93b81ebff1ed8fb5db801a7ebb20f714acea7ef4a02274d4816071ee882dee215317ddd432853bdc9067c572755ed582dc0452bdeeffa05ed9bbcacbd0b121acf150700756537d99fee8b31b8db0107fc223cd9b2fbcd52a31807554e3bae4e7953cc894c11a145b3e9cbad0f235511d9e5a67a903220e60d111cf9defa87855eba963eb6745f5270053f296307080310706480ed1cfc5f2f7c9ed194b5bf045284ad6078a6d39781185a8e674e0e981ef21a7ba4c0da2b36d9a02628ebe21a81f981ec3878ee1da9a6d06c6f3c74a3c75de09c3e77481afa449632407124ce5a19b43ea155d85c172f51cba410de8714c5d534c9869e39e7c2dcff0fdf705afe38d080e2bac24f7683b8d55352307a82add6c95d8011c300ee3ab844e5b33474d99e81b026b2d17ad1c7582bc0ecb5d92c317efa2f02ae1eed80b07da8618ef962e0d6e010618141f932823b64d976c8d8bd45c917db5b4620e40c3437ed49415dbc7a7efe5542b1a63eb8dcdd6efe68ea5a337fcb5ff9cdde67cd2c68945d54408b2860e9cc6acf4192e1fedb9471c1576436fa8882843565c16c44e2dc2e93c1df7ffc645a8fb90552273214051d08c5d5f465a79ef8eb42b3d7f539c04b1e15f2318aea5033e5cf2fa55e116faca491d197d1de3706ba1d8a9768d7ccf9792e2afd0ccb93c434ed945a39782df8d05d973201f50bb76dcda6b666d3e3b929f64e9cd938b0afabc9f93358c5f139d420fd18d4e227819244bb05f7a3581f09d3b246c4261990bf1f27318d54ba19780aa2786fe17d11645bc0e72b0022b841555c11dc47352716b96ad374497f65a3b4a8a3682187ae2db5287a6040193d57c2670deeeead57e116cd61d46609cb3160de2435e9e2a714b73467b781ecc30bb59c11e99341bfe797005859b5d7d83c9c1364c9d33cf2659d50a8095acaecd11c89b92ab281b662b5e68c8fabc9b2e1a5f942503962153da0709e278d1b0a296e069fbabafda45dfe62e5a0e96568131abd65366868c975b773cb8317aa3fc3c8f33d7babece7556b3a18fa2a981f347fba282714c777097ae32e9e8ce38aa32b63b84bea2b693412f4d842fc267b50b0b674468898e370edee034f53b7bb42c228502f2ce80e32996aa5d848fdf5f5f7f905e033182d3e50a31cbf5c2f80614384df53875013297ccc59776792d9dc0b2fd25400983c05ebfb82cc2eb3a4fea02d9d5dbfd64680d4f692ae56242d7e3b6247a41318d289cb5fd22b787f04a88b7feae8266038250b2e1faf5e487962fe9e2d84bfbb1d3a085165515d6a8cc71a5b1ff52780955aabc8c98f463a72020cc23b28dd1553246617b08bfab534c509847c6684538b52110df10c6bd4623b1ac85b25bef7cc52f083db67cd51938173186f94859fe34e17580e1391b9e3a5b956fdaf34a48f5e7ee39b823acb66fe6b9f613bc02a79f2aa8ee40ddcac57a5197c30b82c74ee6e3b0f9bb16f2722d489d245f5fefa4d454e617f37aaa86515d906b00855883a0c38d20210f28541528540c033b00565fa707d9713496a34913f32697d0912a5e804815deec903072b226e2e2cb6c294ebeb702391c556a519fd677efd16e9ef71ba68c2bb793cdc1df7ec42ef799dd2f71eed2f7aa62d5dec5a7c054ec21b98ae3a87e508e515aa68a10c128501dc19ae9fa771f5705f66e04104d17f1643b084e307667bb50492bc4c64cc683b80f14c8d35774b0a9297167feaf3dce1933e83b41583ffb4414f88b2c073d5be83168f2b4759ed37061f37a00449801a7cfb7dee2bfb4783229468f58d86cb4116ed403dcd23538ed23e6aadf21314f220dfef84a42d8a32d94aa30e79b6d7ea3a42f3f296fbbba400d98646b9da43fc3dbef4609733aafe56bc7da10488812c6d3b3d231aefe4c485d102e11db45c53233618d465c57c35c8674fd5254bd34e10e67f8d38b18bc2ca17bb428661e3bfc76b6a870c2e58718d5befcf6b16d05306308992468920a87ae58ecc9b4fcec6e5cca1185578d68c591cb4b61f3c835b857b8fac61697e65ae587dcf3387d2d456be6801cd8c2cd0f7de03b259bc6ce6630481ef86b4b29a6f45b716241fb39707ff25fa5bcb8e673e28183df17d242c677f234e947a8e2b7d103ddc6a7ca2d4477aa9105151a0af488c0fe4e8792e549712c9a0bf10267909bc4d40c036ef2a63c4c861b2a27154a9a7e46b698e63e32e476de5ca2f0dd554cd78d60ac155a515610af0050dc9b1d1a82391ddc1544aedfba8b35cf001bfa7fa9cb16d67288e161b8bcdc25e7a900754594f2ab284d682f7a5f59c1f540f4ae1ee8421dde7611e7ebf8568be941648cc86559a9b7ab48db48e43f7d19036448d4e77c1be8d56a66db25858370583b878077bc91f0b87d2130125b2415c24da40d063a365624caa8b15a832215bf5da2dd1e664114e1335c5c22b992db40b8b00876cdbf4ee1f71c5c1f17df5196ce4d3060f00d20a8061be2cf74d913236f0c150e2d93128d81d17c8521f85bd84f3babdf9e571bce6fe953760d15903bd7bd15f06e468e6e67385623358405dbf9bce64c537991c1c7595fe8868a80a5a19f3955cebba3d2fa13001c84dd48e061700259424b9635c09ecc76e10ff31bbc0e7d2ea5d0810b861773000913db37f620ff214ff057730d2c958939bc47d2c6c7ef30d6e5e93adc04def6a3af1dae5658db1e04dae62b2ed213dd0084f32671d4777feb6532c6eecd1f80a917ccbaeff9f775dd8a1258d793f5ddf0a1dd48800d96498dff18ca35094dc9e5b785b2fb62f2da314abacccb2d5a3e556d14071dd401bb36fb57a6b8a98957a3c442316026f5e2cd7705bcf4d0731347d12d9975fb5b2df48cb26f058f5eb8ab33a765f27d969a9c47c2a9b548b42e09efffb43970531889863890b05c166c594994eca174424fadca82b2dc9bf3abc869fefee9b0301b634d5ee833db3908e551fc09affc2525d3d7797591e6abf060758f4c2085eeb326d784a1b8110227d8b6d5a3b11f28716d98cb2fb935349bd09a3d09179a2f77ff6131ccca6a30df6da9ccb2a3773f58b5c06283399f8afcd91b7055425453269ba72d782132d95f8343178e6c726cc12bd408c1f086e423b0225e1da0bba0f8bea6086c0d6c4cea73540375d265a4c961a3b9cf9b778d4200c3924923d48fcec122c4f6c70373114d7607870198ee512344dcc544cee55f62bfffe816370c15d7d2890956fc5f18fed2401fa92826b52a0b642d05e20d0ad519cc68f585c87baaba3668346e8e8d16b6a6df1333788151b90c1ab74fdd71221ae9bb882774e31a8ea9e9be52b45a54ef013c1a9beadc09c5226fe32b42ec51f0b4477a29774e5442d2260188cf942764c708d27809da4bba98d1191d78f01a1ba5b63a664ec1d3d21715c4e98962e788bdf2c3d0a7716535aac686b80885ec49906c969628d98471a7925c1d91985bf10e8e504dadcfeeb0789474be1002facc4b2303f39f3b9f88005f4ee4ba69a9ae0d197bff19b92d7fa2623d5f1f9c7c0745d3473005358ac17023d7cc146d7303c933117a9faa6f19bf166d899952ce32dce07db4f4f35ac00bd03ba0456f356ab05e9bd7ce1a804dfc2695f493fe895f3071d83d8f5a2b20e07ef9b34c5449f4e74d16a704b9d7d7b182e0c28306aca0c0d9fe6537e5cd0bb962f241888ccf91a44689fbdb662545a02b4e2862c63a437ce6af5b396aee4c13ceb411acf9852a67f5ee4510243a4b75a45bee702d1d3d6ea5842f23ff35277a71585318a72a5d591c8e23c7277093dc5dc32cf39d5c9e04bdbccaf23893a8957a1bfb9144b75c8dd3a9e6d57c428a34721f4f11eefa23339ebd1bc8c6d8a51829e15003cb102e9ecbca5394cc7b715e0b63b91b6e23db1322fec3b85e7a70a4c1c6987b47c0d1ed2deefaf3d5c563682ae90b4d0ec39fff482b8b2a81aa5e9e6ee0e3adad082843dae9b7241aa09703f1e6be563eb18ad22b4f31f4b847f8138d0c2ec6c4af5d0b3028e8d0a58081e63e915dc3c6355ed60cccd4d75b8c58edc0e121e605ff97d42d0a7a844323922c8c3927e8d619c58e0f5de4970fe55f6ed3ecb0c6aac3e2dedec76e8c1b68f0663d8ddb46541823c385ef62b63946752e17b4f1306490f0009d217f4446b213680c1901689ccde903718bb94c0e447461ea63a72e8a5d45191227e773c33d61b468afbbfb15ec800bedcc6032e237db0fa9b8ea4fc2817f1661653e7c908a0ae3063a75887a018077364f2bc2ced3a776506c6bd91921f6dbff714912d63ab285c6759cc3b1463d26cd35d5df33bf3e475a03a2fa26c615fea362b038b8f4dfa6fbbe5ba5766b376eb783a72a7f1a5dac9c7dfa41df37aef660f0f36a50e97858fd4e95071de4628f53e5ff745e6d33b026b3e89863c54f108a0ee5fb29963da79ac129f949b83cae969a36476a5f3523fa13971d31ed3c9e6f8d4bb35d1bc45dc5f78067e37339c69d5662a02574e34a5e469492c2d85a0886e9f4119c54ecc6424775389128de2f82bcf118b2a625a46c66d73b1284b317352b2982c13d8cda4444dec02bf4e117f5be590d4c95c27b4dc676910ccd366cd0194053b8a15da243d1b56370b8c8b198d0928c139e9fdf0d56eb9548bd5f7d68ddfec1b231780942700cffb85a7c3ee5ef35a998304fd74d6ad3fbe51ea707c4a0537f11b47c09930d38714f71c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
