<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ad52a28d0b5c9949c66ff60cc75602e10f439ad4ac17ad5919adea36e849a198540bed0ea1fd0a4dfba61b6c9fffc9ae2e084d0cc34978aeff0af96e30567b2101192f17fd6163f492927f53a7a2625984bdcf5d9108b190fd2028a02faf6395ba95abbbe46f22142e7445add468365db24f839fb46c3f13cc52cc25949016333630ed524158a685a1c6e636f865c7cdd57d8bf5026c8cd19b02140d4c4413fcd77ceb56a5a3a3558b2f5bbb2c0d5325888c874f7c4769baebabba504e2fe057b16941a88deb0e6d5758f043b1154ae18a47d6760902073af265ea5f5719c5b1e728226c900b29f6519a933158896d4c20092594cb00f1b703bc4f51a543b348f6aea1724523cec58de66ba876d837ee94d0a3f692188c2627771ca876ee6bcd4a98ebb673742fc37c51f468fddd4c5632ae9cee1991c01420b1e88a2226601554f6f688a60b415fad4a904dad7c813f612fcc7be2cfd7734bcf32230ec017ab53897722e5d18c713ad44c83a46b71083571945c1f14f6c31e03e5e49d402cb055342e6b4d0e9f2318574f881e61a6964656d48e5ef8ffd0675506faefb83d5f2bad47b14e6cc51adccf6b55c91eeebff92b17163273778a05acd725c8a27cbe6db71e5a5f9267659966ec170f61a1f930526a1b4a13b2f6a4c0cd1a33f7e6476b8aedb3222823a0fcdd18a2abbf99127a82783b93778ad1c9b5d992b593e5bbabf2202b2e4fe1bc644479d9f2b020649f6d946cd53b7d01965af710579cf7e59009d24139fad4eb68e35441e0ce8d3637d838fbdd46a76f5174a65ac3dd7cbd4a361d32a208f815f8d8aa2bc7c285ddb4e200cec0c1d7ce2af64344a6b36684debfaf75bfb70f14c14cab23206311ce8682d3544381f5e6b865d3f28094293074075ae73d3de652bce791173d5994d904b85ea59b74fa315b528032bae75fd6daac576b3fd42a546c0ae4293dcdb040581e10f630fb17ab18a9a73346de4e5e8be8e16c974dc87bb8f647a6e69aad324fe57ed97495f6d6ddb49e0ef2c1268310e3af8397f8ffc293a0f93a9ee2622631a65933c15195137a40ab889dae74707bc06e0317a0ba7ce8794ba48bef79606a20777750ae18e5447493a0dea1dfd63c8ac2d9b674ff4952016e5eb59bb6a6dbd2789f406c506514a3c6749186606ccd093946af7d12a231475a03dd0bd4e89d4d38f44d45a59ce312228f1e362604d666286d46244b795e5ed51325a53305ec9e1b6a7826dc1ea86171e7dd60fd2f03d009fae67fcde50a4b1dc01eea5ee35c6414eb3c885fff9775bbbe8b4b0ef90839fd5472561c48108dfc3e87611c22f485663f2f95ac5b8024e295b62d2adfa181ef18969aa572c798beb5c67ea6f84a0caa3d44e2518ed263d2b2aa1a7c8581f3a06cdebc70f5b75bcbcd87ae4bd17e35fab57ed278390bd69253e2c2d3a42ec430db3b67e65efb7803a52ab03d26c8c6e23ae40a8d70cefb6607a706a92d5f67a8909672ad339dcffd4fe6a584c7ea161f41ff55fdabb4df4e5d56882fb0cda795d943d48339fbf86876e38a31e7b9e8ecb5916feca37f1c7fcc253e30d2f8b1b7efa6a7387cad1b1d8cf4bebcf71c3baecfa499422fb8f4f82b7907d7a5fe7f877e4d21eba1bc914cfd4860963271df9915e30330f739b8c11db3acaa481d4a997508416b1bd9f92650ddeec179a654d1e9c80c328401f6d1d261e466828e93869775f5099684067da27e6f7645d6c020ab2f3fb8e884a92605bb0a945b1a34f450464083e95b5ae3d6baed74c7ef7ae7d796ba5354a4ff3772f6e590c4e7bc33872d85ae611cdd1f96551f35dd4cf8d0ff3775f6b456c5e26c30a69e14268fbaacb41debb3b69f8b370557997e6e06e74ed53a8113ad343771b099352733c06903a8535937020fe56ca3455534c204ccd99ca29f2773587ab2c2d691e1cab7e201034725337d25fc69313b6da9e093c860794869b06ae97b46f23968e48457bf23f441efc343de6279965364e60d0536c93fbbe7e55c5672df907aac5dd856dab11aabe06dc2df5352f81403cf067e4d6f188a9db23e628dc54c52db4ca87de99f08370ed002bd121fc274539ef1c7dd23e9f8af5208864512050e541d4148191cfdb56ba44b6952aaa031b14672dfd090309aba8e889e7237a39c9a8835865735a436ef928c4d4afcd1de8fe6d7f47632eff1a64b859633b1f62176478d6faa515ea721cc561c302d1838d0db2197cc6f13b02df46b1f203487f2ef8ba6ef771de2a161338a4c31717d28d81c206ca12d0ce2c84d15d3c64ca1a046fd5a4fe5dff8bdb6bc3a609a9d17205170e04b077389aac3aab3d1ebd2e4c9672b428b7a114cfe98d8e9ea5346b2a8e22a0108e8cc60b4e642634404e2b213640b0c7c65715436dc74c85b08a7df23e123f5019402646bf00b9f22bfb9582e983419c8e588b71d301c026db0338154bb284e6cc17596103c7a92c762df04400c9752bc55e2edbdf11e53552594bceea5f7c1353f353cdbc05d99695b1045549708920bf1c2a3a31bd1da13f2a59ef3c7371b931a5d84a2c072ac7127c7383b7626f2e8a7b90a4ff4b4b6a651e20bb7ccb72892b21db68f3b48c73fdf6cc02afe08a1adb8040fdc055bfd0e190046eb884a1f018aafdf963f7959a03182eec3ebacfc1ab865658a460a84bf547afafbebdaffa96a92e878d39c434841a770f8061edf23cca22b89dbc53b6f9be22aa6af46377c7ea2f7956f6f12824cc2477d6c66f8277ac666e38a20add94193913e5369ac762727c2a378e5dd163bc4b78c0f8bb5678710670afb651f7f3fb511ed549bcf06ad98b33ce5fcca8ce93125e32bfba4242950043f0aae6431250c1c96359cecdcbfd41ef2c719a56f39ce2129216a07229490e14e10ff5639d6c1a66d8254f4c37eb01b48466594ea6b7da810611706a743da5da841376eec8ec213258e488f11ca47c692f668782f28cf712f96338893b4448b1a510575b3b97970723f50abd1e73b130f166b51f6685877eff95e4f370ec649fa6488e6ea244c446eb7c81ea72a0413fe449d8717e49511560793da14530a8d77b9927f0f95ff7e850c6895011685837a748e3a7ea30793e875a3681d7ae8945cc099c7bdf4acc68f19aa2fe1e47661cfaec96e0ca65dfc76c6ba4804939f01168ce78ba84e87f44d5136e6bb40563a0fe017a2d8f21824fe5ebbdb5fdac0974006d63353a55dc7170551623896daa0be79605fce28064588155b3006f60f8d594f18ea9645253907386a10b5f91079f81bdf416270afd56ba4bec4db8d1fb4020f1f49ccb9a829c74ee9dfaf803348b6b6f12bedf3df96e5e78050f82b822fab7b4c12a16e0c1a4ae23bb7b5dfc588ca8dd17388b19c99443156df7cf607ec8e72dc15e895843aefed3749d6a4a17474e5d4df352b6d78e88d7ae47ca49665cee2ccfdf19bc4306dc82299da3252a2ef803d520ef43dab777ea3ac0eb75de08c49f43d606d151b33f4bb399f23020e6adf91849781a7d7a8166cd3086c0ad4fceb355f7e481166023a2b5a20b7dfa70671b850d7c6e7c03cb04c269136f172e182f16fd975f782235a1815c7e1f2b0532c29c496e614ad66f05c4aefd0fbbd35533cba932022c6db3bf40d6f49b34bb71c2b227167627de8937b28b675e5470a6f4f382a865fc3820898cc426c2026b9220741c400f4a722553c2c6a5c07add5325e983be0b456ac55858e29e826093f02bb39516ef82f34f5f1cfbf4deecba99feeb613055fb1dce1fa0c33a8301765ec8fa15bbecb0121abc95802b9f22232252179fc2d9885e5cc05d80cd0f7e3fdee279a359e3a034cf9f7e90786447be4fb92c8f144dcd42c62cd086eb1b7cb44f45ec1fed7bc8dc49314abdeeca25b5b65f32287cf8177e686eebeb764bb4f259925c54dab380e9476ab697c625ed4ec7dbe5afde4af85e5ff5b11a767b064a4dee364fb3a23c1372938daa599cdc3eab833dc88c998b8d6e74c33d700616f56cacc8da3b0228bd216d1168982172bc3b507b8b7d22c878f376cec860b3947386061b9e94d25cbc076c3e829833a62a4e71acd2d818900e27e2f7ced023410bac0fef29fe63bdfe2e1e0985da2fd7554e4eef10f59311682d4b18e5d545d0a25ae5b19d16c33c0fdabcd4ccdd52d3ecb64a0bd9f206391523cb560bab6680f7ed0c740ea03b88b74cb1d08ed9f8d91342a55e0ffd4b4b0d6eacff086de4c7d7eae5078eb75f9da22b46424a1c3329fcd2867e1d2cdb0b0587ac62517af622770b992e56d686621da0b5c567413c2f847e4029f12d6ddf9ecd53a585c1506c5c8645a3206bed3389197122ba9900f17135ec9bb635f605dd9af5553bb2422b53995211aaecc3358e910865e4d940e43e38511f232d14d775ea20433d9d141f3d6e307f530d855075c59bb8e5309e2288a2d32ab26d01d5bbac20747594cbddf90dc802ad51f3098fa4f4764f9b01a6aa1c8e83f21b91c8cc98f79846104387e6fe584ada00cc407af6477bb2295c55a94acb763d92a5802290eeb4e4889007eb46d1efa5112b35c42e6e7006c7420a2a8c361a39ed95e95b1c8079fac79f90eb7ab8cd2369bd7763ca2bf23fe607bc7202ffdc768cf49b3dc43ecb2994dcea7320d7752adc23e3401cce20c1680812a52a1dd6ed9ac6e3dbb7a3f2da9fe3c7bb0368f7ba8c86159ee9516b053b1dcaf6ef49cbcb6949aeb5a9acc38db70f366a04def5206a5252a8d6cf04b1a6ea9052bec2eb01b1ebff4bcee103cda86ee8a988a3545b8202fa8b714d840d6fa1285ed77336925eac108e591bbbb8d20bed09b7fded637a86fc9407c882c6bf70c9e41a61c9f012e546c1b23b2c323f1f6dcd4c0a15e4dc8ec51e426b16b3da0c526f732ae5fe6e85e723a6093d68725fb7e22be5b07987a026b0f43dfd547e7dd8358d41ef87020d88844bbcf3b19c20000e489efbe711dfbf54064d9ecd9ff8ab5fab793913fc5c9ba721286367a72479035a86195ec5e61abe868bf5aa9be66ae91c51f1592c91a491ea4d39dc3c0ce23968d4cd4f65eca7375df6ceda6b40d9db222bb58b5cd319a7992098cfb1429b6474c7fa76e545e6d4f0eb8e8152c3bdc3a98600bbf92d9b3158939e825531e170f161a1936f2a9096237372f5bea3bb348feec64401b0fd999acc9010e2d7616ed9473580be1295d5bb2e8d360ef13706c1c0741efcd4125507b0fb58dcc5f68bb2e25bac8c47b60b718f0ff44b6329d2d66098d90a7b8ec2bf9f1bd2d8541552252ed265274ab3dd88ea64736f4240aac121d8c240d92b183a31ef8335e0a58eb27a0244198e1385409b89a568e29de946d01af97027147b895ac626fd036636e06c59ab79e889d30b97fac8405a39f0b313c08db1d5d14a9ee578f058ac88ca73c5b433fa0f5c7c15c3678a10c3e28756865350fd8d48daaa43f3ec5ee7f3161ce9d62b348ddd464a3cd2c67a5af742bcc1fa7b14dacb159663ab6e97dd9ddcb8340624eccbeeb5957c06abaccd18302548521644bcd3c8ba26814c90a9355a292cf735d43e52369d864520c39453c78860ae333dc64b13585e5cf76a428f31f74837bfe5c0ab9a5ebb5771b8a884cf279a057078760b1c76e935eebfbf9fb3b6770ad7c0fdbd910bf5433b2cc89b6aa71fa1488ce59afaf1c9fe59207f38179099c4ebd7f3cdfc20b6c12a3297a94871898103884c4cf9f79cb7fdc81d46c61459de6ca063be8c406aeabe96cd019ba1151547427b5dde8a73a192cefaea9e39ef6345cecff7807278bd7c243c69a06bea9cf40112fe128dd6e5b99d9664ab254cad485b434b069b258faf61bc3eabd8dfc279aa9fb1d84044ebaefe78efaab3a25c085a42166f505f160963a963f7cedc21ad3c63c2a3563983dfda9070192f48891d36335988c179d231c85d3283e93e46a592c691383c8cc9e71ec52a2bfe67a12f248626a93abb040e6a3b3116a681ed93ae2508c93625a55c41cd2cdffecd3fb956696b27bccc06514b60e541f585aee679252322ec6d87f2cb7300197c227aeecdb85e2da7920d4c221f1475e84411bd7d3077f75e74d4cc904b5b410ecb0d266e73ae55a1930d11d5771642fc0d6f286878920aed4f5fc12dc330dac8979a6b1bd57e1a6b41e54f5671696939b5cfeca1eba6339160efb2e5396bfc3f05a7dc83e1e4b26b6a0b2bd050aa892c1ea7affd8bd06c7ebe595b9f1b0918535441d852590425350a70f073502801b38c78661881ad1f05a439c66bfb64fe1c1ab6871e66ba7b2e7a00f3307c081d3f2512bde9ae013d987edd68d2187fb3f7a13208309fcefbc1001a7bc223f89a81f436b08b32631f74966e0ba993960ba99471201f0b27bd3deaccafaa50abbfed5ffb4970550b80866880b4bbfddea55b0f77e04920903aff0875a80513b808384efd9ad1e846929b381c67e33cf84879315553ee83a5f041ecae38757d4dbdeced380a3abb724bb76525c5be01207e88e69e764091a9c0e9bdf22bc5905727e96c3698b52336ae55eda4dc69fe703950f5ad17c3c3d705d97fb4528e23cb60955c5ecf33bbcb827785d8d3a803bca9d8cd29f0ec397c3783f0d10d34088f1d8012059dacd0caea99551ec6a36cbfe67ddf48b014581035ce079d3b90dd491bb9b22f55a5a1afb5e11bc527333ac4623f34fb05d99efed066029737a83e84319563136328ca3e7d50362dac5b5bb6170e19f96cb6aa816ad2fff03e2e91429b10cfc81cbd459adaa5a4721873cb8a706690b02c8c8cad59e37de62d98536944225a21c53093dcfb810f6c92799afac1c6049ee70a3d9072e063d33efc7c41761dd40e4eafc2dee5dbb29fff57d94e7d52bc3130ad45d60252dfd739eba8b891b59d99851b17713541fb1b2f7dc712abca3e3268ca0873a005dbd577fb9d1199eea39a49e818b6770f3e7febfabd31c01bc148f7af37b155a90af8b327b2554eaff6c08caf4c7ef8b4c6e0e7c7a26b554977b1af3a3f6d601627c4f9c5f7bd89f4fabf4b6cad62b0344037a24a76c7b3b5a3728e9b3858f156b6d3147fc4e6dd1cd1ced02321141c197780bfb6a4125d6484d8854e5453c5e313734a16c68ddb1fe5e0c22fa1fe7ffe4f5d76721a04f1333f495cb851654e0ed5516eabe0543f271b24997f54c522ddac91e09fe596854df64b944e1bbf684812ebe4ca1dee0758533043187f20a94c1eedf71efb86dd698644e6097195118f9d6019d75440b951cae815a09759dc3975c2f3b824840b286f3026fed8525b4d0df4abf78b62e242faee99d4b9178de799fc1934a1b009c2b9d6dcada9dd8ff7844e372aa81905d183f4175e4cdc41940f0992796a8e81d517ff4cc9519144576d1a59e7c5f6ae1c368eea25fac765e0fd717005ac45790e6512d22044f6174249864f3de18fec0e2d87588b00df291b320fed84087490b4e0399aaeef3e7da43c17cb73e52058a2e28b69b29d0126ed95fb18759b81cd0752ae35850a6febde47158b7d66d9f308858f3d427e2ae2180fd8cb58f376ebdb7b9d8e11acf42cf66fac7f416b41f9c4bfc4cbd4e86df645d6076dbc28042717f9341b2fe9060500a6dc4acc0a9230d55a33fb55a7bc3159e53a77f470c2d09e8ff4e8f1debb033a653e1dd258ce2dcd4640f6637674fb39ad76069d92b52ec36001cb4e888e06cdcd770fcef126a2c7be3b20d0298dea977527514927a7aa2214b3ac1d8b7af1c9e1fe46b3215d6968f1ea0cf3d1f4bb97148f3ba43adc96eac39dece52cde3d3f305d9fe98629bffb5993b639aae193adc9c6a85671fa7e79f151841c35335ee2198ca98cfe36a05b8f2672fffe1cb2ba837a1c1430bc58f3715bf3897a8824a4b15c03c2cac8a4ed0677e508ad8126ddd883e3e1b282bc4506a2bde9737a02f42e06e2df3d240fe08ff48ecf5890bdee7a46a728386d476e9a03d0251437ccc0d4222046c4bb9e511420aa02ec71aab629f7d66883e043f44d707363a403d401a780ef082fbea8f11cfbd7b789ec592b4dcb0f62f917c4684bd6ce035cad4cb0b53eefd71521799416817159fd6b09c127a90f440e44549331317fa75c9ae513edb27b7af0bc4d66a888c4f8929c09091029d75398d7935a3da7623318c1647fa41f40329b669491a295f4ae6daf8d304848de262e74b312f40b28bdca6520f94965201782503eb8214a1f3c7908ac325949b1790dd72c2e1f8c942c0c0406c1471286fec91acbeace34f92e5a3041c71de4dcf01ea2d020840190c099101a5c6d0ec30d7f1446708599cd81a971daa964e48c09eee9cc12f441db1df9a1bdd37f835d86d8a5691dfe8549d3fea5471fa1976815b869e2217f8345a47182fbf41e20e1313ebe66d575bc732155fe0de21bfe3fd153876075797eba13ea41d3aeec0896b3ee9c822755b05c43b2800ba21c90a1fa8b0fb374922da3235c218f1407555a5f15b4cadf61bd28a43d466e3d5e2e4900c35182313c86436f6a89a59ff1b9fe852f4ce9b780aab4eb1487c927c6847a17854ef33da7cd13a03325a7d462d5277be553fd78b1f53b3dcb6ddc2cb3d66ab8ae520247e1646749729a1e9b433db976d923417f9082528fe064c63c72e4190115c67bd8b1da1d7ffd270e5f44eb0b33ad9874f84179b0f6b0f0628fe91e8acb657eddf4b50f93960eb1eccf627d5eacdbeed46c9b41373d4eeb9d24739761d0fb59ecdef89d1ade79c0e9b375027dbe1d479a383a222ec90c1b108f0454bc22d6f6709843c72305939d7d736d8ad7baa90ade4c947a4c4a5d1d90f827fa530070057bb2c8eea774391f6298c6c9a231778c4ca489a8e514f1792d1f271611829892bf1494ebe2e50be05d0e7114ac3e51d071a392ed5a74cb8dd946f4f8e786b2c73f50180c3a107a6f6f7cfc1b9b5c8c7980b4c6a20937c71d86c5641c0c06c538d41980177b72f6a184dfbc0fd11d37f6e9cbf9df7125ea44a4325c33d50e58eebc200f2e2add6fed424687c97c263046f3195777b957e8f1f53c0ccfa86d36c5c42d9c04d8fad3b3fd65f26075f0ac0b7897464357d166aa0a0cc8c57ec164a8f474733b9c2884fb27b5eea1fc8b5c6bb6d5f34e346538ac964e869e29b4d413caac73ac76c3c5742875ccf0bd19c36c4f1747cc25f57962e3bdcb7c07536d07b8d011c2e342dbaeda75adce70f63addd23ab3fb81448c8b35bfec5008d149807ede6d8a4dbe2483b5dc281fbe54251ecb3780f317b92ddde19beac7b7dee91127458a647cfa2fa82e37a25543f32cb22730acd91271d1628ade90e3f23d4f55fecfc82bb6ac9cd9aeb675ac086f52418007c5d373e9b2a5773f2d5f20cfe81a577d547871fb502373560aea81a49691df94c129faa6c53cbea85d41fb2b32142d4ed7bb22b7a2cdd1feea34896cb0467627067814fca93fbd58c56102b188e07dbd226328b607bd1cd4cbe3151c1bb6f76cde5a362a1d3796b10e806db68f092142db5161363de9b3f65ed0eef4d4290dfc1c8dbb56689828d5b5af0510fd26b2965f801ad5d104ef87c4f1944ff4664a4c905b387d5037c2a97c5eac845b8415ce7f0a7a1bcbca7f4adf2a0b120e786fc22de8bb85b845eae43a03fe10f7da00d58c4cad7dd04972e8c98ea94d973fc60fd42b26889319ebb051acc6d17438d05c8f48c29d8cc35b4aab30bb3203d27d60c70270435213a7d6ea090ba5af2e8406e2806b3a3e5ec1381c9984d58f5502f8acd06103133366dff3014a792f589d69836933ae25f4295329ad0ccaafc91f85aedb54307236b5011ab862e4918eff59189c425f1ea0c79876ce3c685b34561be7262340f63813d04e915fea2f219dad9f8fb173dec409ca0059b41d1e222b87fbcd527076f58f9c775477041109161e5c266e0141905e25ca84fc2d701f34d7109225df1999eda35e42c93b6ee94d394ebaf9d3019f8440970e4981cd0f2ed8bdb56e564e2841b0c59eead7a3c535b9c03e81d50ffbacdb88b532984285b644ab1e4086b16e6a62ec0ce6508653d9b7281eddb7cc5d155fd0d5b6b3d4b23e32f2cf42a443677ff005962c4daac332a654dd3f65840c173f1ae832319779d31d4d8f2578e975a26ddb7fbeac257daa2ac6e7a617145fa107fb7e4030a95019a830b5ee6b80098dc4eaad0919b49a9187c85bd93cb862faeefeee7e2e99bf455254e57a5a33dd0eb06c9b2a5e886e290c3be0237ca964a156b33b70a99d204b874a262f905c36c02ffed621369281a763f12bab6534040cadd902ea5bb89cef374d7a935f44928818ec81d03147e5ed61ae9dc63873968681dc46dae9799b3116770d9e7daef5aefb9394fd2e3b66dda1874152c4852ae31d765e256ec7d4af715d76a7735531f3bcce250b1b2c73cce8067c60eaf09267dafe3c7bf60d661c726cf1ab05c2c706ad4ece92f72db25984f27077e1734daad8cdb25e805c0b27938713b7c45b4a3518d038cbe1c130c6e10ce8599b245ac726df2970493a977f1244895a33223b3f995cccc470b40cbb68ac2dc545427772e1326dbb0bc1ba49d2c1971ac4e68ed2683c6818612f11763fb924f2d8413b42fd8c9881da9f6f3dd0b188d176f165d048d5c4eccca2697d1859f06172911f0146a337907514dcbb7ae99093ab888e5dc5f548636a419667f7460e2f645da76a872e9884740de6f6f09ccb3aa6fbe2d3a55ce635d6d7c9f1ec8b76d7b5dd62c61bfcc149440843e711ca44564364f5c2aba251fc3f8a42741495c8d2bf4013d426349ee876a7f79291d2bfaf439bc01bfe604da6045e717783504ca044bea3f40d201eb5bd3c942063818d887ce33d70ab79f612c27510f90c41abeae8f6bae106e47337858a78e9c95e56b4a2b94e66415e29654fea0dce508b9612eece79f766f2e6580aac07a3863dd2dcfaf92f5873d4fc5807708d0f9366fae6011c30238f36b83c3ec16b9c33c5dfb3ea4f1f4077093cc8a8cb89d50eb6c0b23bc2cb0a9dbc3d6757303f1b21128ad2581158d23fd71cd0e7b663cfe185f3375d23ff8d3e9f5c5854395e6aa3f54ab9be7eb85e6c2e7b0e0db34c26357000100e3ead38854461efe8310778cc548e47a624e67110b7efe0a1214d3af4cb08dc1846daa86dd657c535ddccdcf789ee2185313a166ed63fad094d35f0ade63ca5c21befd6fff1c489577ad6e366d4281d6ad3be120e3ef914088dd02fac3c030d834596ed06de1482d6526a38f7045d0a16f0c74e92848fb7866b11948adbe9fb5220a8a5924c6b11d3e6a862387f86eda91c526b00a886654a100685e382f04518c886926e66ba44db9c92d2788e240293298c8b63f1a6a13aa0bd562adac4ab823b0cf8d051bab6d7e904f79f62a6a8488efb8b370a485ec7cea7610a40acfb450880f289e82a2afca2322ecb75ed360d5a0ef4bf1be05884bf2ebb09a53cf13e7106e220ef95f2b2a7094f4f6fceead2618b9a3d00813b4ec2d185b909bf39d00d4835b904d975cdd4c0871a008d6f989d03f00eaa8ab5f8e5420939484f4c743c16b4b829ede318ca3ba5e7e533c564fd50afbd7e4d4e7d852580d29224d88018aac8be344c749f89aea855a84ecfd59dd9679913275fc1fd7f3adadbc3c4e9200ed0bc8b6a164e8ee7905b7346834a14a88a8a32cdac634c0c64f73d65da9263966deef76b4a37fc45762e62817c201a1e51c2fe74d20f18ce1316f8bad2193929ecfc6c85d020caba6128e1542609232ed87c5ff9cca8ada354791a905c609db2f9c53bc15cf7fa4fbf75c8196810219086858cc8d21c9676666f3367e4c997581d222c3190fe37fcffbf61d71aa20a4031b04356bf4da40e7cf7edbf2c7921b5791f56c00acc0af844d984546f93268c8250046433e3a5da726be0ff2cc2c6d01edf968bc64309300a96bfe05fd46639e191385e6350525a584159c95ea02b858334814bd5b87593d4cbca58699ced14234a9d50f7770bfd2947fde02d7b9465dc8a4de99b8e5da44c1f6c7cf9c149f3d3308f7ec5d4ae8b41b1ffce906aaebea19059959e22e7aa64270e52a5ad16e0cddb15645fd6650980d8f9a01a71660196ae81ce5d3b184fc44405cca0bb6e5b6759f32848af302ab2241cb578e168226d502d6e9fb4bd0629b34c80308bf51b3a0289e1813c4c2c62c6422cf52874eec5c619c24d36626c5cfcb0ac87a360ad1a6d03822183e447d440c213266715eecb803ced81f8cde782df6b349eb45926ffd138da2d66106ec7f1eb18e5c64423320aff10f4ff7ef954388d97f123bc1e03e9666bf09bd13c711da0c2d7b77cf17ad28da3ee89351cd9c515a1a01ab30dd42b7f2c0af05134f8c56247c99675db96e931ce12aa5742cf78930b97e933a62350ec9e35b4b903937955e47e72000901bf77a09d1e3eaa1a7b9198d40ac567d7399fb299c47583d51908333722aadb26846e5ffc5ed2a43974188b7bb66789994fc254863984e62042ecd707cca41d58891179ca691a5bd9bb52c77fd3f86836a4a8e87c8c1e0a45c50d3d1d7a969ac7cee40c8bef3421af2ad8ccac33eaa1db0a65afd65386681432f6ea2a52670e926533e2e919e29676994a9dae850b70c107dd75e55c8a0d66f634fc6e8705395e73d9f88e5874ad924cf6252f30f43b8dbc50860c9a3dd0b3a5fc697c9758b214801125374d25b8aed92c10c96ebf99eff8e203797aa172d6305c7846cdecf41e60819773d353277e946e4bdac25ca7b56a2e23f387e577cc294a488b0830c927d116ccbf1309b7ac5736e40868bda35fd135f97b469fc228a9a48a52dc8458b56466bed842feae0fcdd9de2ca4d6bed6c2a02705fdddd338039df5aa0b791a39b8556214d09661fa1af7186399b1ac549f10e9acb349cc0e10f0edddf2e5900f6abb5bdf8e2524a207871f677faefb4d70b09b4f3859b174e57fc0b6d321021b49560f6f504e9420abe38fc301a2db5162c9239e04db0a77e623c915b759988d5da7717205cf7722941847e6069b7fe2673f1771c09e0e78d11565d96fea4d377d6b2981f881c38c46ee73da007815582118cf8f6eea9d6cb2817abfb09df2c8d07a26f3f49696d65976a1e00134235341cec44768c8f9aaadce5e5e980fdb5044af2fbd0d601f760deaaac7b633b021bda2c5e10f631a8808c521d2ff5dff4bc8b90f0d1d59ec0e228418dcf0722f0ffbd066de0771dfa9d7c0a1f5e2e5597ab04dd06341faf2c0d14d584b530583ce1cdb9259b2956d0a8e9bc96982bd17628ddca7075c06114d3fde11cc67aca4fe5e987c27acb6766cf31147713d0e9c44b3411ad17a0bffaef55be805fd41cf4bb911a335b038a8d4a99766eed7947a2d03957dce226e0dd73c07c6783ce2a0fe046c4690ef0924685e60856f23471bd96b778f55b54569c3d2ba26b447ddd59420fea569f7bd9699a2f484c13ed82adfe91248bd797a15b792f4a9def3e68fc274042917fc67a2dd916dd3bab7c351a5c53d747b04a7df51d35d053aebb51149458204394b8ae33a4749035e9b227c1ecd652ba21a1a59558b54fa0efe182544aa97a830eb3d469efd4b6160f25000eaae28d73e0dd616a994d9ced6a5a86f200998ce3bec196138460c6c227ad7a60421117c20ea99f790d678b71e089e5aedc09175495938c8353637fbbf19d915db8dd93aece8c6102bd44f9f1aa7ce07b0c4bb67f0625daf55cfd27c5240713960084a8c3913c2982acdb2e124989acb51fab4958b3395ebb269f3ace78d44d086ded80ac236bba33edb7ca84f0773b84f29eca6bbac407ada882202fc065ad4124200af74d45241cedc9f645a982151b70fe08ed0f1b8f5519ba5246f57e33989c2f3df139886a865abf6ec76aa0544231ac27821f581408c598cd0a5d2551df0822b590cd3df8ad925d1cf2d5d6ef6423209d87de791ba4a9a941dcb8549b376888b2adf828b5d8e8f95aad48a7335d9ffd6a286be123eaa9f74ee2d21fc4709e61f1ff7791d79509ec3b0bca1bd91442b19b136749f84dc467e74e82be6790a33968be6b8b29970b4d9bdf12e3bebeb95e1d054e1fb60b7f860b78cf00f0d5428942bbb182b284a0dcd9b068123962806d510d36988814457d7c23bbdeedfa93b581b1a93c6d6ac83ae139aa9b56444d1c6a3c2de0e6f2e0beddfe31cbdaeb4e1da2fa00c665cd9f2a6e2c1e49443a8a827c44cc55a109c9761ee7d6423aefda18469da00e223fc68ef0c4cd0cbe631cab3afe29198d73f97498c2ccad7559c1dec9ad234ae833f22e150e92dcb72ea024f7142d6c877f595b39e5c4cd3278a354531559d66c2d01b73f57d0c5a021d88bd28a0c6de477583c96006d5c95f783591c0a600e18f5f0a120f5bd7bdb2eeaa2668ba9cd3e0a876f17e74a3dba412656d6641ce0a5e0d6a5128df71d5ef947559de43a10aa300416da61ef398b80a3054ed7545cf088f6eff59feb1af458f9740ea981f5601cf405e2a9900afcd259ba6f67f7cb4327eb7bf1056706f17d4061eeb812f6fb5602b463aea40d13814cb8e138cbd9efd5981c0cf08d2615882be3785990e722a5ac4d9be3376fb831812ee9827e06cebdc4986dbcd7996648274067b518728360cdd9c7c2abea2a9019f744445dd0b83f5052047500e5253b1cb267fde2da373200f66d758b6fd76b8682a","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
