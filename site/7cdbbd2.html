<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"176d809b174178d64dc46f43e3b98f1b10886edad67babc059b56920e8c2b9580ce004ac2dfdbb1e4c9c4dbceb38896f7359f2fb7cff13ad83d34affa762db39459055f4dbadccba6db4cbf17de4b3ed48a85773aaba2042d1765fc0e8a958d81c3cfefab5b27558ed626d88770e908e34e7aeb73f6840e7d241d7c455be7e39d7a3383cf11dd7b81698cf9f2410ce83da78db57e36b59ee7a4f77e2f9ba3437231d09751212304f1d0943c5658178b3df7035448cce9f5e4d4bab8e090a3e3c765d9c0e61a44ef001e57b48243b80a0d94f226804b7fe5515f398a20e06f65a89064be9d900d87ed2dfda851856cc79bc707f0ce28da1df48317714aff588b9ba5f00d858388a309c5e5aaf0caa4e596d331e08fa2d820d4aaf12fdf65fda123da3f44c865786d7a81f8fcc16152d12e08f9e370001ab8deae764eb9e8c6dee181348df182e076af883b322a49945a33a69c73acbf74b8c93ea114851b50b174aa2c01fa2a22bc07672d042521ee0e35fb13d5a479009ae8b96a349dd7a586221c276dafe15a71b4890a3f46e2756a4ea1f04859266ab9e26f10cb9290313f173dac563c542b1b8cb52cf132672c5adb6aacc9de29aa66a555cb6b4ac1ca1f7d11cd60f6a748d0dd09a09ae1f61c3c8d1dc68138d289faac8826e6e70535b7807abb34d581e0f592f53701ac8cce1975bb7d4397fca01ec1b3fe274a95ee621cca84a912146e992f71d902c698dd45afe2e08ff0ca61e667e2be4681c245ced0f5f7606686e506d06381939c46c0653cf93c6c9f58a046d97083795fa7e6937364b5d2793d99008d7c8155da24eeb6f0859f770b235ba98c1c6013f1a50df2af39bb686eff0d01ee2f19578a3499c9f1e397212717531460a9c85361aef8babe8c5dd42fed7ba54413e9ad7099032bd9f3b5210001533317ef90e75270e28170a4dcfe36173a870eff3820d3d87d64b881cbecbd89528efbf80133b0312f0ed6321ec67a44ae4742f5957ea714b0850e852a8d1f1be26ff1e2b1565f11048ba414094a0974c90b99d395fd8a4fc455e7e2b32217591ab718ec33e34c076d9c1ca6c32feaa5bc79b15d8bbda2242fd8003ac135dbccabb47d634fa741e563b99374b8f56ed595aceca6deb302b1fa944f9ecbf6511e01d638cb570b84d31cce4d86065cea8d6478be155cf3da2df0c80157732b1b5a8d1bf5432086586b0cfa50777fe860d14e4e71f5da8df38c7da354fb2a5379ebd2d91160c44400c041d40406147dbcb3070e927be9229442f2b4b1b9e9db9a9ddbf4ce8d5c935988c10c2274d688ad03fbfae6bb08d2d56312be1e8e64983c684d29f944e790daec87e8dd4fd6b0b565f00641449380006cc0869566c5163201a612aa3567b2f07ef69a191e112c7ffa5a4314dd7248b1dcfe029e817c9d9d1d77d52e7e022bf861b1739443ad3da792bfdc81f991423463c62ee19b92463ff1f35ef576ca821944605f97bcb317b85e5c83f4a073ca16faf63e8d15852ad844a64f98a54f6b0d02d5f073f416f99ace1377b1d0ae5c7eae4732b1f8d62cee6dadd70a43af7c48234341591a26bfe73739d37167b0690df33f4583a7b4ae07b4c3b9acaf7d59fa1bf4b1b3f63455aeeb8db9b06ec94acd53a94743ba9c2be85ada6a4bbb05b567035bbeb4b3e5d7c530cd55043ed5b6ec840a46b98b0ef70491d529088ffc6702f9ab79f1af535b3110b0d8d351ead03927bd58c7595504f5a2a87482f9646b3620150b9c118b4a8921a5bcb104d3c7dd98cb6a57c4f3b7ad5b85f054c3c65a69f0be42c9c89e4826d5f45dc9ae1023a6b9a8bb50c11be4e4c055f84d4e0c3388e8cdf761abe7c57963b70367e52d93b7342dc2eedbce9f04ababf2ad64ec84516b94731a674f42f75d71f4bab2fb9b11469fd7697b9ce99b6dada7acdca8ca09d2e4dae9abb863c398332e7cb8e6a2fe1dc1ff738bd80b30b54b74c7dcc03e218e97f0bdb5f905fbecbd080204d4c9d7ef5cecdb601531c0e16eec7070d4cc4a21d595b6ae5a5f2b5b45f5c08748fbbd047fcb1235bb13371f45f7dbb2c86b23daae41e8ef71bc603eb69162dd79c5af477e9d9f45f663ebf6232df4398e92c36dacc54e8dca7bf5abbb85e53ab17f6bebeabb2b72dbf434c430df92a6eebffaffb5d63cc978c3af5d55eb2142b9c09ef09238e084ac0d650df5c2ab8e737547af90f3e73f182222f707ce5d0a8b8d03b6a7681b87b734528d75a3cc24b7ff85d52c1bcd7d8911ea03e49398f1d4d2882a0207463edc72e5bac229b720ed5118bc2b734e290c97f71d409d1b020757bbf710d4c286edc64fdd5e1fd0e23082b54a0c7c055afb361f90effa03417b2e382530689587a452af8a71ac866b4b95701cdc512b5e2c870ce8dd8408a9d0464b11239535d4027088871d64aecb5c06d4a46b05ad9d6f5055a2c07b5b28519ca42579ade02b071e1475e886b8849429f2342366a490607dbbb3d7f9b7f2071bdb45364c7fb7ec8c4c729f7a2a32d0ed5a0c5f30def60889ff6c325022643295f26069c65794f3772e37ed14c55ed1b3c8e7dcc816be66433c3dbbcc9b5ab378d2fd8db9c709085bd7cff47e8347433b926dd2d018c60218a64343a93513d42d91cbf7e06374409b34b12d44b43247c69a0ff50463975b71595f48e1a1b705d8e8678f4c641c62c5c09ac500e9fc175d5614161a56dba50d9139e129304386b1aa74434047888e51ffc107d66b123dccb3f158ff5028df1a8c1f7a8f2b1f12345a996b7a8483faa6c500242c25fac8a98d9edf196eea9e5b0ae6099a9556363217363e3ecedeb79fdd76af75a966369e39b2aa3bd11a02ad6b5c669569fe85cff1147ead31942e8cd3e83b8d60e1f8de790124df70e739f04ef38e665c5e380e9671238648f39a8b277397d8d34eea7bed00788f483a8d1b4cd4541748fec51bd55771a0b71860913b34b660888673d21e7da634f00329fd684bea48f9ef946d1b048476facc0d26dc9fcf3d2c936d2c1a56b10a5479637c4b2cd9ee9bd317a9df2fe3d062236de46fa1f2ddefabc8375133bbb0be7200574db923d355a5d49b6ee55457c53fb56627598f7f93e4e8ab02d4d9edc0e49a51fd763d245f4bdf46fcd39d7cd9f0c3212ceaca4c489079b6328953c6e5955a535619666b9a0f786fd338edad20c14d351a230b32955473510772c5ea5eda4f1dd01f3cdf30ddc7d43739cf82f9f481807c41a6264d99723c7a30ac204b23768e68608acdbd238076742b6ad4014c95192fa178d716e0355367886dcc6112372bc827057e9d1f16939cf9b6e92676fb194215963cd3c963354e4c7cddfc632343054e7360d31a777cf0a697c3fa6ec33ad189cee5ce7dbe844254623546aeb00c9f4a7ef031b199381ca894725c2d8f1e0dee3d30e956b524ac802be7873f5d7c4a255a0cd941ffe250a815c7e029409fb08aeebc0e22a7cb2ec46ff1dd1f0d0212dab92a016cc6e537234b036e3b8ec6b05e0cbfcedbc940a18c8aa2ba0b77abdf0bc4925509acb2a66e9cda816a7d42bab5501bdddd1c2bada68d9f933dc512891e0c5f6930315f0fbbd083424859eb6ca9aef1189dc496dac1d2843ed532f85b89cc83d10e0ceac3716bf4f5724cbb882c7ed1312ffebc1d2faf29b1e61e9f5e024ac000cc10fac45567a2ae861e8902c0d10a39145dd4f74c93f001b4efeb6dfc00902ed51210ac142a33de721fe5cdd971783621b94bdc632acef6d3680aa43922add46ff42ffc4b963c4a0a5886d432457d16dd1cec94b2946c69e60d9e1fe3c88b15965ec06257513ddae34701c72217e1f1e28f37d7711f08e1517fcd2e78ef10a1985aaaead967e6aae5e2d47b23e3ae5978977101acfe2767900e862ad42d906f5636756de1d0e031c12ac2fc2eee273e4ee65992f6a39d5f4daf5cf96ef0a0c815dbff2f173d2bfb3dcfdc429021c13c49bb931bc67c64752bbc9d985543e44403faf7cacbcbb845904f7b72972860e5dc2e11fb84ccccc61dc4f3e80256671ac0558408556b2b9ea6083d713818ffce8cb874e31833a960cd2c94236e11cad923ac3833a5ca730b8256cb76a4c113545438499578ee6577705f11b75e4a5a0f1236d97051340893673b29e74ebe9b38613179bc721fb49958432cae01eec2ae4fd201f885a919277d0c39e2df4b53f50f3906e14962234e2eb464ee0417caaf5271fac869ae4685edc61394deaf48b058958fa2947d1bc86f7ee8a582bd39cbaf4549b879aaeb0fe5c28d641486e2a91f80e371f5b319a9b36f3be9c3b395342526d17eabd13f69e174176214865edc16c53c0f1a4d456c9ce87b842e9dbd2e9143d6a805094611ca998d192a8a766edb65aa175c2ef9b7c8b28d51a16684835a79e97f3e0766bc9a51fea47d3456856dfced0359d9cf4768b571da3ca0e9e42c2c6c4090d3a46029f4c23a4d39f7dbb717030359b82cfea0b570b250d4f00ce199a79a5b58a1c2c265fd38d769dad49e719fb28d062e1b24ecc0dcb612918e3899c85c0264edd4d3c68c81a43519e5ebb99897713d9c1efdf6f569cb1be32427ef4578382e89004a8c62a568304002691bb749d5fb768dc2f894016977225e97036353bf82600c0329a97df08fc1fd057407505320f8b343c21863dbd0afe60bc3cd093682aa601823aaa7cd4a4b57276b5de96e557ef319c2980807fc1c252950fd5ce28355cec799a46ce052d12be66994861b47fbab75b3ffb60fbc6f35f71d4ec10f52b4254b2d35c646552713edcdd7f88a8e502b66d637edc54a49297a45c171b4642dd8b11fa7081f953eebd949a65beb8319cbfc3fbab0c887488398d39ff93235c7d7da97761a7727b3fd5244d5acd9e60f1f12431749e42333039fe06a6c9de3fa8137d8039312d901a7acb8fbb52f1bf783e65469cf9bdc85c50540d0a0ca5c0e096089fd09da39359998de329483a2c3d54918d443e88c2c3bf96b6f83accdc2ce19a65d3e644eced2613b9a028e37d51f25b86d31c5a7132b4aa47d864e124f0250796faa16f4ae7f836dcefb1b0f7689b608a488104c4b812a4a0d210c86beb846c88a79233ac6e176ace8cf8ac6ae0e9cd769e70c78636573f07dad009ae2283f76d46c09b699acbf128b9106affe5c90c9661160ee14def6858f174c41c703e23eed13c40d1f2c618321308189d49e1a4c961fb8c7595ab6673f8340163439a9dcd762775fc280cce6efe0a14aa212f9eed18d71ab0065aaaa96bee7a1743f994133232ae1763d8d5b7b324b6d23255aeebdb1069f1f7679aed7e32ece7e8251be0b85a94c01189ac522bc9dc4f8cad9d383bbfdef4849c23884da3911b4b55d8a7e563928a9bfd5f1712c71671e61a820606edcc327e1b6498145c27e9be8b57de5593bf9c4041c1c507aea99d217c566ea39d86aa837fb632e6d2bde905c1e6552adccef77483f5771ea716aaff4cdb1d0dcc68372667c6c339873ea1bf0856868d6f13ac5d6d7cefd62e57ac0368d9fcef2ad655fa4ebb56334566adc560f21a6c01f7fd1f325698b551b7230500ce9f70cadcbae87d032420c570bbce195bb6cd6bb9869a4823f1dcbcae6acb654625895f7c9a76545d17b2e7c5a280f6f85e3779ed62fce7ec10c4b5e5764f5403b8e93c3b232b5931995439fc239aadbe196df2ad8dba6f8478aa0fd0f5ea14d95d0f34abf8cf1c1cd6ac50d7f9e568eefea5bde3c4010cbf5e8c4ab0e32767e6d4d890fc9dfd3844551691de17df426571dff804f2f02f226a49436afc10a9a51b4a93a4c115cd7c0039236a439ed228eb0fac79e36feec7530ee52c85b285b0c584978997f5daf69bf75a56914337559797713261aea0562e17e3651aad82ad4721dbcbda3a9d10e0a509abd52d06488c4c306dcbb3465af8db7e3a2057f89ef619ea4fdc98559fbeeb4f446827df690182e618bbbe952152433e58ad1b622e4a57a8265879498a0763eb38f8c7ae4ab4dabc433189bf3bf8b931cd28dfaa665ccebe8755077d923d726109f315859ee18e7fe8e9d78957a9a185acc9be6e18360cd577f6889f6fd2ac517c665d437a7690f66832e850ee5b25cde7cd750a77dcdf0d93a7ebc5338df214d81f1368c1beefe618613d09d15fea7c6275245078036bfc9a8207b9d00e1d192831d4a2db6110948ad19dd9c3191670860f20bc8d317aa152554876879495227a8ae015fb55552429380fdabc53dd1a17a8c2892d36055603ca5874c573cb4f76f79bf0f8dd826660f5541b23869dd21a47d4482b13007cc48b87ecc05f21d8307ae9ed45bf8913f0cecb90decc588f48812134efc8ec96888243c05978a608a9a68e88c9cd6e3f7d93e792daf0fb5bb83c8819f0421a98c40724681b1ef557379f003e55569a529fa44e7661f58178a1b890b3c3b49e3bff2d4e89a83599c3e4b7bb0a866389ffd1691c326a7bc0af318137b265df2ef9ed0b3322adb6c054933f668e0ea4ae1d16f4eb262ffccb76fd5f730e56a4a64518cb313195b8d9058453c4f9a46f4aa8150504fd64504bf20748694e8190fe37fb9a581fe031b03421fc984e2dfe35c4e323cf51d7ba5a0b761c64fe6c0a01a18ef549a62bd23aef2c03038b48ee70939f98a1d5d145ea28f9c72c5550d03247ddf203104f32ae3235ef35fc8328609180409480d700738309604df272a025f13505320f82bf86d36fc0b4a79e28dee2a18ee3ca6ad937ab0c90b7914b209f7a6aab15571170995f06992d1779bc5e92431aca4270251fbbb140b5d435e89ba0336277cb81c82221e3625046d37aec776d78226c01218ed8384e908750606627dcb0b093bbcdddd587b5e7db97293e2cf54c514b4264c56eb66b3fc5f146d0d49f15e0bdad6378a2af112af7148b8502ff9c783716abccb15767517d074232418d91f3ec17ea37bf0464a84e99c9f29e61682b9ded2a91cc965c4d8ca673c6c420a4138b3b88c4a4ee69db03ac0dde39c8acb8516b1a5a837ac24c2b0890e0ece70a8281b30af20368e8a3ff795833d65f717e22fe237361c5b1f6524d428c116a9b7d574ff3f08c751d2b087cfc4dd76d4db047786df25d4548c104566e13f44d01ffb7777aefa553656c542d76f11ac2ead5a5f167c95afb44b27629dd2e9b2fb73752f455e20c2166271c5ec47b1ecc5abeab820155a1bec95c8f3e57f1ddc4d1011c040d7d364f90b2110360dd9b3c13471e0f6d4e010830aa59d186c69f91bde73b244a4e3e29d88f2fd02542514665b7d0e3e415bdfbdb93248ee149b9ceac010e12ac2b19c74d024ebc8390c9720d72c84eb53830d836b5fe834dec6849e0cd36256882cec26030e1e69b670ce903a6f5c8b362276146ef083e63c96b4f7080ea9a691c9961d00576d30996752e383075164a55d02936ddf68101325877f39f905fcea0a7dbbe4356f8def4b5ae61c9ede789f26a47bde5e177662fda902286329dd87681708dd35f4ab34bdeec32655d6c923753f341815e7cfa6a8574d328d741a2a996fb4fc4bd41582d5af8e0b4b51bcdf864b0aee716766fa20ed9e10c1960f55995874c24bcebb6ffbd3ff5fad4e2c1450b3aef165985a6d3cd7d5456baed6dd29b23717c7fd8b9fd3f60984166a1023637db623bef4528cf0f35ac4b06a51fac4e9089c3e319d185034aaf84fa28a82759bbe09cfd46193cf54248cc0475edc1de2f4d939c79edb571f9ac2537176e4719dfbbb20713b7a164ae8e0b3a6af54b3b661461b57877b85ee281daab92640c0efdc07ccc947304e2896b1181154715b6ce957f888b6c22b99b9f43ba05e0fa39fe8d6a67c7a2349f34f498f07b0ef421f089739b335c3c49e06022aceca883835a8be1b72f51525e87c2f8d6d734f2f49fbdf8ee3bbfcad0851f8d520bdf76c6fa9caee02da07af5d0bcb1ef6faf28ff1e8a394b1ecebb747f69aa4471416ef5ba98935f088d450699fcf593b1f8ec6fc449b4fb89ba3e98fb06f194fcf85e36fabf66ff476d0efe399de7ffcb295ccc85b819ca32a8e5bf2701698661006f4a8508366815c6ffe6913020b70ef88a909d9717290a470f39d8937b198596bb1805408a873ad035f961888d16bb94ecf63a299b9e59a16bc66a2c9720383026565ba6aa5831655d2723e3b6549e55ee03f3ac5d140da20d86e934253ac12419650062076afb5f09780d2470ceeb5cdaf263428d2337ef328cc8986a4404df26b285b23bd28e5e4205df58d2b8a4514e1dc7a50211948c6f58471b564d9dbbca87c8c89601a532b1019916f90bb2ac82ead0f9cca8a04b02eb7f52cd5682728aed678f76e7e87b75d64c1619469cbee0ad0ee7e0ca0fcd56c6a06bb9eb81d6428ad05e515615efd4ed40d80ddbca4c39952f650cb1d5935621b07a4aa8808a70c1560bd0ece90420b6e29e92dd241bf531b12ade0feb48545b1b9c53e56affc820a7c4e6221e5e71065da74bca35a429f138e71f68bec4a6feb5873d1f821db112880ae860387a31de242bcd0fa83e46c4d61ce5e76364b24802ccd640da0aecbe2e0a0f7b47ecff7ec224396ca78eb3065e66457ab85c61522350f3f15c8767f4b005d9169effe074b76e9d9f2112682965bfbfc76fcd27718e1e8878ba7f0dde08b5b3c85f6352e43a4f545f44688d42ec97a78b8a053bb70bb6f9f9e8bcb01738c44445854f323c3b7a925b5f2af55167a42ff21a8d643bd8dd5594fd5b8b101a4bae23fd453b93464b9e96e84544c1e3489b83713eb22eec08d0aa49b6039937e3cebac8c1f0ef419d3bdf01f792e1973ddc3c6fd936807153d70c376d30e9e7f9117f4ad6d4663a14b2ba955b7b88bbd4fd5950fdf13f17a5d2b3d2887b996b9c919c51c9f975b662dcf07fdbf5535380bba77ff4af44383927bae1e8599074f78556c81b91e5d061ada356ec3d1750d1e50914d352eb59b03363efbc92bb422079bcc0f45a3fb20999bb5a90c84065bf40e7d17d6156eb31dc7e0843caca667f80218eb7deddb327c06c7102a698d13e77a42e7b8ff79a858873bd1b7af08d91cf8974f3571351106d043d40ce02755d5852fd10991bda69e624a04deb44fe0e0d6763d2bebef087a1e955a3c2990758ba43d84d16bafb7d9b7aa20c445f1378710758f68d12e22e2e47fc7faa6a9468a3bf06a22ce994c6269a2be7fbef2403ad6f3f23515318230100e24005ac55e82c793b869a674ee09340806c2a6ebf098274fcdf3cd7ac5b836a2991f401e808f56a3183dbea56d5e5e6f68a5f6cc9a84370755e6e2ee9c4fa16bab7e43a19a91bb9e27e3c5fa28545d70932eadc1174f646ce8048d97532d041a79195e2bcd1fadb5a720d725be18fb41adda7fcb567ebc47ad1decb7168737a2bcde2e49961d8444d0a2bf19614546c0b78d8c34fada88101b7c87d8a97c7fceca486033e48229388aa65519f55eae824f93e995889604ce0c2029fa1096578e6eb7f6d18b305b1905964331e23f7150dc20cf81584c1031791b0c3d84cb8ff4be00f788d3762e8777e55bf72c870ae1951506a2253664d3329b42e4277a41b16e349ef9f778ce5528484b2fddbb88f19cc746b2910c4d11fad7b901a72587202fe6b81cdfd13722d1954f663b295159f1ef53b245c1ed7fb2ba134b379540d591df6be86b4e5c32f5b53ebffc11897fc7423cf39c13082abc1bcea8f1bb18f7412d9f7468fa35ca7eea9c4893c0627781b5ba39326643b720b8f3bc98d6dd5839695f46548341a3ff7150a43673f2a12667acb692306daba06095cf3e9f0a4359573f27af904438e1a6fa2fe199ebc1b93ec9f32c6dedde38aea27f72127e7c376dd278658f06853273dd14914f1243e66ce939ef69624ece3d1feb60cf27b50222c0d9a0841ce25d7bea5806b893bdb0ea9970d7440a50f9e30035e3ce172f9b1bae573b4930e3c4d2bcefbc1be92b625ff48e059bc26e771959639d59765fc80a2241e568b3293febcfcc7cb43ad6cfb3eb8d9bf4d260f56ed8325107319e7481a6df94891a4c8963a70bf89882f8ce56dd06bbca651b56f98eda90acf71a7f466b4afd9bb526774cffdb2f4fe2042eaf7deaf07d49c4613de0cfb93e5234800ede293a6582508e732af60c03d660bd983f0e3ab86612709f635007612c8f9bbf1b0d7ad634897a667ed4e322dbda77ababddb1cd4f8ee2cbd408384d7a203cd373aab13070f0c3b00ad8986d66d17e145533b7dd5db5c75c2df03c525c34b30b4a4439077daa48440cdaae0c9f6c0f96a1a9d34c0a17704e22a85382a8a6163cd8c81ef49e5a1c8501c7c1d66c68a0319a1bb2aa3f1bbca34e67fe9eee063d7a2e64d469cf29f99ea26ab7f2ce5f71359a17d38b9c6c4c94f08f2e126895b70ee67afc937fadb46ca61a1dd50d87e21438bc22e35d08237f46609c37c2d24a78e86debf663b95239d5345a2818223c1c7c437b9780b04885839617e12fe826cc1ddde1a58eb7d1d05fb47a8bbdc456dc21ffbd7832cd9a048b526d050d86a0982c81cd16e02b64ce65ca0b97e26608afa0fa7568c06944fbdcee64a551b82d5447f1939344863f191de8a708914d35ab1ab1550794a698a3abc274df660ea6d6f4043dd190e0eaaddbd174ea8076d4c82cba172baeea3e12889af5b18792324269dd6c6673fd8dfe9e0889d098982ea1b918892e9d386f7f485d630066bd41b978809ba92919ac26bfe99ba6a413064cae9c42e2ce95642934bf47fc69c3c23d52aa70e61bb40eade23aa74c084804ecd49931ed46baa92ecf74ce7abd0d70054eda9caa052e7e521caa77cdb829eec15714dab971c7242e4afa92d82335467e5de4546aaaf6dbcff8edffd877d1e4c1c826f3caaae3525dbd39c426f538a160cf2fe0a407ad2801b4a4066ceb9ee8cd8e2dd3753aa74ef49084eac5b11fa278cf22ad73bcf46b1c86b4c2c146137abc274b2b3b7eabcc7d4a6a253dae2e38e9dc6d970b7b6ca0d18550caac67e271451a8c600ba7c496a9da51e91ba1acd42ee42516e61b10a893c4cc3107fbdc65cecf127bdf2855767380cf6226badf2e591db885cf1f60487dd3d3ebc030157927d4efe84b452ea1a340b0829daa6b54f877f41278ae44f77817fe478e64b517f61565a5149e5455c589d5ab1bad5bf92dd6a3ee41e2ca5f31a8cf72d886f3bf2b185d7769306887700e7458e9697b3aae04455e2931351952aeb2e343feee6b510b8fdd494cbae49585bc0694bb918d63bc4d4960967e13161dbfab8e864216fadab63b611feb133c2b9469673d99610d5d5e050449782b0522c41eab03bcbdab4ed9181ee5a117f6a8057852b2ab314e353606e059d6584814a9ce850b58481677960f2b50dbd5b4c4c6d5d8878b9163d8c9d558a7b7ecf6e8d3de907215a0bf2982a39ee0f84bb5109fefd885ada9d2d9d395439e766568785484aed5c1568a7fa6ec82dcaa6d5f653aa279636420842ed2c723b3e51296e9d8ccb58485bde0ef910edfc6ac5da91648317b87b6347bb637586219cd1c323345e48dae8324f738fabd0fba9b6791622b0756198c48b6266ab06324eb7a2b346d74eb397d92911e7d7b39649bc63d44ef906dedf04f82de9e3f54d1661e11c74bae8a5c12c1fc57445af05d2d818eb4cbefda7fd7215c8f93ba80babb33e373152e26e17493e30c4e05ed57c97e6f5c473ba5908d24d80f28a9aa8da8abf0e84583384e4c4ca41434136f2563b55024d78d09eb864249ff1eca5e5c2f077714a9c79c10ef8c4d668b6cbaee2dd4eb73839d96882582b1220b8255880ec14015d7f0266bd8d30372e301b1cfe6e29b441ef90c8dcb4e817a622150e6b24f35c2853dbc289a1b0041cdc7eca5945dc6a6d053f619f9fd76ab9b253c4b61f216ba3369c378eddd3c127c5f7b0283d33e062a41e0f58899a4f8569561ae1fd0348ad7e4900daff78a2fad8b446a0bd92d0e60aaa66118d631978f7da2af7f230a400f0bfd689ffec5878fc9066af0e3b1c5e118359132a9762c0996ef291f143ae8522435059ac68e63deda413ba5f14dae3a01c40923760b4c832dfb2685df999cfec3eb4f0aa5d5f11c4022a12c5b5704bf6982b79e941ece132ce173fbeda4807a85d25fc52e449de7d51baa973fdbd756f966d21fc68d97df4decd49b24b766f5905afd650986db464e5aa630017cdc4b32c599ceaeaf3fe1dc7318dc317f3c35bfd6141d0e74f20c078c0c9e406fac57d2d8bf111c83261ded399d295c66b3bd735d0e2aa545bc19499154b5dc819b481df9ffdc2d2f3d1c2d94288dd76761c429ca968cc0d8a710a5cddd53db3bee3d52b23336981ca2ba0545938c0cb9b863591b8d7b9e9127b972648cfab2a2bbbaf08c7509fd5a6791507aa8cfa2edaca2e94f9fa6c610a847b02b7493bd66db15e65ad35b5b97571db2075d3b4362c6b6070026028c2a9770929f7605cc3b8f311a0d643d48edbfe9519108eb06812e277a13cbde948ff352546a65105e628092b86600b876bf0937c87e8d72f4aa7ca1a8d4d2f9eb7c31fd4fc2a032f39975a1541b3f6281a76d81b84374b229620a07b17798ab062d72514d9b824c3b8436093653e4b81ef23686f92e8a29b04f10ac633fc77465b5c728046eedf8b522e0275a1641c4e402c32df2c1cf34226c4597ea4d9da47afea2649995a2109db69940a681dd9ad35c155735601c53b4baf4dae2bda52d564f44bd2fbe32ae3139ecf3a7af04a7a9cb20bcae56ccf17f76dd9460b945f0a5bf1dad01f6eb144a1884be4b75faa0ce3ff348e726d31ff403d7fe601a315712d2eb295c982826f329486379378e0f0f1c66e7fa9c57e80a268bbd53ecb3e13da8f7903ea22dd77c199fa2847e4f04e8f5e9bc42ee088aad89fc56271816d97e4178d4d1f86b88def0c5935fe2688164ca7917791c1c1d2552a46b4fd7d376a13663df839e0455272d011d065de63f0ab9bd1770de99e23a422e9f46ebac191f2bbd750628d5434f59cdf05db8c805f8eb740275886d7ccce94b2ffdd0271441540ac01082f35daf680f865a831d8d9990f052667aff1290c7e3bb94da9700ef6a452481293e03aa4b1fceddba8b1319a3549183acda1c4c0ffa6c006e1058ceae733d89227ff67e4129dc16f9d13d518b0b0a8fd59f9931a4fdfa03521e5cd1f0f336f9b553ce1426c89ef7782d24e0dfdbda1ee118a806f05e33349a7726050f644fa96e0b5f7e330a03aa58dffb0da8f06177e7d953fd42090cbdbbe9b954fed5cf5d93201fdd83f28889927f4e8405aa5be39f12df4535cb63052171f9c5c0f16474107d593e98b7aac48de6d45bc5b7d20cb81cdd2475a8e76ba3fc32be9fe71b387ed16ca6f9847bc9fc782760973bd2aaa2795672bed21a84c5e69dede5e98c2879ccdcfd534235f1bf34649381690f4455d09060e55b51d5d4b6dadf458eca6a08bd678bfafcf086e817332e2e121d4ac70f5812a8f70ae645be4b0c07ec4b56827fbeebbfd3291ce3efc1f888f192df0f9a9abfea849345b548ef0493dc2b46471144a2445769599c65d426ab66c0cabeb73055758bfc552a9b43085737dcb8f23a613424ab88b242ace0c8c845f22b749d653066c786b356f8e37c73f08d05693650e06eee4e7373e9b49af010ac12b6679646e01471d5024b9457f3c4ebd05946f345b4626aa4934af07dcd13a672e97a5c53cb1b21d9cf049571f3cf0c8c410c8ac0ce9bdbadad175bc23180d3c9a9f0f1e0cfd7c06fa73bc3dcf697849ac4e0cf61a8e4b81a19aab6a1821d61bd35c61cfc48e53aafe7a80cf10c76d7ebccfe599439debfdd6afc0862691e8cf3a83e56bc743687aa102f23384c3e8ab873195a062c6031a33b3f17a3e186ffdd56621278830f0c4629ef35b1da18911b2efb27ac95aefd8d33c791d75dec1f29b1327dc19b8deff57ab85b4105f12351141f36412d4adc852a4ad45529b8e007eb61b9059468604b847ce21791ef5920a1b3d8ab4f2e0da3549b17a649ef5ca4cbe77ead43bbea7f45f08b034cc84ceb6e67c4188a735d432dfeddcb12a463063e1bdb885e3bc9de4fd5425cf3fb28f5e1bd2d5c30dd41033c35b62007c309856ff7b7498eff8a7a10fb0c26f02e2e23c96d9ed699f99f9b6c87f11489f69eebb8539f84cd72f80384aa7baeffe49e62ed0ebb76968d43efdaae505ad35530b2c70a60c73809799174c2d39fdb6e65a7a0fbe893820039c70c523108246230ab1d823049c5e5d52029b9119e548306d43c05f0536980c744a353cad8d3b45b1efe3d51ad90f326787ddbf0dd349a052a3b6e88ddb50e0312718e93959c1dd62389f7c7a542c1b519121b7f99e8522cdde420916d73b2edbbdd3579a2b5cee665600c8e4ac54acde2a8b07477947723f0d9b9e9379a7922ab1ec5c6e38faec6f1d911eaf7de6ade31dd09c633735668ae5103c531d531d74f842ada98f745b0b31441eee70f279006c49ce43051ae48dab426ed962d1be3f5df75655673b76f00ec321f37ee86f7d8ca4505ac2b0296387251217e40f2b9a5138eb1043f7e3a0c29d5d7e921275dd7b8fdfaf9dd6e0f04e0b3bb3697c161294f602671fb192c7aa134b270b0222e2f9861be59b111dadb6907a858e35d1b6f10ba9c8221b686819208bfc80bab8da5b8f7c6078292d853887","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
