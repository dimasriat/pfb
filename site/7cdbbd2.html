<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"569bffe64532dcdf9d1aea7dd441e48a94e01a895002b98f6e2738ae21196a799c53f9fe6433b4056eb03207628f3b4ace8d9109acce863c511fc54b9b3077e8792b64aa04f28d20ce64e1c44b380fb430287405ce5625b1d0d38718d9b41c670bdcbeab62a9f3b11a444678df269c9c486b338b96c0952b68664f6f8db648015f94985c67b4199a530db9e0c8a54beba0bb4c8276d1c4ea4453c886e539b5dfd59279bdef07b651b1e5a3400ab2a7659724b5bf5df4b8f0ca610aa984dc4fbfcd8f1d9b5e503e03a165df61e33b21b9fa0a614e7dc4beaf38688b2434006dde722f7cecbd51ed8e4aa1de76422cd3c1aeae45a918e7f64ebc4c718431ae87d1c36511e6fc2b28130bb32b017b69a375516e3bafd57acbff0cac377481f2024365d3ef24022f8cc8001f390a703dc00c8bfc9bc2aa91fad2590b213cb23bc835445184c4236131977ad7a1fb477e912af153bfc6dedc1136ee594839a2a95ac327914182fb4bf11359d51ae2a06f751bb1eea5cca92ed70a79d673053f489322df3275ed4f892036f078b0585aa7a9715e152ad2e474f7ad9b452c87ef93efd15aa755259314048071fee407aae0199917c2505551d275a438455ede401374e2e284dac9bf51d97db9b5ae680113043e4a47d8c4ae9451b9a123950a05cfd9970e3cab3501373acc2cb2fce0e9edc79400207af02e2cee32afc0f1d337abcc4077413354a1cf827519a445111a3166e0fede3479fa50f6aae950a478e20530846775c25bbe436c6c14350bc32d4e63f1860a4a124e19a017b995eb7e2bde1a31ebb3561569ab507e89ec53dc6497ecbd59ec2dd6229fada81bb1c4b83efb1e39a4f43f2bf7a755765176fad570dc644e931bbad7f82b3d8e37c0a02fe9399e900b532d7000dea79e8c833cddcc5c8c33696102cce3d975d8ee94c89ede8633042225668f236db8446545998bcad223537497fa0c8a800c5a00dac2b4491f1029b4cec6bb5906b23d4e5bd375a2b7e0da151716cb4f56a035ef7ca207cf7e15cfe1e239d19faa378d9ba5b9860a773af4bca43a035b09036e904251c49f79e2154f000748ac17b6ae5b17f0da5c9d7dfb0527bb106cc7d2100ad11766cbeff0e01a91568b066eaa91a856d8a42e5ede8bf9c08825e515001ab5ec50beadc8ebcbd7e88d34f2e99e95ca4137055e4023928127a80e761ba0f58aeaa283ddf05a81ea5514312ef4d00d55cede3b577ff8cc6df57ce2a312a1d84611a0f2d214fe7fead87a0e4c800e074869713330771c2b8b6feadcd4272187b19716cfa6bea70800817170263f6be23a3aff5853a9896a0db51eeefdd8f742d5dc6ef6d5c81a644eab7d9fac7dabc9388f35a602583343707973698f608e49a2bd8ae2c17d18933fbb6d6017a8b4d609e82146770abfc5106e49e40640c35eefa01de58895af08042d2d63e2ffe2301fca14ccb962968172c9a81aea5699cfccc5701ef75562f7c50b75cc396604ab1546f119d091b74865e4bf55f4a1c4dc877794d04dc2108a331a254cfe699a5f2d27c0bb33e400eebca49ee06dbdb142c58a3d5f8fcadefdb5d685a9c20c11e75bc1d903b7dec1eec0ee3969aed0109f485fb59a56700596b5c15d25055d64a59e611d241386c5103574302bb23c9f056e6b5ec0a656e465f1132c459b3d6bfced239c982937d6d3a750fe220e83fab9663291cbdebf2446949d7a17d188e6fc95ca45cfdccb1561e2e40b44497ffccdf5ecb79ec47aac86095bd1ae9c5e0c5e97a5864d0301c584c5ae9d2835057f981afe3e6e9e6b881a9bfd0b14e6a41074b23107b74ae6ed86e750eb0a42feb79e5eaeeeca7f42e87cfcb0df7b7b8ea864bcb1cd519353fe9333683c803ef158023a981173b6c43d824f5385025a51b38003501a0a0f6fba36b66008e735f50c3107e0d373ece4228d21a151893ec2f17abd66eed205c96f6d33e439bd8e0444bd1423639e08ed9cac319357e1934cc694573c9138a8aa2d2e051ad97f8aff71c0157d3112cafaa00dd7959838b55026cf36f296eab646d997e744986b7ea9111038f9303bfcd85b0d4bf724bc8846afb2b33a55b54efe39c260b4373522c9d0fe5fd248191c2cb15e0a98258a29ed23b81fb41b1f2ec0947454981256555e2dbbab5526cf99921fe44178ce9671547c88d3371e8d5d59de0d7bb3313eef4a801b84f72649df50e0e394b946ba55cb873d3c5715f4945ae8ae04e3f956c7401813821db8e9ec2fcc19ec736bdd44a35e50b6e721837b0c342a6947103ebb20a1ed3b8f4bbc689c34382e3d5fe1ee1f0f0a8fed2d5b02ee4db67ed6cbf61417e31aef1dd5bc4ad5c6ec6ddc1da58afec71932bf4e140f230795121f031dcb4d6ea81d1c5deef6680942f1fac5c62af6154b9576ec2c13c3f972a70aba86fa6f7099c675eeedc17ba2ddecf78e3479598321465bdb91ec1b0d00f2fced255b3841baa4a1ed00a1dfde530deadbcfd90bb51cdf519ea2cacacfcadb9aa8bf210019c916f036194ec74c02bc627b6af7f28c922be95b25c196c6cdca4c74765a444955f9a11072e928cdb3cccdbac6ef1ac6b41228622cff393794c5769d45425f65ed66fe4ca8a16f5bc5ff23080ddc819fa8669f81e1ca8733243180d57a42a290cfaac227a35ff94ac42b78411d63309f18fae5557977370e25f77ba7c6bc052fb93d9fd9b277f11be9f9cecb3ad18be955bf07ae85610264b9e5f122d9f70c3c75e07d6b2b15627fb3b821602627e7553cbbb1e0c0093e8ee5182b7bc57959912c4edd445788bd39b2b9b516124eb0c43ecf04f76d9f1b12e2bcb114f4b71a0765a0d6449e21bc54f141697ffc51da15e43ff1b7ce7f6b6ade858af807b7be0a06c2f40ce5a0f9a582d35af0c05d324448f2b2eaf1334ad5601f0969d53d1c40410a0e99eb770d46db1c57fadb37d30a2caaef15fee933cf132356fd2a85c0b2644dc3e3b9fee21d708c20ce7ae62e1fa10f85d5513223ac0f43448c43e1598ae9ef85be2eae90be0890636466a5604505ea2fde8efab2963ebb3aaa83dfbfd706c6bf505601c880c27380fcd5659d26eeed15eda37127d1d0faf8571b351c8791bbc20df48809eb5c512e2383feac514301da4102057682ff4adba42df5586073cc18fbb1bba90c6c1932bc612db49c632278bb142cd5b7a43a1279dd6c319a459ad2eb1a416e4080d9ce0c5473514bfaf97320492851607b2f27cec02b9ebfb802b7e24a9a0ddb12066e161ac08605a542ccdfdee5817a921d343ff841bc8d7c3b081be185248f642462f316673afc9c941b112e1773830cb07997df010726adaf5e66bd41b4906c103019102044647771d3ff2dd3391d40563f5fb2520f972d691e6732bce23e188b7cb4a97cb74532040d2dd7f62ce3cef549247b32896eb57ad9f8a14211196e3b52bd3dff634c7f56f7c9fa2ca02f3ade2f6e96e2e231491d6bd453af37ecff0fcf74edca55e760b99c069b91334b46596ff6f9c3e994b668a1245af459c18dcab9a5fa6096bd22b511fc9f3fc4d214fd9e0bc9b016e1166ec5bd7d50e0a813e9d98a46a6ba6140610306647d08e023e5e24fe6dc183a78a6826b408d9c1cfe7b1f0548c314ffe15d72f7fc06b3463ed8d0efb8b88226d08b5cf99cf6476a5d55dcde9fba55c283bc5b785dde514d0f689aeca4f7ea0493c6a0cd657d07de70e1800a4800304f42b9e0ebcae25ba55a166c0d49904fd72a7a4fe2a0fa816bae369b3b1d6a90df3ac451dc0fd133c1d0259308b083234571978b15d856741a58c5eb9379e009225ab153a1165162622d00d81454692fa90c6153f237788c50396bde0465824bd619e0a1d680628ee1d007b8d0014bb09a38c1657ea01d5e9fdd1d85b92e51d833cc8ae8f4c7063f7db3feb008f418f1e929a4bae576836b6c1c4eaab18e2a433a749df4cfabfdfb02878d46ba3089b886e000495c53b67941d2b0e8f0613dab36b881b846c5b29b6ee7e8b940c450299d7cf813df70efad9801ae1c1bead4bff4c1e41491ba8e2dc03e10e22cae15b66766304538473de8685b9b84697368e6c2136830713a0a08e1344ff1f51e999641cd45eee2a919943e8a02bc2a1216067193203b0af2159eeaa401ad05c7a9bfe8c69831f127fec14dff10128a867f01ae1d8f078041bcef93efbd6c3e3967afa10df72cc4f1c15eeff9912915af5eaaa1db5c99fd502ecb7b8b3d8c99e92275722b45877da1aae227cc4b8bcede82b8446d80a7a8ccfb56aba958b3067e314705b29e4e614b83a96cd2a9a42d3a7a5f6ce26f44e1a71de07a42017d4bdf26d564dd13d518ced77a550a99524188a37f14a9897f46573ce78a083904cef55a60b56ef17b7f06cfc7480405b12dd5636a0599bed0e9bc90d9fb88675e253296d75063065681468d942cb3172aee8ed121f4864221312bb493d66090dc19e10775678722c3a393d7b4444ebb0a737673d64f82ff540661aad993b9552cba886801b22dfcb831995857313ce4d63529f06b2706a2f4f32cf6b59321d444a9f823fc55aeb0e11eb22efd976cb5033bdeccfbd00307739981f339e232f5dddf40cf0f3f4f56260d30452a502568bb88c3ca9afa57d29d257b149c93b272d35ac1ca3c26942b5cdd41c7a92273f5f4077b2faba6d54f4ec1b404df28889d89daaad2c78651eb6aaa004d5170e73905a9c73a61da4fc419765a17a87b6a3d39a2d1939b1f1b9277e7a5d9e0b4facbc0ba9d9fee68524bcb21c1806cb97031f74e6c0539c8a62dcc3b6b52eb6f564989e7b4c9195c939e8edd3f9c0d13af909e1cb04d0236b37d2aa4a4562e51b2aedd7bb4b638b875f149565aa284c4aa107602a26f95c0c06ca5a9c0fcd6bb0ab1999f23ef97308a324797684f2d57dd43bb6a245a14aa90aa2b92cb72a3441824fae538fb2bb80bccaa2c6e9025c366277f64630e6aa3e2c6207e2c5d9a783145173212afbe3d06cd66887b2e0196ddd27de79353d00e9cdabdfe56204b4e407ea5abbb26a05a954f1f9532bb6430e208def8e0cd70c0d6aeb0a516639b1d1a1ffc0778cb5d6ec6d993b23b96af4b077f4c7e4e65a887fe4bd64816a6f4d1380379d3c2502ed8b2ded3e81e739e2052337df44156b168b046d62862b7f357c16019ccb89e1fd94b781574764f99cd51bd3081a9533bc824871a5aa0de2e77cebef628a5c7540e9e706c99f472b3d9ffc781a1f2662d5df94ce3e454bda36cd759dbf926356bd5bfdf7dab0e15abb4343bb8b96b8d85c43ae22c7e5bf83b04b6e4123dd77b76dd9c47fc25ea330efbc9c591ac0ea1ed9127cd1dffd2158950867a11c4d548255edf1684735fdd18486fb1a351670ebe0e8e35ed637766643f7d929711229694bbc3d894aabc90c1d84c853437af658ce41506ef5d29b36a5d20e8a34a462fc2a227e699dd58447d79eeccc63266684b39b446e7bfdad79b230be9b9546b623460837346908cc6c93ee0ee77f0adab0fd899e91c37d82141f75031c9b60d4f5cbd18c251c1ef9892cbf239fdd5f807a3751e490721041aaa32226346492bbb23dd05639daaca081fb6707dcb6bfd4b584a4cf6d5f20c0525e512ec86c9a0e8fda3386d63539ffaf295dbea175b0680795dd645af89c426b27afc7d23a1507500a74a8f0214459ef99bc2fdd834512dc5a8f68fe3a390deedc68dae58a3c7a02121c808bd4b5c04ffb181aaf0f9e56db6e4c125518cbcb0e27c580d74c65b3e9f2c5753e2e76dbcffc1e38f4b814dffdb92dd7dc9bb071cacd42edca5a50e2576e3067c7c5cc1b8d3fd474e06e6f3c58aaf24f18c35f207b03f56185d52fd16b9c4a78046d082ee8705124b7f86d7cf7e9d560cc747373cefb667acf6e28a75fd32bacab56cd45c92f3dc223257213f6393221160e2f75140770d5a80233e19690d6b5ddbfcd25856afb8368552cc95b4a2bfb46d605716ac6d4173d40e7184864c64953d1db9b3b038ca1715ce12dd5a27c94a28289b6eff10aa2b102e53a3cc46127cdf9c42d6c33c605ced0f949510db0941c523ab523e044912a98bf481e84ce005304b681de942fbfdf9fbc13fe2b5d1e9d80c84bf03cf4b0ecc068dc794dbd99967f8d02efcfff1dbed30c52e1712514afe64aa9a26ee44b849331022bb9bf3e75c8c80e2e9a57cb028993a5253254f1b6b56ec41a416fbd9f8312c3c25518c847e798528b4810be426923283bee9c04495d222cb9a5974152e7c4a8768ff3f9de28d8822f2ac950e39ef91d9c5266a6788875d618bb7997449a209b48470f97bdaf9c616a07d195ded13c19c0e12bd78f8495fd048deb431b971831c5480221ef2a604eb64f3a4f351a23b0feda62d92ee706c1286574c3f7965efef1533540e17f6f6a3d4771b53acbfba6a8a1fc6a1cae8048406b2d78b970bf2de06097b46b1c9252a7b9ec07726adfabbb92e60eb2001017c91326f930431050b909ec0a79cdd30de0a606292ca31b41bc9200c8c5844fc1a25a935a2549c020d0c3a069f8efddc6cf154eab469d24fa6e16e0eb8ddba000ee110d0dd71efac5696cb814d8175157e7196f1effaa1569c5292bbd6247553f02330c8a381487341fe6fe14c8a4a55dbe22e365c2c7f3205cc19d89ab3195007ccac54ca5f1dbf5a451927a009dcda22e08830a1e64ef8520adb0bbf83b0ba79ac8e0a1767c070920f9fa36dab1e066726b986ffb42ae2b012505bb23e8e4d5934797c2aaf873d2256199ba776f031eefd2a417a69c5aea4f259095f97ea6c94f2d504032206d5405a68ddaa593b21ee26f235c8d8ebf0c876cfbdb49544531245eb36379ad624007b45be13b00e0cc2e2d2a5b9114599193369a2b4c8a9d035aa375c4f8269ee674842f0eb38db416fd3b8d5ba97e244f413c15446236064976a2040d820f25483fce868b7ea935e98c5b8895d5497ec54b2510df6134769eb68464f414356d7ca42a431a72a59d37fa6fb817640a92a06f2961dc9d5f2fc4f36b28d133338152eea837d0cdf5ca4342c597702c4946f41b2ddf50e4424981d4b651af86dd3e37e7954067542520ebdae2452f115168bd5c57172fd534d9e3763d3167c7f9212f5d6ef929c6c79bac3cc5fdc1161180da52c6303efe327700a064b599970afc3978c62ae626667e8454d6aa363b01318731240a6e256724a4e8385d314ca289f08b283e316f996758ccef92185d60e0ecae25896d7bf7a4f8777c166595b1d46be943fa3ab459ad6aa6b79a6b6daea65aba042667f2a84240dbb78b3a0f10485a948ab5d8667162a95186f5ed93f14d37b1e093d85463fc44bc328f97ee9427a2486ca0879304b5bca61196ec1629cbbd9a878bcc8a4814ca7b4c53c7e5e2281854e4fbe014268c6b4ae7c534c29859c75de189c70d99cab8a96a7ef4b1a444cd94a53e468386633fa716221895626b6f70da6c2c76a1ae37a8c1432669a24e6e7498fd604e1dcf993c4360bf91fcea75dfaa18fadf7847e2f4578cdfe9c308cb84eea66f628f63ac19767a066c674f64fd93c458ad1738c82cfe283b95e6779532999858922e6ec0aa052ccd41318827c7c7a533df42f40b51c03a39db1fd721a7c988aefc4a3edacceb661d6aaed9a280c381228ca4cfc7d6c87234b54736f0ce0ad68c2b2cf1119acb9a4fe33bf36cbb3ca73fb6f517ce61f7dd4f1d6714f68b3c36a673e87ee0a8d45be1b45926eef2b4256574b6bc5e47e4f15aea7064ee652d27a98434c3ded10492df4849bbcdb997f4c082d2969a1185021cb6d6d3bc30742ff263087fb38a3122f7f716eb02794a7243502612b28862af646c6dc41fffbd090380524ae76f61729ed56309ee201d63379288fbf286ae0f7ab6ca90711786a451f4d3bb25a9c969efb1053973527de9c8d9b3619515baea78f6ff22179e33b3a5d14edcda95cf64fa22957d3a4669bc411bad47355bb0d5de110512eb2133a1b1f6c8aed2ab6c2457abf4b1e4bf2aa3932be9470edcc48e9f4779077c4ad04a275efd5c20ac58acb3e4107c28c94f4a7ec38aa01b11e05c2a45cd0c14ac2279483b85c9c16ff852de328b3ad081d529b697d046a2eca6162efc22b611705d340543bbb8c28279c5ddc306a98f46f27f77fab391d5f00a7ca2554ceca5988071fce5b0d4ae22e62754bfd59f42bc61c3f36547f424c19c615cb6368c8069b84ff37e4d256ae5183c9076bf68553f999a7dd1b305365bb2a998c1a24bcbb86d30389bc80d7670c328374458f194c96c63742dad314679c58f52c173b73def211821b0cafef1f1b76a2726f885703d46d934d82b11a757845270f0c9f74d360d2303ae72c9ceb7097146e3261acac77eb89e68462fb41561e655bf09239f83b21659e58225f6fc0bbab7e83601ce808685030a9230c2b96580cfb7fffb88b64cd07c97c4f6a8835eb28b7e15d5a5c6ef73b79fad858076820e443f59d2df0e077f952025bc004d6e9535e08ed5dc62c445b35c846abab58cb2626785ef6f3c4e057939377a7d8a53a4e28fe32d1259145bdd477c5aedf329b9c7dbbd8663f2d374c123d8354d7b05bc4d0e8a8e48c79e9bc7a5ff4fb7da69c2fcb0f3f38b222b6445d052386588f04f6017bcd99d4ac31efbee47192c6d8fa80056eabb0e06f2e2008e3d407619c0f9c336744097fc577f0040ef1aad7d93018449b0b353e3da1d5c7350c85c3663373321377fec3ab068b87190c40ee2d37d6f949f588baf6c13f655b9f70f90e8e0c3a7a1cecc558430895eda52df2e8ec7de16c42e99e8fe0d712eb5bb880eb9758e9d372df3d36a6518bd452d684d63d31ed109d873139ff6ecaed93f8c8a4a5c4d082effd105ecfcc45b4a963ae9e61808803c2d4a22255068e4781c6d0a74df84bb1066b3251a8ae66c48ee4dc59266ef3425781cfd82f5ec50b510004533cfd8262aef033ca97e803659b9528ca92c2697ea667ccc94852cc78583a157158d08d2058561a06644949777a29d75a5aac07241b1e73db60bf68a84a1ab82317053a5ffd024b7288ce4cc188e2bc26456561ce1d9fb4931df5c460b483dbeee1e95d09d7968358a11c211a2dc41f5b170f623193625b8b1256096ce38814888545732877b7a5e5c18700d743234b4c665260970f0e464f4ff424b4e82926ccf9830a98a12019e9cffe150250950f1cba99234da7819e58624b9f2babcc353054ca9306c3f03fed95d3cecab59cdb061a7ba01e8f35fd7735e365f534f17268a182823190ad86f7b741055aa99d330f2c23f45c394d09c275a0e7bee8c5adf73c1327bf67dbd9ca9728d4ba994ec0442803273b0caed0c14974ffd517e1bdbb83e2c8e9507e77043c3f37127c1edfcb8090a33b4b79f4abe86e699d03794d65447a565d4c918318cb220f5ca474b793921db518fe70b3d67138ebed7871437e6d616777233c9bc52f1bea226cc3e5536034db92129ca7e1e2ab5c82a8a4cddfe5feb801b3e05d79a2e34af04a2fd4871b824382a5668e10d124b0a3cf62f703fda0ef4349e3f62c3b5e119d19311539b706d4f13c89831fcb2605a1313475d7810f852313f14622470cc9313a375ddbbfd2160c5dac09299fc3ee9a089e90db607a2ddd63182c16b5534c46f6fa3eef2c4865bea76143de56e55d2d8be1808541ee8e3a8fd4852bd45e26a034cd58c726277f53c1ad384faa5bb88c7eb237868d7b4cda7bb8376aee329abe3aa930e5fcb537d5b9c2108b4fcaee02ef951679b131faeb6008b83a333d5cb36c87f5338a72bb3383731a82f7051fdd3169cb1354d1ce95f3119ef8ade696e3e23d7d5a704b75cd554a331061fa2d00018f08baaa4e64c1bdfe0b3f33817ab72421108eb71783f0559421bfd1d376fbb8811889e2a08fb2dee86e8b445d045d3743b3eb50142488091cf6c5407df4a15264ad8436735c2e46276e4a3add9506891535559e4b1056b7eff306431991f9e59ec9c951cb219ca26dc75b0e3dae25aa04a7ddcf357f42082c040d17a3fd9e3f5e99dbb8d8266e8e79c221d5376e25c9e23f05d972de338cdeadbb6c162f922fd9590e97204a03ac8c5689e864a6cb533f8d1de60be3a548073878746b2f31ab7c94d649d63747412be5501e00c41eb8da7ee7885641abdc1be6ba51de8b1216dce29859ab349ba4c7d1b69fc2d056904e809e173885b8ac66b846b781c79b79e9c370dd4f622e001fbfc0da72aa61bbededa3ca41b6e216152cc24d4c49b5034276d2f6cdeccabd0ad7b6367c73cc00eba608491b06d22a55fcbc2ba16045c238d8829ee1df80c401d7f7478d31c42a83b6b4bd51f56398fffdf6317dda4c15f08b142494ceebfc1a9d0f7a73b2081649da2db5aa79675e8a79f9b74775da83e287b4db2799e2bd1f91e2845a3510c6a473639b31e873b121da048f9de21667f86953bcbb1d16591e7090b6853d27b0636e8e904bbd6810dc46fa164a7ce64fc617b76157cb9d3018bf60a542af78e4170355cf2976e8b3d4c2810e7c6b1a644636b75af239256ae24a334490f6f76879d8d7538a690750210c9755d14b79af2d449048d6838e347617b078e12d8c9b2d07071180ba9b014d76451282cba44f08b2d9f9cff84d4bda8d4fdb8f93d80c4dbb16cd7c3a46c29d41744befd5651c98ca9d5a2a5b761a9ab66da3d8418c27e61bf87dbf113013003259fc27a6ab2aa045fa405dfc4662f17150e8a727113de21b575e54dd46fc7bb5e2506db7e3694ae26fc6668d02d873f7f4516e94d832a356b7e1ef988a80657bd74ddc1f3b17e4cd90bd5852250045d91ebef5b13d5e953b3ac9a05827b7d1be3a493cf828581d43bf4c06b1515afad12df3150803b786cc03e7c606060814c7a8d0e1d4d17e19cf6be4e7a7bb51c1e2ca4c474edf72a75171f1e13307efd652e439d9b69246509f56b9b028f3e555621fa026f0e7687e0983e204d55346c76a8b9a0760f3083b7a55c76ab7bf0648f8430fbdca2a7b251abc5695ed574c1f8107f68fa2ac8dbc0f3138be1a235c291bc8f0cc67c5c992753fb9ce32a4c8ca4a37b6b48032a3ef6980f8df340acb85f02112b8a4046d76dcc1335b26340ee0a6de79ab9c4cdbb0e9b2498269d3aba0828d1ef0dec92fa75e8f284f0c271536c2d601ff1afce9cf0f3fa47e9900125f8e4d2e1cfe6f4c90624410c8997423512586b57ca67e7fac607fe32155c70ed15409dd49e4c922e0496e8913e860948cebe88b5201b61c00cc64671e0563037eb382524b51cdacdbdc2cebe4cebc75908a11d7e1ac43d5e7084a030446d5f28d0686f43209b0e1d29256920223d9f3846bb1908b7bd3b37d36200a02185f2f7cf0c5b6a02aba6a3d9096536b576105056041ed78fbc5d390fdf0e011bf42b69af5848e920a23cb984048b81ad361e340cb5ad99676d29611e8ddc6a722de491b91f9b1ec778b7b98f0e1b93d88541639bcf4f254799af63cd700c4465227f64fc87cabe0177ba40e43cd7061caa2fbb707f774657fafa6d100dcc1f5fe8a103465bc185144798ee384bcc2b86d775da7890b102bef067c52af810b10f46ba10f0f4766720f1ff2634f9433adb3f6cba3a5b7aa1e0a95dfae1c60c6e1e21aae41afca8d999869c1a5b5d2ba2f02eef619f181c126f9601f37b4bb22679ac20f6ee841b4ab0907fcabe0f58647049f3f30c11cc4b81709855b887102930f6e90f80b82021128ab9eecb8ac031bab0c67ca0d8471e3924631e019b04d5c9eb69ba00e7d5d78b7ae260da3d552404d7f023a4891b61312a01615b392445b94e6caedbf773c9b80702cfcf405ffb6c8c5a9406ef5d55b757897cd203e95530f5e0071e1782b39a4a49913dd0e38deca21a0a1eafdd9240b2347c817144d809a42f503c4bdfa9e0ae342ad1d33152f6f2d5c42043675f370a34ae987cdce02e637c9bff297d0c1beb1b96180711efebf11c88ff9c3317d254ae7bc86a20d93250f72d39963411a48aa2e939544c17c75a5e32a1742dcab4823b81c3d29f4d84849dcb36597d988a661bcf11158c303a24cadcda10409ff47b960328fc9af68885da9cd5bb69a137789980e784fadf340c7d8cfd6c1f975b44644f0ecad0b16bcd185c536616ed340204dcab445c250653498e83f30c80bc223a0a10b70e43ff92ae6ddae359d9bce4f887b19254c7a75d3b0cd67e5d63812961ba20b0ff8e334563d41eb04f7bab179ff722273a11ea61a80067df672b393b77fdb5e61b5805a3cf9dada98c4bd23ec05e1ddf99ff7d4520e39957ad8d221c6c819d33f26b8e12e084e3f62398f632a4d9a2149ef17df85f8c6c7a8babe0f54b9c93ca037b9215aa5193b4e6f0d37f8eb115cfacfb23207eb54623ce1ad9063149fd5e35b1a83fb7e39aba0831982d3f0901868cf0d508c0b0420338f5be61b9d97320c00a04c75eee91c1760b6d6f8b82c726a5b83d05f19744ce0b901627db9898117bdd3e2b8bd52d7a39103e2ad01c8f8a95c5fc1053e983e81baf0a4eb2f85c83dd8bdae0bdf2ad89ae45b9afbeea4697b93f5101f0e3195044867d1ca02ecbe8d69cccf8e91cd37dc30c2598268ca80688b6a16da690462d6357949ef4c67aaf0718c556a12fe723f1b4a90ef537869ea046b9d85ceb22c44dd1b7b7aa39785fd3450a604615d3ce22fca6e0c1b3c59ceaa60e70664485b2d5160744665ea9d1959da9d0e991c8016e927611d9ea9595f03479ea823f4c3774247f3415748cbba598b62f2e89c4b381b8dcae95e29d253e74a9cfeb05b72544d9637c300cb8a80d8a3ee3c49b6c7557614130e9e32574151a7dc9c4d3f20fd89b0ba9a274d69269cd3f7240d435f330f520603967e61c2b33349e3aa5be8b38cc956b7301f9d6cffcb4d8cc288091e6702f1122627d13247efdff20d39d7b1f4ad4f934749b5cb63fe856b46a8b23d925611d73b6227d13a300920e07b8c771c62cde811e8a775d50cae67c9eb5b2c8c51cd34713e0eb094fad7b8bea426d47ab22762a7d5ae9244866ba49eeddce2853c0c0f2dceab6de370ad35ee40c3f2fc3b44449432dd6de1bf8580b52e92c906e6bd9bba587149c4f8e2577ea1cf45bf272c45274655438b8bfc2461a308f374e0da0d0a77b93e51e767d2dab9a6aef94153b157b92e8942060351d033814f47ebf4fa2f6f0a937362c7ccef4bacd4f81d08f8289fa93a98ff0e27aa88d12a861a566612dd57d6d6779df4df258d5609688793dfb12090f3ffeb266d01252e52c4b5444f0033b000a8dd3b3b5cc0de0b13eb1a9007cd0e0b782c5eb5e96c62f5c86d8c8006f7f8c61c39e81a77a7942c828b6a21cbb3a179f3f5699f8a6bb8f2dad98110abcbc9632e876db690079583dffa9e509ebac70ebbfd596f856646f510c55074d3a19e182986f7259e5dd001f956ae06a156cbeef06b5ffca37370138521616786f0a2c673e3bc358b71f1327b3c2facdf72cd3f376a4e6cdef33188a4afb22e6558207a87dec6a7d5020acd66aa3f91b7061bb136d03c2c71b15f75c44719fb27f053bf4fde49055edc712ad08338e296a36dede89fb36107ea6d375141e26f2eb739aac7fb2709a64a88258eaaf102ba87f8838f951bc33df4e1246284440b139a34fb915a82c98a8870c7cc01cfc90574d8e2fe9571c2a19bd8bd7d04d755bef51bba3a336c0ca7676c8a052a26d629cb856df093f127df49be40c8b56a0e543c5d5dea2f03860290dbb9e801ee5aed754d200cda81206b9dbda771049b6352a93c3804650e476afed17faabe5e70f55a9545b7829114bdee63175557d940a92f21ea56cd43710cafdfd6944cc5fbbf2863eaae808b7a30d943d8a0583739f6237a400af9511df06991060fc7b2aa621d30dcc2357df1a4054e2aeee06ab121720309cbcc3e535ac57747641a912289d729897d7b028dc7c6d78176d6c516be77116b990615312f9fa6cc938eeda7a5efaf305ea5f1a77e7e33fed3d3e75147f924c697ef61a1f940f9414b3bb73d67a6f61fb0dcef7e38b54f2a57d4192d62a19e4f9716ca8d6b1a43b694c830051f5512aa77cfdb6da3cb7183d7c8f912ee1f94f16104fd6e774872e99b14df30b43c60827b8ca02b9a7a723a00057799a9507c9437c8e9512a51036258ddcd56b951ba314f023dea33cc6211f32b2a500a05da7928f7dcc31eb0c8bd64a8eb4f2b97acb59710412c26a0d7c177d83734311cb048ce81cb055016de666f81ea1a53627d08de8a5a8de3b9f8bf1c0b2afe3409ef460b58bb2f993257d8905311affa1369951d91c988854f117b9173c5f5f84ff0d4b065b25d0e9db6eee8a4916b56cd8dadd1472767c15ecf88ecee89ada0927858be3a8f108d886e4f23c37df8faa40e34c630f279fe88a30f2591a1475cc846e99cfe0b042d420da856b8c6c4c8027aa59e34c7884c0757181315f23d31d6be9a03cbd318de450d4526ea28907bc2ff7ee47b013618af701f71d42b33a8321c7f42c51782a70ef3546bbf1d10d4d5ae63332c66a3436cf8ec843d383ff34def63af438cd86e3e31be229c39e78435b4b71b6248bd4cac0dc46e825e08bae374889505b12d8e4f9ff62d108973eaa542f0ce71dcfda10ae7db1eba293b8ea05d7b6e4fa0d402d3c79d58909df6d551fc885ef0b4c68a61b59436438d3251af0682d8","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
