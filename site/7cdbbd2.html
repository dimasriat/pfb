<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50b43aaeda993d0a85eca61765e7ad0bf13c1b84696a755012bdf639b907a1ff72633108bfc4a391f63289db3ed43ecfb301aaa0ffe862adb1da6473c93c1ab8cf61e8a8cdfddf4257a4a87328d45e2a2d793224b1e9eac6826883fc15202282692c3ff21572be7864acb2a077f19bd53fd2acee11dff66b01f5c177afb16fc23ee227dd05ad841914a967ee6a1353b8feaa5493866ee57b7d9d85d4de35b4187676870b52fad309f71b89e0b7ce534f47bbfbdc74abe509a650f12a05f1ac986e360188b59fb6814180b577358f3cd6126fc2ae93cad314dca6239bf4c5337fb1e1d1de3384b9fc0151ea1cb8426a54c2c0e374bd84e811a4b3dfe58fbd20d8757f3aa0ecd0a4ae1608683071a894b0fd7503a42f9867cbd6ae9db2569cbe5c768b2c93d5ab12c99f186eba5d1c69989211b8653626b1e81b9d1a73a75d040e1be8a9f2934b21bdeaaa9eecb1dde20e7f20fcbf4d5d24d667237c7271a2fad82886c5ae80a3d7585aef5d1ee63f51f0c0709129849b11911ddcf610ac285d50bf0d47378ffdae67943214be07e482ba90341511d19a2e038644caadbd6e12607b001dc90eece01567938eefcf57188e523a8f1d4cc92fcfad3bccfd4085657a969a1fd47c48c28498840683c957aa644e57c96ec5649699285347fd16907e6642d8b81916bacf2c577d4b4b7d3f7d3053a42b3ba7a0e3ae5c605d503aeb899f3b7fe4142f4431b24e5028871b3b018ea461b256e85275bd8b8a02dead7c666b4235749b8152bd15ff78a7593a6b8a07958d196b12b582e0480bed97dfd998a2d38e3adefe546630b5b1745aba1b674ad0bf20c2876f924b5487c4ec991ce7d3bd32e1c06e6e072700646eb1ac4a4953011544dfcadfd142ca680fda0b17aaad11f7131b75f50e1de5b3d5c629da2152b2e7ed1be5d1994e3162bd5d9bf4ae1087a82ab75f640cad2b29065d14807ac65c5c66164c25acc0dc9196413fee5eac7dc38c9c4283f979d103e617da568418525140e4ade9a04903f97508f61edb8b57db47f7f7b9acaebe209fcaf7c6f8d84727bd8bb4f4162dd7f009f64bcb60e65ac158e12ab2552a225f38fd650198c4861dfd00edf388385e179160efb4305e09c3fd5d62fe1686a4ecbfb1fc2552b6973a83a63dfede9974867f36b8ee80fd53e1087d524f933eac1a0e95b40a2d26fff82ed6fe63ec8f5388f8e800ec3cf4fc546b34d08a2b1a5c568466b85f4517b089a7d6544cfdf3200e5933f822078301a8c9150240ed8bf4d2bcfb5d75f4f28190afe777493916105fb2bda1e0332f45ea63d0de78839cfcfdb1f70b5d20504bfa75a8b8a3e5aa960851c6d8c77be3cd322b052fb78ab3eb942deed7b2cac901a3de8499179701e7da884f8b8512aaa701b79d8660de70fdb6ab9aa0a5abe266a57be830f63458bd069d38e9bf9ec443a61b991a7af60c74a74864d1c0ac4cd539a32abc06ea2f21bcf052bcc6720427bc7ad813d2c23e887ba7826d1a21ee871fdb688bc73b7ac68f0bfb9146348aae7b3db59c05b0f592219e13e9f3aede768a4ef6736a76b565abdfc0e507e842501eedd3f15c53eb9935001aada4584eb1fc901a272b156d740b89065cfbe01852ca3946f0339e668dc90306f3e71e0883a42c50ceb3ef589fbc07b4f7f297fd75d72ad416dec6f93ac058ba1a9ae345bccd2fbd024280836e29b1fcff9b58f75e2851f25c28b6259bd26897af68db09e6166ad72a79f13af802e97bb610a99de1c7acb56e99626efc180c08d22c7de1e6311bca5675aaa32be91e0bc546045167af5411ed4c7aacefef709e2cca2bae1816da6686ba4c5b36760d459545103699ccdd9b960454406e4f9fba7ac3348d314347f67e1f94eaa69195be455be2453aedb7252ddf31f0e38433d30f5b04bb3aebd264266cb003120dc7e9759e039e9512b5f1aa8f806fb389a0f0016f7a9d5c9144b7cd1ec44ebe31778cdae8acd1c4869de2c0c29b013f6d11b64ca945222a102f1496d2bbd7cb89cbaa204801a831a3544dd36059aef691f3e4c222872ea32d0d18833077a2ea880db959760e76f1cd823743743f5f98e86acafbf3d4bf9c8059d1ab486d1a351457d55da857ac918e51b215f387e4bbfb34ec6cd00a4c65517bf85f89c7c3d22af89c8375313700886c5c87d795dcc2c849567f08689910583c2ab6591781e0b4cf6d0507cfdcbe08d14399edb8c54c7abf6d97f3a5e4ba907741447ce9768a461d809f960c7190a768754c9b9ed3f449046b07caf2001f0250cdc2a15577227b0faa433d639afdbe82084c9e325824b1d87333d60a57e72e7e904fc3a316fcaac5ee7e62efcc57a658c1338df3487240ac0fcb0a183d91f744386b735b7f5a85deeb4c0c45470e27a5a1d4df0acbdec3403c1f777375c5d31bc85361e2805409d6da3006a148da636d4bdd23e3df95f00a33e2d07bad3c68ce242a05275a49e7becf6103ab872dee19aa7da38c4047d33436376afef706195e71e8e599bdbf1988bc20fa854493f86d1891d5a39d5bd4162536b01f6ff7179f315421f00c19fc7a50c076e21ddff1862b1662cd6e03da422738238c29abaf1b5188275c412b0baa4dece51f7ccd51a6defadb40e1c42e391183a09942da92906f7add59292cde8f1e0eb01f1b2611dff1016022c7b9c47f0a60699b14c445d404459c0c8e0661f9780556a9e19f2965feb47fca4e6620a505ec07fb5124381abfe005a0747e8cfbf4f77a55bcc53ce41daf108c16640f53860b7a2497270f1c419e3feaf9d10e21ea6bc319772d0f4f92362c03769ea77676822e4a9bcf41bf5cade0786eed76ee1ae01d123954f8d2423587a9c68fdcaf8bef523830a9f1a6c7106b067fbc173851c9b66087f0c9ff9f58633ea4ba1b1934a2d63ffcef0e79858563e8e2656f59c6e3d14cb80d8773d6d981624a42b638b7dcbe28eafd2df2cdedc759b7dad1ec3cad7b599fe8c7398aec0e7480f05a325eb7efba5a7ceb38b5d7851cbd210edab8450950264783f61e670e693d5b2686f31ce783bcd7cb05057b087797f95e645ecb901aeaa92d5e8bfa2d87a1bad522bf9a08dc60cb55d2a09dbf1c27924804e3b8fb3adbe667e8b78046cfe372711805ae3374cbe13bbf226471d219e1c37cab9fd4f4b452b9f6beda3df2f6c05a9f7c9e71403ebe11f6c5fbce32497a1387c061e0d569ea533d766be380485b5e1e4d2c31f8ca49d7ae37bbee605fe44ae21fbaec2094d849c760f010a6187c1ea0a8fa102df41e567aa81b542bb177d5a73bb11495861d31d8629fedf34c8f5952b0465bd136178d9c2db7bb9b2834d902551d1b06b32550b529654520086846ee43bb1bc58e5358a4bc4f3017b47612472f291b9bdc0de95de4c8f56993fb4e2d10cddfdc9b4c28fff2460a3ed4c63b7e3d048e5440478e59a67d139304d6cfbe8a9b60f4017936df7c63cf0dde8eff594b847c6c4384488e29eaf3bc34a15b74f0ce37489f970c56ae9a7833444c3f35f898b4359e4ac75d568b3f34668293addc83609c33fb9188be6b993cda8fedd1090b6754faca2c4a16e2591bc0c3baf97be06eee9d913ba610791cc6890ad43e376353b5699490f43a324404a7202003fcbf0f927a7b456b0db2ac4098ffb82dea38573e71399a1f4a92813c3882bf7d84780197d4df4a5ff5a7a1576273839f8836e750bfb6cc3237b64823cfa684a4706a622c9b061ba9f7d7bc566be185bcbff1451cdb7cb30170d366df55d60a5eb84acee819db148601abf109ec6953240fd87ec7ea400c07d2a6153e810067b651c526b0e2f35e9c3076300f9cbcf4a44aa788759395baf0aa415acb7f462b9243974dce2f2c3122cea66c6fc96b72bb805f30f6903d779a803255b2f178840b7ecc553c54e51dd6102ba9bd684f1c323741584e70be5bd5d34ac5c8699e63e03dab743cfe845f73aea44cc96115acee0189c3fd9227b3a979f5442969c548bef7b443897bf3cc96a394201fbfd02159d3611f23a0f63eeafa944c287d5b06422c2e52000bdd72a2b903ded46b646f527ad5b90c7fac98754aa6f519cd66220226ddf5ccc0e952c7087148b0a0cc159cfa1888f09214a81921d94c7c9e2a0fd772bbab8d5058a7069ecc7366b2ec3252f6374ba65db987b50172f3a6a7537f6fba9f4a60993caf5a33312a0753c7b82ca357d7737b6847a95d25459ca7e67f968aab6bf652d3c26b3455b62e5756b3254900d58733843e6680f50278ef8e464d61a5868d2e1b51f88840cac0a4f36d6078455869917c0a6e5c63d7accac5d99ea519023cd54c941cb1fb23d3fa1e8736800f027c81ea5df9b7c2ace9f4de97becbed1725e07912479847d4b5e5e6f6926b3a378903ad4da697c9642499e0ca8462ef2d0e39ae4635d7e273302637fe86d6ea06f27e9c7d1d0cde6218518e49802353526e97d2d2050355685f42b666ca8c7a0e4843695251e7e1f2bfe9293a0047c7940aa5fe88ffd9668eda500151ef5f8fff651dd4e28ce5cd471d6e8d7ee2da45cde0b6be682778815e9002cd21d988d4204837d29932eb72ee1d935b268d0c0b8b2e9548799121b3135ddefe0846ee85fa61c0df82ce2896f12afe5f35dfcaea0c53d622fde10388d3cc438d207752029091a4336de5c68e1d9c2204e6e1f8f2b8358634fb1fd53cfa788f4caba94103dce3614133d2ed7a5fb84eed20e489c3e1871d2e3ff7ca3735e659b300a6c788febe620b2fa115659dbb80d8a3360e74f61f755849f069805707aa530612de80a5b98d8521e4b31da3eefba6341b8789706534cae0822c9007ad16b8f82f3a1b231df9e06cf3a2034db2a798612323a3302aa52f423e61903ebbb6eb13d59d93de57ec035e3a2ead830aa441bb12134706efa472bdb415af1bd27b16435efe2bd2eb4f47ce73e0e4ed14efa053c38fd3756bbbe9f8b6f36c7b813082140fcc8904dd158b5e0c9ea92d322da4b3e4a5cda90772db9694a12e86e37fa831c40bf18a23f31b8aa3f7066674811711634157b7b2e90bd80725de01041dc4251a5309f5cf544ed8847c7539d8438f470187502c37516411b9370e557d81d5a401fc50206b0746ee5454a5e6a534ba0ead1def2c36ca127267fddcf2bbdd89df7dd90d40a9830b6f632f8cbff9970dfcafcbddc7c6e17f184240be44780d0de816758e0863f9f83878c8f336f537451120e88577ddf9b0cc82191446e164ba537d8b779203fe8d91ff6bced4f4509a6cee04343b49a33d7f6f356d8347ab41dd7686ce2b5f038cb7ce71ac57deee61962a5d799f5d8512864cf37f524e1b160e978a09decc1d25dce416bfc43a1cead2e4598d650450eef57be397c01dba937874bea1fbc2a40f42c4dd2629f2fcdc59e852def2dc748c7cf0d026501e1d4faf0124e7619b96fae21330649d9cab1c48abc31716871279c0d81f7ca611439610f0095f4012705b264ec1fb2655b155c49b2266c8737af75ba32669768e510f66de4b857ec194853957e69e41f2184c4e06786119ce37a32723edd0cf45509d94e9ce0efa9ccc63f84449e465038accc12931faef9f05a8b51d9a118d0c556d3562f6868303b1738a85e4032d27635da305a3bcd041973640e648e3112b23a0679a6c0dbbdda6b42fedeb351af0d497849bfdb51d2d12c185b0480905cc6af72bf786a3df6bd1a270ba62e9144f4ce1bfe52585223f53c1a853cb12302cd00da4413908632c28b82d88d34f752bd09e07469dbc411bb2daa6fd66dad4980517e0f980bba2a91aefe8d7f1a12bf9abb036c0aa5c21d1da2650a3c475c028f03c398ec431bb6fb5c1b1e447942eb26fb975ac36d65dc3d95794f03067923fb47d37ca2d8b93f07b94cb019d4e77c19812b21c2eac1f1f2e661b71050dc507d6eecebdda53ad770dd3e7f8d1b2efb5a7d8b856975b766047aefcfef48fa88873c699b7e31146c6fb97c1d951174623f32b3d94c77887f86d04aea5553727cdf0b6325aca070a79065b315966519df9c24858db36e68c6e14887189e3de7ff2a6e97b2ea91130470ce8450dc608069a5b7e91679a89a1a9926f0ec6cffe14a5639d8d8974a0cf46fbf0d633b2749827540ce594f1688477f410630f303bd607bf7d25a4dc8eb902863a49de73bf7614ece07450a8c8bf99d1e660bbddf8a1195f19cab3161ad0dd05ebdbbed045753c1288cbea8bed2359771a88b0bb7a7c85afd34b2f26fa5b47d93a911c68df5bad6d703580d1b2189cdf3794581f960fd416e0573f6422c24d9f5bd45273e5295eb63b2e3b0f06544625e4874f4e80cffba5f28b98745e326fce6ef92d7c2d8f89e7921198f601f6c64cd62c5514f361141c23dd578ec71942279535d0992177be58a0784e83231a6f4e014a97780152544a734b7bd68f46650eb93ff2a3f8f5b54057232c11a3015a287500f2f345b1321b7e66fcf379fd62857d231e6fb3950594d391efdc9faf4f002acc76ad061e099e0915c1006c424fd2a77186ac51a36c0b4ff7425274dc6f2f1a37d0f9d5bd423b431d21b9e240911f08ebb048b1a586fa82a987211d7594f2656a436590be5852925429d0fc454b626561c32f6115558e4db8fe1bb355bedbf85f5fb6d4d3916600f22cc39eaf5d10263b9f9acb49505dde7c1878fb4243d6533430c0a1cdeb0db057cf67baaa46889c6ba53f9e9ca70159feb7b0e1daa599886fe852e04c6c52513680b56fea351b008be4133d86f538f6f4cf8190c5d4f5159dfa2ab62993150df046ddb153c38f1138a25771f67a4158fa18841fe5f4a640083f3dd48723d25516d2ac63c7579388281df6816586de354f06d7cec9f3d5ad3551eecd65bb948764fd02c665c05bac0d869a83f3fb599da2f3243b9e5c687364db28d1f1b8fe6c05d36d99637a2b304d31f7900c9770d0f4014030560400dc07cb585f1ab44c4e6b6371a16a51dc03a438919c17c59c979cf1fabe69fe6cce3528b1abd92b78061593a9e6dfd90df28f685ce6eeb82ef0309c20e701264d5844d2de4116618990c9455c6dfd044fd7d13f07c7b6fb735d8f042fdf8b0ca4b29a0c8e5fd0dbac6ed5df1c31987ce0c695b9bf700b339cf8974fa2fab2379934a105a460b1a47970409257f47662c8d2fd9b1b1c4f7e65591e3351dc86239dfcdbe9edbd8a12eef91bddcfe1d32f3dd1260dcfc3284a896c1219ee8b6c942a55c3084da1dbcf6403d72b54b1abf2188d0bee6fb3d451173b1eb52ce2db484b92f5e2b3a3065f32c083c6230dc2d22771d311507260010cf5e7c94eefbb02a3a739cf1e6050cc9b0bc15e43b4d656a7f14873fc04a17204738a06cb68f36eba18f9e39f0b70a58e926d0189703d9f0c800d724bbb2c205d173ac62f74acc30b712048e1958985e0b99058f7c9400a78b835cfe88dd6f51726c61a98914b5a7fb25ccf24b2ee5f0468abb7fa4687bbca0d26cf338ebf240c6bb771136cf904e247335988c14658660cb5dd99db56a50a4560b132f6f3e376252a9f63e9683995eea549446aa962e8aec9da83468d91a6b431f5f7dfa987d9141ac484f6171bb4140d721e8ae5a299ebd7e94518b712f4ec4c0a6806ae7b829aa0be543b858d114bd34780e210e5bea75fea269fe5aa52a073405f39df30d445f519242b8c8bcc91dcfb45e008125f7ee5a9b1f703f7162214c173b10d2bba87d0e217d5d921644e1074f063be1926f1ff5f1d592554780c7f9a5891609ce7203ea048e851841735c8ff91774f636508d9baf6b1a6b88727bea6bcf67a7cb01c584d739795e41320a23fc255bd07407872f5095d3b093c439c7d827673d7428e26acfbf5d566e0b326881ca29dc5d02cbe53a70533edd1c8f3e372d55d5581b0d6711f6c34e10c41ac5b8c3ad6fbd36698c9740bfb5d8412cdd73fd22cf373c9ceb7ab4b36b7859e209a8b6c529bb4bfd9b0fdff09ed94c4e6b1eb812cbe4ad334dc7fe82fa0c6baa509c6108c63adba8af57cc919c7a0999bbcabbc67663533a95fb6b70cbcafde7b77fe22ff713fbd2c3788c0ec91395b2268c92b5a63fdd1aa5e20f6a5af23ca2354d3f5394d99dd1aed2a8f91297665cbbdb556c94a014d93e3c66f96173880b473d8ec53951be1bb4560cec51e7e5816d4800cc49f98931630692fb7b7083715de3a3f982c3d80e4bbb0cad555671c1b65508c76e99b7cf3f4f0d6a5c0a133e1de088a52165b418f1b246432b1a0ddaf16ea9b7f9468f3c549c6dbe2387596d5515ba8f7dc006298755823168e03680250291568daa765b7e0eed1e204b4610f6e8a3231613ee04ebba45dc143142e8db526717f59aa290a571839882c4058f61e37cf438ec9a9d4cc1e9601b334265a55ca723bf9cdb019012f02b6985176faa31ee928ea83047d52e575c1ff4eac625e7baf363de1e0b69e910f6047f77a378d41fcd10f6ec894956d2738eb82eb1638789bd17364703786b73fed4aff3a192b4788e748779c7f128ac7d00dcec7d1692faf3923fabee99ea5dad2a5af7fc68fea9700ea4e64eb6f1ab0571b88acdd99d9ff64322eccce5fa8070d571adb122bbac5e21929e86a1968d6bb091f1da4ec805b8beb91216db812124996c58fa3368759fad3097c7026f25a374687b9ee1dcccc6db7bd9c4842a808a066145e0ee74b48141647875bdfddc51ce064fea0477f8426ddee6a90b699b41783d53d4830ef3642a0e85b8ae8032db6b1fec75aa2133ef3e32347f58a58c18fbb7bddce9ffe1176929cce3a61ed82a2d9624097ca60ab2685a628c64381d2df1d967e4f7dcfbbe046568b585d42ad8378d51b95517802e4c34d8acdbb191424f1688ff48b2927e8a49eef77ea70931e1019eeba628ec7dee0f40c3066a8d5e50f6f50b05455e8ef584421697f3f845272d5ffa8e2ae9ad6e4f6ed59b2cd2854bdc0ef2b0e2d557e16bcd521caa15ef1f6a8e05b0989b4e55093b2da3562e32bdb591ec7d667db13e1e370e34f64602ce97fc73eae8483b329d440342b0ac06b832e47a07fa2a6979e6437760056daab88d618a2000b334a470ba5b20af1c9fed01e187ac9badb0ded3ca29974dadc25dbe109bf5adf6e28fba1dc9268e60f26924ea7ad894ffad6a5aae0a375b8245d4950678f66bbb039db2b5fd3572812291ab499ad86a53fd3b79a8a21ce57c32fde7d10ce12d5f48d5a1d181f0c9736d052f73b4e2332516e24f6f2a0c9bc8c196c7a111ab63a8697c793b341496e2aa57d5106332d5d515a97d71653eb8bc5f789b456464f91bb88f84cd76fb228b820446c3aa0a8fb576ae889e37f343758dbce086936f032df9de5ba760210839fc76543d20de10cdc0ada65b4aa1652a7743a25c5b7faaca71913fc7edacf4ec72b95c95506bf69e711b1bf47065bc561c16c46c1332b28eaa2345c444e018e81ed1ea242ee1fb142f239d7ecee1b72eb5389d816969f49f7a40332376c923545fdb98da13d2769038d6b678d52a54f3d47733b912ba3fc89bdb0f39fd3f608d5e1b82aa1831526369f0858257cbafd7cdeeb3ff122b071ac368153e575cad47ca1ee49c5b280bada895a3712832706665cf19b0955c8550036200d25d2ea4d09504c9c6c6b6ccbc4592ef2a33e88084486e9691aa04588bec42792b29e6ca47170ef6029f0846178748e07a3492515f87e944312f541a4992476701941bf471155630300d0693afe90681e7a9fd54eb21d92073ca82446903e5ac349ca25eb9f741d4339ec7537861b9aa4a2d35617cad0611c318b20c061e51318100ad8398048f0f8283d4e8cebc464f425d7a183ec12dddb89c206e685fb55738d91b7b1bbb5661880200db2e164491eddb8616eb1295800652c89d8fa8129819bdd7776fb4bc8d5a91ab683b58d8e3e0499fa4fa2a4f6a1e90e9d8025770975aa368728f9e04b9c19a53e5453e563b0046faa49b1f202fe2b5dfdaf370fd9bef02fd5aa0ae33390b58dce896d83e654343887ed0d94740c080fd3429a362d25c6737fbff7a01a9e2a47d13ec0b8dccdaae9ec105e457da7679fc7e2266f1e5505747330826f6e02500075169e2fd81018e8d184fc13c06d9d450a75e7044a427d1248e79e465bb0243b140f072284117de33db5ee118454730b2b4c62fd1e39c4892dd8cb346dfa0e93041ef7798c2478bf4af7de97d1196088ef7d76edbc12927f9e92300721bc0fe81c51c06a4ce8cb733a606a518f31409d7bcfa1b71ab9ad1885ae31855f22357c0e8ff28fd49014aa5a4ddd7f05bef7868a3c7242c73df90eeeeb0a76ad013088e483595759a9a8efc1724af13ab59412a2ac7ce6ba83696a218c9fb6a3ddfa1e4dab1736227797f5135577459eef67e60ab81c1896b4d748dbea3f843dcd76dca98afea8e8ca09985c9c9c1e313946d334dbab87095d57285468b4a509d06492650bd8e4c8d43e070950600842d639ac7f35b96d9ef037f1dfd3eb91881390b487860aff2a88b4670554cab68b64f1f55177f86a553e93b9bd226ae0806a9578b8c28fe5dbbfb3f3bc7a411e966685ccc066fabc9118d85dfb7b949a92ab9d81ee6de7db0117aaf6f2a445b25a77bcc825aa0a8f1bdffb6bb8beb67756f8063c9ccf73548e1409dd34dc2457ed6401afcd6779f42a5dfd44bd856e2f9e1fcfdced4030126a68c9ef911e241411fa6579e6ac02fa4776288695bf16f46ef5ffdfa8ce45771234d65609c33136d9198ab28860ea8ff4e1b1536fa034173cd9a6d3ad32f4f87f30a0b3e97ea1136e0d34bd1fc27bb965d0ecbc3759b84bdff6931adaa646e2353d4c3a06e82d1f5da5891273620db268fb63a950706923fc08f02b44a1d06b2462ac9faa5db3d501d7de0f03bbe696cce2a4aaf8f5c71ea8b712b689a41dd982655414f30328501935ae2a9e9df266444a66f02e7e34c5c5a4117e5a640460b3d36df5a2c6df0acdb64ab1849ab221f1229f92c22bd1bf2a951815faea15a4b25ad6ac159795f1c7eb1a7822560dd37caf601836b53beb09e204ab0cb6b8e2bef340be4b9a3cfa9b69bac83a5a6dd7ba4709fba6fda3dc41d8bcc69304bb70ba27ffc6658cdf333b3c135560bfa12617df507602583abde7704fa46f04b91e6a46fe35f275a0b1260d99af81fe374dde1e927b3130a0381ebfa4ec99bfe1529991650363212946cc0dca5969740fd5517a0d4745aa0439f580c048f6d2a6f619f61df6d416890ce36107a4e5b2667bdb80b9b44b74a2ca13aba8fad7944c91c85879c56f6b162a638bcb9f91e378e01d9da87a569ac4a886daa7c1bce7bcf86eec76cb418b312aa8316366ca5d77b58e611310e8b35e9cab719ff775d56c91869bc4016d1816a8e7531c098a7417a052ddf832a0f89ed6528bbd0658d131a76d182e42f35fd65b28be36634a1588b09a06fb408acb0cae50bb897e0836fea63c9cc70738b79abdf1e16666dc05d1bc9bc1cb662be6795c8adae8ca74f44e91c217116ed297b941edd79e6dbfeda2b1bbf05d73254605ccc03fd325e373c319d194b22201176e0fa64ceb3572914a670e8e7c5b01fbd9206a6f6976ba431ad3ab7250198505d5d2eb3fc7e2ba0c658a4cf16878a972b87a81ef5ea4826fa26757c7ba214288d9b81dc48233eed5a602169f0e74a6c0e7a2e8fe4f0b2d568fb044442609cc624ec86478a8f8283bd5ffcef318f3ee577452129845d20bdf464f98facfa3b5d7d580aa2dda17975865bfcfc501af358d88166219a6ddcb0811882b2829abadccb483a104b601e3c154993d48b0102120193be5b9418feae6121bf8c16cfc0477aa0b57325927445dd876fd68eb384063d78a97450e7499fe9539c6b9f36af10ad51903a71398baf4ff7df36f1652ccdb4c85bacaeae954cc747a5027022c537cb246288f8682153c31944e87d48dd5316064328c80719b396223226cf4267c2313fa8b461447fc154f016428ae5fc740229e4ca2f6ca8863876613db386f878e7cc7b18ef28809f4f63f3bf7d25e54164f7c0df2663f6d9cd29e48fb8ff76896ec767a1d9778a7d87a7e3635ed1da0e0fff6e190f41af6f544d1480eb52840a4b451aa8d45419575be9e4e8896e86ce2f221029b48c1ad982f4232f74925d8c7f81a3a3b55031a7077826e9aba89272a164bf32b22c9325c806cbdd45cfe9ce55adbb13b40d7a534aaec6385be91df7326b294a01d8ceba268d3ce1a92ccbaf91d3c01f5930ba804152167cfcd58d8278a91acd63d2ddf1419cc71e26a3bd851de39374ce29874decd627732bf2c66b075ca206ef41369774e5baa3381bf709071619f2bb628d8e2b066041c6c47e7abea8c30d264c165f2d97789ffae1f3540917d363c0deb2202d394e0dabb133a7eb091daf6954ff40475096e763a4e64d4fd5bfe385628227993fcef1b77a8c7a2d574e454694d5e0e2ded3479c5e26bafa50edf9b57c20e7f0ca12a9fb88eb883818e76e0f9cf57321742c38f9ed86dac7d0628fff314174ea2a852b21ca28f451488e7d354a5668e24871d9dc9292da26d69e9853b6e56ab0a52a95e80fb773b801541140238483430d9b3cf7e22ddbd002f1bc0d188efb84a6542cad63833d1e4e8a897b72eb620f7e7693042aeec09c7e0b3801ab2d3a22a9e48fe7d1e8bfe3bc7aa1fca5a91633b244cb9f588be3afc46979a80202e6eb9ad30ba4f666750710332b65fe9de709d020bea17c5bc5dcbdf009a3d74966ab584f0e504b0a973433230ff0fa5713d4ae2761d064b5a3425898d62b8d610e7f38455e34639f7af346c4a51b1b9e292e5962c7c31f97e36b2e4b156137115dc0e1ce1d79ed6b9741a08405e1ef0ecda3ad2a5f75d9440d9ba990d150cfe5d97087b1468ea3346b3e17d7cafeb81b428a12940be981ec0cbbc476aef1636cfb86803a88c86bd1e703538a0df5d9a1cf2ea3efd475c9368800b2dbc13e3c19b4cbe18a5047d58e5308de5d2dd4f485992d4b565a01441c8c01d4b43d86922b642202bd9998ee741bbc3fe398806fb1fd0e267f39ad7d85a4d0433d60f38e5c0b68fcd62a08629f653e40df60bb78dd711933af5f07f738d26f0e104f60a002eaa0a577ce4952fa820117630a7a5b538d04c9dbd5fbe065afde5d57a0d1ffebc1bb4cb888fb037fcf948bcce024b69620e84279d0fb6fbe35a8a8f99998f8fdcb1fcd984f95d83adb848658b4f7fc1b4c9ab438e42d4bb9a3fd91e18b47b0d0694915369d42e5d8b5a784a60a2567b36c7703ba4156a9468845c1b16ca919ec31f31a6974c181734c459a84711bc3ec05980da68249c581c018e8aed633d1d381ebafb49fabcb7d8c0b812d9d0dfd2f3d33eec1b97e28f7b4b12333e029c33dc7c477b04275d44b000dc3ccec90496b50e741233ec4299948b0132cc9671f21b4589a554f149c1f236685d1c4a63602f826226514fd550d8190256620279844e0b36bf0430f3c4e12fe78958121d010340a06f44cf322ee04f161a3a8f55162431c2989de5d9c9b5d6761bbb96d2df365eeca43d32d6dd38b5b57b231c5949e9e2703303579c1f9a1607eed6ad605d28d824982d709099ae61d71850d93baae02b69e598855193eb63fef22f62998d80fb244b3b27292c928e2bf3a3e1fcbc58f585e399e151915a4154ccd558b77c0b2076b102326a980aa0e6283b80bb3a6bb4c47bdc5debc8692ac656128a6cf01dcd8164c37b87b4d6eac35eb10a114bef0ae6b051483eea765eeab731477ce06b64d5cc3eea9e76e345532af3c8a1fff9483f4b0f78a8338099c7a674e510b90238f73a21a4c1daa2981f53495ca3e2b8190b86294c86757d41f837671b2b88ccbfba872a68878799b15ddfc81cb89209ea859c14904d34bc477f2d4d2396d245c6de0438edccd01c9c3d581075936cb25aa2aa4289ebca0f89f95850ada7cbcdc3daa6c44a5d705436b4d70e707c78bc4692ffc4b36a859d30f62d10d82fa92c95b17ab94c44e7440b9cfa6530fc0196e4e782de449d8ce00cd301eb921272ad1d6b90f9043b0d71eac4b0f5d1eb3cf6df976d6f1ba55b038e550edeacc46a998de31a0d1452718c92e5461e391f55dcc81b3aa4d03d68f0062d772cd9da25e83393930c15c0107c174c74933eadff97eed656e2fd0237595d0d0b70e28992a0979db548416237d973341cea893db9f2b285eb4c19223f0939ad80f77b64db0547c9312ae2bade7c8790188b056477c56578985548c80cec170011b698973be903814e5f08765246554387a7976da11f1be25c105220a7d9122b9605527efd6ff74d2f5b7277ccfa6ed3420dd38564ced36b95ec90495b8f8908803fe0145640de87002e06c4ef56c7ea67f9c9c3f32195897e3dd3f0ad87424b356036df3159636fdfb51fb1ec70d70d83e84258ebdf85483af47f7901fb5feab5be9bf1b416f85bf4daa1b83d4298ea39350a7447fdb31169678a53e338a809aaa5c232a632ce00d15528b910e67ec9a089ecaf309da6102b10fccc172e955f9f38b5156b581d5555b435a48f735987c7d0a36dd0edcd27fd2c2f5917348e76439319f68c237d7b351f21af9657d4eed3df3f761307c6ee9732a801634ddefd9367acd86b433d6e38fa8daf12e48aea07783996f122ba619746c821f10d320986c9fe7c49fb7bfebd2fe402465d3802898c01","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
