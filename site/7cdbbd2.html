<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"023c7e5782835f382507271fdef9738c6d643160ef228966a691f298f731eccfbf308c8884e606c4681ff8fb5962dfb0b49aad290210d8cc6e051b197b115f9f5f4e641b8d12020e2454cc3ae12714fa0bf425e1ebfc1f99b91117461b9fd1c80e2cd0e3023db014c665cf8e8a1e1c61ba83c1c467e9e4333bed8ba3318eda9d1dd6c7880aa19cee8c31423cb8dfade8cbe7c27ff601c52aaf79b1c38d50b8ec4e0f7f22ac32a770006a4358742d32319cd6ade341df65cd5e7f125492b75332b0e49d0c79f86d3f02078a0e3eaf15172ce2af57d8ac9deedee7feb96364a86e1e1426af5ef2a1c4b427b6a1ce48e2cd0f4913cd0d5f0204ea11db9544b2d6079bc84745c55c1662d29edba381acbf65af37a3cf512de486c759339cc5c16ffbc597f6208aebdcf2e1783c6c60884babe391699bf7e95c170522f69ea5d91927b5ca14890ff940f8b4cc698385f368bae68a65ef5e09763edad95077eed8d237e30ae1678e87e69ceff40086494256bf40d684f89f15bd66e48b97897f96c42526fab6b52c74ef2cc6e1ec7d4b710dd0cb80e730ea77b5686efdbeb973a959ec556f3d9116835f06cfb6622cb9510e42fa2215e12eedd591ffe29d8db49da04fbbc46daf0876f5cb1725bc58e16dd81b566ea8d988189f3100c4986ef93f5441b3d6bb12ad02cc2a40e42e6f0c9da69eb483e08be51dd1a41d4c1edde5ebb4e02bf964590131fda275fcf9aabe24fd4fa961a26e26bbc99447e23169c3fe53f14273aecfd2b9f6ba31873034ebc8fe7ff3a70fc9ff7ea0b09eaa6f03e0472cd338b1bdcb93ebcf2750ddd7a2114136784a9f24f58f4e240f311f8f8bd100a88053c3e6b7732b41f8d6145d9bceba88cb85b002ca56694b24235de0222791e0b1a6a9035d43be67236e7a9de0bcf9c3562fa31f04e8aa260933e158fb66947a9204950fac7687bbfc935fc20574b6d3ad82bc4d98e6971c13309131222b8d8970a5281970c5fb53aff5c09fb0df93fc48dab0851602ae11990f8ad438fd1da994c23b352b9bb7e256c645bb1a9a074a2af2a02813e2757bdfcef524f4fb0984206b65d7a318552d18b165e49b207d66b00175238537bcea2fe54f16dcf264496b9659838b9c9fc43b1a81e6c0dbf375539f0b6780e845d247ad4be70bd3e5324fa7b8048a64eed460ca2221c75d16ba5b5c60c1c940169822c8083c69516576d2258ea45aea68a6bfe7e33ccdd07117227a7ebcc86aba4f797def582466cef97536d9f2cf25a286db99635cbfbe06369f89b87df65e31ae9e255a1b029287850ec9907864aa85efee098bb14c2afe3ef0aadbe81a8ade83ad486986f514be97d9e20b194c5759bd9787b5f45bd2c5d857ffe6ffa9f894d36fe67b7214a920b2b4e30e233deb808266a01b0b9fc9fcdd753d9d43a8b0293d845efd9d4e062417048463ac5749bafebc141426b9c923d0c8bfe835c995c19f48ef3fecca1972f5d4a7304d775224ede0f906b944b3ef3ad8abd3073eea94943c941a7b40bcf0b4a89b65a23f047fd43bf99348c5697024fe55e1372ac426377b1cb2b189ae32dd3cb5724869ddde4807b669ea530eeafbc99cb48151f564379ae191ae63eed3a837c5ccda26ddcd38af789bb72fea60cab8473932f0266b28845d348eb69096fbcb077b854c5a7e5d194ad3bab03702032b6bd2d27edf487e58ded2bf409d82debcca79a5f01ec463094dc1cd96b9a5af805c13e9dea7b6204c0c571bfcc103bcc789906e501b62452d273ef5c1aaa97c472db885e1a020db1a547b9fb71114f909d6a63b7a688d886ffdcd8f04d23381bc4cbcd972984c11b80d92da777fc3f7eb0a287b047ef3d13eb21c139794d800388dfac2794685a5a0dab3f97b6e6cc7ab603a67a5e0ce80b57ed933a95418da216f4d054ad3889497562589b42586b8fe12048576229a6d7cd3b8de3fc23958d9b865f09c3a8b0883f170e1619a89ad40151bf01cc34afb59f369e3928a7dd4b349be89d1a0eacb8f1c199932837d5e4a3bdf6e7504b9dd4e0fb62cbc65352e0c5ff4715da2edc3e0d988bb221e494f4054c44f57ca19601f61b3d19dc874559ed53e25c06b415e7f7f33382fb043fff431e3fa51a08fa9c1d24fc9d09d79bb5cea35e5ee5bb79270b0c01ccef7de5bf06e0faf1a1a880d8414c52e42494367e2977f220dcf05a5536b99f812210a61a580b8ac2bb498212b526b3773dfaa7c47f4722c2404bb0c7602230e866cc7004fbd27f66557e86b5c284e15400952d858c8f3ccc0fd087b961f44fc197a57482416164687cb65b9b70de5fe7972c01d1ae3fb697a3484b591d29aa299562758b6d9ecd44d8f6b31b45084d4adce437ba5e144d736f2f5c58f8c7d2ac4f0309fe6d6c8337d31d45e18fd6fb4d0bd792d50151eca01f0a8c542e8e5b3a70fabb21b304acac9220bb9892f0cd18cb1aab216d25f22654061ee1121f2a76303232510ee01f162e7e064ea16b61b1e70f6cfed8fc43e542f65817e336bca174728a09743515910c443181acc49947101943115f467f599ba432152151d2c2cc6cf1619fb1bfeda1cafd092c06e3cbc1c792064d81e06da773855d8f2a86f3e5711c336b8fececc11f8e643b0f01d8233ee3d45d1ea33d9e7f8423c10a91642eb9cad93cc079c9e08efe4006e480f9158904212907695233df2d90d21400adbe0d22b334a8e3bd1bd10c27c89bcf74f258765663d866ec3024c917242050d6784f84c6c6bd573e7f4b5909596949744780b89c91fb3c36e7f1fd67992364f7f71bdf054315ecf434b0cae31fdabc83fd0687d89d5ef90a2920a5e97d29ee5befcdffdd2042c6a8439bf9bd425a343f5a65e7cf8104ba53b1e49ee9e19dc809589023c2a6fd6424b13a6b7af02bd4cdd1d659d98d78fe2b5252f6603bfd8b5a17c2312d4bafba92612a57511ac2a803ace5d107c1a2c75c44763c514f012a8b79b613c0d18eb3f92757a5202587b594ba3ab9868f44dd0bd2038dc70e175602bcf796a3741a5c670c227f21a63e261c63282a60d2561bf486dbc133512003509d73f9df74dd679e86572793899e4038bc763f5d22487ef732dc0d5d7e6fa1d17e8fcf15130f8a2067f6df39a3eaf831d0bdaab6c28df266dcb4c01f2506d832c6196616e9bd642c4dfad622782ddf2d819eb5a8f1240b575abdedc6e73cafc68e04b8db125544f8d713df90364534aa3b62c799b9bfce59c2f0ce36917e526045c464c698b4bc5e0016a87d07cc45f9fbca5cb40cd245d588326b69b6d6a522f171fa49d077bb26c650c5e92a808c7d26de1a464f609130903f4cb82021d6c1da86d898f5c0b1f93accde25f4d131e30403f11fb4fffea88e6429163088bb95761acca7772890083f641ad6a7830795f34a4bec29221545a933cb6ba95a895c5e384d22e77566ae2688ecd586712f65ec97da10b0ec0d6643e9fb951461456497696944fb8989d4ec56f9255c223abb4ecadad3b491e9f347defb24107f349fc2c9e8ae9ad3a639f540d90b61dc2d67b361da1613900dcb8d8da65b7861627f1e47f9039849805dfb3182610a16b461c4648ba50ea42afae1752a1c8dc82daf0058511afd7f6128a05342c6980ee5b12c2dff78787e56256434b0a19db1b5a374b2767c7e3721c4153fcc1a16fd2879eadf6a8945fd4353b2cf30228f7ef2076e207ccd725161ef779324f646d511357fe2327a461284590f92881f7fbd104937c67beb54b04e36a6f2c5bbeeec2208031ea665dae846a5b129896027fbd9162ad4034343118f021fc2dce3cc68c80acdcb8a918f1de1874345067ce3720ff6d2e6496a65f031fd47b20bde7421a61cd18545e7fe6d93ccf67a31dabddf08dc2722ac68a3246a2fe6d3f75a2d9c7c560c1df930a27906b271cc8e6c5541542cf63a541d7015ebd5dc5e806bb49af708cd2340e52c511a848f3d24304b11ab251d598031818a3f398f503b741ac3a64072599a1304354ad78c63a468bb00c060813d9f3155148cf45c5a83811bd5d6059e40980995443921e87f072c1b3b5ace28ea73be8cf20cb64958d7e1f1bb889541dd3d635f4361d963f7dd7c6ff5a6ef6a6347e79cb236509a5f592115f69bcb8dc7d635caebba24852ea8bfb762fc0f9cf9d482be7e67b2d424caa9dd2130529e27f4dd2eb2b137704fd551d5f9157ef765054960635365fe0797c207c0e8041a9345cd62f029afbf7fdc15a6dad640d5f87a36c742a8c712a2fc02571e73e75c3177de5923ef90fbb7d25f8aec43aec608f2285de6027753fb4770c179d0247796ed931355ad54e6898023169269c317feb04e60560ab06d5bb031ae7ef4f50c0e100d8dda4393ac99167cf432c3433f894fded47077841b7a8203bce9085bbfdd39ead80a7483c7b8db7e799f0bcdfc344221ceb6d2ccb7fab7aafb75f8f61f1bd2cf280c07862da5306fb75daa97617b5245461b5d86d59613b7b43f7471cff052c3537e25697db69cebd1b78a2e479c471a7b4f2cceed87602e643d10f65f3dd8eefcfdb3556a457bbdaac7c15594d5e7da88c0da7f3da7a48ab499954fa47ba34a8b9c148bac7c974e6c7542c036b27bb3ed469c6294543dff89fd05605e95cccb57c55d41d67b77b17f06fc68274fa008adb165e121e9249996d44772dbbfc1781ab370114e0aaf00b16b65827cb0afb301c77040938937f7196dae59651c39eafa95201010e0aa23213720fdc3dc0b6f0c3530c94e2894c04f7d85420e48aab6602414d469532fe83ebec2c5706dda28576d2e365a7312fdb2e58ce52d00a9a2d9dc440235981b49c83a52bf0274d92d745869a25ccc06211fac799f2ae7cd6acbdd7bfb8dee8fc6d871d2215e9c8c0386670bfb583792b538369926dad00b86bb496ad69d3ea4b42fd2e9f37c4ca93cd74891a6ff4f5ae4d0b864dc27e20ec808b95dc2b5e03829f0ab93de894e14271de2e74ee3f9c4a3cbde399f6efc4d230b245f1783b47a11b1bfe08cda9ab6f40ae79b1e7671eba4307cbf03a2b37cd87c6895a1e8c3230d03bb4fceeead49ee55d8cefcbf1f5df421aeda70af5c281b1ed395f3c937653d49eeb184c1a6aaa7634f88a7d0c57f767818c6e67270feb8e71eebd1cfb3d2c8c6901be9d5ec5f1d57f9a5d9e5e090d6fd3e697c3ef3d0ba85df71f31ad557dae82e65f2ffd5e49c69addde0ca94c3c49c7f9fc3225e049cf1c8f55abf28d3491e1a04a9409498e220f7edeb8fbb507942020f638540eff67ecaf45c7a611cb35886a025d3cfcdda25f76779983bcc1d8b5b0f98e51043234f4c9eba4b8a2d0a0741b7432b9b678ec1457ac8f9db8b65565f3abb32fbf7bedb3846bed29db1e37bda6124f6e381c199b396a90bb1cf1eba9f53b5e81f6228de5c0f92a50872e3a33be9f993ca8faceebe4f76258340bba6a1d2a1d96c5e62776493ea083c1dc3efd01320e471c6a1ba3ea06c577de7dc61cd8104d48cfdcb7e9d7a4cb5ae90221ce405af4dbdf49bb0557cdb4f60b4be787a69879de4881f923528ef650e654c6b79eaa984a680c9d570948c4a31cc487432e076468ce8223b59e1141f7da54fdefad2eca2edf057116d0699fa1262822d8db3572eceb65c1ec83423289e5e280bdeabb35b57265bb074089a57713834f4b3c61821e196ddfd7a55f754a0d76ee035ac155d0eb2dc0c9f62c3b28a6b9e83342701797fce616570b43943ff8ea4d3c21e1bbf6b8637f6dd0dc3d0c564594521ea9f9bbc43bbbbde0f97cef39eeb617ae46260e8ae349b0909aaaa1ab8bb3988b2a23b2024f09ba077a0d7f7f338f7efc4e9ca500db679d8ea9c868a0c44f3d147857b8f7675db73b281a09d51ca1710b585abacd9530290857a6333682beb1c2b0cd73d046295897abd870a0f1042b4743560b88b3e046adfb860c1b6e4d6aa3593cf8c1451d4b3184e1cd4e78832252966a01eed266f0e28ae0cdbf3ab920b2819e87424ec5cbc3d2da2cf1eccc7f3063cdadf16225c7fb0362e27a71a8f4feaa5219d02026ee6264c0ea82226ad7c6fcfc549907177da20b717c389b5dbecb58f5c2d17bba6fc7e4bd4f32bab5176a81aefb7566d0d14d0bd3be8c15227e5337c00868fdf69384ec65c68828c8b79a98bb0b9a019352d0f0ce6e4d97744e859c11d2393dea029ba2d006818f1a369b3e87a6fca55fb289eb6b46ab2f203854d640293231808c721fe96602c6cdee7a72d31b4ae6809f7eb7540054c02a2d2ffa7cceee5fa9f54a02932ab9b49e9393480e08af62eb81380f82ad9987459b5ebd73680cbf1c1d0b75968b82678d4d9c9f3aa67a7e98510e3c14c0a3be0b8c78ccb2190f5fa14cfba7df2c2e1e144e03f429024d440555e7a1e8d29a120904f046c6016e3b30ba87d9a6c0071515e716d441177f74c7cde6a63cc3f95d330a4e6f7ec0500948ab7d84ad456e51f7088e2319f8d4550c9c5db52ad31d9ec9728e8d81f8bf3f5247bd48a707fc190570286fcd1d50b65f129cff36d727b01ef77480179d54800a2c5db1b9fa141e4cc435c72eadc617102eaf5abd491345f8c68f92059f1e8cfa67780b2934eaba9c843cb577a75ed626de837b07d54f61571f3477d03868fb9b9dbdb20972208de688d99fdc8fc48a97b38a71d4ffa95ff95d584c71fa814d01c73ce11d979d7cba330edf4c811e0dad7fba439f039025cda55b31c3eb4e682a71f651ecfdb11e6bf1c69a6a105fdb94bc6668c145f418e3f636ecf147533cb8a2e43bc329dd1ef108545dd0bfecc137347fb1f21fff3f0974f9f7190706daac224999ec11bc11d9b49bca2b591f1408ad9ecafbe37df01841bfc182f9cd47a8f708d76b1e51dc8aa5066e3ac7e0620f8c6798a756171a83df08cd4e89737400d81de14e5d8b97911b0f91fccdb41e7c284095d86cf662d43e094138e743424c2e6a7cbdecf4e2d74081f6d02d228f3a4d1caeb717b1af66ff03d62fe0045064e114372e60d94aec3e5cad2059172eb6f8908f8e17fddca2a38099cfb94c2040062c722f157570c3b84fd74350822e60dad368903e9e23312e6e94e6db0ff05f2677581cc5f43c7ef8adf772dfb94a7d6269065e65647fe74d13dcc32339befb29721f334b2023d399cc10dfe525d334aac20758ea04752da502c73bc446aba0e6e5cd0b2a3559f02f5f0092ac1174019e09d9649956f42c28f761f58276345a547777637d800a190919199fbeedfbf0ff8cb0d9bb4943989a82d64ddda9fde6746d5ab571a12a53c5450edcc721fac4842cb6a5e391efc46f15262601ad28303252004517c3dd7b4787838c9b9ca2d830bf80a741a45c0ec7ffc3e30d3c37f90dd4f7555ac57527bf29e01a23fae740f9303b5aa3884dac54af3327e152ce286421a804bc1070a32b709b667a2ac263c5c4d08d8b4b59ff6e502cf8041ce7b00e8e421ac44b32b1df8f6410c95ab0976d037b3911cacf6352480541bbc15a0e086c73b75ecb84a5591f2106fffdf9e9fa802b0f1fa6381467575ee67417e146b675569fde94fd7aa242ca40c7467441249224a39645239f363ad4e5d79c9d80fff7c8d38d64c956e7972bed21f40ca1214ee0e39b1db955ef3bfd243a599908186cbeacd0669f113c4f0d0b745f9cdef15ff2e47e7b779bd1407ed7ed2a60ce3a962e1802b2144f58cf031df262c3b1ba2fb953962f7c100a5b5783aebf39f5544664cbc363822e26515acbafac5eb5ea526afbd22ef8c0d3e8c8d554e00b34fdbde171a19ad8d51d43972211a85419143f0e6a2569783df6b6bc1eabf3479a1436f3dc0a7f06ece724446b729d89756595064501901ecdb207e2afbbfde9eb085cfa6f6d121c962fd616257c65d16cfe5dbc0cad1ee3ae734dce16fa8a58c07e2990ad693b85deb404dc876864f012d445cf3bbd2fe6db0dac49708f6a2b164fe5d623c32c79efe1c4cad900246984d887144022cdeff2a3b3244d10c42112ae7d4f6663350701ec0772142a3f7aed8f06004cc303587371e139d247ff325b1382bbe65f2158db50358bb43a00ade2aace2685fe68e9a4db1ee22506a55b55bcc9e9a2abe10a57ef646c1dd598ceb42b21170da360ce9b2589592056806ed664911e69dd8dac83163e1c120ac8a891239b0ff7ded55950ed5a014b956bbe31d425f93507e2ea32b66f8f131be6b500096342814bde691f8f6b9ef3b6a16bf63e9ac98589d9d845043c69f17fab317e8c754d90a6c4ad8f74dcc8d2f22009ebd80a493e3c1ba43dea89a17d4e55e2ec2997d2c045ff1966a3f081102461b1cb05ee9c27f011ed6d432690a5263492c615340a833ee75ee6fe05a72c6c5be3c38b51cf385f6263418164e9de6c7be30de5bb859509757953e655f57e5ea9b8d43a2587fc7468128c1e855de8ea9a525d5b5c78e84eeedf6465323435e6bf218f1d68225931a70d7a8e081d35377aedbd157fd9e5860892cd2dbcceda4dafde506b6182e726edc0254e2b8d5e6c4be5b27cad4cd0f010706593efa57ed192da3a1afb35965a2134cf768317f60f53b27aa9cbc86ae7c3e0ecfce38fc6b3463d2f1eebb07dc5001da07f5caf0a3dbcb649ddae8eef496ab00f31b56952db3421c1048a2ae8480c99a3fe68cfce4a0c5f85009004930fcdd6de5f11842aa28862ebc3dc2256568f71b05ccad57bbb2aab89e3866b72c44b7e2b2ed03abc073a0f2dd6a14bc7cda6926749926787879a00826e7fec8219b8abd91ba1bd7ba322a44f74548719c2ae70f7943fd5ebf4bfbfbf72432f6c6cff33e1fb5cbbe501f04eefd366303bf986a92362c49204a14a015de1645bbe2ecf8a3df07dad17df25120d3ebc53c2b20186af7734d7426672224023d3ed236f426082f064fcb2b17ef87e90846bdf884149252011b8f49bbb14e0fd14382bb4a90401259c8450ebf7b1a384722b262aed2e244470aadacb85b170effeca035247367beeb35ba81e41eef8d318167ae69b2b0d47aa223e8a1c701ed16caaf26f19640d8c4c6a9f0406611133dae59c2e4a2476a3fe86afc11088204f879f81cc975586c0a9b8bb2536d7bd59730a8c00f27de3d767dbf221e076d86fa72e36d3537002a744a6b3d40c835c461fa819469ec782e4c261ba85e1d0c5aa87d88a36f7e6b81d01ca55117a3b05bde160915cc6c4ffe5661c583b1ceddc31baf854ea24bd9b9f2eae28cf3372a681891204a10378438e03d8093f496048b7076c8ebd607b7654e1dc0b90cafebf4d70283fdb19341a3f57da5e3799cb61d12fed4a7bb8f3af3dd3141e75390792622eea880501dc9a86814e291666fb0eea2c5e54bcb3124ed4f0479d8e4831871249660e8b278af5dc7e0b69a97defcf43ac62bd526e9e5e8849f9e23bedae3c583e6a91336347dc0585f55aee4652e964719f366b0d5f913d81006250bddfb34d9214719553238053e9bf6fde1e45ff6fb5072f5a88997d9d9e4083757fc9699686b908549fe37d01a8baaf662d248ce715f0f25d0ac511e015913f682e07da70e226485720c9afbe93f899e40dbc2139b8c9f165a74f1e33e2e1040cccebe222b4fd1a0cb89d6665ac5569108ec7b50909adb70accc0f77a4b11e6c6c5918e34c8906d35cf1c81fc87fef49d2e457596e5b9fe1d6c0bb6b68d47ea5832875f25e144ddc8c931bb017462e65f6c46c066e69404585acc3b245318c337a2df036c852c801746f3a33acde4b52f26fc8e2a01a24516bdae3669dbdf55ba5f634be947e247236120e6c04f36d700bd8c91558d0b874dff872557cf46fafea6d81d21ff2c1a4878374ea96c2e6cf5200c0449c90e9b30218063f303659f9ccf49d43cfce8788d4e6e240988e74fdb72599ac88612b6df8d1f4a8be7c2ceaa3130b87f23baaf953068c8fb4782641cdfe96ce9263e81b53a04508d4f27a35f0b23903704e7706ce935b9f9de6216c14c37ed344ea2c11109ea09b67f81d07a9c5fc5f855a36fed0968629d91760bef9184a39b5ad5425cd427f5f85e0c844f3c879bb688fbd0ff75cbb78cfe2c375299fc6cb7a617760ba8eee058868cd3581de4657d40584828ddbec8b07c781576bd3d30a3ef80950c61761c90fc3d95b3348e67fd7fb267900de6dea95d183ac714a4514c5df4cf5e944a974fb350169591abdbab8fe257894fb39b2d5d4dbbcac79e225c4e79dc8f9318555e9efee0da5c52a2a3e198893662c6761656251040a776db08273b9b71892ceaaad616e15dc5ee0439deadc459fa661b1a924daa841d1dbd7d5d4a13d251fda017103f7f736b28e5ca9350a8048baa8cf8e17c3d213fed03106bb55c93e81d5ae9091092fc2c726d711cae021a73b5cbb3fbba92fd3330ba3a1d42e7ee8dc44e9a754d8d6fa3d53111f30f50a2e6dbae9c4314635057e235385a65aa2c06f9923bc536ccd5a219db387982ab4533859d1b18f7119027bd8e3f82d38827e2b9de8bb0e10f4e16b5a47b93849802618e93b8e5a66ae22378c2983764abdce9afcafdd5af604e22a4c09ae5b477fae278c119d93de22a21abb30238e6d84ec64fbc8f582936119661ef9e230a646d31fdbb1dc2bd30d15f12f7e85d77f1d1b9f3a069145efc6b4e5c7d9f78ca596bdd74ba05458ea95e6bff7875a48c300433f9db3ac6437a22d9637a66dfe6ebc9a068ba749d1e187750078a201afe5ed75caad9ae16608429715b13fa7616ff2f070323bda716634c0ec1f0309c4026e9ba6847d17c50be74c982abaaa2519d8cbe5f288b3c008f73a6d1681cb4ee52830dda8e048825be4c4f2a0acbfd3b6f572e35cc8300cd816ab443c8972b4f4047397c4b3ce918e68691fd51722ce7e12f9ee74feebca6e7ea2132d032c20d1a361f9399d6ed6bd3538725fb844600ece99e9140181c2b443db1725ee6a47eca625cbda7f3be675477b265c66bd7e6f4bf3fabf8687b9bb71015fc595b464e690e19a057a5bd81c54276cf18ea11d5fe99d78db9771dc833a99c8cba3fd8f643a31373c34d505b702758f0d61d00b5a53afb61f1ab858275306ef67257dadda005df42be0a1265285fff4c0b091d17996a9d13e74a33dc19ae87b9185c7eb1709186d56bb53c68cc3c44c7f13589085a3952cdb090a74405dd8f9bf1c6c65f710c623e28efb8759eb99710ea21fcd20137700c98b4d3141eb0170d4522b8f178f343dd5fd7fdd03a858d4c30888664d23da53925ce5659bff0351768a3e9364d94c2ac34400ea0fb7e2400730825fc5b00c929cc188d94803224760e292a6f3d23961943c013b08de750e7d151585bbfeeda10fa3ac6f2ec20c93bf6526d24dbd73900a7f80b4e7b7ae0168c34cd8fe6175601bd4da5dd481dc69876e39719737845368b741089da801277118a139856f030beab1816d39a37a6d748d8372a9607ba60f8fc3178b1fb895b5b4b25a4bac4ea8daeca24e2a77c44515711fbe8e525166c19bd9809c3d2d4770385f4af6301f0768676dbab9b461860f312f9ea16e2bfa828cf81d9cd5b23f4094f8f2bd3a06c7402428f34140b04d4414eb6e966dac54d053affb2cdb91967ed88afafc09f436d69aca797bbdd3be9fda522001864961f8f81329b3e2bd8d90b248b61bb03f9088f4b00e55fdb55176ef2fdd785f204638f3cb8f2202dd100692b60e1412b979bbffc030763b07301ae0d45a819870a7c1aff591f4bfdd7f5e37bc7ef98699ea81c172c0329d93a844014334fe1e5f6b6bb0d26b19c0360419b32976f233751dcd96861ec05739c1f958cfa1541764760cae16a0144c9951e3f35a8d5697aaac59444b9a6b584056c7dd53e4022733d50085018db69b3ab89cd546b67ad310ee9acfddbb18c5642344286c0779bebf094389eb62a6d9eb42cbced85d2070fccb266971b6d48b8709bf702a76647e560351c6746324324f27b01bce0a12095b88b58c8fd78dba7b0cff6ae846c2a5de14afa6b05595582e5c4f5e85de1ccabd15e328e1446a761772becc078cf82e2118639bf41217883422f7004f24adecdbcd252388816bf526c7c167730ce488d510d01908faf0d2534711928aadd54f2eb22acbaaa2ee0e943056661311a74aeacdec3e199a528a393388fb8e4f3e28a674d011984152362f95303c35238a4f0eb635fb7a6539bb57942fcc039bd7d9e70d3b82be109a1ea905ae9a158baa29381302383f82d48376b7936842ce6aba09f966bcaf7da2aa8af2bc7f9ae3d7a1f748b3764991c061ab717c79e89d6152f44b1776a178f594fce5af3201fcfec905ffe78d02e0eca24cef7d379e23ab8414524b5cb2ea4ebe333b9d7f481a8d778b10c1cf2548c494db9a054ef0dce6cc3565a921653dbf2c456da188a0e0f76bebbef8a5642cded786c72796e22b3ca39478bd8794b0e7146074bb1e3f604e68d59e38e85281f7052df2277b4657c32c1b32d391697cc9e36641a2a592a9ecf49a8b935017cc1c570596ed986e22a5ba1d3978e245b6db2ee4e29d099b5a8f42500457b2fe122bae734ff78f396aea03f58ee9064f4c1fb8781d84bdf09ae9e4127208bd78d894377a314e05a67d2d71f2fbb51f7b3a76b66dbb99efcc43b05dcfb078528df65b6ecdba431597a3c3f5e8932cc11fbb683c1beac374ccd65b21504501ebbb89153b8b89ffc8c6f86d2b4a807eb01559951d837e8f6ca84cf333b7eac656ca0e9b9230e1aa537c3291c33c01050b31d9a1f59e7d117745331cb00c7cb30c8cb12d8f6ea162d36fd37b9498526e0e9d03c1d651bc79b32e1a444502523166499a3d95e58530c504263e783f3057cffcf124104a40fa5fdb47a7019d2f38918efd9f07a54e2ba27323507caa948c4017d618c07a1597db037aeacec2d7261b8aa62b45ad238881876e6b813d74011eb5eb99be80967ca280929551c891defda6dac26e5c06139e08af3c964244df15d5789c9d6801b1e0fcd93fa84c040dc2a355de570192571b9a37dd7ac722825d8848b3485c7c14fee798c67bdab5ac56fe24971fad4cc108741e29039f90167d69d34d19239ad45a6255826516a7ce1edd863cac001330b726f821ca42de61f233f53987152585976b2431fca1f4b80d9b057f3b19efd9ee7d68d2749b2cd94f93dd0ec91fbafa91e0c2c0672b529c1aa7ae21331df3660ef24ac1b82163838a35e5fb64f9c6a77b38211ed204b00427a066f1cabae15017971a20b567f4b688cbab75668c5008fb5d6b06ba031ef29ca92ace3e64be8af17e3d9e987a1b3404b3eaf65c70bd06b2626ef6200a2f69fa4a0b63e43e6daba98bb99a385eab9ccfb04866acb6d4270c4873e493897ada054f3d6ec5f38c83359de918a0e70f563c737af22b0928c7e8dbac6f8d68c7c7794ee04e5841700d0846fe9a73dcbd8f4b82c4334a52c0c19a24bc0e195930098528aa6d2037dbd2e135d38b4ba9b1d6f3a70253f8631c5792d8ae95299181506657c2c84c3c5d772277a9d27197173b64a32f605dcea45e0489478a89dab9ca036115486ff86afe8eee497cd1619c3bf67552deea6df60452ec9660c07372e188cc9fb97997b6f32fda7549e613c67c558d61002132bc6ff25631323bf58a18000385da6f523783b89d1291d08a32e281b078895ac5b56e008c47b483ebfe61bcc58003ddefac7132f555f0e0dff22c606f090c66e88fe6b9bd78d551449fc7a2802748d19af234ee81c43a877340c9a3f9b92ceb00f00e787158981313ea7063c64c001bb3846b4a4c18025b1dc4c5aae8cb09ac58f7ba642c8f1d25c99dc6cae839baf650db96ebc6f1b172873650587c368c01b0e9f149af90b69585dfd1362d1631c78796ec6915383eea8e21282369319fd45ce84a89d3bf0b3825b3e7f2d61d8d79961a439f804fd1d351c67d161b2e617c4ab4d273ceb9ce7ad47d93f2c51b45877930fe95c56172b5e957f3c0310933d10045aff1d40024aa59ac076c39652f24c72688dd5e968b44fe92913847ca2bc24c9fe9b572a3c75fc7361c4753d042accfa3b111bef93d59544da8cd6207b5c5d6a23f12ea9cf713ceb2d67643e6cd02e6972f2414d38d4c7eb2da3420e256c65376cc6f2bbede6283aee586b1500c67018b154715dc3f2e732fc3be9048907f9a9f44ce9743fe33b4fbc9a355ab437b288cfeec9b2c30ec6c97bb2622ed2d8955d2fc7ade7d6555fe1ce3ccfd19a9a54bdb851818372473db9366061d96c07341182b1e389741e5b2edd963e47e8991eca9263ea03f2b9c1374769b3d4b2731070bf11ec39e1b0647dad620475c1f17e32128567c627139a36fe361db5fc837df9a89b7ad1528efec27d300dd8da954cb522315c2683a3075ee55e385c51b97d4d9ab523cef14837ce6f8b45bfcc4a2d5694609ac3bedd0fcde6d8381cd03d4523ca0380a589ce2b6f630502222024e112259a337f919ee887f3a97dc2e7a3ba463ec3478f98816ae4f65e2794c1e98ce03d8e5eb3750716e0531a3245a44c388aa1ab30c171435fd26ef86e9350673830cabfb2deca9c2e552bc450c08b2d7d04064fd58f0c22647c27604b6ebcf2fc704e433c3bcd60d5dba49ebd6b5285524dd1f64376087fc96d5f89d3fa4c7b875d0a8dbd69ebb16f1f0de3f9fdfb60f1414c539cad63b47c01d0d5b34ac29c1a3b8eca54bdfc029638f1e36a5bb564ea86e121","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
