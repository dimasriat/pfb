<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a26aef597674ad45e2ca9d511cef3677bc6942d459e906d7a31b62016582e2f4a197289bc0eb129700b9e0749200941199faa7ab0ad05087e8d1cce1b98e5811a22af194ea8300349d580485c9258512003c0b4de18b4dbd1ba556ef09bdd335305ddb8a691e614e0432541f6b31576c439af03d421d48feb10566b2bd2b45c8d206c919f46b64f534f8fa52bc8cad2a5bcc2859f381e9ba056a9d457fa1cf3571a910e906f7e5b80a0ba8cb51b56fe56860bd2d07ad9a4d4695f698a393837e38ee95f5ff187aaecca5a08d9b716b6ae66634b05a89414a36351e0539a5d915a1bab51694b56d6380378c0b90b39620603eb39bf68f90c39e33967c9876950fd041d7aeacc7bd18ed1b918bbfa53e344c5fa514684062bc2c4ee12f28cbbb461fa149f03f43dff1d51d39888c5e4d0584f06f870643324d0ba77b3c0d34f0eedf939b479af037bb5706b53e509c3f1f07a41751d6bf71578b61c6330a3c6e0088dd6acd5d611a24af9b487941d2c0e31bda61a388ca909defda835f28429671bcdec636b154fb5578d614ba243d915a77656ef6c8fcf322863abababaaa6a37d0743bb6a60ed0fc214abe99080709f7274bf98867c8c7a809a2490aa282d9e1ed8f64c7f9e82b2dc6fce099ed027945aa98dc60af85f5c90c745131828df1fbb150c418a99397d527d13d030a0c08ba170ebc3df7a6884a6b86dd8ddb849c07795ebee445ad8992a22f464d7cdb161521b771ceeb8b8f882101a392da9c50c9adf231fe81750db6020c8f0233057c96bf0da532499e58255004096520c64e8ca0caca381a7e741c420e7073516ceea6431ba83c5e0ff02439c1bc8b25b3a685df2d09bfef6033953db6e3d320ac65eafca559e6c2806cab869db469232ce18e31279fdc5c8132841167f7946f034eba0e7de7886e7fd006161e8816a670edd2be6fb4c68d28d481b36de7a70bdd71f92ba4746772165de86c0f5955b75cd39bd5d456daaf549dfa85be4fffc1bd80e5a164a5ba66318fbbbd262b3abe24fa8e7f4b6879676c16932ef26e85d0a6c249d8139fabea358b38de1111f84c414375815ef7f7c389c8068927e31d8b1a62d67ee1283874a19ba062e13808628a4b1f83405cd1c664b3120bb6d913e23b19e1b58436dfed8812de7080da19eacc552c8802cc06d15276b3f0d2066ac172f37567604f31ef71dc02d3f77df36d2a35c38143c1bc9cd25300858395c072bfde7d41dc5ddebffb1c155ce4f08ef773184839d3ab0405dbc2013aea1e00bdaa9ba613ad82c089f8b4ad413954f1b4dc68215e173c2a6c24726bd5d1b43c6b958d515d7057a0d71e3f2fbda02bc41237fa69ddfafeb1874baadc16f2f2abfee1a29c45c51ff8eb39dda760df02e6cf2ee3463719a0bc11ebcefbdbd4f95f69e8df88c4189ab3c4e21f5c7a850ce97d477fa0bcd889ae81b1c480132fdd528470c7a63c798e7cddbd84a1c96474d28776f837fafd6702af5e3b3ebd48ebe27567d2cbd12a1fa93662ce92bac0c7b86af9abbb97b35ac64c45e2443d4e143f97f4344590b64ad3565b7b4cb502f16069660dfae34124735de59865495fff1a431729d05f40855aa5f729f468d3feb8381345068fe4cb5e220681b1f01bd828fd42407ea441e2a8f254bc6c10623df81c601f31a176f002d4ee0a03bde2ed4c40a89f1544b7478b129f57377ccd7e81a87410d71b1f6714ffa73ff688085fec65a1aa9e43bcac27bfcae0c9afa41f30d73feb034c63e7e4cb4ca9779ae16b11ea52d408490034d9e24d9ddaad3bcfcb14d220a4a227a35d10dd1aaba5fe1cf4c27af490bc60a75724f1966eb3265db30b5d5ccf78a54df0bf55b4d7e11d927986fc058af7f55984b9b470b21e1bda79767cccd9e2014ac7572000edee462ca16601fdd0f259d46ee4c0672e84615619b794ec7ce3cc23ccef67d8681dd8d2b2c6b137a9f15b317b9454cf62677cbbcf1b1e0642d337bd1ef7faae88a71fe2c741fe7c40f160b5d7eda8b346f166ab3771e48e44fb51cd157e7bf3110800e81f9db5f83c9db5942294001b0d55b059c6f2adb570b695272dd36ae11dd554cbb3bb9375ede2969462c3666d5475cdc6e61d161ef680399b5c61016dc78a3fc632cc695d91bd6701d9b89075f4e8bcc7398e3b1950eab542aa99b692e6290a665a9723730c12c72d59e552bbf7052f0a9333cfa47b406a0b8f649dc6e53528ff760c198c1d71297297dbbf507f6805b70e19689be3f227dcb4cfa1b00f156e2543769df9207b148a051fca6c7ef91429ba5d4465663e23c7601d5d5361a6354aa66cc947295b837ee7e1afd2c0b98f330e6ed1cd382cf90cd12d8721e896ea59fb49d5aa061401cdc31783a28be1d0fd2ffc5a8cadb77bb9200db8a04e4de31ed5cece0e759cf27b72d212f83953a8ae5b6e029bd3658b6ab295d2d8a8e02fe4b383283ece871e0dfa5811e550fc69a8252f40bbc65195ac73f767d6f721ec2edd89af42809b781c5724d1f3fea960c6c91ac3083247100ca6945aa1a9d7c937ccd911af4996e0df9c8780942329ee943160727a35b5484205fcef814e709db72d9fa79d20fa9334503465201820e9cc56f8c1f86120ad7a2d69edfd64d235066b031e50d91ea4fc1ffa81d62c47a4c12de9cdffdb6adb1fb586d2af0ccf519b52cf08d53109545bd8a589d2d6c9b982b2643d37e540cff1a3fc987799c91f9fb64ed84493cec847d799de32e5f5cd34efbad81c498d4e62210d71bfcd9f2bed4e373ac8cadf853abb755aaa929dd8aa0bdff357497e1b15bd41a0296d3122748863b7633a5b1e330f3ac5f620759519a3a4522a0dac7e49d84efa595f7f67eae5e17574137a2f7c894cf9c37db77de83a1fd96af69bb376f608214bc0567b0b82af2499240a3fc3d307b050b87f87535ee6e1234a8c6244a89e51dc38d966c1a71fb1985cbf740dd672bcdb4a7822954c252da729dd51351c7db38f59aca0c2111ae842eb3833dd61414dc4a08ec70743c886c7d79e733eafbbbb771b2a032498e790d29884cb928b6db2fd6083c42781f6958c6626111fde345635e42cfb7068f65d1e3e8f6560fff4a6aac9d65edd4d14e15e5abc14261724953db1c0f24a53a7b43ff4aad77b73450de8c1dfe85c8d3c73688ae2642d267ecfc3aecab3e805dadca0567333b9933bcdf81306bca370fa27f8965232e7ed299fdb96a57e6bee07d96ec0485844f97c1e92a96a3feca4ec832669b29d3700232837357646676e7baecbb617ec8f16ff17db68a936c6eea052617491ee3137eebdc5fc7c105b0e4750009ee447497ac86f81e5aabbed2749b9b7a2914c9afac7131d9613378415c932d4bb135ad5086e42ef64043e04a8a976f3e1919464c7e001fae59e1aa6376b4fc76e925e136513953ca5fa0bd56e02b2cb6bb9591f2dd861f9adcef56a66a7b77be786edbe5ca5b0d6591836e9b2fa383b852850ea41543ed490a5c0c0b7784ce27778131f08a5c3c3a50b1072a55a0fb62714ae29392b0953ba6720e9ffafebc9c94d52d25f983a05c6953546f18d0b1d37d5b1de6526167237c296fb83336327736b6f7e622604a284a491eece9f11a28d8a4e3b528d42b3bf6171b350795b6fc59edf95064e1f14772db0822b8fc8bc20dc80d4a46418f004cd025d42a2191f1a0b5c229cc98b6e6738d1af95a24728c68ac727bc08fbfe3473d98a8f99d1b64dba3570a2a15bf8b1d7b1ca605d69804dae6df34a177f9098c16df6a1cb0714083989042c270d8dc4cecd81a7b5d116abfcef52844a9f5e67c1e4a1d9fd8d348ab5b84608753b00433a896419d5752f05b6391aa8f08bb13c602fb8307ef0f4103db029cad4c4239b14c431c73b655291707e76b3899c331393395aeba3b8c6a9583ab47c4c242c57a4a3ce3aec7181098a55e4c47f331315d99a6a79bed6fe3577d24981980f25985d9323d5db5e666a05d400d5e636cfd5beab22d97ca700de4879cb00442945f3d12cba4a5d4bdb530b766c38c8139a9430cc7118126627203bd29b24bddbec6057c85dabd91f507c7b267188adc0e8d046da7bf23973a16e20a400685424de83735f8d806108227d8f869971071a1ca957e1cf2079ea1c5cf174f55b8a642b75de65369fd750dcd1960f2efb3a04e6da5cd74259aa96ab81075c71392b4e13b5116c1efa9edac56fc4faae99a4825eea9c517598ac346917e85d5b1d6cdb12842b173848149a12724793b65f7e2a119d51ced93995bd39e9ce865cfabad074394decf267d017ff2b3b8235f18c7a7ce82120d6cbd92a6c2b4c70d25901e992ee74bcb8ccaa65a8793eeb36e719ae47e46df2fbd551eaf51e8c7e30f2363966717bddb4152d9535bf53aa90e1871ba6e18f73f6d31ade5a0f6a09c2c66463e15dd8fae49770b27c82ed5cf73b46f19548de3c73c8fe62d5c3a4136a00e9f77e4e55f4bd2cb5de20384bb7df3e9de5b6f7148014d92f2124a73d3e10bd18640b561f67c61f09c39a8a47396242f8c6146e4517a4aff4a98ba84a81233d1e6813675f2d8fe5c5e3ba8360440ad9e9546ab707d12914a560cbb0068b94414204e03ca5d3312ff9ab8f8db8a96056119db18895f0211e3a2eba8be8b38909d2fb3212741580a35f1e137a5093100cad8ae89c2716dc1a607e0a8e8fc3a09c16dc679a4c2a5c03e151d1155fe8d6af30a1b07063800d37db1134888bd2e96214b1ef7c038446115fe7aaaccf46e0496c7d3e982e32fd2f6af4b8004c6a418d5f59cceabb6d7112f655853a834a80d9b6893245ff0ac1798f1f225930cd5a57fa4814259eb132df25a4716954281447a9878ab653d0158f15a8543253ea84256ed9a7233fa94d14238595ea3b4d652f401531b0bd1dcae9166a833d49a4cf2570de6b8b7b48242e3ee2fbe15f821d8e9691467a2a5a70a56e6b583046060adb19f78ecb941f572b8797791310689c7ca4528a0be0b48dc715706674bf30dff96c46994fd4051b242707f1bf1c36aa32b67d88d3d7f10db5e8528ad7ce15afda7c407b4d1e2e65e0964a205793b63ea50154cf47393e9ce66aef23823c50827fb890dfeeb3c9d7635ae2663248fd7b93e32dcfed5335f651cfbefe2967ecd8b5b2416c202a0019ec9d9b618dbdb2b13756d02e09ea8ffb4808f4c8f96e1bc1dc9db6ee5819a14ae0b9fdd3ff844b6d91d9907e1b4a4780e82dfe1d72a3f80095c44b346bf12e89f2a5331061b7367f87f6c2276ebe3412e7413dd460540b3fae585680a5c89b8d8e78ab77861cf58f3489fd0b3f1c504a8a27be6af01acb130fa85e68a6a6fd718763e270fc7798a6d2d8216ffb6480b6f29169bf14d3625d7a15f52d8b88db82d667cfd69f06ea4b15cb936acad281af62ca63d5c10807683291f664197e76d3e93c4d7c4aab732e54d8e07aa8564d6fac84d2a87ca5486c061b52684f89d538e84d7c0484f2501b8efb33f1ed60968bf5dd0c2d928be8dc246a5b9539aa41310dac0eb5a47eb14450b55883edd5286d4101b56c2568e3be973714fc239498f6a8a35f61446b093ae2b7e8e0f05f06e0603e645cdb758614326956b440729c38bdf8e808ecc53fa0d55dc1bddf77c4b6b436bdfdf00e707a1ae8c0a23ab1a99facb41a083ad815da4b7a56128bfa6a0adeaf3e92525b3b4adb2fcf89c807fc3aa2300d60b6e6742c583a134b2e4cfedc6df70d3106385849f3918540599e11eb2c90c6ed9aa184d5cee9c0ef49a197be46087ba1b717c58bc7bce6e80557e0f8792a11df3c4c998f60a32c9664c2af37e05d6bc841d9fe8211639bb86d0df5d7b8a7be549f771e022a9385738441e46ae736d48c639403210d53f33624472771a61e9411adc0eb2b5cc446317c32104baa1ec88e23803c7a59611bf036e63cecec24c2e1a0f723fd6aa2c7b41c3cc20df9cf4695d76c44f2c56ffd9345c56f91ff20d82bb5f91975c76c3c824adbdf5d5a68041c14db511190ff4a02ed2ea8e8803df1f4e0546c194f5cc09aecb51e300288d0f1502fc4c5b5f359adab87506bc3f82c6437a499dc087b39f45f36da7d86dcf2ecf956ea5bff51f5a77864b2f3312cdce60fca9d2afa004ee0d766cb12bda9bd077e9e16de61b8e21340548342b73ff74137305927e08f9091638d1b1b2ae3b4fe69322828d354589d8f1f5a69ac4f6138316f4819094f5adcbaaf6bd0647a72a0c76f6dd216ea1fba56e64fbe47852ed1b17f98e566799f162cee32fdb8fe8c3c41bf3b35295a1e5a227aef7a89677353603a75c9380e2359e5669625976fd426eb888e3ecc0e593ac8e61c7df09518bbc105e41ee4f243f2267a62c093495e47e2fe196f128a69343240c7a1f51b2c1dffdc803a3583142bc66c8a8b93117ffa54a0bff170effedecc5884af67649be7ff35f3553229683db6ea9840acf8d4e67ab83280b0906d294421e42545c72d9045155a9779ef880a4cb911c9e58e7f6afad1dad700347a75214dea61f0f9b3d7f95a24d55a9b2e0d7d07fbc54c2c0187f385311e0fe31c466af0c1f2cc13a8e26f84c8446e1733f3d1a723c2f2506f391faafc55bfad8caa451bd9b680c007fd21e32fcca29759f6e679e9265ce818a12f83ab4745a78ab4471cf753811e0bc7d53cd5db215ed3fa91a9bff73506fee4028c93661eb45e53828b7f9f8b9d19c290dd692a04c5459176271de4b2608c806b14cf161d9fb1dfd2affbbe3bd3ddfb1bc3ec776c1a2d8441f2a601722237d2317aed018afa436f76c075c93f9d0812eac99e0f0788aeeaa5fc0b535de836c68e69c8b28065a63722f9dc115cdf71c20e30bc72fd66dd07830d4d7798cd51eab041d0d78afa8358ddc08da1dad81cfdda63d8ed648492488c051836475e1056d5b31d0086f25f0631154d4c9356835c98467f51fa58cc6837798dc68dd34653b4e0f74273a6cdebf2913fcb2cdf6bcf1168e5a7e99eb3ed8125625f7bb96bfaabd593d4730a7926b9279164801483a5cb00488b4672cf3f3b6eca132b4d2e5e8d6b490a2f3e0ebfaf77ad64b894ae5b2b8f0c36a6019db80ef376801b07ebc684e42a10f49aa29e8cdd4d3fc8136c7425d165352804bcf90d426b96d2439fa7bb8cc9f0e71e32e9ed539e4640e1039b208e7671703fe1f1cef7a0f7edd7f2470375a142b621f0b8b3a4dc520dfd714bf1d8670f3a61da7da2b0400d120cdd27646cb4d899211270a4510b287b40ba41373981a3b400c8c0181162f739d62647efad8a0d1d227e143a1d96f1a746fda1ab1c4207b1a4350bf8aeecc6a9a0dd5c0ddcc34befe6434dbad976ccd4aa3ed0d5450116dd01cbf85e94b6bf33254aa95c3dfefc123079f7394e22e2e247fef9542b32824026cfa213c7da7a3205466d7aa0755c6c30e64680454d6d837d0f87cddc2d95f8d3b71679b35dfe77cf2e68f3fc0c1ff6eb91c377a05055dab6a1ab6f5ef53c9aee0ce37caa53fbbbead02ceddfb8d304f2f43ceda9392a4ee22ca68360982dd3c773064012fc49ffeaa963eceab02aa2d867ebc44227a3476f4ae3bcfc990395ac5e9b6d8a4062a9bb1ec740d05eb40a8f418271ba0a3c6d4fa9d1c7748500add7e9018f5eedf5f3df7ac9987f15373a5065c4643b2d777f215177fc65454710be2c58a6cbef0e4caa5d39c68239be400e47ffbac29138f7835f5f5ddeb16a15caf1c5f58cfe84f4525f2a7a166c7e0a418584096ea8d5d5807b990548c4409a5f9d3cf4a9e4de2b677e3b775efdf8df8ae241ffc20f5a6cfe53d9db09e3abba7c78f16109a0dd46f131f8359acf86690b9c1c51f5a17ea050bdfd73ef714908b475667668eff53f49af9a8bab3208e8e77b720ac3acaca85c951a9a25167371fe2dc1bd2632f6878cd2473e66221d3497aee93c8c0c0cef7ad1d2a8063efe05b4fc8c25782be507753b7b85aed98ed289902115434f43a50ee6aa53803b56de30bd20aa2103c957854437c4a738cd9a582ebc60cfcbd55543f17884e79ef67e51ab0c57ee9022656f0eb64334878ddaa0834d5d14a71f37168d3443ea6f53bc2d067b1b238c88e92a09d7221687f044780e849e451bb1f3a1c75021d037b81f2be5d5a2fdede88dd90e53169af46e402c73b7a62ee8d4fed7055b70f628ac0b4cd2eecd145dc6596f1db908e4867241a5d1e91527b11e042939a0c04704931cd21b40be89eb600c2fb2bf94a54039071abdbcf2cf2cd0ed671dda3d502d8ccba26a09ef5bbe373f17238bb1b73a4432c6ed0849d7b3fb122330a9590adaab9d030c5c33528711f4406ddd96b4a272d9d86aca6f10d1b8e53e911e97a73b4d3ad756960328feef5a9b9f31807f94aaf1e32ead03d130ded29cce97a54989c79ca9c8655f90d8fc6af7ae26ef322e8e3d732996f142b0f51a5e9ca4294f6ded444c00ea5c34e8b02e532e80970dc4608e7a43ba65ce3db3bd089fe2aa17695253d63c7f9b31cf5db9c05a24369e0c5568e1d7bac3e3d6aeeb06175f111e248393516237f050ada93480f85d5759b42eed3962e8fab3010a2092cef33189d3dffe1d1cd93955d1e9b4569a6a8b4d0d1e342b52b4300ff7fa71e4d05cd8c4b393e01d24ab694b6b1ea4e4aeae85760372e90d2308ead0f507e93b821ec326bc63bf4b463880838e7e74fba76834360650d854f3de704a52e3eb70df4926f8c916d298159fdf41e54c7186b4859a6afed4d9d646292db5c00683a580d2b7a2885cbe9869ffe794a1b0e2ac9d364bdaac06e9f4049be49a340e2d931a6e0303abe42caea6f1afe88a04dd0b7aa1ecf2caa97517e6b2fb8b653cf0853730a83668b974a324bc42a2d91c2773f4ccebf0e294c6df30a5385a536cfe9d517507ce0cb37e1b8424a160e89d80a4d891a2e934191f153325a50383e4003c246bad7063de25bde4226efdc2700ad6bda607e3b281d27bba9bb61514fa1d628b00806e0c290281ad7c4281a03c0e9828eb46b3f55f568d5a87dc70d8c944f96ce5cd453787d667f47d3ff20bef49299cae906d48895c2577dbe5e62d73ee7db8dd488c90b3db056e41ad173752c78c3fe3410aa0c572fde97e56abcf0b48369c9530b6957e42d884ddebf929fa23b1061716bec28f76fb05297a71f2ef113af07e6660782ef5eeec031fc0db9a066c81fd9fe0306eb1e9dc9b6e87b4d0f1c3b9507619008d650cac970d866531c0ca36043de3674c6cff78f1a7a69e336fdbf7c90c59dfa1adbd103652fd10bd774d1a97b43679e784c664aa9c317edf3b8263176520ed15de4c7f0bf42f11fa6d960b31d8a6b87f78e0d1f0f87bde7e4951105266aa945b4c7fc82ea54c2a80336baaa17b0a752024f63cb8f17190eba3fb111d385b6befa08ddba18aa0ebab9b14f384e855cab83d2eb819d3454ebf8f86e1d1fe24371e96fcf722f0c7988013c0d4e99589178f01c51e03efcedd1eaed1e39d915a2b4efe78d30e9b082e49988fd427b9f174cd46aa6b0d2e642398c69224aba2e08e5e0a6cc794525c386a16fd268884c993bb1582ba416ed70fd271fd10a8949769955a2f105dc53a6841be5091de0aad68c74bc43300f87260933ec69787add34548ceb6c72ae4a96304f045fd94acb60cab483dd8021aa0e09264da87667306172486d4d8e98d2310b9bedcf55cd82171e7f640b9a6b992b9c8b4dab0c568e54c9673fd1371c5b1e17c3e5122561057cb38659475e0d48818684f760f64fc4a97285b75e219d130b61030c2ea97c16b4c1ad389817888ef1a3e9413dc1d35f46c07dc73e83333a2a9914b67d7da3d9f5d1455400ccd60319356d29d81ee72ae4364ccbebc587b03e0b47fa38b31676b6b9d6f79268df58698faf0316220c06770a8be84283a7ab5277e085cbdf0db4931abffcc5e1f33788d2fb7410c12a0f01e6355ebf3bf8153cc49229c59e3a8f50d923ed4938c714991dcf4a722d8db5159c227900f6598c792b80023c8ae5eab963b3fde7084564be9f0421c5de35857f2eb866e2178f62bda3fcdf978abd6e955e8f198fd72038131843c0b6214d4f4fc0b76db4892059e192fab1ec24824abf03c0e7101e643dc7e34387c5ce805ec6eaefee762c3410ac77b211a3b412fcb2c7d9365ae65e234be4f38cb2501715a254c7ade72d90a7ca278be39f52941171380e08d9300e3d9d6a3b5e9fcf61e8b197ab9686654fe298bdbd0c474aa5e50be33b5f077fb81fae4ad49c65af303a7d58d1fe4bfaaf9384dfc0e9460018b9aea10bdc4a67532192be85f45f520499eff0e1a7a6bdacbc77c7ce409ec8ef3753ce18203ca216b1548e45a1474a0b04768ed466de79e3d54133db0cb5a23d1fb8137a8ac022d706a3aea58ef059afd9c1c324e3109b6f19d54273a1e231a2ea549ca9e8148b04c5490c6a3a8996af5bf8359962e7f75dc74f91eb9edd8be6619eb557a937086058f48be09271f5cfd9190bf51bfe468610a58137c30d5539821013d7e46db76ca5fe913328a0099dcb276b2e5a3acb1867f58800d9ee21368e53af22a1f7aa0b6ba19404db90d1c9fce1f6564051dc7ba54f8e68d9af662e46902cd76ab4d035a21aa8d2afabd8e29c03af3d13a2d59c9708b452bcea6615be93bbf5c60d6c0fc25baaa58c0672a26cfdce601aa2276de5d5217a504a55d669e0da4f8ef75accd0109a119d672051bb9bf9aaba43179c6d0f7fb8ffe8692d078c9f2d0cb9924ccd17cd1da3721ec90dd4a1314db78f2317ba1a2e80af24b069d41b06ca5fd8f45ce8949dd7c0ff3568ac233f96e821dea878ad730bfd4a4be0f25e4f838983ab90067cf93f020c0a514280e28d2695ac111f6dfab94a616adaf37eb60f863821de0eddbc656ab8529da483c4478acf4b3dc79a56ef5698af5a0c3f0bdce07feb93f0dc9588e88c2eb1ad8ec0117ecc5c236d6abe8a6933a4894bb1c1c9af5fe06b46c2b9bcd053ff2623127ae0604841d70c37454721043050332c9b879df21c2a6cbcc6d33a26b8bc82555452d563432da67e695f09008f0ef896f6b5cf904e78faf6fff7cd8f355d5c2e33808b537d1092463a02048cac3c3f542cac7f431981e3e844e8ccd2465df38b9d57575773e339769328e2b18aef40da93240f181035ed238f0dfaf2ae9f008d68b9ae616183c15542b9517a3937256a130a90d486c1994716024e91090676960bc6c11c7ad9141cecd375533bc25e868064e226075820ca57268e8a8ceac7ae265f31562292a7bbabef438837643988fc16e45bcdd2126086f114d627671d09da38aa60f8811db3de82a6d882b5015eda339c3fd7292e5ebf4b2a103157e7ff70b5503e1740f9ba3f603b0548a8d9200198be4f76a4e2306832c065a7d6bff7715603cdca9844c37ee2a1f7b2f56c843afad4515bdfa53859a0762aed76e0e1038ae279386e23258391b0c639f5b58aa65d3d01f20ebc378baf4d0ecf2808f02236f991e6978fe47bcce64bffb24d0bd7a1aea4b8b441c2c2f1e75061e0a2ec8c2c4e771a2ea7cbc36378cfeaee97069c30ffc554134d89ed12fb25dc6ef1864cd91b9413c41b90f4719b4a3a1fcfb58a73e9d1288e448dc3ecbaaee7de59c2db1ecb07d28798b4e97ffc348700a8e6e64948e3f8e4e9615747c9798fc9d529cb1a4c5afea471c16c1a2534bd40b648218d1e28bc785d9ec71883ce559893b6e768740f401a5a28ad4a7b68c0b6e3db2f7aca14a53c439b53e4b252d9f765a8931442e3ed66e00eda6ab53d52ce041a931e63443ffad10d0d8b2964d0d1765652d5377c0655bf992e9b4bfaebae3c2d8bca5bee9e3e682acd1de1e8db16836d4b798451026da38e793a7fde37c3dec7e510e29b21bc4c7fe1dfccf92f2440a1fcca0511ca0a316f45a78e815734b07d2010508f0aab2fd75e2ad2da3264e3b52deb7c2a10d8d7b8ec11909f7cfda382ec60482058253155b51ea46eb5ae5b2c3cc036492560c2ec5b4d5ad6d1b6ba68a291bb6a59b033eeb09a34599279641f5e7b3bf2200c3ebd8f20fc61d1c6086b45444b3d51e5f01a25245385d456122e392d5af9f35fb09e08a84df2f58c1e5686d2e8dbb775e31eca344de12925fc02997a480985710ae0ac2d7150e5a7dcfcb46c75586f60d9886a69eaba780076b1c62fb3f1ea76afcb583b4b524d9f5011d0ca8bc8264b1b3538c72c5eb8f107b25f299fc8d44a96e334e4980f979c871a31dd08e00c87e82e522cb2ff1963b215b6ef8d525de7593d473910ebc27d24e8a891c26ffc385648b0940ebf5e2d2eeba3c0b3d9f9b849a17fdf4ee89d09a8c33a8114f43f342283a13251d43c2c042ee1fda3c87d0e50679574e8b4d32670146268e67b924e3269d7f86cc44f3c85cabbb3b0602f52ced815a4b541c2c5859abce3b5ecfbe32ccd9e3ab747b869c61c717b344da49deb44dff76a5fc19775243077077e6434d92b733ce88c2a8c5cde527034dfd968384f2aba678caebf75ec481ddfaf4c48669bb2cb64f2da2bec25fd3eaffd7efcb9b7689e4db7e91b9d3033098f5b9d07dc6c46446b24d79f8235faeed5d69395b62cb93a94af8e685fdfd878226a028488b3f0107d07980b387763eb3857dcaca7a2b37a94596ddd2cfbc9d6b223994806c832c919b9295aba3d1639d01b9430f8cba5e65e86a16ddabf5b7625443805a687870f3a0319bee3275633b61425303861409dcf8e48a0d12221642973bd9b676ddba67f5c10d467f906473330e7e42fb1b613c0f1ab5f3de7d30ef42a3d93735d0276ac5aafd2a89966ed1c963f97a6dd22c2bd216eb795e8176012e92e509efbd1bf5365d76c1c3c921af998c3d1b09d3b9a3c47d54378cba9464cc224dfd08d486b185abe3c9f036f13ee29d0b382296f4c281ddc8578c0602941b1a3eff1efda865a41d75d72d457cd4eb0b151f55c192f5618268db76a233b938d649ebf834998ea95043c1613d7122e2f150c4303a4edab1faa5eb4a0ab0aad2a136b363ba7d9dfb4e24d33e88d02d16745d5e9018188a7af8fd24f85313d06674f2f4a83d5c19b6cf6b8f27c8818694e95b693bec58b920d25785e97fa2b3892c03714747ddd779578e15783e075b045b5f01e631c843db2d3a71080b1e271b7c061662072d8ecb2950494d4d105136a10a86f42eb170158cd7f81b8b5e7ade9857afe6a6a8c4eddd537a65c46658aabd84b5fc148ee8858f722aea8b473c8084de850ec472d81a20595e9bb8a2f9cfd3786b7d9d7e3791934d6735c033a25bf4a3a60ee7947253a9d3f2772bf38382d4f14a50c686a7810c9cc4071b4673722cfbc38329c2a136cc59fcf291c35faba8234308c54b400da933af37c41b1195bbe1aa7325c553126c237334dc4fd97ce732855c7c66f6c2bf65cd61e257b543894dfc74813a9a638d7d6e7d8b920f3ac4d8e6b2d8e10c6b1d0343e5b5ae6d154a6e9df0aed666eefe91560381a5de840e3b340e1f4d44e451778bd6f49276f98dc492caf03b6368e95cb341e24165abd05ca3a33f97d9f7b9c09b8fd3b6c6b5fc480643229f53a239ab72b21340e876a9ecd11a72e6198b36531a79874d9dc9bf3c405fc24635f6ba03ea1540ade3eec58251b442a0485b3533ad6eba847541b13a1082710f0b93fb10a08520357bfb78b40a26c8e1a75b922915b346978738fd23fde2b37ad4166fb4a78dd7d2a907aea01f9a6a38822e5c1cc6203f87f08d20ff96ddad03d2c9704b8a124aeb43079e27b2ae65acde1182eeee048c16dbaaa80749848f4e2d40b76ad65fa41513cd34a072363348984077c347e714b17fb3d7aab5d97c747a15c4563fda8d7a9c26ebe98f0e8cf15cdb6b432d757118bcd43346603c5b8f628f93483748f2abf190e18af8ff73bf6aa321209f0c9428e8aa7d14c977c85be11db2f49e5d7af5eccc62804a9b960899cfb4088b40415f3dc3d74b7657c31d69df9f4ed1a783c30f25461ac3e0c8f3c653b5df15043fa2deb1d4586205ec7549a21449a7941a03ee261553968b0cb40e716a40b4976d32da8a17211f5545f0d42a8d31e5c5c81842bf94568181f93f1e26fd73d9aa1ff638006a2faa00baed4e8d7d44d748400e1b7b16eab373e1533b3aaef9f98cbc5c6e62d37792fb9fdb5cfc39b1008ec717b216e08d968fee18162cd57bb4adc620be18d13dda664cc5bb43a19a5c22627262d291a30c3418749216e12c15a0c542c412801b8f3b8a19f3e1609b1c8fb0b7ee24a5e856505e1ebd7605d38ea870323c65b3cc86f89a9234b3be8c09f57a2af09162deb7f24112bad79c7d96578e22ae0787e4ad23945bc0c3667f821cb80cc511c58c614d34a15bd02298e74585c45b017c85bb178ed991e4330452a393a6b18930ad2d57ff84e12e93b42cd2d98921e2f9ef8556c7219000b025c2595a2659d16b9e744ae807b420b065cbdd3498b9c2fcdd395d49970821c17f292b8bd8c7a963e7cdad5b54d4e4821071817116ab3dbe740d84df2e7a827f4760531189afc6d2e42bca9346de6923aac4db778027b4c3bd9b6c6c97fa50af5257d5a9d4bacea4532cd7fafea1e96a35b8870099381a1e24efd76644b0e642a8ce9df0234cc1479513d8c14a8fb2c446b742da9e4e8e35006d7760c7256ce8524e1d4e49d3457dad5d8a5674e88714b0ce1bc2aca34c8018d87df51e9a3f4607","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
