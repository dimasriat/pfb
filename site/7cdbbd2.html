<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5c3e09e88a47bc653a2d1309c4b088b58805ea3245756aec01c6dffd0728f37e4189ce1296a3a2c7f3c4319118f6b1dab85ce6e538d05fae1bf68de962c4a70d956d0cbb5d55ecd0ce45d3dc5146e17ecaaa53c1eb885aaa8e2ffa9cfa01d63883879e426416e18922751e8697221ed2eeed93eee626a73a927e0f8776dd135ce3afb2fa67bcc954d7be1aa0af11c70b824db454838f65b1b91c17bf7b1f32623ca23b1c9327ceeeda75424020440cb6891900c507d67b76cb0700dc60cfb62e4c890001e7de22d51cc388be50218d63c08099ad989495bc43587f0a0bf54cfecc2f3788b5c68eab818bd50a156897025d7b23975f21700ba927f9d53927b2ffca42ef49ddfa87d903d44f7471388c69fd82dfc229f9ca42bf7e39a83c3231aaeef46f91ca19fbf1451001f1d784a76c217b561080142e3aa3b75ea651f5e28fdb9ce1dff7d13c5a0838af56075d97707c7d1669c93e7de11a82c23cb635c8ae53eeb2c6260a3513d54a54fc369f75b9761a9db5058ef9fa4bf2260149e12cb27f6e862040fb7adda532de4922d5756c9c2543ebdd84f5a9dc4860bb51212c3ed83c631ed9d2bc874565df2a693722fc9570be9c70695deac0bb4deb411f276db19dfa59958389892bd2bcd033d131f3aa9fe65647979bc87b86f2cb9f57e0be04767dcc792f33c4bad95648dd8020cbbb0f4cb533cd698aaec5c9b8aa0c119cea792d533639186d7c021d8708ca17ce49b384000baab9ddf93c9a309f41ff2b21906a93bd25605545b5d6923840c944fc1881ec5751181e1867adc70bc695e518044063e344e30078011432cbbf8198a1104c40875291fd870a373a24818631e414c2346a2eea7bdf2909c7a9d10e0649c4aabc8e54eee1f0f5eab8ea588965d9b0fcd9299c9935cad55f57d1ec79bbef7949fca1ee13ded3403c925169db66e31839e6acac65f086f20155eb9c39d8153235ecaa5a4559f9ffc20f2273cd9300eaf46a0f696729d7e4534a7905975006895d38bb0887255e8d1b9c5f063991cbedc31aa34b9876366889c90329167c2433d61f67c1beb4a97372f4015293a2eda3853ae82408fb0dbae4e0bb655c7b8bf2265bb3b966d5dcc50a04a1cf366cacdddd96e47232675a1d84ea2dccbaf8018eea6fee07dae3954c313db796d1dbbf44dd3edb67f18e092ec0fcdb11365274d215f9bd9952bd7a069db66bb7057e523f24f2af1efa91c40ff7d538712f9eac71dcf618cb716ecf1621e3ce4cf1ecc6b6e262a4e0d09452dd68bd195b22c0545f55f01ca8943dd48af5927c1398faed745980540173bf1ba6a35bd14f5480a18cbc58b9af6f82c8959a66776b56402622068771d12573dc4e895199574a0ded3503f443402b3c8d5ab2864c31a60012774b9c271c50dd34545f93cd36382a843734bc551aba799d5a76af1e1c666c4091e17ccc0c929f69347226309b6f33c30fbd74daea9feea413cbabec0855476f623af7a17502c2f649cda3176935ec72e6e1f8d8a59fcdcb7ea9ad2d5384cd2beede990a7133e4afc74b0f60b52e65093f03a1c34f6a3a86c3775c18161b2efe246c41b8af7d57b7bf0268e0d50eb87150adb94ee67d8bff4f9be073feda866940f01f427579aebdc42b9a1d5f73944f08fbf52c8a0e504ed856303889585179e1d00217e158afc0187dc7c6d0d92fcd7551c6fadc2a5dc3f0d27e6503dd6899d317b05d5ecd79dc87c91ff8fb51a0de0a45d4d805d9ece62fe3c600185728f4136797d7bc222a861b444c1f6b297f632b60848bd3572bbf7a9004ac01ff8f93e17e9b538b7df65917382de9492cf75aaf201a4197ed44e83dcc91a32dfa2ee40f25a3b039d0b888d501885c2b8a8d4100ad206e975eb747839c5fe67119ca8332c0322591a7865cacff3c42fdaa174dd91e6398de5c4f9af6599ce01317b932d5f036120ad4c3b68c93e2f01149f93a9bc970b0464e776d5de6674bfb32350ea2fc6e307b86f97400236bb93a8ba3b8fda9558adaa75a69f9065a773a4ca73f39d39369cf3603889016c03ba922f55ff37a8b3aeb6b1051deb88765df7f234b6c656f1646bf1d34a012362440484cf6e60e7e7ffd8e4230fdbf63834714b2a516820692b7a32cc0b3f9fe428b7a017596bfd416779ab0de86a15557ba8f462f56bd55c61d3f438cc5307d38d53e7e36b4074e48f10881bdb508d0876cb53a5daa5371ec012ed56668f0c069f1fa006922580d887b353b9b64e66ef3f47f788b357befb8638f4a40d51286cf6544e953d3fa9163c9d525e762d37a89ea5d8d1d6d71c75c34cf4ef4961b93df8e38c25db27c3605744399045db9e7abf24a858280ebb16f34ba305d7a63be813f818c68ab655a107a2bc8fbad136e14dac2ea2eedb2a7d697467496269779989f60dd20b340829ed1765e82abd08624a2ada0ab223ff39097e73852e6a9238513b2833a9ce0f352a1387e68aaa48af6190e8cbc184149d101b65248ccc5e8278df81827de245577ab1abe2bcb08a5b46d503bcef42ea3a1e5de7c32c322dec85d6bebca37c90ec5bf9196cf2d7ec93f7df90cf66de5864a444224956f2c90d11e3779b972c1d79d9e0a6a3d1714f3f7dffc354e0b52d76282471b4e949973df7af35f96e4398278a6531405fc5af1d143e4d7c0a9b2b300aaec26e47557fe3afffe691c0500db4f558035005cf129d10c0ca494cb926d0535e50862bfd840a010611f72c3bdd16259d03afc72dc98befb30adcc3fb20cf4e5a51ff7cd6dd49b14d43383dd3980ba8a43e553209bb375964b8be64dd35ce138d879e133d13789a0671df91831e0a5ca663d4da69d7e91b7e96a8a5379a1ec5a31ded001e945440daf9a40378bf8e00603780f0d9fef5154df3dfe4a2685de33493cb966d77e600a6174fa98f8a89918b95d556045a52fe49c45a97d5527aed9e04bcb55d6ae56aa392da09b8b5494ceb2080837af57aa051bbbf7c29af6767de2e6f05d9fceee47040ba98bd105dac4d8bceee88954d0d5aabed4e0d0fd87a60d91f8e3f61119f542226a3368d79572da76b70bd39dc3f7fb9f360a1d59113bc606f142ff4d2a457c5ac2cfabd5223ac39907247d6b698b98f896fb63afb6019a7c0d7fb5cafbff79d39345ddf8b3809f92f886bf8e712b3cc500636a3018b683137f2095287e70967d191d607cab32ffdeb67c6155d20df8c5d5a93f94995b5e31961e3d74355270ec78de632cca15d5e6b9204ced1be2c3594e03d06c74f07d39ea4380613c79e06f346ec1b7064ab3a906af30cfdeec0c84305dab1d2a026f36e62cfef423a6312903d65ed83b98aad0aee26d96077f525741afa9b09230cb21cd7b6d2faaa43b20b88ce945f62253187ca03950792b49064e39e13b819390b3e8b35dfe0155be45df64d7205f06a02f05f94878900f4cab014fe2b40936ef6f92e09d28cbdb89c99dbcb3dda68bb352e1f7c8c6df785ae2ce33811bcd92deb860036d326a98ab0a3b8f1efd7755c453920e1fb8d8ebecc1c3ff3d33d047ec27d9a597fd35bcb283292c2f8753a9c0cb976e5860f33c5d66b7a38959d74e38971fd2e05f6ac2fe46bdd671f78da19d8992cc570136087e8caa5740fe329423c4ec1341903ac5d282ef1733534b8fc9bc5ad2bccacf494e1fc0749a220b24533aff9411adeebfe4ad48270f64d2d9ecc6d21047a8443da20f279ab4a1c2b6bb1f24151cfe67718f8548b81fdfdefccb35d88e5426ca2ede7e2477e09a454b79387d9082c6eb58046944f521d4aa73bb39add5dbad95265474d7ef95a11b6e71336d7dac7776510ef2ea78c3c4d6742a51d9fae9fa7e1d42955c0293392310b5d3585dd672ac6e0f537241de8f80d0e2f03dc1eb911b43d388677bd437b5fa07cdf37abab43d8d2ac5e8affce96dc339b43349b984e8e6af75b1837d3734e56094dd090e7ebe04d2e16b9f982a7cdb191dbb8874aa1be81b8ec650e823c977ffc47581a174d4523a2e61f33fd0975339745532ee81b2655a776b89d9c4379cc4f70fd274d8320316398d98a466b5fe3547d4a85d46b89d9e86922e2074c28ce3f2fc5cd32d094e4eaf2308c664b95fbbdb47fd11db459c00dca16a169fe45690d3f0cf578187a417d3c28c29213eb6b16f40df1453b5266b5e9da38a78a34a7dcbf8f4ae07414eac8c8f2359a478aa48ce8be85f1219c4436514b64550b853607f34b064e09f20d4c4439d13b2b139994c0e7d93be600a9bba6808ef06cbf86326c2d6cf0c42f6371644906ab9f6efd35b962ef7e6c703903095a31baa0250cde6b40fbecddf219a13762d7920a3c53efa51ff2e9bcf4546491e72daebcf0ec59b752891537739d7ce9875002a554852beb43adf0cf808a3f102377fd946e8257090f3203b51c2a7db62273169f3a614636bed2ef033fccc1bc4e51ded12af4c70304bbc3308c378cad70ee265447a9ed8ebf4e93c519612521e8017e6fd2e244a8ad842a44ba633ce5ada29eb3a335cab1f33488fea8b5eb29e88a329175be7d6aa1bce83b159b1cee77c96105d27e622a43aef9ca9a0b9fcc974dee925e50c9f672fe45e111620d9c2f9c271f94dc3d019515b3b7c7e63dd92f2eccb7309fce495a692ff88d740425869fca9bad2eb83bb71332db38abdf29dfdb9230a75e8a40f8fe7b3a39a1850985805a658ec6759b5f63e1f52d8ad2f8ee1ebd75bec65bcbb4b43207ba49840570126cea973a42ef3e4ae8f8d3b686bbc2736722774f5fb0be212c55c637a8929c37b1a1c3bed92a6c46229592a26bbf33987ac82d628b0a29dc4775c000dec4e35ba7b6394e7c3ec5105a57a3c71c7b02f2bdb5fa8d2034fb78eb53eb54f6a395e53f88f6accb2c5700915e23aba70a98a5a6b3aa09322ec0760f271c3cebc279a395ef5007005a2c036ac69dc64bf10887aaa1a8fc2df7aeec0fbb29267d884b3f01484700465b8dff97d7fdc3638f0a6116d6900a4c97b608acb575b3698a36681c7bf0272f686dedc4d7f099c06e717d10a4a108ca9d5ac34f2d2290ee873bd359ad0280b80722b4d0066dfe95e7223a007f04e380de44c57d4052b2ed51ebb457c6e7360c9089d1d68d4b94ee5275bf5b1b150277b48283baed2b600f8e19af4cb5e7e97f7881fb3b6eae2b40f6a422386febe34fa371d25de21cec6ecd391704d887ba93cb6f9baa06afc5e66786aae3c7fe8241e4d07cfc936dd365c6fe198704325ebf342f1da2e45f8113d66fd9e79f65da19fd55b5ab3b4ce13e61ab44b06a20ff5d5d107dec9f12a405afba74a690afa054fe8e6ed5a3f2c27fac4e05a1d7e9eba1885415acef879727591886e8544127f6be718bb72a9201c1181ee782c7f6b59d01d2def456d7794b472d0153f2de70fb1010a8bbefe4cdc5b4f088845f83b7267be2c20b9e80944464cb11e829cbf938045ab8046abeaf90de6eccbf0d6f2a54af0f3a38a3a41c7c3aa2495664537838766fc5375c727c2fd7a70818f98646990226aea870abc1532445bf88f1d0b55c43b754e2b6f3b3a7bd9afe881a7210b280146fe1004be4bd524d563f495c1379e853e1ad5a85d83eac5633ac7604310347586f427bac4a797575b14daaa42809b7f9df049f9a1a53f16db35929dcfe6bcf74f9ca132bb2c4f53e7ac5183a5a6a3588e84f9acf571f55da413630024b23284dd4d3d049c9d8a4e1cedbd27bb0ae04152fd0f44172cc04be4801a660d82914ff2bddf9d0a06f2d5e5714c3d7dae5aba03f2fad49337cf9f372ad0ffaa86bb08c6a84f7b7c3160974ae04ddfd03a202c80a94b504c619dbae406619092423f9a7259916cdbeeb150fe3baf860e534526808eaecd29718f94b42a06a356348b59f9f5d3fff230cd80abea5e4375948c94ca8f98100f67faeface8c264bf018520ca88511331da8f12c7441eb7d0fdbbde3381167015bdecce1cdf1bfdf42ea45c00d0c0e077b2ba67e8508d51b197ed6d62150a312c5de9928bc7ca5509111d20a588a299b6f27fa398276cc8f62d865bb4721e2bf388d3bcb97fc87cfa89905940cfbca6ffd70a89013cbc593c6c7cec0bb5cdec26ce18e7823964bc97fc7186e5e32e974c4964a45af449395328b065b4fee1bffa0cdd6126d285062b97e461976ad5fe7c2b68fc39bbbc70ab7553b885c049c4022320213fdd7b41d0ae3df54ad3ff8ce9086c48fef5f2a354c4f0e235ef42ad1da26a9d0c60cbecb97e3404b78fd91ba88244914989c0bfa30de7be0e2ba48d0260e4a967b7062530219334228d9afd7de13cab0293efc0d6908be6b6718b8a03e9c624bafdf45f2654a0e9dfdfb116614aca2b1c456b8230ca32cb672e92cee0735c3d022e6b1a84c529d26dcba2a80dc3dd20063947c1e6ef0c01a1bfb0064d808582bcc8110cad008fa7e4e9c2dd5a827c3f7e3874c63a26d65f0d2e011a636ed5bca7146dfa82055ca3b90b954494533828c580e7806da8f4c02a5aef3b84b322ac20b4af2cbafe1fdcd563361c5655f4cf071e94b5b7fe7846e4ef1962693e0f3f1dd2dfa2722e79b9ffbc86e2000436d65338086e3b38ded94856a84286837d0a8afabd8c2a6f049637b19f34ca102a4fd6f0dcd2f5eeb6330e51e83bb6c0372d57d4757e3b054f8fd7307888480356801b0b18c899371767e3fcdfad2f09f4b8aaba7cb0ec202ed814d21c8fe6f12c7d2eeeb5bae1ce9d41dfd346e914146224828de2dbf7bc09760b29da810be94faabd9e44d8de86cd1f5a7ac649711db2f7c83f0eacfbdf845bf7abf8e00a314d1653ed4febe4029192bdfae29cf9ed11eb9d46c62dcdf4900ec940e45952dec1a96ea3bf0a4b3c97758fbcc76d9e82be17e03668aaed38b7f18183ddcdb1f19ac9ff08976ef7bba7ef65f4ad0c2b8329fb8ac6ed2c64fc5aeaab5fc28147f08fa35c4c5a263df8dee062c28e7ebe0e76e7555111042d45a987ecc4d8cd7a0581480c19323e600ea654f39d9e573f1b06779ccb62324e61336d580abd481ef130efa9aec91319c28b35e4b72dec787c3716c0812e5743e9f81137e8b9369424d8ffcd3c6965f7eac7ab957e40b9af320cd56ab02d4a493ae8fe18add4cfd029e2f2dc4ccf03f3a39e3f7dd7ebafe16acd3e6fab5f29b638227d2ce2d4229d80aa1dca0819cb0b19310ac2b8aef901193574adcda97e6bc4d4729bec1ee15e61d2d22db0c377ecb28aed055db67d16a4a4e39d8b9b2cc376c771a3ce190d27c02a0bcc243d883d53c1dfd44472865577acbd9e32e601d1fb618ffdf88dc99da5114a06f2a71fe594e77a00d67ae73ca311493879450fd4c43519a48366a7850c8b49bdd193b201bf1f42aaecb649297dba0d52d7a5d38d76fd266fe41ed8ac4442b12e47fd2d69460612cf0555f2d6a1f0afd1787c99317a3188d4f0b6b8ff2626161a8932f128da3f892a23d1e1291b61a72fb60d030ab4d264ce8250f4c198ff29e42686fd7b9d0aa32d181fc351ac9dbe9bbbf127cede27f7a428ebb280b8eb2d12d8543c97991b50045ef86a0c723705f06ed5676afe7be56288844fa1865500ca4305022250c5c56d67f7467be190bf639c0ce491b1156e99db01e49dd203c5013c08bb8ecd98e5d35705e15127c9f71ab4e7c9ded89d496d039b16001dfbe9e0542d304f828949601cce476d6b37f39ce3ed1d06d7bf0bc68f422cc0dbd23696d4909dc2c4f24ab42115ebc804cf38c4252b9fb25847d9a4cb50cec8ad0d3f3ea7b5d42f03bfcce01196ba664e915364e62c4dc6a1aab4c86c483b048f760a1652881da563e85183d299df685f6f1ba00550d65ef47373f780d1e252700fe1f3a407d8a67c12e1b487f24913165a67b65b8e2856e92775a7a32c45b2707db0afa4ce4a3f0030eda43ed42cddf22bec6390430bd43aa39b72d166d3c13fbc8dab40b549146fd0dc5c8e78593f61901979a0a576a00f6b57415b76a932f642c9c59ac8a8193674b7f249c53aad0ff84218515c4daf201397ac59f55267b5deddc9cafbe38ab74ea78a0fad403b04cd3e5cd608f77274430288dfa462d8b99559e465c0e70a54ca4c237adbb2f72fbbb2c7cc1024997ba55db1d0761a67976c27ca74b2a95393c089cca6dc7356322d2ba9ce8d9ef21bb4ef9f612403231d5c902ddb043f466d567c5260c4de4179bd701fa25a33fbc0f2707827231cffcb645ef26d93fcb81ae41c764295c0c651b7d180111a9e4203485d32a0722f94dc18d4fa905db15c5754c861c1ab9f3592896111d884dced3393f535a406694c3313b41471f7bd5d796d3812a096757d0c450e85b6c2cbbdb3b67c42a0960c61f018ce7f940502cefb377246417df6745fc5e015651c68af9c3ccd528bc1049f36a7a551572b2d536ed604aa505bb044e1f663ded86307784bebc7b9f7a1f7fede42e29d7a4f52b36c9de5f289cbac1ffa5b5a2913327623d0b3f521d8ffe0bdae5e301d948f4587c9b3efa952f84ee6732d83cb23f52d3f7fac4736e6b7ef51a5e33743a18415c0cf7656c2bfda8a2cafdad0043ccfc42a58709e6a875ad8931d2dbb10a00330b9e2830a65114fa502bd0da67a16ff61631d12e8dea450e765086e7f5231e5ae9624f5c4b4e0da0ef3adeb2c6b77146eb293de5b1034995520404cbfb5cd14e9e353a3a15cda32ef37d6699bf3461319d8c48bca86d6950f92b575be3267cf0b7d8eedb227b1804c83c6725a9d4b8d11bb0ab23bcb7a87f76ed531c8b26844ac7e7a8c63a38b233d82e3d9d877b99fa018fb3402525c1fd86ef99f807d2cae23ca03a5ce616c6d51d64290edac543e08bf8893fb93336f623729a27fc9a2ec68d9ea46fb14673e73130504987770aa5193584c163dc9c4c04c19b6a40cc34afdbacf7652481ec8b25cfdc3f6fcc3f41b99f67355b515760c6d1a6a301159322a1f5849eb0fcfe7eab80532ec825369446bb6ec803dcd3bb047244b41225d3591a6b9c883676fd82b045c2b097928d6edee72974e2d74a07fcb3b00afada2f109602cc312ed8fc443aa78dde57ded0b25d7e271049f5d82a809e3ac7cf03c4c713c242834e01cb28e11d5f3d05ef1b8677fe08a77b85607bbc64ec5802e16aacc3c4d51cacfd512fff4747fb6a61fada1e7c18faba72f50b3fced6cc3db86f707635ff002f40f30735c4e83187d05c14b081ba50eee6648a786960ad0e0884ed28a4f051c2e0c7cd19c28747333faa37fc95f24bed918b915ea841975ae34cae78cda175e0723112616ce4b6f2b91b3294ae4454777cc3dfa5056aa9b0862f117056b9fbac7d978c96dc17c182718d1676a82b301e18e2d884aded6220852ac5a307f2b277f93fbda56c4448d3f0f894e23094399b00e2beb6f24a21d51fe5497f22f5453c92fc61750ff05e4c972c385750601f542de8ff53025a694ec113a4680a28c659f83533851e60ca5ce50a4ac1e06aaf8702c6c50aa10eb4a63019f8f44eb7e5ee11066e35fc13f4caeadc467129e3ea8b8754750dc29493e50244a70bce2c9487d999db8459d5286fdbc95baa0edb41c1caa0afd29cea80a701ec4c4a1341a90146d96bbcd11ecd5e441d47a725773e7e1955b5e4ea4a0362f59daade6b71f3580f795f997562f50281e6bd65e2756adadc311c2098ad2ace2a10ed4cd50aa6d00372a47e9e67f009123041a47865d850de5fb97ff7b3db787b389a23c6402cc564c956aff3c069b77cca26aec42698f7335216cc01b250ec39860d27949505de57f195e020f1e535f09a10d88dd829102e9321c5244904e021234a055914fd6e3d35529abbc136786b5ae51cdac559a0567cbeb6a27a62b5930e2aed5e36214deb8e5866f1baa87ddbe4bd84d21c42141f8cadc495205b95e749e1e4e9ab91dad338d5148e86a3e6765942daa9d1ab808e4b41c855dd03d2b360be4e7aa3dbc0b6c0bcdca98bfe04e199f7b4f25a1cf68f45bd69cb89044af45ae2bc49997b7218f9a5d54fefae061fd2fc3f5c6427a0bd2088c6aa24b874898924e0b379575692a9ecee7af1986dfe53bbc2e9e9cbb63e1a7f6a456a4cf4a660d0b166a81a8220ac9c85ee614a60a72b95e1ee95386f36ffb74a86ab7e837d792aca78836cd9e81334d3eb94a8d87c9ff24474cfd711dfa45edeb5518accaa483ddd62aebe3afdbd32ec52d28b34ea9411ad33b053305317263bf586ebfd792a2302dd81e4f4e4bcebe9a88107e520bc2170050e26c21ab895a7d99a9c58c01ae84ac695a1ad8baf0daffca27473923459a43fd65d0b38b95515c085c2c7fc4668769fd83d87ac1446fa585bb23888dd0dbddc21d9eadb422417fd1ebb33c09005a0b9b627a9233145accbc476b0c4c951772ad4ef191c0263c3ea362953fb5422fc9a441151d622a0ebb2df38c4627ea8a0979c828d79795dd09e5ce5b2d714b31a1e8a0372a03726071e7932dd91c1c18b521d762a5ab2066bb55bec575a6fbfc3e9ea91543006aaf5574c300a8f0a96f18fbdcf2ab2f807fdb1d8e5ed211761b6aa179799477305db5f6296b63c24658835241c52c01c06e880cb3e0f0c0a1f0ce943229e0263a398d95b4b88c045343c79e68d5be825e9ac517a0c8de06df8fbdbe11c992f0888ca646aa1a23ccb93e3c469ceb14c553bd803a2913bf67b78aa6c419e4794df2412ad6cda3192cf947a83ac24c0aefd2f9666a6aaac02a7d3f6a91c8e805808fa27c27b1dbfa458eb375b42c54ae9ae04f17b38ba098e0cb21b72f99cdb68004532560d118867f6dceb778c545dd9050cbb1e11d5ec5c302393f4ff5f5eb8bef18c11d81ab5005520fa4f28a4069acdb903eb08cbfed0c05b4a5ab81df28781b763fc8cd4bb977ba44a8f7c6060bdacfda01a8cc7a2376b8ea2f1b081f008b14c3a1b69f1daef2d5b5a7d62b6c78956f0544b5a284bda9f21296d8047ee347f30e54c7cd6dc81fc19b6a5855b4f55ae08684e9ead521d66f895e927b88a40ed6ab107e11c947d9d995b9935c9c09a803c8555757cfd8a260deddd6880ec020841e0cf6750c93220d1de80fb01999e5f45befc05d80854c69be1b738d04c97317fcc3a63cdc8020611242ce61ef1ff87360e9750a9a7b905758165714e7418f8bda8f7c31e92fc8f0bf9275b9251bb58fc8ddc59e071398a7d35bbb81665e9727e86e858ac81b40a192b7369e79fde0bee9f1e38966ccaec9570247e1369114d0b7b2e4f1826be1b37a2820efac2b855859677bb836c63a5414ee27fb3c703357ddb7696cfb9a7b6df80e80ebf2856ed208a72f3a1a44b46a73c4de63d0d7db42b5387ec57ab19e8cadb7fab3b841bca2210e3ae1d2f0fd7d1c470f677506d02fdfe90ba51b3032247034518e2e7f330905e3fd918082efb3b03db13ac8a5e02605d5c63d297e93f286057b23afa46213f64ecbf3b1a32b4508e4868b195cfa787e38737919b0facc7e3fe21b5c73717daf00202d3e3c8b754299c01dfb5ab4ad8634179b9b2c4174b1335bb4622388583308c7b3ee2dec4ef68d069fbb77a8feff8671186badf4f08fb4b67045ddc2a9d77a2fa83eb8e5aba7af1d9a9217f711cf653765e9927bca5a148419c44754926c4452d10bed2bd9121eb5bfa3c2093aaaf9d68e269e4bfb56f22804649d386c370ee9b60b712a3439968baeded415e458b807970c3eed407836faad74645f0e4bedddb3d7dffa0853a7f396d25648e24397f6e41ed5e083514529ccaa4a70aa2aaba2b9ab0dcf52d0053bb27a781e6ad9cc40633b20bce3ae58bc716bd0dd3b4f30b129773e48802060bc1a2477866e1266fc8683c8bca6617ba727c20e214b24c896cb89843952a7d03260887e61eb48c3dc252185e9df8de708baae7fcce9fdc3030efa74108adc4b11d9fb54d70b1a11157ae0614b4d94d7e01a0aa329618b853d8ffa8a3407257cee4276e4cd354543cb75bba292fcd89f05bcf0e26d4f35059fdee22e7699300aa979451bc400a96fdcb3bb6932db077f6b8980d805d790731a7464012df04b8648ab26dda6d66fb13951204346d246ac3d8a3640675b64d5056da9ee2bcb59b1bf1a91b01e37917d735b2a359bdfe59d735589790ba8c176865ee1a50d4c4ea9fd9b55c89ca48cf2f7935ca02e3ed7aabdc74da5e8b9cda1f4d9e163ae5869bd07b2cad9176959915ffa5e48fad54bbadc58e5cf885d0cbf62e7718174260a866b46c1217a447fbfa1d227ebb3b28a9adb2d8c3ff9f763b0c8958ab9c69e628c0b8c3325f17b4a111b7e8d1afaf8f7f7ec9f7ee32c11de000409a4ddd270b73cd66dc49bddf1836f1cf456d735e353d8f7b39ae32f9e180b87c56049d4f0336bdc6d312f6044a7421f6e407cdcaf497a42a3124263dfd9e1f0e57757b3d761837940d3c5888e6ab55139ca3ba27df8c0ea988ed55362e924f9309053b58025166b97474b2f6a52f27ff347c68fef6e2427233a6efd7d7fe8d0da39f4e7be3764097e7c6c9ffc6277716d875fe194ba3abecafdc8ece0adc71a67b0d1eab248f1854cc86930ab551ce969cc5959cf8f90a469655d8ba43fc6a86b861bff2317d28cdc90c64318a6408b6d65f9a74402610965160eca869a0f6e443c7d6c5f3acd3b34390268a5370aae1a52fdbbe4e96efd0c5165a489699c0fb6200c5d5210082a37ef362e369e776403c079b0ecf7ee8ddcd4d58a624dad9c08aa47f8cda8a5018e239cf192aca1f813aa1d7cf36a08121286d98473cf388c6a090e5a4ee4b0511dec682d0139839818c7d847a03a0aaf7ec81b5ed5f4db8297a72cbda241ac938ec3d18441fc98cff8f68639e4bd59d1d8880435af13b2bbced077a5b11dc39b9b219fcf755850e8587a7a1d43762ed3e1bdebc0ed91a144d0ec3198a4d55d9f462d42fbce722c7fea54ee2c446622a8262561890a0afaa1312aef488144e146dd88af8727797ec0d67c8a989c70fb744fba89936d6100124821ecb5fcbeb2edcec845941e677d35371b164ff1dfaf5856febf6de5dddf23abce86db322b5878d38cfe7b611d6fda2547561594c693f8f0105ebef4e5adcfb2fd71416edb21bab0b3d9faeedd99a455954d84be9d23806d632e60063128a2a0c3c5b1de6bd49675d951c12d23053ba461cff5604c310040987f616313f38ed69ad09d913347cbc6ae5318f8a5832912d18af863c1472621fd6dec20d5b35851d09ac36e9fe96cfa1cdd273f1c96bead974dcaa044287b8e26d5a01e7e002c48b87291e6d0132a0edad6f3ac611eda51dacb4aaf261e58358161634b6621a71a8c6618a4415b7bf01216a915a7e1c85238518ea10ce6147412965f85127a2f3deac5e5795d5e3878aea78616830080c3477cb3079838e8be853f2120ab6450d45bd93b5896d66c127f896b3c0ad42938e3a9d8f73743e88f697ea12513a9c2c2f71fcf4817df2b09d81431a1bc66c291a4d5de062bbb093d34a7fa0aafc744d52e448ad5d4d9d08b18fe77d25efcfe8e944724786a4456dc70ca5fd5f1f5b1d31bce5b4abac5fceaaea27f945ee5b22aad1cdb00703fe32f3ee7ec17b45a867f5b8e7030f5eb0f79cc75f15f1f99e1c5c0c1754517a2ea2bdbe5d6c858402f49d11953572e0c8bfd11049e904c7433186e25976305e5c28f2a95a0b60f7aca61d79eb80fa8ea918cb4284d1b886b516e867b7f19b4359dcfe151e785504931595c75a40f9ddceb1669ed93c9605c766f988344e3f5d9a147f37c661fefb86c4375e949ef928d4d5eddbbda6cba1dc294753708977554c52a56e60f484f17ad35293393033bcdd700bb9bb3e82395f0dd663c4941db424ce19591ba257ede51a6d7e67049e10f79365b6e5df2794e1ad42f67e3164f0258559f3ec03495c3b81b523db7e5ea0446c7b00dfeb05c2f3d2828a12ad286aeb7d0940b3c3de7179cadd05eafb086194ca15a355b1827c37d5f676b53e841fa7e953980dd76f94f4d6e8cff1ff50767747838734ee45aa67a94600bcaa4848b837342ef23aeffb23ebad9c863e139cad0d8177fe7dba94a73c7578f874174241a9d6a05316d742ec87f75c75ab693e2e1a1f8aa2ab68ee5f7c980046f6cd0d5679d4d1bbe6b4949d15cdef96d4fb8a9c3785c241980318b1d41cb1e5d91ce7062203b28b738879801b","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
