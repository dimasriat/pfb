<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57afe7f98da63b327cf72cb7cdf65c4c7bef07a892805f99798199e587f458c2a5a5f0c8f0430c36583f1607c89910f7287a8e19e64c8cc375b357ec6ecb1c9614a3dab3904744df88f2b54564f43eccc745be1e0de0dd56a9c8e864215763b2b4b24fd0194543013840206a8fcb45c55a5f947498aeb03805d135f9ada61900a4942ab1c20cb74600374e80ed7736d2b5fd7c415d49f9269d194b5f3872074dc43b165e66f318adfc6996b278366e8f27d770c00e8217ec2f356e7c093324f3d839454cf56bd09837bbf69f02306df9c0468da7e7e6062de74494c8218749e2c4415cb3d3c1b04c8b5176ffcaeac9c38ed23a9fd726105ede43598851faec9bc307530471ff7c3b1e6f1e1c9cedef1cb8a6f85fdb07753fdaea84d27486bffff2d721cbf9824c4c2cad9b91e3cefb49ed1fec44c0020d152a0cadb43c349443425674f917301670b7e7bd86c00d283e71a47d0ea40f128fcac5c7d43162b25e996a7e4f267274837c2ca73c11bd3daf2c4504cf85650b31156e238cce9ce97fa6ee237e869e5904173b5de84855c9828a1fbcb0e89ede3234f7dbca31d661e90d63d9ad9c6933becebda7561015b87fe54c6ee3ed25dee4ecc4f57465018f0b8ca720758801501f856a0065454d5d4e4188c787104a84864ad16f92df99c733d8323deb4c6518c9f62a7ea818ed8f10ea7f8413fc4fdc12b84f727e60b949096f2b221c4afceb476c067af10cf89fc0ed6a7184986fe02b442671fd4f2956567db1239e4ed5e142fa2af3fe171ad4237a905d48bbeb90cbff3e4d3c993cb92c1b290a03a03fcf34e2deecb2d692f6f19f16535214637f6a5413df58d84037fe9f07705cf43f090f65edcf310bc46f8341ebeb03b7ea789475db4db3249e97ea83c8aa82fafaaba1211a66f152844ab6e4e16b2a138d39a3df814eae1e4fe2f584dbebdea1ca0fddfb2438545f65354c0f84b1b5748e4073f27cbc06d3845a8c54683ccd4674f293537bdfe2433c906bed7a039e73c6b0ba9c85a2d4881aca0066131da589e2bc3f9d7b6316bda271bf62041d5ea929b83875b74a005b858a7c8532f589cf63a6e95a49a897666220c83ec90a6d649fc2268e5bd783daedd698308af12b6522736590bdedb56d6ad3330a706f4253f100d83998cb1ab457dd7b123572cb72b74f5e9d846791dd99ab6faa63ad9d79f6bc13399ca27d1c575a45549498fa5deb9cc3d287a5ca92341d3b2b0ff7286427a5242ec05dc92222fa199000d1418f80b6682789ec09dffe82c29411486d902da17b6ddf42d1b497787ca89607201cfaf2aed8ca9ee0d5876922c1da2366ef065e07e5288a849d29b4bfe0b65549f408f8e2ffb4ae91c0a7a8ea749c03288146c1ea6d31de2a62c5c32d4755638adb141cda5ae1f0a8f05b8b3c60afc751912af56acb321c1c745368d7b9e3f03db1c797c19e53187e41ca735170840141486f06ad705be52830e4021be0350ebc536a6368caa832732380c0a40aebce5e46868ffc709605cb86e6f7c3a71cea7e1be14a80a46573abf327709c01e0c75af08b9bc2936f45fe6b68b661554b8a602cb30c94e1072f7614972e07302da3ff358dadfe17b9aa1807b060811b0c91f8da9cce190c2aca720619cca8451dcaa4d7272fb018bfda746cc0e4d6ebb11dd8793f97a1a090a0c97faeacbaa68ef9f33f0a828999a6c0776bd2cf66aa6dfd5283bcaea0ddef8245596d94f4b980032dbb9cd6ddfbb6489a4e93dfa10155c1c160a0f6a369829a9da6ec494dd1302b6d85d5a1afabb7669b4ae7064f062e9c424043133eeaec5d28ef48f640c8018dc0458d6b7b22e9c758fdac018db3c5f4c473330b7c14fb3c308a45722bcfe53905897a8154718584c29e7c59260e5e704ae71b83c6754050278da66640f1027161f5b26142356289fc72e097087d83d8c4b4b5e81d22895bb41012f6b66be5a45e6dce039ce260a352c4cb458419b45aebac1b5a884dfd71edcaffd6bd295c99f21c6364ad377c95d789ff38693c623157e0eeb2f0dfb33a1d840d8c15825ca199eeb8cfc2c2f1f6be201de85c2bd4ffbfa514cb0851754b1e67d13aa8a6c792f45362e8108b5c59e4bea084e8d11c1a7d2f85d57294e0b6fb12e909eb2f6177f9eaa930c8d4d267ae891b0ab7a2785909ccfb2c0addde9df3ae457c5ceaaf5953a2cda5a8dbf1514616d340d226ae34bc60cf703258a535d56ff55f0e7609454c551e3d0bbda98ac13f5e5b9f0ad2761412ee5c8ade780b00c50ae187dd521bca12bc25d4683ed61ac03296ab79451250bc6099a64725dae1bccf3d44e939fccb1a882c6f98a8ea406469ea2e7a4117d95aa2f7f1a05305123e33319e979081ae4be4be65a5f0b42f1cfe0758e14617c706e3cbd0e3386f288114b10186e174e35bfd22fbe608839333c1cbe0f8be15e13bfd25578bc3b121d55f7c2d6fa931b5854d872c7ae4116547a2aac01dfd3ce466ad163eb2289b6f68a0003a27943e417f884ab3d2fe9d521b86185a559b2a79733a8b524f5ecdaaa8df3376bf8f6f9a3c1caf7e0a9c91ff1bd7924aa6a3ff1e0a08c4001d36f4c0bc0aaa4ce01723a505989786fa39dff5282210edf396b8fbb90c39adb874ddc2501bce98b074b9a66168da5d4d88dcde493801bc46dd19a747bdb89f19d9d1818dda36088f10dc068824bc61434977867a2546b562ad1e33bd252e7ed2e0705e96101baf12b4145ac685963a504585f14f2be53458c67534b178b0f5ad839b3529fa34f2eb5c6adcef4ee3abd3d5563ff3caa674719cc41eb923984c78bb3acbc6175b8a129b3167a4bd734989dea1e2dda2dbacf4ba08c879df41ff29029c78c812820f27199665a73e7ad59d6951dbf4d01815ee9a05ef2da8f6c7a920b0dfe633547f5cba62eda4c89215e1e73d1816b2edcb39298caab1158736ee9e8f9e752fa88e646fc3bea4f2d2e42df6a7b49a7d4eb53612e9af746c950a2080a446d389c42f96d31866f63adb710d3b1c674347a6f15430f47801d2cb7c410a3772fcb6458f80a654e5951d38e23f4da39c722bc5e177675aec6ab9294ab33d3afe96ee313197990917d65ae4ed43f8d92cf44771556c170ea78579088e87635c0c3db9dd7538472275889d3e5ae3a60903d4e8db34dca44825966fb9bb497699edd291b535b25d75570958794eb889b57d3ac978f24447d2d3812ce73d3737b4f6cf6d72f8494c8848f943cafc9e8e63bba2af9cfe18ed308eac1881867a9963e9f2c13d10e161dd0d461598b100beb8ef417acdac480249eefbf1de110c5857e85f63b25b50d5af2cf8ac26473f21fb7a782a542a10bd2d095169f3595ec6707bbbb296dec0caa39f2f7699d5a7128c396e30d4959bb7fc5051b03bc8d6f55e19ef0f081644bd28903de75226e36132d9a0d3cf38c50131509c7a36997624edb575ed35c52ac8296b4656b39173267493079671013721b91aa8fc93469e88ee31a122bd610db5c51274fcfa421e3e7f12c3cbdd7a02614735868d3dd574e1402c2130dfe66effae430d2bd93f2329562cc76c612edbc1efea7d142da591091661a9488a8f2090019c791f8b0f37d71120c1d80e69b071d348da8d68ab68c33732313f3a6060d97cbf6f35b00d4288d94c07aa0c39858a7451b704b044084fe3515176dd7a79cad640fb5f50084f4f1a5ba6b9b8e8de2d6e23d3a39f69ffcfb5c060555e128cf73a5b6a93515c1e14e6ec03a7850c709006e6fe52d054ce2ed27eb7d31c590e6d183f19d82eebd717cc4a7e2f98e85930d7a654bbf0e2b01de17348fde252cca0dc2bd112433d1890e800654b47cd3d20a0ef3a85e515a2e114030147d6d0697d68ee01ff4200e4b8b8fb565a13e439429563caa4b64d88ff3393b2e72d551bd1984556893cdf6ac40b00671b8ff418b32324b9cfb24c3621b17094b5ca3ea678513b0a7b4569390ca79585c959a7c64db513baf5552a4b0484a18a56ef7c3b054eaab83bf28e1f62359d0b62a28a670a27394157de09706375b7ecadf4f226e1751c781f7d66d5530595c18086c8143f7b7eef529fb9f947903ab2298c1600281fecced751242b5a4ff271f2a10fbe06f6da9d6e3c4fec1b0e656d601a050d2feff74f4c1a23c6935edf9131679bcbaf33c2f6db23442fc1af5e6bd211ebe59057af0e1e8ffd3fa91586cb96e24747a445362ad52eab43c72561b4069ef6850e449fb525fa8efbbb65be0a20097045528f753e11712ea69cb947bd1476a4aa891f515563c0b310a58209956707abf97410093548806a756bd5002d4dbac7c6285a1f9450d4dba52b0a374412c5b35ac274f1d0348af5fe25218fd3a9a1e05e7de740dc5f2ef26f5a02af96185b76d91f484da3bfac1f5dd60037f0b2d449639fd2cf824eb8076e53f1a3afbdf34554a34779a10e7f4e03937136a753775d9571710ab18a4bd918ed28061720478bb7989955bc6dec4661ef14204dfa5a7218e9a63941ec186bba94c358bf3535904aa05d933243b7ca3c94cfed1e365b5876d2cffdc957d3f56b5cc7f5329f72b7eb2804b4584ca1d06a7659acbbb00119a96c6c44ee7ca905e7f5b0d62fd036c9a574fd225bd238ee100ccd5228cb7974a579e57ce51024ea5757ae17513c47c774f3b660975089c81c45a3ddc834688b5caacd9e0c4ede579f5bd331c721384385d3980f466e1437aada78b4a0fcc11e5a61d2953b7bca7e3b939bb2bd759e845b0fb3defb3312189b758eb071ecb81f42195532d48cd03b600cfb5dc5a029e64c3b02730e6ab54ecf05ce067e73bf7cc27e9a641b7a57a32a5d7aa53649808cb2a874368cb61ce1f5d56bd8feec0860182cc6927fd449bcbcd5f9e4fa821a7936b745fdfd82a831edefdc7f25cc45ceac094bf51c5bbf158f7c18525f0cbfced4381fe9869b99d89415e23416338a1bb34a8e27685eb45912367f0f37bd392d24b5e2aa06e7bd36653ef904b82ea179ba0f037b9e3468147b3f63926076867ff7a515f48bca35d742625dc3fae3f01db5f04336321f0cc16775595aecec692ad1d41c6ea0ba64cc490d89a66c1f8a846d7792142fab7687ef28920224e5c3ba1a28595a7e495eb0e54ebdecf8b0025bc8e457f0752255cf811ddb686ff209e7087171dd024b8cc83e59d151b19295c4e1001f1aeadf63c487e225b391738e83239c313369b10e99e84002554f773edc23ace59ef0ce8c3d434f6011266485a169946a02e7fb38e30431a4d64ad7344bb905eebd68af11e0898a4caebab4046886646d1fa07df148e06a96b31837fda48be508279d4697372eae18df8ee39291dff338a913e9d17ffcca984e2265e79da77566143edbbd446477108cb4be5de474d7b6b3c5566b47eeff63fa33429987bbcf53eb3f56ef155fa549d33f72682b9bdb5c7a2bc1872d86f37e8244d03ccdb35ee837959eaf8c2cf7e7c4b84cd2c39059101d48c125b9c14247d08d96d384c2f46aff7f546e3bc25ad86e1a24fd3c79d65c3c5b6e653342b5f4b7660ef6de70e7e52d31a8b642e296b3b9f72ba8faba34ad37efd53e96f4717139fe5866c971df74fb167c4444182236cbfa3498f31ad07d7a6fde467417a8f3031886f1ce45673c484ca5cc7063a1891d01f03dcb7378274f10af5708b6c3f8141a0b67db879a22259cb73dccb8690923116490d9753c9e0c992accdab0fec0bfc292c9f0b88401b1347e9029c5fa98d244a575e781fe22d1146f58a855d2eea1c52d603ac37afe9428a9ee47e9998127d538eff41d567fcfcd8ed0ed5334253dc0c1cecd6134a95aae5fb61b6d117d758ee112eeeb61e3ba06b9bcfed711601c362ff21209f51fdf0f1ca7c55157583808996f8e101f04520bb8417141363095bf61356882263503684f1f459e056331507f2e1cf736534055da689b3ec40f9acbe70659c7269d48a0881dc8678aa791751af1a217e644e12543bad8afbc605c4150c1f992a0cc9f2100aa06de7613f3e0344ffad9242a63e9bcb62ea09efdc744fc282a8b14ccd708b755c95ba2d03364e2909c2869b3750a7fde12072fdac458126187747ad42abfb85ffafa4bf1bbadc6a3ed3f9265b78d1158b49c6743f0cc91fd2fae692a3277dedec09b791b8f9513f63d037f8b282b890a1ff98376d0a81a3c33b49311810f10ed0ca4cce6c95a654375b0b15af82ba06201c7fddc3cf01445a29fe1b834e73aa4ef4289cc335150f4acc4333fe6a1be95472f148ae81f86ee75ccab4b02e20674b1ce5866bf2050e515876b8179ab5e5c292c879258b8e718ccf3ea286347cad8dc6a5a1397e6b6c97ad8de9644af250777aafa79cfbd7ebc78067fd071d28bfad00ddb81f6d716280f48206a648ed2440300eab31bacaa3e40304d8480cb38d02bced9eca3ea2bde4c451dc4002c59cff0120da927c3bdbde611624c43a89afdadf8007cbaa045ee54b749ae71395fa45138476f941680c0cb37e7a5a59f448f6e8513acc6a43206c6000b49179b7c9c2045d16000edce08f4edb0394e1663c83129d366be8a71ee9d652674d759bc6db0198882dca476e6fa43df5bae84421c27b89a8be5dfd9b55041f76da383d856daecf7edaa72ed85293b928f398fcdfa80df3a32d3d793c346cd623bffa664ea0c447fda66639ba5c8bc9d5cb4ea2193d4a7edd6ff52e56307529e8c7f34d9dd91399c0a19bb848bab4eaaab9c1a1c80cbf488e46613647531ef1188656c7eb1376b6f577d92adb9526960f7b5c38bfd5e7afb85fd151b750fc2a40fda9d1c6bdd66fb81efb6e2dca3f2db9a37accfb2d5da0ba4eb016fcba55a2ecbf254178bd81e9ee74c67b4828aac5d858114f2d026365c9cc32dbd3042a79420cdd352841dbce83e1ede15da900ca000bca82e3eed653ffa44bf13b7bf0d3620237469bbe7ac2b413bd39c02ef15b6b4cc1522e042a25e63c8094cbd550b2f851b32e15d5cfac14ac6af65b385571a0dca02e64113ea9670400c0f15616a0a49273ddef4d361bd0a05b6fbbd98091cc31a1582c90a676a3af894023c0c835d0ad589bb10711b9c48a18a598160eafa853b81632a167e65ca07de862f80d810f3adee20c06d894fec83fd34458879ad171ad7806f360b1b6cec40a86d759d0346d00d770bfdd413863d258b069a63fed77325b10f592d8fbfc65c9b197bb754b6769e42b98de048fcf2d6176c63ce35e9bcc171738c14a8a58359a715077a697f8fa8bc719fc7b24b20d8b6a418c75f1c5fc77f42cc375faea1bbfaddbdc56a4587263184a32b9f6801ee33bef4e944da5533426ebe76547dceae02ad193b28a623e854b50232b3fcb2516dfa8f7fe9199a72745d8f4900402e4bef83e48193580c2ff3934526395a5ec257ba2d0ef1606df4e35bfb675b85612c81b284817865c306a2c4c4c65c4bbfb0d4934aba45f9f957b85b572ec1135adc6a3ed97dfa2ed9b4c6aa890106ce4dc4cee1cf0901bb5186fdf0f6b42fbb7d3c354180a319b3c196b84cba81df8c222dfecc66bd02e9e212793d9118d7d309f87cb0b5079b85ac5e58f7e60dd7b80a5a4edd3f33a3b254ba6487c283c04054b70b1696a0c21b13a9667e186f4995e267b9142a1910aadcad1cf0237b5263347242c05549611b8e6af636817f0b3cf9339766a951bacfba6a239fc4b59d4efbcd58931d122a8eee7c5deeb7113a10e8e40a5f5cb756fdb015f0bd482c84ffdb2d470b21beb093b5400042b13515ec01475cd93164934e9e89ad500e7b1b1d54624db77e0cc66c4307bbe11273e7e1db698b3831ce433fd6ae9e7d4ef314c26db86e0f2a63bf2e293fa22f6d2538a8db6eed37d3ed1ccc82912606cee48f178fb3d3133be11c44b139499d49c66b4635303564b8d0ec785abaac6db3c5a4a89d307f3a8ae49ed087277bd7e6424444e59dc00bbd7059e45ad531fa7dc338a0ee4f0f0c5ef19a749e715d9b9b61ae7403e0e2bc60ba7ef55fe2ec3a95d289a8c53a35ca3eb25530438390a7781bb15be07b82288dc50c91664e69f7d10b14b653fc7a475b1bb439055281cfc29bab354b0270b1ddfb3d962f098051c0ae83cd242682b01c5812f9a2de365f4d7f2b16d904389834c43bdd4489f767e97357293e8c0da9341e9163bf9454ff88e981761cac9d7a570aa6b7be76aaad6a7becbfc6ce214baa5bc80cec2b64a955f716f2393980e77a5bde6da9a900a5d202c37736f5a2b51544683b27eb9ff6e61d1c388a71bbf994db7368a9f496420da16fe183eca39518dd525a91346fe14bde04a00eb4c1689c3d83f9edc64eda88410cae4709871051fd7092fa840bdd62306d7d3ab9792ad24aae9769f451b83f6bcd625c6102af3168f565751482c01d58aef789625098e6d9182ee82788f8b97d970f87c8dcc925624568e422edf0b438281f24d5748369c659e1051656ca9e634a0829c3f4bcbf49747c7e26833bed09e2ba7ae916c241c548fb09694aee23e942439bd173c5bc10690c6ac5fc621362a4350a055e8347f91965823c83162078828f3ede52683476d07c196f92e2c39ad53185cfc1371b88e16ad9e109aff11e395475a7b5c492ab68ec643d29e75476c6b7fe9990e573fdae089ca67e82279f858faf5ee149fd3fd8cd6d6d445ac44f2ae913b8fd84a923c0355654511a180d609e28a151dae6c56d36d6702394dddf0c9845a270a80bed8adfb29d4d59d7816e00a990db4106c7f76d5f5f91d92338c01b74dbaba0321353bfecbe6b4f3cfcc788240680337b44c78187e4ee5cb3434ad950b0ba31017b2e6a19f75d297133b54d441345abb75f964884c296b5c0db7b2ecac8c011006e0cceafede59b3d3e052cd7d98d66be4900e7da8acfa8c6fa6b3d46473274d7ff2e38784c5b2ea3b723f8a699140669a61472a211654ce536fd3d5a5648407113d19fc555bcbb815e255809d5977c7e921b1737b8bc832b967bc9ce67a5eef4d6c61df86e48e12a2cfee1e779ffb529383df9834de6c99fe359fd8cee34891e732ee658d6279e158f7f3a9c10026b129b7bbdd7ed92dae47bc487ad6754e0a0b90d0a303328a72f93b54e2bb6e4154d7cd49648a7ec9121782591402c136432c169fbace65e993d4df1733f6da14bf381f81afd0ebc7dd01307dae90109a7dcecc90e126304873cdc8ea7204f4060b7f9f4960ac1dd616f8bb9280ea3fb17539b46377f845144b007caea5dac49150a6293a5c02ebface792d9e8cdee17fceaba37beaba6c65a6370b19983973b218ca87e8c84aa0fd99082a38080a459070c63b2c5c20cd2d8f1211ebe97d5ad281c62222ab66636c3d23ff2c305d837c6d0d3cc231e9d4e1f6f6bc297c16720fca4e107bcc0185db1e5a05460fac75510f5a6c818c645596021c06c0d6e6fbd9731c96987e49d34915bca97f56def29a6505f4581ec606ae50659c6650d510c306a7714fc6de33766d094222ba0097fe361894d31a2249e51df10bacaef130fc5a3259732ee58df8da765e97863701a722d8a771de973607889db925109e5eb6d671db9b5188d5ff8f8114d369625459a530472d8e234c73c82a199a073de0215d7acebd2346ae19b057fca33afb4a98bd115ae6cd74ff3833b7b7f9cd9e77b13da7158ef269dfcdf83a2d385d2bb87e8f1ea85555bd17b92647f6fec7c08c8bc402addd1a45c23d695b49bbb0b068b6aa81cfc6aa7318a955a8da322292cab146dbd5e53c9da8093e787be123fda4521d1b329d3fdc1cfaa328ef746c6ac9e2881f0910160fe9458253f1a3f0207fde73a6eec0346da224bb8818545c154bdaeb678c993fe15f8094c8c450d41523c19b6ad2d70431cd6e607cfa6bf590904a74502f4650c786f1d2c6e74a19a9de901a5289d2f5ebbf9b21dea2b950aea7a81c38f90046c163f5378c0bd5c7552a5df818f1206ece1b0311a67658677dfa766085e4e6a083d67c5b0a654770f57aa24da890009594c56d720e5b2c5aff1e9a9fefe2625879aa62d77e0828ee49e667e470885f4717463635c9c55a23278855093122ced477cae7bc419bf5fcef644a1331eef9198445152ab06cfb03f29f1787a19489638176d8c91a29296f7f689c9b70eeb03b6de7114edd4fdd1539e28c57f66c17004ccee738ddc64dbe25f83fd8a776521685105d7aa64be977a4a06ab5c88373f7ade2de5d2224ecb4bf93fa584045f83328f29e6acbb63ebe5569271171b2f8cf67086c22fda6fd29bda9e42cb352643cd62b1de640e72529f9f99443631d77fe175b05c4fe7b2210b5e2db5dc05d1b48e4ab1e7daf702eee28b7b1209404375fc23a6b5de29656a81e271939f7d1de94b5dd1066074d43302bf97eb3d29739b43540343cb35d07e6554986c8e54a267b0425968836aa957320d75f422225d7233cc69684df0add421cf7e7f04ba321e422b193d2990d3debc37d6c30828401c5d9dcd1b2096a9c619e91126834a371931ddefd3f5b7057d0de3344527ec3dbf8a449623eaeb29c0a8245262d143a142fce92de6627f46f9397d46e18ed94e8558ada557090445809c1d289f22725aee12fe9014251bb9744295e66332b3b9aa7d8ba3d1534a033d39c3b56d5b1b147a603aa9a9e1cbd7ed507d4641416845bfbbdf4e5f9c8e03dc53cfdb3314c2c00c35305933dfbdf5c780e78fcc1359bdad143d653b82bfa35b25835a2a7765be0804d90f5685ede619d745ff330d913d6b489c46ae18fdd46940da9faaa4bdee333a871e727a30e3bab81321d7734b2e93ba2ecacc01e5eb1cd8b4042a9e4e796b63845c093dc8aef25e25b82ea2bcb9f75e8b9d6673d0ca61d33a33bedf28929d06b5fe5221cc459275dcffa73291c82f2caf6b84059b8d20291b3c0af819b6aff2dc677da9bab56cfe6cc2fda1d5235b7d7739ea05a719e3f72b7241665770d0160e4db69e5d0c5671462ca99ac3ef30b656a1efdbc3daa153b0ead73d2345b9c3fb9e5cd30fff8eecee704b85d912615d43c78ef35edf7c09b49bf034919ee3b535553c87520da393692f9ef1043c9adda4735272ef73ad96defb382ca7ac3deb32251bca1500ae7bb4e3fad52f411d97286d092792ea5104962c16d129288fc34500b1e72f0c105c6de558d897e79ecd0013d8d24e0f885cd2aa05ae07e019950a893ff04857f95a8232631cbc9680c31cb658180a41c910da36a9e432542899357e354999ace4fb7c855aec41ea1b4f25b3a8ca62775c41ecd78011183c237caa8de8d1ce2956ea87fd0fbf9a1eadeebc1ca76719caea1a11420a791757f9cf09d664eca5c0dd7f952301ffbf10578073faa32e8c1a452bb8a628e7226c731ff1f9de1f4fbe518d808e7919bc0c434cac9d9da8fb75e8528efd048ba01a1c3c9b1cc45bd2c94aa3d1a083e22ee02760ea6f166724a0b0941c4940aa25714f188b871a3dc903359dcd33383b8deeda929bdd396294821919b9ce3708932532680e9370eaab297b9a8a57abe4962543e5c26c9bba6272eb301281310813fd0933cd259e17b317338c06e61c1b6f8fadb6245ff0f65047b46926d36924969d8459441798090eb6d6bd86ed1c139a5a2fc7e4b97b85543e1fc5e8a73ad9089aa5fb6a61d586a14de498fc46e97ca931c50aa4f95771fd5672eaee216e60d3227216043cb6751d2aaba632339ee6f534e33e2a052fb86bd0c65caccbddbd8e17d71548fc2361ce1ecaa4a599a3da87fa3133e4db9be4bb5a19cfe797c764829faa5c868c1f40acbd159254601c704e3e9b2db3d06cfa6bae3711ee6beb5076a2ab741e373f41d17cfa6ac229fe4f1aed12b55640d8ecc948cdff00f7266ffe50f1b087c10a45ec8c4e7a139678c14781be0d26193f9acdba787e30a90138a927947d050f7a24e5f347a891054c6acae5c82ae39e8c840f845673d8053f2aceaca7a199d091c8b6aa31b070b7aeec6fdd5ed749fa5b183588843c6a82b6a004caee0b1a044c4659b1fa0ad077881aa98f10fa5d0152773f5a4d18d3c314bd62c040c01ae088f99d8056c4a697cbfff8dccfdcec1c05bc4afb1d4c9ef04a9c7faeada9cfbe3e6f643c00902cc4c30f94bbcaa5a60e71b57af268cb9ba4650bcf8b8ff8221ceb25dc5aaa1b3f9d09133ad4c7c03cc7ed84040787bdd7e7d96afbecbf9ea0f290f5fe1cdd8611396e0b7ee8c2814a213fba3e00b1006d14737bca4edb2a300f5cbdcd4e41309711de26849b38077bc10a0c5e30004ded064226c2e1badab9444a1d48600b944934f934df4eb79fb9e59b518fe45a21895327c2051884ef913c0d6222422ae3ead69137f92fd94013d4ade62974d244613e6cecb0ecc45fb84d542530f2831365d6445ce2f25395c547fe3eb727ddba6396ccaf3ae5bc5283015bb2793a1baa7d3b04cf635bccd0dd24bd34551108b1b5a7ceea110a7d6ce82b8d1d10686ea731407a9e07e4de31a62f053c8079afea251e75859a951967182e48644ed27e1cd94fdebdd772f7badd905601d8bbee84b60e0547aee492e74e174ff50881a81fba5921b007331c9e9ba165de411876ab6cc996ce524ef9b02e75651717e1912af196fd69ecf14b73bf77ccd187c084030dd684f3ef5d8cf3f2cfc657c7e74fc4bcf75df2e0149482bfe42d95885a8a3a2fa807994396ca9537b9a36d03238da8402f01bc4de69d345066326ddcd06f0ec894167bb10889c1b36c5544ff99c591df354ba1bb386bcc8a914c24e29295b772bed5647657f81249365186202bd37f14e7b28f3355afdb3fc60c06ce1ed1e7dc77a11f012bc06027dcf857ca62e435ba1dbd0f79c65ec10afee249039a8303d8ab4268268f0a24de0e53d86b449727ea0175627c0fe831d81834a3191b7dd7243338341cf59a32bc218ccecf975fade44dc1fee46424d832fca0f4d852d3de5e2a882b5501b60112d64971b606abee245eeef356c605bd4a740e3104b583f583032464ebf01d9f0847e68186d14eba1dbcd86f5ae98bba2f4e3de12c41bd43c38c8b1f05ce7a285f35f1222036d185475e406549187942e6f19499a61d8a20e89d0a39fc439a6b3aa596c250133be214c1f5b7fdc92359a22e315fe0ff920ec0845877437f433b5b0525b9017242d3491b36a166173df59529fd77cc0f3247d17b4378fba9342e4724503d6eb065a4d1baa6d482bdfa0f2c18cfc77ab68804d1b61915d6e4b4bfd9691d1b4c9f37fe563a607082befbad34a1569bae9a6d6075e12b8df2d802eb4ec464cd9806f8bbeb45ffbb4bd145218fc397f4b2c1e51df66fd8b2596bbe29fb04b146782a0cf4ea3798ecc405bd381204eb8bbbae69c357437cf8989e3eec21a9239607fa1cb70378591115b5b86612f15c89c5de6c54b69f0a12bba6ef3f14d661cedd29198918b587414cdb11bfd3065a33f03ca31ea1c0c37175c6251a2a8bd17869ea6d77acc6b0f7c40bb73873620aad8e5ad1a140f131ae4f0528e67f910ee800f37f7c0a158e9c6e2667fc969975c8f3bf1cac9cf0ee4cc66925346b3529a7ea60b76497e4425861c87c952a35b7f9bbf15cad17f8918d2cc9348d357f5b0f627fde891781df3b7887da54bf12f91fe5fd3f694b4c2547e40fb577796cb8959a6f927a60b5c7bfe309127d24d29ebc9077fbb1287347c2dfc98647bf30e67aed67ee3b729221714397a92e9f702e5cf22418bffb562765a46c7dcb93eeba4bf8ff63915a9607ba09c2028b7dfa899577780e24bd67aed1e8387507efbd9cdefdeb500502179cc24a1eaf3d41c6b48b611e1e845ecab889fbca80cfb29ae32da32c11073e1a31cb99c9951efe25377849de4773dcd21471bd04ab51b5292b071d24dcf3452cc4f9f75108abf4f69c801968d50e379aa07f3930038946147a7d34f280f12b087b802f0e60e1b5cecc9d645542f9947d49f90d10ab10ce94f6e867492c2792d48bedd97425526d9df0cfb0b63bcf2f0b6774eb81609fe51b21962777a3116e83ca94a325c405ab31f952110a9959f9d21f30cecf3e7b6b3b385df78cad0fe861d87fbb834e284643ad505e55fd7f11d3bea7fac3fbcd2a05859cc125394a588f45f952ba9ac9bc8162c1afb727c40493f612e50bed728552f758577da5145bbeb7bc","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
