<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4b0bde377229c52ca157dbe54ff73e3b91e56cc3965d4659b97875753f24ab27363a36dbcc20bb09d1baa8110a41b908d6aa9f0e65a5e66a7bc2293cf1087b6ebeeb546fbdcaa5e5966ec1f53e40c7217c0fd91574795615ba133e42a21ef2b2f3a7a6866ded38a8368b976341aa1beaa31731eb83802bc0ea32a2e7f7f8ad7c93dc9c6866e2b608e892c099f14323449945f3ca6fc946baa6acb7e613d2e40ac4b06c921f288465a7602e970431ef5b17b2d5843e6dc47a6938ec0d82ed7af92c8e791420b7c2b0f4269d1335b4e74a1b56d02bef4e6dadb418c83f8c7a3ce5c377f034037dad92e5b42d3e1ca109f87a5c28641110de501bf60fdc0e8f6ea78f80a2390dde415ce109647cd6bfcc23ac9e79c85ce5f3e9815d0d5773f9b6ab1dff5f19f56ee4a225783287525f4b93610c7bd926e3181f45ceceeca0dfda816d9409e68f701f2ee6f5bae08098a9755c2b0feea30f1f52e4d38c8c3e27392eb3a9ca8b5630e7a9af528b8fbe628eeb177619afb4502c087f30025fe24d3e11b2f264f67fa857bac536694ebe6525577a2d97c5910816cb8822a2becf771fa422c5d4724feacdf474e9a69cd905693230ec44b7e4873adabaee96929f6f57372fb80700f31b2a2586c0c68a00aad219b7fefbacf980140ef05de4c52ab5cdd1ec5d8749d352fe2d0cdcfbf3d26ec94a66a9bdb2985902904bd86e87aa6253e785a8ebecf50bc9a2a9aa7c9384cfa0d91925c5851dd796a728def42c0916d123c49ebfb91a5fe79f9ea48b6d79ae0f006c9f3866f9a87ebafc99b43361d3a169e53347af7330f2225ae1d13bf93f95bea3c27bcefaa979cee087d5e83990be95eec7385c4dd7601efbc2b32595d617e889689911607fa844d50e35bc00abb24a5bba29ccfd433c8118ec7f8dff2ecba16b2255aff7d3b6abb0997af201673aa506145889ba4940fabfe00cb9df2dce5d0f809b6e286a27b0df8260a8aad683f0cf363b0f400f7e9cb161829b9dcdb4fabc748bc48c984f7fed1fa7f01e4db7ca978d7e9c59b9f8ff273c6ed14dd86a139e342b736c40a8b437142da7c4ba738bd634c9993ec7ed61b1f5b18981eec0508c87c4d35a05d7757b739304a20cd8069ee5b78c05a044132fbce971238a451e59a3eda25c81780a7924609ea817bbace807d2196ed36cd8f44a276800c12a408457133ba5dc01c38c5c7f38a6223e8ba648461346f05008ce5be684a36205c334bd258be683b86e8800c6a231c2b22b757b77ac14e6715a1cc2f20548afbbed6e55b86e7da7686aeb146e74307b4912274ef15b0159d34b033b038f74ea41721915d1a0443ce4ee74ea769ac7a543f0bf7a9b9200f2bb9727f77e01e859f369ac11a4e53c003a74e78167a688d9a75ef229285f895942e688aabbc1b7515830ab3bd230c635195d3209d740738f3f53e81513d8bf1f48783588fc91c218716d95a049093a86e33defb8032bbe9644fa88ed6fe4e625a15929d4ee8b08f42b4c5bc72f0f235fc700e1db737bf65dd72e4ed5edb65e6971c22677e510715ced4a6358969ef1278c536169603c8d7dca640a7148863b0a5fe6c5f331ba8d6218bfbc865d38b5011539ed159e05300c9467c87316b706378f355ff1f5455e39552c125a77307f084a563de795e6717101f95cb577c4c6c766069e8516757d536ec48deacfeef69f45ed070076431888e16304f4569a35242013109452fe53566af6a0b15174ea25d395c37bd97329959f136a00e3925dc12d13a7659b9c54b52e4b092e13dbaaf47c4ea5467145ee6a05a9c5e061eb641451c4c92cecd593e8874906f5ff1ebcd90ef7c2bac7671abcc5a3efe40140cdd42fe065522a914c68faf5247fbf7581c7e6aa5dea78312aa0730b2322117826e7d936b4d118866860d81b6853f1441825ed3aeda119b366c39c0459b97ed64c541d3aa1848944d6f14625fa8aadf25d30fcd0b00d30384aab5eb28dec7e6bfe7540368f2b4def5e863700e87d5b4c4777d059c39d6c34233d4006b10b75cb2b6fdb007ec8d25e4bb5345ebf126e36d09b707ff7d2b4774ac20f946196d636cc535e83611472e10a6ed9c48aadae6050e36813202b3e003550519964fa4529da1db16a04fd6c0423d3e14aa474f7923a146ab1971961fb2b2482440c8b51ddc720c48f2bcf6fc94d13db1be596bc867f92b8b298ee88e6027db81130e8aa33565e3b17634b3b214824cac5726343242e56c209d8327f8eda2f07dc62c4de785b3adaaf9a5abee2a1238323accd3de24b3e078ca8a610b88e5c28fdea16ca4bb214b17f2d35b90751a0e65a7ec4402e659d3c8d8fcca0990125d598358144e783a79927fe03d12b0fac55c9c8fb6373300389945afb97ddfe13b65221e855d1af2556cec85234422578237fd128813b1d189a2f124ad111b86b3215d728bab4225bb5fe05e0307de7e4e8a649d4da652b6660a9442ea07526dfe8ef8534d6843e79a12f379d96592dbdae233cc83925470bad2abb799592b33c708f32d24c54f18f25410fca9c6687b647bba271ae83f575ff0f285a2b24b28e3f056654dc15ccd27de38361ba08812d2b2046e46717185fd604f3615073dfff2576b7a5292c33172b4e57b2e0ecde843095673a0086280d1458594610875c22f1e3de538d2c2521b2cb54e88c74915fb4b7512037a58dbd19a51c01c0d99a49e5ae507bdc05e4ed5e5f9300d0c2fdf6b0649bf52594fb38b2dece0ba4f7b057ec3121b4f91eb9be3b987c2d5a01b4b029c132ed9d369acf98c7d6a8508a36f6e22da2dcbcf378d9916702ff663e64f1946ae3163da489356b740869d3630bd52652ba935a12c12da35fb3ab62a1ee44a8a3b565201c250c572463a29c574288974c6d31990f6e13bd64dc11245129fcaafa3fd0e345091acd483abf8e7e1818d6620c2595c9609e22d345860c973ffb64db42f975acaa5276f1b68567aae2463dc3ae019a0fe1589a6975a97b5ff4796656429a1b0f73c3aa65c3f3563f0f92cb59a57a507d87dd02e5c1dc2fc95228a7ec89db565a0214e7534f1644af18ac6f0be2332204c56b191ee409ff27da5a9068725c2ca023a14cd423c194c0729a30f2609ec4346cbb7a344e1778309357869abe48f5ef774ccb7152eb0ecbda6b1927d5fbd496b6dc535b215d6b75332462404510ce9ec1c307f9682961541582b0cc85bbbfcd4adc9df45180093ca81c6c570d6ba84a507a5f3c700358b81d257d3c513b825314d95ab23174559c1b399be9c88400acc492b910342ecc161ed91bea29e8c9e37d881d60c878d77c476abdbc0b1d3e234d86c03a1775d1a10659d45e0adf4efcd4decc198d9602721c03c510ab16508b9ef989d5738f103065c66b3ebb748c37d0cf47d9df2d478a80f6163155ebff5f50dbd3897a128e6decb3d2cbd58ce3152d49bedf18566ba680cf2a55d1290cfeccdf9e5c0cef3364d86247618e891e63988e6585c0b4d7bcf4d82a13c550e24fdd3bc2e748c9f965db247f972dda28101d4b0f8e03014cde3c89e4c6435bc1fc6faa342d73a8e35a7b97591ae86eb7efc15594560fdf251131ac4baf80c4009447b1a62d8f4d40e333bd446614801855cf5cd1a5d27bcad1476d9c1657694caadee008e1c1dba1f68b73588455eef5a1729d00def406f3c507a4de792dc4d1d3f3bfa0c786de5031bdbd2db38c384d2e4712e9ac6077574c63bc5fb07dbbbc0bd16ccb19220b29390a1fd5b7bf5a7297a9b306b8a300d29b119c8be64329ff681dc87181f2087c6f2047514714b3503c1e7fafda4a34da68b079be2aaecab39be030584c3752d2fadf3b858cf87a625c6e77516668253d6a4a4754edd1204731155636ef9e60826cb7cd682f671887f1ebd1d5b55ae8a4a352d8abfe4b7dce493bab0f66fc4149917f6e825880b05bcec34dec0a20b7679a7ae9f346b83544a84aeaa453e26d5f7938fc5d328e543fa3ed0e0baa93ca5d31bc89b824f094cc39d34eed94e5a046f6854f1437b0717a140c5ede13491888a9f51275f5368e596a077d1f0995ac9bc6794e98bc8d33728a18219add486a1d793ee9cdeed8c326594bee4c0dc1fea493f362532584d50e19b113be409c9b93a62beb9598038e88085a9212f4f555599f77e0e73d396ef87bb693e5943203e81da6f109edeee80d0c06720bfb20df68d183cc449a1a272ca4756bc47d577a04276739d7fc1de6cf3e88b720b66d9b3842640638ab943d3b9e6b69420405bee52ba9d4235632cc3dffa15cddc035169ee559032bfd03813a66db9d4340a8e116180b24f71abadf200453bed5956caa10836967423a69dc7883df4c8b41989fbb5f834b29b4a9768f422f5639e6629bb83b020086dd231a52551ea7cef40df8c9b398074853067af67709887287cd42d10c06b2d3f2391817f47f9e07858dd83e30654c075bcbfbb6d70e81936bcd92ab18656497bfa5152faff2bbedaaf866013f85eef3a3678c9493a95950e565d2c9e92752c9a0a1758ddb5fcf82270359292589876ebd695db8167c343dd26a52c8a84f91a3a7b8ea0e21b893b14745ca2b641dbeb003967a662218da6e3f59e50c6e44f4044ac10cdacac78b408a557c125d7c31f00bbb2c7a7d2f75b9a8e7f20a3725f352a47d47f06905f83b7893468ea2fa26b1bb9197bb983bc280a0eaacf50aa001f545b925ebdd9996501de61947f01615f9e6eb424d382e8027d8d92d6bf851a6440a61208abba29eb4f5f957d5c31590dd7ad9a4cf0f81264aa77be3015ec8ed66dad5ff6d3837ccf1cf697dd3819e96ddf1f13cb256bbc50756211726195f28b746d647b2dbdcb00661d823039b2bef234819e27a0b8eede6b1dcf0a9ced7195717cf5cea6043a321b0f9b111c7beaf3da08765bf4ab80ea592eef5c83b58e0c709e3049ed73381787d1cee774d48777bd665d495cb3c4df01b0c3326ed390c068d04ae05d531db88675f870dee626c06cb38b42b3ede115becf984de370e5efacd77722bf096d469ba8000fe70325bfcc34cf1a00303b63da06ecd1793d617db22c4383fb68e742a134cf09d0dea21f6f232b126f0dddb7295347e9698476b5eca6bcbcc0d222b41970a870ba4106192e6fb1dd9d88f59a8ca4b71074be3353349d5304791b38ee067a3e345e34fdb564dc0b853c3cbaf9e854c009c3e1c193ef1d2e60d2da6bc2aec568bd7cf48ce3ac2fcc416a78a65b3215b444ee28f3d4051963218605d730448c302aaa992fc06f23a8b90847b171f6d122bd98beb4753be1c7c18a713231c8ae2b032be4e252a9ebad78ce4959790d2b654ad5c109a3a89df14eb864a2fc3f99409258e1c6724ca10a5e713cd5eabe3446baf442898dd9033654e63b6682695c7ef2e8dad2a7750a30fe2618f52e1d5e2a7dedc0e5baf75cf8a580d731623b8196069931714bee12ce4be611e6f9eede229ee207e56ed405cffcbd3bb97d2f3fcfc0d004f82a5b6b1258fabb16c02827519327f4a3127db414c4a527fd93fe068b1ba16f2c39e5e10430bbb224a568720612f021c7faed42b45ed7230a6d46e979f26e739dcf036c77052379b76aef6cdc4ba9a208c88d107fdf75cfdaefcb6d3eee628d6d5c4d811e722775f5e757173613261383700a47c93c440f14f2ef3d0454d632f4109f732da3b65059c0bc82fbb51181ad975a00e2b7c3a6e0a97551ce6d22c92ae14513b1e59358abce7eda4e1edf06c853e0bf54772ba3866f63a3f46661db36907f6c5a2d5032c54a2ff5e33fdea6bc681fc9726cd006ee5d6c87de1c3b5145657c5a4b8fefbbc5e3a18d3031ad91d3a4c39f727d64029736661e8cb0188ced8360f2e6a5675b647807a6fed63c47a7bc8bfcc18a62eb589aa17cfba7cf9e2aa5c6ab72d34b365e3ed3a13c000b470ca90a4ee025c22f8b755edf69948f1a14e00dd07e0ec7f2d920039f2a78a15e2b063bf028195f9e06769953c6aff70a163fa9e4c9bf546ae5e9c18c931fc181beddd46da690185963b2f965d418f40f5d924159658dc4b27fdccd037a9c67bd20c331ed40dc495eca43e116227baa173121af58e5541ab249c47170f911122ac3d431db28ca83e5a93c47ea183dcc2b726ed15f9f666e8c176566adcce1ebbf46793cf789c6d56ca2550d9fd24a81ec106f3e4b33a0b3a008d65a828d3673659e88d1e7eb01f8dbec0fb2108ba4f94299a3e6ef153db2bf77d930adfdae237ea937cc651c8fe82f1a7dd22692ab2d3a5c939cd6b9991c84524c95adb897ac4e931a992fbd7e69118b58f6711b7249589218ed69d72395b1d15f07949f6f7095ba2c24c201be03fc1a348f35f09566de459ede2cc84da9dff4ae95c24f68418fe1543b8100b0013fa26caf2ded02f98771685473434c98fc9752a2670c964219dd6bb801db1d1388a26c4722ae16dcf02fffcc5395327e2af38b4c434a3d13e156df5aa17aeb1bed73c094404d138fd936e307e949bc29ee877edc7247a9fc1d3d26d6fc187cefc7c6a8c96f62710cd4ca296b6431534409751ff0bb0864ebb61d59c0c9b6873c569df54bcd28bb11ddee41ed5505f5393ed5f9bc6e440201e72f2a30f9a0ea220ddfda595592857a7bc178e7d2a4b70587a61843e4ba729631360196cc46973d0bb4550cb1d230322e8c1b9544df6af5270c8b6cde5e98bb1af34a01eef7494b5b733278287bbde811f71060866c9bbb91c648597ff34e2ed23ebf63e1041886f662f39c5af332754b13259555db38d4d73498faa0519cf02ec474785ba2e45d2a06578d0d7217ce6c285c446dc19a7d94edab2856a1b5f424178d21f9aee0d5b37dcae80f6d02316408ee8fcb7b12efab323a8af8607bb2a052de0072752cc1d6e358b730ed9f09301232cb58753e0ead81eb6af03f27c3dc5deabfb69a68d1f8370f373687021f6873eafe29a84dde9fd2b69ed7926fe72214229caccd9587379890e12aa1a1c731a6bdbcc7e7ffb9e10c2dc9384a8f4d7e104dc75398ca03fe78551936ab1f8ec25f5ec66c6c21e365be903e11210d49f19f6e7c511a240e305dade87917a822aef54203b78b4bb9b0af713b46b4bfd71ec60fa970e8fcdfe681b8d28e719b641f490782ba87da4a0b7affe21c4980b67112e1fd542bf84de03afe8768daef490aeb8315779887cc041a2cbd7cd2962c84c675c512b0c1b52e0453c81ae663ae1252fed46ca3414155dba593bb8fef68cb1718e9192fb27ee3e38f91c956f1b1da17a924fe95c0093adf3385649b5957e5727c9c4e378afda6c1c2fdb5826dc6f3133c416e6e0a5714bb92d4afe137a4e97038951473e9f3d2228f2f5bab375a8e12ec41cc149b66ceb1d9e2d6a2618dbb73d3d45ef523e3babd035e03c112cd603e78250ca1f5ef8c582c7d6987a45920ec0cc308300070c679ac860df06552bed2b1cddc8f9163f69307131d42edcb6134ecd2bb293d104a6e4e2877ca15659274e4faa0455504aed81c5d9ffdb97b9a5eaa5df916074eef42ccbed7e56ba10aa0e78582c15f8ee5e3c3d6fbaa9b6579774d6e17106584719a806ed60bb7458c77ff116b0d319a6a118f6ec0132798d395e2ab90defea53dcd979bbd428ab48a3c607feb4b8918d99ee88c5154567a6ae881db08f0fc890a0e807d55dff9554b714a4fc30a0aeae2ee0e720701dd0e6857f2506d4e26c86cb43f1c4ec41b5faf7702e653e192cf4cddbb9d4721a624ee150ff51d6c27488f573775b6fda884fd310aba9a2546f1261ff6cc9c0948f8d155e43548847a35e6f12bfd42aec38ac8291621a95ddda54d2ccb21af4d6fb1b07bc66d4387d17aaab59c4b913f62c7325a3f767844486feb2786d81d31584d7186149015e59bd0806aaab82973ddf9c01a557b32053754856b8bb333844fd56a4377e4eabf7cb2e5252be7bf9c8f80864b94274bb412d5418a9cfbe7bea6016b9e80077cb6631abbe6a5d053ddb2fdfc9be2e959afd88257d445e0f357981722df21172e2ed875f3d64387c6f8733cd73eacf760e3f0cd845f3172fba299d03e9e90475186662d09150166cda27e9eb5c8e3d7c306da7a142072603384c2a2862bea493494cf46fec67ba90258f258717aabab9e0b969c3f44f67dc89a8c7acd68fa66c20b8ddea20c1d6fcc3f569eb4ec68eceb040efc843f01c77262e81ad7c4eeca0c00fc94e345311e19fc22997055619a231cb5eb8417200b4b3a7b02ad0153ee99fe8a6ecf4eb83d7ffcf18bafe4a44f40526985e615c34a8052f2d0c59ed684b63f6885f987e8c28ed0c201ea2e80d474d1bf8398532a4580c83b205a403f2b99e1be815636f71ede7592c47b0be7a760d6fa458f6444152883f1033d7fef5d3b3b7048513e21dc0b5d297c78653e46b28e069674a26e0eed89b718733b1800f497ee9e89d247e454b6f123f2c0f1e156b2a4897c9423785f6faf355b31ef1b2ceb5730fa3180753b68bc6ae9350d97259729e44f6ac884bc7a00ea27f0e030899822198b62ef5095492a43dd2f1db812548e31335d4fb16d9004fe27163383b442c6ce6d479a76bbbdcbdd7e3c27ccd0f5e19dc5e3167a72feb25f2c219dc5f1c80899733091e891a5275eb8676fb211ca149de980a0d73dcd22f409f41b6c3f5bb4853e2d6f632be88996cd67f6a9b204bc919388eeeb56ce9933ebfa19fb8a2fab4ed470833e218227d1048733b19b7c05b98ff1c28a271e02229dac526a4405bbe739db7bdef115bd7e6f3ec3f494f74e09b486296bf2784f16e14cfb20f78f36d198d101f112a5000978e541b064ff33d664e62289a88f470c4f39ca8af013215407f0eb499f48da794fc43ebe3af4a7de7270cdac77c73d50ce374ebe240103d31a32dfa6e30e9c1226088597d421313dcb108f41fdb03eab07491463f8b18a9038a992920be5398932ad439bb531504f82440b6ccc6f5946db1ca2cb89a2f8de9d0b265f624439b6984707f734dbbed1486bc1ca5844432706f51036571ca108888e7cf02c824f9830c624281d107f9831de95e9ea4475933f9bd875f3e58bd8c4b801cbfde96dac31946f0acd807e346ec8df18095c244eca3410a31c190c68b64f5eabf63decd1e0fa6aa1a708e963e938138e9a4d20ba85d2241d380ec3099475c50b2c2dd9177b9ab3bb8687c6ae81a099894a71299384d39533bad6696d4c48a823f4589627d58721a090304be8611cc25e40beb3fa2d9e9e5063aa6c5a40e34e611e062376907652a9b5f42299a9e49fa3bc9121fc70dedd9c7dce353c53c9a647aa7036498363566c4818a907bf858dda3dfc6c6eb42fb9ec6256724001be2bb24b4cb139fb45c1e9b86da0e3191099989d744796ca22240fc83a5d306392d83d60504dee4a0023dbfa60752dd777365263e0db4ffd68a126c06e644664241da83d8b168937ce51de79a56bb8ea69554aaa322dad04e83dea7e39122d4840ae2c2832d97c454747ba9210165728e3f214689dd91ad922c80425070f92bd4a9e2d767c6d74a91478f493a34e11b939e1870fd1dcf8c074b256e21ac0b595afcb8024f638ea80185400eba11bebc2f6e094061498ad532dacf7721dbc8f21c02c233ff10811c5ab24b0af6d75812b062dee11fa8bc65f92bfa601a6c10679ebe9a7973dc5207a17396a534fd9c472cfe5c718588c936932f234b10c26d0890684ed9a818485649436772119e53cbd75b68b237eba052c68cc7189fcde1ba1bbac4471402dbf0f6c5e79af1da50ee3ab51928ec887dc68c2ea1c6f247df19eb8cdf15219bec93195ce3faac5fb1f3d8f1e38e6adc5d8f12e597b5d381e02ec90b2d38ced290da843b9df573b0e299e85d5d5c836155f98dc19e43a45c159dd35357579f80286b46eb16cce128fb69d95bfd5e17dae7778d7cb37cf3a75ed7578d7644de8750c4d61436aaed54f59fc9a1b49804d70b2b0a7eb04a127610f2c8a2f5d407a22ee80903fb71618b9e449995d94dc1d984250d92228a151ed0d5076b0cee2ffd3f99f6f0461d370c615f32a80b2948d92e9edc80659799ab60d97940ca50b00933a7dde3535a8e1697ae4663205df741b6d78b896f6cdac4e7cd10b00a53a255619b913fe4619b2b58a49a70f303e7b6cc6b24d41296a46a8fe348723046fd1e1b3683043603a6af8a1deb0d270da458bc3c2bda493784b12b4a0ca9fdeea804e05c5257736b3bb8418bf680fda180abcd57bd95e9d171c82d8b48f4e9968c03321c3b523235d4160292d8cf8d4e1e5610c73cd0ea281db9c13bb6e7859cb536e064b95b58dd4fcbcc6f0a7b0de1078f961d3663b7817f1e94acee4e720fcc1f0da906621da3102211906c9c082568f979b99763f3a17f6b2c6ed7fe24542339e40fbcd7049b560d37c771f66a14b99abba34b33c8ba199e5b052154088a89ce4777a1aa9a891e2f6c9ce241faa2f6599b6305a1be6b478b5d9e3ca96ee794070d734dd45b140556880e05d9dcb8dc104a566c3eaed0fdc0f81840263520436064903debc8cc60b79e474bfb1ec2197eaa5036470b254a87d449a7134f95bcbd6e36ea3052211653309e61b9bce5a2943d8a3e48ff588a74634da899f689cf535cbdf2aef617be3f444edfeb2bf8ee8fd2a1aa8fbc992f14abd6a6693ebb9a92a0763799ae47a285655ad228555d1a7dba2eecc723c3e31e745ff4bb216b56527df282412410e3e8b216a033f6ce8a2700793ce3b65c05521884a825792219571690fd86c4d650a9a02bd8359e7d44054caec8abfc4842e27b2f18398d73eda81f0386319093b53603cb9b381319f115eb80726bf9b7d4c7d23ca8cfda019692ea39dd0881de4bc486bdac377fcf538af23a2414a7ce6789c27e5651705412e93b65822778c0cb0d1ab9b9fe169f0c2e23c9f6a0fab1014a6446824c53fffc5ecb43f97687bb4acd24431be52c94e53dab02cf145c96b2bea8448a32264011e514447d4cff5d01a52b038baedb487f493091b90762990307b22f757796e225ba2f682abc75b7076bda24b3e0dea09b0d98c531e6b9bcb3fcbde52589201a5df9213274880a68a22b7fb777c112d7c6cd74c4ac523135a292069fe1c41d09d3676899a7162519ef15d162f1ef30c82dd6df614a191a436b65fe8a75213681157860b4da3ff80106e917a6f0e4c74053f50c7bfef42fb31684ff7621eff7c69f8fd3ae7f48bf44ba79652602e51134f7652b1be241f93e861c23ff77094d4edcbc8e3be06100a1c7a9d6948139a820e85c9324e22d8596bd7b0efebbbf0cc8bb06f31dd9bceff3256999b934768919c5806b0407a2c86489cf780e6b1548ba7fdb4ad461f9bca31c1615ddb48d30877646838a66bc8891d8f9054f0b352d556af97bc46d27910789a23672f5b406517231299737ce22777018e291e4c5585abe5021a0fe454b7c3d6bc067812327e4b0984ea0a10b05ee4cb54d3730de717bd08a33a3b3c4398ab97608c28504d5f930a62b07a6c9d10d75aee18e59706c049466eaf5f9f89b611eb38177845e6a2b6aa3161b4c4582a8217a4bb3cbdbe12d56aea776dcd80a551181b10e39508e47755e0431c9e1480411302d0964e66a1ddf1c5ab4219ae580dbb0ec108796cea91bd12c3b1482a987bf66f16baf8ca903e90324b8d75861b00f4b2fb4655c002c67f70e823dc4c35dc740c814cf25c3f9f7f8ca5b79794eb922d46a698f379afe7de80f052655b2b365cda0ca47ef72a55729bd54897850e5f483b006b6e52f1dabb7c0e1eb1bbcaf046e1a2676039ab683701016dbd10668feefd9886e6c51a31e972c96d54aebc19cf60531cf0cb5d5f70ddc4072741fccafeecc494212852200eb918a95c82b4cdd60b91ce6d9db6632c022a4c648f181a055b78c4454e25683418f3aa06ee227a1554b66277be4eaeb656f35a0cc4b77e8250069e76a182117ff443154ad237f53e4d9cb9b64b215a50bbfbbad4b79d2cf22518372b0304ed9abd8679fec4c2b0271a04ea96fab4b55010635857bc019adf8132ff41750cb40d63a8bc659c16ac65fda33cc17524a3f3bd0eadc596d515573fabeae3a01239e882956d29afe1022ab875d23b7c29463ea0226f262cef5c3889bc16cb1c856b2a7af5a85ae66647633d07c3ac83262dab60e13770af735fb87f575d489e0dfac9ffd334cfe4f16f3f0b76a1d1ce705634e47eb985e71b9240b4b42b6232f0020195a0c61dd2c803790e1e58fe86c1fee58c7074b56f905e12e9fdbf46222737d60b300849e68575a8900e260e39d94deeee1847eb7962762b4d86a475836f684be85d33be745503c6459eed5c2073951b2617bc32d4b98c84e24b50a30ce9294573b1efc2dfebbfba48833335dce1680c25c69e85cff26ca9ab3c86a31442423f9a9adaebac991f9f458f93b4fabbb46843e9aae05a05abe5cb08c820fe10020f6a9daad440bb1bd21a215d19940cf75ab59cfabc2bd8964a7eec75f4676b4cbfc66af0c142069b627d7e95c4f70f9e96e847f66bc5256cd9f2372ee1db2a7ce9224e2e308100c7f82712c1233165a9817f9c6ca78e4fc6bd14749e6e3e4ace711267c631a2ac2dc9c49ce3e9223e134abdd159363d6890aed848ecab726287a990c24fd53ef8caa858f56b649a67c7929d47ea9256b1743bca286fedb3fd6ed6f294e8d0985627291fa1f53283c23bdb9f952c0beee5a421cd696ec8ac1145c2f6e43f2dd943688f3e60aad4ca85adea7327b62b61a2c90e045add49781991af5002501a08970ebf6090b230a020e3d2f865b27760547bf43637e4087992c1c3ed5cb76889264804186dda615ce54263bf02aae2be05e06e472e44df74e4ff28fe3f819f193a708f8a983c6e8b9a1110d295bac288e988c8d489a882f87ec20a47cad4327b4e84f9cea3b29d20379b9a594aa21224b6d648d72ee81b0135bb7f767d977055236d41992f458eeb356db66921f2011f3ca126e7aca1a33f33c12ec791c7dc0721ad12f17f314b1c9658918ecfbd5237879b354361de04ae2d6a7d68406997b07d24774158c46d857bfb62417eba6c2aa4e3c4913362fc88f6a6f52c33023a7b2e7fc067369f15ef2dca0f57777964c3e4db37a71439b2c0355db065c4ac525088f3ba124d7c945c634e49347584057acb2cd96a76c47c764d5ce13b6c5d925b3f7e05f10ff3cf132f2274a7bc8daa63f5f43263e80c07c69f9d484ea4e0325f67e878ef610801a1db58d63c9b7f25e637260faa628fa139d2206be1322b7dc82946082db6d165b5b482e22dac9af5b1251d7ce18cedfd460a9860ab1882daa618eb48425efe5eb8fa7f01658fd88c7c9c1266e0daab4384658930dcb07540e8a997b4371b2471756c6b88f04adf7e86a9999a5030d911420f2c7332f87aba3420d3a38ca1a7da79541cbe9f53ed58e86b9e93db6f56e018859607cc0f357c695c7944d451cb896450c60d7a5d38c6924ed876b9050a77d200ca05285215fa6b2872bcd70cbda7a7cd59f76b828f75d510eeab630e4ee771950489c9fe8ab9d5e0","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
