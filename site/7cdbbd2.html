<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ad51c93b8404dd6f5204fe7c47bd47dcf53553a413b4e4e17fe6f843a600338d99e1f6e508cf0f002dd7e479a6e834d448c591f7de53f33c3003de09c379684f70a7654c8ebc46dc696e8e1473adf28fe6dc01f4a373cc97d15d4c3aa940cfa411508c39aa7454e3d474bb0f3930f52cb25783a46c74c8a587cd129a4115716cfd207b3aeb948cb610a27f465583542fce49b48cd7bb76b3edd1872b31e8bffa55bbc226e4ac6b773340366c65e50b68a920e8288d67fa775acb0dac9213ac95d823ee0e2186399050e220512027afc9872c3265eaf09935e176a8c44f1499b8767f0e46d9f4c0107aef60f337255d41fed8300312165bfebbd1ab418dc963486860f9043612ba9a816c67e0898b143319e4addb94309c421f8bfa9cf3791bc8b907846831f01f275fb49842e5cc45c0df910a6874f94b50ec2208a9ca6dc8e3a0652dfee981ecf37f08017656f1ade36c3bbf5c59412e50e155189c902cf421a54ed124fda8cfcbfec80dd5020bc14a1df8a71322d3fe6ffcefa9d9d4ce181f3e9a1e2824fcbadfca0490e2f0d9e9dd71f0d0aa5217c4e4e12dd8f5e36153fcd7e3f20574d7c8462cc504dff395cd8cdec00493adcb53925cbc05a717056664cb5208f5071c7212301ab840652bd80c5f8c9b0be913aa4ce44752cfbe49142c9f80fc03586539f52e6a2be6fe4866d84b005794e76339d468f1b1857a81327d3b563f7081e0272141e976f49012c063df91a556bb645f45b916a866faa59b6f0380b47d3dfb8a6f06bc445d660dbc840f705187619d450f15e0735be5256feb85b43bae0738267a19780133c34bc1ac764bfd342d09b6b85d1a97ead7a6e9b0fe68676d67a982a31b4fe5cfbf4013cd66437213c83eb673ac0388f655de142a420cabf8d18f033cb386779ed1ba7b4220647ab11d527af77dd3e6c1b754ec944b613db5019390bd2d52ebf7674a407bfcaf53bd88af112b0c01edc36fbc2d2baccf8e80f6aae60794f840125c8f08061f89e2efc7b2128bf04be63b0416285adcdaae153b14937b08bc15b7b1522e3fd3877b26173977b5cf980bf440fed7304eb0d9560cb6258596fee31fe1d693c23a12d6afcd86fb2f5535b568a4355677514649183313af34ce19bd266f545ec29e62f1b54c9338dba90dec1741856102712e1f26de10813a8f5190ce49886ec4d085859366379fc4d13b63c7e6f0bdb849b0423b111f1658cbef9a520b113d16be914f8d98ed8fe093eee154b7897eb2ad1c70f064a8ea26be17f4b23c95d251d5570fedd09cfce74f523f5ab1b93a04846c069159051ef4ebe9c7010e084abf1d86757be45983ad0b118c288e852d1552c0662c2c4e707c06455d6af417c2deff6e950f6369fc4d093dd67fc6f66265016e686cd7a67315b0bf2c6411ac55f60aae5501abf30e9c365e9b8e3119d2ec6d5c019a02399580c31cd021c56c356e5fe2a4c3f2dd0dd4dbe90464d50cb13060bd4d0b01d444766c323ddf8256c0bf87ae957854163dbb1be5ba02ce2c8635b3cf2c5c29d6a7970b5061891a608404e2c5adff985b39580a1620a83440b13eab712a7dc10b679eedb50b39761b892544ef2af08ac237e35a2e1af1e0e6c4cb98ec517b6bff03f6f269b978fcb45816e61875666c091e50e118eae58394621594e0c3a5ee8eb56ee43c20ee768553df3a451f42f81c0454259032ecf469c013851eb91e41963aa8f3d9b734d47a78870f999df1188e344b92ecb6e76a07c18b113925d985e87d0336d5ce0c37d4de140328743ca602c2fafd2ddafd5777510fb17ef88d0c641d19e08808d898688af0aeb14a57ea752339db5f982df7ab64a310a85eed00e45890b05a831ac9ec4d718c1911e8781fdeb2a24ab36a93017a26e2a9d52b870f3b15ef1f3fb1e5f26271730c82f6e91ed812518f8847d5480f4440d7ebb35e60fa143bc035105548a025b20ceba6414f32cac58cd54f642d884cd52b2d6907894d67daee125685ba9aac665ab887133e605d8a16a3e3e01d9071e1dfbcda9df590fbb29fad864c3d752529105547a0a2fcf4f1ed126350d3b645738d45677cd9f84061814468449397d9fe4851f00f3db7f3f059f6cd78ce95812ef6341f3c8222fbbbc200948cee61fde7b5ed2e048846822c8d815a2d65ee3f27448a70bd0f948726ad332855303690fe441095af85c31626e57b88429905125f6ea9ec7a6c65773e5d5a988ffff1e60b3bab0c28e8dea9e782bd8ef847107d3bd1f91f06684ca2141c1238e5c0675f4d7bee235729130f4f20aacc4d9bb5bb7601a51cffc34f9f602e84924c553fccab9d0206bd21143ce6be388ee7033e8c9d105fd6118a688312a4df1311a416aeb8b03b562226f0380517c540348651d759ad31e7b1ea4c0f50423cc26edca51eef25604599aad9872dc6ec99616b927ae3ba25ca7cc5462a7cd242c8ec2d83930da8489ceffa6f2c0c53581eb4c0d4ec7e10e7396c17e35ae4c2196b31cd2a71e03a1e73adc14ffde6e082669249ffd80a94fbc66cf60bcfcfbdbae3bdc80e6c42cb3b89adb1b811897b16d47c1abfdac4700c10ca16420c1aa7cc1ae462b4ee81d45148e623e6b13fd9e3dbbe301477aca53fbdd86d0e6c5769f2edca3a725241a38ec4f57c42d93242151aa75226799d5b306551e9adf14762c016f7434e0b9d7524af9a89d8f274d577143176c0ac3c9b229bd92b291ee5b471dc534b686c8d1908d6dac771a31f1efc2dff2bdfbe7508ef658710e9afff5a1db8181b5750f25803efd459f95cef8c9672c3ce8b86398a2ff950cef0fd4e28e8cbdb8bd2e9103518953b1e74d9ab028b9896be985b707b9edc02f516d5e8f4aa054ab4f1f4ac4ed475bbaaeb2d1d398a21eeba44fca8301cefcd526096862e9e2c763c086e976049196a84e4695ad4b550fcb48f9968e0d89e8eb035607f2e337a85694e4a348fabfb44da69fd10c0d93a9844a4798b73adfb0722f18ade63c390d53355b472cc743d127a394c91b7af309c9a8e4fd365ddd1c64db3dc98105d10abfc10430de96c38c201116e342d156e7b89a1f7385634873faf4fd397c2cc4422457985df9b3f863abaf357149ba63de01393e505b47f6fd6c12abcc8e8f9b987a8f3727f2a7050a1edaf3118cf23ac9a5862d7df8dc751deed1d01be1c9e93569db51fe462deae4562cd9afe9c9146c9384fa2575f1ae9c08339eb46e6b2ca384390aec0dcce21b0e63c47003b896ed5e112d1fef3ca7cbbb68847acd8bade88a1d4daf80136d914e0f69cdee1e3c064ba3cb5865a96a827ef1b4165a074bd5e70df40458627af97084bdfe296922776a84ae0f9fed140b9c075986df79c9039915a748cabb0e3fd462fde7583f688c79757cf7e4bdecbbd9e110f686f3abf6ac792611ad3e22ce36f734cbc6235e6f59a8c090811b8bd6d95ea89fb98abef143cb3d9bedbcaaf0e22a5ee8bcfd4d12c48d2887d914bb46c95c3b2eb7a34a01b243ea5bbfd312e954d92f765eaefbed090fbb2bd81ab5c86255c746df5f3cf268eb643707ab5f7f8bda8209eb4f1d19d761deeadd2201e51283be1b817fe1f9fc4e08d0105d0763ac112627276447d4b8a8479216ac836dd5f4ace0e5ec4557cd7ac18b751ef04cd9777a75cb886e9a7c196ccdb2b457be6e9e5ab6a5bfa367b7854a05a3a9f97b653da3edceeac77d2fa83e8789682ea49c64c6ee689a641b3814ad1656790f6a0e3161d5ac22d2319e3d87a8d0aa911c0e252fee9b615e87baf5288fd5f8ef4eeb4a8b98416c8495161dd5a1434c3035b982df7fb31ffab57543d17ce499daf3f56417a55d88b43a7d7cbb018e75a4d3d335cce55d60a694d849bccc75418993e3adb240862b8778902ffb0a511166305e87827734e7e4c911a7b2000451c09ce22614d70489ed0656a4899a3dca80394c801d51617cc02d6200c3bc6437f319389b4c14eff4f0d4b7fd5adc1c2060fe4a6e0c22ba71b73de4fae525286289de4e97cabc95747dc87356362bbcf5b879206fa7e6e08e17096353ce153e17e0ed603e9df459d872187c75da928e15f8d565aff3f4553c2771e648b9ba9bf31c7ec241ddc1b6c48a59f82339a3605de24cee34ecdb77ac95b1ba5abf354f4cc2687e15caddcaae2690917a7ce3504810ca6b0ac1d56dce09f172905f18df61fa0431a8532490089318131ce719789f882cdc4b961ad4b393b850fc35837d387ca53cadaf858ba8d6258dd04f3293a163f97b799a8790842853e8ecd594413172e98333ce71efbbf938506ee88c29d7ac985af603f95dd802116d51d6ee5a9fd4533d0e374b4bd3acd4c1f3a7ede1e768ae2ff521e90391823de93eca3175ec0eedbc98ec69700b04b477d826c41810d3591f1a23d283c49c9627319197850fccde82a0c1de80b1af8eb59e3ca8d963c7de1d553cb86441c146ed417b1a95374b8bba7f85c933e004630981ca64c21c8e35f60e0a4d1d83cd58c04bb09d60f83ab5194bccd9b665e428ff23f165bfd64c4081ed5e83c788e7d01edd28b3dadfe3e7cfc374bc0b5fe1117da9fe1603b3941399ea225a6b2397cba1775389caef56b4021813cc111272d42edd868c771735f69c88e03f1833ba51106bfb7fe0dc606ea0c6cfa78d349ba1029db38824c44d120e8f3c07559a5a598788941c680794968d25add75aef6f49adfb8c2e106dd66843a110d63950f6459c8f9900c56c093f83f6b1c5f5cb1a393dad836c013b5e46d564ce5997c1849926fb67ddc1154459a653caa2a5bd138b257ac45705b9c7522778ad22a3629fd23925aadd72fb94562b1ae011eca971eb09507fb0500a6d9ce1febb84e95729c42d1ac8cc831e391f442a4ba12cdbea64cbc42bf661ca540b02790d0662197239aaac612a5bff7a437878a5645d7b608eacdb098cf5aab5eff4c0346c7fb4add4ab41e7a1aa89dccc4cb5df1925027664d86b3ffcedf2c03f4a6857a6842af764a5c55cc0f445e8f35a4d13f374b8f904306151703fb2df208d6df075079a6d51491b0fc0e2a2ed51690a7d82e9deecad3e124a8758d091d0818e6ce04fc6540428cac6e22ad547f1a2b58bed6fd7745b207cabf89bf8d47a0301b9333a7fe1e5f461fdaa6bb5f76246fd775792668b9c0c412253f0fca01629d2228a9c77b930832ba5cd651bb684d574927c603535137bcbdb5d28dce587727dd6ff7a4f4a463abc2ca0db25ede11c20f3f34f6fa0b8eea2c1a90a6ca8e1aeb4a74d5d846d4e54a4b20447e505628c841000240ead368c8623e13d932b74d8618016a4cc64c854cc93cf9ad217c2e9d67dc4e7f0d6eee4c24ae11076999d0d26c3d29a1314517feab96db28513a85c02939db7b9c51eaa34431a2a39ea663b90a91e403d881fd3cd5358101804b20d00c70548b2cc3fcc31768828a5f0bd56d9ade445b58088a8c90948697b4a22c422d58fa521620ffab5329bde0d21fe0e469890218ea692a8f1a202062adaa78aaefcbc88cf7dbc5817fd770cc91bac2eded41da59705d33b3a82f52ec6c68625d5e98cb72e5f1cae96f7aca7a83dc0e9710e08e4533434193ae6a6b705755ba698c8ce520c643c1079720aaa96e7a9d4af6e48581322b869d424eec8ee0bad1ec6513764d4865d08c18950a8cdd6c6cf1463a9b6f965c7b9e5a0864c969c99447956c0083c02bc53db144f0696b91f14f033364710ea2189061bd8a017f01817d0dc989f421c0aac09f1159fef68c2a08c34e6e9ad8ad7229f0104cd6e74dd8f18ac8f30383e4aa80bc182a1c1f2ed98688528449d068e7c474097a55da76b2f0dd45bfc0c703cc3a35cc08821b5a7759a96e04d46358258ebdee065106244c2e4b6776c31430a2df9edac4000a0d7f921b750fc1066ce7d40cae7235ad614bae10d8ab1c4c8bdba13a8841a115513f0ca01c92eb82d9a853915567f19892cf74b348d87916b8cc89b8d57e6b09528d5c1230f54aa3efda3524d6a3660ad165856e4193cb6feb68947c923d86b29e6691ded04a4d49238512ac66c53bd56fe7503d221239c6c3ce91faa7f09f118b0bbe550a37ab8bfc12271d2cc0f90bd69c05b125adeec4211176714d849439b71b79305ac05a5c6dcf8de99c1c88d621cfbe13e88c80abca74156eb12f8028c6ab51ac4657b2482789815a8b5a20235b9fb82087bd855314cbb6bab530d374a04125aeff44eab89e1ab34287ef88b2edfc3562f08638fb3223899a13bf32a5f19a9443b351ad6e7bc8279219b40ea6270cd45b09812eabe071a2d24a639387f227248d0a1b16d513c8123529e0ea5e5618b79b505a65e74dbc4e3cc3b943a4a92c48730864c62e2aae4a710459423ff276e938415845621aa0a59cff630d4d29c404961b5778505f0ed25d5f179827073cd2cf3eccbc7e44b5a4ea86a8dd7a263f7689840300b6a9661884025c4aadb892adcd7f8ba1b25869f07c30b381966eb0dd7e171c3aaa9d3dcf6f07eece0bf03037bf8a193445bdaaf0dd6eb9121a98608c66cf9d06a9562583f1b8f8711d17f82c0b70862c4e5e5b4d4d3329d1ddd09bf6a1b8cf302518c7040c24d3c393649b09984b63b285000d2d65a7fc888364a2881220571811051066db7da57f2287875cd270ee533447cdd7a8af27eb499cad363bf1928a23256a99a67d55a1eedfe630da61d4a9e65e9063df38a66334dae8fbe7198f4bec1dcab984552e50c73b71416e7260587355492c56554fe3626f5c71ee3062830b772e936b6fdf7ef1535c3efc33c94f791e0b8ba43198c4ff7fda9c84ed9bfda3245bd15df76d87fc592778d15e2adc75c849cc49bc1925cc1c9b7c656c5c31c376d0ac2adde79d24bc5d40057a5412ea944e07f06eb3306c6e08949578d8863f72a95262e5c5b169810fed0cde0ddf36f39e082555fd4e2416a51d3b11a70d2373fa413d27afa5019ec8c1b7b4e2f3c9cb3c4b52815c7782eab8677f13d300163975e1aaa9570b60d7868bc8c132fc560f45d701977bbc74c88410f2fb4b6342f9b3b8b367e80797d9d1895c52ed9ab7d000b3883472e0805de62d808aa547b3a370362f45ce9e806079bbfc09f64cad71f40e912b822740e290b2ac7b2867d38edccc25e0b98bdc1b1a659bf42d9ec1e3184ab7904030fb3438666c125cc28f2265da25cfa9dcf6c6722078451bd105b8816e1660b3540db54bec09981af7e7dec9511e59cb3046bf7ca832724449089313d61f2257cb34cdeded73a43286ae45ab39b5c89902c1b667661ace83a1bbe213063b16fede3c82b49a116b720801a8e8543dda0ba9986ee0e79eb00816211d8751b4e2050fc844163c319b85af6f53d849ef1ea3a5e56125dc3041bf4a59b176c7a5db0fd0b2386ecb87654c5cb4073ba7cca2a0db38484770fd188f1ff361c8de0ccb10069cece0e64978a6ea3e0f8295a4dc515b3596daa7fab0b887856d5a2c31b058aba4257cdc0353f832ee5f0bcdd5be0b506578eb3bb8a21e93a6cb67a13db9819e234b7d3a385685fb3e40ede9b712a62f2305086274626c6ca07e28fed330e5af7882dc0763fa95f92d77bb95655924f8acb6fdec057721ec33333a154081ea28d697cc55d69c3e7835df12654e137983194f57519d874fa375d0eb3fa95a63e78b1aaf1609eeb0b61b2426892f7e5f47f169f752650e32b0386d141d525b714cdf1780199e1c879d3455085fe1174771cca528dfb17b7b4a046786d814fb51a803bee69a30fd01f5ff250415134f262845b5a8c3b2d10864a4550300e04d656f49aded3e0a905dbf0f2b5767277f94d66574018465db0cff5342c19d5c95c1473d7b5743e8d686017c0afe5555add49ac426417bc47788f6d279181901d322f578134dfe59f509a029719197643883f993f9710337d2f4a2fbfed4dcf8117c07a76ccf033318d83b9ca028423be797edc973685ae46d4cb45e0de22da285bdb67d267a7b2b6056881cda80eb9be0f52543966fb2fe2ae7bf92555b14e69c35924498d2eaac975c9ed6625ba7b7f41367f044ce81357b1ca0fc8fd54a5e0089c7cdee599cfc3071b19008ebbbbb5603f818f013ed8ff7bb8620f513e97211c622557731ab7d2aeaf2f183d2b9705adc3454bf58b9ff8662847ae7aff3a475b949655bbc2afecf52a83d250ba842daf7a216dd4698e10c294867640f1413b363751c18e05511a2d0a4d196a7468b22abffc55f77d106d0afd2a43443dbbc9dcec4fc30624669181c75e78726d41a65e7661d154ce76c88d3103697b8775cecaddbfd47ddd88cec7e10979ac32beb53eaa416506cf294cf2fd6e4f8432cb1f1457f4f8f7967c9a016a77a1e24ee1c4e6871ef62ec41d1de2412a96c1652190d747b743f9794257d1216ffa9dc5235afe273f32392dc862057cfecb256dbe00b2fc3d1e33cc0e95e5252aaa9760e7c393b5f3082173f6f4fbdb1088d031db5a749ce1e89dd750ea350a7bdd746fb0628699de8744e51a0feb5a20eb2b458f923c3ec825becb5c558a7865f1b2bc92a4d8b1aa8b83aba3610fc55f3c68a2a1dad5fd222cba01c23a8397e130a6bd8a1a51e334e6ccc2523b27d2808969c764cb13e85a127ad2ab3fb5c5429b0672b12b53910b3d808db1c88462655b986abf85878ab7ba8d7dea3107625a4ee62e98de4e0df8e4eeb805b75065e87c8af291b784d89e9f3226995c795bf44afe31f5a91c8290a4e7334327d31f2714849eae5718132b487046aeb3353132e3b8b08768384d33adc9217265ed3bdb92212d3e896be4ba593da978d554c14b5a0c6c24d980349a74d6537abd5836e8d4d81277530fc1a0fa39b93f69233e87bbce392010e9ea306b3a50edd3514ab0240c38d30b1f31b850fe02d2144b3d6efab60998f2913b941548aea68160dfe10fda8a6c9527010241ac198aa67d6e3572a321b5bf0907871db566dc763902c35745cb36eb7d69e4ce502cfed66a3cac66312bd82a7fdc09ca6f06231ba3ce7066c678fe4affeb9e29cf02218c9de55221df64e396c054ed44b0cf503e3a5526145f14cfacf723d89616f9a323aeeebbe2e8e15f86173cea44a8e314e5ee327ff0cb4b3924c6448f76d0e641d85c25e66c987462bc8074c9ab1cd25e70d13c7d0de6f4f8225e869435e2953ed4aa63854c6ce5c39ad3b7e0eebd553a334da79ce2e9e69483163a2d1ae8bf56045958b43a5a8c8956b6a17287a9c042683e5f857264c61c80e3947ba81416a1aeb45a872913af2ec325332d0f0e9fd4e36cfdcb1a9ba0d3c6c5ca192eb3355cf8b0de9537445098b28adbce7e0019f1ae76825c448d760d574077721615e263d5094b18f941b507f1e37548be6288c1edf7d4c6ebb57bffb55f77243404fd75e84e72d230bbd1d4a20cc7f1c6920f9a7b591bcebc562509187c1133f3469882ae023dd3446972bec6a497d4ad3317b1612733d7df13eaf47eac2bb896a6350e94e623142511ac27b280f6c717fc98fc92edebb95d189db0d12387750b2e552cf6aaf8c165a791e6e99e518dab2982776409b8ccbae7fa408218072e6607cb465274e60adf8334a3f3671d89c6869ff6f1eb6659247097815817e687177026a96bad0b0cf62e2ecfc03c15d636a18cb7668e5adc9e1d5e4b74a02268e901f6767b467a47dc73d0c2e86bd764f8499d35e69f672841fe251f38e1770c28227ecbab7b6c6bf9dfbeb4306ebf252eeb7cc8cf502979627cc37ee4f63db9a81d4fcb39ee09212dbc525cbadb80162d1b9659adffd5214eaa32cae1fdf284c177f1e92b30a4ddd0f885125e80bb579960674951d42853bb2c0ac53f36f93b44b700b6a88eed4d8338f2ac0d2b7d0cfe0b764f81eb6745256ef77eada10cf23ca95513b4359b8d35c8e6deada1cac22425e84cc02758b9b5703139c6ec8397f0c5e8443e520aab3c430081d96d27eaeefc449b431a3d181795a44a4a72b4372fa60856ba20e763cf74a64c73c4d955f97e4ff4811d6b7bb8dfcf82e7ced8e5bbcc9303787c02cd096ad53429ac51318c2580406b70bc606e42ad4960bdc58ffce356939e2bcc39a6a1a48618976c76a6d36ed7df5b8c88e4b667d4d782e53c065d0ebd68c57758cc6ab38dc1cd5125fbc25c7f225eb2c55c4e9a0d750f1b668bd6d880694db26c4771722932cf392abca9e5e039749d0ee479647d3442a4baf47179c5cb43b941e75f45f24a3868c19a5794d4dd8ee9dcaa8c91eaa6fa361d0c34fe8b5f90375a26ebf37c2aa63d98eb0ac989b74e55d8b10a665e8e8ec563c61734ef7dcd7172b3e31ba0a87cc2b2294a57df45f6b4b635e6f8249678248255f68feb4f7333a8aa6fe1c104e090965a0ae5d2e97430611ded18991b28f6b25ca5eca9cacdee12523e7b58e6893bb9e10c083caf3cdb57d5f5e93288b1665a4e0235e5d1c1466ab7a70ab1e178fd4cf7e788ef2bccb13a23e36fcb54b7c874dd203ac2bfbb6c66bde49444885b433fc2ea708d5b4b91950722df5e368ade93397581c7a5d51bf53c469d4de7d8e76a7051e5d51c7074db77a62f326ad20f9784b52edf355796222928cd4db0a1e1b4813d92f4f379baeacbea3396d18aae593ac7813a9078f53352dcfbeb9c39c4769aaa5c208870d01135ee1290c0e5b014d77a786478c8a0d763f4fe0cbe892eb4a8e1fa76042fdd9390a0bfda40da40b47900bc86668b6420c93a9f01e13e4b30afe6a067efe088bc87a10f0ff68a091ba3320156bd874b0f9dbc9540b0b6288d943d3d195cb77a7406e60c376288fb440e0d0010864acd00ef674742ba39e7aa5b4824e1db89f5791269f3919f36179adc53b6ae6ccc37e04589e3145bb08ce4d04787885d60f87635bae9aad50c66cf338ef0d43a7854c166f1d57535de4b372cf7f7d9aef8ae0c90b55713dc512a1e4ac3cceac0378d67181ad8bb43b5ddffde8f6bf714003858c3233c10c397bbc554b1d43c01c3392f3c67f4571bcfdb9fc7d2607887261358942ce598e00d4c2c9492b048f3904dd8a58f5bcd527890a640eff8d6892af462e6baf6271f354b6c397f7d921a954bc4350d6a33b5f80cf5ffc9c642de201427a5b2ea9137ed4f874b2fbc6c61af76191cb6713b6172620c28eb83ad4db779cda9d700a3ed3a62fa19cf3e6a1cb84908cd079cff018cc38ab047eb5cd354b49ef21142e9b9b825d12e74e4a17256566378caa7f5729aedbd603aa439c04a892d21a33f3a906c0b8f4d9ffdf893dad203773332ac71af3133dcaae503319160c4fbabd538c6e053171190e7a951ebc487c528e6d2cf9836e821f50a4692fd8a732421dfd9b0d9116787ea2263eb167e92faa96503426728b49e5f966ebe8426fcdccb3ae8713353b47d76a21d269196697418e6546bc05cc66c396adc82ab8a26e8da2ec63030d01735a625fdbfa890246d645a96dc7adc93bb614729bb862644f434f610c10345f75a88803fe22d1e4697b1ac756065612209b1e4c44561cc6816bdf088485a0ee726c0d0e397668c20ff4901e27cb0d6a5f0b489ea6ba83364231eeab7067881595f6c59d8447a43ffe7f4e64b1654d67f70f437d9d8b1c4239817409c45765ab4be5b9df424285184f7f191a0692f56d9dcaf46f18ab771eb78f8d161fed384366fa0c4a4ef7cf9ae6d66447e2a5df31f7a9857a9fdfe3e273033f48a625e06d3c9772e10a47de940793a4e3ecfb2d4d459003d4702aa7103e0a7cf70682a24122d0b05d3bf79ebc24b1fc470269b624bd13089fe1031fc2e8afc34f8e0acdc818b459373f3da258e83a74d2d85c6c1e2f08a90a9116106230c43bd04cb1b7233853dc487d14c559246b09ff8b43b1d004454172cbfed08bf0a7946acc436862d154b50cf193ac1c50ba24985ef476d89223fe8493751b62bb03791e7bf0908e0d5e24f53982a95175d8ff23562d878dd0995daecfd0cd2e202ef31e58be2556e2d1044b9aaf6cc318503ca71b4d159f87693f09bbda8874157db69c8a93c153255b9829ec674dc93c24237c33f78d0e81bc676a242547f235827c0cf1de208ecf61ee5bccb0d0bf025d90304a39787b8866022bcdc6e08e6bb739789a908956643bdce1057ac0b5ad8742b8c48849811ff31941865670140302a3f7894876e5a4848463a2ebd014ead02c91fe50bdfa2e3ce61320c326e1119d913138e73426df4122cbb1d333cb22a2117952ebbfeaf9b78de90df8573d4c411a1ba42278df32ad1637dbf72fa5b5bd2995abf05b93847845c895acf1aacd192e2d2cb81dbaf92cf76a83518003a71214a244f4d663c1f7f025eb4592df079fa67fdb1a25b9a810db3a5189dd489273995f0f001b60af94735922ca349d1e889cbc8475339f51fe31bd482bfce7b95e66ea11fbbca071f75212ce9a9b5ba1d43bc4ba51417164668eb32a3fc26f74f6c1edb797d6d0a0dcd0498fc9261699584524e82f981af53d1df3811bcffc80e280223163b1ba8ff5057505bbb59e1f6c84bd218aeda5073d1d3fa382ca4b40e2b48b8a8cb46deeeb6f31c0574751be496a45441f3a29887af2d715fcb83d0eca1aaa9b5241e8c902cf390ee080d01742346aa05e28d852af35a6becc1dd92fc964cde68ada1101dc5ca74c24b8b05d7d56ddf12536fbeee4e5c7120f3b8fcff901429d7ab56ff4cd40e6be67487ef36a1c4b8b8a7aa4fe729e39fb52016fb9b993bf73654e50f5299d168650066ac795e31c3a664846083094b793b702d363e66602f075e5109e891795a59471a9bb87d7a7b8368159292ffaee82cdd71b72ad40681ed2855006388e3104e6273349db56e7005da4411b9204e5acab28c1c49401847af1b9d5ef37b5a6c80f15741ae396b781dd8bb3f6b04c0100f925ac28a455e7357c6b714e83c5a1fe669084fd3e56ce9be3f8c1c36f72934b902a105fdfa6c2672b0dc8ee85671fa89ffb13c20c580137cae59c322f08292281cfd55d9fac9b082d05653e05cc515a42c236aa891cc0f124ac0b5fa8572d27c79ca6c36ae7ef69f7989c161c72dbd75a73fad1589f2877b87f329a9062eeba9865c33457f4dad4e9abfef42f5e970b0e1e7f515786bd11bba16a3e04bcc0e1e3d8f56784968c5f774d85c961438ab153211008db648416ffe573bf8cb885656b185b8928c874e6bb0cc4dffea3afa8b17d2737d1b37d02e960c0abc39b9e0f6cfd1f080e45aac6c6e22ab0f2156ad0895bb9ffb9ef58f858446c95dc214394f0cef24bb4ee16317a93ce0fbc3e50cad2098033209827d7213145b8742e68ee444d8fad24cad46cd51fdb2ee538c4d9d2fb2ac7b32ebec9e473317d9be94427489d6a5145a2ebf2d6fdc5ed4711b668d4c7f545b6f2257211c2ea1af012a0b34d95c7a5397b731e86560c762c52c524cfca86b50638924102d42b9b93e33230e224bc78977891345f34dcabe144435d87d06317a5dde418769ee8408724eba0a5134b20a09b1c8fb8be989fa59a9e2843078ef8411bb20dfe0c01bca709c5bccba9ffc4f991d9e7d6b191501bf252e36508cd2a377d206580a16c4b4dbf4aa40df06b45eb0c2c69b2a819e9c6eda96249a5421f439cdc28212a3c23df53e0079fb048142651f41f64191de385de5847624d03b22996ee27888cdf1bd0f9150e98f248a7a7fcc807eef7ed7db517a697e9b62d20f15a0db6a50905fcdba712b5b0e29c87672b02f97158d955e2460b46325a6cdb52009c891e7cb4f2913ff8c2cb6057e937c57e6f4419dfe8132aa8a2dea8f91a820f98aed1d29a681bfafadcacded38a7d2b3f8304cf86195863d433a0e1cc056fd66e6cc2a94858aa8fad072b3c45009d8d4cb2493c017c1d8b6d46cd0835fba9c36dddda1c858906ea9f06d79a0c473bb7ea21f66bf610c27eb086622e12c43e56222cfe1222c96cb77a14a1134c8982529b37a766d2e29702a803b7da4a3b6ccb8efbe58f358230df01d39930f08cf4cbc10fdac1bb5c597a5db702dd2d7e3490e9a3d62d12e08e29483f57a59aa29c4f27ac13daa470ea7aa9043416f9c664c077532fc01e4891c33e449de823a11e1d25cdca15a971092b686975dc620c641edc2a26a43fb970fafe0311ef6cb90e268916bc708cfafbe6c7871f5ca7e574531db3c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
