<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fbe9492a7dbcb441ed86184eb9261f66df41cd6cdf9cf0c8a056beb7f5031757f7a506386a73902858069d81874640448df09fb7c0fad52c7be334d1bf6a63161f97b755eccf042faad6ae6c37f1024fc0c85b9cd99f5282c4a421100a011e316cef7f9949954e43f3bb2582e515e72a0f5a0eb50ad6106538b2c5459b3ae27386dc39cb162d9929b5bbcc8e33e7a3b8d725ed1239bdea249efdbf587d248d1f36e03f0c923305517443d482c794b8cacc9ee14a7a8c0143f1bb498db4755b779d4c9326e2531634f3e7c651bb9cd318a49a17216d7ecf9786a03cb33eb3cbd97a4eeb494088fb51030cf19d4a5c56315ac6295ed1676f6118c7bccdd07ff5128622be5ca8c94039dcc287a1a4d40e77b0f6089dcbb6563e61b1325022d668c55437d5ba848e265baab8adddfdd7b03abf52250d10658c28f8385d48cd25b4b86b1d5c01283babe6e9627315ace0323559e93da8908496267666b0b233d514eaa39f59280d0e969d9d55add0b4c0022e0f6320d0f0df191108e78b19a9df274185a91ccc888c5aaf95e567e5ebd47754d985eeddebea9e277501fafe77c1456608f375d33cfe30566b976275aa70016c3399e64ec65235ccf50829525e92bb8c2bba24a2ead8bbe84d4d224f09e4a77736f214644ce72f4a5c7775c59236874d99f7a4532ef281e0cd05ce9b3c38c7497f30fa031a1ddc10e92d62ec66ee0834739bb566ae759812b314479c3f035c9edb350294ab12904c96496dcbcbc4f6e19068f020912d0abb0299e10e15f89fbee491f00abdc569a24843948ba5b180457ea91e64274cca8a92492163482d7c867495560bf64c45ca139e63ca5b2f49f2689fde007bb5e3119db9dba84fbbd9fafe6bfb0af6ac37784da148eb51c4b162f6a42a7825be7be8f9dec9ffa82fdfb4a0167d587dd6c36586410e8d2be41ccadaa71c581ed48191f55c20b794e0163126b47b00cab09731da1240b7e321d4844a425e74d8b249180f70675a9dee421e42898548792fe107b6c078ff7edd9447445ee65c13868a04b20805fa7ef2b87c3a2c15db83639b243b5f589a22b28af04d5da3d6bf5d66fa0e888d3722903dfde172337340e731618c3fe1ac0e6df6d6d3024a8c191ee88442d05fcdc8bb50f32007397ba8518682bbfd6ab2229660e751081b77f141f690161ad721e9786b37236cab231fa6bd4e6900f64cc7a1dd4ce37fb4441426c684a64d6266129a8e5fb6c5121b1a4315751508aed1c839a5a498eb68edf59a5f1bce3ed449bd240a16a036b07aa2d36005ba0dd1781a6f50e72a4262008d697793fed7052dd7bcf34247e717341e1cc7dd7122b501306672c9720adb37a5102723e8224cd46797d02fa86a628b013b5ac4a9ce7319f45a741c8870045e6721d9b372fb295d82fff4fd7a8e999465bd055509bb6bc9f0cc921f3d0a8a9b905492a86fb3483ab6e22726245fc41bf856d2de18c21f23aeb719d19acd016fb9e75dc13b7b16287fc4cbd9ff123aac693d2b15606ad5feefe7881c2ad1f9b93c2e69c0a001124aa96aa161ccf372452c644b985d32a69717bc1f17fe83b0cf37da4b0361ce4bd989af332c6d0e1971cbd32f20ca290a7df0eb83d3c962b0e9116bd90a1af7005adac4e284774e6af25379178ca9c4be9eb37ead79a3cb0a14a6d6e299a7c12d2ffebb080ef0ad3fced9911424a7833bb3d068603dbc348526edde3d169b8c111b8b0910307115ae6f757d06fcd59ca4741cb524b9cf6a8adffc77b7efeca48cbe014b5a338c96511e119c81db219cd5588f13ca1b3868f6ad6b814e9fbd10c55094bdd7f552875b138043aea74a45fddb2f7f6fc563261711c1af176221bce21f0f5d9ff870e1ecc70a20f9b28efb9c602d104c1ba4c02c31b8f36d5bfd53c253812b1ff5a59e64bc7c516a1e6a4475c6465252c55cd54fb060fb1d9b7f73ebdd0ee996651c18c0e80018b207cc2b607361ca42bb078012ff95e780426b48520968561de3da423fc799c53229262282bb0def30aa64ed25ee6fd67789c8872712fab64fb822d27f951bce42c7502248152fab501d095f65200f222657f788a10a775dc8c09c9a0908dd4b4c947bc3bdd8293da7e3b9e20aa4b9fd20703d2a69682c40c70d784897530b5683f51576c88aefcc901e128a6d741f58032ffb898e0d408e9b681ceada7935b1c8ac81ad6352f1ddb797e728f75b279946a658522d75a8ba38944d5f1c0990c8d12d79aa2e9f060d3f1ffc6db845342b45ee3a8f515e71a048084ffb955e7d574c1bf936cc10ff2e1b1c7dc9c576be1670b5b6b15c2ff5cb8a023caee13ee03695713f7931555d03549690f4f15d0f600c2afbd0b61ef938efdbff00ac7263581fce745d8b9b9f9bdd1f2432a70bfae7209384b27ab6806e4e8ad8274c85dd2318820eafc01bff83110af00db47ab2e21e11bce163ceec7fd586d0e15ab6398d209f6e7c172903c779e8a36bf3aaad75cfc0dae7716627f32f95155b16d1f85b0425d48c9ea36123870f170c8f35f8046ef20bd54ccfe2cc61142cde8b162328716ec54a2a71fd03d3a3a3fe90e989ec3d32799cef0f02d6dd3095340413890157a6de4a0d473fe334720c568b9e42eff4a7cc10913ffdd25027bde321524cc3c6b126f89e084045acea7cc212e470a17e43738708a9ff96f74cd11041a194084947982f56b1899b583ee7addf128c2ac5d9c2b6760318c117d7b23fd6874cd52e8e03ff7fc88649a4252831e39dffe5433fc52beafba7adc83c3808729e8a700438afb98521504462d8d2f1c9262c2b275d1c4b76f1478e95f3f1b779464b7397a93d6f94395f014232b4f7086deea96671e1fd5a59a52916b16c1c29496e142be6d6cee8e87c6c5c0087768d169628f796cb4f04e268bb88d4d70878f7cffe4f8c3686f46df3f24525cb30dada81f4fa64a3df3d299e082637d582e07df51ab2607ce2359b36274e3e427c07e397bcd5088969c42e5c9465a9aeae17b577095cf267bd608e4d2fe2eb789cd53cae90902bceb96874c7e98dda2b0b3d310c03b526e9c095b3d39d0a35d63670b3e2b55fec53e9e1c619b3bc589db3e267fb61c518bae8afc7cf7bb1812ca20c492819a949faad57b1c5af8b96b5feab7fd246790de665c3015468cb9d745b7980869d2fb2f9c9316205927c2bfa61c0d5006d23e03417cc64accb3b32c3ad6ec9e753047710c63e373cbca2b6ad970b76f0665e3cb877e43c75a1c822e372ee2296f49f461a794c1cfc77b07f21afec43f15741216d3c98581722b75543d531d052c93370836b688c25a157247d911cf1c419d031192e9cdf7e389ce812f4e47a4eec8ce313c15d93f420c16b6680f158995b8080ee1442350822089c9ca1c1cc0aef7dfa111604d2152099b97b6e78e083df49c2b8767c37218951a97d35236005825224fe3c044e86b90b905ae8b6ac57ceadca76b3a28ddffd50c0b906a49b49e17238454c8cb4ded1d162f6a388f0d001ec792e31629b9c11975162ec7ee8c4bba6b5fe6863b687a0c4e03c521092411c3aa5410edd1c9d588854884d42716454dfd85b7dec451836469347150ef12a96ed6c550129feab4ec025f7f05dc926ba90fbae07fb22726749d386e663739bccb48c806f5cb04a11a01eab89be7d5a2069c5c1ec5cf887d5640958dead645cd844b2d844888e6b8dcd7363199e52e06e357a54fc9fb3237aab1b348b6b1a47ae419ce328fcb3b398c44825c9155f2c99c8bcfb3c2041afc6f4fa0b749752add4fb6c08490487c4dc70717f9c5a27ad9bac84044d16bb1f4f43b0e7ce39c107236948206b1a316ba3a0def2f47138ec2da7e9c635650ae94c1444a21a8e3f18ea7fa55dd88d501ce0996e38ce95e17aa2f8e5d42ad1d6e5c6d959a9f8b4b2b0ff57378345c1b309f5bfa1f6ae8bf7490179c4cb5029ef52c03245d934a9cc248d2f531acbc4a3c9db0cc4278d28ab705033c7640915c46d4bd8a57c84d0fca51f5f230908cafe19adbccbd340633166015197ceaf9b636ebd3413cd786bff50247bd733fa92b0ad065200b38319a1cca6f0b5662be2198ee7a50212130ae877805a5877f113480175ad9f18a452ba3a8fba1808ad839fd3864b7ddaa661b3f5b15edf29ead44a0a6214c5c1fbf6ee9860422ce6d4dd25669778c27e18603bee264c7881c3f63de8ce4dbd5391ab508e5f295bb7be4aba928f4c299479a04ef299fe3a663dfabcfdc5642ad0a353d2e5625409db2d439ccfcb775a556ef70a8b0156a41bcd2cd530fefd6115e1eb5b2a4a9fe87b6810e3c64d9903f9f2b7d1126f3f45fd27739f0111360778a67ba469a8fc8b78fb08338776db9448ca698ec9b3ab531210e7d501bc89cb9f54506ae33a68e3420636b719e8b790090a20f789e5264bb1e3f8405137e241e361afb30f9fc38ffc9ae963e7f6670bae73ad5f7bb616983dd423c687c274f371accdcf8f0253124426ae7b4db08d6a7be915b88bca4ee414d49a3a53ad6b811de3ceec4f518017ca9453a3700ed42fc647577af94667e11c084e069446a5ecd817576e6971a0958166f6647931211afcb0e1aca4e95c9bb496979f55653b1a545a576580128f7ae86149c8dd5055c7f09899bb0312674ace2197633a6ac238fc6fc4909222051d1b4cbf4fae9351adb5c1d963ea953096e2ddd6ffc1a07cbbd15aa0d82f0a9f989d64a37c63c7087ba5c657cf805eb1e5c0198f8cee89e9681291b267fbee6053af33e789b9e57d482e8e299dc93b7f1e2826c35b740c596a2c98e2daf5122f2d2814d46b66273ed2a6939d806dc90c04d5fccef1050de426fd7d5314c2f95d1726d7463ea4d432d87b51941622fff07fdb7f415f4b9444e5dd4fe70d50a795024df6eec75c577fea3755d249fb2ab97055a7d14be55a1cc5be21b087fa777247d2ebe2b3d56ed74f9400fc2dfe0a4edd91af10c986ac590230ccff87508dabe924c9b08154eec682ff0498de36acb61e15e3d70e4d0c05aa295d1b886b377aedfef8888ed63617155ad10b9b1eb70488c474b02e1beda989f2cc1af678be304cf650d511eafaa19947d97628d55c849d397ea80031a2911cfc02f3b0b9fd20000594ca9f4540a138340a389e63f0f707b90c8fa4b7a54903b067864783201962eaf9e2525e60e2b4cb0eff03fa4bdbe144b059fbdc7b36fe7f374b45e8605ba72e9e39abdda1ca073c7e911f4571b12e8ba5706c0aaf736629852b3c7d3f463d6443b3f389055899a894be9ebdd03c210846343b76daa0318cef86982a9bf3e9b7a75adab17fe5b0ebbe180783bf3a24c0481afe22b1bdc15d0a5ecaa9e30b175f640d30534937465c8a00d44bf142d9e33f829fc250cc185084b64a48a1f455ae7799ca9878ddc4d6ffdc81825b79d46954f784889474a84c71efdf69d04aef2c6d6e59ba0edf20a5dd3e6dbab2303ce53bbce4cd428349272ec044fc67c394883dd7f276b3d2985e04d6d578fea342b78679751d610890c7d751af7113c700c5a24a466ba7ed6aa18bbaa008700fae2e6d7168826bab43f6f14e9161a39d96c5b52b3404bb4929ecee06a81ce90affa1c3d0d9587e82c248af43a8732640ffc50f7ac23faad6a88c0ab576c41542d45bb98fed32f453f0226b9fd40b28d189a6f84391a889d3985a8b820bac98e1089560bf903ef4442eff8d1aa50b9038358b2fb8dbe6f767d17e0a933a81e5acf47f6e6d33937203d56e35199d6a74c6b5318aaa85ece2ef014eadc7646ee669acf90b5159c71110b26f36b5123093fed6b0c2e1e3c1242292f5cae8cd6c38d46e4cb184877c0cc23746285987d9c36e4c9d8b5c757ffbf1151e285e65286b8d60e5adb7ed5f5005fe88a1f16fab3a7581eaf710e57d7b6cbc92458076e7bf7ab7ab44f77f5e8551756a2a3a5fe265637497eb6c670a47b693d9b809eed0bfd4793595c27861aec7046a9d7cbc21bd31e8c503cb2c4342ff83c814ac8f20f2ca60eb49c42dfcf9b31d411dfbd64d87ec16a854a7fd06146c9244146529231a8fc1c1ff7238632fe07f563a703b80b7a8a6a7bdc6e6f139b2479b6e363645b3a1279e183b7246fa60773e536cea8522a58b87e549b878105b65df9885ba5858797ca236fb86a654a36020cd7f2180c4fedd057f9cf061bcb98ffec3d6d21aad2f1b7096b6dffe1dda3114ddddfea0152e443d11ef6eae3883d41a995e05ce5fd09c1ef68615c5f0b15ffc279a24b4bceee2adde5c9437c5d4befc5fb6a283acca972cc3b404c09060934383ac05a8f10bb125bc039d72ea8962e221ff55580f614a3021075f271dcbe531515d4a1cd14cb7dddf6806e0f6713086a5d3c1bd2368e31447b27f7f9a37189e1b379b038179936d9a48ddea99cbe1e70c9823dca87f8cc78b8b7b3b429abc36d2f50d49730b88ebcc99d98ebfc97184374c94a4bebd39520517a073e532853e5862284ffebf7d31af1d639d9e548b58b748bd3a70204e8458b7f405dba9a87753d4fa0b804acad242c030087cb6b893954e8f2eab83d33bbfc64770b6c822e8bb6acbe1f41a86862b43fc598bcc23518ecfae7564c96467d68bd8d5b10f8f80d029efd5e842075a3edb6b296c02fe22bdbdffc81fa3a2ec25519f7f45bdf9b942d3b02799c0489b7c46f711b413f86d613080e16b20a6d9222f6079e7ac76022d667844e85af98f498d4c6534a8b1d193f56870d298f8eaabfcb0c888ba62cca3ec2e091752ea5aa38e4320ec007114a8ccce73b882e5b123ce74c1b8536bfc710946c03c2d26f48deff7b3daa5c3fed131dfbdf1c535440379cc76be2af91e4b0a1ed65db2c9fdc00e98ebac38495c09e046937184af91a12fff20ca89f1dfbff02a545f480ed0871e331ba582d4ba31b3e984ca9a06ee35b8abd014a5ccce3ea60a468868eceabf043f2ade89881e700be318803ae65e5a60be16b2429e72756f45ec01af97978b0945f92604ec855fb3b34b1e0e1ab004dd1105bf44b2cd720a640c7a85834b1d967c063e8304a1705909a5303010dd3f537312cf047c8f07146412b2285bff68662165674100a6c5f19cac985b0b155efbe64be5cdb499fba0cff0f8df2c3001d8f0daa500b13180b4c207460123340296d567df6ab66c2bd8a8d4fca72f8e0458bcd2d2601a81a87611d095a8287fa987dbbd9065054b95ee09f05b1240d58240ec2d3fd8fde2d554984c9bfcd49fa93815468c792b4d40d825e4f1590a2c3a5ab57749b20e03130728da4c3612f48d1054b0ccc7a2af5bfc11f458113f385617a9ab2f7dc632b4ae9834af0f55ac0bb1512d4abd99a04a40869cf76a23a93c9386e714c593678f2bc86f0f5480013da8ad96be08215e65cc6d1342b939f59e9e91e77e832385024228a58f47e5b1cb1d483187dbba88d71c747478373bdc28983d7f0b916a0bca449d1d9c00985a54070d8859c48b99e4415be2d24b76e6a53e6c35b872bf6c2052227c6aece91f30fba442de73ea45f1b6cb15888e00b5a436c1c960e4df61b1d6280c5de2d8de50d444009d87b04852654bda72815a29d6b0cfc2a55dfcde63ccd7e86665ea93cc11e0e964653f793ecfebc04d5c03b834d2872fa33b7a90682a8215bb01062cfabb7918fd017738fe08380fa609525f3172b3cd072ca48ae6f62de76c0850f297c28341764adf69c45ccfc8961152f6827164f52a125d7d63346925d8b2cc93c08838e3767c5d8b1988f2b452c838ac72b6db8d888e381ebfbfee9fb1d8789632fa7d0bbf88dc43ab99a2399e2adb18a1c9e918896599223f39af90c8ae2c38ca06a0d2880e29fdbb0f75f5d6a44ba9ef1777e5496cb0936a86f22e91cf24d9b87ace11f53f4588065f0643e72f02d83a88c01eddf96780115596d5c006f46e1931ebe881aa728cab433924efcd082d84768436cabab9b66e787d136db36c8e66b814d8d25437370fcf9e087033505744d1be29a45383106e2b1d085a9f279f8ebb95bff870dadc334bf6477bebd55493133cf2334e0ba2853bcaacba291cb47ee33e3536c4042b80aa5956fa8c2c491a4ae49c0c24fe5784bcaa7024a7b326b3a57e88ce710780af68ae60b8c41da9b24393bc470c18bf3f626a4ce6e3eab19d4d07ac951c17687bb8a68815d129fea91feadb90a41bfb17637ed6329b3aef329d17cf50f1172b2d7b47de4d603ca4f0ff783384ea09fbfdff488d91930d4a6c4a0f9e780ba7e6bcc8ad6c6f03007d36fb14e4fc9ac762a2a34c47ab24a636a6d12a5e18f58724e598c6503879dd3520d37eace2c9ceb12b0d238fe53f5d56e36875a276bcf037f8d0c844dc95e9b2acdce58d427a2b93cbe16a63326daebe32ae3a749ed2e54233ffcc1d67e738ac31a1685b3effa7a13296e68937c3d0f0635cc2d4de5cb0d8d71f9c398316830f2e33e913721e3b82f11e5f6b4131b56be9dae9c2f4ff91dc175db2d74d8a9ad77e5150ab9b209cd771fff011ac772877b6f8e01874f2ed90283302145ed94a18b6b43a105b394b6ab52becb2794a5b66d6d5f7fcbb6a42c696d72ec0ad30a4860f93cad21b7a22f56dabfadbbc4620be26e102a071aac05580c67254af2caee1b0fde361776136603c50bc4d9611a9e2ea1d7a3c1103e5c9812607ed2fa6eb1cb802312affb2e77b6ae0bb1e3de11cf6bf07b43dfb431838a4cb765f00c69cdcf23ce4a9d904ea9bbcc6f8d6840e042bbd13435c1cb12abc61f61bb7cb90d2729c7641874acfb14314e116c8224d0b27a8881186ae3cf3e32d3c3225f9105ceb1a60230742ec28a108cf342e5188c85d036174b2f768324e6044667bcff216110be55ce887595fa715820186cd8f0a04ee83ac86e45fd467018bfea90f3fe04945b06b5a2da004572cf7b71601f92aa03af325c6d0b3cab7ca822da675489c60596ffa2c1451ed56e4259c8cf7a60fbe55ad4314a3b3f03a648eaf83a7a29bf907652ec20c9c677d69362cdf4a17059a056070257b4f50c66f4c91fabf7a1b7ed68b81ab17ebc7be3d726bb551104d6cff1567ac5c8907af125369b4c69957b06feb152192941435a0bc45fd0afbb55d163f75cfe28e1c2cfecdd32abb84e09f73f8477a33d6d54aa8550d0eae9602b514c3648dfe5ec764f2b8ce0ba3c16c8d6a3ca1fa32e1ae18bf9f6efd0733fa9b88b0e31881514147fe4811136abaf40a117176b862f11791c81f12c703697bfec7c57b256e810f128c5bfe13a87e014e83e8b0e3ba318a15ee02b6221fbb4b55e63f52e2ddf4302f87ef1c4bdc473251458944b8a4175e217af6e5cf12d74cfde7d1daed52465772635a44530f96eae4062bad2c4ab6f8fc7adf2ad3ee7bcd93c0b40735c1925b17bf4299d61274a4027c9ed36fb6e93ec4d19554e7465da1637d6d9d974dfe793d36b73b11723ae1630650b0bb587785def610538f3a6226050d52ebe8fff36602d1ec7b2cbfee85ffc56d903022d59fcfd281f4d4cae9a8a1058ff20e58e82c1313d4255a156c1774a203bc4ebe4482cbf89d3e1878c5dbc20994ecc9291b31d8e2f676da316c2568e3a0ce00875a16790b948b950a9da214324fdb017e952a4d2f6106ba9c9dc82687801da9ab537d1f7ea3ab2cd07be0dd57e6a8716bd7596fbea85e0a147d024b9d1d98070378ac1995cf5925d31bbcc4344d10285bf11c9009dbe80e15aef9a652d76414567abdb7cc117962b42616ca6e7cdb1b037fee91a8324ccfd412727e42d30b1a63e628d444f027c9c5ec589d380ccbf4c636457db5a260b5a09be86b5965204ef3d9f2ae6f2aa59d682640ea4149d3a0a83a49e6916b065cfed43878d431a6a1c8f4f4df06df33b33fbbc556e8f8684e6f187bf86b92935881c64201f11f2c3401739c6a680e1627032bf734d6635385162824d97fa9960d07e7bb2a37c605a022781d19e47c57fdb119b3a0a3035d8e2b0479a9fd26b2f50afc23af851ba148f2899d3dccb873c2ac7245080177e881d74b9edb33a32ca816db80ff62a5d766cca197ce0bce40f4145af7dbbec85f69c567c4aab21b38c0ad87aa68f1d260681a46230c8854cbc680db9bfab6632df24b217f13a581ec973ab607528429edc281bbdec3001c4beb70c375d772db141e8d781c71254e622f2533dfacb48b17c730cd5603b3788b1c1d9aa3d9dbe24895d6625f88992ff4b90e4a9cda8c88c54389676d81e5c0062da9a7eaff0be7be731eea7f636bc36fff71e40cb8dd50c491551992edd0dc3180d7eb9b532fd5d98d28e7f7d3fdc4ac9e4e65c86d9c262032ff59e557b21f0b0746cc3c7fe4d0f9b8133377ee88bf6cfcb30c92c2d6576a71f7df206a3b4dcbceff1f09ba0ba298c8987eed7d16f332d32fd6a13563d7c63f26af05a7cea2241799d9d84b7375b0a8955f45fbb2ee408fe56e9e0401507bc4c62d50308d420ef91708c1ef1ec60c2b14c466fe9af845dc1613fef96bac3ab22a0e259172904de2df6df412daa0e8cc50e8ed943005f1cef7dadb3998bf801596616b84f4ac8e87505b5d5ad1073028b34c12f7c44b48ecf4c938919431fa1ed504fc7add0dbca88ab1ed9515f77de3bb2aacf2affe0c838131ff33cdb3c0561548e4515cb16a1adb690cf8104ee29fcb48c96edab5d2c2385369676be523f869c61f37e2c236afeee7141c9cbb4dc323a8b05df949be3675ec68d99abb6ba815e1c93ec469ed75aacd9c0560d6090c0a1f4d9e478e97d6f47edb95c38b825287b3de4069500c99e2d1cacd51ddc2c6dd49e2c70efbdd76592a9a695b8f626f8722901420ce55541a2eb8b865e1feb2259da53a7cdd00c0c60a5d20e5faac169822707f014f3ee1425a4b7f1ee4051649a9e874c2e3767140daa07e48d60e0ff0abbb201089bf371e30767cfa047ab9ac380f4f49b88cab93ebae8887acc972bab823a8b9e11d9fd27dd0540d4b995989a47c92758e23387f8f84549d9399cc1bec5e6354fafbf9c136a3d5017eae439fc2db91d1aad63cfc13bea6508c2cf27d2d8cd705d86776202be637b550c3950b8e90cba33bb981c610d709bc9e7edc519a740d73cffe4d972d835ccd3ec71af0bc8c5aef10da3f4faedbb98a56a1564f0e26e9e3a6e13eb425309dc8c9df5ce2d3d8e928062374fa2e933478cd0c368b47c0d4ff97ea3f7e12cea8cbee3d5bf8abb8903a3b513f073b103ce819a6651f3a5c03057574ccf7ff5bc4ce474e5aaebf3894f8ed0d1dafeb8646177b811d1287838ebb2bfd1703d820919f6b3bcf49a875fabc35db2f4eea13252b80487a6ebdece5ec78c4e77bbb66116f79ceb8041cbcc8c737e650bb014c3881d8750ece44401e83757f928c65b70efcf0edaf1dfe668ffbe233aaca7ade16796f79226e32fd1ad8284e1fc61e90646b7a0a8913ddb2e80341905176398eaf5395b56e386f13d9892caa1c923e4f5d9b7e59d238349216941abceb1644badcc406b201393eba06b8e6c7573c2f048db73584ec07ac310d456a56a0da9488099f0ec7c85065268bd17209afaf34e23e62de7b59ce5672127175fc1470fa22109a124840ba0bcc7b82199d109fa21905cbd6635207e11e8c53aa7a0cc96329e9411880311ea08f3610bbce86e5d7133f95ca3e48f2207857effa8a460a68618641c06feeb4a49c48fe98bf728f2829faca3707b1c4174ed15df56ffec5fe48cef160b8893296af93825ce5048404cde3cfe43ba5b21cca11dc2950bc75030369e6f5b532a11081b3e4e698c6b7f21e8a76b1f7e546b751e3964a381a40c4b32cec42aff789d06a3b119ac1bab7faf9fcd49d4996770ad44692f6c9e30c2256d6f08662ecddca12cc3adf783c605536ef403b5aa480cf5fd407239b53db2975efe5fc78b4922c5bc57131fac8ebdc7a34718c87c89cd73667357d5ea19abbc79f993408f66df99315469efbb6eeabd0cb2f6325ef405065702629623965d205bb28484549817184c0765fa959b5f35de9f606e01919ce4c66d90a1da1372fddceaee3c5433d27aabd6c72444cb70b6b64a517c1c2826eb78c3dce27fddf87a7a3db9f058125bcf383bf25cc7d22c0ed17389474e52fa357b6dcc121fad402fad321a5de45a8c3b87954d8d04477d5705c9aeae1d549b9ddffe0fc2205688a533497b44614f07f7149e0b267e0ed733aeab98b5f5d07a5b11ce67c0b711f10c888161762cac46a7519fc7e2585e9d560892ae11c9aa63ad84263499007419e751c5e9d161b1879b44a520bde5771096d201ec98e7d75bf28ff2cfd5ac6772fd7ce605376c97e7656a7ac4a3dba684d663d9e30ec595ed4290b24398dac7dafbbfe4de104cef8fc19f348e9873a85f4f2821ca4c4bd5dde7ef385a9ba4c5041f711231bc82e0894c65793361aca16eae08982aa4a9dbd564a4fa383085b5d962d95566f667eddaaed0ee794c88c34b17d26c144829af2d3e94a8a1b22c261321231c1fd0896e4c42f35e3a96a4de5629e176c414ec20329e6e9ccce2d002001847ad00308567fe65fd0a117faac8e4ab306417c31f6519d94d157a2742cdfbdf61108afce7a3689986ff7c81957e43ed340691ff6a7c356285e97d9b43298576bccfbefa3fb0ff84f396b9c52124d0c03e2198b8189c4793a947480e00be08ca3c255de3903d3393902bf1b90842de9f825b1357edfa485bfeae444eaeaa01f9810c071cccdba247e96040b3f20ce0aeb7ec161c38793d0cdbbf912933a1d66ae6f12b47d7b33f998976c742e75aa10db5cd44464ae8aaa123f81a8642b73635f4d2779aef238a851de9dae3a4d7a6c46e099ba6facc6e8572eaa9ea55966196da4b4362a7f9fd157310e813779ec672c5e17740dcca2525fe492279ccd3e1aab8d954ccf245a8e15539bf52816dab9d6a8fd9eb8a97248db1205eee096ed26cb66d6185bca2490aac7493acd49a109010bdd0885ea27c2384bcc9cb0c1d4a81f559e63b6059744b82475b3b4c21b1c237735572033aa994071de9c1ef9374a6e1268386aa9be83252a6ac348ece8278942effdc50bc1ae51ba4bc6e89935b2bcbe1aabb4efe6f29be421b2e00e49551be4ea5315950c2b48b977db64cebf80bfa10f46c1a30ed0aae18d11e4e105a182a69afe8672e526435ef3fcb4ef1ad525cf284cac8742032d672b529fb95795a190e6ab5407e8074e044f0be729528ce07ceadc0f091f78e513a57741ed766c4fa8e03a75d6fd1521e8f3632a7ef6c31f0a8c9e531454d06ed580fae5ab154259dea49ef27070a5a7bfb31cf010465899245410c260c7f9cfbda2c672a67a073656b16d9074020b89834ef209b10b599f4ad9798528e0448ff202518a8aaf92029bce01b7f51c53134a79e64fbd12f33f38f6b0d293f6466431012acc0cf0defaa7210214362b8de2d8240642445fbab4cb8e31cc20913a19d832091d10a4e5204497ec7adca277ab5d618fac837410f716b38c807adcf897755cf60b7c92ebffc5ba8903ad2a1121db5980a4143840952e481e117d75869b8e4006bc3e05bbceb1fa9e985eddc633cd35b4eb5cc9856a2e7bf879035367e1dbe800503a4939a6fa0a97fcc2d4f13195d408c86993d90c953ec19f1b35ed7d98b4820d35e71e233440862f4522f5e55290e1110bc905c3f3830058950249baef6c09570947928f4d4a31262622edc6cf0656a32a48ba4e0cda0c718db038eb85b4d0ef37e74f453bdbcfc0d38a9778aa43ce67df62c2220d732a5bd98dfca136a78869178e5483f95e283d93007d151b2f709bf71fa2772b0f5e04796506c738386901557d9bf42724b0d59a8419339b53b016e89481cbe10e77c89a4b501ec8b9ffaaf93d62e932f6a2c2971706fb38b5c984d1981e6896e7cdd6ede9bf7d4e6804e12f52862ddf5b17ed1db125216644ec42422bb83c510122540ce1d01074151b157e677ffe6a79f13b3fb75186d8e8ed56f5be28b4f796b9c042991fd19fc1e70a447a96ecf5b4be44ff44e0fe7b62f2ffaa00acdee5dcfd0ca31820e3b9671b40a7c5ad8b54685a3e450fc35149dc410fb39f68ca75be272b2d22c5aae7ed6aa9afa3bcdf6ac83dd069f4cb8ad6f0d1854c1b39fdd0f8ace434eceddbc52d18db1ef8808b6ccfe5e8087f3011f73bb996a7bea69cae70f56543ef6ebb83344d47df8c4d142aed506fae56a25166d18d65b7bac96e7917e2eba20b2a9fb42b4e38ab3a389ed1d5b8cf17fac4fb2f6bd84055a0a63a683366fe524addb79b8a9d49610a4f836a053d47111823c5a2bf6600102d315a081c69808d8356b42e155597b51949b0e34f614dc977b160520506185e64149ef37364d83d6127bc0e7242ce6e10b718e750f55bf67bb69c45c5068b460017e912249c9b85f35c777212706ba27c700db01a13301b27f45dd1961f7ef201d0581cf98992f2aaec8e10c464519bbe2c23debf03c63a3652f0701edbfd986cc6c86c28ff82fadf1c00ca7c18c8f4e8060916ed7b32d5e711dac5704a91cf2fdb90882e4d9ffca83f6620408f3c615c60704e9e2977f1221e829bd9ad4451061b62f6cfe013c00523456844decfa14da687fee47f1db5d83633adbdfaf599ffe6f9a2584e20e5b68459f5badb252df563bfe3f709aa31b3d7be474a6a195185cabc0aac97356bc5b7255e2b710dc5cde96138f4c4bf72fe5f7e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
