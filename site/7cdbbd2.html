<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13f230349e92e9d730238b5f0a1af4b487ce8db81453f99ed416c7477734ea602def93d7e5d2aeb68cb1cbe9fde5f1ea2402fd5bab27c14a4e8c72f3e1cb80ea973c95eebafb4a8e1061619f5c416a255091aac18060e801d0f596626f886ba9fad82bfd4a36fc697238ed25a011e50073c28a6fec84b3008cb3e2552f90f0cd9637603e79cd54726dde89441f58bb9d50f7c22ac53773717c43bc6d4ecf4069c18c6a26f496c677644414ed4c44ff77be4b2d8d9b3ebc1c9bb85f6c00a2a26b198f9a385f824934f06c0291d9029c07e6d3c969d429a61ceeec062ae90a51d70bbec1da440ff56e025f9bbbea19da89ce12f443b2b01173c13ac8daa90977fe6f0df5a088f315578b962051780a51b1e5c0bb10ed2dea494314823420199a65bd9bcbe80244c942dbe77f98ed96906568bb697a0f0860f8d95825a9112aef48a0e43a6b431ac8b9c2b715c2f7beb3d6a85c52c279efc5d60727a7b9a20ea4e56e4ad3f206f86624b1996ee7871aa964f73ca0d876b18c5979e5f08bc63ee03012dd1844f2afb416891f3d0720265feb34ef2e85adc19b46d4a70200920c36d048c4585eb55ba22581920145f08947e02c78c12d1af4e434be4b4a6a738480d05c8b4be6cb1038a075c5cf25d63ad741d808ed7d4ec93e0e8724378313c095c554a207c002ed6944ed8a8f804e14a85b9f41f1aeac0fec3ca963492537de3de963f347559e4c7934a5257f37265d495570389a8ca334ab7e3adf8588f1bce5fbe8937c0ea58b413eb97e38e5d6fe4d91943b74f98b5a28a89df8681722ffe8aebbbfd7f6b6e6e04ab5fe716191dceb469c3686511534458168fe80a5772480d0a4440df133e2aac08ebe6111ce22dc68fba4b9802180ff294cc32fdeec2f3cd9acae4f332a511d155cbe44e8caee4655c83925334b6e8dd8becd48f9580fe0a78e1150d292d490af240b3d402bc370da046d2baed9618ea03b9798f9d977e835906147314d8e6b911fc5e963df398211e3a755963e75ce8e5e52b4de6ecc7db5ea3bc4df7cd2354e50087b355df241db67598c853ceacae8c3e0dbfa7e788d4380c2435bfc03acb7815214279caec7865994c6e1a56f008c56808669ecb4d9dec4eebf76fec656e32f8e3ca148dd68cce3304d98dd1d166bc25b2bb63ffd5cf91f05c20703cf5ffdf8a21ea9153bca944148d08e72ebbc8b3e4173e9a7f415e007980201e9a1a8f7df5e762191823f5aac4c4bc5aca8cbe26cb0dbc0a0bedf350ab86b58368a7cbf9d48e9755d96961020bd23fe3e97edc61256e245d965adcca58447748aab584b7f24177d834199a4212ff0b95b53f723341cfd3bbb9e6cce42f592b8d5c8b675a3544435a2e406b01db68eac53d6adf989b4baa658e5b01f89fe67a6e4e8d21aa6c5996ae864c65b3e3834ac17f91db9ee354b49ca53c7259bee2a72cce9b37338e708c9b276a578e82cde1f7214ae729ed1fbd63193ce252d4fe2eca74e9964e4f8bcbeeadb2998c6cd8f79aab51080a7232a26896e78a17096a369836d8440bd056a5f5f1e0e4cfc07d6e90c95582863b6d2536d4324538678c837ff2978b0c76d217f788c538916b8be0dbddb94ece11deb3875e25726903b41e5347f14655efefb1e7ad1f21d064610b4984f2fc309854a03d05ee90c198b8dde867c00df61006b6fe408d5160a106651a9079947f77d190ae6559dfa1e3d82d199674d102b8bf54f3fdf78e438b67e59f0b5e231f81007828f34cb1e30daa6d78f4be9bf89c514e08b2b72c3c85b6fc87115d837469d38c9d4c97e3b6acdaba15909e2f87f7c0a5a1fc58cee28fada6918e6c3edeca74687a0c2ceb58ef5bf6d56bb691ce3e38e58c7d6d4b2850d922f024c302cf49bce1661b0398acccee59e2b4cc86808fc56d2ed4ea18e73ad223ae7b6fa7072d3a88c6b655068a818c1190588681b4b8d955270d764efb04d470121be1d7fdaf258896848aa6750d0b3bdaa920f249d6001249ae8380483ec0e1c75cd2d0b77ed078b7efbe34226a806fc91d9769b40a721781755877baef60f1980351699701b3f99e74e68c369aab6b68c96e2d518ccbd388fc42f520b090fdb64891bd203b68b4d32439bab7d08e31b683eed8286c107e98cd4b224006934f963aa420cac814c4fc028f648dd542b331d14d80753d32c45c28903fe2cfeb302432f410db41d785f87a157e48e4fbefd522218a0be5b94ad851ba4966aabcfad32f20e8a69a2705de0688c9c38a1b596b3fdaf0ba79eb36c976ede89ddad1075c6f581270f62c9f93f430de14fe5fb3235141abd4851f2ed27911675b00553c683b5f8591ecb9da0240fe067e30c89f7158c25191908fc1aca18e546a158192358f9744bb0ce27ae1a6f98a557cbda3645244f95241412c9069ed55cfd019e037046ac094a4398a31fa6a91000328e893310682161fd35104cf9cd3dfa19068f5324a708f23afd373093b7e3b2f06e5b842c76c123c03e90bd1192b036146d428008654654ad359857a065d3b94b0970df129a0c2d1e8934f34634d056238e5577b35bb3500124a014ac319ca401ab4155564ecd1371ada505deafc548d741a2d78f3a2ea2c2a4fb5084b4d2804889030ab1a182c007ccc13271befdf60f848e45cd72e3d37e91bf78ca4cd9520d4bcef67ab732719d4fbb70adb4201dbbe4d7a1e6fda5265fa1db2da9ef84106d831eebb603ef3d0ab45e92d7ff206938964637bafd811e44561cbd920e4dd708dee88a0089eebcdd8c8312c6f313ea140b1e6df1ee67d9cebf71587990702198059f78dabfe3dfc7960d48fea0684f3432286b62f57019e2103db0f4d564dd808f4d1f42002a5fa7ea11fa78bca54308db2f63f789d9002f747cebe28dcdc504bd902eb27536f815e166f82e8614d379b81d6210d8259faba3cecc5e5646aa478c3bef5868529c1b53ed5456c2e98bad23951eaf91d55208ad11d83c816503f50d5924f597465f31e1fec3320c664a5180124b129c8c88b00a21b862706997715dd58b58f2a471ccbebcb2fa7018bb0800b95043131fb0dfc00511f559ec2fb305cde035e8ec468ebc98bf3f9ad753508a04b799af9ce3ca42789362dc4aa1393934497357463363047267620a699027231e2c8bafc8075a7a01a5b686d7ad814cec5b33351337fddb955d7bbb1abcd4574e675cacc7aa96e0f21900a36ad88a25aa7a07635a6c598736130fdf617de74ad98117e1f497f0fe404e7ff9084d66c65e3fb5f6dedba7d3fd009c7b3b927f9c1ef2b22f065d615a3a537ae7d826466188e701825b841143ff31f44261365360eb588e408d4ae049219c2908e235b650595f1242ab6664612005fb944b4ec1abb3359542a1709550cc524db7a11e6a90dfdb0494018289b3c5b02d3b0fe8b06be31cc9e57136280832e211149dd2d52dbbe64a018f1e7078031604d11fd6b440f3a59df5e79c392fe4435c9fcc789c3e198e0c4b8cca2a5164ae02bb8c49330fb5fa676de293b3262a08a8afbba11f103c662aae260e93505209e0bf2b2929e7244bd3cac46bac645f02d59f359d546d2f75cfa3590dcb4018e412b105c38e70c444ff6b72d47a2df9871f197eafd75f0bc3579e3e01c1cd67ba71e01f098dffaa4f26875cdae180bc5b0484603c09c32fe806ad9f49e88b1c4d84ae6f166e00d5ddf8029e531d69d7734f796463dd12394b9bafd28c0b9a0e9c6f3183e31d41265539bc3977c83e711723b2ca19961a572f149d1ac4376d4ec070804aac29ecd941055dc1a6eb39604bbaba9c9fcf6266633c4bc8673f9490ce869b2431696ff6d1236eae06dc5cd37e3e8e3c521c63700c279669ffd7228d8f3519acd0f1e95ab9a6feca0f39a2a2d5546c47bf8dfb13c3926b9a057fd5445fa9b4115ed18c9f25daeb87f831e3e11a29dc44463b1fc4c7a09a04d5f65b3eba5ba2a0a35d0f0aa86e0ed92bc826f05715e629e3c4b7677efdb42f985d8561934b965786f84006b02f9f40c8b62f237973f45c9da9e1301eb754d26915c703873ad20dee483b9826ee8aca8ed47256d1b3d6402914fd2384e73b651a8d5fce7012e88b0091906238ad6fa75fe2d63a4c088182b1559242e4bc069b0ff2d75d06d5dad2d862d6c304eca3d4738c24f15a0add842d50a81e9481dd41602bc256fe55f46a3dedb7c491ed78b4c14d08256421ae22577bcc5a2f2c0641b75cd0b5129dd18d06b412fda727ff8130cfd1cf6dfdbd3eb3aefd7caf703e08acbdf1014cf80074b9ca01e3152920870fd6d0285f707d9205e0fbfa546a920e775b8c69e17b96e6481e866227fca4d46e1d1deb7a4c6a8ae8477157bced3b7fb06e341bbb562ba2bedf2a63842047e1ae75009dfca8117fe541bd121b6589f7a051d44047b5522864d5ec89f31f3e73105fc0538c192946b3acd5349a2179337658b341283a774d718ab6e6c620b4551b3c0c5a7d144a0f6b08fc0605d0a2c157c921716c274603ebe1e7ae46c193d5953e652662eb23fcd2c731388d9ea17c23979775ec8af942297cc445cb3660e3551cbefeef3337dae8b453c73af4341ee10ad25013be5020a5a1782718b95c56f0d627d975f07efba53c11577c2b528062ac505077c8d8cef970c56357818fabeb89cd04417859d1775ff36ada186b2e3a4d21ebc30618293a6c4c04775d2c801f355b8c8d3142c80205d151352f6ecf2d00199e273cf6623a09fef49eb456b4c294f3f951a830df55a007d537991a083526fcc1cada6bb125fc38894cc1705c2cf7545f8a8d048787242d85c1bc361416f6379016098f2945cc38cd28a842a7fd346ad5d797bb73e73095cabcfcabe041574e6b8af4529937a2413daf6b010b982d5d54d981b2b1862e3ac49532b63cbdf16b0ecdbf187436f7a68977244dc870365519242da562f5c674449a3f92ae4e3c4400bfc41a2a6452b4134f1ffa84bf761b2499d0739ec5ce023c813a2eb5e8621b2720891589a87ec8a0005b5123610f18577dc60a200f9cc687425b9ed669c7d73fa0a8eb76c2bf51acda9fd353ca569655e0ebb592d19dfab30f26830279ffcff31ad257a1da907ab10ff1062a7aa8ee633cbf7c81b16d981ac9d7240813c39cddebd4815fbac096292ccc2c916858de61d57f43244eca6afb0ccf42b865b4b1bbda6eaa17fb505a617412d491f78e6a97fead78bf51bafddc45e7a3be56a0064e56708033dbb42f5f5a6d4aae401ecd1588fd1f86c9f91474edab5fc469b4de1ca2d37d1d2956b6f4b351437128055bcddd1d79519d8281c5436e8c9a48f2d707dde6d85b5c52fa48b0eb0c53b13b4c80da8083e565c2050ee38e62fad5ace01b5abb1b1d0ae89949a633c906f1adcd57233d2b50c328c25e0eec0f72211a84ea8fd87846377dbeb6ec5eb4132755844c64cabb3529381be5822b0d46f9a012756a0ec600ba7723a4fd6ebd4150e17ae22bd448447a76b80721e1aac43bd220cdde674217a501914cf19f66ba258f8bc1c1deb2e8ceb902b7a08d4e2c9d6f3a9ad274fc4065f22306af0ab0ce7a92cfaea31e21d91c557fcd2389dd28602c944e056ff27406663bcb992872d364146935c4ef4e6e70c20a8d72f15426d9f2891c2327167ca0ebc9e4530a728dcd5ed1f53991422a6e8fc0e0eade06bed1d971e6271ce71be2dd413087464dea1aaf66752bf414f880cd2f45cb447541506789865ab1d90f71afd69a9baefd4cb02f23085bedf463cd7eab23448d7572b6f100d9fc0437765194f1df19c908b2081ddc5aa37e9e8d1d01ad8316c856b54a15bcd8b40c0d0a17dba360591725ae2ad4d4f765e1a5f3d7d9b34f21af6a64ade97102ac68f06651e2fad4e2c159d53dedb024111e5c6176bbf79a6b4e9a8d7071e8763f4f1aedca451c87be773a3116e9a6b5b83e9ebdb352434b8c6b027cb49734c687d85772b33075f8051c7f7cc40338f81a6a58dc99d6c7c815472da5b9d887ced26d826b5a75c60fda2d351ac22dad27d949910f30eb602d00d17bd3780842e13b21411d5d391e48a7e8bc0bc23666a5476e68f518e6037fb0c4d833ac0d233275d76b7a1275308e4aa03a4e5200bfcd47a4969adac0d2fab8f033eb24af45baf9ae89b5e4648840e0eeaad7b75f4d594e3a9367dfb64cce5d807ca892a01dc129deca42fec399cff7d6dd087520b46601523f674738ed0036fc53bf238bd5952132eb86e96378f4b6e915df1f39fc4063d2e3b2b0806746be90df91262ae05db00b33f1517cec213e0b985a6ec600a9a32ae9edf2b4067167f04b825a07f35195f7eddf7a84711e07b7433f0a08598dc3ab63f174fe2744a04600fecf0ea6bff26c78e6ab677030edcec1ae7de419e71b17eacaeb9b4ed622c6551afd61aa3b72767c777046bc88db962c205e5033e125ae7a878a246ea7c32c5beeb020b97e7952478973918ee2fbc49607cb81d40605b5f57c3f0d928f972a8ce6afd50de10e07537c4f1663be52f18a671adffffe3bf995f1ed3ef5411b5a46ae20919fcb8c6830b78ee8afada62ef5a07dd5dd0c0560181a75f10c5268d7b04fd6ae6ba68c7855dc451be31d72456b340d05a64a2d12288cafd8d56c9f6b919c796884183732faf5d133e2f6bb5ced31c81d2efaebd094feed864a05e8f7c1208bd0eb0df37f7a0f98da53d0f20d823623f6b558309552fe8ee9db4ae3afec5718cc53f7552e0e6bb02dda4d57cd46b203a4defa246ad3bf69fc5830f4535b3aff335ed887864bb18e51ade1d75a2081e8ddc1e526f55d0c3cc339b1027d04c25a09695b7aa0ad1231b93361eebb9974403884b532d59a92eb71a92657cd2119752b21788e41d104628cb8a2c83602062bb539aadea1ca569e8cf1dadd0a36713396e873749b2e956df6250a9849bda152df504653ca8a55ee2962c43c9825cacf7f24f42ec213d415ff624ea5803c164d71273af7e0c881aaf966dd73e3f8fd7ace73519862b60bacf5f53722a4ed9800fbc9b6e3d24743a8bae20b91e44e09361359c5a85ab6e7823bfc5752cf6534ec1f67696a9cb6cdf92eb8b03abb5da62b57ab6cefa8e13cc2aa08d4c7a43a885b398ccada747e43e2e3fedca79fc9448903feab6959648e58938af5d3f71c03ab057397fd8bf838ead414798dc39778e94585b793a5b947fe26ec8cdb807364b448a6cda57405c8790c96f79356e702081fc01d4f2bd5a3415e6468e696dd8939f151a5320941dcc64a812634d7ebae0bfa4fd9803f66219f9f4ff30d1d72e7a78afd87cb8135e022a406d8bc644eeda46deb5a6413497993dfaa48abd7db3aac07dd317a19b4ca92e26f8711ff966576b9b514b71945931267e6836c1015dfe79575694c7e68b5dcc2b6444a7031f0f397152e01134ea0f3c619c861dc4a3a068fe5518cc10a2b6263756b0647535c57a35077bc1fd5542d7edbc7c56cd46001f124d8125d752644ac2140bfa04543fcbf3083aa2c7991bbfb27214869673c134448d489b26e427e24ffdcad10d43f02f850385e104f1581611c55bf38646c4a524fdf2598860088e9a6acacf8a15d1e0b76b7b1c4181d46a355a9d3f15b08bc22f5ded1a68450b45fac556d76b85b96ea0fd9b788e541febaf081a6f1686e11d02d3b76b1e73500537d895c7e77abb71a4b5c89445b581f7099b127d23a6a7fe20fc4d7c5fdc5fb6f7f8cf4e7313cf1faf34abb6b33b73592d63fdd75d8c6582ef9bc18b7a73c1d0e3c2e15cfb500217be4cf6568f8e2ee8de7603b80192b0ca2029d13f05a911eac5507e34d8483956e911c15052fea357fbd3d1bef6f1709ada4c9faa53aa250132e365dcfeb359a96fa0796c10c375b36feff3927075d3df48c79803e95aa61132a4b14732125046265781ea55cea9e00a90a7752350469dd18ef675f9663045a1f45a53539b07eba5344efe70fa0a554e108060342d08f9bb4df3649f332edb49c9642fd49f87d571cbe34aa77abd43d0000d181824e3fdf7318734c32b8875c144287774c862f3b9e465c4a3fdfcba9009a131bc6099343a5036c90f8cea423e032adf034ca59c76c94f85993d6ccdd11aa7cc7ffcc1fbf5075b0d9f80bdb63dada68ebf8725dc8fe09f44491249a7f5a008cdde00eb26f575f4c211171c4f2ae0a017dd044d1fa5938a37b99a7313058dc0f470cdde760da0bef842b74b2be48dedb4c6cee1b21b7c3948354bd078c3821c32970e8ed00cb8d032c31f535a884d1fb36462f97462a9fd160c9ba81deb4b59586943adddfd227c3061f4708afb6852ea353841ff295d2a65c49264f43b831d143864506fb10fb6b3f77131970270f33fe8c3a1441968193bd4abdd0f9aae7be19541748c7ff9410258597f2a1837155ebf88437f122d4a894957381e2149f9d598378f50bcd20c2c7c38c26a5d77b4d92b2237a342b7ed1e966d69f67a85b10148af14e7bd8dd51a7153bbb3d694419e0bdd484a7336d83c6296658828dff40f8d611f3448d96f1de55dfcdc31dce47d7490fc60df4b3a4899cdd4313ce70c8248345f5a0b771ec5739c9976eaeaf9f2cf8d2d64c4056d14e83cab1a8219f44497cea763e431dabb9c24d80b4203d850870bbc8ef80e625fc4f6ab67cbc5f4d96930181ada32e4226628d049db22ed38beff840ebd41b2655f4c95f7ac6040303d199ac6794bf9272ab5ec5f1c1c527f0a1ba5546af19d517bc650b3ca90146dc8171a53a6a0092afcc5cdabeafbb2c3323fec6b06c5081e7bb386db50fa956d43178774b889b6a1072b2bb9e1ad9f48cd770c62eb675ef1b6b0bdaf5a17f146364fbe9e3b3b34c298e3ea324bd97ed05660f7779e15f955ec04805aa42ff82c2f892df72d3b5b4a7e19a283058d3b4b332c067c3cf44e68fa74269e16fea1b01a6dff7f9750184cac32a67ef8ddb360353f59ad609be981b3e59ed33a24a6b0d33a7fd7711569dabb9c18dd3a7a5678de0ca164cd248733ec716833cee860d3ac92b5e78a670b90459875254f3308c7fb4d27439c9934c42da20d36831bb52cdad2eee5a7ca75b93a6bbcd5f25ff4f1f183b3120b044f9ad40708e155b8e60c61e3e4206035597e728efbb080d098df5163315d031665f686ff169d7cfcb6d782541823bea9fad822dab606d325d7ebe27fe71af5e4e75fa5f6799d510a37b10478fc69f7f7f2c8c14c15dafe08f9d9166dae9845137bd2e448aefe4a5072a526aed08c2e075d86fc2e67a7fbc5bc30efa6bbccad89ad6fcc69dc11ac09aa895286fabe15da003c4ca8f1b744a573c765cc098f13b01648f3f95b361131846e39089931c006b09588b6c54eaf377336d2b1b8b985a3abc852039753bd44906f8e4fcc26e0e91ca16f1875f4e88ebab8a27e678cd08915cac49b4ebe50ee8d9b7b34d07ccacb0ed6fa997d65b09d35a961d45df0178f124b4e6230a9a4e1c8ba82caa5d05881ca2a02d782c6bae28c2f67eb5aa707c8af8eb81a39d873bd438f3fda17cb9f55864c654f3d436b6dddf652d0ddf38823db8da71d351e6c5b84f394a96879d6fc67b1208a34fb5a9b0048bfc5ee9e1eb53f4b88bc4a76ea62469ca9450bc5a4dbd6073e4dd237bd81ee8b38ec3900d54a668b336e919a21f34a39d23db89b1b0b08cac7b198d94c1fd9ea703a2edbcadf3ce634ded2c7c896b648d1576b14c6b41a886627fbf3db06219bc230e89a578641b6c8d7faef609c194fe6e17ac7e9ca25a997e512f2df4e22da51ea0b50c05c246b3741ec3403223a6fa15498c98127a8b9aa4dc8f06e0f04c28bc9524cae3de8cfd86f1f0b39d7c412d7711fcb97350f902a312738db5514d35f6296d5d2733e5d98e55b961bdfb72f0eacee138895b6ff18d10b307f5cded807b0999f1043333e046e94edf629e25aa927c734d6ba677261648072e3eb69f175984126eb3ffe324691b384fa3c2b60e0d0aecb5b69ab235b0f237913d07d10a211f86bbaf9b013865b16e07c847e18842c4f88fe046af0d811af7e2ac8e36fdeb4a4d110aebd799c341d818efe672a7ce5c8f9656324acd26ff99b99524d51aa97787759c0e7b7dff65b12df3ad647af8a961481c808b654fb76a6708d1f548c8e1ef6b276f22c26c51a06e49c44ae1220dd7c3345c52968ea0b378afd760d5504b01d627e58e5dc4bb660dbc0dcd027ecc8f4a2fa25329d5cb52ae9249c223e3824ffb58e9030563df7d7c517319a04e45334fc98406bd6bbec8359edc9551e9ab5ee6ff651683f169c7ba7cfca40aea18dfe158970a63aa4e281e4d3d323dbdf777910b0862d1244e5cdc3b5a18fac5515301059876c6b9d77f5f59a08190527cfec2788a7f116b54958fde85eb1fb36bb3b5666ab111673e975a0c8ad0a59e6e46ce6edb49d59bcfa93ab54cc0258220ace1f8aad6e73c97671931899f8f7194834bec087f2c1d7d457622a718ad7230d2c8e3f05b617de12a45124cee51297c77e0afb276bf2cad76b86779d31f2043dc4cf2b7aac2470cf81ac4b3fea437baddc6acf68568d24efcbd1ef42f60d2c4c332dc1531be74e47bd51773fc9b33f38a2c0775d60c5888302a6d32ddcacda7c05f07637c905367a1ef320a09a777033a7d4b7944b110fdb241f0e076933a3ef02def848cfc17ea6b2d0501be2543d63d949b4e8f5dcf6798f7f96cd611602d98ede658f4d7fd4f7791e4845c49e31a3c8b18536a68b9421671e6e6e5b980c60308f1730b5a5d3c91a201786aa4ce0543d348874e5c210337af63f24e1388ec3033a753376c13b3cf628e5e086011edc0b12693aa921ea2c5d9857bc50e38556637e0ba53e4061691f8ea8260a4132ef1d4c533436206fff6f5b7297988bf388909bcd8362ceeddac4e82f2c85e6ad4451a1751f199d7ff5a1d1cd66175a3618caab11cf279d7da22151891b4067932f6b09225d25aec66f819bd2bdfe8459207f0b6ced79c91816f8a74506c1f656e8338b0ce94c574c6a811ad2728aba054984cf00316a5ed9d6dec7e4e592bae43e5c08d8be6831ae4644da3b2fcf36895d2b2cb6282b883c11614ee2d715c77826fedb34c52837774a62bdd3ebbc38a47f2c39a8da2c8c3a89472d0f3542f3a10630dd830868a74c741ce2339b7ac44e7e7713eaeedac557878effd26c32951ec1c0bb224d42450185a287601dd3460764ca0d53fa62e250ca433a0591ae1bcd2053418f574112f6224802cf61ef19b6e938d91c9f12601a1d346a7522f83cbc84333c0ebfd57f8fd3e954a63c8e76733cc80f9bf055650005af4691310639d1a6d41f7da27249305471f79e9af6dc2dff14e3a9d4d303838676c2055228c8ff2cc84486b90983b2a6b80895f4062c33c0275aa6538953fa5fa641a618e467f73de311c9db53e9a1e224baa542c9263d07ecbabc97cc45dbe90881ac267d5c1a599918914870886f3d002ff01f1c9319a93cd1f494b9ee6056adebb430c04081412a9cfff5d2167270e450324a944fbb226bb66a72cf42af11b6d9cd23218cacf5313552bb4e5585a6ca2ceaea925f6e869deed71e580a39b0d94d1ba3ce7230ebca1d2f1012ad375f64d811129a2066804d1f16501ae62b4534d3cfb03a7d7c998faa0b77343921afa42b1df7a812216e3bdaa91bcfaf9f30b95da83be4c55c31d754735773169e9410b9516b2978ae21055c5f73fabbd3de4ee04a1248706d307097005cbb0e19f5e178080c5b86ac43e541918f6530605b1dd16e16adec7522a77abc22338293dc1198114ef6affcb3667eae6cec6d70f1010d3ca21a73972bc8658ef5720cf65943f069af53d1f5f3cfe396dbab95ea70eeaa35ff7c051f8eef761e9c851de4c148e4e11a3143ef9fc24ea6ec7d9e89c6d1f0307c616033eaf1f30bc465ed392ed4df42ab59e222142b6d44e5bec726f235851423a31f0eb1774cfb5bca6703419e582002e8c8b428194bf958173f71966e1357497643a832432e39ed2bf554d277afae594b31b13d35d4cd3a7befc669c06bc9b5a8fbb84cfa6ff633a8d30ee4db1a7e2c9c637cf75dd3ebe789f03e99973e3ed26dc8a7156f47843a2ad4c4663bdc3d7c710f4b94a847693151a373171d813f0ff3071253b9c00550facfd62e2a39f0eafefc0a89529fece11c27867375be155709de79b8c6414681a62e169e09631c760ea8c37de39a072405ebc86ae884de5005c7f0fd2e0bc727facbacbf0dc4fe23bbc143cae218117143814b7e68a7591b139384d5828b84065bf5838275df9cd2f8c13fe05624d4a8564745a6404fc9b303aae52e650adf01589a2fa695e25fab946650278e862b5c0c26aec68e8d4a178bec42bfe97c03dcab8e16037e9fad00169e419babccb36b7e5319126c7bc15ee34ed959e7e43781b30641981ddabc44ff046e1d3d08f87a81609a5acdf44f22f247b26d63ea747bc46198ec9444d1a3dda1a5de869186002236f1b8833a4fee2a53f9a20b4c415b6d325bd1fef6e743504dd820f08c988c523dc1c14c6f122187b1e091b2a98726e8f0dbd12ad816d0c4d02ad1f3ddc8b9cfa21d813ca867a88941522133f3c7b9e7a27d55aa7c554820c14ff39b65d40c111e616bf62cea2a7d291695319bbb922d2cbc0b8196d23a56e3147a4bbfa883080b6e8a87c9fff17604516682a80a35defea093e0c357f66b607b60a7681c8fb9abd90d438a773e7d2f3885bbafeb553fb2a3a1401e65da81c6c7f37cc4577be367a7933ebc2f85470727180a39b6d9ed754d0046aafe56b7e92309f9f32a6f12682bb461eb294d01c7b98791ba1c9e7d66fddf901b109752919506990092980c13ee2d291dbc3c628313e086cc0215d3583f5428106cbb205ee4869702811182dfe3c6f03a55f298053a817bade342ee28cb32918b18dd2290d2a56901b5a5cbcab49993ff732a2db5110e18a535562dceb816d3c9e04b1e3cec8649d9ddeb08008ab7a1ec3e231ef16011f57c6403d9d70f4909d7c8e7a848e610517209605b6c98f98e5bc9b7e425ff44ae73f13fe3c7721fdbed0486eda1ab484ed01363349248f25485990d3a6ba15b7df055a5e9622b6661b89d43836fad22c3fd2726e466f679146898ab5992adb88d3478d6d2b0030e183caa7dd4d70f6bffcec18edc75f2755055c3ef205d79861ab3a6c2241a4c7afbc9692e67b809c2cdd10ee0e9e61cf0f077c90ed49df010d9775549c91148389c5330d15867de8247c5c9415abde8c290a015102f17b39f6a7793e9dc3471ccb0e42569e34f5ecf34198f494a456ce8d64edff843c811cbc6aa843cfc6f1ae8bd168876f4bb27735ce3553f0fab2e68a8acd32392605016d09314585394b52eb3dec3fe4c835c8e363f2d5c84ce1c5216b5d575d7b75da1b42c501ee86f49b16c03988d5ad7405cc90c9c6525a927fa164da52d7279de3953674d06c81e7cf756a0fca08b9cdcd4b1e0200626bf37ae6f8a00fee55324560b68971a555ad96a1792053cdc32c006803c01fad4a57e8aae1d22da9f403ef0ec1ba0052b3803fd09d4396d4dc1a7161e654a151ac5131","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
