<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c206b0acbab8f27ea50cfe58ce78a09c831478a751cc868f06476f54842470c82e510fa300a4934fd9c8d62660f3de1994a570b4e9e3567d3d45cff195c800fc72549e4e868c7b8b68a55f9db25f8d3b8e604b89450c10e673d99b25a4cc0c61d01a98d8e4d7acd0196298d1e2c319abbb5b86a78b2b01deac738c8280d08911061f6a85a1afecbf07c86fdd50a22675a9cc9f800fa97a40a6c32084d000b6fc3900ac3a0aa536a53794d1151a4f6a7df3589bc8d54a3477fde1611e83929b44afd465cd9b127085989fa01e48a3c43d53111408526eccf1105a7c2fcbb21cd76330a05d6b0522980868e414210f8efd2138b6827c95ebf8fc2f85222eba32f73168477521025e521c7e6259c62b1c432e3e6f74a9c7184e49ea05058b16006d6b536aafdde42290c4ab0d5f59c92cf6308790eea577a228ebd53f0f6b64d06e1623272bc50f78825c78c5db73e83094988fa8389528b880e0ae07e71aa40540797737d0996273138e5637db249ac3c1409217995ce31ef6c0022d9ad73099bffe476b58396d5528a6efaee8cc7d9354754f2d41d9de0c269ad71044f7d9fe1f620d1cb9fa3d2c96e3a50066765fe6c44aa48c0db2c5c6fced70c804725da0ae621090046f05bcc61c5037b7b7b4e1d51597eace089ab578e8bac65ab92f54b0ae49d5548852473d22b52a37730f1fe9fbc47ad63cd28c348d9ab33ede9d5bfcd6a1e4cdd072eb61874d6e69114a5c2c216c51f145f2b93daf3c03d7b45726daabea18cb4ca880a620f3426d7ba9f436f8e68e794fee271bce5418bbe7cc21e22d3c5e094491d03433add22dbbf99274450a81731e3a796b9e57bda92c02a1f992d4736e065968e2f12edd17d3028182dcb943aac2ede5011e2bc749440f7bbe6713b6d3e919530dd2ea11ea052adbdfd6b814ad026ae19198c71f37b44f5f7d90bc5ac555b7ef7e4f8d73ac9651f84ef0f96e4972ec89757629574015089635a4a10dbab96b2d214efaa364f0cc5134c22111a47219a21a83bde3d3314966dc87f7cb09b7be551bdf71881708494e27eedc013f487402521a77c7cfea9b30d4492fb79fcea6c400c0784a7b872bb86f177c308bf6af35bdb46f4e702204d9c911b4c41ed21afa9017b19c80af958f434276c88a17a5721129905cbe8cccbcbf99906741847f5d860e42f127da363094fac7267b8d0826c40a8d311607a4c60dbfb8999d48c3c6b5c75f3b995f911d584c1e0b1881faba1634f19224309bc07012938aafe6a349c3083b4f8ad7f0864599476be36fbd6024b238b7c815ae52e95ae9a33ba8dd32a00ac176d19cd2166fca87a124848ad21e2d94fb9942ef0303f2256df01db8998f02d4ddb141842cce3935aafc4d01b1dd0d4de3ee76e4d430bf6326fc5ff91d073b105d7bb1d40c07bc5975fd561479bda73823e82adb87760ca6127788c0d8ee2a429b3596e746ec811433d54f4934866cfc26679d20f8923ab8f5cb747e43af71945112b7ab7654c6795d3ccf40281534e6661577baba1cfb4e7bfb1c4b5387305b090f940de10a74489b0550fc43722e55e4d8a5cd863e9a7497214f2762c31f195dcebedbb85999f53783c137c55af6bd2e5bb42901e4c44dc75e8b2720401c3f407950c329743c44be95069fda640159e1fe738342065db21ee7575eecf6cb7c34bfa0dda737078573ebc6a53367035579839d5fb9141aa71d0552fa2e74e77f07b19916741b0ab0d94a1ea52b7aca5510aeaa8dadb2a875057a5574c26081ea259364d29bd132a356648a5dafdc9e236c3b91b76c2ea902b551c267a89b6983c99debf8a3952ee201c13790c5271e5ff53f0c26c930a123fd66340a043e854768479744fdb215eaaa7a4b1457be1802ab8d5479f52f4ad01ca8eaadc1c5329787a6d382483a790dc41c84927e5163e262da984f6ef8a614e1e5411b929cf0466486c46c0116be9ebad5dd8c74385c4f1f5b55ffc7e08b0d76346d65677bdd1e30f006a559ff985fbda0abe4f985c5cea595db5a476e706a9db5ced65c433178aa76b51600040acb2cbe60cbf37ec8f4c1eee0cd69239748c1b1c3838c329a38956c39e6094c12f5828d6a5f7372533641bc071dc2b408da370cf8e05b1398d9f38f09f65a91d92e1f8071931c40d9d4687b4548f96128893b10f61b680b4a7e05d46d5433a6f209abacc264f9277c8522274a07566e5acb90d5e2802dfafcb2913eb0dd6c5ba6e42cb4a463c727146b07173db897af370a548d9641a14526d3dd79ba5696c55518ab2c1479b39957cbf84e8aaa4039d90f992b9e89e4d4690bc16325ac189f4c956cabedcdfd2258754d76b9ca26e798a4e51624ce3333066768e1af4666890e898744ce1fc645cbae35b02979412459998b5417ce832307ad7faf574d9b34f1db53cf25469dc7c6355bae5a1a6aadba1bedac5bc87249159f6bf69a5b99daafbea9aa7041b1f010a24c7d2822b7fae54437e22072d3f9c2a89c71fe093f8ac9d124bbcc326f91a3f0a75f5bdbd61911ff26a5249711561149f9fac04ab4300246e72704579011c6d24db3472a4fb857bf58453bceceaec022ef7ad466b5953b638944658e46925ffe40fd3ddce4b0409ed311b841ed02cfe0241f4d42baf9a7438716429935f8b42d35827e632ced5016f29b1c02c2bd8e75832715880ba2e53b983b58137804674d39b31f9560bd9cb9c322396f6cf256a9206e23c3ecd1092d318530000df62eec38ca0cdee99b6a6bd11a9af90f7805373b501a23f3727a5877c649b423a11fd1b7ac58032a095dadf2d288e92e46414cc6a8a7536581f3204e096781aeddc0f03ea083e768aa5cf6b00145639b415b94dad257f5642d406b54800a13a311bf64a7ca9b3a9cb236cf952918e010ead882e426ba87bfa03150e7d4afe09cdb6aaebd39cf5b5543b5135de20b15a5ae99111d5fbf9f890da8b764ae6da4de084decd8e8475d7a92d8980581b381b1feb728d3cdae33c837722d61f5ecfbd05f82f057b532b2cf875b9d9edcc486bd6e5e2bde56d19c28b49a8b6c276635ab00f1dfb4506f1a46d6db975d417d7321d8379a4f112cb30de24c93441956c6dcbeb81a9fd2b42588ad2112b9338eeb93e91c0d1feeefdbf7c5156a38b173e2a141f2f1511c43d98828aefd9111d2895e5b47e088741da7ab4d4c203476d1fa302d0b1c22c7aec63cb6dd7293749d775e4fc0e58560b2d061320cd5d0f9e469183c080611e385c4af3d97a43652c1d612e4b305264192c4e873bcc90c0aac7a6c1762ba071e77585fd61cd15ce56aa265b5f2650f59c1af60184972c6b7c8476aba8adfc747f0bad727b050c1a44a3a759bff4e4e9522c0ad3a8ecafe15dfb08c4a9662bf6b4feeab8d1c86b48fab227438182c7546d5177591733784f1c733b37768380379504d7622f832519b02435c0684a15b8b742b7571a3a8d654bf803f8493f29180aebb1d314462fab82ca38ba94c8ac35ad857083c1ee752f725aafa3f96f8db551f3403a7c1baf46a82b63a3289637d2390971e929d9bc6a3f6b086928d96f171fd3a0651920f28c8fe102f68f3c1caf36f4898f4ee4d70d5dc37f25a69c8ebd1e4a122f3edd749b715759622249d4ac9b3e1bba51bdf869ee2b58ae1ec6044ac3441d63b84bed79b50a975f78d0fc23fd8fa2428148001f4b21e5a7f3ff90a9528651c596bc24ea0388b760c216160adceb47178be98a974e7fc390c58ace1a79edd2778ad56aa938fe80615e06dd7bc7d2e00f01172bbe2404687562340305d705c3a95dbdc29a4075d4c0a4b0f95230cd378359da9bd84dcac2465391f8a9e6eaad310b5c429c03290dcb608148df2a3e9135de08c955a94b7a262fe07dd344078b77667cc672641d1ec30c90a8ebb75a17eb9c5968286c6562a5ed1917957726e637498057fee91537e0836eabb7e829e0e9fd4987fb1d5fe9e9ace91b36d02eb3067c16a97e865a9ac77605d64c2f6ca45879cf3e80a9166b2517c79d7add2373576a44ed6f77e7df7ea93a2d7d344890cd2918efbae26211cf9f709f97f8cefb40d5add5e3bac45ed4a5b84b1e425c357ec0f17209ba0a685da1efe93f7742c5fe49320c4b8a54469653bdfaf210b8fb5e72b6216324def58c91a94da2a9a3312f6fd138d153e9d0d41c13ac8f6918ac2a6084a60443e84f4e60ac8645fd7ac5390735fa92e7c7f51afb0a6a2decc73416e6f9365205bbb153735d4c1728d4826740d5e25cc76691993dca7464e8efc4e1b876a73d7a5012d02bfa607625414666ac54a9ac34e25148e23156ce13611a6619c5b5e2052f3e2e8803e3597468b71d43166b2d9e989cb47b0193c9a916d3c935c5c9fa58db450252c960798a6ac53d05dea8020df33ac86c78ad26ed353059ba1f096f56336fb283a3293416766e950769217cc5f56c7c25e5f397917c0d50273c8315bf74049f48a28fa3ee9254220d9a27ed77bff601606c3b575ccca613f29aed6a82e256d755c7840b01a3cb1afffc71e09375e2ac620bd3c80475346a8714edf1a0a01f09c5b2601ea2086035082d902bad2ed29b29b4edc2ae5897a70a42beff10e7d5f360023f714c50766e014d0049b8d05d0c6f9f9a76e8de7c9910f5414469cffd017771cf552320cdb62516cb7acfda537b6398f0bf40d4620ecab8c25ad617250a51df90c4c522052683b174273f8460725d32e316c58784ab258368863167f4105c5f4592662aafa1c2ea6b890aa6d2e75ac00be16e9ab3c501f1a000b64a060790af805d59987a643a0f7d71152eb1739b30b2a6597eea8430b8a1f16a52ac51c8c1061e5c54032a4a3821001a449549d853d2a23909371636e2e7b92503f984e74d91d5331268faf02ce389c8c4e828fa0831d7742a24aeee49c86350d961857710acb2315ec8a2c78f093ff37010b67427d1ef975aa9bdfd36e92f25529c35182e2e37b0167beca71715a18592f04672dd3e024f680f021636ed3bb46c7715cd8141727602053a43b84890cc271ac7a6f44aeac0d0d6fc3a5eb0749c7599bd998734376123bd389331f448f77ec97184183f0c7ce7edeb6664fa6e34d38be9c53bcb321481aa31be6179ff9be6c2f3083b13218fa47478256c4e46ba3936a09fa1de5f82b9d5f68f21bce5f2f9a8bc62936d01fe87c3fab8052bc949f3af6e9f84d1e738931f5358a44c552372508e644712d1b7596ef311a64229612bdfe5934f6e4dc51368fd81644a9b29ce83fa0b4035c8f918155e86f954df3f48af6d7e836c1f5f34e69fa23769a40b95f691e58338026be839ac6372821413782808eb3e55ea18b50b7bb68555304d0f54beba903ff557ba7050ece15cc6a8e3f7dcfcc7f508aa912d6b76249cbd6d31762b6aac0ff9e0d9ed4f183b455ab5ffcda9aed133b4e874e925d05cfe7a8f0be838f56930fb16457a29cc32b9a276fcb1020a1126cc2a3a7cad2c80810e8be693370c09d0b3019d9e0197de1b59167c6429ecbbec56483b628da9c955234c3a55f369be11dbe9229f7f1cea4845013408e15e8b5ba28922b67b92a913b31f15a6942c2c95af41c0ca15f28e463b9f51b545837e2bb24b57b0e68d7718fad20d4f93614025fc422c43e2e3c81de837c7daab06140371334507c5d74bc7cd61af0965653e72a4ab290ebd61b58fd19241874ff7898e792579fe9508ef9d5467e6f5e0a44e30048b7cb1832b3a5a21bd76c67b86b356b5f1d8f367cf73ff81ee5015d3ac7c61523429bd8b5dc73f2d7c078683f4521f15cefa9f04c84525f87e0ff93cd2b7c33cba71e81e5eddff5e2ae0822cff1482bfa18f01901249d2daa0ba6e84bcbd8a354dae05c758cfe31b0bad37ae413c86f100ab24a0792d66836f54b7742fe884f2570ade67856a075c0f50fbaa9e00f41ffd4034b48a068e164cec20025a0b5c86acf87be3cd972e7b132d8af43b2114cfca2d898e60932e9ea9db9bb96bea2daaed07eef8a82fc11ca46dd8adc08495a063041dc1cddbcd51b6f2678436d85dd79bd8070c3259846bbc549cb5eb47c802ffbe5c681beed0005295d2211f0ce72c1b1dffddb3cd4a7e2726d132dcea0725fa554ed4fc619493c0018f773252f70bda1a8c6c33ebe7058b02a21ce8bf534958f6240895c27d00a66f3b0b3daadb4bfffa98e9bef06b17622e93c6c094ef6d46da293403c99dde2182913cbe6e58aec128565394c3e023e0e90a5f97db9fa2da4379f0507584653f29cdba57197de470c7383a168a51a84db5760c7835a0a7c541e18f15f64a2157cb79cc0f8374a8176ce49d703a1a17f65c4bd5fccbcac2f5cafcd2591e3656615870465d622241ec58381440f6925efb1cdedb24e6a7cfcb7bb1e3c2057182e0a3dad7f229419234f6e15e77c9fe845c7d5c678d04f9638646bee84ef7ac56d287198b4c6c13a8d1fe3b93ac45cfee496da559e3c2c2502a9760260afea582a036c78a24cc175444a025987344db5ba15b7f9b5e6abcbced4872622e7356b65bc76d4ededee2b5dec008577ef4a0cda246d87ec28e732fe62c332e4f85c1d00707b9b69f77992b6b777dcec82b514d15019ea1e6f87f4f0ff073ca1290d161e036a314a498c05696aec893c8daa52e1944b1e1cbd015caf8d651795101d353777053cc71fc7816a3412625fb2bb9126c2f1b4460625edae2864bfc3c2e74947220d01fb7f607c8c59a5cc0fad663ea8622993a13c4834d5279ff19be26a057f0d95b6088c5add93a0817b9edf1f855af2c2a5b7adb83b77a2f8f39059ec3c7134af30c59be0f503e7535ec5a31aae26eec50d3399ce489abea9b0e3f0bf0d2926c714d38418b72bfd0076069a4ba3c3f249e903b6e149b377923951147ab83e47f6f0a7e043ad1d0a5f88e54880b6172b49961b53c85342ef361cdf4247edc509282729be8b19b3c8ca3e28c73b8bd26a6e26da4dd08cd3117511970a85c96c94adfe429686d4f61bf3a1270f155967bf2e979a92e849c0e8897d0d65037de06dc3a214dfa8a330f59a94dfe44113c874c2ccd9c34658357255e8be4d4d6f6ed331cf9d66cdc0645608dfb7469eb8122d2c99e94d422c11bb5cb4948e000752eb33c536485b34388e0da1c502fc41988acf3897a231ee04e68aa020be4f3ff147a29b90660bb02cc0fa2285cb353dde0049d4be937dfb2251c8315433b695bbed768fbefeb49eacfd42a68bdc790fa4c00d905e6b3e0ea3e708518604da2fa0f375613ee51d45b427ffeabab135368e8033fe9d54d819efe055079fe6aad8ff6bf659e678815333ecb8c752350909b4155c6694c949aa3af680cabc643391ab6f94bc363b76e2fe5781b9756461b8d635f09602cb9663ae33772c4281edf20b15bdae40f4da0020669b8e4d78d7cfcfd5f6f54c86175244dea7d7878973543b41b5a4457877799f84fc786d2b98c28282a40778fdacc78c01bfd7cb93e430215ce1529fa2e6e6d5f66137a85f81984c262306508acb06169df333d1dc28dbc8f6f2325e140a7a017e2210c2fd431e6c1ad71870bae78148686396d2dc83e785b1c3ab311662be44cb5abf0562f24938fce67706e652fe2711228cc7344edb2db82e0084820f20e0c53ab04916bda517b2f57177afe25762f711b51309dfdd6780a2c437aac59723107c34d53d4065cbee7f96c264043acd8e6f49346dd78111d8776d76a51df7d9f4609a3ac178d66f7de75f16ae3ed9717f142d354b02812fa50341d26086bd31ad25e2acf371652b34b8b2d66ffabb61b28e195a30275c9af2e4b9940f5c21e4e31f6ed5c24bec10cbfe769378e8d0796c417e17ebc90f3912dd86fcee27c8c2d1826a13669936e89846da74cecb98e579c2378db8fda4cf8a717014cc4fb5f794d7c5aae1fe75bee8b8611cedc27865802ec0e9403259344785ddf99df457f3a996e2dcfba7bb4a89c7ce8de880f3503f134e32ff5e979a8c181704921013a7530ac52efe904b8c599d08ce86e9f2ecfb47038038e2ed846b016665323bf5817571e95b1a0a4d1292047a373756b0cb2a5d070f7320f3bdeef2c290746d4f454753c0347fc1d4eea20fda495b8ce276b8d0f09768a379e021f151e0849166a2819dd65691b3e14eb8cc73d4c596526d6010931d7c70486395f9c965bd5ca6f26499fc29544c3c3f1974e3233e95abac854dc761bf453af75ef9768eb09586206a2e2d7a491f90c68518431dfb34c02eddadfab2129b895706f9f29242ca1ac3f8791cb62cb602e8d8fd7d4f42ab7c9a9f2a2ec1c9bffdc9d35c1bf4a0eb97ca2073903f1bc4fecf0af0c700c21509d3fdc01ccd62bc0d80f67afd8705b70b52d44c9b9d1b1f6163304d353699b3e14174d5b41725c752e0e880a26b7e8ab2a60808c5204a02f0c4a0a4d601e327c3b7fc514bbff8d649b893186ffd77a4f8ae949e2cabbfdee8670718bf1013dbf5d56cbb07dddcc5127c73442a7d986548d176759bbe5b3c56aeb27d18e9189c5b8f3d29f4dc7f69581180161269b5b0a8afa02897385ea117cdc79e4bdc8c70dad9c7f9e87f674ab3b4bd32b14338b41427cf41098c1f53fd0a905d7c14df08b3dd2d9cf0899d5607181cf40155b6d7eb147a05c183abb00d68fe25532099718320f2fffebd1854e4f3b237a739d42b8f0c168f47970547fda0001eaf9414408ff4548f52a77293ec35d88d7da30c22bb2e990e41b459cfb928d6bd8ce515b6c537d974272cf42a01253c5b07ccac5b5a3e8c5739c83606d411967e1f635d3ab287d6fe169e01fed2c032cb8d226e5771c76a6e6f9c2158d8d0ba3198e3eb4e353dc5ec601735ebe0dcc99cc37541e9d72df58192bf11e246e94b16df7d7831cd4b8142d96a3d79a86303b5b25451a40db7f0546fe5af5b8425894f3872a2fbc054b3862862f22bbf2eacedb902773b4cdca8c74a28625a3f308a36f65cb5771aa09b5ba930188e94c14c56624ea39726f90ddf762dc7b3c1404e8067f9b474326297b1953970bb3619d9e19865d6fb22f5e1663058dea18b9ab3465d4eb3868f2b30159424d9bcaf3196c7afea3c9e23c19a57f7ee8fab542b670448d713e419632a73bc7077010d20af4608f7a9fcaf12f1b3186f2c9044629bc4dce1f12e4b670588b31e098b86c39038590852867165d40a41473229705cc0077a07672134d723cac26e794cb272ab87cb71d5b8e97eb18eb2f7f3b176914fc99ae9c6c19a03baa615d980c8ae8012f7f6f248fb84ba4285c4cedd68d7ae25c69891f366d93c0d2a60a31b99e78e00ad90c78471a864c9e22239e5dcbadf7344727309ac67e104cb009db8e324bca402b68be4d63561bf26a9f7b5950b21e98191f27a97426e9643ca2933db250a1b2c15b9b0eb543e092d18264b5cad328380cd7193a487990a01637eaf742055551a092fb2561a850a0036acb741bc102b7e28d0cc3868a179c40064a278f2bf2021f9983cdbc7ebdb8ca42481790a3f7c7ef61f651fbb1d921531d0219cc74419e003ae7a45fc2315c90d5c92716d6bf59ff193ae9437b01a4cfc9e0adef7a683553f4dcde7eca2e34addf81181349f712dccfe7f57f2eaec2c1f90129eaf161a6fafbecd9ef466776e21f93322bf137c8634ed41c906dd4141b3d1e5db5553be20fab531b6de17d311f724617de24dce7f6a34008d31c0b90bb7a7e696f42373f67c85fee6b360e69cc9a039f4f578faf24f0a9e0b59a08f2d6640ae57b756da57cf0163e04381b4c2392c18b228f687deaeac40fb6aa65e61ff47ac2d15aa406720b0737bd629de03da9da4dcbf4a53b8b2e30bd138d42d38b6c80676ee69acbfe81f063a6fbdf1a41463d1c03e6b5afc07106bf1c94201cf0fa234d284342af870af8d791d57db8972ae4018aff1cde7e26a37b1051026cadc91df725c5bd9d612a7aa48c281aa3f083e67f0ec4344dbdcc6be4d214a9523261f0fc66388b88fcbe880712c86b7d65177d1159e0bf450044d7b809b61b4e108e517e37204157c21ea9dcbc426e8fd7d762e35f84bdfdcdaa349f162e36fdbacdd4510537a11147f44ec01e435331977f2c0501da0509d5ba4abc8e86c1be55ee4089cb88cd241e8d5ce027af9892d008aac54eae049b4db86d20fa308e50394e6eba901a75fb257ca8eff3f767bac972e7aaefdff46c455e5754c6fb9603435682f41c18478e83a14506b4f3639ba098f6d5126dead8f098af8dc51dc978fc00c5a6ca81c4a5b68e8c50753e9ada8240fd87ac39cc514163421bf630083368f19f83a823a7923259221a5583065a597f31f98a14874eaf416d0ca877cf58f0586ccb655be348867bec765afaea7202242855783789b0d697c7011c677a81303c652c756d1ed3eda779cac96aa98488fc41d0a82864a2540a3d3f94ff1076d61e868c03b8b01d42aac8f1c48e8fa7987945ebd41328445806e3abe30c5f685956a79fe24086eba6b94a56e5265d2631ff979a52785b63f38dc85d4ed40c6ef982ec5ea5a555972ee4faa7d1f501d18f4df9c4ea73cb6c2c541eb2d99fdd4f89fc44ae8b65164a23a830a7336055c71f67c885a4a1172a3d8922960b65dd13bdb7dd8e6641cbb5178663c9f0de291400ca9626e8abe3a905397324899f676b62fe5d8a4eef94123187f25e04d0782517807334918eef8714fc3db6589756cada747beaad0697e0e92593ac56c865a41be935e7ba0b05c2ec3e53c458a95ebfe2845b7c66c8fab5925d4756186c79fbd77942f56c2f53bd7eb9117bec1e9b6fb2742427fc60e98439d00a1f4e5fb7f2cafe8b9b6130769e8296a8462e437f2be0d84295e27c50407a32a06aacdfdd2d7018ac759102c111a104cf0ed8d0cb9002d2eb689469bdd80745c2d79ea7a206ecb5e9c283fe8a18090f928a7da9036b502d25d929e748127cccec5c2da7e3fb15e4919d9979758cbf8af50a8d41dd572ea58aed25aa71327ccb5f2f49f2ecfaf75db94bd0781386f8dcd6dc16f4d6ee8d564a62dabb8d9da98f893ee29f5adf9155086c2e5c955d9640f01d63b56a7caf00f092966d3dea09b6453e9359c5f91ae1dc0f6bfefb98effc1ef8aa102681d02e16b0bf34ea425e53052be08657842273cb45651fd91d4423af5a2e1e5a036996725651d8251f9c942c80fbc6997a6b20536fe3d4531328e679e68073cfd39de50d26364e2756101f94bc9b9d01aacfdba34b3089b173f452d5627534f05a91b2a88cfafd233a3f270794b766bb1de1628c559a3a7bf530f2982457f188a1a7b94979f8dd223ad1118adbc93e33fdaf26f5ef25e2845ab71b6cdb0e2316441d3255b795a6dbab7ee039aef3f630a48fc93470cfc63914b741e96408033433013b72833e08938652560e6e31400d5c09b339bad7451b6de28a6b0d00d62c5ff09da148818bee70314f352b85d8ece1df3946d12eafc6ccfb947a6d39eb514f9fbf7cfe671f599f5dbc4ef36ce3d82b5ec788385ec1d59ab45e96ae8cd95a2f52356979a317e3a4ef6bbaeea9d1fb01daf658496f256990193da9afe02011e81699fa2c89d25a4638475b7daab58819d7cec61e65afec5d35cf0cd4ffab984a7be7552d9683c3991dd4b3a0492b3ce5efdc71bf0cebfcd760c91635dbe2aded44b97b0390fd1132e69ffc0a0ab761df1c9e7814e3271721233964e8dd9dacf0cc86a06a9b38919828c611ee6a3883806e4ee79a040de7516c8586ef25d309136498704172a342a30ac05288ef4a847364b3d1bda8d6fdf0e22de91672a8a601a8968a2d7685b90a484d3fcc6ee9bdf7e05d6a1fe946711bb0bd764ff960306b8e8520920c3b6fe5896b273b0a58a173c400a2a12108a8a847bc3e9ffae2297f647385c4128dc6b270c3a94e73507b0d9e2d9b9fac089f606f1c70cfb0f810439f4a9a6a68c779e3d2d42f16501c1a4532f4d8b255fcf1063a7ee091b0baa38858231e4ffc391c089fad2aaa968ca0eae99011cf055fbacb83ab5daa719462fa796d65d2561600104539d2ac419f98c723a1789338e07fdd28d9710ad6f91946e8d8b9b81288fe91c020b01fa55a0531b7e73f286b70c0e83b27a8d4b63c93d33e6c1b4addbbf197a48813012769481b7f5d4f3cb34cd0dfe774cebdabc75945fdb8247ffdd899944f066e593c006f62c1ff314b533ada7193cd3bf80e4ec4fd91f580c3cf0d83a85df86876ed1c67a6b67bd5921ad5804dde525363ad5cb5dc00ded63f0ee7d08da33c86acb50e65af92664968c9c1e9424097d705c3ee384b2ed9037165760fe5fa701643b917860c158ed2dbe5aad4c058ac8f8b289783c04f0aa1861dddc01b3a97772a096635ecb5770598bdd213bb1869714f26e5942417173f488139364710258c07b807f9cf55238bcef6360e9eca52bee3c2716c1c5676d22dc3fdc3108f6a7ab73675649993a1f2a26bec12ba481d6f565f121c2add69afbcc7663d25e828d6815f83b179d64257251aa8ce13ceab7f53359d9688476f309cf98e33bbaf8195254385172affef716b2f313523963c7682c5d4a8a5e9002dd26beed7bd8f1f290171819fb5b605398dfca8e3aee782f9f416ccc413fd7893e916070026908e93868d6c6691fd131590096943899651268bdace6fefd6cdaacdcf3df438a6e5bd4b7693bcc8e92089bc8220d7d174ee22f27f48b6993d31e502ee7f3ddb9b433a62ba09d051225f04025ed8c4ef472b83d53cc1212e85eb24884d96bd7f3b14deb5b47ecd8c38cb07e9983e51229d8f3c2471477952ce5b8ca7c428b5cabd6108d569760f7b1d7e531bf2b6d93e2990e6f1753ed7e236b42768d32ef164ffbaab5ae6616793bac59d1e8024bd8bb114e6111886a9071a13fac9aaadfec01694aedd744242280394bc5d700acfc67d8939fcde5b2f816252fd82403dc32c75390a7a001fc0ebd731e873d7d164a5472728cbfe8fa8eb92e85cadbbb3f3e5c2a837e46b64b335bb7d8791f8bbaa25564b979cff5fb349509d085185b5accf7b48308cdc048713ebd84dacb6014dccbdfb8482932b8a080d37bdfc56bff5817da3fd058365147f85e4a70822b20038ff54241c351310b25780586fb11a650a2cca46b8c8b6d977905952d10283ad61d76dd7e825c1501ae75468be39d0b80eff6e2926f6f648e40f0911194799886fc187a17b5c5ec51dd193a876ac9e8960f92c30a04d838eb427a88f04be84511e1fa20a06e7b33f2875d32d6955e4f7235f0744d463c6bfd756cf9276885e8ac780fe3afaa364db62e15b3f3ca801bfc37b376225500d9fa1ed879c778dba7352a8c5e6f6cbd682cd3372b315294c494ce4780a19ab10c2e70b2775976f568be863d7f3e900671cf1e9c1e162232bd7cc5e480777d3a712b034e5e1cc64686d2cab790da840160c35a696f89a60570f2dcb701775d2ce1d8f89a07fd99dde06e3228aad8ce95c716d2ed1dfc41a7c8914ee35bb6cf1dbbb8f309e8dcd7a6b46ca9b1b73a766557cd9a54cb9691bfbc09f60cd1117af50a5a2e449a4eb90eb39daf3a4e4cdfeaf078bb6fd53371bcd77d13b62a2230eb374afcc483ab6f9505969851ff505d962d45f8c91e4b7568bb44903ddc8eabc37902037d931952582f8896494c93678bd914cfb002d9a50fdef3de6444dd6fce34f00f59fafe88d5598062ed979f93b146550e423e3d79f41ffc7ca78c268e5f54d848cf5e81bce2a99b83b2d5c13330687ac599cd8c34b61b6732bc7dcab8ea15e57c5922b06e7d5942a06cb5c2a23ea3eb6b9f00af76fbfc4b51546010742d6820d032ae947abfb36f9bfce9efac924f76474c384b8a43cafb5b88b18c92cedcfb480ec713ae5fd56c8327b97b5a485bf84d7fcd4cead04a497f907594801d7e642894dc452961b2761c6e88f03a87bc62b027d3355821ae5292b1708d0db7252ac15954da690964cc560a768e0c1b7927c1fe124b119e676e9228066bf59647f0eca1a566948789060b04ffb4f95a6771904c9197d36c9cffab2c3558d11586315da03fa46090167ba9c9921556203b07a9fc10b7e35207c3bfa45cf2a1726bd46d29bf07f06f29130a1eec963013323c80b73b648d4ca9d8a342a9598d539fc1a664fc5ba5039033821b75a8ff066b8465d9a7fa5089ae0c5fc63e04d7cc4d7cb571c6d9575b25691f345204e12f179f7bb4d172b5aa6865c14c29cdfaa1e021fab181e8b5c53b9521327167db6e843354dd1c84bd801a3848678c5d659ecbcbb5b0c43b16167ee8d3cfdb13cdcb8a57657dd890e6f02ae13644b9a154807f047cfae23667cb402c1439b2517b5f462599173da52908db40ca925650f5a5752922a26fe3b001bcbcc388644fc04c6639cf3b73d676ee36ebabf2b306789a02dfb7648736838682fde49756b68b959082c5270e6c12158a249093bd710f81d94411851d92d0947cf046ef42aa975688a96a7ff8bc980c70b68f7d32a9c31ccca941a1d287156d3d24342e821a986985432daf4bc398abfca107a8636cdea0d995c2672167a4c8f495558f923913d2b62504f1b2350589e541825d79f98d0da4b2e8e2ca661c21dc0fc8a8046f79b1dd6821f00ebb17789f748a2735728fb7cea6acdbb0562604bcc03b8108fb893f1ba0c848c2ec8d43c7b4f319af74b6733b798ea49da1cf2c2c62014db2433a7277bc1827c1","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
