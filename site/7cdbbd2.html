<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d9dd2581c16f032a7fb07ee0b6648f9a5d83bddb4d4c3f01531e5a9c0d6b45fbb04604e46f1be092064c5f4c636c8886a1cbf7e0d62f494fb36171c6a290040977eccc29ce1797019da5a8802fa6ce3e304be5b59d6df16b984b3aaa7ea1f6af28c37719ffe7d928224e4cb273818e28951063580cce6b582db481ceb9a1eaa45902805623f90612cf945fef83f1650e265809d0f86db8b36c4a7ffb86fb15bb0a589bb78a45c8ca290c96f4a4e00984ff0610183205022b43ff2e79de4a364dad2a5c5c9a2ef9b825dab2e01ac17de05b1ba18842e2ba1b5e47d253531c741f1b6e6252a290a1f624aed58fb1c2fa21a43079bbb725e57217342ea35e5efa15ca60fdcf534bbbb8ecc7c0c0ccfe80c6241b8aec9216c90fa952f7488cde30b36ed6ab13a06b977d027b331b1d45f603d09932d4cc6fe58e6073c51b4fd4d759fe6b3f99e4e1fafb80caf73ada78fc1a2a3c03bd6ac56f7dfda5f02fe32373e169c3fb72a33b6e0b396b64339956ffa03b03a952d2ad8bf45d95f9d2a443c3dbe319b43ef52403a34cc7784849ee93f5dcfe63df5e9999e64c873f844ae816018923e6cc754a07bac2946fc3d3065387f9fe3710eff760a813854081d18c5f4b07c5f315c0abe1e5ef12fe8b9ee1c6682a471827c450216f3010fe1e53299674cbeeca11ca51fc6f1b2555847b238c938de314107a411a2d049fd6e199a16934dc3452b2d8637c8751d53c8d2ca8ef5cc4658aca50370e5cdf1483e1d6cbd8eb3eccbb4b5a4e0b5f2c623d3dd6ba407451339af670f14c5406b2f47ae71ca30c30b63f1310cd2078b7a2b0c71337075fa502f08abf2b5cb80a4e26b74a52ef1613fb60c103e3b0a393f6ab3e5a5977b116b2fb22f8e6d468752bd26b7ebd01a7b1ed6073b9ac2a5d2498989b72655e7a81a667777b44bb569503dcece9adf8752737ce2eab5e1c2139b592e26af5369d824b87e38d6ddcf6010fb82ca26f3f51151167e0e67055df6e0cd1c756cfa8a4d46dd955832849da7c955d3d460d65e3bdda390e40cbf8cb15eb99370205c4fe69952e2177db199d545c2edf485ea423aec64bf04e7ccd5e4696fa9131d076e2f4dc58c6b824e83b2be75802af42f17ce59b7e23241e28f0d5d7bc194b1c5d60a0460ef9461ec18d97cb7d9bd975cced4624df228ab2fa854c154f6cc4cfefdf76d8b81bf08e843a03393185cb1ac5ac2552743f2ba04f8ac595f02ab05619d8f0413990c67b96235339b55437c7712edf03bcef9070b94c3859db2453857dc8729b3d22b0125f8cc90356d12ba3315e62cc7e63531c1688935a5f608d1a842cf03310eb0d5c911632546fb79a16b40e3d4bac1349234fbbb57a0cdaab60fec246a35b81b3f8276a37f3484244eacf7ab579544cd741fa4febd70c983b0259d2c69f26e0bf0e4580275df9e6b3187799a509b5c536138b8c74049d584f74f995600dde1f497133cd50451f353497382e0822fd8f915d8f34e1c7e4b5fd608c6adcbf57073663c0cf55c78a045102652b7b30a5e9f4508af326a21c7fd09dcb7e98b30246f80b6e0ce6b50ea3b7d15b28ad5b444ef4cb9d6b1feb7316550de7f2edd075b3d9725fc4b6a29edfd9e2cc4b23c1964f6710792b2b43399ecb9c3d1036e54fed00d260a8d7d21a7f6ebb57eeb999993b006b0c191f78a5449327b78a4a508e0fbe3cfaca7263760f858517f1f2ce346b71b5a9d411ef63a8b792abdf5b7ff207105f6f3636cd82f04431085272eec0b95e7abcc823daa9cec745dc61fdf8a682d7cc0a216847ee0234ed3f334415088a6a379e45e1ac811e3f47872b0b8eb2ed75ebdb0ee31fae24ae972c7ee782c2d7a52cf0449af1e32888ff481c179e0dbd1da89fd58c58ceaa9b8d9e3de4d59abe0e809c4743572a56d7fe57f6ea3d059e7008557d59548383cec982e9142afc20bd0189f20dc0331549035bc57d0e8b4724438481b54255458b8ad62e5d13dc9f3091ea9d8e3e32a58c18c16f975c280a17964d72a15caa22b4b135ede2d80a65b1b3d33ea35677a67986ca3c7e15a6291e7146c2c94f0c257f99bfc8f62db8d7cc2e34675856e8918b6a2935518c7a4ed19b14387fe2484ec880ffa6120d362c62ed57bfdf2c89d17f04e6a14ecf24a9b83b6955847f9fc9dc959cd1a1d98a8ac4027aed10dd87b2bd3d507b3aec3942ec03302abdf98adfe0ac9a59c61bd2bddc95c9af599b90d3d0adfa7e0f967bc0d0d07ef5681d5137eccd31fb720d7d95d9d2b1892963e0feb2505c698eb899fd9e2fca4d104cc52205dc91dd3c3e50ec488312c3caab7d16cfefdd4a643ac0ebf53b5be9336f1b01346a0bbeb80260b2e9dc5be3d37ba77706022915082f43447c6ec5288ba78178539206ce8f120210509f11396cb75955a1335f3deadd9ca540fde35b0fa8d47525acdb173204fc140d975b8895c3b84563a0fe04214a202027f8d4dd5d272816951f3313c77aee210cca85cd4aee4b827ed8dc05a1e778c23bafc7857fe6aace7976974fffcdc64fbb8da035e6b895c4679e049427c90ec29a486c7df6939cf19c8fa4c4bb141a4e160b287a059600dfd6468187c7ce3ab4470e5f2b553d3e12c798e1d8aeb52241f9d3c7118cfb7b7c53421a5da675cc312b4694ef944cfc08d19f53dce2ad5084cf342d6a6c80bfc0cea7d3e9eebbb47fcf1df432a2c618c2cb02805f368bab4d8d5887203534a6065ac34cf70ce3b498068595343c9ec2c47af8da187ac46064f3d502e3fb2aeb4bc6abcb0fd7ac9140c5ab3ab6915400f291466388bbdbf30f3c9444ba373a7fdf24267e0c0797386f120f574bf7da56d38d2fefb884fe41acc63c39cda38d967c4558881212632495ccd1ffb706ceb9fa11191f179ffadeff60445e157bcfe0137b44c1412fc12d01752caf3ecfeb5a0f406ae546d9b22b904372d56281344ac56cc2200cb496e9aeade2139b130f4c8b97ac4fd54e04c24c58bfbc3725b677d1750301dd0518b8b4dbfe0842008db8654f60e6d697d29965084df4c50aee7eda2819a7d9b323f1d82554752159bdee8f9a8d96608f3c521fa52f540d6b1c419fea2b2a68ccc957dbe77d15a40504af2a6a6ce8910100df6d57df1d43756b1ff8c991aefa24e7d8dd28154d00289426c9e248ef22adf725a072286c1802712147fd17952f91db4764624cb3d38e165a6170f765537da1da0ebca9b02c33fc6cdf766accbfc2f3551bef47a342efc401faab69acc39823aeb7aa818ea7c118c41478375113fafc631a17e0245b2abcef125662479740dba3b7efdb694c3400bba6d2eaa25a73573678b3fbb99eb723518b99617c34cd2fe4462f88fe4c970d5945fc9a8422cd33d996dd61aca5178304ec5575e7ff0ec665ceb78a1137b579b6bf35aac0a7fcbc452c8a1b71a2841b2ab7112f69bdec5e8b164610e5646b377f8db2d4da890e3ee2ef987013af2fbcb8ddb3711fc16b12e2c257dc6dc59c3994013e653905576da5269696be159ec1f16dc61a51a48c941b251b741654928a779509bb0b04733749e8680118f61d4b2b0b144f243cc0a70e04a86ec4b81e81d849b2a5b5e5bbc17528c898b46eae6432e2d4920498bce34bdee99f92c1cc934d150b1c57a62dab54f2882916ebb32f42ccd88b0befed93a985ebd316211a17dcd53413d49a82232a6655bde750f5f3d4161f590c94bbbc5c72f03bb68a0877f42046c37eba756fe6589b73993d69773df945b1f986eecfaa9896ff7b1ea7c3c5acecd92f4e2e8c956078fb1e0eb9cfea9e27d2d84a16ac448bbb0adaf761b0147c391f4d237252b4f370f26e952be7a76e8c6147b0d5e0d12a831d7af620e495331fcb7b7b1f462801e752e4e4bcea0004c7b0798dd9e2229aca12f071c2379e9620fa0d1abfcdd622b78425dffa48dbd2be46a8d7f1828e98fc4fb2ac56a6e5bfb72dc1acc354a0bb8167bbb4e03b8fd5fc9dcc07a87d7ae3636396be3bb0fa0e2c78cf4eca6213baffa6ae54e9046439398178008f1d5f846d0d0c2ce4d0c2fceb9d23ac51e305d784c035041a3eb12c7204ba829f0d7a413dc9c954510f4267673c9d6dc3d953e4dfd1246ae6b1c370997664ac8025c395a1f3200c1e914467f2cb7db217b66240c9aa33ca74993b2b57ba4e67a3245a3f0eae4fb3bd2638cd7d2e8634e5d18bf3cdcf35334448cf93b247631d0002311f73380099f82297c48829b1ca6464f192caf4fd5b54bb2f8ce6938b1ade56ff7f44d9964f3408c9a6385c9cf7458241580084a84193efd2a99ced2af86a56dcc9d82f48dd9950809fd3c5d8f9a7dc0c7c06497ce1fde00caa05a1670bfe5e44c7419c9bd83fd9583d42b1c235150bcbd5f04c6ae7f922ac24f8de247f40628de26c0b49b161d9f9c5503e1a9584640c35fd12e7c45261ec0a854f3930498c8e0c61888d0e5665d674259f87c8d8f2c2fbfbaacf27f6f23e2b52ef532dcc9d2aef0fc89fe5acc7e77b43989b3328fefc0bc5134193cab88e76679d44284b2a6a00060a6acc21743ae0bc522a9a5a5629cd5aaae455db0e1f8c2b3c39b454d85fd37742ed44adeebc31e90bbab9b441943fedf11f698a7c2e01b2f0bf2fb88b0816577bfb797aedb39dd99ef82338bbc5ead060003ceda80c0a3affdfe72ee061e106508db7823a2302a749329a3a3afb5a8e8fdb2bde8d1a25196f506d41beacd6022a64e78b3cb54dbacbb0b6562463ccdd21eb5c721e110645cafd15c9902fa43c68ce5096c8fc530b15e70b5a62b28c7dabc54c633d30aee93c1096ea405031af5e4525bfd127f3d571f34749faf1232887656d58f97ba3df058378ccc2b23c03bdcd209385b6e596709d59a9f1bbeeb5d4bed2ccb043cee79f882b9bd2abc80a721eff05c992599ea1a61cbb7884f91d5b153552d259abf20f2cf31645216a280a44ae9d33ee3c1e0009d5ed8a6c1d2cdfbcb91a5e92bc81f03f640b3b6d368abf35c340898c258eeb9ae51c47f680c12ff4cbae91e1aef122602f4ea37564f3f17290d55f4bd51338233cd568e6c0ea2499b12ec8ee3ec485fae4678ca8e44634e2423c0eec247dff18447522548c7b2dd5e52aef7bee58e900ee802d94827863529813ddab778731ab068cc17f736ae34a8a5443ec62648e63215fa0c2a2ea5280f2771809f1f981b28b8b6a640e9adef3df9f3a698fb6413b55621b113d9e557b5b324f4655a10cb46a96c6c41412c82245af5b0c7f33e219c54f129d00124e216c2630715b811b34e95e6981d60a123c99a5a6ce5153ad27c6c2ca55c966ce30429cdedc7272fb5027d8dfec17c734a260e0b9a9aa351245f9c991539ccd571e95d6631e304a067f5a9e6dc262da11589f2e2b7842a4424ec71c882e65758cdb5d74d972f37ce89327c69a5bcc160518d768eb97624a7005adc963be389bd10456a2bd74a3ea8e27818fbde7185f4605aad23d3468a7667e4813cd3699abd9dabf81deea7e42adbcc915b5aab32b0a82c1bf62d47f86c678eee66a5942a5207b42e87dbde0b848308a57b6021020beec6b2a1d6cc420265a5ecfd55dff9ab2525b0589c80e508414576823238ad106c5dfa0765e47b292fef73973d70ef99e4cd4e0a0ba586642ddeb3e55d7ee11431fc0bba7a51e688238ef757310119be6e28b11f91141b02c024a1df8d73efe6acefbd956fdecbb113e99e3e4a9129656b6281837ba48a75bc73d9eddba6e2387e6d569c59be12c37039eb34134610c61cace451b433e49684a207ac865357c81c68745fda443bcd83f272a2f947fc96e43e8a92a6d77c7a6e5263b9246d3b9c2580dbe166b2503367d9276522921a46f37775b7d1cfbcfb2ccbd86c357fe94d37a1eb6874a65fccdf91411393c4a70e3dd2145cba81e6d52d07ec76443aeaf95c8ed8951f428b47c833c5c8de36bd8386de54aa76eff0134bfcc636d8121b05e447074576ba4d9f90ed13b6954446abd5c04f682d4240ffcdfa00a1573e54205ee46783adbb3826c2d1b448f43bb1a957946aa40dd324a3395f1c96913b7f28e01d81cf65252c5d0595f6a386728154fdb589a858bde061d32cd6451a20f0d37966e86e356e49e6a5422e3ba57e3fde08b6e5f4933882048deee6e6c85fd755ea297a1e113aa6fa43019d1920b3e28cc576d311a0672a508f204c1c716195d2a28308bc7a9e5fc9e351bb3a1de0d18b6933f79196726d679aafd69d86931942f1d5d0ea4260df99bbf919531b62f36470fecb4dd857734aeaab12c36498b1831391dc17bb47170ac1007059ea637e93f06da51bec33d58fac673cb76c51f69b5ffe0ba7bb2fabb7e6c20a7d9a782f4b7ff21ca5b759061e535837399073730dbe494129b723b19a501b66e8ca68c9ff463cfb17e5d8dfd365cc4daddc8635c4e3ecd6cf96b4cdb49b2982756d4a42d93bc730338a599587709a7ca20b7f9472d8295e55b66ceb0d6ace15df6583046e56f1258ab0787cddf585faad744ef74a7e0c5e8701de005a4a42f60e9b960a845834e3fa33ac5edaf23769866d860503fec269e9e6ff0405d6f298ae340b9748b87d46e33cced7907f53f3bb22415ee719ef911e0a0e219608edceade990de8a0858b967fb83505db3a3302ca5933b5ee66da5a23a215dd29f97eec8b141f10c2f339a0c784c3f1d3427d22f6c061c6fc1d20c4c55ba4710e019a7abaef4981583b52e4ef1c1559b5f63eb9ccb1f756ad85e5606553d03ecda7df972ad78c511d49e039f5118779343a1f482bcf10a332863fa123f9ce0561bc15f8d97f65ada45ee622a168962b0bb31eed9fd4c81f68880d52d180edb5a0ea24301f5acfcf774aa272dc2c2e262993cda4def2e7484b770b1e3dccd9813536070f2d5684522c3c4831a27d355f8e4de190dbd4432c09313a1f199fcefdd04ae335740c354adddd0836663035554b0482b2e9b97c4ca9880a8f6e9543c64836980b1d1f0df2119df1209abe8249094977b8bda79a3929ac27ec843ab234dedc2f29639802fde0309e67b022814f98de0392c37009709808a307a162a9a076ad014f860cfeda5c5322930b6f4c7324a0d957881b0ae0390b705f39b490fcc1abb3a8421aeb44b3cadfc3c67c149168c3d25e0931bf7dcb65121a2158b696d1c64eeb87c76ce3aec6814dd7f80628f22fadffedbac07b5ff62443a63de15792b6dc3431aa4f1311d74e79de8cb8f3178196ff62d1d1707f3a6e64ca70f972b4f9b7faf3859d8a37670b8276fbea2b13877578f268160672aa25b78c481779990b27b086d83b59460f9a107ad2e743ed46c9dccbb952278db06ad2cf51f71c9b210aa47c21c241c9d0143ead3167cf37a65e46967391736d74d0b3513d9178230f92e0fa1619a63783547b953a02d23ae05ac09754f193d1f7d4c8f6a8e9ee337dca1b3a904911e761addb4d516ec0b6c2c5dbcedd4f3c730587b7f8513c931499d7dcbd537eedd570081047f77ecba7f5a569e32740848a1517825883935e315ec237a0118ff91d6fe667f3645fd3394080aff61fa7664575be9e20d78eb0858ef709ff48b85e814ca5e52a627781e94338ea55d67e9622e85d92d71d518e192fc0e48d0425431aac304912ece2b4fcb7a8559d1d06e54bf20269fcf476a216c2004e200fb2adfdc04381ed1d4f44d8710c3c691a76ce7561952b844cc91bec4f7f6dd94f080b549dd5a222888f140371e8b2b64c462b48c0bbdf65b1b4735549542de499decafb4f4f0989f793207e8cf187e3dfcfb6e087169eb53b07712d8a1b3ff34cd28717c3c558593ed463b2722f1a08369f828f337e867202e8d0dfcb59653702fa10ad9c5aa65ab0fd8edb1c97dc21eed8084525cdc7bcb40a30c8ad98b57467188451da0eca85f2d02dba035bbdaf4843e44b9a486f8440c6fb2352a64dfae7349ac8cc92d61234c0e8eddb49f2ea3f45170cd0f3d76269d889458403584c7643d6ef4d6b61bcb37d6dbffa431f3bf0d64fd9722d57e53f089baf0da97d27b19909391067cd4504862979d8808b539772b7c7706ae18454228e638d7c83126cd15654df1261e4bb5bd4944dee752b9967aeda1a415728127e4faa9030ebb05dc78b1f8b3d1cdcb1e1f2a5db11545f33506a20bff2282a61dd366ccac176a7e7a82020a8ae8fb62f17a23611249d4e401ac0963a9bcfa4c467eeafea13e6f0172641984083361382f5e921a16ba4377a6d76afbb236adbc7f95274d71b8e0f36047b201a5792238a05a4d5710104a4ede1a0d3e439a572242020c22acc9a4e3aca1823e4938f739d78b4e8551c0e63409409a749a1321cc13dd2872710242f1e2ea3bb5d33003a559c822bdc362e40850216ce0b00a89869772cc65fc4f053ada691221e32e464de56927f1003881c12129866538b1cd12528b3f12b33584f2cea2038460f83283db1a7848db9ded570763aff1b636121517184538105d847137b64e2ec855b4b7cac489a365131e08c0ad38250a833b4d0b12811a247a89e2f2402435c848c5c772efaf63429bf6245e1a49d9b16e7d3a28e29f5aaf81419c43abdc621e609d0f4ce8582f303b9957d41202cf4205d5a78a886421a607d43970c02bb9919c932ba993d178fa881db3658b5c40dd9de74ad38b64b1f6953fd18b27800c32118e8d2626ca27ada1085e1cad6e7aa75118e0a111576d110d3cb7784f09da6900fb3774a00473edaccde0e882c72abd11cc8bda2b6699fa07667d7830139a81b4d7964b5687a84f6eb372c9f07ea47f240cd1d1d0932a095138185610d77da36c8d089851f069c3968b0879a7b9a4d01a47ed6871273ab21b46ef721781697c2d1fd194afbab895207ce53d2dd7903bcc60ce35761dcfa0a242840057663473b3b719c1f54a6f68ee3f1c5ef5ab3ff5ef3c2b4bd0eb0193314e297e1d911dbe911308ec0808b4a8cc25edde224beddcd2645588080e9905787aceed6a9feb4cf7ac1672b9d476b63aaffd0605f4547a1db01f7d2a64148125c0c9411b05139686263afe9df94b16893b82bf29bd885327398b320cff4fe876407fdf323b13aab5e7784212895395dc539bd41ace92002e057c444e7e23257ddfebdedf26938c8a1899649a5f94894ce46ecab39dded19b680a51aa823fe080a13ff1718d6748bbef31764879af0dcac905dae13b941b65ae1251970f5cd6c93f6e88bd8846b0bf6ecee5f5181c97ebfa8791373fe9d1f113016457fea1691402d0d2a318414398fad7cbb88ee6370d883dd0a82b571fb561c289287d45f6d28c02a6a2107718967d847e1db2501d4f27367b2633b6be2da0e32bd719c2b4141622073cfcb47627255321795dfe837db800d85db176ae0b9bbb3256c875a53719a6a77b052dc8faaeecefa6e253d5aafce801cfb1f1189578520794e992b917f279f25556704ace900fb79d912d5f97c6874605fc5c0794a04670a4130fbbb09e0361551863e9e22b514feadab324fd236a9b993d223acffda644f264f2bcdd0bc4796ce890f12df2da65f3de365facacb6b600508cb71857b3c44ba7f4a32770d22a7ec51ff8d05396e3e223fd804b3791023b863477990ffa8fb7ad4135af9c72e5d502e1b8d2992f49e40d215d599e766f0d8ad755438efa629c390a069026384f0206c0e16f463dc37a6d2fed7b667e96e24a3495edf261c88d67fd304dc415a254d605f255a10a697eb44c5da4dba1ada98eb1c4b83303e4e96a6b239c95bc957933f26571621d5df68769f55459e7bdf9e717e768ab2e3a187ca219b7d1306ca548b083d662c46e44dcdf298c1c37f6ea8a1e61aa51affb1ca8882d539e18214b4be326e84130db8562c2defd2b38ebe9be57454631aa715aac7462b0e812790ead8bc96523656a50535ed3b4bfddfc37bdf0d8f801e9df780c04ee09a08b2fbc0e9763ac938a41f5888582ed6caffb5e3b3f083427524e26ef988556e77261197d2b0d8ac1675b2ddedf739a2fe38feaf907b4a6014818de4a45468c8d0df6f153fe00257fb3f4c08966e2536934b1aad29280167aff521f370ff09d653dc6f6c8f263f2918e54e8239456a80cdb9b19bc9b3000b0269eeb6eb1105ac38dc91039f6bdc3e17ab98357d72491199ff5267e23477ef7beffa387773e87db9669e1e308b909f5d42b96d382aa63bf8d3a0fe2168adf5fe127eac1f98b959c80cd0f331a7af28b0d1ca701cfaade698a9f8b9d20bd3943f5d0ffaf65b31ba90d0a7cb1d99ff371268d9a0234085d67418740a53cc3f810cd79c87be411bbc8f213927a1f814617ec92d08a5ddff8eb311492ad88b681fc833263f346d00ff0fad36def0e1a8d9675e2e0bc6981950020a5d52b550022878574372e6ce2d6426a4656d7b63eb5ba7d30268af58eaf813cec16930da543f4c47b90d7744a9f85a16e7614bd8c8d1faff421f44f4762f9f2b57604785bd03280768160644a73e573e0ba363f4a2b4f641d8f52aae4430cc81eef45b8e7e08d251f8abbe804156b37bd5b10ba371220146e91488599816d7edc6d456b59cef7fb2804a766545ff3ad4c45854120574a08873bbea671c3321a3f6c9cbb7c5583bf80a8902b888c13b308858acb7b70e5ad2e3e316336014f45ae3ddd8a120112e7763922afffaa69f4f18b6d9990863c3050257eb8e250a708617850c2ad56c0495ab4e352c2c4e38d7a35124a57bb6b0c0339d128168165a5fe39ca743ba211d3193933cba83c4c6d059ab27932db4dc52d795f3b6002b927523149c270fe9614f67118ae81d123df442d32de3a489ca48d5ddfa33bc6a78786f97d7c809d563804bceec52b588d1226ecf6c986ae60d296f00bfc36516bfe4f58b26729bf8845b078c17c363df1d15d13c4b14f98d366b832c6e5d7c77b99cb7ea1e34724ca3734ad1aeccbaca2dd9a7f39280706f24614fccb72039996791c658108e71cbd46537b40770b6a6ca1e61443b4eedb640f42b35ab10da70e416f0c4781664c446a7fd54c2eee20a10eccf02d046df5bc0dcc660e1efbc4d920974da3aaf614c51c230d4a39910611b14e5bb8340ee1eb992fe6c43247064f67627f83ca84db55e320b5e899ad623233b86113cf3c081735cce1c49cccd6494b947f5d0594e009e90b12447938aa1e7d8e78de85adeb0da406c114f9276716ae58f2cafa07f18751a2592e114869dce24a1be58bc73888422839f2c49e33d18d6432305d3ad8764fbf27c752f3fc7876d277e0beb9373712e6c0dbb3ba7b7a733d76ec792048614c628917041495254d1c6e2e66adb9446f695576ecdfb88fed8838149a04f2ded13a16d54c6a61e5b4b97ef3d8f7fcf7fb186fb3fd379d5953e7916e3247cd02f2f866d2097a829fd9c8151b666b9ccbf82cd7369c20061b664b6944a944d574b529ab1863812f8570ee1dc42a900595bdbf54546f194c22e5af4cd7e2c573831c88fe6bacb3082d5d71e6cdc50eec2c402aae18b70d4972fea571b78abadcbb63a272e82c11a4c5292954e4528211560e95bc649d38a045665377631c97eca036886bf5411d640166012218e39de2153e2ffad557d834916d81c6493f7f52284091e8e6e9665d9c2cff03fc1316220fc73785871d60fa3394deb7f0891de4301c377893a97ba0c8bfd1be5cd94c61200467df8f6a827b0012a750325b0c65638d89e8084ca30b0cf68c6eaf103e3becdee0bcbad55d753e0b246dc0c79447d0879d3664364cc4937daa63e890f9801204bdd6f8eb798ace2748435368d3d5ca0b6bebe6fd74ba9002239ce7a80cc6fba4dc5fd50ad05dd6d526353a30afffa78374800ac369587430934b46104f2be9166f4579df20204b098feddfc8331854bcd138185f383f41b4e9ad26c334669a2d7ac516c5b3bb25a1990da45b68bea9c122d6c792bb623dd07843ac7c8c7c4bf4b218eb335c8bb8c354dc225c12cc5722262a471550d3c2dcabcbb5b97e43f16f8f549e634fcf4ace0e5e506feb93766ac63c3b06bf70ef0a7dcb5fa46a04cc3e8b94f5a03697a30828002e422a057d71efaa941f5be2dc66ccc9106d710ad7e56695663b66e5741e7c772b622d5b85fff3690b3cfcd3e6212917042da0d459678c228880b2faaacfe1c4bab534da5c251ce05ff87a2b49c0747f395b1dc36f9ec2cc4db082c8039761629fced1d81ba7ec30911ce39b794f65289b7dee29d2723e6829286685a2f962c113899667bd6d90ebe4abc702e9e5d0fee96b2eb814ea6d4e1d1c2b621be6e3e218d8a036d457b2788a9f1486d6a0d81611edf5397437734bc2f2c293f478f8a5f05e9f99e3d0bf4d36d0d1738ac7563ed80706be93caab0bbaec89a6878e7bbc3497cb87a56682e3b35e6b9161a65c8f17a1f2eea5e3b268d575dc42960eb5bb486f57c3c54ca71d2b866de8c6c4f004b2a34ce963ecd87c77a557d5cf7093829939efdaf5f29bb6ff09cd85e242fdfcbb8f83409b4fca3cba8c3f2aa101c50e3db216c7b3c363ba829e2251555810f34d7323307e6267794247a04a995193f367c32396b4a5ceb19ef38d5acf8221132a133dc74bda52df810c49a1740117e1662caeca566814a5bb08856fb59991eeb2234d1ed58c609d07ff309ed05e7706e12c68c3ef44464c8e2c96ab94f2cae3db679510bc6173d7e28ee6e0e5306a1f7915b3f345528d67d39c0fe5a6e374e3e68621ac14141340cabf763916ce84a3ef578b761e2d78dbe0c1ef02707243cb483ab01a135c2cfdf6f1128beab0c7e096e6ea851b9b5f3a1f1d4fa8f8a65b22ec02ad2136f337be07b2512cad424fa516fc87743011a9131cc9fa16de2d4ed4b64ec1aa1012f532c943a4d904f9474bed76889e3c7fa0b4acf2f84e75dca1b29d44ba585d8891ef2a3251edc94ec7669dff00ca9f95895da17105cf2933f0faf4696ad527db4618eaa1297d1fb4fb204a7ab822fba38a952deb257f8dc00a64ef90f4592d3aff727c0389d770214a3876fa74be30a2c16086742dd168de13c45adec18fa509568e8f05266fc03fcf85be648b1c66d4f9ff88e6e4b6b6cfb3cfe720575b16ff478976277adb0a731103bdb71b30133550b81ed8f832daa4e65bf20f03ae7b96c6df659b2b60d2a447b5b4a7fe557903072952ef73226f152ee1ce606f7a903bc0c5a0715eeff3dec4233e7e48217f37775f58cee4ec688eec144b96ef9bd5df7fc14edecd8a7e9e4c37942446eb7dbcff39ec44f61653e0939dd6d2daba3a608020af5666db7c26a911ad63750f3f35ad26d78db01deded5a7c441498514e1dae955fb802b89913fb73b88cb7614ad547f8797747d86d15c5cf5162693ea89d4ea2d9458c14a42f6c3c60cc588e4f0f139025a6433458284e4ee2e9ed74ee787d98cb0b3c90026afd3818c69c52bb32a19a8b26daf5b6bc27dec32c5bf7da05169ee28655c99ee0a18016dc00b10fd8b35c971a1aac6f0487bf7e019a2e7c843d28e5a2b44f0aaa956630517c24b2b072472e170869aefeba1bd2dfb1dbc5c67a60a8d4f1f5e021d4005ade4ede6c4588531b9c26956a8aca84fc7e60a8d8cda137316cebe00c4724821fa46b81e0ec966379cc2cf6368e233d74f41f1044b1f3db5c5f9f3596e5b11efa1f2335fb3172d8bae6b4771e8db7fdf54d0bade279f93ff4fc418bcc760638f878c5253f3b366a3fa8f0d2252889cbdc39006c7eb6cddc26a4dea7c70b51884574d6ce950ba42f6c295f2b1ecd15c59beeb2ae861f391424ac597f9a13c6f48edef7152633ffee33d976736ce23c60cc46c2bcf69bf16b019b4ae34f7522ad92b30138f0d1584563f0ef026909d9968d35e7bc8acb194789a170be3c92ad4ca613efa026b825c61e4b10106e07528fa6916f1d3e0987bc2552c10a331d01012e1bd96f7afffdc34f84d789c49c2169053502cbb26051aaae32e43581d72a063a941ee1da238b2a96f14768bed4b275bd21d14caf472e564aee97d220b7a4876acc0492d044b7ee7980959339c22676ce9fc9ea29b09aa6273e24d5715ef54f01f08bfc8fc29429d1235f8be03c51dabb0626ad2b2a9a3cf391c9f1d37c24b60fd1689f8f6af1d3bc1e45b024684bd7642b2404fd19820fb107fad02c0b1eb24ff43f7793947306131fd2830c9bb1eb6ba05af73aa520d9903b43755f4f125200baed3c863658058ec1b283df6bfb9b3ba4396cb39acbc5ada0b8efe5480d8738650189569d3c1e6f8895bcc847b23d50cddd245c833d87eb672803c221c91a331964be418c3f4566c07cffb895486862e94ef5240c0dd6a468a72596a950e75ecd01d8e634b2536309bf1e58e31894ff350735dd1e628b765f631805c248a3932240ffad0675c276968df0601f46ea03c780462f7982e6986b076444a29117202c99526c3016d12c2f0b9e4f5ccee85463d841e1297d6440bd946c5873f266acd942ee9fef69c15104a57af7b494e306af0546fc623ecc8c11dda7cc81e4ade706a7e2dc3218dd6a84ce577fab8a2d4f9f30e7684dc298dd5aa9b386a8521bcc65d8ada83419fbd5dde1c61589a976c4462b4ff2b1e05160400480d09d089bd760bae8ad1f5099e0347a59c77c0ebc0d8e2ed829569f7985b892cbea9c60a7a0f17a16b6ebf2e8365b4420cc8bc82645314c5a1d070037f57bacc3ad928e8e4c094c22ca92c53f18a3c3","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
