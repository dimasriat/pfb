<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e8fccd525fbb419376feb48bcf3c3ad0cd2449567014cd3e26c3aac6a95735f625ffa9e1d0c7795fb4fdb888b0dc82a966d2e0c212072402a9700515d8a80009826f2ab8eaae92288657ef507ff42f8ee2b3d8bfd152dc4cd0921a8e2cbeabe51f1e657f1dbe55b94b89adc110233a93edce96e88269cb1cd89dee074dadff252847895fdb46ce35674d36a7c1243278d288776f358f277dfafa6da755bcde4b7ad65b6f07cf476748783f73d8f143871fc7fa7e23ebfb594f64aeebad97ab5c05eb477fb6d155a2d46b457f771f170b31bdc61e3dce0dbeeab953f394f0631db2a657c9992ef57d55f6c07c4b31c5b1bd23abb063a5250e4b3204affc910b6fc1fbcf7dbff13d9fae59dd37220d0d6688988909f9cf51a02aff29b25fa0d13eec521cd3af9a44d2a09b2243232c28ec1c4bee64c32d2eca1a5d0c62c8742630a6552773f565cd86186eed0e04f7868045e6e54f388a37024049181c98df2fca70538a04db69bd28bf204373432b5d6e4b6465cb7ebaf0885e31b6b22062d7546bcaf57e9d3277c088e25c53305d4792f489c2db51843864a01906f04d393ec95f7be592d9ce4f80537df16a19aa44074719ecc4df7bf14448e0c7eb4edb2094d8eb703e7ad6bf35c678951b421d781a231f603609fb23c60f7e9e74359c8b193e08e67767a6e688c76e0fc44375c477f84bdaa6c0a8445418ae4b40ef03072138c0640f9e14f28289364e4835e8a20e46372cdcfb0915ea52a9121d28cc5e8e63b7f2eb79898a5811427c9bacf5b1b8c31eec7033738d2c6f536d7a042fc879979187613faf601d7654a98213e79c7a636bde3662d2853505144df672bbed1394830ef4814328fe6375e5b62ab0ec865d3b6b1f396713e551090645f0679974fa0e6a7a0bc589c7a7712bbfc46ce4341029ac2deeb38c1b2562230646aae368fc582fdfe791e89fb1cf5f2651356223fd8004ccb757efeae5e791dfaa842321e539753b9cadd03eb1df19b763a2393fbeeca6bf16cfe8c6118b5561cf910cc8c745ff0d3687c32e50bdf7743254db16d3f775569cf446f7c1581f9347101d93cfc216d0351e422425f6cc545288e88e7bc7d6adb8cccbd09f6eb053c1e97ca024c692b407944d2f71e6d7b067a3d8f3ecacf4f2a33d9e93eab21edf8c3d9e5344d60241f90b2a022179395e681fd503a3afe5bd6e8dea00b7f8397acfb9aca81df40a2dd384937036377104735d0719fe11ee60c176d116a00dce4f3680f43c87d231ffd9967856adf042dd3d5587b5148a17adc65184254d92d38f8114dfcba355f3caf235469c1e6de274dffdea5d45e373ec9a734f4e981c15d86c207a5c749f843a6f634c46de58bb874fc19616372757b84718ca7596f5dcfdfb37d6f0522e4432b332e98994fcec42fcadd2d1dd1246e0d6f7c807bbd7ae621a706c0dfb99e974c66bf71c005c7a591252effdc0fdc44d5730233392200259721334807b70997a2582aaaf07b5119b93223d39f00eb952d7d968abd006a43bbc653724a661abcd6850afec4ae61c367f6e607750c520324c167ed569bd5dd0c418083cd88858387b82772e26629a01abc53deee5082481321d16af19e37d22d3c24a3ddcbb6cdf53bd159e71684652d3c67907339fd96078bbeefb953babeeb7c20d80581c5dc2174f17632efa7e4fc0dd149261926111daafc13af5e8c1a1aeba6235ddfa05d7b67ed02fb1790ca03b4f00c50d1c17ace4574afb2adcc989862c3603f7d24e0121cb99ec194aee6a687017f8ac94318dd72fa616469cee499b173b6b9b3c807593e74674288fd39be29e8db55818f080a130f99027bc937cb843bf9ab0e7144f3c290f9f5bf4795573b48a04939ac1b8db35677d418962769141b2c0029be80b3b9a18ce7cf51d958b774f18503544f8f40cea107c989f1cea1092ba68c8c2419353f5de30dfcbaaf922e9e0fc5b03885e41d3ecd68e607963c4dc3e065eb6e0295db227b47cd39ee1d35aadd2f2fce5675d8891f134d3894efbd1862f65ed5d3467c1c36b6fb91ac7f7da50bd7566a907e351e205627a9f65eb489af3142727d285ba8a37112a5260662b9989bd2f5d7356865332c3555e813e7251a07cccd12b6c854815d38ef89e6103afbdbb3c00faf9ecf5272e5ed26a8bdc0738e57e0e123bf68cbbf27faa3746f78a04fa3940da18282c086d6832c77f049217c56ac3d68feaed826cc9fd87011b884e20493ed501c04672def0d3dfe5bc2d955ccb5764774aa8b176234f5a4df1b7c2b9b7dd8d55ac6071a84b2a79cf4a8b8c854719453f1c24049a3a63b2c1e9d4010a2b4632c86ac6a29724566f9e60c3ce72e83696032b319cf61533810796ec5241d0563aa80c5058f4cac2b8d7942aea0554691d25ceb346aea00d2f07d4f8445b97f5da31bd36c050302437e094b42b6ec9c92947d1b1a7f5513cb5767acb2274786f27f3efcab7fc499ab935a8582f5c1fd0e730a3b058cb329844d3d69fc4da048026b042bb4ae64df03f8d13a45d8dadf38cb48e8327e3e839b7cd30187faceccb457d13ac55669ff75f7ac601c3c02843a07e1489ec4dec088dfb56104b6e3109122ee03382e562b187140e10f15fb5fa52fc16c43d806073d1f5c48bbd59ebf976a4647d6665e1f5118b3a9bc531021ac87c43c15c88054a2489e2ebaa1a28d83f8f2e8576e5082aa2b578049b32288c4ad4cc437eaf5fdee321d4901513bc306518da8da74154a4a1e8d7bdc0720faaaff67f5f3efa48e084c412142ddda56d40b1c6e83fc5bc62253ef7370bc5b83246ff97144c9d5bccd3d6cd4f063681eefb41c5751b857febc4b65ec9c6a633ed1ecc2a647c5f76e0d2aec49ea9adb1d7b38712fd5a6e6558e4c2016f100f0ce88f843124ca24785706b73f5041905bb147be20bd433fde524fec9dd708acb3fad0c765a476b4043c5078a05e008dcd5545bc3d73bf5751d7126794c6a8009ff1737a40385ae68ec4a0809c263d625b4088ca2bac3bb04ecd696ebb37a5ce1af495f0d16a0722308a530ab4b0476f97c5634ca8f37b799f5d519607bf0b22691a5237106d3270ac5315f06eaa2da3d39ba0c98b5e31490975ae73f286c42a01bdf3a64dd2d3dc9691912cd2c23fca2b414e4d0f85bf53afca3fcbce472eb0c23741343905dc10af0f3d4b357cbd39d45ae4c2321fd37fac42b82c8f4871ba1c9fee34bdf4eab8c931a74dea79e104365666bb7fb7ff3d322b9adf60397af6b4526e6eb3d2e38fad12e5475a0ac48dfc447a182aebe4c1c1d965d0e2446742577a37360c69488c0e6c565ed102e4f458b103f0fbc6ca73ab07349359fe45aa08edf5685865911e691327d31323797a33a1d1022cb4f98f63a1e20d70b34ad5de8a1a35c10a10ded10ae7b862d9a3d14dac46c3f343b0a0ac14db1e004ec82e5e21950491868eb7f7ffe3025b75237ad9a1ddbbeb3c3444a89b7aeef9d490ad9d61176d784fa212afadbfb0690859f7c2d4c6279d9804c29c138f73d5755817c73057d1b39d6f93c405411f9a949f3444b26c3bd7115e6b45ef5de5dad4c0bcc6519a1285836b56a8b2ca41a39d2deabcddd5f5a8b11ffb77fc08cbc9518d0cf81efc56f7f2c693f4386297da69f2407dbc400612b430c7473bf13a43106ba0dc0e1ca56fc4c7b5e2e28a4287652b2837804165bca41785b58f1d1b9223d4b52b4fd8d0917f9c8387cb7dd4ba952e20e1f3fdd197ae12712dde6f8ee6b256ef50e40993e80514438d2316a48722b57945782008231bbdde33ed6ce8c1e59c75a209c9c389438818fa6c363f1d7fb8ade3586426447174e1a22e7323e33a56249b9e97fc91f9b3f0171908ea9ccdbebe69b9f821e2784258ff2af83f4490da1cb6a6002555abff5784ec4b38cc209f3a6a7f9339ff29dd0ab97476a71b05351b3f1227881b14d62cfda49579407775ca96040aa096f6f40db682c163c7855a67b770dc8ca295b864f39350c7bcbf52c9070bc2cde99bea73184bc34dd599d602655b8c4d3c992cfa95372f8eab325e6dcdd95e47917d41cbd8075a2e5c91bcce0b9c41fc787530770ac8550f40f66966dce77ba5601ffc7a1b47ec2c9c37d639aa598968822db83daa4f220b1eee0604695056ab005fd29cc743fa813b862f81499f81a406e874e45410adf0f1d45c5bf6a8c5fa91d8c2e08f6581a5ddda4d9b7567c2625c8dd8deac9b5554f35f0550eae5a9fe1487e9407f6143af3bae0d84c0dfee8b09e83286f597d6d130599fe4ffc5055c90a0118a2779e53d15f70633ea109e688e49d807b012606b832d882500ae57cc9b31973a2da6f927a4184e64d31d061763291879e3cdff1196f3353d90c89d5bf8ff067bd06a0faaca51c346c3642c54cae52fe4ecd6cef263f6adb718d39a3aa541fcf8a75f73ef4658f1e1140c369c93cdc11bc70739d4bcc597c2447f1a02f7c4540e18cb086088ae319945a1fff20ac4d04a3f0e46630da6e8137e1262832bd4ba7db7fe67578dc05c377e8b690cd65e680836b9d25b9a9edae175a203ec3ab4816ab72766bf50e125db63ebc02f017104d2f3b1d7320ee610df9a267281402856486482deabcf0972bea2cf050b9d7882944fddf3b3d1f291528a8c2f17c4e76d450f36f8b595747563fe28a01b96382ea1b4aa06f11d0c279bd81e18036d310c2450620776aaefc051bc690e3ff99896be386b9233e11cbfa23d8ecf1db3623efd87bb2c86d923f0c57b55878eea27aefe2462aa8761e05dfcda4ac8a249bcc4624fda3d8278a92044f07cb48de5e73ea08674e1b3e5b8353874f0f1dfe49cc76122b1278a939e700c55be852163114b7259be0e4caeaeb2b42423d92e95a135ffe03aab5502e44ee6cb50903fe9e06fbdb4b605714616c195ddebe19c8a9cc8bf9e9e1ae065ab19d7b9355a44650508912efbed11de45de72eadb65783c017e8b1618b19ee4cb8ff608a6b2d177fbda4dc2f7b059df3d9f04e5f72767e296bf4907bfb771d973ead68a716531bebb4531f862fdcdf0a976db6877d86f1f35d64c13419f2eb1a28471bab7b861b771d0989643b268c11cc2d1f45ad6c1f7a5ac6d04dee2269ac4eee35b06f5185d86b6d45703e2d326830d18053fbb2c47db958e2de1b084ac93e74dfadc79fc53fec9be38610da1f549ccad5dd390e3f7f306685580ce9b17c850315b1d34f6181db5e449f1382e12b86b0cd434bd2bbd837bc8e7e2f3e4f884826ef5555f6ac144389d15e404323b49b37687f681170cf92009ba222bf8e3446c0c22cd90dc40a4e27f1bb64651e2bd33c12dc25ba4efb36cba3656d23ceaecd678f68e08bf193e6528887118c8c9dbea33561029909763d99d8ee5dabfa3a3a3d2795df0ec6e168b934c64881c09026ba0415aaf3f7563694c31cee36efd9f56d306f62ce4b6c9820d6f88542f13e988bfabccfa91fa88f0a38d77468bbc526480c5e99b97d5840d50ee93bcec9b8a7bd8fed94a2ba59b1bf095ab79ce4034558244abf9588d1af52bbca6ed226fabca8276afe811bbdbecb714f3f26dbce72ff8e4c2a24bc796eb57166b8c9a1372ad5404d42cd52cbe0d5bed18c64a184e3a3395d9ce9925562a68321366e713ed4b064ba7075b812d7ca837ecd8466fcca6bd2441912d0c9370dc8870cc6ce9c3ebeeb36aa8cb72db8e66a08063ec63137032a4efd8b5ca97289a1171a5d61bfbb7a5618b65e64c30a5979bfe5a551f0316a6104b06192ff7e6695beb6efd983cdf4cb2c33d35f14b51d8279d9be500c97df4c83147706d19a287bdc51634865158304ab007a7e0bd25921dc8c0a76719fdabf139b05fc055538f7d1c019f33fbf74da2186f74420480bde581cc81330b9810bb67a703639cddbeb0cd01887b4194c80914ceacf93ed326369703fef1da72c1f1cb3261caeb7833b4f3df3205d25de32934fc1c254f50ee91cd9228a170390ba5fe93e63f341d975ebac945af961a9574fe2c00ec79163b9fb85b5e8705ea4a51853a1184c27236d9d3d1cd2911c6be216cf6cdd57ead3fc82ed2743d7a430d650da4a3e15f61d473f0ea4fce81616fc02e6121d0d85d7f1bd843d1d8b60bbf955ee121becf01046c044a5b910597666f3d45c4794dd21211c996c0cb3db3a04c1f3a83016acd3c251c737e848d8a7b0f8a548e6a3e342814bb0550389f8c5092091a825356bb5d3656ddead1e2b39090ff704d5ce8a940b76bd26cc8503c04e8cd884cf6cf5f40879547ebd52d8e2ced1ea62fc850422edfc6a69230b7af25387ae6ec163c2776941b07d09e6841001a5e1b2fccf4501c14e85444fb2d8c8cc4ba3a638ba8a8a505b111247ba1c773e07368e727d278a7b0ac845b9b978dc038449a37c59a9528a227344240d930f7ed8aca91229200acd6f108970567ebe5e52dc2f86e0e8fa5d412b16851239f6cc87101b9e64a4fd57e510cd75193f2e48cdd19ea75bfdb82ed69798494b3b22d0ebd9d358073813287b1693f1d70b5ec035cd8b96ec540fec093df54a775242f17b1e870cf9b01cdf9e18ea8fca21b9eb3f69acc8ea96dd35a82dd4feb771c474160e9a708a60ebb04a802a7bcebb0c1ed2524884f8da0115550e2711c7cf86c59954dc5a4551b0020200098f53e98765fa0c6b48872ded9980f2d1e779259e2500fac379ecb979ab67740cae09ef96017c28966a5a09df967e25ca0b63c7fb1d9a06e6f6fc63ab563b3536b3f64f38a348520adebac3e8da696f0e6f0f25d1b1432e0c116cca3120e96b151e550a1b6117724071dac8123a6d23988c4f976b5ee6cfe2d69c1c1eed70ac8e72ba0ec7c696cb334485f55721dfcc85054d4265730df4886d1e0fe4a8173a774289205f2a705b5e4426de80637c419328762cd4de301b67f374162252866f6285075d6e568d4854df1155ecb85f5c1199ed0fea0214949cec165fd478f53e5dc18d09ccc145d9abb7a7696005cb96d7982f0eb8c362b852548bbe16d4d56333240883891218e146c3cc27303013c0ed5f9816b7b63d0a601ebc89bc9753452ae332df14e4ddba0d992a4f95858e5c82cfb5aea488c6f523ea5c6b2307fdad2da1d1ccde099e788128486a01abd0f9818967ae902ad22c3e24391897bb41f206433298be66cdd5af72deb83f6a43bc673cebab13fbe4bef503e495cb3f1ababc7ef6629f8093c3d75cfe14243499cebcdfe04e939aa9795d1518b53cd3f0ae03e52904138a38953d1fcf8e27d4c404e90feef6bf032077ad0b1ae1127a1dabb3e147b3d0b86ecdb43c14203884a4012e3212a4154f25fb63193828b1952ed738dae541a1d0d3af767fd1cc4d8fb3cc5632c7e6098af252a8c9295ef68dc6f57ba009287df79ccded3b5c23acdf882046bdce373401eb5500cfa3f2d8e488585139ef162fd918863ed341cde1ee9b6472469d4ff8cba5fa266338eb889ee8058134e4fac9a92d1eddf346b6a0378e8db2068b6b2bc06eb6d309d1780a75c327667aa434085a42d2ab8640c51d93ec4068e30ce0d6e0c6af56037342bd07e7bf85f79806e62c6f951df18d8ea5c86cecf2db9477fced07be4663231c7f914aba8b896632e72c8ad0bf9e92429ffbb763bab8bbe09066de01ae1de416773cefda380778ea14d44545098d1011d52af93decaab3fbd4574e141ef7eae7a0388bc35942dacd3be770a3d1538ba7d7594581f26f6740df00411d10399ef72c9737bd47c0a9c23a08ab3b20f09dcdce07c49229ae4556bd378b5c9305784ce7bf87bdc00727a258402c77297242c56984cfe8c8e3455000593772a4f1582b956652dc5b8cb7f0782a049dbd98fba09b7bc3ba874811e0da9a664a3454f1d8e061e44762e2138f55023afa1feb26d981fa439dd2b7dd223bb4d52371a8532d10918afd1cbb313d00ab7d5ae9b1dcba812c265abeba10c373d11c8d4ffc3ee75c11eb8ef796e19c1ff900634b6523ecc030041ba6ffe2c8895e24b9cf28d6373e690d4c74acdd91bb6370afac3dbce34919aca388483a4c69126676dd8b43fc94943c0756599ec1e3aff35d5c00e5594da5b0c4b10e89b30e45d5e76835bd78fdb233c61ce5eff24544525c25375b52e7aff3bd49533850e39f77c9917f25d518ada7b39356d11f2bb4346413ebd5e827f4c338e08237ff485caa6b906070d4eee0b5d0c85c0253f3122d37d745a3cbf3f1ddce6c2421eae0c1e04b5bb00a69bfbf5b8ba97a432977c2086f347188e0c30d4954c6d68f3bcd391bbdb6a9b4263074e7529f0e1b03892bf0b14a679bbddce26a25481e8af6206fa4c795916703a291a335922b885c8692cda67996a044a835a1f9c77c74fc12dde978a1fee4d186ac1f39af1263b46be5b832b262242798356776b5197af91396341f4bdb723d2be77075b7529ae63d185f7c6823584937a010908cdc54e878fc1491eac3ec6211685cd2d6c5a38db393365ff268cbc9e52d27079282527a3267e6333448b14bcf42b5c9a96158fec3a9ea64a683fffe104f43f8e5906cd93cf93378ab98fefd2612154889f16744420fc9a6e814d4cf911a2b959643bec854c97e47b8cae203b9af4d8f5cbd9f4b3991c47e4866a9f32b96d3379e5c457d75f82c934ec8484cd7dde1b6d65b80cf29226cf57bfcc6a2cc2891b2ab408cbda0c8bd70dede6df9e2c708b522ff3031f60dc0ed84e2c46abda6bcd8c7833e013b461d16250021014e8b7b8710635145a7191a7a76f16bc3728f27f40ca77e804b07f5fdd3fa16e4c8c6c7a557d62bc0240d35fc6310eb568fc0700f18a9204e5f7bdc1ea89360a0be2b5d4a41a4c8a118ff7d1aae3f753c132af4f422d56d331d05808901f5be98627d7e2ee7c1c1179d7646744f9bf9960240f5cb18b344b724e7511841cfd91f31f8ad13db04c0702f1e189738902c9c5b0e5c2e17a112632e945ee90237ae2f8bc9143fc1c69d95406097db743dbf7ef9346cceb8d202e1697c8d369ff52183d15b238c7956e4f188d3b7dc358694368306681bcd4cac46deac147c4e4b085360b4683df7d419c8d8ab4ff0e88f76c018a4a0a76912f8201f8c93ed289a2242f701ea94ac14f0aa97f0293f7029cfbb0272281a1a221150c57e5bffaad5cb073dcb663bb2d4009a294b2f1ebf806981ee14123799fd0929974b4f6d9ecdc0313c57b9d074cc1a50fc0b5bd5103531812f96ac7c409ffedc6db2500b833d3088e6fb59ea9949aa4ad484ca1ae26b3db5cf07e35f20a3f17a393aef9ba07fa569fab449d3f8a89d74f2c8f31c179a784613d07ad9ea535116c0513173bc7c284ff914f1d76458d544bf025592439861baccf9ce8357dbef2749b8b0283c9d10aa46137e868b37f99ca5d73ab27f26793cc1de0a0954b1dd01f17dd236d971ed41d4355b74d3102e021489d95414fb027806991578925fdd669d8db0887542ec544b1edc964b2ee189516303ce556330a7ca4e67e3fe0a9a133936dc8280e376ba894f1d1c70855820054f5c26015b230c122988c6436685b0340570487ef384536137596027a5cb52103cbbbfb626e663cf2535e1d65110d0c293d54a38f83523982eb4bf79748348c0e19c4cc148d1bebe57183c98ff85a570ab234de0d01e5cc8e23a5c54520a20a9aa5e3f13d2e82630b87b34cc56f166323310eca96fc5f859ca8ea2ac64debe0a568d21d96e8b7e12c3b687847e7fe2b44a10b0a680d561a508bbb3ee41545e3d15c1f7c99a7cfb81bdaadb6c9f484b1229953a860269811e5085625319116ecf49433e2209980e6afdf8e19073bff5ba625cb3c8d81cc88fa7f973897cacf032b20cd6be8430f537603fe839496f4946ac5f17a734b7e8a3494e3d67bb59894490f63fef4f2841a6eefb841c481c70ef4c37f186f0d4b94ad6e4fb5b5cbe01c7903ad50fc6f86690a45a32f3676f2bcb789c997e740b56862dbc373a6b3e4d13077e149183be5abe580c91f60334649070be90bd0f814997cd870c9d66af8a63815b7eadb02042c328a9cc99d22e016c6779c36bbfc4980b473c6c080e11f7d542aafa3f5db2b8b3f20bfe1e952bfd8772f89a17425ffabb17a5a5936e83710ace564c928b6279ee648dbb2fc792264a837321e33c526ea9f06dcfe77be530a4a83e6646f0fba8119a747b1f5b74679a46445afde140cc44f1ca730d90ccc5694e53d173f93b5cf64241d754f2ebe2ff1583cf91ca39ef4b761d67e6c863b54d5325480cde0265473c07207f3f70897cc78a92e6f253bd745802fc6c787fb6616498e6228f4029dbdc3662fbba3959222a498bc47cbb947bc024af15e7c43b4995ff4f0d1e35ac1fb9c02b45e2c7e951b1840ae94c158ec3c6c20f007a1effaf168280bcccddfbfe81074fd55cef4171ec1f22d067c8160e63afd5b6228f9357cf6b5dc75c25573a16c0bdde7bee85c6ff8363dd9b2357ef4441e1af73504d3dac69dfcef07111b1e956b4ab905cba130002f1883bc7abfb9864cd3ea59d88bdd4f63be8fd26ef17de6585829197891f4747dfb5f566b6759a67621ad24f750a2d796c3ffacb6785e47263230dd025deee450690fcdb7a31a6f2b9252e819eefe7f7010a0c3f62298ec4b443aac1a5d9c7ce70477bd3b63e0fc3aa8a4a1a1bbed1351cb0f530cc63282ae608379d50dc08dfc801fecd21ab80675bc2dc4c29131caf85cdac53fc0eb887f33fd1f40160b34503a37fea4e026bbd27d0710b21978694b59a10b8671e1851c7ade6bfc0b5fd59fcf29f44e9920541baf6b786ce3de09184d3c7751e0e43032f19f9bb7d874e89f7f645151084bac77f9f3f236d555fa59b070c66c645c67ea8aefd164dcbba62c1be918400f2277a5b66a6a5f0f1e750603618d7dccb0c5cf9cab6959c35c908d5f8b875444b97a18843f1fbfc82e70167cad48aaa55a7989a337b0086fc66f0330278ac3b2a4dc5348c8f437ad682087b6207c047bd7b7f1e267da516cbbf6fc214897f61cb9bc8b2a7e9bac7b8f9f931eea8c8b8c446bdd1e8aec39a1d573b03456bc9d7c7929b149e4b13878eee49c5e393dc7c21c5cd85e1b420b5d62214e6492668fde090f5b6f6003b6b6ff4554a00963a11c91faf2bb17ad599958f8e0c7dc3ca99096fc11dd907575504cf84b606f61e7bd19898d21aac5dbe4b6d2f7e34e82345556886a9224b7521ce0dff4097ee14ce250c9c427a37c29f5dfb0c2e1c36b9426f056f8906c5b330efc101e5b979352f65c5a9e872375b8145eb3b862474570210203f6d8f6077f10f0183056802b1c4aa0fbdd079b53a9b684499c115f4dcd529d027e93566e588fe18dbece9e880240daeafe6883be0297469c6c1434552a8e745ee5ea1c17fac96b04524b7d1f2e9759e54213018d110e01953b812df037a2058910b268bceccf31d867e7ddfb004170f407db9b94cce137215085554b7680a59945c2008cad5107bc37ce1837b900c725a82aac07f5122a6254118a6bc0006d069beaf1b8e12c5d171a3fe04ed694f3f36f1c94292e7572cece93f4e05ccac0fe2865795d9c81225e3f4d365bddf621ed52fbf7300b7ce9ddf840b6b4f698eeb2df52b45468f7c82b0a9a910b2692d957b9d89fd41ba8afab90aef58e108fdd5674fced7f968bd1e104597487db4ffa4d11eba0ca0e7dcd6a01a65bc36c5d2286a43a1cf2392b2a8df32b79c106744adbb65359e7fa459614995cf1407f30d9d16b5a22816ec45ece777d5bc2415112ab9d079254290b934c3ca4023b9e34d5c0cd489de436fe79eab407f69c497588cbce35c39b19b4581f0fb412c4052786251072ea3dbaa3ce4278e3926a2959d9ea5361e35f01f84d45de05ce87b7db3f0ef54751b3c0930503e01543776b32b721af566c4b6ee05a6b81961ab3ca9f4a7c3908544632f9250b46700637a69b999709fffc1df98587c2c45084639b33448b653b72b51f2fa87991cb1d5cf3a372f836f37ca07ccd36c772a585495dd8f4a0dcc1c5dc98b8a799f110180e133456142e0f0883a667236f7a1ac653d4559288bec853e7db1bcde44edbfbfe40660cdc27aa03b04c0caea7171f9e0b09452993965f3802b8807c6a5c7e5ff3fb35ccadd1746a2a3bf6c5941a4923256d9e7852bfc41481bff11b4c11781c9d8dc1745dac90647f2097cc7cef522959f87c9b30072be04837c43a7b2b18ad3ff12646a2eeaa34b7e3e3ea45faf602bf1198f61437c5e3e78a5bdb3d05df3d3c6ddde8ea04f2a02cc75775ed6e3baaa248aa6fca5acb14782c8777c870f39ef4b2bd6827ecb5bdd5ae24ebc4e6667ad4cf1f14b03986dbff8ebe0862ab39ff01dad533f2ef3d1582df7362e598c6e251432ab0ab6c704ad9e1f67270789937a92d4151c9e4bd35f0ce7fd58c85ed8ac410335edd00dde64415718f85b4cc9e913094a4bb2d4c67a8994dc4dac9aca45795452e4ee97668cffc35a12e63c266aef493512bb02ba0b5045ac406bbaead6d8cd1b25b86de6f2ae40cf875a513b66b1cc0e3f3415f08cf4ed41f8dd8a1d21b5dbc3a2c390b49b73f0fa3a66aaf0895c2bc1e504578d903a80260ad3ea350c556e4b1643e981568f7350fb522539f89029d24097ed8f4e5b74fad5d5d610c80ecfcbad44377c8df26cd6cefedd82255502cd764c585f1d00b31ca7bd92361dfe55cfe5c1220e38ba49119ba963a33d6a80ad38de81a31e9bea9dca76d8b9f7fc7254fed754c29c6d9feb73c73e8cc5f666a4fd171f63bb33e4e9795d56e9b2f7f35d02611dc2e288f8794ac73795ee23d9036145771d069e9e16ec8cd3d018197588452f8b26a72254aeaa0bf337dd02a31c708a6269a4bafce8292582c3c631d45f3fe29c74f92478cea5feebdb6f4ce2e42f1db303841ac3a407aaf8a7101fd5b7bee5e6b26017ac6971137f7c049868d8020ba7579a88968e42bf6bbf9e3ea9160890691eb2c9eba4e5f01facc4e682ae9ec8cda475426be0e982d80526e3c12d6524761809fbbf6b044c925af297f6d3e793cd22092fff429cdcfc79b821f2054b2b063c05c2ee0873f87309534563604a53cac238dc6349f79abe8c8d54a895c9831c20d82db4c770acd437de1c09c0eb01db579832b009f0e4cf8b9b9c2cef8764f278765dded00d3a424ccc427a927ce07ccd33ad1b7472adc9468ddbc89a51b7487510d8eb4de4c0101bca3b34158fce8020dc1dc44ca728e72e19768d29c738e192493ca6eb1819056901b8fcdbe5394e1c81b2e1388fa8ed2ccfdd6d5a1262a2d3ef959a29130adabd3602da8c02d56dcdff475e3bbf29ce742f590d381679af0a9cbdc18939c1ca2dd827df40f6fb7ece17b71ce81f4ef5bce174f228ed8a0d3a1eb5ca0bf648d360efad71ef48fdf531abc47cb16467624cbc7ecd03d748e56524c3bf137825bc64f2178c4e2d675a98bb1baa585138e48eeb343a8c5d93e7e7b49c0bb03a48a01b72696d43ac9f5c0f04f98cfeb91788da7f1ae889a9292d77c1e5bdf98a5494476c224e92c4f16c7adf36be75c089c410d9a2a6a6f51889e0a712","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
