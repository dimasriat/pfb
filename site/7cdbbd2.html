<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c1b79fa8d5cb5a7d36bc97b4ba76da96b93f6a7a44d25e0d948c2df1d93650b814b4a2720e9b95d002eb3de46a001316fd18c1d7f36c5cd7434a78fdbac44c9c15d570a47c16ff9b1e48a0335d8a1445c2ea037c56dc97c36c1e3d0b2c522ec1f76162fe60782c68d1a89e2fbeeae627866300cee53a0f8f91a629bf7b7dc1b330a81bebc17b7e4cee78ab4d263f21d46ef9a7d98e7109284e1b059f8c2064172e0b45530885518bc7dcf044f3376dc767bd5813289c07901b64ba9114f0d7bcba1f330387ae9f804ca01c96227c195668c18fa729ee35aaa4627a9c7ba725c3c014d8076ad80f0c7402bb4f5ea33da1a0a80afdcf716b3f59e5d12fe23183439a7ede106fc94e8afe3361611ac0afe8cf4bbf95be81dfeda10da6e154772e6c7d93b3f7906229e5b95dc553e0bfb45606c74f7810a202d599d8b136153892d9063a5163a78c5055961959165164ac0c26a09e07ba5bc1a5e348a017f682d1cb5c39a37647f7dc8345fbf9b1674a06a2c6e948712797a154763db3020928dc16600d01856b9319dd11f24a4d0fdc8ca32bf938271589afa20e2ecd49df224baf9598dd563a023df4be6950fe0a5fe02c786149cb0f4b25dc76db987c8861295f522b3c11d1e54a450980dc7c6a9256465219f63774da607e5917028ba4e7524ebcee255e0742ea79021782b0001cc60da8adff77b1af6d98fca5e2decd613e90d6bc59a1e8b3e7ef5e744d89cc6cf5778fa94b0850ea6a85c3d441569cef403fe75713d95f1ffced0d5c90bfe0afcaf34c0d0619417d6b4bf3b3750a08dda3bfe36b7349e17c30d97e5c42f719dd59bd0e46d175d5718c6262561f97f45aea2a2493d3be8fa857e90459b452c06d7db35e304c114f7bfbb3ed85c0beb09dd2e9fafea5724b3f9e2836634e01d43f07a97b9db9f31be51b1d1e166b45e77dd584dc911d78e06be227003a543fdac401cd112124a2f1954e66e3baf1aa158ee1e8c3ffcecac34341d3b55764d88ab329d0ba7b78e747d3b6873aab65b0515bf7b8ac7c506536da6b5e908407e71c498b9cab62ca4874ecba0488b72330a10bc48557dc0b05cac22e49e52e24a6f88731e41a9d29ad783d6f31535d91665304d0a7ec7a6d02e6a9db9c9b12e7b019476118d77eb68d26828524eb6fd3551a2c8a8bfa086751ddf40f2e712057420a6caf356db9604ce67799cccabc2c16d1e683f4ae73695e97a8731756caef60d5f67b4469a5ae28f270374fc0c2464b5f9e0d4ba4499b98e8b7f6ae69029d2ca84dfd9fb79e81cc4d34aab7167100405e789e977c6d61f2c9e75a12d7058bf0e27a33366573b53cd56ee289cd37604c36e2d8cb89785e2b02029be1b92929da73a49ef4bb341a791798901eb04797b9619e60632efd0ef99445d08fb257528481ffe4882009c735a41d1afad7f35927829ca215cbd898d8e62139dff1eb51d6446b0921f976bff1cd0652d0f8a818839d0caf7c5d0896a1fb0d28ada118edbb09acb4ddcfb40e66d4ce428bf03ade3420a4ec28d54f7dbf18de4a4d61feed78cb98abe4a6ec72d83fe267f08542471ecb795177466de679a5b330c7cc7d09229eb171fb1fda8e55a1020330620e94a745a28426af37b4f7b57bb71cfe71f4c475a85493c2d216597f5be1810ddc060298d50a85a7bff3d390674c361b032dc474212bfeb0222ae29ae61def4cbe26218c0c85855bc5c443c7b024fce78921725a4ab6629bfdfa1dab06295d8c7d1aa02e8b12ef00897bedc9d1863829c7ef949502eeee500885f1c79c38cfa17dbbc76363ef9dcb19f3377f71830f77cdb4fecd0a6a04143197559afa71a19d743675f07a00e8b6fc0be873bfd24aee8c0066521b9374b7e11c510d61ed86e19102a4904f8b1c29f0d6277484fd5dd4d7149cdd100b6e91283e7ec7b5d9533ea5ac77938ac6417beafd8c5453011c8b8c9c1cade86361ccff3f95dc3f11a956624bb528d0037effcf1f8fc708af83196ae403bbd1179761cf020d6ac4cfcca4ff4d3567d355d4e7e3c4c4276276aa9dcf1b3a4af4d0175400f1a02360b8728c197d9f1b6aac6de62e1b02258e78a0c5742e7eb37f96fd1bb9d50d57427532d8079e08e9fe1bfe004a25b0a3116dc7b55ad3c67ad534f94fe22b5d318e199a376d4f42eb43e5763dc05f10d62213a3b21b29af344c6cefd1377c22a7e4602d9f01928e468c9bd9b24c70f97be59c02d35c70d210e79acd8e408c51d9be943b9a044234ee873504bf7412390d1506bd497b9bc627ed70b3cc31b510865a1fdfd5ce5291c9babc5eea234f1bfd851382146b86babd7cd9523718fe797fad739c9a3a524bed60cb2a283e97af14b800df95d8d0308f95338dc16e2fe2b8ae82d013e36b31f07147b02fd09790dfa681666f17db8045cc07479cfb0ac45c232d3927199da548a3f0172e06ee805542a8309c7383e3bbdaa8ea32d0b6b1ff15b45a05e3ba753bcdf3655a2bdea76e09ac9acdeb517f8f5206c01dd8c654a8e2c7cd4d5f00bd7bbde809254e88096a21970b28cd684f5c511295b788f722f70fc2a44ffa54f5dffc82fe7b0277f815393cae482c06b1ca922ae402b8ab252dfcaa0c7224044f0267d5ffe0548ed1891029201f84118266909b3cf8d8a67cb88b667582e9975a4a489c20e722049c84d74122a82c20f558bb9ab4d9330b4281b1a8a8ed9f55fa4a068bc52da61eb7c9374b51b4c41ace0fefff05ac1ba7a9150a45fd109d31859d07445cf58e32efd57aff4eb8df623795cf5d8f8beb80410a89644ade4cb9ccb03f5a1594fb8110781eb90581e7ba714b524726400263d4597ec6e19eaa7643de8f561e096bb961b20a38cad05137c07e7dc685a17d0083ac91b3269d218cb362055145dc0e7a20c6e586b314ed9450330b8df0f528d251dc840a0b537baddf97fe5f8c6ded6e1734a1a11659144798712ac2d2f8c52079fc77f1187d20b1cb4fc4bdf6803453751432d0377f12a824816b619f1ad2ec0ab13b38f85c5222bda2efa79b153be4a4bc62ca1d6680ad4186efdf030d7f1435863be8153bbaabee0ffa8c13fac20747a2116c41ac587135e1bfb5539f35528f9aef53041bcb6bcb6cdec529c23a247746321a2885d328df0713116f84129dd00eaaa49485bc8483950aa26e6bbfb3c7212a5329784d99fc31c26a0939ff4ab2d7a02961ecdb1f43dc531c77b18b8f796cd6b0599be35aa6610dd8002685b2dadb07995b4ce226379bf865a52527bde6f4a39ddd0d1434f8e7a2bc5a995c80a4ebd5baad69909b718945925a41163b07512532006a6958f1055caf7c8412b68f264382f683e6575b0d6ea983257c2ff40739c4dc95bbedfd87f9c093e54bc62979bab92e884da1bd9f1bf86d53ce3326db1136aaf6d7891749cf435ed6e10326a62e4dc8559111734cdfe1701c6fbc2a202a24fb508f39f60af8f9539c10c1400c66f41e24ad95e69816cb59a49e50fbd30bf3c0cb92734d179aa9e6491d201b87193460950e74ccbd19fc92b0468c7b9ffb180a29e27103b8e913fd906fa601b12fdab5cfbe4c8ac1c98353ece8a32055ac00f4f7b840d5724c8567481b97ccbacc239396fdb8bd2c65970f44cdf592c158e31402d9a661ab0865f2a3e120e32c53057e526030e845b9211ec13bb531b81c93f2a6bd0fb77edbddb5af0ab58dfdb78da6990861d784c722dd0b0cf12152e4cfa95c4f26cc07787b6b5a32154550d9e2fa32d55f906173a8426032410537fc3007ec337503023cbf4ac4f04727a30942b8260d450e79c68c5c38be04fd8d734bb8c0911427583b6443d6765f56a74be0a448d21bdda738c88f766426f859f76581734f0488293c90d228c408ae77c7c9ed4cc45c786b4d4ce3cbeddbfa162c9ed0be99628072749f8ce5c4324dda99df50e96bc3258f32b6710efcb2f9f040b802484a4006ab08d94f1caa35bc49f4df6a0a141e4fbb4044fafd1c3245bcb4abd2d1d3bd1850a4cd3447022be5ef2b1a8e14e7e8c3df51a36a63459e5adbf1f4db042f7717d2ace2057dcaa63638446735b62553a0dfe8d156babd5b954ea329712b9ba5597079358173207cf0ef00991a6c78672e638582e290313050a102374b2a39b381be7b7a6137b3d10dbf462cbd1b27f808e760313c68ccd314d74a26b38354bcbd2771464f0717d081951f8eb4e8514c8a23a6b9118451c8c04cfa3c7087055bc41c4e6867c450d2b88e7ac773cb5aa68fb1364a847b97625c7f576479943b26d4c4eef3688b5a83f38c00dab43d8e25372ba6c4be6408f5aa88630200ca287333b4204b088aece17e11dbfa03e47b9906d18b87611e9d100c68c9f7e6ebd8df301313b07e0773006e7b9c861771c4bf1cb32fa86e7b3e20ae3914a54ed569464f79f9843d78e1eb2cd7914fd885c27d2ebaee9905240d019ad39853b55f1a2d9c23259199bd7aa3b908dc44d26d6ae01f37681d1afd0e796ec45c6f8992b0b0162b3e396f62f51acbf6639e4b4605774778a6e3d95cbb6eecbc3665fab274644b04f1a994224c46b9b8a5b5ec6cc10c51e4087b79d01661f5e55c9a6b27ce2c19d2ec71669f3621ae4c2321c2752419a81d21ca02b50aa7eac06f25aec77578023e5ea6c637b32bbc2aac4d84309ab3cb8a9117e570e09a7e5a9bd07894e6491db4c28d64acec22ce061647c72d0cbdc84173435d3d148bc19dc9f431cd88f7817f93fa5e0940ad376c4c4d11ae9c66409feaa7321471eadd6647ca99415340a0458ea7c09eac6bfecf7578ee473c4c49efe2f4bfba975d75db16b02936856a6c39f1bbedfb29963c247d27ca8c1b40b5bbe2d6c4bec581e7dc9fb5a2aac959208a557f2fdf96d53f205c48550d52369f531426996e11a3beb9b5925066d5a0a6cb00f4f5939146e57d4a8cee37f6c856b0d0edcf9baf0314f6b5eacd181cea9127ff3a110246b0e95da1c05668e53322788b09ea26edb2c8d9ecdd7178ce350e37309bb6a4d9608f51f6a51f1238edbb33dd9b0df00c1bd5c5249b3869779bd1e05d4ea72b48c5f04c4b475be1ee55f358e233a4ac5461463c84c267b5b29afea23f940d12be38a61047a2baa76e1a6c75d2ae5cb3627862caca62c3eb77b254e2e8ee6b598604c27bea95b93479999940e1ad7d8028ea006ecb0eedc33ae428e02e034e3fcbc0a9ed559c24561119b0eb67b7edaef0c82766e65146751bc8f001c5623f50b211577d1f9af692f20cd88232f6c295892a43cc309f192e0d48fc605ae45d1d3c527585a05f35e5493f9507ef19b24264471d67b99b9f5dfdac86b698a2ab0e430abe950e8227e83ac8f4b53c51d3a63552817b54c37b4f33aafb9cf4c7a39f936f4796bf3d9fa8b3ab7c72e37406df1f1a809027e2150b4afa6744c248c036e8ad8754ca4c3f663bd91fb7badba3a0218c0dd63121b6607c7bb3d2dc3bf5d77d6524b2eb3d4adf7deff7be2f3e315649a5e7d971b55c160816f9c30cf98107f0f4407fbcb15521864391cc382a8d3d48d7dfb2d0d7a2ff260f6f24a262195281edc4a5557aee04c8578fb9e0a6147bf2c395770c631ed8a46c26641b312d2e58ff0f6e0e3d7dd44a8b840380b2ddd1aa1343adb1512401ccd7218e076591dacdb06ac72f54e8b503dae9ea6126f4961bec6e860a7095047959955df9c2ee3d0a3b1f8e29d6b810e5c6c1bcc0236f3ef4fd225c8fcd7d84382a4e9d3323b044559b9cb8ae2f6511ba594e86d5a7fcd43d67b7bbfdc01b12cd90d2fcd21f6d7a01deeefc9e72e91d98df8e40179873cf899cdfae079819a890676199769bd8f88493396c6a6ed95cbdabf36610b9145a6b842ae8e2ae9cf66fca3768ccab77fde2774a1a61c9f47bdd3bdc0c495e6bbec89bc005447918ebb6840724d5a71a83b06757e355dee0d71988dbc7c077a7bffeb535fe0294998fd97ee48934a0c4050cf7dd24fa4bb2f199feab12589683453f773e722c23f96fafa833bb4ab6d9ed7b842f2e44fd118042132fe45261afa410b9228085fdfdc1efbcf4f7e125247522263561f9c6e61304847b9863e0c597f06bb51d7f7ac0fae1bf587cce5fdc495d68fdfe372d29f765db1f05275496a7f51a3b794c04a588aa9f5b4382c890d7923e33b0d510143bd39d2b648b5022391518986974412a5f126cafec416ff4d821b6a9ff1248024f152bdfd46e06458f89263eaff414a15af0e9de426d1c7fe00b164549236ad890491f44b7c1b7027da7f701fe87df382771f705e9b3fca3cc7af5a00d04c8156bd79cc2fe9917d5431047333607de9965dbf23c15a6e05b2b51c7a0c91abe46eb8d9d326aedf373b8f896f176d175d7791a52ac0c838953e0f218f657ada582feb95153ccc7fb94d3b4fa2fbb3e0dccd8c1f0e0603fcb4d14916ca7f3b6778ca44ba3d949df93d076e195427013529b67788f4f980a8ecb0d76fd1987862703deeb914fccb9c7550ab1b28d7686c3398749b10d462c9d6df191d6869f65273bb96537437eedcebfb06d6bcfd6f7dc39826f45c3d365b749c302166a60bd80b0eca3b6f890f7fc8e2592f23235858cfaca2e5149c019202a304e892dd1c60e1b140509f77bb8278ec3c5ec2558d5b31f585d5bc3949103b5f3e187d3454254213cb18b9d763fdf1465dab3ac3d38d8310685ec6c051d43e8cdead52dbcbc1f6aa2b31301417f29ab17a4adee79cf27145252815b7f2d796edf5026c7cb05a6ac2211f7a027fed1c8b20c4003bfb0699b3bca4ea6b95d7e7a9d15954d66f44021de4eb23abb9d9a20e3a6c5cf0e6ec527657be91051c6fe7f08fe34bfff4ec26ec95402874097090cd79779021261f7626e4bd20b729b6675c8d72757c6f5ef0d9db4687ffc52740aa9fe18e7752eb3ec124f33df98f8235be0a3b50714b7bc97091dc5c84c9edea95b000742c845e3b233d7fd23e88d726b75554180b3a83562a374339fde247158ed413191a309e5b8e3f0a0fe55b409f6413736817ea6dd09e7ca0cc846fc894980be37ab9fc3d51fb9877345721f351ac87d7e8e31705c2a1c89c1005c81c908f1de2314d72d398a6dedcf601c82bb5e84e893ce1b511a21b84b8f59eb54609e96666302e408d382249c516d4b8f90fc455dab0b4831b8f534714f07b0ddad381419e7dc1d398e7f651487801c92ed7c7450fa6affeed2aaff7c994701ca7389f7895b5159f856d6d701f4196fd14c90a4fed9597da78d7932ebc606686ae735195b1fe43ffc8be5d4f0dcc2c825147d6d2f4870f393e125bbc5ad5ae26fcb314ced228165c06ecd399750c7c27ad90a2f9c2973e1f44137980ab96c88ec9cc37671dc027aa65ffff5687d4ce723453661e01a0f731988dec3b915308571a4a3fa3c0003324a92fefc36e1c68db369d60bc0e7233703a39c6ccc153e60a2823fd1a75498f4bc12850a5f9e7f6fdb9be24eedf0b495eaac08ca7f1cccfda00cb60af52fa311ff461183eb0234ac241abd9f3d5472aba2569b3ce96667816c36b21358f88cf3e968fb05188cb02d0e7e030cc88385f3d1e4dffb1ca029e52edd2c535b9cabbc74b0b1e63d7d277c4a4dccdc586b4d4c62acf6f66fbc3318513a6aa4d3ad2c56bf47ac00edf0b3821ee76119da9336f5a09c850c1b7e6a33c14b6afa318c2b88bcdb6d0b636a320fc2b3687c89e2a972a7f8b3ea1d5e2534b2b404de8f86135c87ff90b1772624981df0fafae1116722d7d1eb096a2ee996373a809c2ab2fa339a07aeea7126d9c6a84789317233bcb714b9569d578706312916e628f109649e69214684b5234c101e612032122e5eedce2e4b8d10878f3feb5aa13adcbd8e32a429e931ae0989ccca5b443145dba14c0ed18a3267824a11da801548028b79cd3c5e61fed495a2b6732ebc95c90d9eb3edc2ac3a9a1b730040d964c09e93c0a73c1d93fb5ec0db513bd5109ecb482453919192f42a7c36d93593b574ee8ecccbb092ab54b368d983341ddce1c85039e72044c2f77e7a672f31b09e500629b616162a61c8de330031cac0af163357f28d9ba90358780518fac704b1225944e07ad411c9d66749ab09c7affe3e8090dea6e3af9e38cd6658e007d05f33d0fdda31a1452c3fd0c13dcbcf41c41b915adb1f2199be9bbf7130e6288462ab5af83f45a7a300ef8899b799f92a70dbee402c9d48a46cd73a8d1057f9dc62350704016830aca5acf91ce7131e13449a2f6e593c329ce38a35575b5cfa4dbcf38df7166547010464d6766c9a2bc93a6321915566de396f89fef80e48e20d4ad392bc1b585d285e67b734d36652be3dcc6ad6a6ffdb6df1a5f322a60f4dd64cd0909f0f2e058cbd02e93596e4552c08617c582696c2d9d2d80997915f3bc95263827bb880a44a50c0d3543ef11754b13549b34c85bbb1ad1a095b21cd612d2d136f84ac56d1234ad7c9401c781a8c844e91d88b0a5df1922a2ab429c699b7686178fb8f1cb7a29b65022a574b9f6f411c9d3309eaa67ff4d7f0d4c31a3bf19f6143f14b431cf38816c01774a186f722d9507ab5f3842f79066d104247d365194243c7df959e5dd8105c2afcc89a316f3aa9b3911a42ded0978f6e7c73ddac16082590641ab650aae07400e3088d645db46ae0fc6cc521ab1d85d1e35e4e6f70170b4f1155af5fc98b9449ea044075a36e287335be651b27d83269e3f76a8d81a5396a53a7abbc681b371593a11983305a270cb9bf01b5e9810f8bd0b70cf2d5eb980523aca5ba5ddbab857acba393aa41e9209540fc299cd46567299a542e183a1494131645c5e69d9c6ca5568207b09f38ecfff455e6ad33fe1dfd43d1029421a7c0110ba86bd9ffe276f44f376ecc02c32228e181631d2a9fc3fe5083a1d8e3329cecf4430c028cb03b7196cb0b6218e8f99e8d80d51a84472621e51f104e26f89bf40f844bb5c492aae229639736d1995987da4b167933c1f63509bb9cd35c2e722c0928f5f7af639ac7d6ce3b14691adcb4afc35f88cd8a29195e49f51c2258721d42ab959dce3a5665c7e7ac96d1fa6f37c08291d2f6da542598028c242c0b6c8a24c3f81cca59fdc7d66393d84cd0932fbad63b159f61af722a6246b690505c7c06b45b9f2d3d4e552a28d1b11f4859923a45b626dbf2d0c15909c52031f2d9e5d1c06ebf7d3127db92c429968d1fd18fd3078eddae387acfa769885bd233ff9d07e6e762604fdb35a2222c0408ce3c79fec988084c071fdaef7c3d42ad3b0fc05514627e8f3a8ee8e2c120ac3e58a3538eb4a96775f185419932d44bad1eb16d3e16d75aaa13af3336faefbd459f5035a2f66d011f969644a60b6dadbed260117f5cab9c837c79cfadba34c8b5463ba160648b427fbcc8e3e269d36843b60e90e0cf52ffbce3e5a5dc5078e1de2610bdfdb0ba8b21dcc327dda38591b5d42c9cd34b403c3d3dd3ceb35eb89df55eca2a582ad0cb6d35d551739aa12b6da068ccca310868cfea0a8afc4053097ee46925aba8cf0e448c906aeecdc00903e8fcbd812e227435792df425589a9f7faec415ecc9a6cdee00786a997a90df7baa1103a79d97cc04aacfeb7f639cc868b5b4707bbe8cfb60a342c35ee010d389b63e5d1a8c5dafd5efedf88fc5d552e5545c0f105cad640928941b1b7cc47068b5fd4814cdbaa671d5bf0fe7926970a06bc034f485b73d6d1eb097867736e3b119f4b421a15adc9e992974342aa91f1548594b89062e3100ed5c36997bcb125e94e15ab3dae79c90c40638b0f545c0be252d9b80059e3ec6176845a0781c4abf5d672287e1eee7efefa80a895e3e386133e97a6d6410afa2f5576531fa448a0a00196c0340920cec4b14576397a330385af7035a8795a3b03a715dbc733c0dc69d2ad987da7398b3dd09344f5eaf18811ba85fd59eaec6d411f27073167ad9018e4507cf46e3252932c1527bd4aa196a288bd3c484b0902f16fa2055b69364f6cd212c20bc3a81a28834dab417eb945648b859ad12c991155302d21c1ff27eee4ecc0358b8d51ad741a15990d4bfe3b65a156b919ec6135585dc5bfd5435a7bce1aca3a51f1bfc944d4a2123edf71875e8e298a5483d1a7c204752663ba7192b75d2f01edbc08c6a63b47e030c4a2a5c8fd43da3032c119dc6a2bfed94253a4904ec42cb511ed99c25f9badb645e3de6d50f28db1db5aed23e20574d05988cbab0eb74a04df1595770ed8c89f2c736153cec6aec96dbfdda5a81b9ce71e4ef146b1e4c979c22b3a6ca6957852f6270cf1185610162380f8e1f0259676a0404f9d72e412312ab43273069560f849d82e185900ae4f63c64476c7fe8a89b7429bf318fa46174c3047df0b773a9fc5bcd5b904b0ea35a5ac4d9a918c77dc22b9a11cd24cf36480469c644f4cae12159bbcb28a95fe779919f821f8069626429bf09880d01110933b5565d894b514114f5b6c637a8c773b36dd4e77a81eb24d5968c26fbf0a61aa4b12ae68b57ca224f231ac2685a0a0085158bc5b54f961d10c22bc5071fede0003e70d8ae18b25906d926e323724635fcd5063b9877f026c9eb40580de1b4938ab65d6a51d4e97e5d886dd3605fd30f3466d5e15a18c00acc082bfe972d70047dee60371d38fd898188108c758b7cb7257ebddab17af6062d51ddaa66a28df7025b7e63a8e474334b6a19b31fa97bf45073736ad9ffc96c2e9c78debd7e50cf0581b000911d34b5d3bd5349fc443ea310192814a951c840cf7ed095761efc293f6d34625c156452ff45d7f05be36631b9a5d34feac08ad6c282f6f67d955532600a3f502858092401cb4d9040268a5c48d40de26ec1310a2013f4808049727c24486c2cec3ebccbab5c4ee09c5f91f2b79deecf9f3c851ad8e1122234f78029e417d2c032dc7c3e4e700134e9812faf877a37da48d5bec5d2e3ad2c8d5ebeb29d58cf815023a3a32ac7535ebdd69deddd94f33d7348aed531610cfb48efd12cc003c2ecc1e43fe11a75ae239daaacc59458687b367e8738a6cb442a592be35d481eaa90db5e6e2b7dfc8bb154b385b334bc9da7d405425ce2a1b0e34abdd13a5a66103c40609b81bc950d7df11b9f709b8a4e3df0e5833739aad90d254ed968f42c0e637f70ad4d3a95fec1b8442cff918f1370f7655b758034cc98260f99115f820c423c8c0fdca22b5e60baddb9a46df597c79f1fbb590d34755c41e3ea09eb23ad403de2b53acb35d91dc678062b1e1731275ed49aebe9212c3e8f54f1c8844fd447fcf50d7caf9b9684ee6b7a9d7a18504c33122ec62a8852f1178734e60b93a9b21eb7d3310ed4fb3c790b6f870790fa26139595a386d9e652bfe9424227b6fa85856a96ffbd878319112dbd266d89777462f8f07d39fc5e18ede6f9d135fa17904e5eb2526948f17b24f4fc7374570606f41ece0b75372e1d1bb3291ab407cd057d36be8531fed8ced7dd4690baf0c36a750d28e0a2cce8167af8b931c7771979b86bb2588dc951e2be0a2444c730e17c292f6f4512a4cd6775b2262135cc4f04c2acfc1b88a7929749bd43488d73fa0be2a84c14799e783ee3857b5d95c8f0dd566a690ccf54cdd5cebea2db887eb9795d7bfee70ca4428456c654938d339a75d819ef477c69fed26050e51aeeb24e6aa1ce81d5d7f49961adc50bc29182fdd321e7a7cdf55cd6feb569b32c9f1b8c73302e5168a28e55aa503390865e178c1b8fb1178334f36239e283966b5c2854aca2edd96ddf1136883c2e64b0d71989bf8532ef415c1771112d423c6464dd88de3402528e5a5eb710afb2ed17a41142fa4aec45d5b73f2a66284e8cb9a0c15add084c89f6eac3415f90136e9220a82a58b7b1460e8b631eed6441a0ec8012fb5f7d60efe12f3cdb64afa84deebaffe8bafa9e63c65e0be9494846c3b3e51fc2a472775844b16d22d2bc48a6a3f001544fe9b620a99abbeda0ad6557b1d94e9a41d9fa40dd0a2538f587c41f348df3d86be37701683a3e787a30cf74f6d80db61c5181debbaaa545ff9ee0fc9a40b1645cab7e2b43e8fa94349df0a0356c6a3cb4972e99fb9ebf7fcfaf5f8986dc522ef3621f71e9120de109c3380086c39c549cb088683355767c2463bd86e25c4c30561caed7ca891e8c3920feaf31c5c1badb6e3349702f80b85dcbe325404e0a54f2316a5974c4a42b4fd90384f7384b429db3331c6b4f6cff69278cc3e6f8cef4cf783c56c443391922fd3ff535b8edebe598c8c81bdfa2c6dce1344448829777733ed388adfefad44ce180115b56650a4e6a73f85c1969b132a73a4f42b0329f8f2da7f3592d2477254ca867d962fd8eeb5ae47879db894b7c02b1a52076a5e0c2977287404c0c184b8bfa6c54bd47686d8e7593167b73193944562c7ce63d582b2d4d23f71fbcd205829adddbc076941eda3fa0a4cef005b7f583a88ce7ee454b696a27907b02cc3581d7bbf67e49009bbf845bbb2785e716cbfc3193af74375fa76a82b9bac69c2a95fa601557368861ba35dd5016c302385606e80f8ccc9fd3c28e2c2e335af314cd25fc0c3575e194e627992e1115bbfd206eefd4e451ff32cfcf5a5c67c1ad8a04830108ced099d4ade16f716e7ba6d5c411bc83fd6b3c119af6e2671247d31fcdbb251b2c1b70394aa374fc660a2266d14333c5396f10f1642d49aab94065a6ea5193fa7d46272b1d1341b7ea3b7544833b44d1a24487353bafa58e732095837edf892061acb35d0e728dd0e42682115d79e6a9d1d3560f02f6a3ef0b613bde2f6df39849fe8fc70697180181120ba943838e5c9cbf1529d61f9b6c702d370fe542fe40faa63f3135d4a4e6f073c849d950f8e5d6c9c0d8460fde3af6ebc5433caa549a1f4ad167b2e1f7a39bee7bea21ee5b7e358e3d88ff48ed7880e0c8221c4951356de1117d0dad7bdb1de1d030c34705be7e9b0ff1828f7baf1e23f6590e3589a918d87cbdf16159eeb94905abeb6f6ff4bb4ca7f84dc86be322dacd82f1297ff356ddc9cbc43d73341dd1edb732d6a02349892e25bf5d18fb233ecf88f3c67187bf993622856734f464d256097b0446db3ef8e2d5bff24051ca8fa75d373831e99d2b12146bbc1c8384e7257bfec457ee3957392e38b11a272872337201c8d91b82a524134300f789dd4780c1826b63bfb5cfaee451eaf7a30143ed4fdb5f615a5e0ae0e0b3c6d49472d404133689858f286a41c36282eed4f24782ca12e4fb1ba52d6815da75e0bb7dac88b1ff6818d42b2f4d15f262f8fe8fc89a37eb6b24f5f9051ebc9c5ece1989c9772a4f64fe40982a1ce72dfffbbbc760e8dbf7afdc2a215ad2f18fa0769cd4a8e040e99e8c78f6b12098778fee015b42d38a0603719ab643b7ba88a142ef0dd31d12e17f714619b8f61b6dd69724c11be26c1520804de434e9749fc4dde94704fdd8ca979d871c73f726495e969cc308199102be3148c91063ba2d7987837ea165b1dd2f3a441eecfbc965c382581f44f1fef7065222e2e1047afedb7eb2a18bf9fa649ad6b289ae646705a56dd981dbeb10a62ff0dd0a72cc4fbe6db659dac67094c3c89f78572ff5643ff99ae0427fbd8a96b82e8b4d53f84866bcd6dc511ef6c759dac23a290d868c434400a751ae3de2d434fe8cb3f9e22970e6168e456233972d64eb93de07ef9715049d915b0b4dbd07475a6dda85cb9034cc13ab7216a2ebae862dc3aad663b9a14f8d408528351125ef48a6465c4623857c8d29e682cc24bf76b61a8148a69a696b509f5e965c74c1d5149723fc5feae600fb0036bc41bf31f690dbae534a9f806b3f731d43bdd32fea58117deea293f0623fcc1a5db34bc278d6a7a6995a940e2f221d5c6296384dadac646c66c97ddf5ad84560a5650e75dc66abd45ff740652266f378593262077bffe1ddd2ae796a131de11ce351e2490cee1c0f14ce02bfb75a030ae7d3ebe6c7a1a422bcefbd996093d55492b535181d60b6eecca86255cc956bf5952444db7ae08a7fb36b755c9689a60f340cd3189dd59ce487974744117a81ec12c0423d402f226f292984c297b1fedfb9c3bea4ab23bb990c1cee8170bacf02392b53da63247971600393a3fde783095f4f025af2ed4e366f8a1dd3f172acc56ce174f7a65898addc611d6401b5ab0b1","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
