<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e32edf9e9ea46ddd7ea0ce24fe776fd0f1c2fde7aa81df981b7e15994a495a97b965a0584dfff7e1029b36319342b8392178d2f46ea3e4937eb111cf26d3ca171fc446dd20784d0e34a7ec843b7d646aeec06eac4555c6bbf6accc1fc708ba58387fbb22e096196ff64468eca9e26d254200d88ced19499ccdecc90da39478bb0959b35a5c44e0abed8c5f5114dbc313b24aba92ba1cabe83950bcb74b9a94a3f77f64cde93f1113788dc1784b54ef392bd0af7a33139ab02e063aa93888f7865cec08f2e5cae88e55f0aeea27bc2d4ce2e8bab103071fcf50370d2ea2b19184787f93bbc16d1b2fa984080281bca2394efdb3be6b32807372e7ebbd6fe4b1d625516dfec44d7f381c0434207b7b757ebe9df458d2ad6994680ab634fdf01defaa7e814997766e8d060b5bcd81b6191e55b10621983ad5a31517255d6473ab589e6dbb04b34b5dd73045e2783d378ed62adbe78ea98c91e4b16718d94077867db2775d5ed8f44e652f785207a182fd1942d3dd9a41476832064d00917f8fd6b52daaa4b904ec7170585515b8ac6a0f37c02959d6887239dbe02794ebde4f299be4dfe77d67d2152d4562a86ff42d1691d79a8aa66cf9485cc6d732ed52b8408f97fe1477909b28cfe7a3f8c8fe68a62df2b2f6479e796e42391963a389cc9a9acfcaada3363321cbd3deedf8c28c5f98cc0ddd828090e0d9b667000f4d41de6dfeefda16491ba0e1281c30ac48c40be4bfdcbce193d35c019e34e6d6e6a214f199b1a54683b6ab08214452743d3b6678a10ff03ee1cb5a80726df85af4c0a61c47dece435619856c55725c782500b93beb911504b62ae0453cb25f930bb56eb585631578b111e85bce27180f94f661887c03a8a908432691306cb61ab3249cf404e01e4aba558e8ca451e8c390f555174675785178dd00cdf11521ccd7580486d54252e88ac2341ac0fb9507af2153a60ec0adce942ed842748a5be8be113455555c18e13bed4145c5c1e249c874fe74cffc0019a4a3f928f5a3f2401fe7f8374d404b1e02c22fd1e89d3ce44b2e40c74ceabb8aed91f035d30387df5645badc14f7cff05829859ae130013d344dfe6e176f78ecb6c4fedc2196efe8684f0f4f00fb3cb71b3a6f15496c9689fb6af0de8365b722e9522e68bc59dd233aa478ae78590e6be3e20da2c5e069859e925bfb861674a92e8b8bb6fb606e2a560f784e7670c6e11e87e62c9c335ad78f012f6bf9b47cd17966428112699db05c7efd19bc7ceae974da79ba464690d7c1ce948d89f49dca05a12721554cf7b3f1f024f38cad497d582de31db5eb818662dfd7f969af74f9e41d6ee983afbcc69fef6f7b093c52d90c6a956946957226bd8cd0d4511cb74493f58e382bd3b625cebb293dbdb0323ef64339eca048d66fd4999c478b95df9f49bf6015c6f417e30ee1f5e49e81309f3c388a869651a3f748769e9036be59e983b1eee33ca53c0e4b4480730c38b6b656cbc0b4649d4bbe4daa7d9ea9aca45ad689004eff5dddaa720e04c3ee00fdc1b0cf0c247b7c21f47c524d978d6f5839063258a20cf6f0f8aae130617b3b9a710b505ebc959b4a66d3eb22ef1e4865e1bf534ad4fe6f78fae91b5caff37e0c680dac60336a50f312e320c417f3e475e173675f2ade092b364a54c8e4ba007cd9f892b65761403cbbfe444a0b7b4030f7d06963d34b2bc7fb43f6d62ba7d3d205794e9b7a99e43266d6e581f525f77a7884f35d972ea6f611c7da8c1cabbc29f879bb08288f6f1cca19bd41f59e55a5199292677de81d90b5d0b742c5d27b32b93877afb5805309ebb1ed3bca38a22f07a8f51f8b52c0fd01502ed8083db4594f56cc121eb06e6f23e77eb45a2d090f8b84e9756d628cd1760dd65011db8b92138fe318ad3c09073f0e86a4edf1123c565576fa3c2ce50cb6f3777f7282fa0e6682892e406f2b4bb2ade1733a600b2611c26a745060b26f8606ae9a924c91dfa7a406d7eb127fccfe77a9e190631c08e5ee8a0477a7b9a3ad794f9111e2a4ef1554e3b20add295394b3e2375f3c33266da93046f524afd1a56fd8f41c8179c054dd9a434079f82366a81265066d25b4fce84082082a9b4d0d83053777a2e0e87b877fa004f0b99f5ad60fddea42284308f281bc29558a9f68f8dfe647a6ee8cfa5650bd910a00aaac9ca944c53ba0d2b990c198adb5c7c1421f8ddc82a965b7414ce1ef42f37a84c9af63aa9e52a104d18979feb502a0db9fbce84cfe0194ec387b05ee3fd9f58d42bd7a958200402d86f8ebb2cef9bd3092e5e52510843b912c682438a3dcc6844fd109f1eb1b6a4b86b28f97892d1a1b9aafc5124104c3eb37bdf82d1dc86c5d176d3fb2be1f3a903710cfd70818b23603245f48d2ce976670778e8588044ddde6a8dd7e6c4bfb443f454ba91728c7db7e070c3af19dbb44c1aacb4adeb9a25e3c6479010f75b8c3486de06aaa0134d6c517beef0f03c6dea8602025a8929205a18dbbc600bdc09410df1611abde7ce4339a92280600b9cecb2a479cbde8fada325df40648124eafc400f9d121f98244fc25d313906d72f7ef9c8a4e924b51febc40e9b54f71ad090ccfe03120892f48a754ef0894b06e3288ce80119830cbb43be1076cf39aea2e81b600356874bd394d02e63b09be88612faa0585b51bde224191b5c88d95e63d98091a0ad320fdd63de291b59037fb7fa23ba94033a74137ec6ca4933ef9bf97d7b8e93cc5dd1d29fb9d7e79bba51f6e3a5710f124ee86e510bd2d9b19ec3afec00ed93bb233abb9a35642572bcae62ae43f4f2d64d51c8e739e7398602371063516d17ad41b6f153da87de122f0ce47568d15933536700da4a7d6563a9607e7b8b06962896ad5ead8bde5cc2bfa6550e354c54f9a0cf51cd28d51dd4ba33215b5e7213399ae878a14c14c7ad69f03bb114f3fa1b08c6d2903a9bb83d51a77b7153369814abe210fa1ccb06603137c4a5978039de791fd1c10970c2b58c0ac9aa2e83ef965a3b0ccd6fc00fb79c9147a5ae98b9d65b313457d6e9c2ae72f1c472fafd6fc97f09a2261843b15038cff16e33c79ea9ca383f573e44943e325af5d51bad79e6de01f3b25338f1790bcfc622fc8052a2ac71add11fee508efef156da88b8f6200e2ddef4645930afb644e0bf7afbc51b55104502340f8a1f2f0ed39ca08673222a649ece7502db03003f83f029d8e97739c179649a3bcd017953012371c1c486504c2a7363ce975a32b347905f5a77a02a3c8d8283e2d8587db0a44f214c6dbe1320ea865a539dea2f20ffb123cc6f67aad471b76d781c5f79cd50e380aaab5643efa145b7d93b94eefd3c5893746455b59c6ffc1906d4a8f7e4abd99c5bef5501c8476c2d3817c28ec0136383fcbe8ce427d29fd94f655f94510df4bcfaee48c01e39d09db0df7fcbd327fc1fe6bd8d459e09f1a6a4c6c27d6e714a99f63e6053afd6b40498fa02ddfe9f290949bca658efc6eaaa80252e7365582a8845848905d7e5f0abf7c652e242b47a1e2a3ef5347c98cf3de685448b7b20549110756b9ad11a119c8f2e8b701fade7bb53a6cbd77e9f1e9d4ef61dc414b05295be423f5751154b27302763e4ace8fd7cf59382cfac2ff5cd70896af2de062a02eee7131b94d753f9ca9e8d27f6e4861b7460488be2a4efdaef84de67c58dd385245f21e3e994d68d5b6b42615a09b3ba0648e869f5c2a15778721eb555f11ad2daa89f1389259446735e7709db6dfda7815574aa366fbd45c7897471f1be3787400d87f5cf53c9326bdae0a678e2e82f61a53cc4453a9fdd6bca7d2112e06169b158a53b12dbc7b41a09b1fabf94d9a4e2f28753e83df6222a195d748caa32ff127ad3249dd4510ac76215f90b9e5bee563d830185962fb7cbba496324c57ddb200ee8b3d1cfa6f905573372a6992dbcebd432ffbcb7877f93715582ace689f85254551c90d44c321102c931a37667e6427efebf7bc5b5a58bba259fd458b992ea6825b0f18755f749c8452949d0a6ea998f891421c8b7baacc21e8a69748c9c75766cfd9ede630c89fe1d458f3400a8455c21ad9a1749a4e15f1191e782657a6051d8ae555d630604d54a200211b65440fd8fc163af2efdd8c5593d28ede3a8bccf5367d54ad92a176e8a28714ddc993731d07945ac52b956ccc669f160e878e17cd99fbca53061897a732cde41aed06bc3cba06ddcfd683b3dd769b8722228a1cb21046e0b38b66d2bca42909fc0da862bea4ff02852050a06d6d79b1a9ecdc64ce6b28bc83004a112f417d838e843d1b2b1fc0a1a0302c38748ee05eb329de824d0b2f73403faf0533bfe1b07629965e0a0a6f3ff67287ff4af3d6064be3210a4ce7bff18606b78f6f299388b51e9a25adbff01d6ad6ee6aa18fb97c20eeaf1090c25b6e29f9b8e6fbe48a99039e79c581b8a7298794440c1d4e080dac7a7bfd4835d837ee62019bf57aa449578a8e52baf8813efb0b3565bd9dbec50da90aed651e0dbb4ae337463da8ed4061edb2c8e6516480cb708224a994007dcdf1b8a663cc085dc6c7e3c855ad1e211a305b4f35e5db047b8ec14636d7721af13b20abadaf93e149a169c63057016b412c66ad3356b078d70156782f3283ede2254f4d70b371d542e4ca555d62dfa2c1fa46507365f848c5c3787bccff351cea4cad21c7179908542ea8e7e1de1f008b7b23a5ced861befbfb69ba293479082b8624ea201cf6ec2e169417da05235e5dcc3c865ccdf0b2a23e0d5e6d5eb7a6118441e6bfe4bec8ba3e2fa5b3e59909ca3d2e8917148a7ae4795ba7c958decefe0cd018031c337078f649de368d121b235233453b3c686045e115bffe4a353e5d87363c858b2a5c54126d5656ad00e637fd8930283ad691ffcbba906c19724362948baadd508aaa9c728bef72687803f4f8e006f76e80252d0d4e67ede01616fa7773f18877b1e950a3292c33bb435eee29e0527b4e7c0bc201049e12ebeb1b6667795d0343a51b65e449f60430288257b2f52a0384f64c1a54bf11ee62f3fceb1f6e66dcde620b4b14242ed1723012f5914e0b1f81d6626341da0b6d155f2fb1918e5daf80acdd21259b8c363a86fd3bdc910305e8f8ea1b90959e2e3875eb511398bb5cc95e9cf388677131c657af302767fc5cc3c2f8043a7bd8cce62d86719c482825a9ea0c117ee5e99a3b0c9f27d776b5d9a02468faefc499086611ebe4b5e9663e70380e4177213bbd8fbde1d3fda286bcea17f24037b68f062afc93d04df511f0ebde96567360d170f47a802d14c1188315e18145943b98453f641635296201188c27ba2e0d7bfab7aeacd566baf98ae433c7156bf41450cd65c01bc9a82f9d151639ba213524bf8cecdffa2c57dde9300b1a92ee03ad2a030c1b358a6197f7d30077e1d72e67e8ae761601b9302ee688df02235060a2b30cfcb6ed1ec184fddea8e94ac4dd415fd5d29a84e68aef210d8e2802adfda137221f570fa1c863be06f6eb2871df8e78fa17b302efa7b409eff97296a7308f828c274df4ddc2ade81162c4a3423a5c54b0f9f4159fc333f733b02388aa89915b26b16c156cb5c4b81ce92cf3c792d25ddc57eb6c726ef31463cfbe6078975e831f44b9d580a4a4ac5621f7a474c276288c3c77442a31c93d0fbd850b13bbd32d1d072fc352847fa906952e0a32e5eca3c5a55f05afd3d6cc9c4cffa0dccdc7770dad0c387c817191da31c545785c90ebd381c20e3ef5f135b07c0140b80f3b56f1d5204383e63e5cf77730be50698741928beccab9e70994531ec79d652d17e9f014dd07e37deb0ace6e224621ae1d03dbe2b94c8c8416f41734c7add61a9ec42d7d09075878342d428387db29ca73fe77c734fe2846c63310a41042a1462fc0777a211d66351fccbf53c1cba674cbea595e1b29f838f73455b6056aa228ac111910f1ea28deaa134cea929ad71780472474582402f7e35379031a1831780654ff1b991279b862f2235d194fdb0ec72fb7fd4c3d77b908f09b450ce454b9c76b4be11ad2adb9c36baf9e12a240b60fd096d10c9b8e67648d0ca897b74cfb79f42e57d332c5d26e9ce35b9d7ecd28ab89a29b671abce7ed5b5f7c94e97048732cf14e73592c47033e1dba2dfc42564e3c586982fef6afe3b003a48af32d15ecaafdecb9838afbe57754c396602c89d067be6991c9f954b87012335e66dd054561afc3ebfeb2d3cf6f48484d1f5df5a35a904d31116e5e976dcab7a18a5eb05f308abed86f6083f0d96bbf37ae94de3f7a16146ec126b724128c171ec9f4670eb580618d91ccdee88869734c0dddd7870f871a613f08e7aec4dcfcfb3fd9203d8681631bf7e93bf1b969f76c12e797973d62dba7be28fddb5326d6148a62b8ea62d5eab0433a248ba582dcbad02657b2c531e2321c2f94a199da3ddb9a182f433fe1f60aac001faedb0563bbddd1f64ef85cc7c7214a5ebfa5bb5dd46f1fec6ec8bbbfb883187d05fe68ea4fa3c238a9d5a4b1d2307cf53ce74d0c8c886b602e473b70c2e909aa4057af8a151d6a71c155482bc3ee69c8897046ffcc6727c5823fed6ee60ab4b04e4e51343007624ad4232cd0e005c8cd463da78f4796d3bb7d5888fd2c73129813672d5f2b42400befc13b31f47fcf10da6ab53469e8d1d5e18aba83d046fc32397e26f70b399650972ec950db5bc2b501c3509abe78717234c1ef6597e3a7a3c503ed7e2ecb90d34fc1a3ea995ff7444dcf67c35db4857514b73b6fd5e80490be5b846a7077221a2864ff9bf11b06c09c9d967c1abd4040aa38ac6f8a598c70d4855d58fc02ca828d87824178ed7f26f3e83cb9c54e92ff52755ee637740e6ce5b5c64a47a643c1d0da900756546d8ba9f4d052f5905c6c35f8eaed41d213d7d305d84feae984c1526cd3b57a64bfb295f4eeaf78f906b2d1f4b5e5e744322ae3dcd586c12e482c85eae0cdbdd3a13c06ebf28d31e5799c2fb8beec91bac32d1d17ae55c2ca752003838f83f2298c870e8f350119e53462eb2d215c075f02f33ef3629d9729a69dbd9427f3cb1657a96f2562d57bf8c5bef4de8915892ceb390015957530ce6a61b930a390419148915c6ed87500548a39dd99444d150bf5a4425d7a094bd28d5e3a020cdf0a8bddfb2be196e2e17034a845849356ae50cb9cb1fa4711365a0c891b982451347d1abb36e17eb8bca6068b6d4e4f32248179f3a56b12dbaadd24f0fa54e5a56c9e3e7c83b6cc44108205be26d2526f802b317fb3b976aa4186911e040477a3a274ae146c915203d04f5b0a0576549e6f3ca8720b4dc6238ff56620fd6f81e9d39009bb9f643af6641e2e18114af375d3e6fd5792f3920d654b4163ba360caffb86d6f11e0caea72487708d6c88afcbe4c9ede3583e79c0ff1bbd4837cb2527eaef77973d0058f99a8eaf20fb7032afcd3bf24f941e5ff494c1dcf24438a1d022a660215bc89396d7fb00d99c23549f60909362a5caec8407a6ac61547829be3d99411d2d076a07c170b5f8094b8c4cb6b9680c6cd928c2d6873c3947d05845e38f469d3e80031e7aa9f8f3f8be8d4d8acea1498322f97a4a95cc8a862500494be55de93fc4c9d6ab09a5e6d8c8ba7011141a3cc5ef7db9f6f95890099f60d29a23d7e84020c27db20778d31046a829b5970f40b5fd616018c0bcbb9666105b40c49beceadb6e7f683d6714aaecca9e1f08f08b80810fa53280b3e4c4a111210391ffac9c0c3e41d417133c2e942df1b8f3e17d7febcac8d0f15300276e75e82f3bd7b939f5ffb256ff5cfca9b63edf68daf8015457b27825078b07947fcd4c8544895458d6c0de5a7c4ac82e6732c58879d446604b33d7f3df3aab1388d1464fec34d57b0174a0ed9f616a7602f20e7f062dbb82da505cd90390a2febff5a0b64cd71a4c40ce0e0b6f51be11e6c19319b167d140a75eac3be11049c18e2a484d92cc01f6737007b0c6c15e977ff332b86ff883bca696c4b266aadcda32e222f164536917e59f747e595ae1211683ed61eb82bde9637c638ad3f42f0fc5a93ccef3b1e731225b1f1f5ce7a171723ee29634e6adc9ec8131aff161765f04bb67cfdd8a8f3b9c3ee6cf11841aaa127d04a70b91fc92574f2f5b21d383b6c0a01299a50c6ce9c5ffbe8cd9026c65b3d028155f11d2861eb9d3245bfa156bf2fa9931acac9fbb06da10be338053dfc3b4f5f8447db97256913c56b397061d942bad66b42b2356d5a6c44e2753887d7d99de53050985a80497778822c0317fae88169c756ce6377317cd88d3b678a5e6dbdc7e08e3d5a201370d756f755563bb1f4ff0517fa3f383de90fdf9749a89130ef2faf2ed337d41df0fc522984ecdb3c747869f8ba73731943f7d270881fe5bae89ee7a091ddf611018b7df2505e0a767a2a41f0d7f9cd9345a59fa46b24496c926d018dc54c402212b614e0650a7beaf7f38cd62e508e8bfbd5ff16ed683772412ee4304914ced3fd4fdfe2741420fd17153bcab7a7a30e9886ccf4de3cf5b80f1fca3862faf89b3b9b304d6ce73ccdb31bb766db8b6424157f37140a543a8555d6f406b838f6377a56e6e1077c3cbf45559783dc53e0c09feb2fc0fe5af09ce867c891383581130f7b7bfc3b7424a1faf21049105a827d1c325635bfc0fa435c95e430187991ab82ce80c080dad687cd97d2198b573c388bb0638fb7eb7811ea165904a0c5bbb87b0622bab71df2c86de41e23e58f8958b47a2c65ab563881e54525abb570db8a22a3fda437b2f936cd2ae96e27563d0f1214f286b24cb6c759a24442d66677eae65fcd9f5e274f7bd79afdaeb6665ae91c87ae23aee80fe94e7852e3f9e06d4214112d3f9f3db05cff49c8fdc0b531c46d27759cf8c1a2fd3fa44ac253492452b3ca78c635bd8b279a998cd19bc65239274bee4fa811417d6112264032b766d22db914d242b2f99ffc53c64fd297ebe86fb3dbf7b34477742ebb7dc53b4e81e51203bcaddf018d38574b1ba849675af6f10cb88977ef366623cf9ac73bc42d1bd3854b426b9f7546439ed989c6b75add1246ba7d0a76349626402241a4bc495db15cfb57871cebb394fb553b7eda6cf3d0ff4f68ab9d49f8dfae38014d50a9f2dd259bd06d2e2d91ac5601e2b6e3986de772b61bcb3c979e7230cdcb2878e27a1414eebb5d3e1732f4e2787f3c6e845d1a372557851c341789eda1275714d532bd92034d8fcfcd82e94d64318e266cedf34525fa90d5e1bc3b1e60ef8086759475b89529be70b2e6f618374925ed2b10177fc529b4f436038c90c4ad204edbbc18a6e1a5a4f91f71d396ba6f63b880a1c2d63b4027eae649c3c76ba0036b6ce7d82e272a63cb42220c67eaf2d2323ab43390f1a38c5718bf8a6dd27444bcf1e3fb59823cb8ea993d18f0e2c524d8e6f96e830112823bf2a75f97e48862480859e02d4901b49c691757e3971143e9f6fde03f60428684b96eeaa2c796342540e6c759057df9554e161ae41ad1c95be88a7a3768c87b859e962a6e87fb219d8682053e64ca8653b71bbb300226c438f639c6a0e19817530737bb140b45835884081021080e18d2dfeaf6e6fb52e03ea86d7e6bad22db6672f13891b99e92ecb75bc5159054c5c92438edbac222df48a7d2d2c5d175941b6a1692a33a57889f3cc4124363dbaefcfe9edb0b376d6cf2a4424a61c3e33dd2076630ffa9ee89dfaab15e75352b517b3bd5c50cdae6c446d3edc4cc7df7c7713d114e68d1368b31fd3d51407ba8bd707086d4db090bd006254a0ad3a55116f7ee0033fd8c32d052c944191b393302b2f26c8e0de338ebb2646c08ded1f94220eb94e36cc11cfab88be3e82c5ce4d2146e3ad236497acb167e71773faa42ebe741fb6595eff8ecb6d6f41adfd50b4f545003634d5ca1699215d86a943398e89ebe79fb895af5b845c1c25e19154a57991292d28fd5411feb192fb29e0facad31d9d0575705b0c5f73dea9ffea20bbffea40184f52786163c6e543285d7cf8eb709ed5c46ef611828cd43eefd4783375f196411b9aeb1e42587c09bca250e0e4b8255b8c815e878708d288cd1edf66bc59b2dd31ec63fe805a1dc20e6b18bb236d3bf05cbc3ca1161fbede3d183626248c011b3e497493a33a44493fd1733a8bac40516bc5e524745448811bba9b6e17131fed9df51e014b6cc08553ce25367857e819cde8e2c348814660b13fe12a059043b645d817bf7eb1b19486f54d8f76a037fab5928a91c850f1b95fb6e4021fb87c0ec7f7199ec4315c33041e37fcdf075058d5e9d211c70bf6ff2b8aebd266aca38dd1443d9d6bd4df47634b32ed5867082d57dc1dd33198083bd69821b8b1d0536a4a086c41e119c5c5f43bd817be76b58b340061d53946b570b25b871c80a9dea81a794dbaae8114e1162b591f29f0f09b0c7e7833a2520b8376c24d7972a0b79197a57f738b591f47e26392efb1b8c2d8fb72afb1bdbd190d0d7d6b625f4e9b9d7b1c67b6a9191c42662547a18d5edf3adafd628ad8a244037540cc2e7104f3845e97a2dbaec4d2363b36a7d7b51484fe6629cc40346a13ca0fce10f3343afaf69b21ffee278dc1c2d5d1dfdd87b8e885f89cc382d2fbc04bcb8ae27cc95bdac5b494a7b33ac830cf7a36757b477657f3993aafd1c1bed05e9d9eb2a59261a4309088020573b291f657d43dd05e7380fb277d44a6462ddf983900b3d7a6b1a7c9988afd74ded5e661a322b6d73a940753ddafd0a454bc1929593989177eedbbb5b3586f8fb85d67bd8910c68acc3598233fafb051ff56de3f189f250f95f3999473a0fbea08b1db09cbc1bbf29f8593d11cc1c29913c6215ed49e4fbd5c933bbbb89457dd675f27bd12b133f4d336eea8fb466d65eb4b3d3de54575f5cc71717cfb5102d8e4b5e4a3c9f5d2a95d31aa112dd40688b9e3a3b61a4264eb567e26a01e55110b1041ba7a1d0200f373385b1f428ceb76681f8e7727b2f0cbe7a389db34b2f0dcd562dd848cfc7d8dc2f42073ecc19719aa38698798358dbcf5647b2f95bc70a18c034528dbef846cd1ddb42a9cb94fe8602d4b8286dbeb183e6bd1f9953bada65ba8d379d1977ced1da6282082d9f91944d060803a9851c21726058a659ca96a50f25bb2b60eb19ae0cd10d924ac386557b81a138307fbe46df006e4266a0ec557355063c7a88585dd91432d78292b82a22155d3d18f70a3dba9508590c061371e3e241cb41b62c78769f31df073e6b9df4be0e3ee700be4da9cb7874c214b172ccdeb33eecd83906309d93dc0a0cd281858a85d7f6bc66414f83f4ab73cbce8c6062e0157b5952093211134400caaa74ccc9102f205be95526b07fadfbfde367fe6e43216b59df4357fc2394ca1f03083833eabd09395cf5cd2111488d2e892a457332256d5e0209195afd0dc048ce72117c8810a867910530e89d8cf0282adc273a421c22c8640f3b7d6453bc441cfa17826d8efffc302451d8cf974d3b21132f4aca6c130bf2d8e50b2dd31a2bda2a3600d95543287f7c0f88b3cbae791176dff694e69f3b3b42c65f8c7a4a9d6a54e5f9d17b4e8983f50cdf7f472cffc0842d6a6041d5b0392cfc9592f2118b9732687c7ac9da137ed440673413313d3e9d8e80d5cdb11238cef0645034679d83643bb4942c8d1459d688e390c7055b5fe66254a41de5a11796151cda62b8accc70d868c50d1cbd3c979b018f0435e5ce81c4726fb21c96ddea54c55e0aa2d46146db6021bce01fbf6672e4db27b0b0c4dcb94dc0fc87d6b2dc3166fc1b4e161296bdd0ddee6637fef51f55be98b5c4298c57524cc9e382b6319918ba171b4e962973d874cfdbb32953262463244b552f956605ebafaf4a0048fd8445099480ae502b087473b15395225ac96972f7cbe3d65f6b1f941bf28527a9a8ed955a16be3b6e699bab8cb9577b860a90fa1d445f8563858f2cb374348ee2662f7a80dc008ea1e7fed2e71f2fa6a76d6a6209d81d13cc0fffcd360d2ff93b9b147921e458f7308fc954832fb7eb9bdca061d58087b80a4f4b7200305363a199861e403bd22e600da99641f15258dabe7eb35fca3c3b501ae9865b475faedabdc404ee270f089672ced09b64db8f3fbf317acc68d0911ff9ba0aba1bff944f76b994cfba7722fc1803dcb5988760f3275aeaf31e3314855881d9d18dd03fefc41ae0e6db12ee1387bf161313f31d1ee2c401c871b1e2c06daed92ba72d5d9120b9cac8e30c3a2ae1e3fa178a694221a04f69dd9ce4e0a4da58d903db73fdecc0addfc5f8beaf883c68a6d9894ee83481acf82ca344d4b81889b33c08160cd662430492a1179a574fc10b0e088be22e1afed693a1d514a9c01c844d86bd0fc0a6e5843ed1f01fb24d0b97cc8bcea9203960e7b9f53fa38c40923438749c555cffb4687086d56c64f39a86aa685dc570efecfa6f000e6103a27d5cec3cd78025ed5dd38fd2982d84597ca06542dde4a0c51b1c2338cd1aa33e4efb0cac0a829c74114ca579c692a7eacd9e742d383cc0970ccab2e2436e30fcafdbfa3dd325ca8f14b84d69b7d2f4982c7aecaa1978bdceb15b8762742b653d5ae78a04049e0e16cd13dd4e1569234d91ba50b46ae61fc65bc1ef551d57b2572ce67ba865549b8bc9b7ae2be4d65989099a8e7c9cb28e2fc4d72ab40cad154b6a5be9af1974b325a07eaef4225b22e8676b0c080f36c31688dc983dc338a31416b47f3a5802f9f694d27ee38a89f06270d6f9bb8dada2a10d0d9423eeff06d696bf12a175bcda2a43ba8573bffbf004bcf881b107df543824a2aeb33fb40999759e5e6f1ea2eb108cf0c28556448a299e50433069520defa0ab3ff6497a94c263e0d6d0562ae4524537476cc7c97f13e6a6e4e4f5243a66543a6ee7df0bb5f24932f926a05e0ea53f44fb0656ce63158995a5f9bed464e088a1cc1c71577a292e11781cd94bf7de0296d2fd7cb975f98d6da281b22dac08e0935d8ab71cb547ae3dd54813c243f0ab028af2716516a8a22dfd0823feefc204f53ef4484a6908f051eaf63749be6dc298cf97ba6b8dff25412ec25ca8fab70ba53a7eee20c44aa057097cb054a370f4f381caa41d9d97e89a826b5b66f740f88a66e1284c635434abc0d549b19ad52c2085ae0c65f9f089436d6c87cb1026c22ab6c9158cf1af86a2d368a188412026ff657e1a17a843b04d2b05b8053a8ed4a4a187f4c6ff3628227115c2a6c7c49f6ac173be6bf39a3df560201279912547c88868459220f30f83c510a1a8811061e01f4635196b9d2beb662d93f0fa327f360fa88537e41cf6d571f6ca4a5b762400622fd15a71d3a8bb111a788bb23c707db5b19c8c7d9cab3724190e6b753dc1c3bd6ba470f4969efe35eb2d1ca1dd6d02dd99cefb48e77c5a9cab8b8d89766814f54b220b09e8c794343d79f6781c29a4f28b6a249de40ad0f1b658678acb318ed19eeeae87a885761cf1d1234dee7efcbca239cdb836b9363213c434cd661fbe41c12c7f819f3e8fa0f4f701d6aee8152002cc46c9be873ad84d2f962e1a6f2516a1f7ee0af54965195f237f3023f2db9b875ae757cbe493fd05c874087e8ef12a7f59cfc807f31f277fd64ad4150a497bc1244bccfe6ef5d7ade981fafb4003b98b0852e56d96ea47bbaeb8b1e956de2aece0f7add040e2b976de4b50723cd0625618bb9069bd4330a9e38a1acab6602b8f1898bbb06ab1a31ca56c828fea48697c31d967ba1fd2d0b126a2fc289e8fc146dcf067c118a1f35cfad5647227335308a6d9d7ea030771e811eb41d3633b6361da4432e4dd08991bcdb51d66516052cd282a31e102fd508e755375c2cea1f77cdd560a6f4ff51b717aa45fabcd52c90d936e73241386b43faa4b41c13b26790e08e4a2d7dece603dc8907c2c186af2428102201a6c668505fb5f9e631fadb48af998a62cb554ab7df938b4430d5f6085be1a1ca2a07cbb4bc3c83c45583ffe655187eaeabbde77301d30bef19d124a3da14cff1fc75e0d54c4b3f16b8624c391603b55fa357809aa751be3cd88c5b0b8fbd3cd00da2c65f2bb04aa1a6215cf16b2fa346999f57fef7506a764263cb86e4a283a55ee5ed8da35744f333578b6df1f344e83c23631793c0ead81ab6d0e56789c32c53c4707b9fec50e08480604e5eb6062765d79e8aeeb841b54a1238514bb66c8be433d00ee5eb970cdff34393ccab9ec2f69deb62a69f22943c25876f1ac34d6fc769183000676253a38f7cc9c39946af96bc3ba5369c18005f4e98f55fbb15e4c540817669e4aa2951ba2500a909fa399b2d5a5b6923680dc36a51fb1b26a58e0d46c7ee96604aeeb20e2fa3fea4c55a6f57b4f816cb7208efb8fa72dacd96c346bdad5c807a35c78df9495218436727132e8c12a7822ef51ce1ee922108035ad75e9766595db5a7f1a39f0c4813613a2547a5f0897083ebf1467cd34f53c07cbdef50f2a760fd956d7ddd37d7d90af3a2559bf6c01d7afcabfaa2f83423775fdd440e5b7341db278394df2ad7fd2a5db023c921f983442e855300955645b21073e59770e9609da36608a4e916da5ad4fd39badaa5d257dd0a7804edf2f1979a584336bde03d7a12703425c62b7eea3e6f45b3a60ff75aee9f6a8bb20c9dd30e78f511d974ae258e982c0d","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
