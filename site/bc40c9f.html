<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9627af96c9134818979d7e11b5b67075167efcfdb67d3edf619511b726844f8ed9300ba124e1dda6db4a0c1a3d353bf37106e13acc7754b06e155b213409e274b34363496dae3fe05d36998b50cd99df09e2f26d12f7dc50561313be8253214219d8555bf671bd21295cdb79c98a4ec0ed15d6e9043ef12fb4896b6730479126c2756909c085722c75ccc1cc97750dfb6873b1397765087d9e0e7b2a4dfe7f02fac5f961413803ca4633de242507b6f70e491b1e15160b534c9a72c67bb6e15f043fbc720b462bd6a768d3e053d1c5c30db070c271d9ba7d711cc30734d49e9f1f8ae8b6d653ef8c9cb432b1999e94f7d8de58e2ec2b7b9f17d83c620ff32ae87e888c6115e12acbc75e07d45bc0102b61c2d5de5afccb47f45d8e6e850f71737a73b8403a4326d8dfeff79db1ec4b081a1561a133d571de51d7b9217f4fd9bc36929ae1de786c13b4a60fd4988572acc1dc965da3250af32123f0a5cfaf1212cdb427426d50f3cc5bed320955d4ae604d2d8efe7c23819ab5d3caca62611fdd8f2bafdbc77437dff132293824a088a3ab4301487e7db462c1ec15baa3c4f78186f062bda5abfdee933050fc9d23ecad757f01718c114bb74357abaa877b94cda8247998e54ffd8dc6082195a595269d8f11b308eee06e73f59af08c9a53f1e95c69dad41804bf1cbc5318442de22affcdce893c311a414819f0d3ba4851116c078d40f3260a9bfce58190610c372a4bda74c9f4827148df8bc4117e7b30897463da18e80d1c0e6b8f1436fa370cc4e9d5d2997c9c29fd0d5bb516671ea3387eabdab4b8b8ecc94133d6cdcb56ecc066a55e6518dcc00a706d55af6f5a16ce7e897020763622553fdeedeb2e1efdf4790dbb626bdddecc2b51d284527d3959e0648cfd45633f14f70dff555c7a4d267b310a8f6838fee1a48b62b80d3a9bb76e1189941394c4533cdedcba82fee10542747c88642fd4b3abd6353434e6248274454020f39e9de4f288ae9b1a7929c9abfbce5da5630f65004f6498a699db103217fccb4eb1d0760c5d46e17276fdb592219ba3bcf6b3e6e4871196bd16f8c8607295f351f364d2b8b217c03836e8556f2b6f3260a5aa13dabd681bf93570e25ca7b904379b03393b14accfc3325e7f4548ad8ae9983a0b1e6db28507cad830db8153391b29f447a3a87d0c374da0786bc62333a0e5cd7d6f7975631f6bb32d8c0000182bb8d7e14296360a0cbe2e031d88bc3cbb722185eda6b7b84d587c763db7306d732eefa974cfdcdeaa58533ea6ac06e110e3d522f187000618feeccf5f8f8766b617143b3ce29f71c826906eaf7fa1e930b0ba3f1aae6abd58bc4b76a64227971878ab2857030efcb1e292b4e8f8c69bff904c869a233d8ed2f36c1d65de6683c0c2ad35b16dd7094666b8c8227b0392715752df898ca850bb3464eef1461efe58c429be3815cd29f24e0f18372e116bb350199c3edc00ec6d9d1b162c118d8266f3b96b46dda801a26f4a601a4bd8834a5aa912c72812f00d4b55494dda30df0bd835d2adc909e455463b9044526122527fde623a290bfbead70c56321d083745daf258d40489f4df406f9427accea2269278cd729067abd5df0485a64a67a1eb54bdc869a95dea1b330530b244b0b14a9c136e56589de942ae32e847808b10cd218a44c270a689db54cdfeb0ebb405ff38fd56cd3e3daf8b9859452bcf4ddacb949f6ffc7e9b1aa941f6d52640f57a4148bb8d49166c9a153003503701c2c591e7dc819ecc226965694d403a139d2126f302d00be8d5711710860add62585e4dd5c4f9013726f29771c2a6afbfc601bd52227f380452a36af4df091edb7c739fde62b91b983b0f51ddd97631cb8a03f7f5d49a1f1cd08d2ee029011748f27ac797abfa81e31d02a0b67336d3d540182394c84b9ef80a0493ec3bff1331230b8fb6b4c5a5f6c10fe5fdbacc9f8286affe43b9ee50f6b73c16e4507b0bea0f4f2e77fe113101cefac98d9db2888db7fcff64b71f2c15c0d0d24273bdd0fa5bcdd4f18a1e7e9259af48773d92f55d07ac62d5aecc4495b0618bed37d4bb94640469d013fbd9326e7c01ee032f0c5ca8ba614427d60454f0c8ee5d1f8a71c46c42f3b75e7f4ecb30a8eb5104c03ea78adadd605479d9543fcdc8140469af3aafb6cb672dd2269a306c71de417609b91ecc6b29ea36ab54f118174aad411025f848304e5ce2e3878f144847a3c72c712786e516ec0ef7051fe6fd7cd56085c9b39de982c133667f171c6c0aac4756b1eb1f7dad5d66d9a71e802ce0bbb5d5c2ab11b5ee440492351207a121798df665d1eeb2f7be9e8b88893695894745864a6e3c36db87c09c315ac2f03c680e99ade90ac9a24e47de04846ea8febbfe9e15d4ac20be0b29d84cc5b58a49dda7cae42ede368da8d01412fe44a2b286a3121804cd492bd0eb8d1e0341d6c6c8ee4173ab1832fc4bd66fcd8f6c3e00f613dfdaeb9c6349650bd872d103c8262da919c31c81dda1588f89a8813c78c8a4772cbb28344835907a99a77b14e46526a2f16e3dfed5db1dd726678cad500ddff88ea29f267fee30b325ca8642db5a312158b038b7d8b18d19ecc3aa59f113f9d18053dd0d229322d3284e5a2e20783fb911806d2006a3ab9a51c2d15547582054130079905a57bb07ef73208546547a448497a1623c3cb54f0d4d4f21f513d0ed6c95d1a78459029ca4e85804296a378a473dcdcada35f3e5162170bd3674e7c7c56366ee04a7b3367f4ce6535542203ae2ef427f98cfc501880b94ddee857f2b49e6c2f20d6b2fbe94336f2769851f0e3371f687b49c394592f479ac9c0973c4dcad580cbf45336711e08508d874665e3e570d8026d904235296a5dca3cb0b572e06d9e819e59aabe0ce771f5c7f7927139585730cc51df6a30ffffe87be7be6eacad909f861f11e386ad91d6667e698537b20a0a0595ad68e20078848e92ff02f2830284e748cedf4765dc5f7888488876f60a669ca9ba71f23f8839f0f0e0154de550c919f7b6565c738d5d0563580474323dca9b6d87507e2e0fc748f52ff094435c828ebb2e45a172ec93876e7d2873c7d86f1e4c1cf8db815822e6c72f8cbd3d16ffcd0b43e4f1f0dc3e4d1fb959d6209b4acf8c941bdb812e85e2d12950bab24e92e902705811297307e41f759fb56491a148dcc1360e1c5f8a909f854af1a4e1c3a98880d69cdce4842c44e508e97f4a2133b68aab2e269a085d1f67be7a6fed78c2ba6ff853ca4e91017ac4a7482a64606e968d8f17e138d80275156108d58a26c0c70e4cfddd24680fdbf5a4c7c728cecdf6e12e7235720819a653f9cadcb27e15700cf618cb47ef9c2786d42dfd535f57aae73e3c5850a00efab40b0383c5030d623e1da0845c5e80078e0584f92f1a8b4dd9985f1b7256ece84bde37dc7813d394bb87fabc2842b2f6467b112e8812b2a6c6d4a7cf3e59f0d0f7ad9802f7e8e8a9e30c45354a340832fffc72a32350600a15f1314e1c91ad6f89179bc6cc763c116c4969e2aafa49b7c57b39fc915a61bac0118e1bc6367ceb79b2689d2a97090655261221f16ff93e42538f5a555971d1cc18b76ba99f5144cce08696cd021ea590b3f304d75c32e27e1f71938dcd64991f6b5cb7c199899a9e8a490cb43508f3f97f7a3edd597d97bdb969047d3e5e564a029266b347226b0aa46bd4be424a3c6f3e58011655ed4161a541a9da1a43b9edfec3d3195113aa447ec84805b66f4fb699001b2f94f9939ae7ce3a99ccff0512a29ba8bffd1bbb28745b7c665c2653a66ade34a266c69f9722d7addaac13209f641b55743a147d1ff19a4300baebcd65ea19c045fc7d3e9ab99084ea9e82c871e1f2486b62e2c845628d5830d0894d36201c985fb89ac1093f2d74e5204740334c71966d2112649b5ad2895fb7227270da9794650c3bbfc72f5083245972b4a262e4174870b8f21214869f4041fac678f55ab8bf561ccf192e295c7733ee372fb4346c53e6560c16e8d740a39e7d00431beb33aa55855bfe8698016fd2d6021aef8e2138701552628344141804059b567dcec8fa16557cfa7fb32f1df7c1d2b0cec4009e49bbec00738d14472a69f86c183e457b163d39fe27e04c9aacedc3796219124defac8ebf76c3d0c895d309f637f6653b186d7b4fcdc6e88c1304635511edbb29d48b286b2f1179e84f6e1040d35b248478add9f7c250a90379295d65bcda6586e9704967f183f891527da935f5d858c288aaada81c634357a8386f0a032dc7fadf153ca662e67088b9488285175ba3dccfefe302a96bed9bfa21a5218b134f61f0e88086663b1403d24633a3b1d2571ab764b79719e6443e8d57ed88a52a60dfdfb46ca8248a71db60a9222af0582919371ebd7994db1a31d94d06858d1730a9988b775008a3202be593198a53286f9dd25c9fded8ff06f932f754700dbda8e4ae871917e19d3e0e225e93a1c919bc8b3a9a7d9fb0f76f753711c88a761a2d37627db9dd267dbe487d985533c97ad3176a70eff2f3da151d17e6afd346fe00a83283bab4247b718c191ab747988a026b840377dd94110da95522dfbb82a2f4dbea9802381e47159e4a512565ef387376baa7beb7f26cc594920c757bfaea989f6f45478bc8e0d2e5d7ef96cba80c68412aa9088b446dae8292f8dcfb4aab2b11e0deca20532deadc167ad3890109176d111568ba3d0049a1893ef8a19ef889847d705972cd93513522ca3f821c6259918f874f65a093968451342d107a3d8d43c357b033a3f8220cfd0eed59ad2d58f051bfe06ff6b4af72327a5c8aed8021e10ac92500cb3220d1f55e69d53043e53c4416ba814cad4b3da3637f439180343fa8f2886bdae79056494a50e38f3f13a78c6b336541cc1caaeab2b92d3314fc6f313d1c77a1271f87c88f996ed2e76a6b279cc90a0d066d57ed1ccb258bdf183a2274d715bf03029cd0506400b729f527bad0209b9994b826acca0ab4783d3d37c43ce9ec837f67885e1ec33c1e3e461a4fb690f6cfc37c63b70ff8270d6e5eb8834a8b9ad48528a0b4d88a3616f2e47609c37726c32b21b601c9707a6fa28ecbf38650efb63d0f489fa1e0891fad4dfa28aead4865b8fb074aade6f66262e49a6d0c158d3f9295f630ba4c5e6df4ae47117fb1a4179383665f5455fed6f51b92c38f61673e782b16e6fc7769ea88811868e08945bd521bd5c8b2f730baf1b7cee68cc286fa4e021dd310b63d10465a5d9d82de94c6810c73e24acc46d4994362ed32d59f24c8f1ec6fcd2abe66b022a737551314e700d5bd5e69dfe8226d9f074712c3b423fb4d66d6945d0aae7eda5f6ebda1c8572d88ef2533c5f3505f3c3fd596a4f7d582c52518ad46648cb6deef94f2e009eef2b658622ff8f917fb3c9aee60e9d3b7598b03c61e89d5df3499bb71b32645a2c9472360f6d901358bf48e4a63643601fe97b8fcf4554b2be03a0446d9ac1fe2162dfcae2d47bc0101442d46ca5b5b31232a51cddae469d3d0766f352b0556f74c95c7b74e5e8ca115f6d4e7adac9edb76b3cc3e93157e1cd13c8fa93707a99f937843f3859d0b14b20f934d32914c79f9857c831141d199d995406f86b3dcd3b1e3a07c24004f9382eb22741f3bc7734f13a0af958f6da92e8eb8fabeb709b11dd42784b21f0ef15d622b9a347b4d596825f052a986210365c23e9fc0f34dde572a7fc75fde2e229adeed4c884618120cf146eb975ba94885f66547ea5c6a60dbabfdbd92f271c122c1bd01aa1a739faf15ed7d71164285cc9ac6cf0196de320068b5e91e55a983abe5693e65783b3f02e9ff9d62d556dcc21d08ee4ae05209c0aa9c58c756ae8c3c10f059f9f59b97be3d535b7b4cf49a740b36afa74e6de99ea6c95977bc0466a37b9085fc6f31c90c1524817c313be1a95b25b41ed0236f92c7c44324583fe146b522630cf200cdab9231797db05d2079a257eda278ebbbfc5cfe2716bec337ca17f35bb37de1fa64bbf7ded8d57c4491db14c16d92e8568e9ad27bc429970cc2566e59483e4d922b8274402e60d7e5fd2e6886d4f960c2e204106e2c8ad675a0ad3b3c6ad199378bd007f5449ff3c4ae948bdbbe6d9747526fca6a17f56c33047f7911ee96da0396bd518ebe0a561900d3506b1f6a45d1ebecc54055bca1b3d369661eaeecf21ad384a8c3e550f77773aedb8a0a3af524fa5cb1235a9552c5fe3e8fda9ee11f9b7069bbab2508b2072d951b1f14cf67fb5bf9e2a52086f6a10b4217ade1673b840cd46ec4caa77e9e94b1d87521616c947425b8450a56ea32a87c0321feabc2a621b12270eae631b2259abdb0cd3fa6b2c6033fd345dcdfb1ca66a69514f129d2e03a5b586764bf672ff948424db812cf90df26f80d72cfefe22819fdca2d2998e7cf03d76f9ca14d6f6e9aef53f2bb448c7dfca9e9dc748b8f4e04ccbd557bbf11e27b543ae1d29101f7d9494ad542d84c55f3bbb9ac3308c63644a4e3986f8fad256da209e576119f5160e4b8b0f2a5816280a20e66ca07af47b22a74597b037a36ab25bbba1c4201e2002cbc74da5adad781dc0108e7c8bae6b1ca6f8da67e7b62709e66932eea152402eedb78642fac7eed81dbe2ec7e0a6491ac2205eb38752183d3260cb526b58cd5b71ea98a6f94f85bd7925519daa8ffb350a77307a5858738097435c17f8ca5e0a4cf9ff82673cdde029565b5b65bb9e5e148a545f4ec8ea0d4fafdc588d7288f98c1c6b7eae23eed9325e432e158bd8e08d2f04480552f448ecb9a674bc92f20eecd81bbfd0604622163a0cfca917bad1a30b9ee7ac1d1f6cee50054671a7601e49fb07d8f37380a4e924c5ee945b47bc172acb86542561d275b43fac044c3efbd02baa46a76ac28478dcb5574f5684667f4894d920aa8289a1af21f0cbe99640382d0be9fffcfb5e9a1e781876a62a8c2c92e86a5c59e2608acd755557090abd2813e6056b25854a535af72a697701d3c314902221d562c046425af13f5167345554b93e041357990ba5246dc2cae4bc1c63b6d83dccadb2fc79d736cd2b458e58bd584c44901da5334b31413b54d2e2b5dfd08178579d5c055f1f218ee0ba3239be38aaab8080a7771a60eb2aca031e2ebbfb499ef49c57d591ea031315957c7fd69bb9397a2412a3d92438ae25abdaf52139044dbeb382ed3fe18873922885ecd9cb9878ef6fed44f07885ab6dbdc62653c7a33a02f419e885dfaf9e0097f031eab5feaf8323cd92c7a6b4b74a493c5c6e8e92a39d04b0e0e6636931bd057e483bd342357bf15799fd262f70a647c1b991a62149295ad562ceb412cd5562956613bec07c108eca4f6205fa4c1cb19ff917f022a4a6442028f4b9a5f257aceb4792ce0f6a3d647b9f02de380192d28f3f6c031443fce3ed5b2e91bf467e65a09867527ebb4549d84b06e5224ae668f6ee416fbd67cec1fc106135eed81d62cd94b0e6e6e6e9c5a413ff77eb8aef8dca0d3d2571fbf7a377f792278d847079236ab4cb78b3e6198f032be0ef77846f1fed2716738a549e62b16aed1b4b010cbcfc964d80e646f95bac53d1be7f6c4076331f3054c6af014af13b338a8cb63895de7b589254617613315d61c31751b9761688b746866af22dd21375834a1ff81c66b05c64a6ccb83b2924ff0f1f52582adf996724021fa2e7738375e41bd575490224f6cdfe845e32091698bc556993826922d1c3d8ba3e8291321b38637f524f9eacffedfbe55a0eae434856e621c7b13c8bf9c12738ca41d19032f69377728be6a410891cbf30a7ddde4f68eba542939e721b3757d69c59d70f54dc4fae1441a9beb03058920712b18b6b554a5c946eaae7de34ea48c3a96ffd665c404aed53eeb9cdeee4de01f0208e3142acc1e639586bea2b713bdf50e3396c09f2e74f5d347494d6c289608b38c9e8e2c5dec1f0a700e8a49bc46a11699f1bcb22dbd05f8bc497ed97b51fde8fc9bb59fe1140f1973e4f46e49eb33f61f760921071503d97e4116ca9e576c514479d1b11190064ee650f8b3414f3bd67c859c990258b37a418c086ef04774c5c5d2d37ebe9fe22b4ab2c1bde9591f39df3d9399e9013d17d326776c8f7edbe3fa12dc5145f346b942390c835be33e32cef51ab7f763b73f894787025ed95b460acee19a4df52d31eeb96f7e2475e33b348aca113cd4eabe3bba99f9c1630f62d654547e0c08d51bc1c0aa5aa1c55da04fd120349cd81cfd8f4e918e74668937d4a36de2e923b09480ea14c571a77ebfe178450b5f5f73f5d504e7e10e49d50dee3ad3642ddc7e7717c77cd0382a3f547f80ae9edf85b1fccef0e602f27d2714c7d2a79c05d549d13272d7a12e35f4893a2a82cfcebf9d79ebdaafde3252b6be17869edd6b8e132ea0d94598368e6b75ed8ee1f6ee738f86e50dd4d6c03aead9c985dcea072b2e8ad6cf1164ff142fc4568578aea7ca128968773c21f099277954a39e85122966f712fcd51732d03ce54530f7df4ac611b2e8b6ecb8e31a743c6001d3a896a6fb65cb7daf9a320e44808903447f67cee9ae3a38db786314fd47e3bdfd6fafb9f05158f292c76dd74b01ca0ad384e24f41f92bf55830b478611c2b562fdc098d48d256d99c6d5f0df08a3c638baf6d63f431c1b22bdefd52b36b29b8ed3de3f778eb44b730c144b57df7a11349fcd171acc6a3833b81e1ea26cc69bad869ec1a7c91f6788615c38d947c2849c552890f9921649bd125f28da57a2adb8bdb7ee8ce2da3e80cf64b92b9ef702af7893a3f4e90338725c3ccb449206005fea0fd07365c38ca028a16420d7e6295c775ebbb31c6b93f598eea216a72309eec9b3b83aa4cda50cd9ac930cc7f0f6dcfe3fac2853b8bbef1458b0b629e80692a359c559ac3171884c93de41226345f5abd5fa088c441efb0164b27b6b3b72603991edf420f38911f00fecaa5b095af388c2fbf9680ed85546f6afedec28553c1bcbdd28a022d87f77ca272e97c3f34f2c971176abfadd157eb403c554fb936299afd2e0cabad985ab426d477eed8548c38eb561ddff9f3d0b80160129d61ac96b635526c450913cbf3f4ae37212484c41bcebf69cf4508cc740ed9566b9c4d2d61d9bee1ca21d50c39f3136aacc10f409a3ae6fca9e6128af56cff38bbf9a5e080c6d086af61ef1e5eb8057109fdc97b495715a43d75867d7ee826ff05f39dcd8785541cd37c82ae48471d48df0faecc13b104730cfc2cb7938f8a32c5cfe1535255121ef1a3e12c27d89b286e1f49ccb17c2684187dc91af8be8f1eb1fb02a9e52489a0f0638adcca23f2e55c671613b352b1a87d378fcf5e958a4b7378db4c95f9e317d497484c474f264c92e9cddc3e8dbe1fcd34cb9680405ae884680f5b393c6b768b3d6939dbf843d90344af52b87c19ba565b2e80eec4414ded61180b4d404b3ff676901c8e441e29f80156a91478cd7ac65969d8da667d1905120c8c719be373012fadce0e218efa92cd8d073cedd25da31c4a98ea751bfc54c658e210ffb29f1b9991a472f9e0a5a761929cdd9972678fc8320efac1c81b316ab2627a43d39300ec1a51a612d2653fe0138dcc8aa7c9932337864b6a5221557b708b273b5cedebe444be161f1b93a03a1ee7b60567713495bf14e8a8411b5c12464aab7706f55229c57def5ffaee5a198bd02e9b8a572be9790685b07bb7643dfca08aab7d9d8f926dddaaf6a868ef19545f24d5534da249d0fc5cb19f25a8b30c5b6f822e25770096cd6294b54668d47ef4da31244a6491c1ff88fbd682ec5d417ba440466a084ab21af07f2cb890b225dd3ac4627b6991430c697d9f268c648be1d1180ff5748371a260be56fbfec409420d587576ad0474640d92a45d10376716c536fc0ec8af2ead684ba1e5666dad1f675dee364394f4ecca475a6c91e3f99cfa02fe61eaea2d9e78832f91f9dea4561ce164fe6b1a7406b890767276964b13194c86fc28d8ea4836ba8b7ad8a49000304a3d0f4773e54a5fcece1ae5c35cfa1c82ed68f415c0add68b1c5edf2510c512fa3001a1143f6a485953b6d3113f38e1a8cc8220c5b620511873c86851b598b8e5bd4718434e9942643921cb790b0853cb3dd637d9ed1de0fd134889211e00ced98f1cee0c2e1ddcec071c1e6922c58df2c2552c6de35293579da74c1b82cfc5c07e54a02d66dea0c80739bfc5d92d8cab8e5533a408458116370184e3257f1456128a7d11b1290139f0d3ec82de271a15aeda5c29fca00c247726884f2f65145c39e3be90a23d454e79c20c4da252ae0dda3cf2c1b490a64a98b420e3e3af808b3c81cde736b4b6693c94a73b3f7aae2d98a2d3e59386deb7976d85bc8d821f096948f4c4249363ca38f7f79457a654a996fdff321286f7d52735774bb1d62331753d3d255e630e1ff4d180afdfd073d2c36bcab05c6715fa1d655d251fd4dc9305036fc34b19c269d90524788d5743fb9345241686f3fb8e838c6d8e443b0954b2bc3e6031871427353381b9b89811ea831586d8746bd8425e3927cd3d4118ce0a1b3d021ef11eda01db030f29591a5a73d4ddc7293a49ee2270b08ec7124792bf6b198569c185d944ffb6ec512d4a072f6aaecea8ee7b81dcb631f4efab8252f82ac6f046eb8c2f5c9e487097312a4988ab71583e3066add6eb4cb091e10c70ef70e8d582c31a238ab0aba3472b82ce2279cd3f80b8fe3669cd47298b1152a0ce451913be798362f079f08f90d37a092d01784cf33f812926f59d241dc1adc4650cde6c3450c417fd3fe62eaac7ac9e755d60b19940e9353e9e5d32dca3442bbec5f223483aceea856fda4c89e550b4d75b2e08bffe1f6494f6c86ca0e747cb17fff61a2407be58ec8bc0c5c6e302020c94520897ad1c03d3e922e13d78cabc400306db93f4c46142940aa3e3459e45207a502bb39349754a638931fe2b3f6fab66d929c11e7a0575dd4f8f1b8022beec4734b229f7dada09b007738cc084129f307067e7b6450eaf35f7ff7bf55d0d9771e198964a5526ba22b11edfe937e6b9830ac14161400862a93638f339d5d4639dd8435374959ed63394ace00311fdf470b9a347de2eee91b072042dce4ac99ec8f71977e4b914464737225f3dca68fe3989ca3eb06ea5929537b0c750c784b0fc0d4f87ff3085d3487b90f1bac460057e1e9199ebbbb6fe175705fa544a76f5a6d89fbbe18deb63fe8b87480ecbad534ce668b3cc24b17bb091c2c8c32a05544405f5f948da5d14c405bb47c7482001bec4ad374c33e4a88fa773b4b270f43380b139d6ae39f6c2ef6111dde0162ec69b4af3162ddf2c77ec0ecec487608d7fb4ff288448cfaed54d1d1f09fdc6b664b95497f0856736eef8b4fc05e4414aeddd9371e926d4cab259060125f12e577162dd895af91d672ca7dc0e554aad088b1aa5427f03105884ff33383851427d35c3096378fc73d0e8ca2d9be3056deaf826800efe9baa9a070712d9d642fb98c878349bb7df08cae8fc3d814b4a6da66806181e2c42e98e0af365faad2ec6ccc8b8e8a79d904766ad2f3ca6ad1f3a9d7cf7b533c9db27e5b6da12746c03a8cd1ef3020af0195354d5431b258fee63078a2cd7c6b870ff4a3571e190e632e9626036c91b9414e56d934ca50a5c025bc40b1c0583122c7d5b53999df28306a6cc7a673e218e0233d972f176580e967f6ff73f9faf19918644263f0a2db7834d659ff127cd4103d03c31b3b9a1a690774fcc98f3c71f80fa1ea2260965379399a66f7f8e995cfb8c4c0ecf76f8f9d728be231ca71ec26e90539dc6638b589d9915a2e74588c061055d7d6817f1f29e7944b355ad74da30a7b802e2f5cc89f8ef789d9a6367b1c2b1f8727e7f5934b6dc6c1d5bea131ae245da90cfb1e904a267b49d426bf0dcbeab44984f0c61b8667e7a83f7effd975c47134aef4ba0f7f5b8441b591e25a38a28299a8929fe2d10dc1f4219d769253710cd02fa1f661e2e59ea43f63fe0d83150d0e5448bd119a9ef0cc435b68af8978d72f3b0ceed2cbe4ce16b34e658c811049743ab032e26eedd70b0add75e2b78440cd1b023074f0d4bb6bd3ceded84fb7da9dc6a8fec73afca27a89990a659a32021881a14d7d40a5245fdd3fb2b49ccf95f23e2f05d0a0a07c06db71594a806898668430603b77e8db6720aafcb9462686a73cfea985655bec2a81188c7ea14da6ad824560e4e45036b00e3a12ae3290e8baf07af08f03213d1e2af3a35b460baa260d78102fb6e51fca04fe004e3c2480831acdee7b1d788732a807256ae8c5df7ca02c8d575c7e5f1965ecb6095f10e7343cd91d92ebd24f5eb5fbfc6539c985ee56a7c3e504669016112890593d0e4c864c67ac01e5d17b68edb324de62c2ac49899dc1b3f3c35249b73b889b5bf02a2fad6dbc904094df7b80471e8ee327259801a146c7cd12e1bd4d271b396ba41a6596d0c3269a5e356f8ee65a56d098271121554cc58dd0ebfc252bc4e05fb693fd0fe50e68c5ee8f22f7ce42e6eda1364c1b7ba3098b5ef9049dfeae057b9b01269b0014a89b83e4a443273a0815d63b6b5801f0bb0ec61ce58e7580a67632b797840e06489c1c6367916cef2a465ee3414c7bcce7621e9801c80a4265e88fbc88435b73aae713d5dea6b5e6e8c184a32b29c031b6b6846b3eb5ee03b20a32668b5b08536dd6363b1d151a3c07bdb4acb75777d71e470dc1bb5b0ceb802d7d1ae2fae84f62198a507c306e8cd1ad36ae1f8fb659918c66bc553158f5dd786a74328be36fe5cd74b1eef7017b54a4321a199f715199ff16056f44295eff3efc35da66a389c1c279d3fe6dc9f89f1b1247dcf642c7f662a1f50f3b0bf81b8c24bffa4c9eec744b875a3a51097715f3e0fbecd5920739252c232fa79900b0f2efd5f6330f49776188bb8353f7edd120b77df5c7d4594aae288975b980fb4ff98372d7922b861a43aaffc420df82af3cc9a35d11eafe7d625ed6759e4105bc1f61ce5ef8f8824164814538a28827b7a70e2cc7fd05ef6059e8a60064f2ea47ad224f51e8c68a6e2200a1f622fd93c97bf9b776c59887157478899b5da07cac55305eb192692cc1a63eff5a3f5378da98309c4e8f9b5b11f3e3291383fdef452fdf7f1cef3a4ad4ee0e54c5b76216d9e9b0a69b5be28735cb226264341885b4d26b420e8358a72c5ceb313a0d7b7e2d80536daf0560f1892d7cfce1a9c1822173ea017f013a284f31ce7a87cb19670ee65c5490f50b01259351a6b03e7135840eb21f98a650629f7f11a59c62d06400827a59c62bfe327d79656f62d02060fd913e9c4e7431b2678dab4767f211ceba5373f5bedbafc5fcd1aeb75993e4054a4489089a15309d6f5233acbe5ed4aac4bfb32ad3878a37385d458933e1165cd1372cfd87a57c00124a542fced53a0d5770abcfa59ad52079279e2b07b277b9eb78d8244ab9aed0636e4ff41c34d68d99472127650512e97c6c13b5a773dfd92491e4bc0cf72428b683058374a143ec142f8710cadb6a7f33cf006f87fa6ce89bbe54f7","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
