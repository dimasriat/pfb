<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c30ba582f3d03e33af311d0335b27b88591df8026f168e05557579ed25f42c40c8632136434e309867f4aea5011c59ee37be431f554ba2c8a61efa6e7cf7d69258d14e3cbce7286c7e11c8a96bd77a2585c86149cf96b896f4b1fa38f6778e4504a60282e30b25a11e7c3cdf9e871f791e2064afbebfbe698c7e931d28bb08eaaf4465e004d14c984e939914b287e98a77b1ee1ceccf13c0d7b2c26fe9c54e8b7d1517c4ace8c84b802ce46cc2c3b6bb32a2f3fbd3656c0a654a4594a91905787ecf8b4b0b3f66dbc648c22a09443a041bc5ac66949e25f75bf736bf3d3b8f8d5b8adfddcc6d41dc58502beccf7d76dadf2eaeafee99d6fbd2141d51b257205bd3a56ff3b3b21cfe63202866f8b50c1a76e15b74787e0b34d1479488d8cb4af08a1c66a82a6a82d6c3ad77a9c14b3c833101eb33f579976d430f4b81fe9008eac102bc5833a125a779d4c24369dd734bedbc688d144a127fc7d134dd48f7c34cb9f1dad5e3640992957ba85e732cc43a54595486074ef59108f51575c5cab6a17f819ffa519963bab3f87a8622920f5cf09e9596567f3e0e73dda6f7cc395ce7de798e3e1012110fde16e975df40f3dafb8f06c35c72d14506d1651ba657f8a513bfac993b8db2f84e0d84a5c2d79560073cfb7ff5aea48151bc1a22eb3e0423e9267c5e3982fecb9b0fb78473a212cc810adf5b29efd19306261faadcdeeaf70088881046ea80699526d0d08667232e081a97f4e76022bb4f591f82386d0292ae772a0e4b9bc673352f2325890e089ec2eb37732913abceedf02f1a2692b55b8facec38a647b6a9bc9a8316a79a2b478e6feeb48b54b703627a94074a8b452f4ce726a5d59dd177e97e26bca6459d4d69f914a092d309217a7aa9eae39f1c760e1ae7f41e19586ea69b4cec295525728ad4edd4764ddf5d7106654cd1e4c30f37cb1c6716cb1ccad315e86c848fe8943f2a6b701a4dd690f1fffe0247016bc703b9dd4839a0d8e2e15f07520fbafa7b372d8c5e4284802e21a5ce683824b72cb7b6ff07bfec0e6fa99b72e1aca8edde1c7c5667488cb74d72887153c28670b0b218ca8847c60a9d5b5d82dee3b4072a94eac0880d66baf15ffbb9f33689dae0e876fec8e8baf4aa6a3125e5e2bf83c1f4cc0f2a4adf17e5e043e73b552a25dc185b78e34ff20174eea4d06c9b9cbe1e0a2efa15232eaf353f96191de2ea41b572dec372687922d37391f4c64b7a4b2550b129f28e998f0a9c7abfcfff03c5cbdf2042e06b3e8a18366d6ffb32c17ba8ed9385703328294410dee7ec6bba7614d50851701d778e6c55cf05dde391549e2a18b6d31669fb59fb1151ad226a00b940d843e32ffc18cff664932191312e3aa863ad4a06e44d46f9e70d682a291c7f7ffda940edcc84fbbccff53169b60e4121e927385d55c3cb0a1b229ef015fb202a40ab3d9bce3dee84508a9b35511083453c04c7cd8261423e42059f5510302dfcace4b9b00d640d0687dbaa79072d3840d40c2b4c8d284d0dbdff08e816609ad314facf80f0bb79fde286b5e9dc51ec163b2ef96f000a47cf785474d5243390fba0862e7692539bc50f78f91b81ed57e10d46ed4924d1c4f55c302cc26c19426a927a1bae7f734ec8beedd26874e21dda148910786f092e518c58511db21fa2b03c4559b2ac22871aa78a51511d9a99881385cf6cdc4086b19315a1273a612895d75c07b7eeaba323350f1f2a8c4013f032e63e165bb569f558caf3618bad93158e92316f74ce8b7274106f551f17e0263ad1c23e679ee1c7ac1c717499879cf17bc9f511f8a2ea2e9e564ad9bd361271d59e08ce07afd391ae77359d2b4dfa998293639ef4f827624a62c3203368bfbfb16d2b006c0cf16ed18ec0924b27c3970b4b293b47e47f262df61b054aa3e8ef1edca8240352ec947aca210a4c178f05db46e2b708f7e1047114e3d0d90ec3baf3c8df9659243a3c9bd305ae14628a2946d83f677fae0b4f2e2d3d433281de65208e09ebc43d425727f5be59acabdf0e952264f057ff35a654d38742468ff5ea491862212ff95a5006ddf077c9999a77f9495006ec1e9e31b0c72a22179a86151934885cb6d2c15df2450d128eda7e77dbaaaefd76cbb926fa5023fa720cd2cf639a177b3cf81387aa16d3fd5f1c75c4d992bfb7d5aa2ef96b850723e7a1d456eb8e53ee7eefdbfc8ca27883cfb4525c96bf80fb9ef8e7be286d3cb57827abb4a775f89ed2f30bca0d4849320050d8ce3514e21c29585d8c8599691a125be8134e28a4d3a94d2abe9961da54193da1126688fcc0dba85265c0a509c359271de02e640e7f418b8ac80a38ae27acf7b13f2f5cdb906883a706958da4524831551370ab0f83c82e776393fd6685668f4d70c040ded3d6b9deaa889e0375b141c145346bce1b3b3ba073dea9284fa1239735aab23ebc22c10aa329c7ad733e09a074e74d9eabdfae8308dfa7b85ccbc1af3d0c521442817766481c0d06dcc143b477ec2adeedbf8e1d123aeabb5a947da2fb5f3a1745002d9b97816e33dbc7eca0164cf39e7645a080ef315e2c3277df62cc04e87c5c6eb27d93e397692e1c249fb1fc89e5c5e28160d359a3a5fd60f876a2ac42e343bc307bb79492bcd4e658d3bdb0013a27ea2ae8d2ad5bf2c1c9fb9e76ca02a4b32c24af7ba8071f638426a774040b6d97e2374b69cb57502d9118b6924d26f85b5059efa7095f31a67aa2646d803ba9f3a78fde73cbb5d9af77e8a9bde2d6fd0d23da006f8eabed425dfd46b7155d31a020b1df9236de1b12e9e6610bcfcdab1c3f652d5515556a5b37fd82c607f8b323d4db5dec244aa630fa065668b0adfd9c97ea3969e2f2a54dbf77b6ed59815e4a0bf9f7dee6d2afac253ec6057d6304d86e91b3061c19cc71057d0c69d3abaa88d3dcdc49b2d2d54732c2ccfec43d27346751daf82c8cd4ecf78fa4aa2ea5dd9c922f487e38dadd191cc474e6e7d9ca0d5053f9bb78bd097cdc336fb01d3e94715fbdcd3fb2675b42c86f7f2ef3c8dbbeb3c3970f5e9e68df33aa91100ec4272ac4cd9a57c9ae322ea5baaaf5e09d5c474ba4c31377eaafa5538a3d1916741afba02e1d994d36927fdc59bac76a145c929e2bf93f0c3f6096cb33ec18372367c5a340af8e624cc787d16cbba031943d170ca6eddfcdbcd1765066c35d51cd9b95aac64286d3217fecb6152a91c1352bfd81ff53f482d4146cdb84caf06c497ccfa725eb4b3f7d23690ee3ca75ef0537a365242dfa00aafc0617acb12e7265b28718ee861388696d6ae802431e4418a1433d990c0c9180adef86e2e33cbf340a5ca730f32f26d2f75fff591aada528abaa979aae3948c37a9f603a310a30c2ce97effc2d6ae8ef6a74a3ed972cd8a0c3c37a55c64cad09595aa23f047aa2f1a9f5dafc84daa3adff3ad5e594cc072356e0eccaa4ce544bbd08a24944297c5eb93983adcf93c07b77258274e710d495bf9be9f2b4bd978edd10416a2a2492cb7b2a53dde35e6b83916add3b4f6fa578e080c39d577560c72991de9c8b4e93a2cc711229c282ec5ac58285229838a2bbff6bd0b98efd39203fd487d4e1723db210ac888abe515f9075118bff721c2e494e7bc80eacba4f9a30e15bfe610dad7d69501e4a38d85543840423a7146e809e76e76cff95add681194b6ec60b0054f71e3163156c02cc0ace8d610f9562b2d61a88c0b87886cc478c85f75197d59a33310b5511d94fc916a3127bdac8353940669bc34643f8c0cebca4684812551553afe6c52ba2e7f96d41734c895ce24799ecdd5d1a2ffbf16e6ba9380ebe2328491214ff37169520809fcb01722b2ededd86030ef3c1bb439ea1b89cb98021ef754d4a0eb4ac53c680b9972d4e0ce005b37e5de1325f61b38f09b6e50b257c1de2665708b35bb6ab0981937f69b9bab0af5e925df0f192bbc00ad4d3377de3215e45d4559cbb2edcd768a339c558f505af2950e1b0a34f23b0f95f260339d18f4feda02c5329f429359c27d4d68a1227752f992506325935d3c2d7179d1b36e1d5657d4448b7b892759bb221a975854a75aa8c4ceb1a39a5fa79cf3bebaa4e53260421e5b54a6d516a9f28c46bd95bb0b83a666dd279df9010cab5082fa78c191b3c133f4d346fbc1de32618597f3d2c4924e52d3d7316bcbfc93bd8bcab26de27b3ca24124c39b15d98173160130f627c4c7a0e76c2819a36c2b348650a6e763f5f69df8b810e2ce001a876ddd6f5bb8e6b8782c2100dbd06381944b7cf80ce79340abe973e5131466c0141cc0707717f05f781522a757572cf2da725c0b433aeaa882825b8274fcbeb4e8a102fcdd1cd0e9eb4a5d78697d3fece7dc536916b0cb383b1dbb5fa1fccc534c75f57f66230f6de0be81fc0bc0e7ac6edd6ed90cc0c55e0ae2e8e81c25bbc9eaeb0b0c18f59e0670f442a7ebc3e96cc3745696ddc0cbcde69fab3ee3bc1138ac5a33ad367d8885e65b983c3bf66ea60492fdce1d0e6405f70377209c01a53bd2e3f477d3e61dc71fdfa8cdcfc5ffad6a14849ff02c976a0b0b2a2e987a851608fc635db84a8fa71c67da915828a998ef5f46d65e40329a7dec141b8555e4116c9aecd434d1aa825f6ce115222db1f0feaf9c902107ca290064767d2873ce200d37984410219e8c9d2d391d9e6c2d0d2e7d1eee06132663d5215d33899cbc9d6f6b46a856a2607d044183fff2678ff24e9b67c81f34e7c70e2a69bfae890b6d38d628fbbf1f24cc20a548edcb502f8dd65675e8aaca6f15e15df32f0a4f349e369641dda36ccfb87d3cc53c98600c3ed3dfd5ac133bba895c94cbaaa75da48245671e75d669240faf5de9c1e610202c64f7b6841c0e834f8e42893493e902b2f6bf593f0b1370c4f495fc4105698d5c7e1fc170a5cdd32975f7580f7e123006b2bdde458c227126222e9ea91fcb59d22d2af063c229f71c80210aba8b026abd8690d60b050991a628e5a83f5d7acf21fd1351915eddb6a99e6b06f115974021647c5fc0715b364e80db16b5afba3ff3f2d648a721a09626e93993a7afa24292e56fe756f73d6e621925b64ddaa270067856f5979c52a3b979089c8e85d4569098cc342fe8218cad8092549cf5cc28b11df59d214d8ec3ef2eda166afb7cb45a43360c357469214baaeada941b122a033ca5dbe9d20c94427b4de88be02d8876b95151635d010bfad94d19ad379be00acddc83d1a09da96ce6daf7c71b18de9240aaf215793593516684c3d66809c5da9e2639d480ac575095bf8fdd29efc6b09927f837af7dbda479fb003eddbd6bcf0d88edb32355da904509c20c59911dea660a7f293db384ff90eabd7429654d3f894e4b44fdd3bbad37a33bd69555d5c234d15b35a6ddfe90eb1009a3e76abbbe78a766616a1de99b6c1a27bf9b55059f5ebfd06737857e5265953ef62680ba811ee1796480c060094d6e52cca6a4b772af3c6b17863f542c23530b5d2bcef7b48e1ba4a10b64facb22532a4d071c51a01641af59716389778355de173c7664e0f8bdcf1f195f29addde26f4339513561e76a929f34d3de549bef596c9fce65486c5d47838259061734bcdd1f6f25781f6ef6303991e9f1ece79cddfa4caf68944af5592c0e1f53e7a468627667f72675ce07cc3c0af71bbf4867aa80ae8278e89ef5081aa39f4625686081f34a9a3f10416d72f8f2dcf9ec1a0e64abe475288390306623ce79003b25022e81a8a3a779a7ba366d06dd386873563c9382c0386c19dd42aba9aabddf95262ba8a003990ca8e8cbfc8b8ee415d2f50ece2888e498441e58bec5c9b843e1dd6c80ecda8ac2fa5e01615717517c95b4c270f5baadb22efce686831142fb305ef9da3bbc1c264ad199874180ad20ac141a14a3a59a252878ee577cf97809cfc1d0d43d9f046eb431b3418edfa57ab5e5da61901787543716e3b03375fcf1968a1fe10e61d417d6c91834d92b7e729e268a64d9aee41c5ead8df39ca1c07a84b935dbf833f7bf0cfe46920b21694eca2d0976021e9a6f635bfd03a3a8f0605dd992833c4de52fc307ad0a347ffc07e970d8802cf0eb41ce63eadfd3417d3c7f60e760223710ffd0fc9c3760fa53100a3b6d8eb3bc078686202be7515f880d69c8edbb439429799fe6a529d3ef1ff8e1e3db5ab835220e11f0cce5560856e00f5242ff4b090121f51ec5f0294b915c099a757e62763be4b47c86ee4ee290e9b40c22ffc1affd8baaf6ab961a9839d90b85988434796aa2df0e0a949fa7edf7bd9c97b919e579fbb00aead218f45c806682952a70272f3cad4c1e4ba6a5cf17b07b13491c0ac633a63e38520abce0c0d56f41ea2ba710732f17eb1f52cd8859be347e7b81bc41578bc2c53d031dc00f3e905f0476b75005005cb2879791697a5ea00fc6936737684baf2aed393875fcbcaf6bdc6206504b824eccdf300e343717e21f172d9787e3da422c5c1463b87494f101b788aa3f262877ac588932bddf82c145cb81e788bfb6591a1f61411763e15781f83507f2aa03f158b339d8fa7d3add1ce69380ce9b9a604ecf5b5c9774f62e8683cc799179722252501a281954beb6bd1d061f926fb5c74f442ab13251194b41a7ba9f9d4e2a6b3a3cc4b0e83cb08c842389d9af8e2eab90bf3fc99596ff2b483313cf250852bad24c3b40da71d8434bc5f18a988b49f8b3af4e9bcbda16232ae8bfe83db2bb5da606ffaf6e44da7965fd4ec8bed8c4947bf6a0ceebcbe6dfd75139c30ce66202bb0da6dee1f45dc12a9508d899e6ab5cec475a2cd1e61269d5ea1d4ae859c13b036941bfc2c6593f050c866d9f1254c0f6ad420da43db529f8bbb0532dc56890d93c7bf31960a5d00bfa466576fa01057a6cb59eeca0f47d0adb6e0edd9dc67e7b023f88c3453ca9b4b37a1399df09933192cca9a1f9328294b3e3c0e219e2463c1114b391d465b3fdf4304e3dc7451045cd2616204b84c5eb7b9f3eeb8996107fc9ca5112bae763e8fb64aaad444f686566d556fd3bcd7c34fdf6da5d7a7d8a8eddafac0ce461900176bb23971d83d2394e25ee2dc4f1e3c1d5fafbc86255e992e794f205ae513a073ef32a72d9c663745b8d1a29459edfa1bde24c104f0ff48759ee4682458dc7342aa20e4ca01a10ca59c7b2f8a00ad09689973049976f31a5c9e7479dca48349acd3cc41c2ac2f7eacaf6906f88142aa83804367a6af470559e9a9f8053879177aba0b96e5bfa447ec6907deb3d9a207254d695a9540cb76910500650402388823d4f945a42d2a412ad10d99c58938935ebd686c1277ee8682e4ad8ad17491a6a5c6afd2c8c8f31b38ba0f976b2d028a6a3514fd0fdf263c756ed91dadae926bfdccb3a0b0828c234b2f0546c371a61d3a16bf0f018715b5487d723f79a26c3ca3fd29b1f623e6ac3d6b0c161eb8d60439f08a9dd4b0b1bd0bd629c44877c770ae3d15806e51a12acf6646df08374a1f602b164c691bcec4912906e9a9d854169ee2b3911a42dc26ff585e6ff81edef799a253cb43dad81d65cae7a943f382ed729b1f7628265de72e9608e08c46b1a5545311029b6d92ee4479a03c1b3713bfcabb861e3626a3734cca8e6f0b761afe3c57bd7514bc6357f35b38253db3ba2ed930d4fd3882b352192099e1a590129f08518f204470964df59b2c6669f89764ae12a3c607fb7e52dabf4ac1c3223934402edbc500f1b01618c52b974fc332f3f819aa3f2172fa383b3fff4bca2b0ba665f97ca460a9f8103b921eac5d80aabf044fd3c376160d00674d54116d7970ae8bfcc6cf1b8093a9739ca916893a374733da2ed4c9696ac9405ac3d95eda0defbc9d465f74191e3c5ab8875aa547a3ffdd39ded5af92e622e8a4e40e4fc8ed3f9d735e28380fe98a3816f52ff9217e2b570f127eb67c1f85960930bed34c28b3832a92dc42f20ed57924ab84e2f350bb2eb8e4ef9685dc199359e6f240057d80d9c189a75e11930ac33e3016bef47b4910bfea57c5487593a44137a421e2521568366637d0c3372234f11e97dfaad5f416a46ba26b0937e43293afcfe662c4cafffe1606054d35f141f3572543da83ad69eef92b9642fdf20b0b8d47f1713619ff8049296353811d6ed50eabfea0b71e8bf11338fb6ef97c57a53fc259c9d0f754a9c37b6971e880b818206f22abe886e016358842596df57dd2510b9d1fd13d9a864910e046caf0c2098f3c3e81f8f13ee78bef745f7e72fcff29e43bee2b382d607851d6955fffa56f3d88e6dc05a69f96a58dfa0aa5d258d217acd8c839b56d718e036cd34a75d2e77f86f7f7e7cecdcb03a2987a60171bfcc3c2ca39359d2b4f5e9d1b1f9b4721508800c5cecfa3ee3a298ec87e9a59b86379399644850fbdd1316583ca089e8d43b6b3b04d9ae9370ab0db882c1fe01c01bd3c62c09cf0a1a983d2139198615570d68806e9fbddeeed875e741cae2601d5c2a1341a16b5a88a92be630f534cad835565b33ac75295b9558b557579882f30c7e637af41128ab8baee6496789bf45516b65f1e8cbf57ef96f1fe3c5867d96888f5cddce3f7e3e40c885619f635e1618c95269f8a82ba4fb79f59a9c6a24b2bec0085f8946008c657b6e80eab49716748db720068b44667d1284bc1da353317306f03a5d9927ff03bc269929c0ab0a10e4aaf7f1e7d8025650e0737244cae4d38ba4d6316a74fd59945631973b61b4070dcca758c94b680cf0cec6f2efadeecc4226003a2b6888eda3b20adfb5b212987cd82ed445f44c71c9876c9d112fda3e9ae17cfc094bca96d868de35b5b84f013b88493d9ceff16c994323ff5dd219264c5dcf2877b9a32ab176537e4da3cf3669d6d17f57d74af2415a95cca99bbdb5d2457cf181fa8148ba7d0504817fcb23ccacd73a8cbdf6ed531ea1ee1cf0a992432d732832418d214a86f4eff5050b27f8972b76d0fd212cab217bf1be495486c8ac52e222e353cdd0147293bec99d160cbfd80119f72fa9639d0b59e82cdc3a4fbaffa81a626d9cb6b9db2793f72f40a4a050c377052d25ba48a8b438697a4b40e5e67deea933c233e2d2c74baa10469fe946b119bd96b113dd9ef3f006eff0ef858dbc426e0417dcc856171cf07757c76dfc086eaada6f574367ebc78debee5ed8994667ca8df90b9f7a8259b4518a05c263a2d423fdbbd6401fc306fd9f815b702d2a665fb74efdb0f91333677469be1ed8a0df2cb14f0fae2aa636ba8f42b9a05e39d609e3a06a64694e9f6801b2e7a38a6c8b24a26e20ae0dc97dd71d8e0f0a40096d53b8a4c9ffc813a68945078d8bcad604d99d0fceb5edff6cd4e731b288143f29995cfbbdcaf031febbab98687b26f58ae1fd8fc211457c45c8b9c144ab83c448fcc1cd39123d0e2edbd76f1101bf52314f1543f6094da721bb692b603841941e1773305c2bd8630ad165d92b1eb5a22ea6888183efebdc253e249a0ef5d210bbc1796f93da74a0eacc8abcda686ee40f607434caf40fac4a0201f0a208a8e425d72d6eedecdf8908041d187ae2035d20fc9930248b28eaa5bbad936a1bd957355ea8133e874ccdc12c684ea78981aa29ccf04a075713be39cee68c35763cc9996e508fbb72f81f3df06a6a06f42a475345602883979452ebc2d46f6582793517e9ca8063e5c7a23a44ab6720ba6b673a930b36eda393d02a62d37062245c0613a3445b3ff825cfca1f93d4670b694b125610edaf8688d41b152e5af919025f0b8a248cd3eb76c1355d2091f801f52a156615046a87259404446615b7d3e9307c4c8ef4a9fb2eb0ab6c29f1470ad11409540a2f2fb9fc3e85800593e2663f90af172ec449ec543b44587ac4d674b0b39effffa12f0af7f1d36a70f44c1732eeb9d69469cc34b55b80884ac9c724738a3480798d95d94608d4aba40647041dcd9a38ca3386a61d5d0a1a13dc0a70cb0dd50b937d5436cbbbf3c1eaaa28ad90c2950a4cf06e56170f33d426522d8cc2cd39ad73cf4c9edd33384df045cef93f5417c900df95538c3ee21bdf257b76885793680ac45f68b2fcb545781fad39ef7f7740c61c51928f9e5e8a0c3593d821a4c3ca4cb03d44e059663f252c193ff23ed517c3adfddf0855972a24d9eda8811199be947f883e3f1270e3fce1f73f6a9e65f9bee88fee7c37e1b4f32bbee50dd00c3aa500b33838f8b893944ff6139ae55d08ed537cbe61e014bb7858e5f9a0b3b32a7194f7097067eb897438ba824d74610726609b44279ea73113071609c0dc805b4193123bb5641375a36052b8d70758601b6b00c608c21a9070457377ccaad0d8072f60591121311a88a2d8acabde85d645df201d1697eb36ec6559f431c8ad91d500dc7b26745daa4da865f9742072efe1b961492f1a6ad2f0d3bb1ece13b32f2fb02cef62a7df9899b280d836ffff53af217439be9f5fe18c624b6e43edfd5c5fceb922fae275dfd5bece898ff9207dcbc328df2fc21c6dc1347e55648c5c9f7ce089de6ae2f331a69e94a5bf7b14d6251e84661454e19289e4675e58f77b9c84dd96573d82ff07f3ce7fd3044aeec1f0cb4744eb363836bf78e48637bf83dc92b5b18cc78ff2bba56f1ca5aa371bbda887acd762584faf8a5ac6de6ff8639a06a59e4286688cafc8005f8d9b922029d25e1dfe5bec87ceeedf818a041cfdc35b0abdeabdae5a79d47379cdd850f890035590e48d53bfdb244861387c906c535529f66def50afb7fa671bd2ab375fe40688409875d388a5e55b5a01bbf8007c93476508bf3eab42a5db8b088c27c8d9d9d82ef1d06d8362f4081513f583e7c24fc98aff895b44d440cc654f0bc7d0cb54c5478eec9f330f386631eae2c0c3ccb6ce7deebd74ae9052b77d0935024445384f6af17246eab7a37fc7b264291d7865ea2e94e36cc84b1aca24963b414488ceb26188d6164a5166091e5761ed223c6a70b1d061e769caa06fa0bef4575925173c39ee3f8d43aab990cee7f3f9498f95e815b4756de9a5b09fe4c6ae54570a46724dae69c1422a2edd78401e3c627f6bb0ac32e08579e68691bc22fc6792a953dda035496615507ab804744fdeb3e6f6fb8d7319837b231d621762a3732397a5df68e48afaec7d00c9aaddfed361e897018d835062e381a164902d5cd49059e9a1c317c031cae8de9c6f45aca1ef44cae8cc5b118cb681dd2cc2e763e95589ae1b527df534e9eb1ff833ba7028fc00329ca3f34641d37290c22a26696467cee090a0a547ef739dd358a756161ba82eb09c6156489a4cbccc06070b6ee58a161ded402603e0582c1006e6387e0f959cddcd5cfb72ac15d3b2a934b81e41e96d444cb391cc3b3805637b5c11e256f9844f9155db983ae23ed2ae52b4b3efe3bfcab51a8039b89fa221e93a3a2646f0182a4d0ba2b7ef15dfe160cd6e77cb85ccfda00eb537a47c44ee660ce36819f3980b33752090b91791c2c33bbc2668d1d4584d2d800934e33bc7b45f2997bb45e77e7bf5fcbdb1d63a5a32b8e2a6230a6e998ff5d33b141f8a0a6f67a949411abdf2fdf53b1f894413884f6ff5890a3fd912dbe103bf420b21786545f164856c79b3a2afba701f329e1c17046ece179b75fd7d99c2a6e4943bf7218974ba5407ab88597ccbbf0532c14169f2e3fec09e33c9c2ac0a1895daf54ec06bd6af33472f883afae5d41e902ce5f568626491bd24325204fc7bb209da5704ad1ebdb57b30d5c65d3ccd471ea3f8f6f46674e28aaaf3a24c2858401cd8cfd1b88a9099740dc6968699457aa5d734f6457e7a880b90fe546543cbe1dd7a53c7e6b5a3902a8ac3badccc4605052e988540d950a61ce2e6b3ae1e55b6d252974f3bcccd2d4eb39b7485b4c40fef85827bb1df784ee0448c295d64e995bdfd949ec97a34d91aad9a2b679ac21f0c463746f48750b9717c83cbc7caa1e3598b8d0a05b288e5607fbea64754535f132201f4d1efeb607e1ac602846b403fe6ed2331f7731d946d6195e62d7a1e9b0e6e7be2afdcee4278e4aa7df5a185a243f8dd2a8609e904d504d02a0a61dc44da26dac71628c5ba1875f081cb359af210c19f48c611b4d6a414b9a58f0f6c0b1aa7bb18d496f7afd022041789d7245afb86ce6321f396a6e023c066c4e2b75c80d107a64b9d1d558c04cb5b3e69ecac4871e6db925ed5ef40c108ec0f1393d6786ce2b1f348ab04f6bec198f1d760c0ca34e02bbd88bdd241966b0d97c50dbb5a517244dc0a6d2db3fb98ca4e2d65155d79b53bd22982b5ef615e486382b7a677ec6256f23b390c5dd7a816e74cf51f2a2ba68b6da7831b156ef141a0229bd42c567477f7ec517d061a0281d9530881c8dccca0a1b63488370a98273c829c330a2491415223e82b968de1b3037ace2e5c91b2e31196d9721c7cef3c4315325d1cb4b5367961e5805a23a1ad0450a37e77e7b3dfe7a4794f22c989985ac110bb96c5c41c65c78828913aae0d521e1f83e6181c16306a1dd087e8d770a953df0fbb1301ab174942bd4d7232e493150e03c5ab065b8bb6a8904263f48c7fdb1d03abba40ed6fd1ffd04b6e1c7dafd31b0760bff93f24a94cbf60a160a5b9a2fb6ae9b8f167feacf614bbad3a947b88fc0b7c5dee04fd0a530c14c46210d8afef7b87d84b2591a57c747976615042135007d3045c4130eef864ac9d9a08988a78a2c6af99f40fca0d482021b6ce0ab78fb4ad19d087db631f3522b534f6c2fb87bec50310b5bd08e903fa1bb6e7706a44fa5dc324866edcfea025949c2d1d52e0ba1991b7d68ca663c964be3be52ed480d5eff7851865965c7f3a870e1b926db18f002f0cd693b41b9c492b2231f3cd5f12e7b4260c621012609609d7ef0e51301f063f38a7d0536ecc9499e0e488daf34c2b83ae2cc8dbd7af199d38826aa1b7b8c962dbc7bc6b8a72cbdb144f96a2c09fd8e0ccdf3a353d09b0debb889121ec4820366d3c48f17682ff66848629a33882d3f40d7c05360c0894f2608ff95b64ce114e7ca08c550036e9db0a7237478b299c3bb3483339dd7b90c00aced4e322be60ccec5458f79d913b39b9d428093964a590098339ad66b6656b71133c099103e34c452d54f60b8c196498055556446836123a60538110425d813336df671a72c0dabb7ccceb7dc89fa63736cca01a3bf7aa64827366a81a94c1ef2619b80b7f4c0ed05a5ef7f067afecf67b73ae4453a92bbd1f9d3914d9b99376999d53c078735ebbfcdf67a87c43333f2e6dfa66dd4b75eca591e47d958d3e27512cba6696bdd6a5db84d1d798925e0ed56b25de0063202c9d4fe37367835d9326fee0122fbb73fcb3c0ac9e735f6c3645d73d0c5424cca5fcc7246557a2862716ba60c27107cd4f731023342a31a2b166308bd27e21b4714f3d7f2f47e7a65a3b51b06d8a93f3cf9cc607a6db8c1bd0d84a8a0ee8acae911f283ed9a373258ab139322f277fe186b4a1882a6bb19be958401abbd0c53ae087014c899b88db8df4227b99383fc7fb9bf818f8d6e8fc5c7c18d9916ad5b66e2507713ac3c619fdb069e52b4bae65191877e8cf0531b2aad8946d418a77764006c33a837ad6a3c112914974b279ee7a4236472c470049c671845ab15163c4bfd6cfa818b566cd3b0a2c583a45df81708643f5ec99c1b8e325d556ff8fb37e8248842d23a7eb91ba47a574346d24f21f81cc990f1877ef8ea2862e4d61f5e59cd5776aba7cdf421de91d3fa767c2fede0437199526f6a115242584c63f6d385eccf76f3b56459401946fd16a72e574f0dbd430b59ec0680bf7cebe9845cf2203e61effb445d450ffc03432ab5fcdfeafd1546aeae418b37dd2105ff2b832caa9c5c7a9080fc0a81272d0ca9be2a70fc7bba51b292c567dfe5a0bce80e4eec447678d89c5d17bd49d0d8cd8788f7ef1861e60e2d9e46f565dd40d0b02af5b1187706354833a76cf216336005b230a80210d6161ca2a8827a307d888de521d6f917fca4e0377b7f723b47fc1d26162b0b8f484692d75b8611c98fdc514c4906d0e9cfb64cc0a4113714d8b8a1d6b1d779c40208a585b01c22d373fe0a6316cc338d08c7aadf26a034a335732bc5745934ee6e2ac8d818eed246383991163fa77dfa3f5307a77e31fd8f6b0fd1af012cb09297e42ef8f91fc82c4f9436d3966f1e23b4ea2d49ce128c75fac2b5fafb3843ad25ac98c6ffc15b3d5c9b47d953090f00d497f1c078a29498e402af589bb4d5800ee68db71fb199f5b0db45bdfd693823fdc232de68a5331aeb18323149120f2cdc245ba77305802ccbaa1728c75ab20f25248597359172e269b989cd8ad76fa44e5fd7b11b356feb0db0498d1d8b8ab23b0a70c0e5a1f55846bbf4819d89d67a49748307aeffa38a1fd2288ac253ac50af0980b02c274fff2e9040c8dae3cde7d426df01527f9b33bd53094d7ee029362e6aa320bcb78a3b1b8061f24dc7808dd593ebdbb974b73c8ef20db5a4f8825ea529aa8e59b2df0382a812f5dfec9be2f004302b3c1fb3842c525b242135a19261ebb70cb6278dbf1537a42bc5ad381194670455bd851545c900ed8964e97fc62866b6ad4a62fa2b8a38dcf0247db426ca9c50906197be305985576ff81697f866208a0f998c287ef0a42014ed2152","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
