<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"29d5809160f9d3827800cacab18d2133068d8d2f286c3a2171971ede733140583a932be1961e852491b214e82831bfb3ef755efa68a3035ab44f68533a10e669f781981de691bb55090336aeb9170bad9239775132831bf8734b870338085dd08a8ac4939cf9a252646ae3cddd925d3aeeb47a069975fe9bbe25e469011ea5a6382e06b80a47581eecfac1a2abe21e94d7263a1d6e44042d008cf43405ca802ed105f13e75f74972a53ba792bc2fbc814873f118e3616fe53dcf71a63b3cf368b97e6448afdd10c22c4a8a2f02cf5da7a50153ea4a76ad94dd514c853ce7f50ab343797b8c5879e8ec50dce83f76e6cfb11fe7e0bcda91f222ec6795985583e7512ffc1540de87c5b2139fe550a7bd4138184928ae058864631e300fae7bf13011bec8e31e40043c8fb4f34fee5d6e2ebf252737f91f59bad9468ab2b8699c58de5dcc292dee91c8204b1ccd50e11b6f9136dfe4e5a33443bf2465343fbd905d4f9af19f5a062f27773817e010762af7a82225d1fd3a79d7a6bf70d47e9fd60a649fc48ee93de70136b50f7d4cb0a210b9fb7e18f311084da37ea01119cffbd64256b4a574e6acbc28171d8ab361989ede19886cb06818f38a6538d9e24aab0c58f300a5c4129a8cb9dc41f9526c3ca504c76edc0baef09f180cd060725dae41b057afcccd86873883d863fc9a0ad4643637a4398916404f475d1ea12c2509187f0358242644e409bd670b36c22b4cf25f7d892d98ee9d110877b8c7676702dc3179b0c6e69182029c335e012f197124f605f6cb723ab652e3814e2f86cad7ee067d88cd2781e6a0ca58a0b13bf3a2c3bae1518646f9c428b93b30b3ff9d7eb838f9c6dd7bd42a5ca7d62d36e4b76d30e473697f80aaca2e4d906b9bcc0065b649b14865d01e4ebe97a09311d5415a190d3fcf4d7e7049453d92366eb302114469e6bbffc6b7dc35aab180fabd1d9fc3d0abc248a36b61e9218c302131acba0f99d7831c52b14f1d7167d25fbdd8866d5198d636ef39c0bfa26a849c61fb93bb18f3dcb64bb037efa941809187404d1d847f3f473474b221d67b1d2635e09e2e357f79414ba1fa2052a4fae52ff10020140bdc32d2f5788bbefa74d3e04fc76243cd9e6e1eaad6377d321ee354f92d2ad441147763f71b1065b744b75be69a31efa037567764861ddb88b5331c8c6de5d4f6b55230446bd50880d1a8e9393fae73d34c5a372338342a50de879d4ed3e18bfb6a7d4370ffa00f2ddf1dfad227b4f39762750c27d9f7d7ee53fb257bbae586c7f320d02ea0c06e7b42583ffffd49c23f36c641fd0a4cb7725987b2d56ea2c6806a572b704a003474e0e25e69d0550acc055d866b0d09b4fc6649d457d5a9499417199d37dfec78650830b324bb6bff21c4c098f0c91c0acad2298227927cda99b6e73de8274d2795fdfceb7bbcd9e920cc5e9e8572b55f6e0d7230f7a6d8b4f1cfb03e0c83a04741c58490efb5b6be2b260716ce9c9c368f471123e3d6296ed34ab0c4c0cc452915ff6701056e36b75b3fcc3ae5f5ee0cc2f356b023184958edc809d47e037db8a9d002e2458c0ecad60c75c4be8d34b701f16072b7769b20d15246f9ee0106c0303694a77ae6d840cafd9535f63c081181535093b7f0413635f0ca616f2d79c085eafa839aac3d2da6ff26bc13d82056977973f7a6690a1dd9dd2201c21d20c4ec8c4ac4e2066ed91cf104c069d247239065ba638736199ab05d2bf485f51db8d5287e5f7074d47c3dd6a0a669d1fd1bf9422888bf981669a389dc4ecd0b9d5399da4959a1774055285382308e2a767769fc2af523748975f40e8a1d541bb2fd90850d82d73e8e4e66e14ba71cc000a07a9a384cec877c06300dbc3afe19d8dde68aaeb8744a12ddd44edd29d96271fdc89ca80623580ac21ebfc852fad3b38a14436675b6193acbfcfe25d8f2378f811470e1c401738a312e25216c53ac5f8f98c9588374a328770e02b151c607136061ca45fc27e8579215afc7e0417df2df4241d694b86592752a2d9eb691899fcf3e9e7d6718730f1dac48513be5dbfb9156906a6e0a5dbaaaa13394dca172948c044248af1a6b9f218792c97be94fb30ce86cdafd7dc1c5c2811e1f6ff3e0e230675dedb51d664445ee969a132081b032882a08aad3824576651571cde086242c31c27be1147bae692dc57d298d2a05306305dc91db2a2acc3fdc27dac990fffc49e2504e25ea7c6ca6451460d6c558d3b9bc5fca04786669c669926505d81485b25449efac304bb8a79ab894f38054c5587da2b5a74d085a63c49a97a87724a57057ba7b38b2fb7689b13be2949c26cc901933db4c58edf7449b28f4ddf614dc88eb5565df3cb24b3b0c97ab48ed2a8b952f7db21f49bb47dfd51d1b27b35d063016bf3eb171bf2720000f47d4a23fd7049058bb0f085f2fdbfeed24033528a1c3537496691c8ba5f375d68a11bcb4e9e0e5fda34a32ed9f1d5a31f18fd06adc99da10d3f802bc854e7f13397da179ad649a5e342ca7f33166212900a40f19c07c8cd4bdc418483db31ea408b2b5cb7ef2c2bfb77c5b4ca08dab98be8764a16a175c5df292b9af967a533252c8bf055270a4442f46afa87ea677e616c12d5770ab56a95958c726dc3d65efb8e4301d481ab1c079eb125993b00d5f487923ec4f8156f22ba1810c20adddad6b59a4f22c7bd5aae597860c1a24b4a2413452edcb4e05176853ad26f38a28c3044da360deebb624d9bc416f947949a3020e3b732949dd3a381244c5526adf4df42beae0b1aa7cf85b140ed93c0f9e98dcc146d677835e30e9b67500b723d1ac0c491f4a893f66675f3948d1e3d7242968b08001cf59f7623e36a4dfd59f505aec566d6c651df1970f782ad8ffc48b0a9cf9106d425044b3d8bdb58faaaea66fd3e93ba692f6b0bc04c1aed2e5ca5b98796917122929fbf09168ae233c2dd9b4ddb49ed3e93670aff1075d0bdd9dc14c7c8e36458511ffb4a8c76e0c035f95b86c8441c7e28b3419dd0963dc6f7a28bef9b7c11ee837b248f9ad9f56e1a2d0b90666c028dff25e65c54401c51f23c9a418323e3d88e6784ef9dc5dfb65982d33839b4c765ebfd4ceb8017232c37d5b2db8daa0684d76fc5c0174c3282efb85056b308df8f20886bb8df7ecf6216e12c70bd16753287d8f8e1c5d9da71d98ba5618a411ebc7462d176e40963e6ac236334bb6c7adaf745a64e719450597ffecde95d5d4e6198b59a37262880d72a5e4e4127f12deb70294c6c30bc2082cacdb76b1c387f8e8d1e07c432622052c1c86bf23fcf3dec4c10b13352f664a5a9d7ac85f374287e61b530000dfd85b9d38de7251b4f101764850438222135a9fb82f1de17e0bf2528588cbe142fa152f62f878b66688d1d663c101f97edb6ff06d7b30a583c61bd01732a121311cfe040a93203f8bdb42b2ef6685e2dc6756f325f4c548442899b349f29600abfe467e51f6307e6197f028177a994412f9509e305bd3e4d560b132dbd59639f7854073323b0ed678e68891ecbba7089237dd4da6d1e59e0ff2127955ce7d66f08cf3456ad543f5a7816a71be105bf455ea1582d83031010770803574e7c317c10a8bed0f34369fe2050bebde19e584513fb1925f455005ac025f8ab82acdcf557996236953ee4fbddbf0e1da0b8e6bf359ed6a9fd6be1c5ff5db522eed173f2055d1fed77ceac5e9db46a988d6a8a0fff2dec132f7e1877ea1de208a44ee8128dab61afd8e3a7da962629ca20baba91aed3dd207c7f9142d2fb6245126a08a711c6533684d462d0878d91d14a3445c0653e92c59a0fd5b24560fb027687a4e7ac4249ad1214cabb877f4dd9a4f471a47e11ad266d2674abb7a3eb977446eaff9cba408a5c91558e986887772be1ed64c06b8a486989a084846896d76813142b95a1af3c2b261ce7cf5bd48ef0519fc92007c58eb916063dbf747a06cebf74bd9582f8f37668f3ee098f6325eac9cc1e39905576c0340f3c7c1b69a515468bbea8d1ad62526af1fdfeabbc03eb15f71f8e80a79b772a668ee6ce7f0121c13846c866298f4cbda401be1cc935a1b308a8b250de31690c0b6d8e40546dda5701d0f72f3d9f73fe3bb762ab8c0ad8e431e17b5f40dc754ffae260322fb23c2abc04cd4800be9f675e8f36154578195ed1859b45d505be7d265f354df1d772d71767da2f6fcd5e3d5dc11869ef3e0d16673182670f33bc2808c9ebff0c137ac635294718af8f4be83aa1e5c55405af9fd6a68c6b401f9370a5203937362117e54a1bc81c7f21dece8d98d121120ef28a7e6ccf628336bae5533484f9818699d6f5fb91d2d5e5ec2b57a6868f2cf1748593231691a3765686841560a4be5f3a2cb41c20c46c98ddc3ec174b343f6d32d4142ff89e0e28e5449b22f2c7889b3f61112109cc24b46e66b2800beeb45629b1c7597d76a341f7b37c84c5ccc81ceee4d04d86cfd33f8e4197019f795da69ea516df964ad83787cc22350f58a926f6ab14a7b2a77cec3506d0ccc41067ad22003bb002233b4c509b526b8393f23a5450d5270db38b5071d452679464f993f0eb2af37267b193db537824acc9d9ea08d76b93335186a300dcb665fe37d22633e6b95cecb064b42e70128c31c5dae84e46736e10a2e9965dd86f76e556b85361fd3dbfd27f73e23e5e8277df5794a73b78c9d163055a5baad765ebf624f1e8ff403d59c51184850a5a8c52dd91cc8e0df00d56d399843656afb8ac83413a4ba249bfa8a57b2a9c10fadad45ef8289b3782e7d6d91bb6ea7bda469a9b8dd6511923f245085d791a34d584a0eb711b51ea950cad12ffed86a4b19bacd1d82e6034eccae525184f43487c060606d42695b7740d0195a1147410f815486731dc0616451b642716828f7a3d2b0d89ab0e0741b2f4d1dfb3a78ae1a282e4ce35e05a5cf4fb890059e16811ff985c76a2cb6f2959ba50b8741fb70634aa19b6644eb81ce605fff10b5afd5a63ee790ee552efc0066cab9e253d22aa587cefe44774bbbee4d759c2782af1737d3250de17d87ce33e8e287b6ab746d04b653ac8092afdad2c381dbb28fcd57a500f74fc8a85034b7bf4e50d94b0a02ab0863dd646122804ebe95f4fc99a091b030ca2601ff4d1d81b50e3871d2ba9e87144ac51908ae86a181d567001518d95c79051167d313f5afb12e39b6d12a7057122a210bcc085595cd2d2035578f3d89f5bc63e771fc20d5e97f28b92c6facd9e524522a0ca1a5e08f5a9ce0c8fa725ac9a5e1d423b68b574e39feaf6ba49b05ef42f2e029809541869b9e0afe279403d2811ac3b1a5e356f97e89144ebb16be8aa29f0a8e7e73f0ab4689fc0623c93849c5b47b08a84ba56a4c2a790ab32ad5d863af732f8e581b6f379a73aafb17c5d4ec64b75b4dbbb09e747da561112a0cccfa22a022ae7e6501b25b000aef640afed0aa997df1b5f379aab56299363e9e76069714f1152dccacc3fb31aaddc984cbe1b3de1a1eeb3e05a97be52d3e81aca9eeaeb874a4874fa260c7326a3de43d8c14e53cdad0579c14b69cc1f812660299183219125230f5b728cb83aa7af80c36d19f2555d7e1a1a299ef03d18aa4a4c36695c894f84d54fc15f303310b6f43c574704896915201234a7fe305e711d2e973f259abad291956561a69c1ce6fa5eb8ae55b449a145001d40ad0e1ee7cb130c2ac7d4a8e0ac3cbbee99ea44e01536fc6cdaec21dab3d8a452b6bfda24e8decc495a45e5d9018f276db941439d6c4539a69e69f882d082c80166aee35a2cffa03a10fc75f7e6a29c508364914e19b0dcfdeea039b482f6cf873b74f689fccf7956206710027bfbcc2bcca46b982f009e1f05afd93199a9bc5ab2f6ef7425188b8aae1122734ee9aee64240af1bcc740e5ce5f111cc38250f2becdc26c6a9f61774b2d84fcd5ed29710022d26b493766b827df0243e93c4504caf685b70625b0ad1058bf55ae757c7008322181e1f57555f762a03c1312e2b1f2440aac49ca9a5a15ac9e925b9463a679676f2d144f308e26d26dcaf65cd9fa9c4de1f9f88ea8e797809d339809672b1b42eaffa281156463761c679cdd73796a11f4bdcae8f12d5a7c129c5c1e2bb168237dab19066676cee0497e9432536de8cefb1816035f510e9a1822c12d1260a96cb3a703ce6db3997779d9dd63f0e54a164feb9adb1395c534ac804320de51a08719af0e554338cf996963e9f2b1d6618a6771457f0f151edd90ca58484d90d50f4a6040bf0c7df39c0b735a7cbca9c2365b22888a133ef9faa07ef9e82950d19bc1057cea2de6f7df4d5b43d1999f7a69994ba0feeb8ba572a4286f1d27f16ad0490af4f280b1548aa7f2abf0a6062435ada341ffba6d14bdecbf88d1cc4e7130ba86757c742bedb9743430532565f1bfa834cac5fec0929903e2926a41ab5fda08386c1919c343fbd373e63ab7da1c0bc3c8178b41af630115f58d49cb6e647800689db11089dfd6867538934bd2786b3726bda35559f20df27f9782d67d594e268784082e9c668b8d9f39376352d054405b4f83cea00e91263499502d4276b8694fa3ea6803ed5ed13505a80e1851a67287d737802a4aa336a2bb60f60e59f7adb7588573b8a43a6b5cac3a4f8952c498cbd5249547bc870a28409712409ee8b7dd06d0ff52a88342c7f2d904a9d19b90786e379d328a9d1727b566bcd86065fee08fe7fec06fbc18b9643516df9cac96e4eaf3fea15edfa839a35d18300cf960a165944f93ec5e4825763af6ff08fd509afb9811ede5b50b65f97dabf312b4260c6f51d05b0eba77b216e8c41d37b0bd17474682306ed92578f2ba6c7c68c145aa6868566b02a227a25a38d2b67e35ec48fa340f23766ae30f5711858450d7a37ecda09f36436394efbd22e7f69ec50a920a69159cd1d1e3e671200b3bf968bb5e14ab24d47354905cbef3bbf4be9db505e56b86600986c71dba7e2537b5faf3f1933e6511757bfda8d4ea4e235a5ee94c1ad8025e0ceaf09afd2d74ec66cbe524706c114af7e48009cca2c24a8b27562c70ddaa6d97c1892ab80ff288636fecbeb05cb30989f07cbd808e7942021b9cb8205d9ce3b1d386ac560809ff8b89079f12294f79bc7048fff237d5f2efaff54a7c27b2c1d327bc38e4fa74afc0e55e145a220aec3d5d168c88a446eb87700413eb414cecc7ad3976b0661e5727fd61e2ca67f96027f167da45840ca6de1d9f87a52362362738a857dd63be4d561989eff2d43184806f689cefb4e2b3d0d71e49ef7b9cf20d4b60e1e6443887f1fb6327998aaaa5f329a76b29390e6e9cb5aba1416f54db2730450edcdbe5180cfc18906637207dfa428348fd041e5da1532b7a176beab517d42a6c651f2d78201b132e0d725d929e6db7f0b547cea93cdedeb9ad709c63ab74491fa56af5ec1da8229b0bb83bf75068a8a6b6eb9b6fc9b10941bec74b9808083de6abdef28fb1edf7170ec21a4310acdc376d1ea0dee965224d83d68e02f21fc581a67aeed4388f4bf21a85efa771de1720d91663177e27b9caec9b6059ed46db274376f25f804b2abb3aff3f5babff04f151c12a05f3dd82c7c85155237a24855dae2e8d583ea7d33893c45a5a581f1327e8940e32a5d56ce53f94518f8f1800166b78588d09183593606283f12f2840dae4a5457a6fd7da02c5ef2933fada30f29aa3681b25f5e3cb61c64b610f4d80602fc9d48b5bd2be7b30185f67a3cd511a249cd42fa97f18c3cb7591687c7f14a88c36a5ed02b8c4e632c7c0db91051a5f73837a94797fefb3515b551345fd466ebdea682827480d6dd108fef6cde714ff459cbf9859e53e695f0f133e0ab03b4a96755675f4c162aff1fcdd31a979a8de04021167afe21b26a55a6cf21466a9e68746caf6c89c2b0274d2302003dd9f4962d49896f5eb89e27be1573359595849bf101b7b74efd658a82f1a578202af65182b5901110ce38c7674676c0b39aa70eeacda89cbc7defb1479fad19770ba294fb38e42e2c3e0317fad4965df750747faf68df7bc375c26bcc3ab02a8894593d14327607ac22ce0b7c5dadd11efae06f3d3d8248d54b22eaefce80bf1aee41bca4a875c4d4b42387de2d0da25a7819d64cdb36ce311d71afa921a76ebb59402027219b5469a71bc8fe3f213092ba10fe9a16fc8f1f38eec569445f5b5475ffb2ab94d1b07c7575596883ec59e5dc5cf7b9f1695c8b4f1e3957c6692d5adf0332e81e336ae40fe35d53718057f21b4574f25e97073165c05d559bbec3d8adf812358cb69124e6af29f266b59b2933af1d4aa0e25b28e04c6ab9f847e2f8e280410c90637446ae9d2644c9042ef319f3666806dbd886af7349061b81fb5651c4d7efc8e49d4ae047ce220e606acf28824e5ef85793e0bcd8b64f1efb9c2539ad1dbe512817cdc3a14d4ea61aca9ad9eec8b5d48c557443328d9b05149dc6c8a7806962df5d2fb75627df6dc65f46b0295bd4b97b110387216ac40663a84841acd7cc6104eb0a19a58fe9ed7294bf39509715d84d539550ea04477a264432cfe61ed01a42bc49a385d56588ed0fd23eeb759c05ef02c3d957ab57bb610ff632fbe824009f232e0ffa2cd64901f158cf969fd8680b33db14cd58c60c5b61a0dfa93539bcd8dc9b2703ff4e529f12704cff9be17674bfb43a1bdc39f57b6b48f057a5810fd676998cf19f6e71752324ed2df78f177ecdb44ea5c186c10f0aee57fe006a824cb59aa9b80bcc61a11ad89cd629204cecb48c75255251498fa1903dbd53db5fc50b721cdf386f94dd0ab60b12a646d01fecf593b14296f5adea68789ec75db53036afe9699df3e17b675264bc16edba7e5bb71e83cebd8cb3b0eb0b2a95c4f66b5783fc4c8104a9e58005cc764f1bd9a86b570671efbd141b508feba79fe2bbc8a98f020ee5b54f5e6de42aeced39556c4eb4316b4f86fa24c1f5debca6956c4607296cbbdaa44b1783a30aec3215257e41a6a00675a7553ab4360a4f53cdfdb23fe40c4572d53d1dee51fe05957a78e83cb93a0d977acab2df0e4b45b5ae409156bd7e51e561da59782fcbd76064033f91fa5c1bcea9b080a2c97f2fb6a641b92ba70e2bf9f3dfa8d24c3c63b28f985e0b4d7763a06622cad2ed78f94ca997f2179a18ad73e547bd278866f57d6808b9905e811f4e35e91cc1662dff1fb6a255d0abd4f6f0b9c32db20dfca5d5d4577825b8a832d63a224905cdd3efc9c950f921c675d79c67f6bb3adbce97cd90b1265959b3c03afb66aff1fe87bcd9e720952675c7c7d9911a7b502ffef5431b73dc12863b9a4317db1706fb47998a8622e299ad9c21d520bbdf4b55e8d820e5b6c87160e34cb269266061e48aa521105387449d011d91433d097dcd1348d249706ed1843197cba64b05bfa0cdf17b0d37a86ef000930cfd8f6a50ac52e0a7421af23eed617574c415cbed39a24550f30c1fc7c34bef5d89bec168be62da6291753b7357fe3cef30e55eaa0859d9d5c0206410a7fa7e56776c417b74c2132d99c8323cd3b083b20fcc87d5e48c027d8ec69a877b431672f584131a4f8213ea308ebefa7d168921dec3d46a0038ee880e15d8624877900dc60d967130c0b8baced07472e29b4a7bed2f997d75acf2a6dfe6d7918015baee406e7308e2c4d6ec13e03bb3a66517e3d949504932bcca279fcd1663e782344c565600779fb18c1ceff5b9d95e6bee3700ac62fde04d5fec10268adcb1a1f3b8389b13cc78fb62c0b7e39adc668492bb38eb66f83bc0339a117186d88306681e7b24b72d0717b43841be5119934ef442ca9a00da56b8949b0cef7e96a72046967d2c421bf21e9a687d846e90b1416ea1f69b38bb554df071cd1dac9c87c687cd443a29d5b451038f8ac9d4ac8827338c77c961c656ece6acf60083c000a8839de97ed79e1193f45a70ee5f5ccea189e7b8aaee744cf382fe0b90c1a8580946bb564c32a3eb35988cea2c522a47c9df2ee7502b6885cfa05820f0578d2a853fd0228b2ea3de5664f4a8b64faf7aa887e1005be3d5b63b545f0477fd8675e41f6e094eb778f2257c6e79c18d32627fe32467a27edc3e66483de0f8d849f29175a2e6d8c8ffae55bb920b6b6f8487452f426143dd4cb0b4332746175e20cf8c76f40484d6cb0878dc48decdd70d47fbda6d61377335481110473bc384d4e73aef35dbf6dd53e825e0ba58a2fa4605c92a42a84f38a49077428ee73b69d7791c7e48a837f9051c8a93486f430fd9c6998ff9063ef7d2c29a035820d2cbe610b261ea10c7b3d8a83674467474bd62d71f4564eeb87a893a8526094cb21f84150c9b59d35327af501e7e733bd2250b9e6c3a17b2580f91ac3360c4bdb6a867ec4bf9fa46682d4641a729d56dd847108b652dd974101f7d079b142d8ef8bad5ed4648e50df7a0ea21d8905b6ca1962807a9ab24197561b1a4918065f796d0130727222d29384be4e6bbf64d6d21f685a464709b1fdaf6d43ae9186c26cdf7a7a9fcc1666105569e5de95b8255973329cb5732141059b867150c7a8599a98eaad6a263d5d6d667f94f4f3463382b54c4238e960c8903f77b7df9e70635dcb759456aa914ee350f13b970b1910f77e82d205c3fde809ce1b3333c3f877322d0c04ab8c899ecee05dd42cccc607941fcdd15f5503d1d28b8d7a80c8f3ee317827f725363da4ff8e16fd7c79b22a0f43e2ae573d663d771b311f1cc7ffb3ac6bba2aa7daae6f7aa86b25fd1cc1876278afde86118dd1c886c3912d9d4c386d79b808893cf08fe4dad08046b0332f18dde0150c5e491233fd01edd7490bb85f1579ddb3d6a687b86e306b3c8576140d8bfac012fd6fd0c81d47443b8138631c9eebfef1c79ac5a849f01a5524bb52d55ecfffdbe5e6b0d9efc1f311897c709a9d52a84df48e0dfc54decd242f3e7afebf5b25b08f026f46db16030073122033da94045f1c355b94384d3307328948cabe6484953c17b1691ca42ee1cc4b8fb78f047f784dc419ac3057e7238eb4088db1f19b977916ba9bda1d9c5c6e2c83680128bf07de664ccf1df3d11245b15959432bd7b01538663fd33b97e61112163a9b294612bc697b2c258038e468f7271d9f73c4954abb271148de4f6970a3a8388d774a8da39672dcd67446a88e189b14df922a81197b973412402577db6480a4f6becc519b24b5a1793cd5cd27f36add4e203550b80da823d3f1d743d377c401a743a1d35016d772f51f382ac3c130e127bb0499d6f786d4d2a4ecb2959e601dbadf822784611e327967410b87cce6874a90c39349a7948b03022b33dbe7f2ac6901d4277cc46ef48cd062e7828e8efedd96fdffeacafd8edfe25b3fa5acf3ffe1868321f16c693750df40d23738c94ab6d6df05445b838d8c5c28adf4a3acda2ea5b43c205bfb67ca69ff94a6aaf64b6065b6727daf0456757c6fcbb7962de1694e6a87eb904692e52887469cb365466151376e16f84329e2d576a660be8214a8e8d4a0d832867139fa05ad43e144c96e27bcc61407a292c76303ef78f192aa199ad87d21ce01f1f1d55c7f4b2cf7cff251728d56ca35b6d66bb1826488ddbdf5e5fcacc6c61202ecaf51dcd61bed2fafc52abea33855a7f301c9f3732026a7c7529847f97a3d2153d036796a27838e7a29eaa9bdd8080bf39fbd32c78167c9788281b3c555a87640fe1ce61f023bfcd1383143641577409bc707c547900824620fd3e81608f5e772698682ac6199c024c8311d1b1a0d212a9ee6aeb3d32df67027431b3f5358ab0e5333726262faaa2a8605c5cdb552f1418f708b3a0ed1e3f889bd3e9a6c5b0b4fd6ad681a503d0de22e0bdaf4b9b67bc92f18370340fac31856bd9b91e1a0ebcb19797857d36a14547e61a98b8256c5dd15dca5077029828cf1334592a4d28334f82a3d998039606ee565a4226abd3315453fd8cafffb78f8e5f309d41ff0b411e5eec79822beff162a154169f55245c2c892b05a466b70b6b2f88c5cda787a4e6e1e27a3db9a95cf4b0fc239909c88052936fd927bbb105c7649cfd5779fdb6360a81ef7af63215775bcdb7d8966dca0b6780aad4cce91fd10c6fdccb6918849d6b7b931c83560d3f3f0c67e1d31ebf9a167079809290afc36d0475614f3fee788402463e284e4296863735712ec7ca3b8b2d87f1badbf9c5c299c8dbeeba9a4497a8f78ec6fc3bb02476959eba706c62addbaa1e66e03e1e8c7991fb8e7a26c17492a33f8eada390957a0c995a67f813a4afe24e5c47933121b8e4c152dde854d996c5cc1986d737d808625286b9a52e6b28f149a8ede9cff6a61d8eaed51fc5e508630bd9469a4b7f77ca95284cfb106854dc445a2d8db3959d0915c2af6a65f64e6764c0b68ab14cef0169d488f3df1701c35c51d6aa90684f8565f4841e09b5cac3e34227a3cd2778eb02d78e191a499ea6ae8a9c3ce6e9582e26a96771a1eeb0e6947118d9fbd0b53fd25eabadcd3ccc94c4f5b15125b5c2e1ecdf2cefb1e3ff35076b506875d524aea2f9591473dafa2cd8955e2024cf79dc71510cfcee5d83aa1690696602a97f10c501f7dfe1249f1726d20f5062fb07409997d133950433246605b7efe04ee09c46575e6075911e88da44f26481156686b1ddf5b6581c926b668808fb8f56ee5dd92e317700869694aa4f536623cf1cafddab894e70eb3c7d3fac5d1d0b38ffe210b1aba8c31f12a53509e349160d81f69050d6b0070582c7909b239ee67349d99e820bb1e0924f58a8bd7f7d7808d405d7978d3d7db6534029ced4319b4dcd2175eac126a10428d4e9f8ec5612402930dd5f75b08ae2c1d9eaea15f7ee043369f237fb35d021762ce1b635c04b0069118ec097818dbf106ee1c96d0dbf0c58b6509988dfb88ad5d528b094eb5e66830913bf8829053310d466a5817c3d168a281b1e1d6bdb030b2bdc9a00b1775b9d7f22d97199f4c17f0b0c70cd4edb82a41937cf1cc561a8ead0e740ceb45aad4271daf89c20e3f7bb1f17fd8ea01108825d6967ab9c90c2c40621699d48777fadce5a49bc5033b22891213b8c62d4f2deee35e9217e874508b8bb9058ef385974e272cd7332fa9383576c6c36b266f93f1c2679c573615eec54ad308b242d8d88e3eca43ff845438e2b4ac11a176a3a523736ba2c6f33ea46d2dab296fed3d0db4a4d81cf4a93d3e5f5dd06f537800b80edb032ada9dc6e618d7b748afe1485217982af0e1248e9a00e2ba094626be9a7a6906e34cf14f07e715c22646feda60bdd3d771ce57cacb50a9560015d69a18103b86653a35b8db1274d71efc9d4a50028554d7625b47ba45ab7327b92cb95fdb4d20b0fbf08003092325857537cd9b14e8f5feb0a51bcaabd746c036b2a699a8e7917757ed0b63aff0136c3e8e0f3ad932e76bdff19b78ffc1d5fc9e39fdfd1d96bfa64a9ebf9f1c5c3d2f926d6b0ac058f2208a74c51485167667e09e5c6959da977bd884a11e868dadcce6edb8c9b240e581d53f5fe58e49066662364d1297e2eaf5bdadc9918c6c779f1bdc84d57cdd0dfea4a90e37a305f1cc9f69ec4db5d030b2d50fcc4054589413170aa3db84e2e0748b2437d7b74496fa85b7eb73ec33c243176a37756f8e399713c2b254e9f63a2ef5e884352a9698705c44aaf059e1381bee5fd3863aff8bc31ae0927ea2de885f2b7afd344f18eaa97b8813bb3d73ec92efddc65cb734644acb431ab58b3ff20508d90a1b84d70c122d698806785c0b94192e1ad4df3b280141cf3ff2b51de30f95b92d0e2ef3aa73592437aee94b01da61aac8be11ee14ee81f2645e49dbca88b962f135553d01514655b9ced1e646945c2520b9e9727ae00c92df693af094a3e9a45ed7db5b2fc6dfd900a5a2382289b6c7c08966312bacb437a3d0349c9174b2bf7000e26523fbbdd4e152beb31c2ad64d691cecfb3c4a00474b1929edd20bdfc1774708920018c91f66ee523355fd02e8ef48864fc588eb2c1b952112cfa5eaf1494a28c33ee755e0020cf0e79a8f71f5f49f241917c81b543fa91d8bc70f773eb8c61c73ede399121cf25732fe04f7209a26c5c4a09e61c9c3566cf7f85ad1f43b5871953267fd21ad30fc1e75b5c093ab439c02d42750b6ca40d45ae43da9e2530dd4f031ecc641ff74640ba935b6acd5eb9bc967fde15f3ceea7cb66672223f996ca669d73928aab2888011b58cc96dc71ea0945254668b3618ae1e585ee3d99972ff874439742efe6e3ca512c27ed724d1240d64349f65e89183b88fd451c77ac4f87b4deabab6a5c7c9014a216271f0f04102959f744ebbc422b1bf5fef2013de45c7ed00a901a3c1349afefc973a31a09d2555bae759d569573fd6ca9355343c95b01879a8491ebf1ecb8d9344a72e61f92a29baa73592f16a835e474e3ef3a0a402d4bb9372c24ca9516d45f8a51dad5c19b8e7b2134a8fdabcab333bede6724a31a8f3c326e30b97abac5c625d311b6839c57267960bd2e54e807f5c193485b3b2b82dd3dfb7e6e3e133f24a5e6207f1e4acb24c5af2fe3b54deab2e330d397b6f92ec943edf56499b8307d75a8b8d0f7bb60f0fc8d164c4c634ef2512f29a831ce3950a263c7f8b8","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
