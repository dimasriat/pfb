<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43a675c0efbec5230f1a26b624c32949141720878bdc830fff2fdf34b8df2cdb24267cf7e835525df44ac5f61f01799fd4c95ed10f75b5aa87f458e5e7da64482c0731dbcaf4b797c9357b263011ac73b6fe622c1ffe8543cef0feaf98287f1208d5e293ef105041366f79c236b7099e0eb7f6a44814932af1994ed6f23adc8c3773488f90250b5d0e92b0c27b9b34f7de6258d64d9c01b163aa293fc2762a8dbf97668bc8a38c61a89b7cffc3b03424e2fa9f9e8f09e64d194c1bd0e96449870d25b033c090e7fb2e02200c180f1285bcda0945c2c0dfcc7432ac40a4fa6a90f0905b000850b647d7b66cb09a6cdee4cbbb35933cbcff5da624c80af14152fb78724e8b01fead354a18639c250082e7b01dc74e7e98db0416bbdf7fbeb74b59e1efc7b3a27dcd67a61c3b302f17d63b18a6222c6da0de93a27cfa7c2a8345cda0634831ad9b914ea3653b512f74aaceaeb26ae73a0279518911f5a440cd641eb54c1c2c385a06904b2791dd7e65a66d0b578c38f712b937f4f03a899e57a3d00e2f469f354df391b5356addcff8a584460c613e9fd1cff723d6fa4a3205f7c7e6ad00e23ad3ac54394586f519da8fdf70b48b5859b566a21021cee4525f818671572a8bd846c0b69742350f6b7867c202563998f55f266269e857a225f69d542eafd429eceb46d98b2b24dd6fd83421adab9b2f28b2ba2b59c7550bfd325104572a6156abb70d9884f680e3415964e9c4693cb4762c94f907d36d8059059989b414230bda86558194445b2d4d62468cc88fce8207eb15f990b72d1acdc89bae462e460bcd6e4dc7cdf99747602ab8acfddda935a6a905cd9bb9bd36f257f9fc9803dfb0484937966aa454c252053f7e6e9b21a88d0abe9e674c83501f101202859ee8b8815326fadf0124f45736898a481a9f15e27c9cfd329938d91fd6460847cd2411fb4dd62be327523b5fd6311e2224801b6b64e32041dd900d6e6bf4fbb498cf7160db3e9a887c87bdaf4b37bb2e74d43431c0a751a052bee9ea94f163febd5c1e117c8ec676e293266087d86d1028c6274ecb81e7deb3d68c817503a734dcd2c1485b15f872de860207d627e542369e7dba7aec03bc218bd173224643a1ebc687a41352fab78e8d7e4619363b80597037f7e18713007be41d9d97995bb7cdb09d89a583f0af71e2d93f764c82834d90bad583ccf11f9799a38126dacd65a59a7e64e12f1ddc7e214936cc2f195464ecc294cbff11285f34a79a344e1e9dc4500ce210cbd5ac9514a17be15a64ac5f20de67df6aee7dfc06a29aae01bd84fc2de4c79074c1e915bda43e365252e22b51be33f8569f4c2c04d4bcee22161f6b237c7a62955b2be54dcaac72d83c7d139aec2f514ed812778d861ab8e400378128a2d96c2fec1f48d560216e0cc7342e9f1390b40dc39072d4052e4c504ad5e52ae7eab9b73a98eaf96478542949074a28ece004ef50974d803c31ef21f8ead4b4455a1b34e8c03121d9f1ec7683182a3701eff41deef50b503fa0f1fa16aefb60fc327471f41c209d82abc8d1de00f266c49bf4f851346203d209ca1b2db41e7dd09ea3c04452c1d2463df71a55066c5116c9673f213621d67a7af65948d08967f5c79e293d8a64ad5b6e1eafc8ff58c297ca0edc7cf5a7ad29822f4a8b5c2327aae9139875e07edfacba30f8ec8b1f4be738f49885bb13ec13153f055b076c0f4d2b26db6bb33ae864a5b81933a469c4b51d37d62131121132312daef41297d57c68783c4bc4c1310ce13beacb5bb4309212ed3df6f237600dc4dd1be3de24e256c4af5b851aa8a5fef0389abecef2f8ab48de22d751bc2621adb831247a76d587fb20be843027c76839049c3f2014e33e2530af9dc1a1b4ea51ae856ec8851982ea450121de6371c1ea953880a0159ea15663268215b4ebc3c2fcf642cfd72de3ae521f8df98cedc778355c9dfe6d98cf3e8a248f16b7f61a39fc391757c8ac59fb90b6ed2a4d144ee41fd25d68ff0c2a135c26b409f0c5587a8c5a2c7407482dfa039b570a08fcc9bee7cccde45afc581077bcb5145c07a9e9018c893cf7d4b07df50a73475f2bdcf7b6924633f75b55a4f40bfa60999305477024e02cb6dd3f7b1fd890ab6826e068efbb5fa3d32306d79f07c87f3381b389b1d9b0088da1580c077648dee369eda4b2f22b6e2fedf75f5a2377c7ff450a0bf47853c6b6ed417d1887a98767097fb66559a14d11c3f5e48bc19d2ba7fdbcf3e6d8a244c3d7a331190184a0fd443774202e35b2ff42552e5ffa62093c01fc755816323c230dba6c2561cce4082e45a8308c61c4ae3312c96c0567bdc5d9af46b81db198884eb6b8d8ed782c07d6b6c57916100dac252b0581f6e66300fb20471e3461aadce188e602ffc7a07b8a7f0b7f37bb4e06254e4c370ff4978d7d3dbdb551dc95cc5d56385f8ecf1be1fbacb2d2ea711e4dbb682a78309287536353decc6ac874248f051d24756ce800b804662ea59841ec0ba2704ee3c85f8a8c0424c5bbc5c92a621662cab01243d58a5dda815904621e7da48cb1315b87d212ff64fe57aedc5dba3c8c965bcfead31e66f28b68577c6376c91cc9c5a7e6463272137e84813a45c2bee8b0e5646b28f8e6affb01c3bbbe0b7b5cbf53079c19d9fc879a1eeba39a11214284baf5588b69810d91425985416f97e1abf3ad2ff1593e778e4a2f6ca49ae2d8a1b15000edd94d10e8cda2dbcf87aa217d147d49c30c99e4814f8c39e4a188c72294abf1486ce49bf5b324fc7268672ab656544ce9c11730ed3be016dedac9ff62d59aa7bbff56faaa1625d2ffd9cfa047382bbb2fd8a4fb94587668b5072c0bfac3be9a3953a3bc683e1b8a799d4c293a26f857b31ef2461aa908fab3ccd53a51ae4e4ce40b6ec9ecacb9ce464446682a633e69015e7bdec4ffde0a7393f24f2caf8f16e3b4daa817b6d87b4c1785cb799f056352a6870ce5be8cb0b2c352b80099bd66daafb8440a36075964bfcee0663280ca7648a95afc566ba106a3dc9cb0b6f64b9fa3341d76eb6d73c691364e5ffaae81827694131495cdd81347891088dd1a98b5536a900d6f7bc09a8fbd81d7676c643729d7494daa86857149a0c25c8bf2082e15369383ce0d711920cc6e9d648e47ddd7ec61d129b60a719979cc9c44d2f185fb0a4874bab37d67ca2827f1af33ef357d7b36e31a895420f10cf1be6ed53d5ba74b772264f82963ed80374cee56a8ec79d40b95e782e363e0ddefb2ddf5c38e5905bd54b7c5fec9d2b2dcd06af36e2e5fd18c3c55c79ca3b054aa76904646dedd7bb332ba709a00ab3b5964af9d345b8f5a3f8b97b8f2fea7cba688115b79bad7a6f1088ce4cf489e796bdbcedc181894ce8681cb8cacc622f50b0a170da34a97c141e377d14fd83716b3add4301e379952f1a6c90a081b4f95bd60c7ec05d032bc797c703be4a17290ee6c0a0a9bce6d241888b9e4c2b09fd69447b04c7f873d5b7e7352ea51e6362fd4d14481cd2bca39c83bba7df2c9290d28155e667c08c0c79823b78e511ab81aa0415d24c5d6ba4c6d94b7cdd0527e325486b39a302280012ca6160501d0e6f5de6604b7575f34a7d4e01dc6e5a4eff0feaea1094cfbe44130af2ed2d8b341bff50d0d2aa52dce3585701153ba1af36849cc373584f6c509cae2f19201fb7234a5cd80f8292ed98bcb350f71fdb5d8994a5a0697a8a840b1614922a5e2a4acf6f63ff0f4b78a576f039c384c8c4098e11440639b189a69854f8aabfb6d1d470e7c02911d4db9e06a9679925f5f6e231ce04b99edd4926a140ada5ba97223a111db6dbea2b223da5e24d0591f831733771d93f7de268b8505181b2f4f6d71782a87f247ac16df5e5f7fb51b78eab1cdc9f5aaeb8b9512ffee94e87c2c14aa5181389c87727415b0e7e1776942ca6e48412c57e20054e5e487005176e4f89394a44d16d0a6ceb802207b15ee5841171a3451d5cea230c10d12e1593103a643ce9b28ae76a18ed8774a53cd7269dbe1bbd42a473a4cab8b38235205507a65f07dbbe7e000667eb3c22298bceef7c77a85dba3539771c2b78b77453f27c0e262a0549f97ef828a2a7e196317091ace641c7d7a1f5e3c2b002836e16591eac1777bbe55b5b20e1def86a613001fc49f7acd9ccbdcc75b766e8bc21b65f96457570f68e49d344431e57d6c36cbf2f048d30c3cd477d3b9641c9cf8acf804715e2f605166936390f102d6f47cd33df3796cdc2a77891ac0e23579d0970cc23a8da203bb357cbca07c1f5dda1ea5176ab1cfa9d9b1b1f8e3013113b0bdca74af5a2e0d9f77ea9da76afcd59c5fe3bf0c47ea8744e577858b3bf9c1b03a1ead3a65dc79d7c12242caea253e0964abc4938c2507bd8ec24f094dac637885048b8274e590e4f428713140d3fff521bee95d70038967b5557a8cf7e6aaec2269ef1717629a3ef2d12d6e0db529225d4fcad93f443a73bdd52a4507369fa55592c74c014fca5dfad15b8f07c76fb02891ebacb925244a02b46cf25c665f06ceb6311f543141b449e631eb30915b59ea1c4aea50b54c720b2dc3b6b8a92108953496d7b2b808f24dacf95d7d7bb5a271366ce505653c805c22b2b24866324e2a7e239855c565f1379639159bd3c3d19d8b121498532b1738815387804c081025a87ad52e9c12de2b4624f8f81766ff092c337fbf738d9543e15cdfb0bd56d459c35e587a1e63aa9cb4af00461442cbc7aafa06692e81d0befed9bc131723f597b393c38b2142713ca27db4dae0f15e5a76db73805af5ec9257475181efba9ed3539d4c42c11d20cd03b79cb37e54c998e64c3572b3053af07a94b3c877303fb27337383f13481e0f73cf6ec0e531977191cdcb0a799393809e2b905fa01724be3a1902b53388218331060b8c4a4f2c97b3ff5cb46d96da37a2ab957006e57275be2d375d9c220f60a01311c33d43ae523ca4c2b891bda1f494a84899c69181a14cf30c4f688fdc070cde2f8c351325b711cd820cb25d1b9f107103bd4f911abc4e69ce418f2ee67980744de4b9038c629ed4e3ce8110780a0be4e1781424d8742a7a130fb86cc8fa0f0adabcc1dedb7a7edabc8534b46cf592d2db6275516a2d59ae6fa4379882c61319ee26e473c61127120c7f0d84ea64ed59549c78eb1da3aec19b9ceddf75a860c22af6ec19f9f1fa003a12d7e46b8b40d0b2dd00da0b59c76a2f0d7b9fd430376ea2269409a35b32c342cc7c28fa98d5ff74771925cb3c114d85a24f6cebf619f342cd92c70e3ec4fe74b806194270d2cf9c14e44d3757ec874ebcb90d905c856e8801454fa248ffd3d1f38a8d3c3453434c866615034fc978d41ea956c74339137da8ec2608b420b8f933540ef8c8a0cdaf85f5b5cc1f2ebc73083568bf53dc48508ec4f3f8ead48d1b92742efe06f42afb1f8e539e2055a2be89e8b4c14fddcb2419d73dae57abbb31985e52fab22418ec5ab52e2f16afa2fddf8bc215601d8744d34ae5d2655638b3133f96469a6cff4ad9c3384f13f0b260435e7932c68ba566b7a1ef36995a8eb2884521bd05add6feb473b59651e7ead782a1b714c4e4ce93d85b4af7dc064c8b1246d37481a8cbad63d8da9529c031daf136a6e249c5fccd7f6eaa9121d08bc167462d32d1f8089e10ea40a12a7200fa12670439a61b7d556676482ef87f22f0d2d9a15046d347e68ac527a0e9b0c58d4b72db48ed66c3de4de6750a5b340b39d251633513f33dd976cdf20ff61a4c24c3ad53a4ebe1274cb29cc25741bc4b7279dc15591dacf3094c0637af9ca74ef21de044c9a0a6af8f92bea7b7d77dfc30786ad86996fe09ecc1629cc64c435b9864cf0917c3a37ad26b2f6321e631be453866a7bca5cfdd27a43dde7dc04bfe04f2a236584d20655148c2200058f270075725497d70736bcd1670f83d426d3ebb552344f409d4e0bd3cea11423bc2f2a2a96fe2cb26736c72669310a803e399f7dab08d9d6ec39745c8180b58f75cbde7b048e34828ea746ec9c19c3a77a69c2ad1ac26a868cb4696cc7a6ca322c5021e256ca852187dc807ecb0a20125a9ef0e92bb8005c76dbcaf66fc1c5ce864e4643bd321f9d3bab4d32e0fd4c0adf289151b088c4302cb59a6653879da9ce9e95d10b1e9e7eae0d4e3601f967ac81a00255ca9fffa35edd97caff20491cecd5575ee6cbcbe4d2c0e5ceeeda2b53c9629e1d3083f4ab59d562610e2820d0c52773b541e1a105a4797c43dcc9d2d419eef2b703eff99af1422128758901001c02bb3f203ecafb7643110b4c28a27acf0af72348b1a973f2c1dc2d5445abc64cfcb76cb6f27b51f1429913dcd2084a35118b6b836db9848fe303ec3abc1a551b3ed89a507d714ce570f6924ac83c09b4e7f300add44b741c889b0be39e9bcc46bee0bfa12d5f50e66dba3b38f14a8e30e92152be09354fa87197efe322c7c524f8a6552b35881d1f33416a63814ca4c69170d71948c31b3a1b33f61e7fcdddf2a44d82555158935206a0c469a319686ba2fd5deb0e89db249fa8c527e0e8c6b2dcbe9886b01bee909be41a3e646ab11c3aef0254ac9bbcc6046f2042a9b5cc0f7fd8671644003f611dd772303a2a2dd1044c09d781ef45c7dc09364cd1dc22c72b13cd31a6275663e5aa8a62e18f809563b52bb8f7ee2f074be32dde0a12421767099722daea729fbc4844c2f554c3194671c4ec255d11c03a5bddc99942d0a9527d2dc3896bf842f3e841b81f8383f69bd20a9649a38c18f5890faa197fb81e065562f00401c7331a20f4b9c1e8811730b2f574075dc84c07486504c0b20d7d7958adc20e626d95253d98915a2222c04472d50ff8ead4b4a7a2a61fc340d30279a435dc48b6962dd55846eb4ab8eb80ad79b94c4c170e0fced05775f96e3c49ee9d6fc17a40b5bc5ac2a0dc3ec98af1e73eb793baf88b623498cbf3199ff31bc1bb447fb572da844c7da3d7e9756e40811194c2bb2d575e2b8e2aebc0f49b45b5d99bfc2a44dc3dfc5c6c127c554da47dc84dec2bf3dad8372a7417529818df4433ceeeb5489bf5fe41e06cee1c5a7b73d36ced5652a0407a31c06a530add0578865dbeb078ae0cbd50e3d6fe834f5a310698bfabc48a7c4b32a0223233ca245d73b31116193d5a274903ebb8297151a819a8f6ce251a8dd08ec5e8cbe3677952f9150452aba0df791e7fd2ea13dbd55419c8a503fe5f16578e50acc3550cb13c81874c761a4bf671f4ffadda256f2da733fe10843e79e0475bcd0bc767dc548d31f382483ba3db91e951b6cb7c200b30cac8427a46ea731c5d61dd17b4c61df01c43ce2086cb65412f45a5963408eb33e0c71a2173cb4b0212920d00059e40cce504614bd672a4645cfb0b4920a27c7b0bc4e1b32b05d0bca52534f9f38b1a9aff5f8850ee4c0eea29b9ee955ca0140f711d6d960c58d9a1a0e5f7a17b7d1fc8c5d96623260216217b9c29693229dcd8ca49eb41ed3569a667c3cc7db9d633c941d082a8d894e5ebb1b4761c74d46fb72e2ce666ab1815438f344123be0c0571b96a1ff43e4dcd9380136e62a07ceba19b338e0918cc4659dc3f003801f3735815017eba2c579a191c6e525ed624599f9a4d651d69f49cdc25107a4b9586db0848a349fe3520d5298d2670a0fe986b1ec27a97ce65d48afe9a2af4f046b6dc40bdbdbbf7b5c621d1b406200acd40a6e488c8db4e530c2b8f5927654ac90084fd1ef1ae046ea29609e6c6f8a8a352e7edf52221a54e06c74dfcbb1e40aa79dc51445235d1efa4a1d3762dc878769750955124549e1b485df760414459f6eb505e8fbefc786e6d6d43be2ef62cde03340e9e280e9b78912b407d6ca19aa3d8de3aca1f6dc65378fae10c1c7f62f9847feed2ac85808d0f9829f328fb401a393baedfa4fbfd0a7c585b4372aa272d7886642ba8c2f615ec89c24e9d842a8ed3102c06874a981ed3ee7154f55d9bf4cc0aea027bba13792fe5ca7eb8acd05574ce61160b460930866089ddde55ea4fb56206763bd9f05b2152e963a4a7c2d5accc40e84ca16adc0a2f991faf097a8db43a855e84fb20a27b15833df96057f1e1794c9e960e10ed7e86f154aa3d080255a18924961e69a4a5781801af0a67672f22f993942c92adf0e5fed8bf7e6309a5f1fe763b561fca89f1d1614cafe64270cb0100b0def81ea39a40464a27fe21659f97516b7df34a7ec929fdb8b88fd7ee91530d9b2a975d5d5f0261c64a92715a3b0a4d3cc767c02c8fbaac2b2378bde0e99b5c6805c8da54c64023aaaaa1d9b0274c561bc859f097a7c30412e0e28e29e2ccd55f2711fd97cbd9143f4dc2f9d0544ea059d55fd11ca4c61cbd7583462d1cc8b49eee0e1018275a7f2e5330abb0c90e7c5e2d8cf623bcf4340ffdac45fdd898d1ae9b9c81f23d68e708d0e528a1e8e88961b41f3e65e20a590f2acf09d327cea3019d442423a274a895050517f990c268acd92bed59f6d45e8f41fee5fefe60afa32d6db60c044b2c06aec825f2c54a305f4d8f2c0cf8842a8a9cf037861f3913dbf66e02da4b07a414a11e6cba4043c8903f2328cab14396705404677de91dfd62b34730ed9b2f074aff389aaed0853a7c1a63c2517dac0adc7e052684eab339748d2b26821b89cb947984e7b862bd86acbf3b7265f8c3ffbafa61f7333d004433b340fed4afad97c5d75477989938e402b7b2f1899079cc0e3afe077de3a6e9566865bc6116405cb27d7d0fbb2a1a21984bef16157eec24466ce4a0d5c1ff75cb068c4de55138d3428844ecc490addd190b40110bc1fa43c81bf45c4dbdc99da630a6332f9c18101790a161e1ce3aeff33e0655c5e0b83b8f8105722a63d247f1228a4f30b74ceb52fba8bbf5c5689430306e8667b5840a5a703d2a0e17cafc115f7401f1ad85cc18459d2a8c1f8d6787ddde9bf75cf6efa5d7a4caf3c5dcb0c2ab79fb2cc1c514613d2652330ba48cd9c22dc6b1828950d4b41b303f8ceca06c23813eb7b3b50c060dc6a6c75f4b439c815dcddb397b6af0979dbe1deba25fc32500b3563b1823202c8c3782cb6c99079cce8bf38a0107e5f6f2d80d0c9d83f4d042a0cc758ede246f2575ecd53c15ae17ad2194723c83e731c0da446ba9702bb2f223b8eb330c697daa5b81618cc74ee9023231d65461adc2f79492e754cdbf6c1d3f2f9aba28a8ad519db962c40ca88aebcd10ec882a9d2d62e0446d944bb09b8b688008239c36930fa2ff7792dc9076a2b655baa59d901a3f4c89fd5bb4ff80d5de98d0e508da6fcd22fcf739a5d3587be27377d68bd606b374d7d671630bbc370986ddce361d07dd525f37c9a890961f38dba84800c804ccfab7cfffde84c3ad896ca76d6c77161f4ccd3ce4e6e70b5a1e54d2f817453c830ab64b34b941095d02d3cdb3d3a4b8c0d52a1969eca3ce1ed71225fa11f1563c78871e7e5fcacb020b9c43c05565e6350d6feb84d3fbc1fad7a3511eba79bc43db3f3c148fd642e535b3f7a85fc01c27c8495b53c031c1312ad3de62b683b234e6447b09c613774ad75a284b71d5d0142187c05f52b772efb39c7ac7177db362a36408949452489cfe578135327a333791434c9fca0e82960c65617f58b8092eae886408a57e450922e5b2f0e9940411e412063f226ae8f66cc12f92197b43efa7193d956fad8e36ad241654db1b4f25adcefd72598b7cccba7d820077031109d35492e059190c51278a951d0733ee4b9905efb8195c4621b1b4df38125b86829fb3bd3d09d73daee4be62de4b23eec169d006b791a9ba1309c387ed4d9c0e69b0f0d3185cf48fc06e0e4b10b43b08955ba69a4c0990e86fc346fffd779d0b293bb1a233655ee3a9ac478aadcf0231b00fb80763b64f6e3df6f8d6f3a105577f20f67154aad1f44a2f1b452c0efa708dc70799a5136a3f759929ac7d88cac5d7c07130656c0537dd19588c14aef81133e080e34228f36e6d66c4f549826e7b07ec1497b655cce068a60392c07923a16b7baac0f08659bcf78f8646ab969c69180fc97e0b2a3d7c0536b19c2fffb449198ff8d31a40565975bf97e036302cca161568a2e349c267d311936faa9bbf4608c6cd1d774bec803dcb20e6a26a91acd67dcb703d852cf312ae94d0065037c3bdd797a3ea86185d33d62cf10ed465d2495e6cfd11a06f874dcd5fa06af25e9221161bb20eb87aa5ce55ff7308c2d228838a8fab4f8ff25cb25e1cb402a21fb4c6db0347759157152feb2b843ac2be6200a72af99afec9d3a7faccbb7794a16d85073754a91e9c04b36719434e1083df19fe1515f9d2e190b037f0f04ca943f38e4bb781c623d2cd4c35319a08e3e559e01cbffbbce547a960f7841677944e21bb4851f7db606b1d5a1572f059122084f300f7d1861d377cd3357aa657af6da8d2c7b1bc28dd1cdb37ec904da48f7b024b4d4e6ad230b8b6c990154b0b87ced9e766666731b910bd3d69447123bf89d64592bc417c9c5d7f44eab8b169b31f0eabc1b5455449c2e7d7d26a979ca22ba8d7e68adf0e29d2ca3b297e09aff0e21161af8df711af535a8e87ae5a4dd224c99c26d6fe5acb78f65c8fc0e35bac216b2048b5e273696726518daf1e8806108ce5a9ab22c2147273e5670404bc381eb9da99b52eb12acf226856bc8f1b0aac0ddf16600543b9b94b7710eaa331b974e7b582c265cbd28a4adfcafdb023202b4c8d2e0e195106b95528ab91380c6895b45a0e76fe730268902d819c7100a76934de14c84bb1c8019f41e9a3e88c68afb1e7106051d88e32d59d36b0fcffd3f99ac13121809b0ab38163f2f7ee13425c3b81095f84e80587a157b142c73ad7aaefb4329bc2a07621d9f976acd7b10f8dc6348156d6d648eb4c7d6b29da670408de30cdb3b592e171e72017f6ba5ec185c6abde164c413b7d1a26ac95dbf8289f72cbff8a781ad896f289c264a2bfe7105232881b9fdb1da2c2f1e0b9983ff4ca6cc658527a8eb0ce6a9802a42c80c8516de17b9bc90ec3b2bd1f2ad7e14128cc0e72e66181a6b1c10f7a7ab37d39fc6be80a541e0354104e3fc19b9548c9c14c83169b4e5c1e4e8e8431dc613d95753a0d88e3f256e8e0b0eb623bf9ff796b890eec7aeba28602e1c902e510966c80af5cb72bd2752858f9bfd7a9b2a3b74e33ccac3cf001e7c3c7f85ab2d3bc7571bb90b632e709b98a3dd1f5f108436c59896e152ae98c2bc06ad1a52415f2a131e9be2539993d58e1030b44f74f2a0bca039ad99bef9c107a5bbaa0382b00fc0e33ae3ed33479aa67c5bcb39d1bd1d9eeed7d0558171367e2dc6f2df5777e8a4161d588a216f6ab691e9be67529e085b0615d46b42b735f98ab3b64060c3f11e3ca32962419460464bcf0f1301789bea4f8cfe99fe8868906431b450afed55801f07e15e56db7ecae50eb84c582331cd15dab66efd3200212e642118e6880cab13cb568500d7d5ef360b89a2acd677d62ef2f51a1cdbbcc9773c5ed425d49b4b53dfaf679ead4592c7dad8de12d9d607d9b069854df7e6bbf120f2216ac346fa2429623ab485cf1fae15e4cda2a87c67729d330ef57e08d76dfe2b1d63b477109c89170f95f38bcc4b473ebbdec565ba6440524f202270d8e89d0492c9a20380edbf8e706262f4bae4c3057d19c07ffa922835d92725eb15797c9a10b7889a3da238372d44ff865759a7ae360588dab7e7cf08e3bdf95e9f5006aa3a14350b67b231caf4a5732e8eaaef49466d0752cca9867c7a4863349769bafb32e43d583cc540b43bb15669a8e9bb5dcadb50654e3023d4ce3a243f6572d90653495cde12f7196caddd14ae79e6a54e858c61c6ad72ddad74f957e9b96f18b2e3d106b4d3c0bc97571f2a2b28c22315921c57c2f9d94235c73693ccf3c6c46df6f376097ad92934b3336ab149567d19d0120d4982b7eaa0bf43ac4e9f05be371feffc55557034ee40bb93c03e5f72ca747882981b7426c7039cf9349498d2c77405a344e7b7768435d27ac1155c064800bb4d244f2a9ff3858996089a7f4cc6471ec9a9456ca2b0e0ecc30ce824fc9f4fce1897643b2f440177710bb3802befe81367ac366f68f95bd616745a2485f23b5f5245eab8c75c303da4e10a5929354d6e85dbc20c75168982b56327d1379d2270399ef50f6a29608cf7133866d63ffe1434e8c032c8947c113e097c694bda13b38f1224a3e93202f2e6ea8fe681bcacfb41bcc88b0ed5669caded069c4520778878f7ebe74d0c4b4a50bf1bee6e24ca3ba8bfc2f1c4d1dc63883464585edb617d5c5446cbc64fd9388520c2af97f8b7a9badbb468a788a096dec8d0e2f62e889b3e579ad6254c4146dd54f1ba5ea4ff6f77685c232d79282ca4dadece4e7e516ea18fd2974be069bfd5ed08dc4a9a45d6c41cc701c979d26da4ef858c9d0132389d5cd1abadaf09788edeb511507e08ef83ec06bc59393ce39c8b3620959631ad862c77143b6ee8e868be74ddb4a53b519366f4b6e57fac9302d83a1d5e99cbc2cfc97d25f958dc0dce35810194c12ca90d3942587b265b7437eec085be08765c58d7c55df9a99a5ea6874bba97442affa2bebc0fcecdb78b80ce2e7cfd25373f9cc1830286892b1011b4598cccf5b5720714d13c072c1d54b5eb6663f0356dd10393512544236b0f38f1944bef5859da5da19048c76fea049f89d37ca12e20c4d696a33669d8092a1d9acedaa57a8d13cad064e0568b8f382caa4c9884cf6744174f60614a362accae844ec83d901c1046c3879fe705f98d04c30018e7ea8d04e86dd835175571ed3f6b048ee0ce822bb3492148781d7c96c33895147a20dbf8c1f237cdf5ebca76fb68b7c2d49acbd4125812bad0d77b67b70a579b8edfb63d54f92cfaa182ab3270716f71a75b81a3e641038d21dc975809fdc0d55b22f8e38045f59fdcf02f64db1cff7c0dc4291ddd94681f0fceb9ea2369d776e46e9b0bb1ef983fc6ddca7c8b91693b88776c221f9e9d33b95074ca2be14338b68128794c1f280b240c8dbee22333be3d5c13b676ef2d98e71264ac15ae888e8151f3f38e0a1cef316c9487ad0106ce9a2b0747862e99ff9966037df9200a11a7799cab1076be806906d7d8da8b098a0fab38df737ee3ba49747689abf320988f364c935f560e7cc98baa77fbab1c0dc3cebf5f00307a6f9d6c34a7894ea0afe37936cae0562479eb5bd68d95c978e40939c2105984c509e772382c0a333b0de5925ec0fda92015a3e20bac260fb0f1ba84dde1e234ac4d6cf3b3604a7f59cf65df0bdf8ba54fca53ab3e8614fd24f3bcfea0629b6a5e65da040836e0e41ac4eacdb85594a120196f68598fe23e343cba87a770c6170eda27be22d1e4ced874bc483617a5fb507c93619d2e7b264efe3ee826931e582d1a56adb2b0b48ba7d9561ced7b7081ab41af600b1cf07a1141a2124b9aa325676b12406f1fd0bca85cb0b9e8b5481866d0c9a66b65bf9bafff1ac9cf7908e41e8b6a72607675c1cdb21e8c26ecda1867f68248453a0a47349144957e6a7a3f98756ab1278ceab3068d7b7b510f8f3b7a58b09b1d5b226ac8bce8926d0f67b76ab9759bcb34061d5773d5254f40f0027fd1737693b1b838891c08edc36af622c62736da14960800ef6fdb777eadc9ea90a8b13952787a56c6e80ecedf1c9a4268650ed8f2ec07b7f4dffab9c75221c650a304026c2bb1dd8c5fb8ba92f9a6f9de2817bfc456638b7e317e0946cb52390973a11f8198f4706fc5877427e0f189ac208f48e97d704f5e3304a0afa1b5bf68963f3b6f8341721b8447b0d3f8c55665949d884ec77b11100eb7e440e978fd76633ae7e4d880b7981024a84965c49a791c361f8a702b78fc8fb2ec9c5709c75ab40ff94008fc5653ce44528632d4d63c3ae6a73293019ec3ba1f9e3676b69364f3cda93475fbc96f6a2df99fd3af3cf903ba7c53eb801183f251c6b68dc891823bcb9d0296a2e7eda903b87506b103da73f32c5b39814064d6ddbc09c4d1d8caedd599ceaf92b6d541cc2e39363f35d9f3f4b41cced141752c765e0b4a5d588c8dd19d073bdf10648a0776933c335fda358cede7d53cbdc52648eb404305b163d5bc0c6c91ff60cb4bd7a897a0e81ae2f4c068831e16af252fb4ff02ae2ea7a7dd4977e49c550336943039c230d3cf988bc49087c9e68db758308d709edb12a12b6e84aeb58ea8fa3b7fe43e8592edf83187df8c2627e672fb644fe3b4a730f53b82c20337adacfb5ae94c0fca15f545d6df301f3b7748c6870ea99969f7d989c0cebeb43ad771ad21d69b94f118f6aa2973502ac9c7e71caf269caaf70229b0b1b4866206da408f39b7a6a87395f1eec15b6957050fb6b98c2f93a1d6ebe2317e143b4de8aeeff3e5e5bf7df4eb20285fedc40cc804e33590d2e0b789d6f39f72d18f328ed565f7352869ac665754b6c344739b942ea90ea44dce43a54ad1d6e590f9e48ef83e4d3ce4d38f81d07d760302e557d4d0ad5ca2638d604881e7fe83fd6c7febc28c8aa69d514255cd3e890f43316750d26aef09ebff49e0984e7c3256ff40e91f84575e1c7475d42118a37733354cea437b5e8cab4fcc4c947c3f4a7dbc6f3e96feeb456394017749f17d59d9928994fcd4c69f672c833d0e6503155a2fabd643f47c2ddce2d26bd95777113a0e795873dd54626e031c6530f9e4f7e41665a0b8e1a2bc934b37bbd3ad197a628c08de846934dc0260f02ce475918d6a0d5d6b4449241e437aa3cf0ae444f9bdcb7595ae49ab358da4790937cac45990544f9f2994a1eda3786bdaa181333266b09cfc20da10c50c83166d47fd8ba01360cce5374b9adb9bd325da96f40150980f448d883dc65f86b7840f59a7722aeac2ea9a6f9a7fab2a1f18603d9649bfbaa6b246f3b3b5847e55c2ab5cb63ea14c79e5cb71a4a8fa7884c86d11a83ef252338b5ed47a3f69","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
