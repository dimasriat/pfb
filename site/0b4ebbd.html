<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c1aaaa3183a88a2d8f203c469ac82be8c18df18e58fc7542b4fea519daf8d7219377978d0483138fed08f2df72b76b0fa188c5f2d5e2eb9aa4bbfe471894a581516ed16cf827f51f047d8a2d5f8e77d24bce33a0667bcef5adb912cb17f3cbd88e096a92e59455cbf4280037f9e758e79e1d1e3cfd55f196b63c7c788766bc409c1246988bf5f0623005161a7cc5b2481d83bbfd7b7640077a9543aff37ca46536b9e72b2af66dd5560b3b5c7a9df51d5ad686b3e48bae35d6f65649c4862e602b5b192d130aa3bea348b25bd8d50288a28088d274d5313ab5e2f5604f7c18484f8d7309e52a49ca704b34377119973938570bee924d2bd052e30c402125e2bc879c8dfd2aa134aa995c7595004cc451e584f8229e7d17b5b662961c63a0ba36ab076d89875326a0fb16293f8c997c7bc60acbc4832400ea35bbf1622be7c34854c63e6c1db158390305ca4cd42f5af2b7819a0e35e23ef8078eba94048bb12d4ba18ab19c2a2bda9c6bf6c38f045ed6aef1c0d47db8f494808cdad79c8a5e55abc2316a0e80dec0663ffc6b4e059e024b181c2da0d7f6cf0bc8ee87b1a57e2f370d122fe5365722a4a0a8012682f5d36f518d42f1fd7f20f775842f7e895104dba002feb3f9da352b526a2a482c95a999c96560ab0b7c96da78e496172d94edae3b5918989b3060ded9349d0446406b6574000caafc8847d86751f2e1bf4f6b7aa747ac6834d2b3ee95e9210aaac205029da02906bc96689acdbc551f8307cca4d25f8e8c1fda19aec13d77014abf1afa8bb1d480f201fe0c5d06f96b993b2220f4621f3428637ec1cfafc1ac8986f3e0d5f63b439f5bb85cb69fa7ee30b7b1a8c7577fd471aec4704fc89321ca5ee1b29953b7c61413070cd53e7a8e27663a1060614f2c0182a7f8a06c1ad2cbff9d231ab605c8e1063c88e38041205c4ec662ac3514dcd2a2670493d3358c85bc7db48353d3a2f95f24ed07ff6434bdb63bff94dc5b8c3420aa33a1b74a6c88498d8e48d5a6efdd4de31d11feddf78520036065454798fa6f858a7e2f06fc33c974bc073d261cc41645e96c8d993fe5aae45bead78e46a79dd79314e663050336c7af947fdef053e93e1d0bb8470712835810e2c242f3992e60feea370fea8646441859606b4502b671d96de4bcbe256cc14ddff8367dae60bfa5c4419414de1a12b088171341f5e719ac60828810c42ecd707b07e22ca276f3700dddcf31fe2e6ea0ceb6d057d5227844682216693ee5c4369aa2139a91037c089b0b3abacaaed4fadfbc3d45fc5636a6086c4deb2bf031bab1e692cd6352f0be6d7daca12762b4ade61c5e11af554b08a767cfcf2592ed48103ec793c7aff389c211bf29d41aa96f369c483bc80dc24c1ee3de422d4d85af4e6e505f1578f2b2ac1239967fdff9467652f62dfa74666ff11bc83661a33e0dd44fa59f4de9a88701fb1bc7411fe392a9c56c169f8a0d151b9b7bfcb313252b43f3fa949f4067b454724433434bb621353acafdc9fa4c1c220c6378143fb2618bcd50af7380a401af0e358006f404087fbb7266a5744cf9f371b6a64296af525e90779d2d67f6a2e09739ee58c37ed80e3f690b151095af59c1cc9f29d0f6e6718d577f702f061dda66e2d3a22bb28934199db2a1e8e11feaf7862f71e47d9d2259080f35178838c868bdc26d5565976d0cd2e71cfdbf43ab6de86eaaf2ea95e73d5fd2e00b4df9ed07e52fc3143d5a7bc1530ba0d05870fe2887eb2b1d4b985ba8f06633314f16283f7ce52a8b7f4ebf9acdfc61eaee183c45d847cf149b7d3c6594fb8b4f381c6156ec63531ec7d63b14848fb080d53b475b834cd23a0ebb2dfc45cb16026b1c8c570b202d8f0eea97e35236987e26939b76a8572e9b32235ce6bf52bc814bcc1f5fcd858c7d1dde6017ce20794d39b66e15d06b18f96cb0520266ce3ca4d40e55c9345a075ef224f79a3a7226ce1ce70733df740879f985a5b83e3b3a0384f6ff31de278963136b305f8f9146bd906be3057af2f55046c2b10aac6d7d668a3bf6b873eee1528bfcd9ad16a82adec453b99ccb1d93c38bab7ea88c183f5942b485639c6157b9ccabdb24b9811dffb5a55c271a7cd947035fdc5300c7156b5b3cd3e909a2eb77c14419c87f1b8a5a6ee90246ef1fc44c1125a66d5695c27cdebe015f9ab2dbd49d7f2ee88a3aacb83cee1163256627c3d2319e1145ed01db848933de11a44745961f71e362b4344a7b51c4fe3009c2af753778e2657bdfab33da6a84814ee3be70d6861b9b1a47f398ab1aa7b5dc42657e55b67f394f54121863567d982e7efa5b0343b8623ac24c46f091f43b4166cfeb946c63f68804177629b5bf49b9bb66947d5251c6a328487e897840f49a1c52aa5a0a3f72d63a3ca42286a84ed9e938dd4ea5b9003faa867f673671e594494842e5a521b00cb7027c61536f83f0f76d79315a94be91cfde1ea34d8bcb2aabdf4fd3d9ef3df230bbfe6e9f712c61c7e5a3f3098133b9978ed8895a03b5aa175c107c24ffb087a01dc36c420c353e140abc64d9de788fc72b1fbb524346870c46d521bd41ae3f4950957064cb15bc9b534f06d1aaa502aa1c11641c5eacf4619e466b4082813d66b4e16d4c86d49645c26f5aab7ec327702111cbff915015f31754993aface591ec5ebdc83fff82dd89a557ce4d09322107f33b6646a1db2a88ee0c4e3cd7599308bbac27f4bfad471dd282ecfc6c754f233dacdee6560474113aa4cb834e40b12c9b15cb8458718228607de0e3ece26fac85048df0c7c15643aeccac2a0d2d7d9de51931018bb6a36d17f7f3eb811a80c7cd5058206b059b08d043cae8e8d8795c9b43b79ef3aea119354eacd6a36a56c35a0af7bfa71104947e5a7725d88b86be594c99693ed5123528a13ee23518f32c932a577190d043308bd1221e019a522eb79963d725ff3284b80d2b6753636dc5016822bc206c308263d3a490294e7e16b50e2b7a621bbbdb7bb2dd5d9646a422d4abd3286f346e26858f18f02ccd75f4ecc0afbec58e9265adb72a88c23d19f1df7cf6388e6a2101b673fa61531da67a25d2bf250d1d4041d31959fc4983a9547b052469f8134e8293b81fdf164e71b0a89b70bd5ba1819fcc5025d68a3f6424aad72709eab86846e7433d8263c6cffcb49d932d1a9d4117fd176aa7c3752d3c7dc2a343356214783187ab7f021670f1240c47d69636f5d719e3b5260e80a1f4597264da80e8fd019734e7ad1ed87bb9f5144f40d3d6dc50a9b948852a76fc6057961e1f6b846e57ebe6676196f236bf0382c3e85a533b289b8cd15834bf861a54c505d6a5449124b65ee1294d62cff98df3bef03be34c8358945a749261c025bbbcde79b3670b765446261d6688e72d968405625b3c631b70e2a31f951be7e0140277ec7af60dea3d59d27e9fb229ff11c68af17e162f7c078fb0da4e4be9fba742f81eb849319f38ff31f1f0143bf7adb45832cd7a0f8b9df3620fdb09090dbdf61fb4a77d952ddea369f9c532b7f39b48a60afe146a9bce5cf5385c37488a789c89661aec24f0b474665caa1ff8406140bd7242900d88abec410edbbd168c346ad1e73bbac4d797db14e5ea40b822c22ed4b75f3e7498e06c83629879521fc73e6fa4c99875b02b4c07725aad0ee9485f0da9fc956be1b6d9a02ee57cecbc6a376f09367a9eafeafabd1f724857295ced88ab891296512833213dd77112ae71d256021cc4e5b771d28715ad7251375db64fbd3046724c05e8807a354ee5d12e67f167d406e997b2ddba474e738e7ee393ff2bb01946218cd788e79fb73bee59a10707ac91baeeea00a37e31d0c1fabdd7b5cac6a41e0365d88b7658f90e1ea6bcf525c6a30e485722033d53abcb90d6823253f7bc73c0905dbd52bf25e35b333d16af4c1e76716273e55e6c476e432138d824a6a6ec18621bfaa27cb6cd8353fc9cccaecbc655ecab692eed38a294e8808eefd1ec6cb65eaf4cd86abfc4a8ec7749956b6623aefb6851faacb6ea5bf89aec129deceef16dd8c0280dadb91bbd7537fbdaab937486ea085ff0fe953406b39f1655f33f1f7d08b97543fb3546ffabbf5ce402959b876cbd55cb4b05834f3696346c73095605b8f1ea6aea28d0fe32b68ed8f9fc12289defcc3a4c569aeded9562d919ad3a155bef866eaf5cd9b4c69b1f5b34de8c0699d23a413c7845114ca60970e1bfceb3d38280ff4c8a714a7b8655a06810db4b5d1dd7c6f6a78aec9cf1b2815d8bb47d92c77679dd079cb6d44b7c7d8422bd8fb7a0e5231928dfd80babfe42c8fffe60399c7ab46ffa56804da42abf16045bf85f40a4cffea44527a36a59a375e1edf9298d65730d2c462bc9cc4583c75c196b9030285eebd78fe9c0618e73090be455c387286f0e08438b58cba6031c1d29712d0597c391cd2ee3107d2a516e26bab76866e9a193e21e5204c2599716443b5cc807a6a1a482eece1ee9bea365902b1ba5a2ef5aa24f370359ac9127113d8ae1ffeadb2aa134567885489adb85d3f51884755bdadba71d1db6620bdc8da519b52909b2ada5e059b498941597eb8801891e70924999b304b33c305c60c9ed1b04fb42109b6460538aaf703ca5e6b6fed04bf3827a7cb26bfd6e6540bc52a3d2f8f4f4244f94c1e68497be35f1935408d7c4d654540c30318113ad1585c5ed7c57675b8a5e8783c0e985c5dec3a4de7067618e284159000d2d0a424990b5e0da81fb0bf33c814b027770f189147070de73887bde8d74356ea030ceee88026fa068fe9c3d849d6b59645704f9f6d2655028da8e6194a9765ba6a71983a4f724657bda8b9ad03103a521b4779c99ea5dc3cc402cb5389d5f2bdd2ebda1a1e17d2b8078dc07ca44e88c26c5fa2a20d2970117403270862e7b57768d71ab2df80253e016b75bb10231f5275bec1c0ffadd7b1d582af9bd7580e95dc94a370041f712c47d1b4a0fb3f537b04c1d88ae589770d5c86db6978f43f1b9965e1886a5b3c4bd50a8e23b2a376ce69bfdca82cfbc3ada6d9e239a50b5426a978f034f657d5f9dc86600a87a5854c74f9ca98a7484eaabaddd92b3c31c278017481ab47f2beeea59e4e105afd6b1cb2ce1c7c719050a938005ea4f360fadf67959beb5a4240f83b17be9ad0d4ec1a3abe0e3f96839a45627ff692d94f294f8dc7b15e09311557a3c37701d861b8f87cb364a3d5f7389ce76faad156b6e969ee72fc579c6b1b919caf7cb84a9507fc47df3e337d684db7fa07ddea66e31f81be57b7424bc4ed7d1ffbb3c438a16137b296685d1b88504fb96813fb9a254047ec89432079374a4ee10d0f20564a560e9a81a236523b6e6bb5d946d7856bd3d7c347e73340ee8abdf9ffd9f7140dbedb1e760d0811df468b25b6935639a00341fc8dab7d50b8729052559ccc81d3b00ac1caaaa329cfc20ffe8d08de837610493f00d0543bbde0ba228c728f66aca621bdd1423cb6561713eefbd55eb80b35e1206128f6bea54146ecddeba07c6d1a9a09abef17df411df8f0442f39846afb20ec49d536bf44ebaeb94cb2c57143b32be55c394c467dd566f08921e66c88664d07b24ac3942b45506e58559cad5688349df4650e07dd4c4d7e75cf00355537fdb04449eba5e9ad051b6df91a3c7596aa8f1992a57fa7c6aa7e908621629a3d7514871ebe74797e3b3822b5f24f890f294a8ed0e68f45c9588e7c3eed858fd428f8667e1b86ce65084524a1eabcb9e5e7c1d6292f5bc44e1da7fdfab8869a3e1610d21e4cca0918f5652ef22468c4ae1c52ac2014baf8dc6ebb5c0953816563d7d1e37e3fc41c41cca062f371e30194028f8c5907f09bcfb86db474ed83cd21e2b10d3d9e7fb125383e46d7c4d5b3c54f8a472da2bc0c35b4ed4d0adebe7ac6de322ea7ab24f3222b73bdbb216b511d86a728990921316ad80ab47407b2700da8dfb9e3e59b6ebc629dce40c453eb8faf33bac964bf58635cec0010ddffc1a306f6a61d24fecda119ad7eebf017ec330b5983db68c0307d633558b116d8c4ac8918f729f7c45b86681d8f809a6ce646889e6a1380258ca4f68da81ef5c1a08e153f01bbbfa70a2a7bb851346a5eb1625c7c320a3817abcbcafec12cfda678ae29069bed468fbe394d8508279b8c195d092a8b698e2eb1614f6e7c2d68e01e23517e47a5dc0877417454b26de31c130070f2672b189a17b723f1b6fafc77b92a6b5e33615e113488dc60e8e5337cefb8d68ddf3d6ec245e1a533e8d6659537f5711a1353a226d3cce5af46507650bdd0a457be6dcdb2ff6921cc28ce86dc73a16341cf2e1d33130597afce1ac4b61d65ee093e740bc2fad016e43d73a34355144a48c91709b4c23996fb3819b77a2a9551299314aabb869616499778abe489b63aebb2a66bf82fd62967ab8b39c318f69777aadaae8bcd61803916e2c293280b75351e65d0881d078f9c0eea932123409f1ef366249c2c138afde2cb7aaa50630ccd64cb75bd21369fd3133099ee60ee31abb3fcd3b4a57259e029e4cc872aaf22982eb4693544fb08ece70ab80b69bc9674c92a5ee327031bf583f1055ea37f9759cf4e5cea59e3c4c090b839e6c0c79bb5a4850333173d4b28d896004fdfee978e4f86f4aa735ed231e082abca6fa067b1eb322c20b0fd91ed7ea6aa3ba4430ddc09bc833e6d98ea5e97d86c845b020306d4891c8edf6d7d6d7c89e0f66867fcec5a3ca50a338ca82793ae3a83817e3081d7f7cbc30a3a2d51372b765dadd76a3a985583576874eb36f27b2fff7ff979ac3dd893c5914b4273c6f322f43dd23bf7f46bb56cd77c043f2772a91f1e88d49ef3bda443186bd363cde53639b85b545add208d72f521ebe269a9d47a8b7acfdf3513f0a10ae9ae5f8daf8f4bff370a620b2f8d3f28c84b0d0ee367018bb7cf7528cc848d40b7ed70e27dcf3fdebee8602ae8cfe3533c6eea4207d085f0797a666433d5d768f838a4ede6413d5ec99930c2f45ee70c220322ddc5cd370c1430f82a856019e29fe36d8506f7773ab43041e6fa0479f4dcfc626852840b3f91ee730ffbc73d730c9f60cda6687f4c7c17eaf95d4c9aec37485ab3343279203281c7b55df06338a2a44820f6268c85755baa303c264b79493ad6469341029ef95bfb12faff6536b4d8f3665274cdcd0ac84678d01b0ecaad2f8ff4dc6105f21e08e3c18c1f85471ae35467382d9d38bcf092e66857f62d9724b0e118ed5ab7c835de67e5c9a92359095d271f9e18ba2d323cf55cba88a3cfbbee3fa3dedf54165cf2d4235937fd10dc041abc808d87acb8a37d5b8c8cc285a51cb1433bb66bc635ac8c77b21a5c818200144eae4a002ebfd4cfdb42b466e90e452075801c4fa72d6166ef431d62d44d0c0e3d44b95ecbf0e1e743919e5a04c35b9927ed46170dec16fb0840f6af592520d09469d0bd2474927fc8ed4823b0fd50ce010c4795724ac63041e94246f9793514a4bd1780528a24789fcd922218be1fe84dc8898f241516e6afc42fbd20791ee8891ced79d5b5a2435747487c00fa9fea09e713457e61f014156b53c5591635d3873889359469c9afeed5448ff082454fbf7b9885cefaddf8ecaacead7ffea71789b995d7698662674b53762ec7b60931454caa91a3dd428a934fcfe087c9e053b5caefce9e53300954a5c5a15fb99efede56797a6eedbf694da43eda76236030b29c1bb0492c904fceff0621638e78222fb9e50028f046c5148deb1c18dbbe4a333934e93b6bcf57f697c140d53ac17fc1cf83e879e4a8bf5f4d515a08328bfb7755194cca7fa8ef0ce9bcb9684f318d475f7c01f25f89ffdee109129ec82dd8b8a4c15c008da1adc8caf690dcf5f7c5636418888600b2b7d549cdf5dabc8bb5949f48bd9fbb7b58fcfcf900c959d0c01a5c1721e16952cc8bdd3b79a611e0d89072b4e1df7397ae4c7b1d6e7344c3ec58ab29dba9c2635e12b4ce73d9ab1b6660c29546ad790e9600581de66b9a5d9f0be07f626d4c1fbbe9a5d1a2d8b435c3d94a1310dbdf867ec4ffdc57b7f91cfcd6519ea36dd56e729daab011bd4d0cae1ad14dbd7736ff5e131848c50a6045d9199b37094b2cfb6686ef70bc2a47ad91fd61e0ab0f8e2ce38edd52a171295556ab931cb6eeebfe6f07562e200847d7c294dfaea68a6e17843b2fdd4821d25813a1fc6d88123a18b5c022961c654e9ce6ec2170a4af64e819d2b2ea4910388d9e2a8112b41eb02cde29284e0eac612171c5929067db441088d773115eed7e6708c7137a66ecb519dc3386738acba33b5f310f703b65f82acc5f42b82a0599662c1ee247eafcd8aae281e03a96e39618a9356a8861fa5c0197da108b8944211623d854f43560eb13827c929f70850f1a24f11a9f3d53537b07f600767b917379cca04d3d3692d0752dc4b54f1f08b85337507e123f0b7c6e60e2546b121b0f1a5e11066efc5951f2af56456702c000256cc0d4f8d77084092eefd51318f758eeff5cb30e5d1d2200ebfe45c023484876fb845acba899400cfe95ecc746b45062138fdadea63e599fcfdd846927666494d7cd37e715a9b3abbb36b08f3eb5033c05ab4e4316029cabc0d2b26300479919ebde319d5cd18c1bb3d0a2397fe118d1d5087e43cf90e763d6372c12a69928c0e5e34e1cf578a78242387e55dbb26e71377e138970cf09ff94bd62b7131b79ae80d256adf71c2cd6055adabccbf4fd2099582ef8292117c96caac82f0b06bbac72e94f70f69ec040de0d08ec798900d05e35e3d17fdf6e8813e3376e75dbeec2e313635135826a920e09bbc177d78a7fdfb733d843bb67028fd3dce493d6a7aec8dbebe0657e2d41afa2139bfa65872a694c8f32f7a5c978728f383548f109420788eae5855893d4bf6b9604d8b2259d2e6d51f3abeea96f4c6d7e2d134532f964a067491201f30d88f04a576a72e37833abd48973432a5e669dc626d1c5375b58e969f15df31cd3652377615b8cab9a9e2ee1a73e9e0ad852186971665deb6d41d65d6ecc3057bfc2854b768bfe8c15789eb95535d982a8b787ba83e38c9d842289da1b35e06acd4954dfb7ec9694cbdc9d8972a2e0c638c7a5f201d5da7eef23bfe3a7430b6f3f57c2c755af936fb0bf40d16b764e9a14c06772fa313134b284d55e60a8c1484d080b800adde46d5f7347a8f76c6d1f639375c8f3f8a4e79c1ca76f7a6091869706fb56fe794510e2d133b13758fae02ff67615a8dde643bcae90bdc17c1fb5ece7f3620b8dd035630023c755535325711b869ef7daca3b7008f8632e0601a7ae97f7b485e5cdb475b094683173a9107530ccc341d95cd9b7f6baf1170ed99c0293dc09c6bf88858582d9a26c704685379a58020af80ecfeace9ac3f60c740fe1f45d68d7e2f508b2d63b45e225fd013eee6a181dd9102f9202af3cffc43356856f71bede2f7fcb027eaa7ed3d0082ec878f19008be986cabb96fc8c2be318bab30c621b7ded4e22c7b4cb2aee94d3ef40cb7fdeabda9e3d9fbcb568ee1c64a9fc701deaa9c47561c9d96f31ce9cab33d851861a720a8022edbcf3c03f6dd140725b26587cd6ecd83f7c607387fc52515a2fb834add6a4dd38e3cfb2311e15f4b606060e4118cd1b56d2f36fb972ff6513ce8b501e0b0c72fc0a793ba44732196e556172b4117da8e0e3f61213318eaa3cb24d2f062e05721ca512426658702cdc094404874a36eefe4578a90c345371d2dc765a3b6a6f34a71cc4fafa6c76ae5d69a6de49cc3a10a03032f35a78d5d901d1a539abec814748c4bf5b27edd684e90cb831d292184a81787feddaee89ffedf7e589aa901a57353fa36b6445513f26b0863fff7f44ebdceea5e13898328a40c859d8902f238ae1a65cfc741602963529bc143e1078ee2ef18780f5acefe00d75b09b8eb0d67b03974415cbe758ed2ac775c8e6adc57fd6318171a9b5c93c5f1aa833d3c7631c4596c53f3468702540714198445b56e795631758c76a561c53a4fcf1be4fe0a56a953991a477c9736d08d1ba3b8feb7a2c16ed50e5c0903a9554d9e8faa63114bbfd1da84b924f4d651a0bb7071c3eddf28bf6b3f7411565cfb019a42a21fd333346d369adc5f10c56ef6b77bd0d54057c82a235917f27dc1768493f01bbe25dcdf14ac0bc373f903887dfd158645a714eaf6192d41bd79e06abd75bbc6049285f919ac4ac228f8a10d47b1ec324ac8080f34327302c300944910e526173470f4409e46653814fc2a8e37dd09143352125c661e9e07c99f1dcf308d093225ffd56488eef12c22a789df603e9ca68362b35ea78d21c6ca569aa9ba28acb484727c707e34a139bdfc347c3c36ffd166cdc4efb7b74d9e90278c7cb8bf8ac6f6acc4ecb23fdd7dd4fa52e3ee44634a3356a773f0a9768c949da2a785bcaf5f0455f03d28ec4ead80dce571bc7c392f53b245728342cc1c49581d60afb29d968d73d08390e559c4b5638fb58f4d8eaf40a76e507ad446cf46fb3f2a6e750b929395771f03faf33f7ec9c9404b501c3f725edf0120353247af4115b1b8cd074d333dbf61c5f8c842df1ff8eed63789493a8ba630aaf9935775abcb28de78b71348f97272488db885cf823a6082628b0e48e531a2d222bf9d48239dab435f6278ba85ba72ada3694d0add86852bcde62747c03da032f194a805ac59116e271d723401e378461ac680825f51a74fe62a88028e3fbbe19f3d2db7af98950bda3365362ddadda58d591342fb3b27d84dc3a54b854023addefb24a1bc225891a4ba1fe65f3cd10c165d0bff7ed46adbb196a93c625986a50949b4d4b778346a8b9953c30cd238e8aa4eab9ae1d85b6afa7710c533ce2b6397c2f3e7fdd9e3b95817d02b767d201a7196eccbbd1b177a73414799d5659586ca09008b5755a906a96d340c3b0522fc763f1a4867671e2fe6e45645c1253f6a69eb38916ecfc308cd5a4992eebb0d627a93e7e5daadd6fd610f869187468e3c0c0391a29809999057de01fdb07c8a1665298f48dabb38c5bdd932ba5567cfdcd0a009433362093d2e3dde96837a4a57c80992d51c3ea946e053435af70dffc7415059a80517feb43b1a0a9de3607ea06796088cbf81880128de697d388be8a7aa97d62d7eeb51b2b24cd6aacacc0fd71a5376becdc7f9020b4ff727015147a8ebd40ba1811999217f711a59c094175a4d5c4cd5ecc56cb3cf2c1ff3d1a4d1dcbda8a4fbd220b10e9e69f18d3c2b90577b97a7f9b62475bb703f0a0c63763229d342243927a167fc41a309f62efba3eec1390183ec0730c52a6c0eb41b48b25bfc5cc24e15b53c4c8d4dd5a0f79aa159d80cdfdba7a4fc69ffd9c7a9db325864b38c6f6bfc293099becda317d5c9ce145c6484419ebf6ae8b6ce930e440a4fa6792e09f8c9d773c93f5d1fbb76031508859896f5ddfd221e5e16e53fa8b4688b33f57ecc9ff51cfadc5198cacd533b7ed4c074e01656f714d58eb7ec5954bf9f2221f24dba8082c9fc3631ffd6643dd5b0371f62f9eb508492a2b6b8268670fde9a9b15f1e4ea0dea49bf3d7976a1a0f333eab723b4578779b8f2ba9cd1c9ce7da3b0daed955a56fd4bbe056db8578a14a3903885a949fd764bcf148764d2379bc1b76fc553968c7a7232c19b39a0a711726325234120f3f17f94dd3e23e4a8e85fb067fa6ad16fe14bdb89e0ac83a185b7c7911d0ae43ca50081ef8da5141d59ff6fb0cc0100b086f5617004ec76e159cee1c96197063dd44730792e6751f18e78fd28800ee21acec902161337a46a2165ee7adb47fca299856e27f700a805bd5710b7b739f6d07cd191a5405714cf009ef4f0b419d00116ddee8270b4858d72fdbbde3d344c6f17114d15d8c09056003184f41dab9446ad802e02f05ead7094197b7c02deee0b91fd77f898b0a2d3adacab4bf9efa70021f3f808ae590360fde66d26e5ccee94867dfcf2704eb4537b21f9d4ab721f799952b699e024d16027114b04557663924d165c0269a22e53377488ce89f869b913cbba369034bb2bea931edb030e9ae2de5d5b4efd6a9a3005c289cf94560543d7286e88fc24bff5d7b04fb32995ad6652dab3d654b7c4c7f235eecea93d81d0e41d599c3d4c68014d6e0af8846c95c0770b2da7dc59801a914d62ded07f5cf10a93a7aae4c9e31ec03253e66eeab4c9ef8e39f683d7a366c2f0b14c23c17620c97f9561de4936e932326baf0fbbee5405e18bf9d6ca4035c58e57f28d36fe8f33e2f434dc2d06bfd61c885c6802bfcf5f349ef5c60db1085b85a69e62a209849018e0887bbd934f506c04d0d2c92513ff675a7f4b70a28b025755f94d1a7c032f553314b04714083fa646341d41155526c8caadcd68a6b4dadb52c96da04eb5a6983206982199eede394d8f54f7ed6fdb0af35f99601755a03c4409f212d2525c35a1a9ecca283b3202bc544062b7e3fa5b6e569b03bd44c27f37e9e16dc7848cd3cce7c663c4d3e3c0b8283fa9d6df88cec518fa6c136ba1aab081d1ad2801c8bd413efba9f8d8f921081620194025b21629f24b812138f1f2ea805e3a254ef495c04fb4df34f11521996c69ea65201c570991565f68119248345d3f22500d62cab048f9f44cec833f48da9ce976fdee72322b54782d802add490fdac718e070e0f7e1faca7547552605acd0dd51cfd05bf0fd398440bd3d09a850ff3cbfdeec52bb4ede01f0ca20836ffebcd4ceb1cac73810483fa28d9a4661fd6ede864e5836e52836d1e915229317e21e955824d9319d4db6d61af50ccecff1395d72bd71fb36157225defa4d16fe74b29c5191cb2f7bfa11f02e4a256f6865d29f714ce9cd92af853c0245b71f5d9d23daabbe79c3a3c1a5f6af1541d70c23aded130c09ab60726399765df5cf121f7b0b7cafad974db9f92f23377601c259b5774e79322ade86f44c57987b8079b237230c8569afe86c3e8c49ab76560a319d65457838cbf6ff8378164302d79f817af7509473d6981d1990989a361eeace984bb74c905ed8236a146a1d39c1c8f987ff4b04bebdb3e9c745494392bb91bdacf659339fe7a90a2e374bb8fcecbf2433611a2de796dfc8c733d8f21b63518a47a6fa46ff01ce63c4e2b466bf817419678c1bbcc7e923c590484319062f6906f8d88a721858c95e132ca8712a5d596de9fcfb36ca21393ca032a4035a2f201276764e9decceabb3cc9d0abb443b71bde5d1c9ec8f8735711460e7a96450e28e8a0fe1c19340232f9ccf11488084cbf2c1a6dfe5436cf522b19bda475cea1104143fe91c217804a68d3952cdbf3fbd006686b50426889cd8de9524eb89451aca56e0e3a636d2abc7adf0614175aa47ba8b9e329e38179a51c6d37f36d29fe9c8fb9ae174a5553be12a2008c37fd049811ea7ebb486f9f4f9df99eadd8a5c31734eb6c091e68191e7b8f81a4dbf6aa5db22ef8c46f1721501676cfdd5bf750971a0c88bace72cd7f9cde8b34d74f454799fae4f122b08b894fc997b4217167bf8132a533a555649870fb0e4aad2f4a5c265f7e13540f87fcd5831d36e6660da951480c313416f0611f4473bc4503f41dd2ef4bc0cfbf78a82dbe7cbbc78060575d1b633b66b40f6f4da9c18b4dc4610933da2f25a6470502b60deb83dc7ab57f889236dc5f1bf0c03ae4a453b30b753d0c97d80cf0dc19fe761947890ee8baa408be6a068ac6de5c64b383c4024abbec43700cd218ddc9a9f48e447fe1d426211f4c4fa760f75ee77735271c2d7abe0e0dbe1443b2483fb7bf95d315af7cfc94695e41d8d7af50a1c62eb525e43e439687ad44077489ce878eedef316ad50e7e8d06cf4d55033ca5ff04ae9de918b7afbb856f560211aeccc0310961f9f8b44053cb76628f39ff714aa4a372a12ac2f1ad26fe8b9924d6ccecbe86421b97c70d8b94e364e5385827b248ea0701d0e12a88d175bd08bd28c273f814fb578ba45cd35f82a262b4a923653de1adbbc6541564c300f5e6bba8eb029c964406e99bd0a00a6839b7e25d6a22d1eadac2a787fcb2ed45a789ec207e0988c2e251f2d3f0a878dd5ffb759fc9a9eb02e7328cad0c3b8309099989431a37f13d3fcb5dfb0ed18461f18a2cce7b85b86693314123db2688ca3032792d8029ce916a9a9b955f96418af61fa64c894ce1140bc38844e388e91066f8e1b67589427b63c7e88094b4de97451872915cd200b0cb09ab822ad99fb7271dd31243b20fde9f08a159e7ddd78b300b6f8417fdc8cfb44f21579cf29afe6bc916d74a6be80b4bc5fa3badf5ab91dfd1698e916b35183f9a3113c50e480a2b700cdc67683aae9d65c584a5491dbfb22e36f5481b230cd0580ac471290b8b5f9c14edd70c9e97d94aa99875080a31a86f967b90f051a76e9068eb8d1d4f5f0c2d1617265c926ae45dec483fa95fb0f46a09051856b9cb188505c7085394b62115f5de8f25bf219a71b98a2ba03ea56e873079194cc552253981e074043da95a929bd7d80c915fd988662aa31cf294ad9029fcd08145dd2eef12fa292d995d742ff359c3bdf9fecbb4f4eae67a107c484f8191a7221c2c51506b53afc7a403daef8249d8a67d53582288f703493760e393ce153653ab1d","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
