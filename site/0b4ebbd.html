<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5813e95cb25a215421d778de9b7dfb6713920d7f4b7ce834f671a4b212bf0fb164a67077d64cd77bb8671eeb44d043299028b26b912fa10ca5ed35a3d3460b5be9f7f50bb751a5b2f19df39e78d46a4583ecf356039393727ef105355d638811f63d4d40831e7260bb6c7b2b4816cd051b17a6cc4e603498e4e90c11d33eaf01028fb371306a2a2e54d629286a3e3f19802ce3bcb4fd3e34cd02c2d6c76be46a6629ea6aee5dbab8f26956a8cb7b379d60db4f015fe138efd4dab8e3610d61ea12cdfb67ce3a826266519db885fe758bf8cd7fc24c80b218090229840a78c3313e24aa5688821be76669235d399fafdb3d3593894329552e1a71497b6967f8196c0aa0546bf40168b370926a99e18eeb7a03bce086f665aac96c9128a0b152db8862d33a0a834586f4db709bcb63b515ee5bfaf43f9b81a236f9670aa84944bcf250bb0cdb77dd6035019b493e4698c93c3c2a58db6b2bf050fad3b304af1ccba7ef2394e16e42b808bd0561eb561814eeabffcfb7bd5e64f24a27411f86bbc6a48578c432bd8aa48ead6880d5ca135b095ed7fb9543b1ed2ac440a1c5d63738b3e329b5448558b05a63b625710d6d6cbee9c22bdc49b0ffa0a64ef691220b3adb46d8ddb9f67de0695ab78562b3592dd075c72baeaeb2648248ea67b6974d12297a1e4e6b9aa3ce2f5f59be8b38572996d3893497d6e4cc4a0621d3943df356c562a8b6b2673f40150b2d59ac88066bc0035d90fd5b92f896b1173d19cc64fe4e79dfe411ea4e728411def046e05674f97c1f2aa7b613e09ff2cb897fe97829348a0fff659ecc5b341cfab7f7f8dd39fca97852b8de794cb01799d5cb390708d851be4dfe425508b8dbd43e5cfb1bde1621c4de6b7c9f8e582381ef53849e7cf3fb1be66ecf0fd5f431ad06037d5addc0f0f86da045884373a7645361740643a2b524a3c2af180399b3599c5b48f9ac64ed5defe7de1f7c7d7fcee64afe4833841fd01ba979ce33d732bf55a5a8d8b62ca8184b5cf03ff6f53f88c0e0524ba17f08c1b502ce5d43cd741de78c679a51f4162ccbb84135afe1ddc95083e59655a9a2786251404f652be530d8f1e21c3161bfe28b43de6af8cf9caf1dd9b9a551ca96b2375c9e3150e566dc7ad316fae5781203f96dfd32e163a802cf632bf6be07866ec3bc23385f4c2a43b617016d64bb08bbfd4eecc50184c92e7b98b92ec2e2c615066d8bb0b3560cfb6406c296aa1c2e91b347d6b181b3e98faa7e09be8989be2d9316b02d9485afd2d6a0c5b7fc991e1133ec0cee7c94b7fc2b393f44b0499426f6b123556ca0c2160d8fa7712479a874ae2ec8f562e461bfc415bbf9a61edbc205a4fcc6b42cadf0634676182d93572edc7cf3ae0d28c776f968ec372ab468f2c3674c659f95e820595a2cfd6bd22c3e48207aba3191b79394309b566503a924e0a4934730db03f5ee754b6bade9ddf5f89f3b7b6c983a460c9aa2f6faf78ff297fb55bc2b1e9f3941fcaa1794991ceb5d05710681eed9cf8276a6e1cca88a730ad38c2183959f60ac4ae8016c7ea1c9c6031d2a0b0a29f87f1e0651ab9164a378f69430a5b17a3bb23326b7c4637c5cf8b7b2618d498668b7c95ff6691cdd6e1e59cd37cfe34aa6412804b49fc70d8271489d0c4129c24f02ebf7ad45f3c3851f419fe45d7815d465c97f40d195d71612b567c5046ebe5fc54eb2eb9bce1728c09c541bbe8b1f6118dd1a46b1e66dace3a7993735115fd430e8e8a9380c4d573cd631c3097c2d634a41f676c82b009551bd7714f56e65f542d40aa3d1d7c49907ea00e6878e66bec50f5cef566e968a9e93438c8c2317e9036ce8a7baccbcae351fa9640cbe5b18cfeafd580274ded5a6696cf53ecdc604ca9ac2c69ee49e489c569b60dc93e8047b74d74fe257ea05d6bddd13f07c6cbfd47c1a821b0b45d693eb8f468ffbdb0b64db0e900f48de9f451a8f1329de50dfab62dd0c3be76727f4eac954a49ce4fd004e429e3c2d41d5f235c4ffb057d0d222438c8dd9fd8d703a0079300cdce7e3498e791c963595f75228f3714118fd5bbe4eb5dc7adaf49ffd100a4527af9aab65d786e68aca7c0b0bfe9e6b1eccfbead39b1791fa0a24bea5c5fc0ddb502f76c14ae36e870259c1a8948bbb7dbd207c359f8bc82ccc055ef7210e9cb561a95f5d0ddb204b1c02e8975da09b80e54ab684315200c7e19fdcca3c6335cdcccf95f376a071e3410e5d77c5f672f5d25b165ad99646de01b1ab02593de0abfebbc5b2959e81acdaf204574932fd73394d461920578b32c4b6b7f1a6f613a6b50550cf3c592282806edacab6df92ca964d7dc44d5673673e819fd83e6346d6a583ae696715adf1c20e6e02ca806a32536d7d5f24d8ac194fcf50ee484a02a0cdf0c8e4aa2b3d5015636ca711f2400ca9c2f1ae8eb193e8d52daf86d84227bc9a7b2dce405bdb8c1a50da53e7539acff3e326bed00cd080a7a80ee16b81d2d64a42f2b949515acc83ee7864bed21f27a2df1e8dd40d131c8b364f1b73ef5a0505962d6c63fc37021b2b4324efc9761c1b974ca289f0ad9ab1ec3e84b52187fa65f7df883a060c8df048951e9bb904ece16f1870897506f48e2de72b791ec9804cacbe3ae95c5b65c7b3e9f52fce12e96dd523a8b8876bf5a0e6fb15c32ae136a7bd37d8eaf2d65612af7161301a8e1e7a8c2ebe2c562b0e7384d6208badd594a7480013458920a7187dfffbd4aa2988954f514da034448f896d99e9518f78cc47f715f7172c17e83c3ee446d0ed1dc422e09cc8a53fcaa02ca74b1cd1111d9901efac8e4d4a32b14463b77bfe771eb0ebc55b6bdd13fa968b507cd19b8ccbff83525664fc5b3ae45ab9ea2577a1ccb6e73f7b08134a6bc7eddb4b3eb5a9ab79c88f9707b3575f637326a8b92e4734cdaf1cd53c511da89b533dc6a202bba3d4e89f24e09845248149313a586b3908d5d93e4337f6dfcb797ed01df2db39f211c804ff5aa005e18f0b42fa95314075a31aa3ab415f259f1dfdda55a18002cacabce691b988755620c5f09599bf5091cee42e8847c5d24a04b5a91335f0fbf5d27a001d01ef156e7b5709c087b301f396a330e580f88191f5c4b3262aa393d0f018dda4e3859d47fbeb5653d302195fc45a02d0b82c62dd6a27cc282dbd515146a7e8b34dc9f8a092645d5b5d70cba0369c373fa1abb85f7fd68fa367d2e67e00a7dfdb51d90f8749a2f8559751c7fcfd99689cd539acdf7c3e62001083abb9731a2b5755a76d691564ddec4781670fa7d224ea946850f4e45f0fc2b1e99e7e920dea72407dc1a30ac658783067f87e50eac412fe10208bc5a24ea1e53647328579d9cd50862c90ab68787e9b2f373274a3b579640299d669a87011edef84a17fb2dd1c9a00455d357cb1c298b5652788773cd7cedb6e5498d4d47a705498f49b72274ded52e4b0d30867b80edd2e730bdf2d97d513b9765d88a30895236118dad613b1c1acacd5747f1dec6a20c2ef76663d496f9c4d8cdb239d566eaa8b627a31327ded409cc9fe64ad95a0c98c73046a04c596286921decd77d90ef429fef765f4dbc6689428a9fcad99304a71ba3ff1f7e163613a09d28c1069c5b36810a4bac3a594b1552009eadddca7826db5116dc3ae289ffdee496e3517a53008c18acbea41798cb26bc4433a7f8f1bbdb8351da3fe794ad2d492b3b138e1488ceecd67b283ac1e97d36bba1ce4b526d52a2656a05cd23231b0cc4049e6f9d0fc6a4a99a0cef98e9c6808caa6557050aa28bdaa85f42007f6d64369a00e76437b9160733d306986a5e0a57e2d8599557f2f8a35b71e5f6f367ffc8b031b567545626e7f4c5e70194010360867e36f7c331d707a9223f00b6241e40a5ad81302109d0b9973a7518e381a50250049a006ad4dd60fcb5702bf21ae6b83c0883d00e47f4d945dfbeea901089a937d5e26fb252e6ad3f45035297b3c84f247a12e232debe148bad7641078237494fb4b37d66830c07eb616f14916933cd1176e9d40298078eba1bd2deff6e8044fe2658ce8306f58e6638dfb6878f39d4cab589d39ef8e0535754e4fe6eca74f2cf4838e037448a437a9c5fff2ed0806f5e842b5950f426a5f9c4896ffbf26eedc4c00faf6ca22289baae1c807a205463a04050bf6e8f49ec340c1d6242968ed3fdfa51519456765adb94ee44561940adeac844576f7776a00401a7da5e5cb2cdb2aa1c5f6781c19fc4fba875f35b4fc877ebc383348c0bd2e5b06f22203d618da3e826dc5edeb4fdee0c750a77fce43b98c7e44f5cfd463f157c7f811df5d67882352e6f8698fbd89daa4f81b42153c14135490f01ad9c9d5626e4d0330f7b5c01fb025d18e08015bde2786bb84c54c19f6a2ce99ae2877efbc448054834b18dee452b763f52b9dbffdb063f1b169d92958e6cdbca68055a67d78c5a6a6b0235b18cef1ded1d03034a38e2da5353f533a0aa5b3cf8a205a85c47d4e0db6f7d2443a2fe975be3013f87dfc26a3604011a4d98daae3ae96a8863618bd46296b82d9a42227603e0cb6ef0dbae7551a9fb4d562e374b6454f843954419b62b68853fe0228faae889bd129011e0be299085e60cd7cddba3e3743cc8c2f85dd6a5fce20acf50288d48091c5d43aca3a4f314b7c4c1aeeceaf3e645c603d734ea57102337163f8f562ea38ea7640a7d5cfb80c7e24fd3a0b0da3b8e72e8b9d84075539d5142be32f5a371383635df8fd99634356b09891f1c4ef987e09982184ee911f93509e916c3efd06f8bd4e4bfec78fb45903700fb282a4ad8e114d4f9f20b12b1da751b5640e4259a70b111709ab4179f1ba85d88169c3e8295d13736f3df8a6bc246d2c119c3ccdc358c72a9df2f471ba1c2df8e765e9e623148c321400ba1b7a1c192a63310c8aa2393cc28f71682f7dc6397ba8dc81ae26b513f6d25b310f13cfa1879bdb403ca6ac02635be9a9a3ab9eae7ba1612fc29c5826d3d078b0b2616e50831dd12ffcc60c0776e1dabf5cf6ffc16ecbd32a0987a8d948f73356fc4e42fb0aca22d89e03c4ae1a473144120a734fc6ea18387813b128665e4644d0c35a5c55a6d9470b74d7a4b8216dadd36930c9179f8211a1dcc802a0b4de162b6287a271b6409537bbb9f9b908c2d71e17195beffa4738780e9fea0f61ff91d7c37e58266599bfbd3fc5a0535c7b31fd15abe6b8838e0c1863c5ff186e68d10fb45c3d7a9be51546f935d805f8945969f183480debc15d07a385f1fb2c539d30fe0964fedcb0826cb25463ed56d62f9efe8625a6132b407145fd11b4a9b86503dd3b1b32e4331cca9d444decac9c9249c424d5ae531925b9cf77a4c4c4fdf773eb31144850d557c297886fc5ed0af9d91eb0f9b75c6d17ac12f2200dc6eb60e12700ee67832a2693a7c0af76f33efe98f2b77b14c867494432928efcc2fb9fa4ecaa1d1a5d841dc75d279f975a7e247868d4407c60ec70a41ae90a0290e16743eac0b8678ce59c6a7d74f998f43df3f6584cb1ab3f33bc6dfb7cbbe178200ab76976f2c71eedf56d8b03e6a86923d977d90514f4367e0ff081b081b9d271ca8fa577e952051befac77b9f738b92a21a5908df39b0dbd502dfea523b51f915fa3677d0abe0c0658e57e74a7720c08431a66aff6c3e9d9bc609c0f9408d034a72d6cc82a9bd8563ba45cfee46949d173299dcada18ddadce64576b5c75de55d0e01ac205cde59a4f2b34135bdfa74c968bafbaad735b27e020ee17b4c88ee076e00fb35874d7e2bcfe58d2de8fff43e527a07e1e84c9b584dc5b57c95dcc9575ce8ec17df3d44e7034a9a9fa115de9e6ae056e5a8e2ee3ae4181093490a00e98e581a42c001654340763234054db11efb1badecdb07d20d7748b05c6b36164d02c0247becb270082da6bd1fc6a7c07e65d3d9ada9eb484aa816953bd761e18c43e5ba5efc168d125f89b326e02a3355722c3a0091d560fe6827d85e097ba619abaf773d81e70df07f43b8b90b8ccd183d7e8f0cd918b46f35ce65e220a146329b0286f0c1fa118d2d41217859ba1255052f6881b6090d882e926f12a3eef7d8e8af5855d0c80230d500909983594783acb068bb0e6c2e03afe84139e2f5d79e886a56d1c8b73000a3de1959423e8ddfe9796129716546ba9fc5370c96de96df6498f5bef3d6980905ae5c8cb344c642f548f68947e226102aae1f865557149f1378e8948d259f2cc13f9c2676a0bf52347c67f9f385210f7cb9f58493d8642a9fba613de7de877491162fd0fe02acdbe3571be4983a38e4bd75768fbf3dbe8863819736433c7982953ccdec26f726e66a797fb62ee606b2feb41f592250b6a08ed50bd3e06dc8cd7b21a304686d7711b5ffa8d840e8a95d1a6a5a4e0bf315da185e71245812d1e274c73cecf2a0b37716d6ed56f2b0452db793044619c41bd693f12668e696e6078c68aa9e81557e83b639dab99f59784cb2eb463a5a2d74a9912a0d69f4765ae1fcf150b471985adbd0f675fbc2d31fcfdc36f19ad2224d49dc037a19dce042afc2461177521af619158620224d5af35a3eaac28f8ce68fc425c66bd10ab82a39abe28ac38b46418b95ce4866bac8fe945a3eadc8c71d0d9f7afa30b5a9643b840595ff9ef1f63789122d986a691c514358a3f9b789c586a22c180fe55cd805e7b507d02e37829ce80d1de2d02dad0f7e85cc6e8c789281d4425a1ed3aa70494ba693091be57487bb4b6b12df3e904fffb899435eb35c97a71a40a1badf5a7e8a1ade74aa6584e9491b1f53d982e62c2440059a2973beb7188acccde788cfadb53b3749418f87102b5bc6ff79047052b29f18f2e0f7dbb1918a5ee8dc928cbb1bed7dadfbfeb66b0e84f32b04f57bceee418f3b22dc5844242c74dc4e94854c2c52ae19eb1ae096e4d1ef5d553e881e1d802571eec96037ebeaf9ced4d33d4b1f0649e39ce66054162d426fa41b1a469f636c553e4951d60924723ab85595ec28c356c9f152f61d0605036cb9cacb2bab038ad2b7ad65d21521ab37c4dc26e3f6956b542461ab60bd52a2379e4afcd4f0d82455fcb14692bb2a276ba8c92f68fa617c56a52798d29e1ed73868dee69446a736670ec8ecfad1a3d3f90875f56772603e6bce688fb1a6d19f9e4acb7146604e970b8bb39e24f6643b0351cc006ede759b32bac9a576e9019f3e4fed44aa68a66a7efadcc3acd0ef7858b121391bcc4c60e3cd64c3ccbae4da8e9672994aad7b5e65f45bddc07d77bdfb9ad01a06bb5e9eca3f18cc9490eef78985039de5bcaefde8ddb5c2bb0be82c0c383d6a681a2e547496120776c5c5722a15b18023058acf126a3093351eec20d382e7a403898e2d196ced04bf2f9d5e848a5c52e226f0130da807277c22d5f624362097995dc6eb206531165cc13a5dabb9cc6a2b053dd76cc97acb27b58d6e79c3f37fd7cf530a6ba8db722b0cbcca4830f6cf4434b0fcea0287f5ce7adccdae741ea480048db551c24803f66054846d137e3fbd7a574d8ce4d5cad911bcf8490d5abdef65881884e26af699d59ebd98ecb15a8c60838b8f30e0f2cc39e697fa5c340c27f112d2317ea6e90e70860127440a354665877c07b4e0e4a6737e5cf7c12796c7c95343c1b838848a66a02c2a31f5ae85b6b00af57bb5e4a2ce63ea9f842435c7a1c17967eff8b17f80ddf02476281576062ec9b9eca89f0c7fd172271efed0ac24e9857fc61f31b18769b4918389603cfb9b08b52d157f39b0501dc4e2c707982488c80228425bd002a9a9f6bd055a535167607479b7611698954b6135118d97c1e120449eeed9ddbcae439f6d9ef2c4ab17cd89b773d5d24fd286d1bebe0c7f0e4317f16171761958702d425b4aaa631ad1cdd00bac4861ee678fccc6f9348a380cacf7fbc43dfde97cb794d813575b5461d884d25b28d2159e9097826d7177dd9224d697ba36e5131ab7aff718a49235f15bcf8b2749dd757574a37bc92059f9be020cac7f2e438d2eacd07a7d044ad669879bc2c8612bb0143a75f9cb9b39d4c0c568d636f457493037b685c6924f4bae458f18bae628fe296248d2d75962eb229e65cb168acca1928ec53447fbdadecafe183db037a7080d26fd78da083ba8627dbc8b870ad2e836fba9d07f57796c34168d5345545b09ba712265650e694ff91528572b7e24f1d2c1cb3b16174b2335434c5542f289e1802eccfb36e189e14a2d006d1103b5b221d6cc27db18a3b4bb0ab248f2a4ec83cbe31cb6f8d25b5eb9da1061d6504392f8446f3d29e5c9a259b94f4187d3ade4912966330d228b727a945bc18d0d3409cd0455857912146204a63782f3bbfcc3f1d07a447c05e25d1287fcc6636c8d1eaac8fb26ad3dba23612e77699cad84a35f652b589afc943e6c3cb26bbcaa17551a2a11aad05262a69da21dfcfae847201f7e5976dab71bbf64edcffe59774bd440686f3e76f51b897349eb11f93842808ceb53b4d5a7efe6b118a0208133a0d5dc2a49367016f3186d60d7cf84ee8d83ac345aaa4ddcc183899edf45ae9cafafcd19b826bce72f3d097cceb33f13408beaa0cb9857e99610682ed71f250342321ccfa2ceb1a3e708f0a0f17d2bf5d9b8bcb7fac4d781ed2d1ea0acfb09eac49d8529e7add815fd0340ef00550ff4445232c98fe08da8eff5b70640e9e0c36fce250ff11072247bdce8c7447f661e6b198d23013a7ca1758cb8f4e09f928f8fee8bfe4ac50741e845d15d8ecdc0f0d4756ad09c040bce180ea8abd205e53c05d11b8e2dc81a0720e1992e42b452f58272e60d1cbad57591420851cc4dab7a9b8d0df12ecd03a40aee5fd9251768235f762e68a2a56c92fd6a557bf078637a0aba9170cfdc8d53234d5caee8c363b357da9ab2f2a8667ec68c4e0d50d7062feb40b58d03906b4b7b669b1236ff7e56c7bdfa23fd8eef3c368d0cd3698048afcbe2e7af46e13d210439ff50c4c7f34acef71de3aad30342dbed2c18b5314af8447e2701d75e84830750fe39a25e55ef9eb4ce7d6b2d5f54d9b5ad191fa8627efb2006db2b6cff1109c88f80ea046c26ae8207d30b5cb98c6ad033e3f63a01deb4d2d595e2c0b280fa7aee51cb9857b16bcdfeb65fad90e9020d8b8e4b8378015442f9e2b94b0cb6df21a7b4e50443617b3769946ac0b742483a723eae8cb5aca0270d7fa788f98e0b9a2591c6c96836eda7bec2006ce4f153a05efea9f31c6bfd0b71a5ca0a679323317f6a92414b857fcff17b003e5316e46e24759013eaf88b9aa8b9fee203ad2cd7429793b841ada37fe9c000eb4fd45a93e50655e573e2aeaf462a348f5a22a02cfdc2926b3d227a727aa5935a3eadeb5970716ed9dfd6588eaf8ea28e06ea06479b06fc78060f70e9ecc222b6bd423920e17a248c561206d24e68bd61b1790dfb028e6d640f83f8991023a4464e154dce39cb24decaa939f7fde10ea0ec9d05dcf6c51bf3d93f2e0e3608345dcaea217ead42e442fff8fde9818985f4b7bf160f637f668a38ea70dbac38ad487e96fd52887e2ca871f45dc334eb6681b6b968627d72b07948bcee2da260362e1fa6f023005e5a2b65c9731ea21ff4c94e03406c56d7bdc16397163202d1acf4bba9084b0e19326236a8684ece30fec0472ad75f03c399fbf2b9c1fdf730b4982c7aa79eddaaa725abe909b5de28dbfb513e09b4bbb065571a64b1da84e575e937bad851a5b09a50145082b079fa6c42a4120d7c1a6092c2881901d90ec2458f55d96b630476b2cfecd78460229b4564b360e5eb15d8c1ec4df4ea60e2ac6f87b4e27193a1a3231819ca022ce00f27897c7a2a4b7b40e597d5fea96d23c41f017d825c18d2e09350b05a3611b5a0dd5b805207f9ff35574a097332b168e5984b888b9434e6d4221d4cb198dd0272af35675c566c0b89df8103216e40060132d5ab3f5162310501ac4589112fef35a58d14532f6dad3d8e5eae540c387b7a45a609b80c42473ceff7cd9622044e634192c1a4ef28f94c607542c14804028430fefab66849007ba9ea472ddc73f68333acba02b205e3caeb2dd356f3d009cccfb5add5b13ec72342cdc7d6d2d0e398e8ef880d376440317b62d31ee3f3d5ecde55eb6223cf92b29236f5c14add4fd089c672040f29839bce70dd03bfb5e415b6b4d3f8caa0b3e12f0541cfe8d852a52db422c3a8fe91d30da6b91c24c784f7471b082b46b61ad6b141367af73a659b32651e09393970af55fa46c3e12a30b52d5d70538fb6e16b63aa610e5174ac5ee46cd8b599eb8066f16d9797dd2deed40867671fe670bf5f1f30c352cab33d6f3fca38ad79fdd0c7ff12ae8f6642446e9a34d8eb29ce6a1686599c3abeee62de96ca5b0d22d15357def6129a71460982a9a7b45f20427f14f33ecf3fbadb7dd4bfb79a0479d5a6ced551373b6975f04314073426caa07b2b7f980638442b5545fc480a6afc11a508a47d85a74ad2fce644d1c2380b9d79e06e395e5bf869fbace3bef55e887dfb5326bdfdb958f48587759f856206a690d55ea947fcee4f5ad05ed2d37d627a94e0d0c7356b4012039654e7f3e212dbdf7ef9f2ef7aae7d38d1671f271872741e4f2b2a49cc5dea4df9c72a283e74eda5bdb44e1695165980f04a8616665ae29b69a42257566b6e600b083e669dc1cba1fe549d878ffc2796f23f388a8026fa6ae6d687639916234629c948f9dddf81c20ba8665f100849ac9dd10ea51d285038f5329b48a0ebb4d99e5ac16a9be7aa6dfbf329f3d12a50b523a8f27d70eb03548d7bca68142a1bff836b93b68faec700ff0fc82f9e155260372b90460c1478ef1dba547437410884c412b5bab9ca9021f446cdaac3f0269917766c9b7a2ab2efc60fe97955a29248ccad09d9eacc93d49559440d6c0c12972428be5aa5c5e0901ff99893b3c37df7197a9fb8b3e8a6d124d1f73121012b2b3dade96936c8baa921f0222cd292694234b18fd8bf7751cd7a8204f9349c4ed01966b6d29c421cbc8364b9e778d8254ea20289fe31fb6e497683c26621cb68203a4f60aaf36e4376fde81b5c855ae13e69f2b13d59bc896e9fe1f72eda641cc6a61063c64d31a9a741a53ee94f154d03a7fa4595ebc13372d4b89d5f3bbd46a358002ea68ff44de8dbb9b2def79bef9e899fb5764a084b5b1633150714d1d49754662e04b4899fa08d0b6de9f46ed959ab9dcc8938adfd722d60303191bcf5e4b32ff4c505ed882a474154d7fa70c89f1bc2d3532872845cd9b4bbd773c40759e722c8cb344b185a067d13d4f96a366370ec922105908f7fc174f8a46157a27e0ba155fb306ff47a0127cbab09e87eea8f7ab7be28ed6a5b1410544dbc0810a90e7275d3d78c8844f414c4236693993fdd303920c240e11617ce567842960385922667e49695af417b5bcfa44eb7e54538eb1f238ab36d092d4db7e1b9c2c74ca539091db923becf5ccfb43842235c38c8f78547a56574eaa91c737ff80a4d828834c5aef46a253281829933a0310c223e034efbca2acbf05766c3ad01bdc9c1e4c9347a49709bc8d720dd0e25ef785a51608784df116fc8bba0ad0c9cfc450807cee4277530bad38241014b73c187af363d2ff65950f58aaa7bcdb03e8c4be2d53898336b54eef70348b8f1fbea882868f674fc986ac094a6ff65b082a78c720f79eba381e2a830554cf5c8c6b2f716d9cb8f9a7c15a9c1634cd46203046dbab5423e3039e2b6c10df33b0b4115b5315f81f8c7697fdae50a5e935f58a32ee3e7c2e56c832603e98b0647032ca88e9d5accc16f2ad041e9e04d5a3f43bb4e5723fded9686d8eed17bb2b9e110671447b00dde88ea726ed880789a01d1d6f7821944805b55bb01779068cd5e4cda9808505b89644a58f8cfccce3a202c265609484602a6941f831f89934c8ed6f6ff67f938fbee025c3ea2eb74d86ca925a8b00e43c572822c0e0670ae9b0cb337896a348523fc90cc307fff511236a4e28aedb0fbf0445507de720f35145b73bd38df25b2a1c8057ce6dfdf684bf9d793dbd94bb35f4c6685880bbb3bba69e1081d9cba264cf6916ca28af457c238158f41caae67d900f631bd87e1d4549fe33bc01f4c0ed7df61cd2b5b298d455e0a9419930d3635cecc0f982605c5bc5b5d9a88a8628b045e18bb2ba443f7d2761dad7e151f8009fd96780cb4249cd72aa831fcd89dde5d28f114ab4da7a3e06dffab6d438420e27fa617f0872090bc474a8ef16cb91e7cf8f8d8cdaa17329d42728f170b5e89003f660ff5fc72b100fddd95055142b10d742147c33b599baa0f690ef23d7f294c3968a5eb4884f1e3cbe5e570e7588e4953e3d68d4b498cbc5b4d1dac0e9004dbd922d1c4a5d0eafa7e19ec3425e5a5e09631c35dea454e6ba2cc7dd5e22557bab5f96444af790803dacd5f6813b4b3da1d5fbeedadb2ade348259a25cc3aa04527e8acc2b29e3114577ad15de387b086662dbfab9204067d77d5d6db338735eac571270a0c958565040972e34a05e3e3fbd9698f2e21b519e1b4271828b02096278c334d5bb305980e2e71312c6e63fb6e075485aaed34ebe7ee41980ac2a7eaf2117abb9e22be804f0263c7c043eb6d07610bacaf89898687de3c20a221ff9a6c55c27f277d7436c506946150de2fd26997f4f07f28e7e2de1c2e886bc4a8ef9e3ce1e7034f14157a5b5a879529352cd0b7a27d536b61f9e613e7050018ad7f28a71d71e8dca5e763070919646bd596f77e89638cb8211d01c5774fef372dbb3db08f64efa850ebe297188f354bd776d1b6298ed2babd07b8dcdf7bb710e06db57536f9903c186fcefaf17a51777ed7c536b0e25b2a6858a424b81f4f279397d2da917e1ce8bce76ce40ed7cd348b8379bcb54de5f3888f92e686586ff7103bbe3410af57288f2287b0946d3facbb4cf82c662e6100142909c9794e5bd3f88598cc9ee5093145846ac92017b5f683c147a2c7416a9b01ab805215cf0128b332a4d05a6da931599418600d4ac345530a5bed5f401b7e91f520543b7fd11e3c811dc51f213cd07b20730cdee5c5d8d69ca81ef7c7eb5b58df57816fa20255b4321f54f390c130d78eb4b93c8481367b569b66d7bbed9902adf8fafa476f83c7981c2a74cf140b0594609ed7e4c2b17d005514b6e693a8367c0f985912bbbbeecf856113b849be1309b4daecd259dfc0814cbf04ef37f178a71bb0c7afba92715e255d9a82abd71b070759236014d45d9e910b790b8b55643b7c07a25458ea88db7fe36da2f1abcfc5304a0376642c19c73da88f4f67cd87d0c94c75c1abe87cc785f00615c6e3fc9b80e1eb80ad7672fbb3d8e909cdd3dc9c335306c3fa63d6baacac6b64e18da33674be48b47b39b008a68164f9663368b3361c922e48acafc64ceb0438e78bc5b2d777f70d7eea14a3dfc619ca5031643d55d72d71057390666f88e8565decdb43c9a61061ee5bc619c07643bb0560773845fffd612cbdb2229b50c2754575ff2b58c94f45c077ec12caa79622157a4cb30bca0c4f380ee00d4ffd03afae320e984329cd53d7c3ca5d00aafc8a8d863d0d82754caae66ea4694511a848bf89af8c183f9b6371981fc09a1a9d3e08148f01828e198a7848869e19cba8279f45a93f010d8c28f13c4ecf46a268d14803100981900ce3e6e19795286092a128ab1a27d385d164c20382c8c70ae8ce73af34b710c4ffa1a84e8e553cbf4cdd26598aef422c2e8ca32a1dbedf03a39119dbc3f3967abb5475e1454eb166fcd920201224d62e7ec9fec8b9e09f84e0d68d3807b0ae9f59d56e2897b600e9e2e33a407698a0c5a6f3e040fabf17680ba2ff9f8cdda1fa8c36e4dbfb4afb4827efceb59a90a2cc8fd1b9502a0c857715040def99cdb3fabafe669a20b483c0fa8cf686b946d10317c6729a2015f2cf53aa4b42432a597e49621617d832cd1cf6b2addf6ab35d5223dec5a013a4f88765f9bf1d2419677adac054f5f522545f901306a9522c483aa97925efa55deae4ece0bf3b4a39c1403f52df1e1992cff28b0ebba3715b31d7fb58570244018d5c11821f9a23abc8d3ec21c2abdec9829aa9f3bae30c0569744d5e391bba4d6a5462a9d72b4a3bb30e235e662107a77b23f34408ea91c6ad5adfd3b725fe19b34d38d5e6b57546703aa95d83e670435b950e2fd15deb08160de9b9b6831f7d992c94b667c991479cffa3e3faa36e62e664ae35a7939e972d15d4c1f2841278a7a822e456404e3fd179fb4449f6415ddb65606cdf3d3613a6c6bd88b36dd06ad96661a9384854916c895c6eaf96be444f1dc20b093d8d4305b7cb6f844862452c7d13b168a17b0eeac8436b2798628f7fb36b9ba87b9ec03d71df5c88c43eef615024e1317fd814e48ed6ee4b4f73b74c0c328c9309b1e55bf8476f59fecb1b4d0c3764cc42aa0f37a8f731067da9bf50dacbd3cf7adb4fb1d48de5b9d4e0c376093786a7236320129d9186d7a7d0c9d32a81a27a71aef592165d82a3d8f23ea7d04fa88a755b0c3551ffd1a8da253962655c3df5d3c477acb94d0a862028c0432cda47adc5ffc2255d86e4ce3e47249b269656f63ac10a3a5038028f2d9c350bd6472b15d4ca55bb8a6076f5e2d68bbdafcdfd725142e1b6ed804f7790674f9f54c86db6e1a5f93041397b5f15866ff688313824c3185396503b894b1742add1606b4990784eae813dd843f523d59ce97c4b089c317f77fb32fecac8989985a324f575a70cecf59e84260e1e6fceb1cb62a5fd991c0857ee1c0a9684061c80af6ee25985a010bd244fbea8696542b77eb3e371c4372927d97256f79d9406492505ad653317a3c7155f2b3f76ce59b53d646b76f74f2c03ea1c666cde93529039df09ca9629ccfb523198f5cb6c87b369e64b3059f42de84858c8886e517b522dd336e3b3132fa22f707e1cf7e071a2f60acdd93c5a59405cabbc6f0c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
