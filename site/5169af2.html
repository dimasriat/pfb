<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd4e36fddd1fd00763d622af15aecf37ac760a98bb8462e5ff168bc209bf333da25ade8a414e06a49157cbe416e068c31a8a8516d8319b05fd07955ae290ba261b46d0f2b7838798501004e3fa2be0fb80a93f7825d1ee1e6b1eab8e76b929fd4a65b2a822748fb01fbcf76a448c8598ab7ac53b91c79821ba0c96d342507602f986cb0dd5655e3b2914793fab79d5570ca653200b73b3d632b84fef97995c0f8e7a26201d2ea6c83801f4fc9c2a71cf21a6eacaf9cb0fc298bb989aee28ca1ee0a322edd2690bd1f4ee9015a70d329e0651d49cdc102bd968aa41914fc1eff830d72ccb8acaa91e86b32269f913dd11a09a158fbb31528cf5fe293a7e82433d012f7fc89642f3264e083faf6aa18727f39a1f0afc4d65023d3ac6df3714698e63d412b97521e5679a5b9e618d3350feeaf44048785c28c659f4966aff40f5ebff4990e805fd887b6e86ff4ef402a1b64f1b411acf6683d628639b9348eb6e75919318f029c7542b17f8b7e92272e1755712f45079a8da6eea3514284ca14a186e44376df21af6f2e47840a2a9ce8feabc3327e18f2c2dd1d0d4ebd34544796e54e16ea7bb91853b47fce14a7bf78bc2a9077c0cc2d7394fac025e6697a62ec9928badad39e692c20f5f34c6e0280c57c13f42b9761dc898461de83d08565b10be39347ac9a42a49f8066a7edeb0caf0dfd038cce1ba9b0d148f19ba0c3cb2590be1448bbd6ed38423c3e72232093b0d3e5938ae12a88d0f7b97d171fd3272e115fb0da6337f2a1c01f4c34e61dcfba63133cc9de04d6eba333d14c85d8bf0b2121245589ddd4d1dca9d125fc6c6cd18d6ba122938289785b768780971ccc3212d14234ff454155e5430b8637b334f3a5593a0cf1175e89b476aaa9a7e7971af263ef218287fb54422aeac2b169340c7ef21d6b7f849037fa65a9514480bf15b83fd2dc926f8aad597a2a512aa443312e77572677455b766dbe36395f8a678df37c382491a44cf378e19ba58b87db35126761be47d5d39a3d08ee5d3bc52f6e9685dc4df680e2601085fe100485135ef557b6bbbca2000d03785798b8259a157bcd3ace8e35cea097940487d87478a10e9dce0a579bdd047a61ee5a1f624a5d60e1d665191280a0aed993641659171d8fc1647b3b4b90524a6b4cce9963702439c0c2a8e61992ee4440f864c98c92b061d30341d090570704d8f152b3927b9a89d90e70f80878bbe039ccc33eb00144b590b92e2a5f569a13e9897252ffb4cda2967020a5f25c83c727d258644b32eb1321e9f851fcd1a5a3b21d11c7becb881dcb4c30d5531a8f4d9db8c0f97605b59521a0298afd0a4cd6fbe87a8bdcf707723242324a32bbb7f1cc36627a4e94956db1057632a98a8a4b15dafce9263b6e167c7b1bf7dbe0c118aaea9efc9bf99b35377010b20a017f6a13f214c9b6e56607cf8012dec87646b69caf903a70cef21d3604ee30265d22aab26bd572183001951c3ffe60a097ac923934dad7691167d35a0619333658d5d9e3406ef0058793feaecc4565f58798d582f9fcdd1e4fab58a27785ee4c783d97eb353a70c4aed1cd43bbb4f987868da81a5598930dd6beb509bc8da425b1027bed28413c377756492f6c84ba62be5e36480cda234838ff7f69360e3c2ac5c3d7dfec556f5942594a6fea688b05de695ba5bda98890aa12e166c348038cf61cd3ae31be3fc2f7a98a2d321636442f14447deec1c0c409c03f0882422d889a6776290539a2f4ae5215016ea920f94697d88118894eb3f858912296c89db6d3940aad9de3d1caa130b201d1bff5b5a0f50b1eedbfd21ae3046cdd7a182b4f34b7d6766bd3faa469f609a4dba2f8fe178496c55b4693fdab59707cd471944c861a83fe651ce230f8d6dd4f0d595bd9652ecd830f8a42e8398ea53488b8960f2634bc80b261fb29c97f67760b9d3ecea89f5e2b5b52f32459d612e0cb0186956d14a78bc985464a96cf7908a6e98ed99f6c4c8eec55873282de2d156f1188c86c2fa661771320b2b18bef66b18fcfdfee2dc963ef72ade4148627914cfcbea9fd9be893b313d755cbb37178083abdba84297d18e080ddc21f18c7265426d6ac4aee3cbe8154bfb8730a99bde115b36cedc0ee5a1e4c4a497c3d21dfb95ab8c4b5cf97ac86aa08b8a8829931e89e708da8ea70b1c4617a3917b3b4eedd59b586c34009dbbcf04bce9bafbc639b9da899ced17e25fc2e9b7d00f4e8365fb469b503d6ab20c63be15f5c5366fb2250df034eb7fa29f9e39869d9ac95d377aa9bf601d32f769bda7911365a1fb3c63bb6834e799521257870a7ce51a91548823aaa9e2f5bf8306ce91b213f392e802c0e3a5483a724d243ace51e046eccdce56a65949bf57067a593f877c764c9088b8a33c9b093557292ecbbb567645e516d4a3faf54a4b98c0021d46bf09f3aef6f6c0b4c1871afed81818d35bc72b1350c18cb8d7013a1000fa0c06304c7cdb37cbeb30dd9c47e64f01a42f9e6ffbc580acdde17fefe239890c69fff8cc179baaee4fd971b123c19b00ef3047a9ad524793daff22bbe9cb812aefdb058fbb065a0f944b24b9c9581261e1435828b5b3c53387ea216e24746af74600488d74dfe300dffe47b457235cbf8d09874445d0212eb3789ac942a17a16a57eee7bc2e051e5ccb404ecadb479d375a2b5d3d623ef584df92a477c4043249c0705a49b8771da012fdf54a2b66a5a009d8313c70b2416d3322d61887b437cfd31912f78f2e1b4b1a661936b785916ff646e4849e678b5b858079ec9372559f30060b7cf0f7de2f456389c46dc637af2e536b4c4c2c69abc2ca2e773d2b008c6c62aa17d9e3566efed010a01dd896b88bedbc218dc37ce0a673b7b36acb8df9a9743b57fdf946a51fe1c50f71cd8e2f345de8aa6c26a1ceb9e91316569ba6d820494779adf160a8bc2287f0d2581c4d2f73201729be5c3c693a81f1f1c89fab578a1e47354f977092b4000c2c396b01ea82c629da844da881873f98aef37e3d838fc7169eac2045fc7bc5c83e74547cd3f20998157231c7d6508d18296501c252ce1d9549d2f5dd26d00790e56ee93d802f04715798e4e6159b5dcae2ae2a5e081a960a13b7a6eb6d511be3585b1a032be1ed840665bb7ba3e51b18947b168df610c2b2162722b2d707da3d437046e82cbcbdce078027cb7c9c3e8f7597f7a7bc7dcdd761a2e2cbf7221dfcaa5110f1a58fd2f79b2b80e76671e317136080cd5dcc5fc42e38af34e42734d8041554f819683adaaa8a52b1c4eae53a71bf63c8c5bc0c951c1e7e3c6bd6b81b7947e3c63af3c294ec7c3bfbffff807159e7dda1f9b379ac751ec867644b1576c00e6689292d810c202437e9b8160e6a508d03df0a71eb6fcc26f2755f005dfe358ef86d0b8604cf4aa257c9f7db0b37f38fe3d297bfcf00dfd6ec8b2c7c4e469b2f7dbe1baa4c9d3cca0a58230fdd82070b8d40d5b7503855faa52c5288959f4e941d9f2880a9299f3032cb782f31622bf4e4ed0573ab586dd8ae00f8b4b54392e85d1b7781887b5e02e4fc4f886fa956519ab742da967d781776f38bb9e8f33c395aa54e97c7808b41b0651263dd85e4172ca4fc77fad1d7ab8eb4fcd2b22fdf38aab15a1f50377f784cfa70680ebe0f0a91465c69222dc5861a7ac9b32dde4bc5c2a66e0281a32bf778ee98fd3c28bb7132a11e958d815df813e1b842365065a45f48729d885524984bac89dd47cc14a37bfa6735a3d482081d04dd74e34955726cfc1b1e050df7276dfa13d8ad0eb74f6d3c0906e4f8bf01b5240e8823bf6ed6268cf63e0e4fc74ab0b6540239c5a5b294baae813d9cb5d02bdfbe971c2863a35e4345b6c1cc86b1c7a69b082048ddae7673d030c3ff50603d0f33835fc008e08bbaa4776cacc7c1ecb3a19a9e9018b26d53440a3efb1538bf9e88cd79545825fb8194e03bc08a9bcf44bf3ec71f029c311261dddd3cfb65514cf0961a692d40e532a600f2b160e25461df4d9386f6cc01e425812edd1bf0e8cfc94543dd20bfda3bee024fa0db64ed7b9e8f2d1d6c958408832ba61bc51ba5bc1e8659ef3faab277611475b4de896409c8d7c79c0c85c8db0b68152fd58b777c3c1498f87f3ef1513b7bd736dbcf24aa72de19e1d192c33a71fdc4d0a952950920520c3be23597279eb0311b34540ad37091c68802b3b9dcce6b5edadae10bcb77fd498797b40d7bfc1c82686d4586d2bef764bdae5130635905461d173802033892259a397841eae82372761ab5f9eb010fe7427578c34960d56ddc8e08cbc9cf0133c34b203f3abf2088dc9cfe6176e986a6072ffd0f47b82fdc3de8bed0f8b2f5665b00efe3e90f507d73658824bdc57f7028c01910a306d0a8137b97e2d8c1e6e0ecec5e1d98eee8e7ebc27432a819706a22604ad422ce9dc4a1b3c2c4b2bd2dae56cd0304307b9385bf83a13c9ea7a1ad8e1b7c65ca9baddbf7c1f1f963270856fb537bdcb3313ffa7918e98b7ab0e163d5ed8f36c51c7a357e46dfb0e7505d9ce4e3a826d77a809992e6f0bd27208043ce7e08ec91c7d0e109bf4e871210838ba89b749449462dc9f2585d543a4091efafce6b08796e97690fb65bbf547f1fc7e0947352a15e3568ba8d40edf7527bcf6d01cb11491a0f1209fa1c5341261bdca8dee882d46fb49f0e2881afef9cc6c90ecec6bf0c06c70cf903abf0e7ca506b2bc6bef7975566ab4772b5f5b01078ed4a106225fc031066e97aa64af05791acca9faa5edc630b4410c0050e083f89407b1ef1af7be000a22f7c2efbfa0e8d45b251f3cbe814efdb3a14ab23def0c902b13cd8f6430359f3f94118b279a58ab725d5a9ac65db0199a3c1ccccc56b6a3c9260f30d47e046fab488a4172e1a2a58766add0be11f3ef0ceaac1df6d5213b508ea1415dca255a417c4ec9e66a94399c905efbec467f8ffe38ed6d30b563041aa89c16e6d3dcec428bb1345ab05fe755e30449977c3573c0b8e06ce305ffe7ff3d731b20b2aaef94ebe818d8e253a10712fdf61adce8f033886468acb6611d8a9966fc7a2a49b438f089b1b11cc01b009616c23c7fdaf070ceee38cfcb19864e1ed1c9c789f90bc9a399986b1a28d3e632a77a15192d40384ce9b480b759837f6b1c147ae0d80ade729bb251959f8fa02a5621b98a17cb472eebd8c7f886a5565350811b6e75037e447e97cc734c70f079634d859bed1b3e1748fe5af3895ca27bcc60cf8876b87ece862de544636db76b01e82ccbbcdea8892a5966286bf80cc0b2af868e00033a1436f260421de7b4ea428d96131f9daa02b87329e3bbcab39436a5fa4aa51ffbda5456a59b9dcf816aba7add0cd561ac6fbf2352d6a277d9066642a67e1e3d8d02ebe5047b831409aff2720da1c05660850be3b45d94cbff638f8dfb17342ad6b69a14939a1f6fde08a2d0c7e2883548ad6706c7e1d38a4886bf491b64295816af57ce60c416af237fafbf370c2e04561dc2b5112bac80e6284805bb6765f277b38b6f1c9e1cdda2186927f0bd3604662021e70024d00c502f15385eac5f450b3c06e0e6b771953d29f375d4de2799da73fdd4ded07182053b4ef17c3703410c02df553369420a78dc002b8e2aa1a351425caf6d6e1e9d62841371021d39e8fd5f601b5471227ccc79b247b69aa08ebd8f054bab9e30da28f8d0c0f6b6d6cea98bdb19eb4f4e335df2ae4507e0d3592129c338e97553d401f2733e71d6ae64612ccc28eb23bc2e017e496f0ea27018a7f242978e79b029b13cfc9084c214f83958e753fd9fb1d23729fd4884a026bb556c3ba6bda7ade924fc5e6d954fd53a9b597bd527cf8804cd658e28c8f42bdf7da4cdebca4ce4a4697f2cb1067d5ff3241fd4724e2d4b40571c3ae98cde168a43715f0c53d89cede1f9d3deee56ebd51a288aa4ed02f2b0baae7ab90451c0c55b4fc2ba67607e15007de25ad9bd677f245ef926216aa2a0e66895bf94b3c107b8625d359ebbd2c492b4ee3495ebba52cca9b52a8eca77be732afedf7521fe58edc28d91ed79f6eb367a23c5ac22d3c82e718c6a367095ea56ffdfb815e0986d014f223e35b28886b473003f90d26a9c2881daf367b65ce32b56e2765a8af7f4b506e01c529655f537c90968ec0fd13afddbf229e060657220b517aa5079344b009f8a8ab6aa7c54cab5122c3641145c31f52d0c46acf1895bb9b0fba1d912169dd81a059ba22d3914d388e3062946fe2ef442dff8de9ca6a9f9e52722a40af692c71106354a12e3ac4bed6c1557226114484a50b9819b0b654af382de2a620c8aa2e0039221a9aec4f2455f3c3ccb9eaa8f7815441bb78215542a59e807cde49c33cf3cfe5d041d69f50fec6977301d9023cbfcbd42f1698e2c81aa8e0c443da185535739ab901a4e40294b56bf8e6a329720b324d0d63be3bcede037e319f2ba20231a28e59241e4c0e9d604baf8bec60569a1e5e95e07b368fc4c7bf01c876ac99c45b28dd49a640f403c46b1d28a8192e3fe5ab3002a076a56a7b81136021a022015ffbe678495db33e7110923c972edb6c7c017bdf467a2149ea4e16ed9cccdc9cba40d445c1df9537223ddfaf2b2765aef6949f5fb9b03e2272d64980c1e4e111aef8c77d2d5ef14fc186f4f3cbb3699c256cd6fcc887749638cbbfdf34faa0fd3ec378526b80e389127d19cbfe9f08d958811df9d870a06e2f37f50c7ee6caee94476746327caa79dd641902c5bd012ac06f2ff61f9aa4aed8c653d8583215976b66f8c231760e69be81f87d8350a3b4034f8f8a7af82c0596bb5065bef835671db2591d3956b61ee60221d4fb4d0053e0b846af87e5459f2ed7a09adef384a6e4352c98d813325f75fdcb52561cbdcb4feebafbbf81d57fe7dba1313bd7955ab4163e2e217d5292fbd26c87f56aa4cecbb2706868778434055bc7a8f272259ac3814eecb89035f9f6fdb3c1e44f77570a60ef37137698e5f008fb408e5ce8236f47fc1e197806da70518926bfbdc0b1b64cc9c64c6ad1ca3a3c10509a8991b01650692bfa49fc0de5f2051c8fadce1475f1630febc8c7b1a1ee43cbfc664b711725bf8a3fc5758289c1c8c744a5c2e8e8ffe7bee67464fd32a0aa1b92a193d54c9488348a6be7d5445aed072155fd861edbbd44a2694a25dc4064d986d2a5c5a7d3c78f97d68ee5c4b457f30e79304aed8844a7347c32f5b2f0c17194daffde4c9a9b12029c3bcc1b0764427765eeb2b1bcbe19ce560409e49d1e6c4c37c09b2ed14e74a46785fc78999f4c70fcf82cba7a89d890286d530c38aa40d43d5f1c456cd4cd0fb0524c92a14a2cd4817283b57f1cf06764040baca1d4c433e1fd01d2dbc98c50accd2e2cddd41fa512e705643177a2f170db5a84c32023ea9dc58dc7cd314ce847cf8ccdc64447d54582812d791fadd687ea23d7f315b1724949672c821ca1a5c1b6bd03e3c3c64ec097391b0d648e409155c6d2ecee524dcacda61c804c7bc8d9f19ac757f4d6b314aec11f7c932bc04092a93fa8c0f2cde7294e14977794cff43b34f582b0d3168cee379a79b0e1268fd499def2ded20a480e65489fff785c051657a287f9cd065e4ad766878d18049ab46fce45804397d659a16bb4d068adef812d4b217dc9d31e58b3662e7af199bdbcbdb364997775916c1fc7670eee13c73532287b63d7afaab5ae9c0021a92294c8613a4a295d98c0d73341e421590eb7599cd07611d029c40038ce2f0d56e602a673365df26f15ae1da7ad580f153c214e19e5039e77c828b8f9702777b9441a4fc9857603ab072bcd652aee0f0058e3cf020abea9ade17a8efb827583ecbec334f4b27e931468c32f674a835b743c8795aa149914d960905ae63563db961f2145fd00751c2b841b71fc4a0da5fd22ab6ebcd1a86a1ea69676a496effaf49848f8968b6a9142d826e056b94782b7d38dd5a91f57bb295450c6c3c9304406cd7b3b83d79288663a0896ad9d741a05cee2585f5e34b8b836293e3b0b82eeed37475957a2dec323c3e9561a2ac7b48ddf599064a7118c1f72e3379093a76b2e79b6732ae8999e3e5d165a64626a902a69eddd891fa64f79f130b08bca0b78b2f901bd13748814eeaedff450462f3eee8aebd02e4f1b3e5a0cde26c8556a1bfe6f391412af8c6f8759eb377a80f85b40cbc6907542fb963870afb515ef7c0bb75c3dd1273e25efaaf72e2261a7a596b4fa5867b8ed59ec105842cead01c2e963f038c6e4e519f8310c5501499586a24f10df8e22cdbfe9c454b06ca589731cb2b2723abfcc32fd36c0b500448a9f7c06354fbae60f9d370aae95d9aaf67aa0a91a824f42d447399ff6c41406975a9926d90d66ebacd0d3dba768e33b29fb9e594ad10589df1c1969156a99d230e91f7bc50296e1bbc78f2168c24905700c605363ec5015df3918daff18f77aba9c3209868bf96f7dd53450db468970f2a0498dc2677a5af0ca4df487c893d8479789fc1a529f90a47401ac720fbacaa3fefe47392bf895f99b760dfaa3b7bbba931583c3c49be46e587a63cd36c5f05a9c163c2b5e302428f845586943bf8ad8ed66d4eccb03e299c9f227e1b5e1b95215f66c4e73c648f27d7750448a0178fcf9b2c5bfd4b143f8cacf580b1fdfb85fa4b8a13c528d1b23d2f04daf25539a1781bc68f1ce637a38c0c813ba73a5358f021e238e22abd818131fe797227e2dbd3af4898b9e9f8815d70fdf415b4fcf320e93337d33e922fdfc2e89bcaf2868d1b6d2c766fcbf9a1c4c0f92f56a98066092f11e4a0f71d9bb6d825bc743ea4541bd24f227a0623584332e0b26b21ac82036a4a632b47c39b1a8bd4e1d2bb9a53755bfde838fac24b7f150a959cddce985a406fda08433b8e284dfba4af17f6f570f6a50895cea75505e69d84cc18fc36ee50a6dc6d820e5ec91cb35094c0c819c251bf2aa3356d42c3d51e5c32ef9d2d14c383584b4f35ac37319c10040ebe75a84bf11c59aad86d984fe131c372a7d71b051b790d90ac7f785abfdd7533da632a7383d8689a8699b93bd1e9f2f762a3772fef24a1c79f720a66ffa699","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
