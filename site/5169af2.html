<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90c1af5598952a595d2c67eae551bf7723920baebd5591737fb56744e7b3db637885d65adddd8182df76d2559493699cc092637022dba04e81cff1f246984845d835ef98722b973bc7f9d71833044bc2cf6f2ac7173e0ef76723f99225a2ce0560fe8e00e5e83432912e284c8ab399b04dbad6a4258c351573258724a3759bae9c814fe975ea6317009c631d939a97037b13cfef69c69a94fb60ed5df9e94999f486c962a612d5ef6a681925df3fad9b6cd588dc4a628a45a3737ca878aa24567dd3232e369045038e68f2a4f3865422f7a70e592c184a31b2a874189fd9b9458a69cec0a2d641c060fbbb4f00f699261dfaca5143053a446f8440812d2099a9048485a07f512b1ce13dc7cbad313d7037e5763ce93ba0addfbb93628a803b2c8b5d94ed3395894047c14cfab1acbace07cc522457cedc767d82efa3040ee27c084e72c5efb9e3be3d7686d86eb9cac99e2a5c2f4537aff6e8871bb2afd8f0675d8094657d6d1fd406772d874db574b4af5a79b7afa68eb39a57a6c259af4da1fea22f2f375859c0f3e50bdc39fe358e90b23e0d0e582a5f2f8579a4f3413985c41ad810f0815b13997dd37c9ed0e82d6625cab5d35ef12d60ee0f518bf8f67a885e133bf103dec71f991094d4cc2889ba42d91f50ad2b979416481f2941fdd6f7b5aa752f4ad01aba9875e83a069980f5647140b29ffc5e81f50d534df18508b6ea1b6e8e67d9821404b587e77a574d2e809751fcf2bfc54fd33871731f47fa268a9b4e822e37abc7ab6c3921b63a667ef0c20e26fb9f60be67e9ac80633fcd7af62e111fcc2ba4be937004e04c85b61285bc001625ebab791f732ec1531008a6183cd9bed0c21b3e5601ff14573313dd6be2b1cb03b1b3bc736dd7476f8fc7ff68515d4ef110340183de00840eee73a7c5a66c02581765459df61742bbeac52642f9102d9a9779000c3b094848279a2c488fe79002470a561288def4fb8d6dc5164a1834aef66d89d4f80087ecc66d253b8efb50822318172d6b2e3f273cefd8cfd158fc2d54550d0d2255b402acfd9c6dc9412c6d38fbcb52a817d35b0d191d65c71fa4ac38131a747d960ff78a5fece183becb2b88736d4245be622f21458f6a2e672da5ef7c1294447259577af3792080aa581d9bda561faa0fa68ad544d3c32a4b15af52732184af385e3242c33990e47563b2f48bfc271ac194e5bef8a9da677c8cc02004b92bbc414cfccf1e52876dc56a3211c8f09a5ffb375b4d244bc15956df019238d2a029479dab2db3b618efad67898225272f516bb15d363c10f509053dbf4c8529e3d27b023760a968d24351e302efe3bc25f2741ede2bfc6fe0f597d6ea9f6a7eb88e19056ff3a95eeaf3e16dcd62abde1906fff0edd7a65e96f0b1b0b139f92171694bebb0615d82d063b813fec93745111010c916caee6778c17f7bea8e2eaaaf47876264554d635f244f1c5e358a46e904e163f92bcb2ed27034d5168bdad0a4ecfc62b4215e83f5f22ff6287c7e7a0ebd724f13ed37491cdc7983656a7fd37e327bb7047ad0542a31b1655dda7e94d6ebf58d50eb272733877cbdbc8b59de380f98ec1e1123f0d3ca198484b8c11a84038dc7c5e6c2090922d4d2873c0e9218001aa11eb054ec03f524066f935313056a25f8ef541805abe05f2e7292a4c0fb2d5491d48d5a2ee89a6d8f23feafedcbe5a30e85f7e5a8842417d931f998cabb04ccc9da356c67e39af441745b77f698972e4aa613006cb91453fa057311359df349f9ccf8a400272f49eab7275b83285fa04bf6e1df36ebb574080de1b63f59e4bdb19ed61e585b8b62f7ef33b86c209edfd0f3c05b7649f427cf5d7a9c6deb3de090357249e37bfd7b43ac3a92e69d4baab53353362d4206a19ef2f6361794bfb4e2605c067f39c0976cdb72c8fe73a4010b58a96e7fc3479e29611dedecaa1ae03d63ebd2fed436538c0e31e05e1a4d25681b5b198d55d38669b21fb37202ff60903778aa39ef489e366fe09b31829de01f74336a898cd23224b10b277ab7dc9e67013ce1160ef6616d97d31dce76f76a51c483caa0cb32dda86fb149d984c2fb88d0461f0cabba02032d0fcbed6657aef56ffc922a80b2413b1dd15a18c08c29ff93e203caa3d97a50f8704722efc54f24158bdecdd70e6ef6fad642104ee20a63cca3c400a857739d49ea6c5324171792f9afb1a7af82e6a0af0e55548ac2cb83ae164ccb91a5fea3184c8a5b3501032c2d489066e313abce547e536ebbb35a5cdb500676106b20d926e07bdcd1fc1e1ff0ec2bd1f70fec446bf0a9b74996ac581da8a73a45d7a5cc1638ebd6e7a79a415f05800c261a3e04ff080f6a46a9626d0d1dba6a99ab6cb94f70a2516af4624467d32f8aea02f2e40b4651fc0d9ad63d08c586e95c7524c2923f177a41aa31b31ca22167c3c2bc1ad435fb0a7de0f9cdfd16500070b8b75a4d3879f252416593cfdf931b7e14f39a2fe12e29078d7f68c179e84e2ec83ae202e2d6ec4db9ec0db9d53c98c94812ebc367f2493fe470b33018276eb697e9aac23fa06e463fd812c95ed9455852846909d242b9e182fbc62f1da0db92996995af37c1dae256204d4ff43f8b706781079ba56de4f85e1c5c88f5c8a29cd117fdcd44cf72eb5665b92fccd171b828b6a194ef6e5a60bef6bbed88290436804023ac210bf386d6e31d8d4f20164c47011e25cce65fa5d76cadbab172856e0bbf28173577358741e6084e4dbde83234b6c0112955a5e13e2b6f84d9ad930ecc656a7d9245e55a13b7e775ced580a62090cdac097953c46a10723e968522e003a2a93b58bebf613e653dd25b3bca64d7dc3f2f1a48ee0858ca6ce57dd863f9a3271bc4992d18d4d21d73e4d174e0478ad9a1cf9dea39c1641af73b68e30c52c2113b6e0165a58e515c561b0f53b78aea5daa81cc3c8f230698a2a7941a54c1a3e60eb656170ddd352a9a09b051bd49fbfc4a8c1d82c50c36667d490eb6d1abe21ff993975b8031cc6f76c03920e344e5b57fe9116853a96225afa41641ab930ffebd846c19880240f2ce3e6efa71d87890f452f8b2d5f472fbdaf9e4286d450e1922ff8b6308370678191e35e520e4e69c5814ffd75c3afb710f5644aef2d350c28dd5fcdea77e76e398982b48452ea21fb23b90dc01a51df1e4e49c6b2027fbbb1c9d3b3e7740b415b20a7e39c391840fd3691aa45efad5e71e7d97e8e4480727bfcfdfcf4ca1224197c34346f517620cdb14ae0f37843875f9abb18041e9abc63748394dda1c685f7ba27d3e7250629fb01c7435e3e0fc4b9f3e404c774e686bf26f4070bebdc09724d28cfc1072f83c1b281e0bc7235a8baa0f0fef1e00d318964930662cbd907a7d06356a80f8bb2c783d681124d93c4a47f5d14b933b6d14ae557d467ffe499eacd79304d328dd2aa5820f498f49aaf9188525ebf576e87c7843afdbef8a63bc99edb74e4d18aa49f7233ac2cc58e6b5417437fc4fb14eadaa6a2f2759cdcf4fffa1fd31473a4c3c468bd7f5d10b7bbd0f13aa8a77a288d4139dcee94a3fcf1dd6598121b2390d0fdc9d6becab9e88ca6cb7b417eb8c2048cb8e719eb4920a86d10e55fb3a4b4cb698e1b8123c474d74a86ee1802729c45938f967be1796e352653fcabb6571472a65fe554bc1f4f5919e9120b96bdbb42c20cb6d10540b78ab0c8e6d97c3659f55df4ee8057f4f5e6e578a7c312c923d13837131fd04b74b728ed9d60c0101c18f2e6095bb66e132722a9027d9ba36d947344a3aebb87181894900dce059b1aa44b84b8bc445a9e3de5b701738dd87d875da5bc4d62948a5dd4e3a64a160d9bd5aa85f7126f80fc872c5283e38ccb89b27b75c1d415f91abfbf69374d83bbfb4cc51eb29c1f7673a8fbc8d68acbd956a55c87247332f67b7c5e2507cab94b529c42270b188fded731d82784d3c8e7f81cda0444fc5dc9250148e225df230a98b696a979570f9277f1cef2dfa0e6a69440f7553c0af4be873166f715049958fde15edaf481483e1b676e882a475f3ef43171e4a7a3287ed8ab6ffebd04cce1cc0ce77120de866c7e22717c4dd087a5e79acf7b0636258cf15f69d3c2511e8412e513cb14d89d19737575649b656c697fb38f6f6ff5a7284647cdd4ea313c7fb89d9c0d9ff9c3be87322104861deace520516a857a547e6d9c89cda72a0f5007a4fa0fc0e22ea5464288158a6e9fa891ad209db686f437e2b6903edd34d0f2172590d47716a6bd570e94d7ef55c1590ba692be9468e04da636944bfe39e8b8fbafaea36e317b6e35ee4835486fb761e7b0efb0443ddec42f9ee39430d4cf507aca30d7489947c970164575244c53a1d5e0e10230fc68d77545238e0ffef8c551ddd8805fdc7b95ec6a6461b7bc182a908a4f6f386d87c42fccd87598c7d2c1d823f11c4a4a60830cd003dbf8d2bee2ea35b7f2f94410282e203898834ef29d4cb9462944949890ebcf713218a6484f3238175de20591a847e04c23452a3d8f5b1390017dfc15d4982cdf29f1d80c76252e475a018eed5ed240ac0a1172f36840740fd3ec4cff9c2eb8429b495faca55de630471653758b40da82f0c626e6dd17357467566c09e213b6e777111b593e5502318304b2b3db668147691a9375c345bdb028e3bb370dca90225e5fe1a3e40f6bdab38360ddb0866a38e7bc064c2e2438d6c9d9008f008a815a5094c1adf50f8354e28669ec92a3769a3d3d3ac1aa67e3d4c40c0d7923cc5c9f2da4154fa4a2a396bd8253fbfeaba951dabe5e6f6e49ec04a67b51c44352bcb668e0990233b3d6b8400142a746cfd49b6ef8ea9caf6049ef3e57ad8452a00de4154e18d32a7632ee9974a7a3fa23c0f9d21f5ec5c1276c2885f4fbe1cf42d0b7cac96a365cc412f2f9487f673bb0bf08fa88afbcaa62b9ad51071b3d6bbbd5ed960a48064e912db471d615ef56142d6645edae47bb6ee289fa9d1508853196b505a6bb6b6e822fe880357c65fa122ea7ac53f10e08c0cc883c8d0bca12e81597f507eba975f07c0bbb7decddb5bf75d3a5085f97786fbfcef3ed7b3f980af1cdcf9163a817076bf878393a19e18cd0228a54c0efb360444f410e636c082096389d753597ad305dea2ce0a747f39a7b0d76b7010644172ef7ea05325bf958d905302dcfa14b0ed6ea4e8dba0b2fcd5434e69039f1b3f562543d7e3f8faea19e079a80cc3ba9efc2ca27c9023c140a53c1c5e628e066f42f7f7adeb06fee5546d83c5121eb0459e953ed564672faf1f19d2538e3c5b3700937e6f78809e921440e5cd55a6b587dc1717519b13951a267ee7462b5540955886c7dfb96bb12928cd0bcafdacea9265accdf0424ff45de6f33cd14c504dcd79ff612e385ce786a8d4eb7b69d8c7838029f1cfcce408257c6295ef60497d0223bce73bc4e4745541b18c3cbb200a43c7af5a0eec9982b8f5a2666ac104002f65051de40e29dc5ed58cf26e56377eb2c633e5588b11ceb5db56f5bd138739fedc28fe5aa6dce917b273786a5b7690d15e9b5d9d2a6eabad0e30cbf77e80c1331fc0dbed45e3f6c41c77ee18241d4b3d9f98d867e8d65b67538b299f926a26ceca16d09831b71fe4a4932e52409c4a3f271341a26113287dbb4dcd3f72b1ef6782d59dbb766408f2912a6cfcb4fe977874f12fc27f3abe93474e1430317a2681311bcb0c5162edb3705a86ea091aad7cb61c13c31fba4813a4f495776e5db2296dd56a7962cdcb62ea28cc388bd9f3586faaab40540487b4be5598fe6cbce7571b528c57edbcbd412e23bd2a41adb8555e76097fd74caf1b0af80e2477c5f5c69d3b2f15d47addeab4c9294a9e3160ea6726612a61db52e3a6a2a4e55632a122a5b5e929e80e869608e1fe98f024b37850aae86747ec4a4cab64f5362a4ab1f5875828c4ceb90fc5adac26ea963c00c046a9d80483b19abd75a00f5c0f2efd186f478ab96e7e9005c39163235c2b1a3d95752a2fcc22eec04f95b051f0d121de875833f04e01491908e1463322218c8a322d59f03f7776699606184810fae00c77343e232bdac77655c5b375b325cb3350d5317791544ef510f1ad662b6f70a5a62756c3cb59353a459ad29a3f15c0e8d575e2890b341a6b84d3e2a619e7b34a25c1b36a7d5e51550739c0614b255776bc7e6e3055a0c1a6a45cd3ce739165b391facd965a8b6032c769c8db62c47eddb791acbd7fcada25b6eca1dd3923976e4085fa20da8a1955dc45b3d123bc27013f5c887f5d147e0a4193e104e39cb00fa2d69d813852fed780fcbe51e0832f27c2afe0ddcd9cec73d9de9fd3bcc00d6218c87250e5bace1ad0d0f5d468bcdc07aad3bd9dc08b75cd5a6dfd1af1d29ef5ecf91ff6367c9c60a5e087d29272e45f7d52f4f04aac6c933a90d52c39bf5085ce4b81dbc54716a1dbf3b9c29025b84a0ed8ffa7b62100006881ed9e2089ab7206004bd3c3f9cc96cad44598208a95baa520114c774f4e0b8090f52532a1f43fe09dc4266fe6034d1a704d100975fbe09ae8b13fcd5cc4a5f7a1a40d6afeb996b0162d1572f0288f3521eabaf4c0b2e662447babe1f58869a9da9bd46669d68e692e34dc5d986d7903b8326722644127c993d7bb80162e6aa60c43e9dd2b507335564fb40233f547e5c66d63bb0f0a43c5a0df89b5851021f2fc6bcdc5b8108ef099b3f95f46ffa68e0e95f715e769c8e8786191d534af5ea1b49c331a382ba8d718bd5ac5a719782b5a6d8cc672444051c957fe584e46b9a729a5d56c32dbdd8a3d77b4a2aa89caaf6f3cf3a10b184c8f49e3d24dc7e03d5fc965025a21ff2fc9734c2fd677246df1af601ad293095bbc43807257463e2ede4b6dc478db37b42c336516bfca8a20f3d8facf6070dff35169243dc4633424ea29ce1f86c02a96c2f0a8f232b9d756b9c7d72861786ffbeed052b3cd9615eaf6a3f67739b1d16ad2af1a49c2b5520b7905b1bc230489a0441de050763660972ccd60fcfc60ac22cf90898c715d98b99395f027c0cdd6b22b4bef95bb87bcc4e73c3a28f9b5e65df0e27d4dcb773e459a3666d89fa4147e45da50459b6389e58066430179b774c52818147419f9b594c1737457230e55e56af1325cebbb4e5d3f5e884fd1fc06e2e14871415a5e7b98e70403b53a41a695c44c367c4312959686808ea19055c945c523deb34b5a482283f44e370af71b0ac15a55bc19ea3bb31897bba45ec074de97eb6074b952d97831573bda2a7d3bf88d6e79f02673c0cfefa996ff2a90c5201e560cc4418fa8b62de17b954fae15f97cf95e45a6f78f1c3d987b9a198873eda5af37278135cc188de52b1b847fa33d5dc2fc019ea44652afd642929977d235361162a9f23a16535902d9f0baeebea1ca8d245e64054b7dec1ecb803c3d5da5e00cc6cdaa2b2aa9ddfc31ef66ebe1bea3093fee44215726e1142f01bc80d02cbc281ce35d429d0e678e500a05e305ae45178d5291c0bb95712d5599a1ea233f73dc817e015e4bf290dd8150b7bcf7ef96195a419911fa2453bff08f041ed834efd30e825f727bb3ec0a43a3c5939880a46489e3a6480d9bd86dbb2ac95f0b674561ce9eff9f8c8e68234ca5c35c906b25ec8336b3b5ae2dee4bed43938ea8e5878f8939d0200d756e21eefb61c3fd2bdd6e7889c85252cb3d5fb402e5b1479b8abbd76702693099645bbe3e54103d267cfb2df7e96e062ab8f4465d1a5d583030a4b8fb44d31d7c82d5789e2334bb9096e27cd5f45eb4bcc30f8ad7cce0e30f0e97b41e26c9b26b584632a36c6cca33888209897374b1680d738c52c5246b781d9a8c3774481cf7bd5aa7afaa1cebb465500dfe1634c43c9cf77d992ed37de93835d82ec1e2b362b670817028bf6c43e44718378971becc70ebcde5d069e53941f52f244eb1b7ba9741ab53a6f8262e83864ad7524799f42b73400cc3b36c5d10fd7d86b9712beee4cd6f41772f2211b9fafe2f6d5952c0ed5cbbb14fee09a0b5716140c100343ed1343ac6c5bb046db9efad2572ccb187b2c68a4e77455ff0f3e61ef36225c6f7b0d9ca5021b9b477c2ebba0a80df26663a63d6c5f86e02259245bc15dfddd1876f49cb5ed83c11f8c1b3c806831af1be0bcf5f36c946b4832a2cb88d0e5538bfcf74741b2227774c601b7fb9f4473fd7ea233715db374c9550583780e9ca1f5beef7f1a6738eb99272740cbcfd68f5d2ab605e6b436948f7a8a567ab1445bcc819c9fbff03d7428b3452a618a42b9618704dda7c9a66c0522bd1583843c460c8f261d1bb61899ce3b99cf42c65e1506ad3abfbfb17ac66e4c968ca12dbb44f851c98e2f7ae02929e3d1c977e8f8e19b60fde21f3176df014790360c900238b878d966b3dce379c3d279b9391cbadd1ada0cf2a2abc2bb6a97c6836abfd483930634e130be8b0549327a39e1b1b0ed3a1b423b7a8f5f12f24566bba5a5622dc5b68af88292c6b68576a074317ad23c91729b508311940800dceebbbbf2c8d27bbf75a720f586717c36b397f862a696f77a5d5b62d7bc81bbe0c42faa1e50845c1a926d59c81a0456aead34bf7b205c0a278e0e32751b835fc1c30c3af253c1ea5f3d59ca18fb36b224793a5bdd3bc4713a335b9547d7a211f3765d1b6ce93f66020cb5d4917d2aab6935a1707d4710deea92a42677b6c815eff400157e394b8738b3284fd2e8a1bae00c133b051d23204a94763d5add629d74f0b543c258db55d0a2c647fb7923180481ceb33b9522f0f855dab9d54bb2ffc09699af90efc5aef8de05577b7c16acb4bc2e6977b85a67bd1e55b26d0662ea99b15a047618b6dfa2cee6b3dd22f7c46fd913eb28f3b367ac2a3f6553d6342a121020b4a24ffb51cc0fc0474f5dfb3c6ec0954b4125b8f9a85486d7d9c1a09f1e49584cdb2579f551a077951de753ba28e51bcb1d21b15fcebacfb8429b024a60e2065e79751255638684a4b37bc86f4fa14821fe4e311cebcdaadc53b53fbbba770f0e9818320cd724ca6bb520f66206868c22776d7888fa668d2318938c19e66c44faf9327bfc202eddfee64e5c802ce2411bc6e0e6241d329b9f5688d4c23168764b4e4136bb636ba9db30dd3d99e3a09342890c6d47ed9b7e80c725675c4c7b6839ffb7418a45400d14d39f076ec7b4daddfffd8563575edb6392f2512e1c7c1c1a5c8569d5bb941350c697a9d0c0212ad61aa50888f2eb9dd57da96b0909ada467b2a5b204b97f30fc6c10fa29045bff55f8f5a3185b763b80868f7a02f59fdc115cc0c7bec55dbe3f0f8654cb4e893929c2bb08b7c615317db689043c653a2200f4fe0e10964db8268cc688d38e14c0c8a6ee34f1e3e393834e9f9830830b939f77a38b026a3f20003b8e0d14092c1397ba33daa7032a76d3ab2e220cef0190edf87fc311da4e4ccda42715bd7130ccf55845e6974acd42ea1f217a7381659740237bb7941a63f04728e63f0479072e37e1055565dd440c179e76a7831c43130f2fd729a63676504afebd491381e61511d55b3a259188fb7492add23bdb8187d2108208a59002eccfa2c5e3494ab9ab8ae430a5f8adef7be0fae381675e0c388c312ae619ea653fdaa68335c30e9b90e84f5fb0a35b96a0e0c402c57b2fe0975f49af2eea7259f179497aa8392de71e108948331358d648c709ccf291b7cae552d69a1bc484d7836b7bdc8053b8d269808c79f1dc75d124f08459ea5f095aac72e27e3e2cb80acd55a7ba080101d975b0f973a311f17cbae034eaf60fec966c8b21f7d155f912a78d3d6fc2f2943ef834191abc4245691b649ff8662aa3e68ffdd3d9432bf226d09d7670823005c344a922dc477a07b4552f1e02b134ffe0e827bf6db2fbcc6ea726c5303477fd30d47ec2f37301f184c2994361a2b83aa21c0d96709bcf3d60cb679509a94d3cde377481f882544aa9fe896b01e7635cbad6f86efd8b96b59c07283d0ea42032ef045cd488c81fbb22965d74d0d471469923df3a0146984de5d708efaeda0875e39db683d444abb367f072c83a7f53d6c2b3840eec525ba2dab28de536e63ee76bdaa1553a49e8874bf32cced83d1a6d30d7f19bd0b75b9b459e44aea351291d3ec9d86ae0a391104b2d6d5acecd4239cc7cfe34bbecc3db6234c747e5c71ef6126a630e12e859ef45d7b01574237d626f5edda5c5fa1dc8527883257978379fa07d185cb40f48ec9dfa8c894627e33dfbf4f0e7faae0ba53d90b4c78fd05a7dc2b04dab601faf03be7f214c9861608dc5872f4ad5979121a1677bb8f44797b4c29f3c9c9ed67e5e17c5d1f47ab1a66537497ddc693a9ec8a01f665d199569ec693d4a41f0a4e08e0217f31a0ce82f3ed35e575ec26720a0e8ff22a3c023e731576aa3eb162b7f799046860bf400ef9472a21cdf6479227b7601f4b2fe6c87922bc7b184571bf0b860766e67752fcf0abf7c5ece7fc178edc7cea39d1db9ea5be3f5a72c55ff3f26c0843159c8cf6f713498afd680c57f7f68cffb4e562a5beec022ba02c85dfa937604f1ad8410c25792910d2aca2ca2048f9ba8a398df190237ecb4468796212ad1b12b82bc40733423925653927b68b10e4e59a2561e58a96e8cae474e78a23309d9922f016c4da5627c75d28a7c45c953330ab8b8d95d9b609768a5c9a978e5bcf190a50c1d0a0311374b4422a97ce179e49923889b7704f1f946c326b0b5caabd98e9571e79606e1f9f5cbe7b2140211c5dae9311a80bae0b23616ed4682c55c0576ec023cad0bb0e892117a215b3225c76375e730e598207bb703c0473326226fc01259522220d632c82486346e5f9b8ae2cd5a35","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
