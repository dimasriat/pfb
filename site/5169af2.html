<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f595b7d1e699f4c15c7409113b07cb1d1209af8b56b47042ce0764dc0789e52d6d394d535a7199b823bfb50a562d5511c6d004c8e220eb1fe0702fb31edf1abf5cbb5e3d06f3ab4f9caa24e5acb4a666cc516860d04eae17d072c904784a30c458171191bdd1039906db158371c05d588e061708f50bc7093a4754a462e5459312691d3e176d6352437b70161f558503e778304f2201f4368b1ee5b5324a501999c663c15a9ac9d1d87a55f2390274a4eb16079426272a8f15d608d4fe51cca302a90021cf6f1aada299826f24caaceac508dd58ed8cbe1897bb83c8518701517f95c7f980249ed07b1564fb83e74626143ee940c3017f7c036ee370e3c5551c81ac337bcbed7c3f2e3176f5c2c74bcf78e97144317b3aa1263d7bdb4dd2cbaa4455c71f066e24b37be3466927b180c2e5bc89336f665839cdaba725ff1439db76e04e5b26dc8dba05e431f4dec4f0da4150a2e2089d5ec20e942b987e78646b8fde8520d73f0cb26573fb59ae7f2f130d64e13c497c3fb4096b45788ebc7c700f3743f7c6e2590cae262fb5fad88d6872bb2adfaee5e951275ef6f88806736ad910082016637a3276da6aa9f96215f31ea660da43b1e5f46017a9ce076561a5b0e0baa9dccd768e3e0e1c2dfff6b76bcd94f44fc2351e1d4550959cf5122e75d46130803b9f05c3cf59483c76d56189f742f85382fb10af0fe8a0c6912f4a736ef7e1c615d3319eea57025f07a87534135ef61b884468664ddf887ccfbd8186a06f4173a4e00c461422340f139d42ef53e0cd7dd3183854c57641f0a606294358a39fad5ecbd6a23c5607d6011c9f013f6ee2eadc3be5d8343862306999b72c67e3ac78e2367c9d7fab9e80d7f8f28fd124ee9ff042a260a84df825513b1fd92005c1e2b5c47f4605207a7472d64c56a3d81710d36cdb5d2aac55523af81f688c63b0713aaee755d309ce5476926c26594f75cadf562f74c1eed4858f33b084c734dfb8cd16e11ebba52927140f1827108df4d1836322df141a646dd8c84b69342ddd0c0b56d85347d1a9eabf8ee83a2fbd2f365482b938a32d5c76777a456f8a6a0a6234e0b6397720e7ba561dbd900af97ea86ebc8b352909c6992017f892de2fc5fde5bdf5489480810c520b5081adf5cb0f3f67abeac2392eb5deb0a643093fcf7d1633121ae08e0499d5214785cd2be74723f9a76df1c5180432fe6b5ec39e278971866a492f281d4045c8a7aef48ab195a5b8fe7893cda0f81eceaebc8eeed10043f7cc31231bef9cb5306fd2f69619fc8db8971870a4d5bdecb9120a39f1501793eb9e6da7e01e7c11679714f169bb65f1ca3914e9fbd0cd16ab9dd2a42f92b808a7e2447110c8f5c9e9148b83a24cfe8adeb289ad73d5c2444c29a1f4f2cff01b54c85646ffc89e59250077b94c0c847825fdd1a0cee7df078320c6f93261e0813ab900f13ed6fd3d24a306752ac3daa9a3f2aff4f35a385c601315fca3bb60268b34742adec83ba08da1a70fef897452f7b6bfa17e138904fb049f5339d4ef159e31b636e94e250c33458ab29e01f8ae8a6a2faa92297ce745ac99d9c66bba6b80d50a4d5add3ac92598dd5d5e731b4af0a4e0fa02f4c62d37c7f5b323b26c68957d0e2df990c0838624773869e955d968131011142d7db904ac79d588230367c34fd67c8525ef60a0123d31b8b64ac5d3bee3b5092416f44885d62a12ec6bfe978bdd4938f08e75163875481b43276e17ec216e3ee82038f56d80d1f400c833d279bce412b385d336bdacdde3e590d8cc671dca3286a696fd58e1f143ef617d92218754dc8269d51559339d5f7b99b71f888b406701608dac9e0db97012f63d65655f2e782aa6190929ab09968731498b6c369bddf9becb7905f24176eac3b08aba06726daaed4d8f4d39b9bf18b7f5c1a765a5373450c2c64599952a1a50266256fce9afa27a76d1a9d9253ccd3920855440ecbc50297e7d81c5856225661a25a196870a37b0608aa511f7eb227468e03d02ae13207271573b9997b8166bc6b49296c881b51c2b1e3b8d618cfc11c6f6ff45c0840d37fec121e2c72b8b062bdb320667dca8cbf12fc76a32cf200309f6e6701131a4fdb25ea49400c0f2daae56860b12ab818072d306100138b0615b97fa741295be275d702cfa15f688aeb333e70d4713dbeefb60298a1018d7b374e739beb20ca85c8446c463f39ba78af5b270cfad3b099ee75a0573b72524d7d562353fd6849b28247ca1ae4835f3181786a77276014c6e56c8fa183230b9616ed8619d24f04dee8d933c54d0d3f300f8615e7b36eff0460a826799d081c1778a05baf00fa0c8eecaf9e644fdd2a567cb2bb317cb095fa6f9baa983b2b5d15f30a1b0b99d27ceabe9feadffed7a17cf9f07ef6cc163fc26a2842f7107f4d983ff9f8f66f3ef9deb97d15f818e6421a32e551f5e70a8d09621d7453feb6d530cc5b05d5148fbc27db3ce77d38d084a39975150bcf3fd6a3bed5d941a91b21ef26ef9cbe2a8e921fb334544eb1338c36fe56f231d544b1dc7b05a91d2d8428721119ac497918dde91ef449699cbe9c0d8fd1067958e948ac401048df71db50962278ffa06dba94d373c897c345dcc3c94313f2289ef5134c815da3d1f312120dc6685230c7833f8ba8ab39637d306430120e3b2ec1f0e037f2a9e8e7a2bc2e54bfd6edde22c39c82fbdfd6079b08aa775ae26a00020ebf3d1fb024791a1b4517e50f6a0f82baaa5d99f609a88a1f50f407addfe87c3620274fee52650296a5b17c499f39630abcd22eb3caa1e50ad404baf9e0d33dd3477a87a1f7afc643cf83fc576d7d15b4b295bd55cb01aeb112e77a1d7d0130b7ce037e3de726e07b5053050cd08a02a157a8162172e6c86d939cca4ad786f77a636f8695bbdd1eb797ec66fe2cc275894c8b3bb3ba3a724ec71a48dbd131884e3555b3fe0d7a58473ec8bc84f14c04b001064815ef1e82cfde2b1abf06ccfb54f9da7a7898dc6345cf8b45c54023f723b12631d1220f6a4763ed9362057ecdaffcdba166fb2c9746a4a0021c18e499e687bb8e1ff2c3d5ab20300e355f0ff6997878f0e3cc69f9899fd75b9b9738225a579d6ed211791a0f601ec6a7dd132d9b8f3f7ce9898e26f540a3957944d2d7e12c190e37b843e5e800716c3c83da48bc53f4bbe46eb5d6f1d2353473a47b94e957ad1e54d0135264297d3028dcbdf32ecfc76d4f514d1e723a300b19b63a4fa56761482beb0a62dc1490103bd5a0283448015314c815a3f8debbb53496599d4ea2ffc53717174ad378177297823e1376ec8189231ab7e6a65ff116b75479b215e7c9ddcbf5cf39204f512818936cb08d49543fe35c0d893242c8a113be15a6b9a0ab358385bee818b4d7d037a38b49ba583bb34fa9f1744f37eebc834b757823b7a4201f7de36e6eecad2e0782e538f07c58b25833baddcf221a2c3698a029ddfb04125793ff1da751a32380591d43827750fb3141aac9e7e088fe00c51a6e8cdc8621b7013060cca13b57028f534c74b098aa973262785f02bddc1c44acadb4d6c7b382c1ce3e8c3164397e3f81c6980dee2baf60bb4a5245e3366d6b596a468f376340e8ebb8bb6f1addadd0885c41b23c1b63df71a73c822e22ed03187017c92fea7ec1a2eebd4b6b26641d35f0aaf61dbf4c2f4f535b77186671969d640c45cfb49c54967af6752c7395442293df37cd6dc88d44d5b1d5cdf55e1c6be90c5013a356874f3926a74899d0a38d12a9ea3b65d82da7d9107c9a0e6fa5b8373b03c103567cb28e09209e6ca59df67d853ce6bf3b493a5cc36a118efa8ef8d1cf139bea55f6eed6fa2db72694ad3e474e4809eff74e81e6e48bd37127e1a33d4a73d7e42fcecf8acdd6010fec1253053dcfd7de3b0252e5267399182af1467a20d014ad02e11189b7c9c0c4d678192f41797c253ab7f37b775aa4e5b9f14f3ba7fa5cebbb0a4cac5f91272543ca7685a825f4f5f403acf3263bea1e68ddbc0dbfdec9268b5a34f99a67a9dc3b9074d66fed6bb70eeb49f65e3befda67b092a4530b064de2cd8663fa0e4f868aae083b1bf98892d9dfcd4ed3a9153a9644782fb2060ab81a3f2b4ea369aa2383df7cdc5be7394c83abe6d14517d7b117536b2c9da21c21f9e7cd190e95e9b000dac30589f20818cd0ec646555dd9c7b8094791b3d8b76494271e06258a25cb980ddfa2c620040ad7243dadc58520e9fb72976ee35b48d8f6fd663408c2bb3dca83409dc993eea8682b359bc1044b0f863241c67f3521299e98f94825a6b89e0d7d6d6a5be744b6fd3227db8fe3ea424fcdf512a84670c4e5fdb8ef68c60a2c2c3576ed5eaaf456818a534d3a5baa5bb990c1eff75db4d19e93d4370e0b4d29a3cb1adc493c56aa319a6448d5ac20209565e5f3c7fc60c229ce429947fd1deadd91dbe67e47c614e4c903d817a88cb1b7a6948c5a62e2e2da7e4aad40c2a6cba32f39e5835889675e73ba2f43ce87387361cbd96ee72ed7a0129c0597aee6a0468808a6746d9b83813233622cf31061e49a28f8990eed0d69d9a805df4359beab60ed9365c90498d24e83c5a55e50067daafa95894bc6d775f349917cb5c7b115c75318504d84c180fcafb601d3bd42ed753a5b7963f91051499e352499935d6b318951fb1abbe7f9d5860929573a759d49259b419d047d1f2754e99b1f1d5edeb9c1c7b722382b798bd5782a298afec927a4727d2c5e4fdfa42f2d2d6696b9083b1bfc636ccdb9de9d07afa77d44a616ac76eda4c72eb1cdbcecfd832e9f0ea51e175f2e726fe669ecf543588e0b570940c0fef196717b7749d858d30b8a7e8388992a3ea760777971942c3996766b4c3660da9776fd122942b47162e7415e3aaf2b4051ddbb3a445dd254c6b512875f0271931ed78b7d681966255bbac1f62c308aae818d5c9ba3ffd70aed82e089c7754ffcdb39bc181a35eb970c16b259fb77f63e3713d0a2dc5f0654a1104266e33b548948c37aaf1763e8fc5b0e7d61619c06c221a0a1fd67bb48928cd0d14423b3b0e9bd48beaf46b96a07c6fe23de32c663f8d506acad1e592ac4433efb5a2d086112f7cfc5353875c5e0be680d611d1c0a5cb9385d05bc81d2c56df936c7a511041238a712d7669840f10685e00333dfd984e1e531e82927b3857d052efaecdaaa5ec7b96a30cfc46b9a00a904ee0d06e9b686d641f583e26a597a0dbc7743137904cbe6be8f162d3c107be33df9a4b41eb5c033cb5eee5fcd47b119f5e99dda86de582e144aba9e542e44c722ff76dd59b4b15f7d6be9ec3902c02a2db687c53eb6b8a006c3acd6ec2cf50e2f14352d43070b3a5498d6a6c41d8e9cb4bbaf21306b5fb14a577b02f61454dd96e4d23896e65043a1cdb39a92c7aa06638cb015d0e1a6854fe10a0604562fd7ff2a9692e2a8b97d79757c9d1a2bd42f68bf772114a2c6d57021e16d9a23efe9257e5ed61df39a32e10780ecdf4d22f26dca891345b5122fd5badc9ba19029ab9282f1e8da7551c3bc05911edb5e16259e7815809894623cbf370482dc17c4c5d7351feae0f1ff839fe20cde99d51212e99ae479f36fdf7b1b33f8ccb083a60a4cdf30fd5d62a22880dff721c9c51d62fe3a78f41457ba66b86901a19ebcf4bf984db3525ace5e1409f496361a14afcb0cc85081a90761f7a0a9179c990021402353ea5881fdf3415d0e22028675eded12334886effd0b8334a536ece076b371e121de82e3e7b22cdca314cf1e36487e907627d718aa5b1f456407f09b475ece51227c00673b332a98329f7027130e7cf3720e00b48ad2d2748e6088243dd0ff2a4df9fcb3c62187a50dcc4e9f30c0f2c9961e98c7d0fe9fe20486c09d1e5e005e96306e1bf4d19b3febbd2d8b0fe091a632b6db6fb8edeb8eae3ad38bd1a72541678af2af9bcfcab300e50b19b364c83a8ae5eddbc634b314a6fddfc0e9b3fe85133ef5e9d372925131899e3793a449804a7ad80a182969797e948f91f18d825c2fae55090c1aa96424551cdbb8625c1193ecb660844f0ae329248586b88a2108b971c1d02efe49b739365f18986b67deadf18e54eb9f5d2b70a5b022afecc9bbd04d31474f9ee46bfec6588b1ec5ee936a899b2dd8edfb1830b0f738b9b2a10840a36247cfe714d25f54acf821d3b1b69b662b6245d2182cea3463c88e2b621ffff63378a40468a163718c9389a5adb260653b6e79025fbfe3fe6a1f957cb340e1ed2ed178a54f7298c1e4d355bb5443c971f8e0807efa2a7eb324e5da9f4847c98d7d79637f9e2e5dc9c4402d9227cd07dccef5f7e60c4899fb41e98563990514044b2592195a8fcb5f9481eec3eb5a14dbfb8bc227b3ec991ff1a1faee5c45c7e220734ae4f761b1a6d446b33e3dd80ccdff616d40cd078d3ab9895cd4a982a0f59785ef2ef50243178f668e9c64fa7b0285f2424f1971aa1b6b1b0f4c3c9a48cc111fea8c2a2453a841f01db1b2597da4a65e57ac4f79aadc8da96f27709276f78637d581af18ac0ac4625a2bd4dde4d841632e96a125117c9afc4f3f77703f29c48b94cd2cc8932fb3ce20d3846e6707327bd08c94fe9e31429c6517a27923e5054b1c034caeb505255bc57fd5fa81359ab3091e3e3ab4c6dfb7e6299240a8b19b41fa27cc70dc5d14d948d8d7d6a284dbb92429e5ccf326591ccb793efbec67facdcb7134d618e75bf2859cb9965d0776eafd92ed0075bef0dc3cbb7fbe95cb444338d086f9d16eedd5e7f0420fe867e57bb86885c82118fff1fbd0097e8f2fafd0f2d691cfac0b0b2d453e480e4b3bfe05f9ddd3969edcfa4c5df9413987f79972a19971fcfc5555a99106b861fa1614a185db4128d78ca239e230eabaa524c056b423b37f1974c250e5d89c81701d7d9243695537d017f8bf30f7c517769ed33577c70e5767fada686ef98ef01d91611a4e5e091ab90178b927a259ce8a7f5fdd27faa40d9e1afb37e41e57abe33d0e2b15d0e4813b60f6360f9298252472b51803f6ca6c0b1119c749a09a1fd4d24b9c8676b912fa931195c2eaf15f09538abf70d6d2d3ca353e03c4b1344b08f1284b6aca6ecfa7a2862dfbde26e79eac26b096b11e990be11d594aee8ad73fbb5f62d1cc56a4564bbe144a4defadac81cce631675393106fc7f873b767a1f6ce0472755477b1554be4a1bcfc4fa9ab652338e0b0eeae51aee590a0f00a4c953e7d5663e90c0d1b79d63d2049d74f9ef4f46298dc63233da34946599ef96679c95a3a1350c91728a4b27a2345e29eb0ade82ad30bdd74091f2dba8b84ff55d5d905871af3bb0c478a9f984f1facd6ccfb78def9bb631e12619dec0948557d6d9cbf0a1590891c2336bda4898416dfa6df5b7ab3873b73c40a7a56356cfbf3a2a939c0c257646c76cc994f416ba16464557defe2663264f93253c5ebbbda3593b9cb4f7cdd215b4331eee981c84e0fe0208603b0682eca92ba0e7dd5321e2eacfe3499aeb61f1b343ee368129864e61ab69631a9d73f57a2f80d03d8a3288a39c0177e71eef8988c23e08e98f21666b6cb84eb76f477a8f8a19a66dd87743426a998c9294d3d0d1b70511601c1107ffa9452aac0d39ce6dddb08971eed38bb39fa794236448921a4ee096cf9fd5e9f8986ac14051f7547e9d5672360786be4e979972762627107e5ddd7a1ff15d6f5681993e783ea7489a06a9b732cc86b73a1d76af36971184b6d9f9437a95af09b24b9c0b7862718ac16f60b8593097b719d44bca33a3ab072909d89d91e56c5dc0219b0a2ba5345f6ebb8a363cc4ab09ef209b19b26b9403f49d09e0f472299fffa2cbc6396393597b4b98b305b14d55ec8bec2596a7033936f289d96230c9b105bf583dd4921b1f50a19db7173b2e4b213e4484b527fa0306889c4219b42b0506f75621bc08b2445969a4e11025293e917f562815324882a5903d4fc1317b4e55e91925e84f859ddf3b2e37f01acb3b918689258121d2e4378bd51350675c929b3764316ef26d8befd2d5cff228ed1ce38daeb8b8cb08acd655e47860ca20e9c3662727b37993856a64a6aa81054b7250e93ebf121d9fdd42672c58aabf13d48848283dc8c811650127989acb2ad93e00710d1bed40c9c646d0c51d1a546172d86eba972e50e0b09f1668d8c5f0a748be54652e3a8052eb329dbbbb1c5be8ee8c328c07ef462373787f15ea1b25091a8c64a737736beb197e80f4bd04b5577af1bea78a5cac2d0e82ad0dcaf562ccbf0fd46f13c8404923eff8b79701ce6e6d8f0eaad5cbc3036f6c9ae6430675af71697fbb762b0e0698ce644b2738966ae8466f255b1aece4b81dd24a3e54070e8bbf3971d4a1360154270b62b51157cea3e8fd65cd96779e36aabea9f5f3b248999972c8f9ec4a6abef440aa8374218a64b5bd1c4dcf53017612319275a52340e858c794530f50f950174fdaf384ef3a3ff4c526da49f38b884d031fea36ecc6a0593db26d039a0f43f432dc0ce69d9defbb4bacaae100de721b801572fcecf7640bfb331df9ca6e1a352ac91b751f450c412a20c7bc4c0b18cb91f619a27cad6c54ef4b7432dec231319cc46e956ba8c51d63946dc46fb4e6065282affef50a4628666e14e1cdc69ed60e241cfbc79e0aa351b1892a0dfcfa00c0350c2135909a3b263ff7fc2e8109bcc4d032de8c61035a9da087e65abd62958a52c25d1e0a71cdb8f9d8974a474421ad6525dd7178c9f44fcfe86658691910c17ab4c20486b67e8f54c49f8664f8f28f51e2af89a9a4966e1f2fe760fb4805e4746d113f2941361aa2c58a332c8a08b83cea0a87c5fd1e918456048ee140075e1df79218cd7e3867e3935e0c8df71428387449072adfa9c5a45fa5e49c364cdc503716b6742f1ffe5a230c4c94abfd17bf693d6d12cafe60b7e98590e9db7f539e3a065abdb260746fd6f5202d6a36e1fad03365838608fa7e245fa4d9266df034184e1d90076a1e228f76ecd8571717b7aab559a6edf88fffbea8b8a34ba5b346d9e6af40ac9d23d5bb22cd67db4be3971e0666ac21aaf2ae4b096b2b0e648adc261","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
