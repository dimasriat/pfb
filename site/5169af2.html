<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81b9a3e9991d0512934dbf4d5da342b9ed041a93c1d681906766b8c37a0582e3bf49d81e3191bbac7363db10e1f0c9a2aa34db839912f70d5a59b235319705b2ff8f6b3ca482fa3b9bc8faf49b38c6fa33cd4771dfead2bf5b66b4929a5c2138e6edb80a4e636eaedb54382bc138f673a1ae01c28568d02fb9824526ef62c9f5e0f89c81fd9036671c96abda1e7def1488f48bd31f464f21eb9ce87b7836395e528c9a90738ad0f4a821e91061498c7d6225281044badbf102cc5caeb99912537a3e2bf00c99c190c402a0ebdf1f18c869d1c32ca705581d634a989933602aa6d486e1f5cd14f152ed593669e33aa525d87157cfab6c9af0a71819653f900fc5fffe4e3b8b34f7ea8efdc16a2afbb24f26be87d63dc8b943349fcd24988e34c815652103c3db7980ad617f0dea950dbee72275111978a7c50ae96f57c5609f0160326d8494c9c8f8318d97c8169390150600f42531af26db9b598ca76513744c90bb2c586603ec80e198d8a0dd6a4961386c46000c3964b113b0c8abe26a578a51e4b0a1625ac3d455fe5e6a01e5b5db42631d595ade005a9a3395cd609714a419bc85595872f98c500290b3c43b268ce7de7b6623178e16da0c4f974c70fe9e287761eb5f9b4266137d46f97eca38b8a504099fa4a1f7d9710f1a9720059b0bf1364d6c3400ea759e87b61707dc459f5926f909f1bd454e653745984d4b289d243e2b48fc0ded7eeefdd5a57a24145752bf94fb98cba236b2fa3a08da1c615bb26e0b62aef60126ef6a681e3a2b2cc4c2a9d63d9f8d375d5bf924b47f6318d9d6265bfc61d39157b59663f06f5ed78c053659c38563276ac115f85e5c80fc44f1d9c98a0a915c9058809b43768f510b9044f22d2d5eb8ec646008b561e1f26bd059f9d4c45f363c0b2551837f7f7105c85e662f32b1126a1c85250f95f9f9af77c9479924ef5665f2ad187eaada713a04d2307b484d2c6e1b8f2da899345b00fd50e96b74e36970e0fab77adf49374e08958ea0ef69b60f7a8b54eac02ade6714a1e05bdbf1a0f8eb281f26948b88d6ead3f7d06d5d235c5b09c582074d0b8ee08a1fffa530ef1d9a9b1ff558b5654bd52dfd53eb6927a2555b7df710582ba3c47b573949821ac487bd5f7af62dbd72e448929d6a34660384340352a06b2577da5f42539b22c9656d7286f1f3fb56d49e7c356edc8bd3d95a32a0d3a1ad06fcb70b2418800140a8b5451c819e99b7f1acba3c921795aa896732cfd3e100642591fb4bbf4297158d44d4e0b4c5c562ab1a199c9acf30a6f45f7bc6568510db2d08ad3c706129c2d57060062035940ca71b65a61685b7f34f0699877755a4dcfd1e3b1784294f46779543dd6a7bdf2eeeae5bb9cb0923cf3f40fec4f985f78f7ca804439af08a84c962b30829ae564f24713aa329d5f29c5a0e56b9cee349d9fbe5c69ae2102603e282fadfb80b3fe396de6ec012efcfefc681e85893713457e1e83b79827b0e511d2226eba4ad68380a68c7aff247bdcaad9baa2dc0a194428e7d28b14778500bf0f9b75efc08e72c35e98fa93e03d3bf56755a60e7a822362adc1c7dd27de21db9a66329866a8e3de13279ec589f2ec9d688223b9517c3be7c3f33700c2d55f571ad408ef2a25e7dcd5fea0ef5a96acedef2901eb60031f4ef5a804ed77342398ddf394062698592b9a6be900f6a9bd04c1a663c60c441b35f2b046abc2669edf4e44bd7d12ec17eda073340735e89a967923fceaa6a11287dd7cfb0151d7e82a60ef13ffcae843a163bca558578eb63f5b2890283904dc30b1a8e5793f370ae53bf00fd1b6b2f1713908701c4a04587b44c551797dd00eddb86c7f8acd876a6d8c6f7c53670d3666b506ab8243c2d5dbfbc85c436bd12fdf46e25181760b54896e13cb174be429f9c37f7ebf0f114c2df18300eefebf4183331c38213ee37c0c2f75f9e774fa38f4acf4cea345f4c596cc5cdcc7304f2b0a79f950f962600927f0e342dcb947478f0384cbcd51ad13484602712a2d4cd51cd0fc38edb3116f3b2f01f0aa5e9c55ea43673ef6f48b38cab67c536709039a1b2925bff0aa2899196ff254d45e57e099c9ddaffaa51037d6ab05bbe0540ff3b8f689762dd5b1fb7e4e0ee05f8c54277b8aaf2ff278d7b08567a7a4b8c59c30368ff196b62d77b19a070c60bc0f3f5e941f127bc7d6f3ea457e38d17bb66f2f70d27d0b9d6325c7b1dd98f5824914af7e5ec0a07da9aa66e2c5a57a27b920f631dd834f5c6f17914ef26372eb8ecfae5979721e874b1618bc56c5b8139c11e438b83d6ea19e67b194103310bdc3d8fd4d35f2f14589a9e965e425ebc887831fc7ee2b632242bbe39714724cf8620feef8cbe8713b1ebc075535efc81bbec1dc3cb36a0e50993c2fe528a7c16eb9e17d00d7bdff4729b3a9fe344c0861e0663fa8a9b471c9649095b5a02c73b157ec05a5878e597a33e3d9a408211f7c41257f5e554c2d20b1ab45ca4ba63b6f11f027a72302ab0cc5a0ab80e455400ba217949df34037abb35d9e2c6e16b816d2baf278353d65ec3b6974998873e659458fcf3c6335afbbd0eb3ba747037d03736438236c5eaf1169f6abd1407c86de5eea49a37d0f16bf7981aec73a512df8095adf2e203e2408421d6d14314d09f408e56db6a5341c37c9cfdeac3780fb6db201fe994f105e1994bc4acc68b423b3542f3fe373f2334b6fdc37cff39a529464397c2de94c73484ee8621c801a930734554553c9b240128dd5ea841a91448f644bc7d3da95cddfd27f57d0796973e1810c3870593a525444185b963017696ae2d8936e5ee35daaa094624217f4c0df75007bff1a8781bdda470e953bf068567830ce727dc7ee05dd9f18c001d5b34f877c268fba595faeaa4615b2237f46d95e6e3b5fc1ea17a2cf3cfccd9dc9735f7f488b0c76a1a2a4e91693164c80a0b8cef7663a67c483af8d1ba58f945f575b71adeb555f929977297fe325662372930a8c78c0c925389e2a884f57bbe4eb90b72dc8a0df7fa8bf853ccc3491dea3ad66f737ef9a6d8529d7cf7571a2656c1d935fa12d92bc5531cdec6215fedb4d2e2d4d8c3e872ce2d4ac88391aaeb4f54a4871d1577eac2d58089bed71f32eb399269edb4ed4cbac0a090b3032ec22705c925bcbe94f358765364787c179701290ac7ef72546a86ed5504247e3b9a17cbaa3eed6b0874b15fac992ffbeaaf4ebcc5ce859751eef77c3fa6eecef48e8b8e137038116c207466c8cfb8d9065ccbdf9885619f7dc40e57a9e9e28d1a5d6cebffbd89c52bd8b5f02d32409777c810cfcdefce37ec7d59dfa9d7e67d57776d8df5494d3490820b84786bc5603a45cdaadc2f1fbd817539d1a2a83d71ba2735766da9398b43eee1e3d84f5ff46e9767797a02458923a3076b31b846a2f311a45893f3fdf3fb47bf66cb9f47f1695df8228793d5d855832d2ab2d87e0e133fe30374e191e37df1bcb1780ea5dd47c5ef83ab2606dba6fca3fb94177dafcf452afe7ef6cd54682c0dd7d286ce91d4da25eb8d8f92a59950551c2d07e985f3acc164e33a93762250209d424e4163400e82d0d3b48b7373a7d44f9b103e566b66b9d1d065bd378fcbea991be01644b120b6e7c634f04dee63dc917dbf99e39b544cee87d3b2905c65df3c044c48689ed05adab32d6a2a82efd9dfa62f300345724eec297eb4b6455cce0af5587f397ea3e0b6b8d71f899d2dafb611198705e8ae2c178fe8b7f4fd0c196b280d30b5caa60d2e8edd0f72d3f7d41632bd2a0986c32defbbbadfacd4138d7634c14af645396b0baa251f46902db8b75a68352061dfa4799fc9806d92e45c1d978e3d0fd3fb8c47356c25583fcae3fc3b16c1213353db0e316d91fbf91db0eee006798405df92d807fc1e6261771df952c25513a7357e07eb7dc9cd72e4b4f6d719b3736b3d694d28da7c1d7c56bd4b944f4d9f07c31e8ff5953e82d9b9d9c45f17014c9f49568e09c9998db14237ec8e321e049de811eddec832b6a1d47e1a3ccd58c995515e1d22bb3cb7d84258549d917b7e5e8e961d232e958a27316b66273bc52ad2b7cd3b88fa9d9dc0df4ae3b3e6ee199a7e47b113248ff4892e8a5c2b2858081a492aebb0a7502538f7f9b910b43d6cd0206d0a6e2de46c330a24d157e3da8c531153bdc5af3303228decee82f60fdfdb270d9e9be64b2fa71061e95125f545e1f6fc5a9f9ea5afc2df40726b1722eb4ef209b7b2194af464ad78f94ea1e7c29373a865bcecfe885b9d347e955bdf87770cd39a8c37b627b2445be510ddf6c445b5dbdd02607303f177f661d8b9f4dd119b533ef8f5fc01920d6cb401731a480847c4328e38e28808a5771c42ae93cdddd298f7abdb9841c2fe2aabc07f6fe472c6521159a4e660a6c10af763fbaf00fac7ef78f7b30bd68b2b0dcf7b8a4292ce42a84fdbefdaf4dc561803cd1c68d452993f1c7ebdbc22f35766f1d1a9a23df7275b9ceaed5620a19c45baca75d1202c3e4f00c340b5646e3f5d1900a87cdbef9fd6efbf184d4a3034b3643d03bb4ea883a24cafcf6974124f717b30ee1011ecbefb45aabb254170ee50d694dcb8ec02ee9838366674c7fc63263587f1d1a67e0b911971db718aa212f691f43a9a176fc4179e7548d5df3cd13d59b30df24e46e3df3e532a20647923fa76e80ac9b887150db1a1f1efde304fc80b1910cf418984f83056dc7e01abefd3078c2e12adcbb21c1f5f5e87d025e113766b7defbb66a6a602c87d07017036069beb56b025c693364960a61ca7fec3d1e6dc68e4938ffc55c1dd14edd522dc728d1acb6622c0686a3daf404013b130fcac7f5997102eaadc07996c000d32ec54d8e603d6c5a77ec5f68943af386e590c5642086423859d349782f58f76b51c7483cc898e23d660902a9048a7af8e538a13b5f762ff72ec27bf724c3f342675ea1d184c8be122a4936e0b457f09796d402d5ed34df584e780220166d55c832840c0c2aa05d4511605f0d642b7250818dad2f52f382b1347851247db2160db7ad118bc68bca5ef47eb2ea20167943730843c6d94555d930bc8b72ff01c2e11dfa9cea6dac68eae386a7764c90ba20c22eb38c98ad31cdda038d7764b42ee45342e3cb58ac6948c64efd7546e060bd7b6b0f0f89894e8554aecbe8d8b6670d749a9c4bf02ad223663d402ed572c150ddc4063dd2198673df7f64c79e2b91bd66119eca9a93ef9c778d1ef3ba590f0e1e4bbe7643681e07c8a93f2d3e6183816c8a5c516fbe0f768eee353d4b20f8f67dfb8d8d4a021e974d08e070577e1c5e21bc7595c389eb1f2447454b6a5da802ff5916d4d2038d0990f92416fe6d7ac67e293e53e4556890a71109fc77cb7a9500215019a8f61cb66406687ddf967d21e1814cae7041ea9e5dd54a2eaf44d5ef7774c4df7b87236983d90337e5617b3471526e13ce357482bf28791e67cf9d783ae495996bf17f4c6c0264267564ba91d4582dd1f150bc9cfcb7f8de32726f9dee5f25f6c7d01f189169ab6e53f64128cc0816fbb79e0d351e158d3b9b2071324306576d373e88a560e4e30e42668d45104b2c2a75b4d3270245424936fc7b8d9ead7cb0e2a242de3fbcc035844ef82afd39a9e4cb4c455dc2a0cf3d0b67ed918dfd0c3522865b51c7ed8ec6ad4ebcdb84fa88bdef7ecdfc0c57070848949af66a31beef1522ba7057624226aeee1d421c269ce50cfd1a17d0433d4d89f0c996ec964b67704d435e07f02a25d9f37787c335e848a172b105e46b35c8537b2386a65f8662bb116e5790bfff15e7c7cd8e09333d8f02aa5365a7d4112112d27a8021b21d8c38a67736d1754aec546d017e9be981d22ae6b00cf51336f261a14b266fd4baee3acf9cc56c7c36509422aae007dd34192e1d2d811618a43014501a2292cb051b0697ac7c6ef5d105463445189a7c47c0f405785be8d039faba6ad13df3ca76d4418a04ca65b6563064d9b22eaf95ee361d3bfd50f3155c053df511723f2dbc2a544a35144f4ba4f0e802435cadb052c6cd428d0b8a575538d5aa3e21d37fb9736efd19ab13c411b96605e1d0e4d7d693a5ca0de61b602ba8b26f59250dfb0f418f20927b499a936632bdf6c5ebf6268c0c494a759be9416b7ad0dfb41bfb4667fab7cbdbf62e19c46f64ff549d1625980085879dbf69b76e51f841fe8b3c581778335dc37e66a6235e6f6d46fe52c3a53753d75ddac717015c4bace168962b834bae64f41dc89fe0e205c152f6205e1f64af21cd46e60132cd512d01de74d22e7d5a5c49dadd4581576da9f2d51cb3a76f4f2b3b27d9edfbe55c554b347ca2a7d4066716b2bfe211972c16834189fb0a08691658711594b10961120c6adceefd2d2941db1d088a7a9915f68d87abdb0f29bb4e9eac2c8c5d2d7e34e54383809e43b2b02feb1a44313a935d76d133ba0118bf9e41a2ea368a004facbe7d364cf0f48092bcd755b3a1803e075c110577139812144aa424ab234ea6403826cc53c97ec6208f230e395c5629c993511b038e557dfa809cff46c136ffc161a38b6ff713f96086706d21b60f70f0faa80b121c7e75456035ac296a81caa27fe3444021c5d349de52f8fa157a2fedc7782f4cb0d019a52276f047cbb9e85908bd9beba47594b58e7ec1ae773cc7fb95d09eb13e2508caff1b33ca777e8355448619d4758b1ece304c2604448a10e334fcfb7c548094a2f6adc41043ab9c9fb4c68f8c2a9093013184a63871025262e8b02e98efe33a2f1032cda1fbc692504bbebbdcbc1eb76e486a6f57d9de7ba2c7787fa1367ad50e6290ad6e20746471926dcb11ce186e17d7f320ece44178c29b68f63391b1d01b3cc5a34c8c24f84f9b73c7ad9c8e301500566429ffcda7d2c7e999d05467315d00e217201f1ee04a0ab848e80a0f95b7ffbcc48a944e49816be6e5b352a0e0cf0584f65ca91c384f60268694888df22312639242b36c41afe287f1bf35e6d56813e60eed55dbef71a4fa518d1e4bdaec5f4a64ba1a6833f24a60115b921859d8dd4142ab873b82b43fa89c47665605b3c5f602cff2272841f05efc128d481d1af92abf03c61d48e23ce45ec63a5724840c3a4bea723619d29c7d77bbf4954452a1266480a00196912994f74b3c8ce782f5b48313666e598c2b42e8fa47c2785b7b8e692570b15cc6154f08e9ada7f8e118537459b4ccbaa2f2890fdec38839847d70a3ac9505e0a085980755a6f9b91ddd28df19e67fef80c39b0043b9c360d552fa91562ddac68a7ad7e6d371e8c94776d5d1699699f899b25ef76965d4901f391b84e53b551f72efa90086b8297caa1c96cdf5c3ef4e1af1a64809a596d72ac2aedafd026dbebee856aa76c23b0cdede77454330b9a328a4504ef6d3bd5135ed6c2ece13053d7aca9e6f060f70f555864fa51fc4402f9c0cbb33042b895d979c2680ce0472f509b41991bf3a5de73ed092d5834e5b13539c422c83dfdb708a0dc34f8dd5ad2fb159847d4678fbd5e07fc4f2e01584112619fc00d2c72ff0287b61cc793b50a1a6aad07f9691b6b2ce12c19e675c5dce8e2cc8d0721394df2c52b2958a78398750f2a94552a5660eb41dfa25dfb868d26f942627844d1edb8a511617b8fdbf94dbec3c3e4d69341e7e269a7228ab252a68b0687ec80c53c86e12ed2a4843d8ef698e824c9909f83ba762c1bc4a385a831ccd964af1ffd5d85eb1de6be67da96070042ad439d630c5428b7e56598e6a118347df96ed778b2727c0a44e79f91aea31de728240dfee70423a95c90f6a62f32495caeed3ae02fccbc5d39fbc09afe8388af228576954ba3751095fd8634a815b750dec60ef510dfd6255142afd687d53eec5a9c688ac6b5bab197c0aaa0b6827eaaf5020a751fd1bf34e7a14999cc00bddfcfbd8b8f09d5dcdd8b1a1bfb8d920911c45130bb57bbefd3dfb1b478e7747bc2748f73c4bece788df668c07ec4a6d7a40ff3a7c9f33da6856ec052d45f5723492ff8888979db76244afaa0282bb062b63e80965b2e7dbcda119042073654f43722a14f7dd6f02bf7c88a27df28561a333493e840d80c348d7580e9b909de9d60bd5bc134837daae988f0785c5229d0a04b9fbc511df047382e1015ddb41abe42ffa03d292f4a85b3621f79ba7a5efc12822131a7d5654808382ab47ed745078f852d272ea1d87513d227a1670f82e1db40b72d6a2a1cd066b9b152d7061f726e3448aeb04726bfe0555465b00913d9b7eb78969668e0b81a354a40a4cab5b1ef08d6f792d1b2be9a4998355694821f34d30ea39f4fb0ee6f23f49ba1fedeb0ac971bbb33631db3da04a876e77ed81550e7e3ba5d76065323d280df5c45e87d9ce24bcf29b3222ea254771541392d51ef7503928a4b0ef56cc335f778c50f12a893d07838c65a85795a1b6c9e00383ac668f3e9244df65d02bdfd1ed1e7f5b128af5bfe8106d7c33f0a271429b1147eba1af11a5a6a78da995eae4f8386640ac2252e21c6cf4618c814b90a930f69bc7e62bf5865686418658ca2da2b23bd1fe97781da59c8d06ee7fe8753b7654d1de134b23136ee097e5f5951330150b0754c2afc75fcfdee2a29099bc06ec1a4e30f9021cf8def51e452037dd9ce53d6e354f29e32adc162928335ecd6d7850c7e0354550570863368bbe0a84f9f8537ad398d48f4061d153dcb873abf0e3f9dfcceae52dbb9786da73df6102023714e00933a51b9c90851548b69086b09248b3a33ea810c03934b35e7f9f2cce427eea18144af17fb4a59a9c545b7e7dfeb49f6dc80f04ba937774ecc64bc3ef265fba842b9ee1bcf149f73fe576ef67b1b86bd33bdd43885e58cf8ee2cfd0feb58e52d60c8dc481629da0f02949fdb8d47c1c53391e0b939818dcddb71d38e320ba9e241a85a4791bd008c749bab956cb753d34ccf517ac4c63133e1a79b515259e428364d20cd02101bc8444477e6cbbba5262147f6788d851e5555642734aa8ef85f63fc52282cf282d02e4de87c654775824216792b61e064d3e8de0ba68c52dcbef524f63281bbb35a46f750d28c95de456a34124daa561bcae7ab76116b70e38ac0a09e7b7d8cf9600d0dca4eb0e7faa5eec1fad9bfe2e0eaf05bd3dcf7c9b01470a52593ae3652a857f958e17fbad5401318f64a6d51ff5351787654c44322324e84762325582d27c1def26e0e392a871c81312ae033330b1c453a9a40e07f3bc03d812345df43a7f6006679accbb2b5c6661fab6d46229050bbb06645249b8136609b9f15e1da0151a3b3040175329189f5b2ddeeed085b28bea076c63d25d0f5177c3d5217f7362f13090b006b35c9dcac9def1a646a48c264bc6086607e1229456a2965fec30acbc45ae6e2ccd870b4367249b62fe5fb97a500e6e40d8b08bfd49e436d2e75a67de1ac98148607d5d51e4a5184f0c85ee6bbf814929c27da0fb941d4f22e5414629372d612d59de41aae2ac9f796991d58eb4db09f329f0c7e9f5b0eb5879c39ca8c9dc75a3d4ce89f94b4faa8358d932e9bd7776b05f6189092d97f61398e16c3aa163fc9eac7d8588dfb69f96dd5e6d93b1f3c60591eb56bad5eb86652483ccb8556942eba15794bfee25f6891282dbd8b704dc245b48de85fb8184dc9fd3307a5d4715e68769ed6f9ce75e3f0cebb3adf481b0c095e2545fe3e773fe12ee3959e89cdcccc879bb5eccdba8b33573e37545c8fdb125049aac1609e10d983102ad03048cc924dde4924fe7e0e6ade962fad6eeb4a78a121c557f0d7f7205ebd0d1338ba8e1c39cb397e6d0a7a5816bfaccac6bbb5bdb12270f965cf34b62498a11956a644434f959d5cd0233e75782572595cec186ad57e7933a41ac3b2192b0990cf2f1280b423d45599a8428ee2a530d9cf1e6fcb628cb65484b6e410f188d770e0e2b24b497bc60f86a413fac5a6f57c52099fa94cc46e1ca8c2342558d2c1ea7b6a4a8585341b29ca5ba8ebbe7f87a30ab9f72b95081fec2d5e4c6d20f2c4b941738f00c7c94d26d6b1f2a6736d2645160b3141db3bedced06e1bdd948be9db6c7f181505bdc8fd5c8a49db5dcdce795dc6276c373fe99d3830ae9ff998e7651571ae26ddbec2a9796abdd277e98e0604fedd246a2a6e9a27fa0016b46c59b81abf201fb5b1cfa0cdd25873fcb44867ebaeb49374cf61a4a2eebd106e39d8ea6eca17ce06b038c0ec764ebad60b2cb21c6975ac59a3482480f343f16734b6b0037e2f01fd8f6b","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
