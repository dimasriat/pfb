<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b163d1827711f62fd525496cbc52084b256177eec6695dc94a5021b37f11ff2b9270daa00a39c7b4937a9a4646d07419203c6f631203428c828a7a11f19bdd72b90fb951bb2a2cc4e85a848949667787d7e1a0402d612c4831fe018c44ba854ccd954b9eed9e01a6c9fe7f127ab942aa752c641032bd7ffd19f9b2b42ebb219143537be9c6b6112e7cb409f4da2355825079c9c5090924d44ad2f2f66645be52e499c1556fe7ba7857a633a2fdb686b38788b6f37aafd0c7ef16c84d54ffa32f164c1a7b1905ac25b78db6100016f2252000cde820fd878327528e732d85da148b571683a404fd3a2caa928c9e04c46469a5d2834c25794e76e36c5e5c3f925e54234452180b588b259c2dc6faab3101dc2babfa0aa5a7d77354c81b360f9c3b2e3dd74d298cbd75920517de6f3451b32c5c3fcfb34b870a240e7b13900a81623b694cf4a6c09cc783aff21f041d597efdd09ffe63b74517abd35abbbc105672d482beb6b865158720e8652365a0eee48b475d074179723458aa4d98d806ff61b5d8d38f678b4c45ae0a28fc6b1a388daafe0a66e710f613e60b7d5f1167a61c94d4ab2028c4ae9d5cbf99dfc1d521d947530bb6576bbf118de9626a2a62884628221afc00df3d08f1b3f484002559dbec3eb2de94bbc2aa8459fbe3735185343c5a07d9fa5225d79b9cc56ba35901697f26985029e2ea2f502d0e5555ba1572621a14f83730c8e5a73a7b4d57f14f9d8dac0f8f27a4377e3776b0e47724b266c2dac95cddb952505ed441a410b37ddcb76c47738fa6995292dbe40db65e7fc2ed27429f12cf8da5d431583d7f18bfc04a89db1c5e836f18fe65799967496fe28406b3c0761b1bb149ecb4f25b78c1fdf7e3581c005c929ea6538f35ac0837abe20c48f676228531e68f92c4b34e3fb03e0b371be9bcc235c50516d09e7a61cbefdf3a0bba7ea23171312ee14d9606a8403f5872e04c7d56abfa117a00b4e5239a4460eb24238b21f4b2427be01661d4c801aea70cfba35244c941ef43bd6e6fd87d356ac52964e758f74eed6d91ed0082e9621a2ad1ef86d512b48dc2cf6f3437cde279ddf42bccb049e54f0a63d889856179fb1fcf18298114e01ec1f9919c47d4fb5da3ee353350e619bdf93e3cef0218ac00acd732743ddffc3fc90972688f837a983558e95e2c260d6dc27c32ff98414250890df6a965a9c234c31cf3bf0a67e193db5ab2a92322abb947c0506a3448c3d7d50071410d3e1e4cafb845f573ed96c89992b5e5382c1340a818fca6b32dd5a81164412f3d140c20ca9b6441f7d74f1743d481718b74dbd86765113bd11608f07f2fc791ed3e5ed37977f7ce232e849ce8c68aff82dbd2cc91dcf376282148874ea06d4f80621871818cad4223bf374c9ef2f8ab3b649550c0806df251a49ce3f58e40b4d69b034f087a7fc1728aa5e1951cabae072d4a97ff41518b491cada9d204748d0d13eaa44e0c5884bc3f39290c45cf8f9df0e5d0250ef67de2b0e6f6a4422f1172c38554e2894a470e736a231a54a512aede0cca284916afc4a37739269c825af1d69f9d635218beb08f9be6cb781df726c45516dae54118f4a12878d9d0b9aa4f8a14daeb59037877f67e9acb9c102d239964d8237ff07285cc7e946ab588997259fe077a7774e2b4141630730d93d3054c0ec10e6b3f1472c7e3db2cf51c76c8eb58b083c589e3ccbde41c1f64de7d71859e5781da58d10a239b7316075f695991c9c124fe4bd151e7954790990479f5b732956ee9bb6788a48c097099dd655c9dc3b7ac574a8fbab60763fb6f39d299eeb2ac1ae38a394a77350156ff9753e8ba2c1ab63d67a8f6f6c47f6364572987067e861af88f2aadac69e8b12402c4b2d3ed1b4d127f00de7b62f1a41ff14b6aab702217dc8d2d666fd56faa466f2ac8746f02048c7a2005acba2f11c4068c42b6bc10bfbfe0508a39f9ee532731f406c9bbeb48d7f0303fc08f82b20f81082f36c3056c4b25a4ee9dbb15180f5192b44de44ec43763a37ec69940349ba4d8d46b4d9d61f6a4103af2131e159f3e143d0cdad865078d07b4ba9ff09134c7bf2340ab126dd840fa71f31f84dd72271d370fe3013b1dca86e12ef6f97dc5e0b45f22f37e7d84107996088d301f70a036913e7a96e1585d61ef8adfbbf2263db3360b4b3492a6ead800f40c02703af4b8e31d031f799813fe8178113deca15b6a146fe1931031987d33f4b16b24288a877bc29de16099433d7079febbdcfb1e1e5a731cb2062ce0b99537589a8fcabcaf14c06a47e60846dac564ca6382c46d2d20890249fdc6c4c3e24e6440d57e0fd0ced56a67af1d4b29c9c98f1d31f10757f330abbea64b45e56ef1219f6a896478f2a1ee4abb0e10ebba18bc9df56fdf43770006228b7585828a77c76a5c8308d981131fe31033eee63be75027b007a4cd22e8c5f80e2282694bc8a528cfcc24b64a94eaba6d42797b227f325517ccdfd79bd22121246e706b769154c1157855fee2ad6254588f95c001a5aef5f869f414f954a3945305ba39a06c4f5ebee8583b4cd4f616a8073adb6d99f141426b18ba53368a52b5e4a45e9bcf029e8d720236526427747ae834fdb4f7d61460219757c7803822bbedaffa01aca2bb76f26f8872872876d10efcb1e271d118bf03721ab7af31638a36880d01f0299c06bd6427894d080af1dff7b5f8e66d40724ff946c092964a0800126bf11b9fe2b11535402c4bbbe01e65ed0c28007a284a69227345a9e042edd9ee2dab3801d8a491506f06c9092fec7a1a453e60daa2d7cca5e5a0247eddb679a3ec8aded49fc446c3e8e894b91e217581fbc61b0eb2639017fa3ed1b8b176c62ffd7f66b16f3696b14717b1f8de2bd860dfb33baf795fb02184d389205cae19cac2ecc252689b8a38aa1b1565cc6f14bcd72380c418f362e3a3d468ee2e81e9ab2e63985796ede0ed025c93d8abc350b6a279b89c3598e41eec74ade9902e41c7a68a8ca33d4fcb1cbf6da25d7855b7740c64e2779935f97d556cc1687a00570c3034cfbc9d3299dcbb2d8a14a6a86283573c47e32ae502f80a4b6490a2a785d99d999eb5e51b0ccf9e50a5d2bc041129b752140b0c1e0ee9441af531ccf65e293af79f6c858a753f5005df57e07c508ef19e771f90b1dec1d5d5e86d732bebe53675d6b98c9c1ee3c20095969c210280472751292dd1c79e055c3ca4aad9306e58c4f54d7609bfc27408fdeab09218802c340fccf1230839b43e8e15373760e229f00bf3171d3932cf132bd65b4fb54989d0643f28675049ba5b0dec2f85f7efd092ab8382640c9eaa1e46bc66f088a66a069531f649d113e82dbba8b20dee214df5f799d9d918802c88c43b2d7000ed8787e3a2ac8bf3a40d8dde396fc5726c92f2f230a45a6838e63bf7c1a1fdcad86219157ccefad02259730ee278c81b63f54d80bd1bbf5f1f7a098170e737936d435d34cac84e7427e434ed6a1d905c86cf70461adf925217c4483bc139f155bf861b5535304e8bf0ec24a76833d81dd3373bd53d0d4ae3068cad9884658e26f147d6659cb30a9c0a5e5b181e1926019319e4fc7f27b8ffe3fe9fe0c6f337813f2fd15d8b01a5aa96f256854d11aae00343688591a6fb788281b60f7c0ca85f7c2b14967a7602c0e6515c5220a462451e57a8b1c97262ed980f891efa1c9c73e9f739cf487d5f7c590146f3dd69ccc1f1911549a37d23d839109fd23b5fdaf734318147c3d96705658acf5d131d197a4d492097da024ad0ef43414519d1e5f25ff07969d3efa9a657bf54cd4315ea5860ecf2c8ec0a0565c25d0dc3168392aa4240bb6e87af1dea19c88830e6f1ca88723f11713bea175e28171c583f3c4acac4ac6ff2567b6817e297a93c693582a0303d6b19174b6eafa7536cb6430e39974b7756352c9155f64fa6370e9b151adaf83f093d1e7a62f0d1ae1497809ecf96b6e98f88dba475500711b17b05a59a3365f13ed27d662f29d67a043645736fd31c7e429c5839ed285bbe8e0b87bea99963c8a1ae6639fb49075dc46275abb0de1e4d84a2acc379c30f3fe4e4148f90df4b4e6fbb7b5b18a86f4aa14a7ec148cedde0abd3a7e74c2c3a237184fa0535e4988fcc3fbef440060a36cc1ac9f08d686401e6a8e00cbc2c586c345fa93e72087695a266004b36f11576ca067f127d441569d58dbe1f473ec3fcdaa7b8bac23e1f58fdfcb36aeb6e6e479b9c0937aed03983743a19e17008b691f2e8affc534e23c4f141e1030cddcfdb681081c018de52f0cae8325222b179919a32a865ca3c404dd9481108f9576a47d7e2a95f6eac2051426a9a60a55a8dfb50376f628122911ede6cd1816097bea162c8f142cb85bde6abb394e0656e7e0bc9ad9b8690a805de29f83f06cb7c47202d37230bc02a5c0ab262f2edb8e2034a40e11797207e9f44c477375130b8efbe7eb1e9d75383d9d7b13c2784a1f822c9ce16577be6373387ba30b08456dcb29da792b4545575f0a18f7497daf7939339a0a1072fabafd97609951ccad2f5dfde79dcb69c807a27fc854c813f344943566d3ae7b85519fec16d450f486014f3b0e96ad24a8c58d70d2a2ccccd1ffb75fd545075d269067c9a5f9ef17d35c8cc00d5735606bb4dd588444b34e266fabe693d1c443abaa7a2398ba7425011b95a493376bfb750eb63def4c13a33ad7eecf9f6fe771fa37f7b45975fab74c514ef0088c135659ff88b96e54b0023a7280875c0c13e3edc431d658955138159c9b855ae0f9abdff2e24b0a8fc735bbda80674c09f65ebb7fa7e811e3b3cf3c0df774f06cf7591cd609d685dde5e2d0c466e0e93f62af73e0b0c7e52634abf05be37c8b075ba9bf56e199c706e40c9148b812b2d0c7e95b5a08af2cc13f6f126f4e46d6a322b1dd775dc448acc7c59efeca1397528782804b8ccad8a02a12e8acc4f3ee7ecc8cb9572ef8bd2969ae1cecf87a4922931f75539c63c6fade63ab5c61e8e570dbf9c7f31da5fd567502208d92b963cfd578722e60ce0356666f3204d66bc0396b06e2963fc4794bfc6f582a167361bccbe29f4659f762b2819976932b1f0bedf51f85675a2b407ffab8d5b41bffa119746c8a38189ab11811dc649d9ea933ffa6a382d96b796ecb5a1181c82038ea2f305270a760b9b57d1d31063ae99402aea90cdccb888c55502b4ccb3717c3e005f7d0c57da02c027ea021475c4d0e5e955776178afeb5fb258c03abf268df552c0e76e3b760db77cb22cbfe97639defcd594aa9e0dc61a6f9883248feddc2887491fb254cb7a84e5ce71e59c6b33443bf73d2c70744768bfb3a2b1975619835c13a0338eaec5bedf493589c25d60144f7440131bdf5d1075373e6b9bc13d90b40b8c15f20c000f96900756431a9d2852b1a16c0560ef7ccff736dbcb024456bf979d37495e98d67258ad6a7fe97b4d69bc50d1a1febb08708000224f2525bf4640e158ba661c682473ab3978d948440daa7f48f2f8fce9f9a426df0395e1933553ceb2c2c094e82f152a892628a027cbfc2d8697450b32f967f9314dda0663189df9008513d3c74caf7f9983d48d5a86fd3f6fe0df3a8ce0fc6f63c2e175c80e29813ac056e09692e4f3ae8154ad611fed964a42f5aa8f6a02cff5f8c7c10aaf3546104eb50c0578ea82ebd24933a10fe03c4497ec7f8287d5b217bc91969cb2cffee9e7126fc38f42aa292714cc955a884217a93a4fa6892723609e503f714cd50818c4e42dfba66dd7bc1083dcf9d1b49ce6c8375a53c4608586c801024865a3ff9a345a4e0c1f83beeb20229b92b5246acffa371c0639f830faae33b400930f358ddfab6eb9bf0de3579708c72f4228bbaa9d44ffc6c51bcfa19c93dd39c7a51c436194c72c64a3b6bfd39f1ca1d14b171c62fbb7b16a8058de6f821c2342b2b65ebcd82782bb767ba0b90865ab09a9ff82ee284acaeea01bb8b1731a874d2616507d0fa7c62aa7a94f50db3434999e3237c1b79c4b6110b094758710e72572b1efa7dae63325db7279934618fe05070952a3e8baebbe82b0b79dc299b6ca5d727e7add4d6297439ec52f8390b529d4213af921bc64a178d54845120328f8223cf9491837b718368e434358b5b1e50b14de43c059202448f3bf34720019f9b3188a8a89f7ab91f2be8b4753870fd2c0736632695a723a10d031bfb3f192df8f3a5487cb7864c4d965ddb4ebbf48a3f4677a1369ad611f172782c9ea54ec45d16fcb35f50630a4604ea2b8fdbb63b0d62d4827b08306eaecb7e4b2325a03215dffdc8d1a377a70f23687cf74d57567dc9a3bcb8996464e586fd75ddd2bafdc32e5d49718054a17c6d7931ea48af091f74fbc7d93266a74d759814673e296987e1c04a1781722210df639be5a40c42b38e551c0ca680b8068b92aef94ff57e3d65b6c28136753a44465278cdeefd8daf556c551f37bd12c6264691a2e1e7cc5ca87933223644efca1131083d650eaf8ab2ed149aa5261ccdb6596ff0c0e23da3bdc017d27b9edf175e334e1bebc262e265a40d2502eecd1890c6a4b25dddbdfb6d61daef795ac4551a9ac2e8c37c9b7ca036330f4f0cce58abcdff512d8d1c872dced85cc4537d6f92c06f2622372011c2c986aa7eab2d8e752c9e612511b611e789e94ca57fc5b1e5a2ec32a3ba8479d94a5d36cdf183959bce1e9bf542736956515d9cfc06f349921f15ee1d2916954eafc495148d0cb3e1c1b80c78a5c4129069ee01d742cd47c1a25816890f9837a1257b2f7b74a0d7a4db6c867505fd2657b0349b26a21ab0c2759ccb15407d8651da858ff6daae9b6616b1768ace713173f3ef5edaa74f0fec265169ed7699b9962f0485450af7efb001abc22aaadd544cf19ba7365ea551f068ff17a415c23f65f776578bc3319d178112fbaecc3fe6c5bd19b2ee264f3fc486c5065884c2782c420886c9bb1f22ca730a8221dc5cb6679fd67f2e3614d94f1b4b7c7ca312640f02fdb09ccf03f4682fd2afa71d72691e104395dd795280447980c244ace224e9775ff7b6c70415582a3d173ce64ebe5a5136e9d54c9c6b84ce811b438474648cba32df7c4c986b13457b3545e281215b19e6ce5a7a4f7a9f339b30bf0c9ca405adee9c831e1b2a5c49cfa1f4290540f10f81d4128f745cdbe7c924aceed9c3ab429011fb720f18790cb215643744f8b4ac3063072671543ba8986529d3be84665712af75ba040cc3474f865ec3a3ab417de85a41f1880055f8f0a0fce5182a03dd2521943ed0c60fddd5638257adca7f882bd241442f92eca189147f181876b819077552004f6ef7bcd419e80d41f14c0c24444d07ba4b2632aabf2a805abf0a766d236e86c3e8b70413bd7b602605505b535cadb796e84760b1f2225a60e4c592967b9fb73a427deb9dd4a37c4910acc7c852a8ffc6ef6664e9b1327c6232a199f4b743f00211f563a9c2cd090d56a45e2be7ef73754f4057bf191ab30aea42b20f707b10882e7754ac110338138d9bb220149d24b8ba3688e4097b2e87ff5d040037f79c2573b310feed35bddd51b392cc57ff88987d6b73c4ee56bebb5ced00844c1c72bd05346cdec0a52557ae188b29c8f2706cea63682e433012c7ea7b35695b1b93543f7b24a7333ca10b330556849649721e87468f35f78b309684f227bf14c9972147e15e9cc6c4a46115c71c23869ad5d9d1706f0c8d1afde2d4f9517a25c718141544b861f038df7d0aa781fc0a74ee064ded26e09ca8b90c00484a4134896eac9190642111c37aea48bc94acaea0a654002b8a9c392c1109258cbcdd529b85b22b3f7072c0cb9c44f7d5d735e8bb59f625cd2110990eb69729853899351b1459d962b56f7c860e1d03d75815167d2bb1e7dbbcc2660409bf8750c729901b690314a1fb4905b3315ed46e78de73877e5fe0991f3c1d45da73dbf791f002458511797b091e57625e217134ccd536f3a230fafcf5eb9f7a405321f44e3f23df841a7023953ec12434d61a4499cdce61b7f3f100adca286ab07d9b5a6195288bc7493b26b21f76f7b65a02cb843facf9705c93e57a64c42a1b2567fc68696a9150208635575527dc92bfa27cb0e21e11ffec23d68167230910043afdf96cf2fa1207e83158e37207996b8011d30c8cee23fa2d32ee0dcc3724000f8cc7843255a50e0f15b477ba30a59263526e06dfd354b515e466e3b7d83eceb8e762fd2aa25c1e90a70f801161bce4204e4f1bc609a0242461492d576e895d2c5771ad14aa1951b42d96fc0dea5dbaa97aeb00b33391d84aa93f41b51e0ece1f69fc4703d73aef4386b55095e2da8ecd5b9d7fdd33588169ac2df9150ef0ec73d23ce9a27a960e45ac7f4f9446120381987e5f98cd1939a99e08f1de1c151c4450bcce2b27044d20c331badde2c628677a3141ef20c51143fdb0c105b82d8e47847bb21619894a854af6fb139cf6bcaa3d3e67ed2e50a8edf7cb1c9022cee77466956f0dd05629abeea14cef611e4f329d1990c6066a807aee6d9f59c6606543a4d9020250d069b4c0a3196830fa9963184249ee65e60b3386efae61f24cbe973001833a4d86a797d3b282a0bfd0f5934625bcb9f2ad9e948a8bc86905254b44e8d2d83da95df4806d5e3b14bb11c964a226e5552fa4353b6eccd122f3e2b38d04f04c66d059cece72c8f9bc941451419e47ac60731dc6b91ee45510c3d81137ea1b467190daff3622eed1a3979e22390413a57e4291d57be2a09cbddec77bd4d15d980a40ff989c425bf1abe48be3ad6ab8a5a17af4c8979b72e395251a26f0a4f7e42c477a368c8e42b8763175ca35b3c62060b1fa93992cfe1521890b46e4754e7b8dca828f0bd3cc6be930dc5dc8fb49554b59d3639a4fb15c8d18568d871b69e617a438e769e3ce907c8490fb35ee65fce2c83645fdebd0926ecd432be63f412f8ba12b2bb001e48aa1b84ceea1cdb9129a843f6272c1ea4bc002033a6c63a721d2928f249f5dac757b7b3d61f753850c35d50f49eb0a380632fcf2432efcaf4c4957c87e69f9a8c41933bfa5933e23e9fbcd26c4c5b1223a6066192021b9d1add075f6b6296b55cfe9e29d38f632cf913663b226322655ea696382604c6dd58f0c7b7546dd5cb42dd1f68ba4e22c23a9bce53e8ec63b9876c5800c2c78ff33e67e2ce8e37fc63517657c7f8f0b49851fd764a9724b9b1318997629007c2a7a8d9d5f43ffc53bc054c47bf05301044e89dce73956f98a605b4fb67d0e4d9b1070d49c0ecf6f2c2d8a4e803c7409316f5c818cc76e64d523da09959ac04423dbdcb0ff34a112345466abf036cdbf3b0c4adf1dbbe2aecc118f237f90347b64a7b695eed32198d6f59a9fd08fb6d47668a93310ad7b54dd205cc06b3a5d9640c57385206f0f90278c263b087e5952cbd44a41a90f4d9240779d665af5706fa0943534ead5b5097d17c12d75e99357cfc1e6c5551693a3bb5212d02e640c89d3b9437f222ce0b36e607d0a29d128415f2df7339dfbdf81787ea8f037784f967dc65b08ff89c964be92b3f4a7bb89f096d7163c9147e15ded1896d29bebb33f00461463478892ad266e49481540716fc4f7e9b0fb4f14bd7761dfeab4cbf1b5338f965484ae684f0f93a377de98d2b79412f8b8a7907583eafa7e9d3b3b6a6b83c3c2411bb5d761058cbd09c975b3a4a4721ad9f7bf4321cfd12fece8a4fd9b61b2af50ba75e72891c287fb6a49a130d09dd53e1b0abf3a5dc9ced533ad126d2a82b6df4cd3bce70516e6e9dbf37cd9d2d1c0373bd9d6f8b41b6da10aa7322c4c66d0fb49310628b76a353f6e3158d6ae4ed9fa35608878bb221b3ce47ef2fc95f4978991db5df2a50ec23003feabbe0b9daf57fdae128577a16065c81e9ff820501862e1c578abb996da4fdc72a825aad433c8ce122c4b6ad0b1d5c5145ae4f405edc045832c12999359d7042b0ffc8cdbcb44081abb9f88b75b5617f5aecf9ae6ef75484c6443506d5d380aaa1445966b41392f797a3554d4bc15e52b60ee932fe984fd5294b4cd567dc733cfccf8196a6850e681a73f26301287503e7190eae483d0e9e6752671053f7ae5589b7a2808ee07d8cc85ffe372385a56216f423538412879ea2755ab8712f471e10eff7a91a0ba696e96931aa0ec374be27082a34fd1be907853b9d5eee07a369f44af2c1a2548a99119a7e8cbdd46ed79391bb48540dd899e4b00947139368c2a40b0930edcbb43836539ba8246b84cc73f9d6613feb52d9d787f4699b9fc1cdf40ef5dd62e83dcedda84c5a84768a334c3ee2006059a68e0450b01be2a726f4767e2d7ee4089c87efc3f47c1be0d1f32d1731e41d5db6e08ba91676cd4ee17951642c01180276e6470af9a53da45815d1fc9860692b9a2edbb485871255c28e3d46407721969cb17634a57e4a6c849aadb66467c4c4b3276a91dc74003b9ba4fdd6343d0063a67af0e7b2b7208f9dae8bf287dbaaa34db6c536433d69ca9c7fd2bf870d18ab1bb10e3b5e02e3727e753c977fcadb3c53dbf07c1343c49a57c58c6911da039c0c7862e5bf3f2223bee060b1427e01750f9a58c3e3821aab549684bbf63625ccc4751019890571ce26c3b8342cdcb64c9090043dae8f527a66d2fedea6824881377c39b1818c29d7acacaa981e6910e2aee0e887a2173e438868e23bd8c88423f978dffa02b12611ad33ca56f14c0bc48604fb36223270c3439d28884778f64b26d3106da7c9eedc20c927e9497c4883730c1857114c98c3c099f1849c132dc2445aa984a32b1008a1457bde9d8b6ec0a6d6b56f2989cb7527c6baf3d8620413a481b","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
