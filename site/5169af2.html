<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11c52f703adb981a59cb22ec69e4008ae158fb13459c680680c2bf9668eb754a61a7a83a56dc250e9817b1714592ab65d13be8a9b626fc9631ef4dcc4a0fa40d3b8f0b6a0bc5a10d9d1c4cf48d8a5da55eb13f7af1036f7d5bab3bb7b1134f11799a7086d009a731c78ca931e8c821efc41d69a89deb4d853a38adc0e7bfac3b0ca583df43ce0bbdb6f1a03f8937b71c0fe988b900400b43567fb6f479f120230fb0b4c32151aeb8c258bea57d072fc255f4b6174c33c820530e0b394aad0af99596df46471bac9fe0fc701568cc0cba416ff9a14317adac1565a9900027feb055a3957b18301c51dd1c040ab1ebed121f753f44829e300e514a437e0d21db4fe7622fd696d0bedebbd47e6e6231587135558da5f607c91cb040d87992eb6939a215da24102bb581d39fc530f487aabfdb0950497d68d6d650a47a272c390a5a285e857d1d4cc2dfb66389393b7eea02f753938622f843e739c03b4dfa61ee850af9a9d05189f122116402af2873bdc5668bacc27ec606d364950996f9279a4681066f51ed0ea8035b5795c2cb60d6ef8f690e2165349307366bca75c932e6668fe9d04b749ec9c504e91bb4980bd7527daadfc6f01688a22aaf51f52d0dcad7dbc1d89b7f54f4392eb1ed8b93a60c710c2abddb8205cc6c38cff4c3e9c7b30a5deda942e58dcb7248971afdf75738c30681e1e6b58c6f1cb852409ea6ac00fdabfdffd1a59e294829d2530e3253286e4907e157cbdfdf2f5c00417ac47db64ad23095858bede5745633aa52a480655b08e0093d8b5cf44603db33f7077445ddd7708e083570b8395fe7fd1c2d2d8117dff8846a232f47eafe96bf9739fc9d616ee704da8e972ca292bf5ccf61cf69a109d044beb9bc74f805cfc54b1c4088a97429109b22b5c2a07d05d499a149f3904634718954d0592d1c4b4f081604d36b10030c503ee72893d093bd556a3c656869b1bf92679d99959eee1f612c67cb4eb24eba50b806652674ff82a769c33e71165804a6a4cbc1ac0c57ee02eb220681be291925a232da3417031b2263be42d237e74f5651aa869a4e09b8cb4fb870edaf2266c4486f851745dccb9076e2cbd2535c0ccbd3ebb6d2258475e69a020e4bc3411ccb4b033f588c7daeeb9d915255721ca214f482e9aeb0713a58854b67b651b3f98c3c9d0a09161df640196d940c2dc4f03da93865dd5145d4e8afac6a187473a386ffb478f03df2a9b9d67f0e773c8bf4808a910a446e18b034d29e78ba002bee6854573f6f3ddff218ff48b02d65bbec7d9dca51b5da51ac9d84d5cc10ed137b0d6a7a39630212fd3f2a90ee766a1ea287809dfbf4478bb0d422afc075bd5ac21df027f1dbd5d91f6c9dfdfb1390a85ebbc455b15a6794b2878bb72f5e720896eaa56c394a48b4ea2d40bc81ae5a8507865a2dafa13725de1e823490116c7bcaacc5addb6d08c062fd71863818ae447676f5ab4b49e64b6a3df4846ce9dc2664dd02b3ff1a8c9988000c971ef01bff360e640053b1cc4a315c972562eac43044461eb2218c9124ac0988325f1255ae86665244c68eb28de8ce78d873eaafa4c473bba8ab53c7e2dadeeea77cbb480554a05f8e7b337079a1f25651282317e0724c910555fbdcc41f5969b96bf4f193eafb1fac2c8c4217638c25a6544471d2178cc2768b52b4ea49fff665a5d73e645d22c62dce00a1e3440cb1f2d57596cd9e7b8e60fa79e4707378ea961f69ca0680c6031db8f5b1f90cdfa6f2c61e928ca4d57308860137baf51a30a4d08980d25908e46dee97eee1e47e7664e1251425c9758bafde1bf0c09dcacf8d2cac38acd2abeeb61789aa9d7e1ec7e30dbefeadeadc39de579ae48d9ec9aae582dd2e17593caf553ed77d90a035ab0191e65faca79e392acf55edbcb91734bfaa40ff760e1d8af6997f1112ad77c97e10a9ad5968d7b711328cec4200d2df00ffb5bbd3c044670df29ea591fbcaa0a0ffff99e7c21dce61ef26dffd4369c6298a6a992708d4fcc240d4ee2fa1ee72328b8d7dd33d8cec0b18af56b4cfbc1a78f7e052c5cbf0a1f692ac21308989e43401d4790aa066699e68bd2012ff2039b24bc46a64df0f2e0993c0c3472557da8f42352591ed534d3c67e932e0c6138433b31c44d6f2538d1694a7992ee70b4913868ee688b9e4e07351420f779c0cacc524221838eaab2c53e2049b775a0d9f64ff73edd993a6a303565c27848317423c2626b47bd7834babb8c2e3a259d3a19adbd830c7bff24d917de07ffafd66643ad71109b0b821f3cf507761fc64cc19ef3bcd14cf53deb5964e136968c0043728f29ee2499fdc702678286f3be0c867b6450e274448a735bf13d96dd900283650f34ee6f6f1b9d7a62254931c701cb9a9cf96dfcc9521b40d5dfece5ee2a92e99cc1988c148d920c7f949ef1eccc8ea32498a212d4386e2a690ad7f0a20d3607284219637f11872ff550d696f78fcf0072d17e7fd0e94a09623c0b3e74f760bb94abdcb529c2fda6bc9879e7eba7267585a572b44ef56185c4a4e84a01d5177bcecdf08efa54080e4707381fee19b1b40ed2f4341ba36ad266b109f1653dfff75c0c04d7cff2f40b53995c7cdfd1777715c1dc6896972e0c3214cbcee25c1ba05ade12f1cd7434c7ead1b8bd10921ab76014c796e718219d959bc2127dc3c539fe9d2c01b27e2ccd15e82ba206c53b92cfbd804d4ec6938f806a802606dc694a3ed71473d298a636c63ca782b5bf8d8b1267155e755bd91923d0b3cdb654ff5ef3614b7ca5873e87ca9725de38e821d280f756ee3eedef0babea469d1879b5d21f63fee0855060a3e56e76a024294e9faee9387b5691f25e4c678cd8ebd77d070ac045f18b8659c8714f5ec9367b0c4126bc1cd514d168d4ae06d0ac1bfeb5d9c1fe2efc12e2978afbeab65ca42223b31f6b4637eb6c28b62988cc8e2b9119546ad5bae357822f05123acefb5f6f6c5886d776d7f452e935ada6dfe3cb074c7665860dff133c6355fc75650b91cbea975c897c51a14d5cb9c3834557cc99b460276e2f4f27aa25d958ddd690397de16df2f091ca7ab63781888188af30847fb9022f44a0bffab89351532ec5fccda882cd8783f9ec85cdc140f3b71a1430c3ee1edc211f3e02b71aef232a25db2fe165837af744c6f72e89403126eb87f12e9670a46f077f006f0cd36243437e1307ebcf08d7e4fcccf201fdb9696038132c7bf0e7d92fc68657ee231117af4228078382877e902b2f8f721aa06dde668d7582d83cd5317cd45814289a42966fbe25e09c46c66180ec732fef2510289db0046e4e107947b985a716d28eedf70550a7d7f7af7d16ce6119d9d5d2cb00c56351aa9f617730f1fa500d602cfd69b86bed6ee59c48da047b042a6ea50a376a6a135516790f70df03675c130e1986ce6752d04e9622654133a48aa71f29a84b17ea323dfe1d11a0bf26ba8245ac4b154aff9b334fef8a267d8a67b4b4d702e5544991248028fee79f502b4eb34467008a1d9347054a40de4f06db0eeb3c7c40dd6403fa4a8be2f58c31eeff105cd663ac40cd679aa09a3038750eb8f1a3966d2f7791bfc636ca90e6f5341286bfc1dcae9ce8f68221c6cf1d800bba0e524edd038ed4c66d4e9c31ab41a14737f4cc420e5dd017120415dc256a85f0f9fd66c98fca14996cfddb1279229f390c436289756ec304c2114fe3270e4714ada5bd90fb225a80f2640ed978f5ec5bf76593d7c0e14f17447e3166d61f468580f226776fd8c7fd33954f8b7f8ed584ba1be0d5b0f19d779f63722815397087b81300f69ab97287a538842baed64b4f79a91fb859b57b4a49ad9b8cc1344e840f022472e590110cb53507f1e26f9ed830860337c1807dfcf800bc51496530c475d4e187abc53da5ea91e2b6561f2abede463785e68b975d008ad676abca2eb4c62781451b3573a1f73435d2f6086aa5688c42a13c67d17198132810693f24a005cea0838112e0a5491d711477520f605f7173cff4e554139779f51dbc1327740366728f86871cf3639015b8f416476f723a858ab383aadff11cf4e6689b9dda05723766bd95abfdf8dcf793d366161d6deaa4522c486f4e06f8da97d35d288a761213bcbcb13bd1d900e8496ef5f253ef7265c4e487993ae0c448f9a8279bc4ce47063aa4c052d08cf5b60281e2ae9ca8462dfd7873b0387e91098558bce4173c644e77ae236acd4e5f267810f9d7f1bf68acc3b098b62525b6070bc299c0b3eb3c15f26336af8b8162c7aaf1de0731139e0aa96f040cd73e1a268c69de61971bfc96bddde6d89bcca7870f4f98460457bc1773d7210e4e42402eea069e8775fcdce1211fb735e70f9f1d0422f238d04a327962ac5805b72b21000eae69758978568b64e7013429e534e259c8ae97371123813d9dbec9ecc55ddc0957a877646e8ec84c4d401b130f4d7dd6c6280335cf4515af0e2638e85e66285c1de88e683b5d49303b76741274622892824ada8edd2f60ea2dce927946b61d3bbe36423ccd59ee9bd926f36bde72367efb0fc7b07f8d35256c399db6c0cd286093a29e4bdddb575ae729f1827663639457f5f829e5837f158ba67422d2e53bb3b1c00ccddc3ce1b22b3bbf2ef1aaaa369eb22b63629bc3bfd45efbe0163b6c9f30be8b4ba73223b3d6259066151168724d8bcb087371b1389581f7a782419fa3cfd23546ce5a1183c34a49a076488ca99ec7a493a76ec59d8403628721141dafeb819a6d8f6316e4dbc28bd785474d72d7ed5467486e23addbea5fb5dd9e37d9f73556e420bc5097c725ad45702725652dcfa0ee0d653ce52960c5c28edbd262a6a2115fc70881c1f3e0b48b764e96932b237d8c2b0ba54d7b18e0bb368b98ca7dd69a44cdf86bca62d41a6561c7d1ec0b84035835ffc53fc38c32f9f47f4278993c8e4093b1131030cf47c281d48937a6114f8555c008b2c60add4f2684f01934329744e6b8bd62d62dc130a22388b52eeb730a00235fead333cac72518104c4eb38837f82fd79707be51e6fb86de626fd88c9ced0828f770b8e61b5eab893d4e312af7763316e7aab68ab7fc0a1fed787b38684c415d6a6f2cbd9e821affb0fad0af9771a31ca9a76e2efc2b5f50cbab6fbc5310eeb377ccde07fba08f59e8ee9fb878436cf6aacdcb0bf8fb2ba643192f260977338b00da7809b36dc6ba55a037e81f36da045ad87e516544fd8651c836e41a11f5f486f3cdfb8c8d3a1a4ac602fdf6eca52364a3eb65ff2d9b6597fc336743072cff77120a7cd79a97f5afb1eea86979a6727e754c7bf54fc8524a33e0606ef82b360b3fe0c8f4c1cf46d1da1e6363acfc34750c9dd6039543a195ff501b7e3d9a33b1756b5ed248000eba2257847ad3994b484f6d81dc7ff0313eda09fec6cb1b6a651bd4bd6ec2b857b100601f77fd6d2b582cf66160225c17f3b589727d4e689f7533e8d99cbd0107887d8799168a97e0ffa94f62f5d4c8afffd18df8578f50ebaf00c3ee9307ce560eb4b30db91805fca1ca51708b44afa9171aca22980cf461ea6c9e255bd1ada1268cf8af9a4e48f1f79e9c7d5c602fc6455c0e9539b2073b0867d256b72fb2cf4c9dcf2de799917dc820e24898166e0d58ad01b2e1e02c9f461967496f6189a456291c9acd6257ed781a9b66238c3c1ae96f9570053ed7701fdfb2f2ea3cfeda7315603d487c4285869384021ae86710988426f739e63db9c52fdae53fd9fe9ebee07dc128f2ababed1b25058c92461299905723c5fe6ddf6a8192956a281c1b4b0e00b4a843aa81d15a67f60c5f2a49ebb3c70edbfb00eda36c9f8fe4149f1d21ccc5bc2b3143a172587b768a9ec16f71fb7a54eb1f762b326790727c306ff86b82d091e6bdf300cc738a19eb7347c715c112d386f73d2914a0df3830311880ed0764b74e6e657f0a22ea3f8e4f75163a2c3a7c2bbb5f5b8a001d350a14dfafc54e0e39f67e98d807f97397c640f08cb8c7bca0239784636ea5154ffc6763afe8303b71d31ef2cea9ea9ddd3cff39b7a60cf8d830a1496ce34841b0bcaa392a26dcaecfb90461f1cc11a71116a74260261f590a92866b68471daf98fd542fd4b4b4b06c10312ee9c0831829f64f3f211c772a941eb929f6ad1add90d34a59a436a2a9f5d145d511d28d52250323847f50709bb305b82c9cba12c625a98ea33f39187c156071b3a364b19520a134433c7db6b6096290a0c297b470340a55677cad8901a82e6264f56a989b12af6250c1982569c075e9f514a7d8279369be33281e17339523b668543a1aee0042b4d7f6b76c44133d4342b3587ed85672e378ed58c68cb7fc6dd95d1eb08c2578a5ac279d9150461bf5c6f5c4ae151a36c9847f786a1454b397bade3e4e17122ce7489c651e0e5058c58a07c1db4c9fc323e2304a697561c4cf791b653a258b1bde190e353651a7d657bb50fb4f24de897dbcdc9e452e886ec576f81f7810e00cbd70f041347066bdb366e19306ff4fa55a237fbe433fd56c8f23aeb5a039deeb72468daa2c30548ac535a93624fd9dfd8c065fb2329663846ae1929a76a014b608f4a9a92a7e484490cf9e3b4401b999ede2cc9a5717f7a3b814afb6ef1f48cef7084637d13c785330214fbadbcfa6dcf17e228bcf895664b276e23e4601a0f59ceb8040d2be3e4a62e07eb0bc9ae91d40a16f2745938a9b805792ce374d9a01563ed4b13e56c10de50e35bb47798dc401ee3163fbd384e3d8558783013415a64898f1341f7b5388bf6ec86ff5b6c6fc128370e9e9b6d11f3e559e7de7a92db06171b762966cd0d76cac59fd4bba7c3b38fc9286577443a7b6a74e8edf2699527fed7a0289b4c0efce64183e36ee4f9f7f7a50a0bb61d9aa2f3e5a6d4390fa49245ac510daa991f365052cfe7453f1efdad29f8b520b9887d241af1286300443978b486634a2063a52b53ea53557158c61ccdfe51c195c63b856203968ba3041c6a64ab009949daddc112c91c992bc37d45ee31f2e2c6e6a8af66d7266deb4afe91fe3cd611a901253b83893475a050c1fa303609575b212e65e163398f983b6b86897b2420e482f2c1a63f0604203201cf609e3eb2732207bd9bd4b10c098d5520b46f7b5ec0a367a0cd4e731d120f39b5403e14062f45a7d051b84ae5ff7cfaadd157c6063d8f0d26283b2c8e149cc6471790d00d4255ae0e637239118261c02708a7ab77e6244ab8831170fb26accb3b58ab070b2543023911ad6b4507359018a265f249f6a41c6607b7cb760b2d039c63b491834fad7a3cb714f8f54dc2e8bda5ed08c6a994c659cc1ed68bcb0a81b79ac33c6bbd129e5c7616f474b92ad726c33dda3f15dce9ad0ab25259820da0cfbc2bb88dfec4c76cdbda786a7526a3d47aacdc4a35adec448f2aab3a815d140a7523bbfa81eef4afea017da0cd99f1d310edce5adbce71abb838cfd793e0103e12707c597e8d6a02d900c083fa0290ee6a5112d6cc07d499c4b403858964c5340e4903cbc00792e6897206999b6086da825cfc7d1428d04fd6e4a4326f49228127f5e0bcdb3182836d60e8f1f6f05c3cd94fb8768e8b964146c556461c7eecf6a65e9862c6691bae4a3938f515cc186e0a0c15c49b6cf7eb34539cb7b64047a608b06602c1298b7b22d5b3c74a3d6bd445a9d8273f1dc2507a3877000eb1aa79659d0244ae9822dcb6c4c425190f5998efb81531015ad814ec04f17304913703112b0d71bd4af378b3998ce6f99968e5a62468f86a7c75948551b6ce477345e538cef716288bc6936d755dd24d86ab77850f0c82275b7c7f1be0f878b174083c064948a4834df5c8d1ca0d3f35756ca8432d0bfe3afcb0afc6e59a459a11391bceac8621a649462499d6b44fae7fafa71c459d1348e660c1f1f857c3c7512c9f806d90b36aee93576a064218f0aa5d425ddbd98b98e51b57aa4a3d527e480fe2a14e1bfd7aabba0023004c8934025f563fa88eb4b34eec499d0106e934872990bd3f39b4a54fd9b1fb540a0b07b836582e226123b68d51a34c0946c62e865c86c9820b6bc892d63c9947fb680fd0f73aa940763c3afba86288f99ffd11d1fcbf0a0759fa667c4269519b6ade085c44a38583c6b3078bff99a3448ec7e04644131ba4aed57bd4604e618bfe59043fe8fba8c77b9dc9a10d236486638c8b93cf979c1c1c606d84a105c2732f8db5e4cbe7c3cfb5bebed7b594c456d51f4dc94d27d6f59e426aab65b8401b49b8491ae739a342e32f5f9711afee9ba61f1efea577e0bd7f46bfac15e2c88848e5075e92c32703c2c542ba6e531845563673d95e78520748edf32d90afb226028891783cae150df944f76806d6af8ef5ef0c9018b1cfcc83f0d758a7d7cb5dbf6d2189a9326395345cda56c68c17c6afaff2ccdb8801bc46cdd40200edcfec8396a26bb20ce2c58b24b7ddb280dcd4ce811a67f4f38743124b10cba3291c3b92ed810c09b202641fa62214993e811e4e5d7a34cc982e0cdc7b32d2905150912fc2b1d2a7396eb6d12a8c51f9bee61432312a9809ba01bb2cc5ff405e1311e7d04f0c1d1b7db626c04c1d66e2c133e124e9db9b00cb420fce12ba51421b93907889648321ed669142ccd28eeb1ee09c6365d13399ee01d591c59841a58061f213198203c23f1a537db7fc8d03d0f1b797fa5eab1ca4d47c9f1da220d56179db1ef3dbca15725eb8aaca6a62747dbc0330b20d70d7526e56c75815ced0075062111fed5076aed32835934e1bdebee379c38e0815846f05d7b3f2fe0ea2ce189e8b10f59409d3019d0f9a5579b929e784edda264dacc372d9966c396cd9b3fd78d8acd3a1f00da24b7ffbcf7965a2e3d3b2b93f6e7cda15be36e6cf1343224a37dcefe1ef882943e69bea258483b9f5bb679fe3119eb09cb6c4a108a578fe21fbdd814b817006b7803acb99b32ed3d129c1779943166a49fc248fcef2cde2ce63dc9a5a94689d9f3f1db6509630a23d844114df2a4752103d7bb1818bf85408238cb7137455ff8f2a05962fba7b3d399b77cc7f526f6aabebb5d050e3d006421b780b8d76097841cf39d642bfd9ef8046f6b737e4a808ff7414adf26db06339b2ea54b4e634caffa367ac019deed178211d3fa1ec7aeda321c3b934ab6c581d481308a360c61b2ef1fc1da674738e0614c6796ed544733b428f6f4bcc7a4fde9778b9094064fa5186f3bf9b6d2ab8416575e5a673a4fed0e19250d57f470aeff2d142a6c36039d3c6296d78ee1606adca8255a87d3f7a4691e8cedc4ea8bcb1d7e96263c38d6cdd5799c1a4f2b6db382f9cef200f4c06b3aab4f09725728aa070e707695c847ea60ac851cadfdbf0435964506be13e376dfc1a9c2cedcad3d8cbf7e8c15592cd5410896f144eed5676ae6447735c1007d5913a3ae9f6a3f4d8ec9971209f5788d77f585a8b2a39fc9ddc1ddb52c113386349fd932747d5807af0c7f7aff9b3b1093fd7a82b56860972e55e010d89c6dff7ee542ea74c153c74e323045f775604b543a6f4273966738bb248d9c618e61d2f266776453e3b9df85737022dc27ff6bcf1e310cdce28af13822bed17f2ca10e3568cc7fe241b063640138f91a75e9d604fab5fbb74eff677bda06de6fa635e079d72ad7bd3f8766b6d94b2813b37689c2258ca33265cbe4e8a82715dbe49bd6569e5148a8430c58beb7d75a0e4ff1e532193ac8ff63e570dff6783c29e46b75e8513f95175adaa462577dc87f79f4443d7a5aa66342e04bff40eaa6dd6dd460dd56639a351e3de211135c4de5074bbba6a9ad064eedcb42846d8cbb650f11153b04e78766e2a18d65d8a198cf03c28f4d225de79c121136400c4a1af5ff63b14fb4363a701d4a8cf7f32127756b4623b7f94a860007b6f7569c75a64e89214420b0149c2a73b9296a924ae796481ac15b8d5513aa44db38ed7dbea679dc58ddea6ab5685f9e9224de31e5bf22e7a07a94227887f56fd0f90ce11aa5ce3372c10e812bcdf396cb168fd4fb3ac5d70b55681bf8f9bc5fcc19f599fb5f13b1b0b6fb1aff5b55f81a8b6338d9ba8a0471c71a7c6fa87d32ac525852a32014fe6ac624803492031d6e2f9eda0a0d64a0186167451daa3d57b601cce3b0368f4b5f852ee8f303f21587a626835cda2324da300c76abede43db37991654ebaf7f7d592b7f5bed18a47a6d4fe5bb1d15ad508dfdd27a34780cbfca70795685d75d14f1b0d92eec710cdf3234cd0b3cd8bcdfd258292a7372a25d653597ad9b8169f2d7759330ac1decd738ab533f74d3b92f33a9fbec82c94a1299866be1db1a0868b3e166e567e0374b441f8d4d5756cbc571d2080adc320ed96e892d5cf09e51c7b2a6c0926dacd5ffabcb5c088f7f34086f9ec834b0ff3265d22c33ac7c9f3fe4eaca8d7b3ecfa131e16d1be8d4fd0ff9778705e7239a1eb7ab3256e7128ec710f1b8da0f136965aa92d6709498b15df8867e84cb9af3052e5e6d404d1340e7326ec4f03808102863307a495bd25f4972ce8643106f9be663c66b71545f818040fc1ffb868e90ea70b0f42de4b6b97a953945d804b1d02b3bfc590c737669267c531bfa9e50a87d78730b35fa1dc3d2bbe85fa31c14adea069f9e04c32a29ff78328a6e031a7661e68ee93b00d87a280addac9609665267b6f58794a78ca21ce3e2ef359a974855fa6661339800bb1ce8dd695fe16f47d7bb53d6761e07b4590c27a2986d0f97af923de0a828bc7ca60400442867aeca779f96c12a75a83bd3a254da4a4640ef04e50b2587ddb3fba8cfd4eadcc2aaea8117af5a3d2ced6195e348d0d8677b0bff870c543f29f8d79c4bf4","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
