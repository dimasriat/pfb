<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b3d1c49669ba770b02df72cbb3db0444d4126962c069d0e9a0cf6644dfbb334f41d5d1a4a47f1b73dd3c25d220d26cd33ab768e4ec71ec3c8b8d1bdc15a29a24f57adfd09bca64cc474e922f039a79fcfa96540d24ae5cfa8680c5998424a4c98586af4038ea2292f6f6c43e3d7baffcb6414b6216800a806e934c335db5232c73ba28a4b2a15ed10a446a3b1a083ad67b16583f6cfbd4414e2b2b139f0783485055956d30c0d582ff016214755a507ac2bc15f03d65e2730830ff1468b130efc6df90c78d259239f4440a393756c6c6b4fab7f1947c2e128f089dfe556a2bf19a5b8242bdc299b5a23b6f9aba55c8e4e254e1a3894b43897da26f67426679ce2a70dc15725065e2a46854f4b986edae5fcaf79378b6fd92615b72467fccfd91a429b7a2afdebef49b9dbbb9a8fc27350e00b40a17ebe421181905029bc2e38373667fc7137b5a33f052075fbb74d96ad9ae62bbc46639db497b2da94a1293d8236397e5c9e464a39f00e0caa3458c946782132b3dd3f43bfaeed87c99fc03fc154c44fd1d71a3b05bdd422293506d8e554034051ad1837eec4f4fc163a1218a60e712e554e9bba297b93239bf26b7e037f616176c0a18094132da0d6e7606980624d4edbe67110a5d4c49de7e6f37634a66baee862976f9feca6a3d01875eaf454c1213ff4216f5bf9449c835b8431c70e50186c58998b5a9f4485ea843c3e7cd6c3431b34f2ab35f0e9be4fee621a25b6fd7a438955ea5819c4b43c29f27e0a25bc0d45d3ab16b799ed518c77682e6d163b60635af8c23a00c68e9056b590ac8436145a01aabe3a32b0c8a2ef067f2fdf1fba7c449da8b7b28225ac35ab932636d669f1a684e3689b3e440c00ee0350f62039f1304c63c611f2a98eb55ffb7cef847f25c0f34b18c00952a71231b3a9dc8c6f10b38b42c49e253673c1539089e47b286cd73779b414850aa19e38e1044b950854073b6265964d4a50ab26f4becd30cdfbc520fc0d79103c96debeeb82c4a45b969529615cf868bb1237eb5043bcfe568a64bb7eb48182b4f01b29262ffa409da86e74ad5b6d10bb2330c384ff7a7b2d4d3d8f08c79731b121a24d8b0bf62996c50fba69e396fdda5766ee19095879ba7cc90a12e5d94e6be1aa2d811ef0c957feb10a6d7b7e3ae08d5fcf0946b63feb81139f48e2c0484e7cba40a6959bede58ce18fb0fe1ed5b8a4a62de8c3834da406e7f1a96869268b911bf62f9d9647322ffba6656d40bfe3a6a9a1548b267fa0a42ba6ceaf5eccd134b2be63503e3a74c3db91af94dc761a0b7315bd552e6d26e7b1731a157ffc70d6e2b3f57eb0b58a772c91b757a2086ef803d9e927a234239eb408401b17b09a63fc6c2ee5dd0645a4a1acd408b2b318f9b6375210b90ff2f1b01e430943e8840a4a9e2bfb148fca7653031740464ef204ddfda1d97775e61b1ba9f3b88279c71c2bc38b892f87141dc8be1a182a0d31989012acd367b3d11cc555762d22fca9d62b47ce27328eb4d54b996482e83fb4b8c7c1fd602d412f89c83603ecf523311ecce8235f89fc68e17cb1f09427e33bc1a87245d47b8c4feca68d65957ac4da8f13a417ab9823cf42629418d163ba2a2378f3ec07024847e62815fa78b5d5ea9e12f9224efd596a7d84601eee55c076139443ac81bd3ceb64106859d70eebc8b457c8fe07a7472f8afef869ca03b040f6bf067bd2102ddb03981d182bfc5d96c11ef098e4d2047cef42d583833d425ba68bd1368c0dd06b84d5af3b8ea5225f9a3a8a08187475a648ca5f70c85a87281cb7a2a17857b6f6c0a09ec54d5b5154dddda69d18ac381f78bde3ff28313512b8ff170895a0e0f4c7bcd5c2a63c5146ccbdcc0e781d7ddecac809e161fd9ed07cf947c656a0879ffdc16d2f024dc901a16f556b15c08c2a6b3026e1727129d10ae885c6945816d4e18051bb076d6767e75171e879823599793f51b02a9b54b490e8bcd1bc666020385b72adda41471c0eac4e682e28d7602a7476169230214c72318f5a77e7ee3dc7c1aa645d9a69acd193af0b3125e41511f847f98cb057c2bfbb3315fada1d35a76f6f81d4599091cb9af04a372b936a65532895c2dfaf328c3a65ec2a1940b8bac4bf9f2d1d02048fe0622036f6d9aba4c53dfd18bc3f54871ef1c416a79ea42dee51b93f5342c533b09df34a69db47fa99b08c8d12a63466434d0375fc517f74e43155763bfb6da665f3456181a45afd5445b238e3e724aca6de566c89ecf63a417892430c519049246e1b898a26607a24d0c0fa2dab697f635170b23c61f57aa88e370b2e289c44a372afdc4f5ea8c522a5ea305fb6ffeaf1fd85e579e3c95589ef7efb6c73f3f2b7821785be55572a1b476a71e0eb04eb72e023a766c21d93b7f60008a03220968b89a419f152d61d38876511cab71f00ad170810543ed2d15087033683ca0c1f1b3297dac5992ca592dcdbb1e35e866bdcff05e10aff406dcbbbccf8a238a1db2476174ddd577eaffd53ae2e7853ad89d6cc236e07171d211309d8d298b1fb2f41d712eb9fe27b687d32ed6321509d790b4d37f680c00f7a2a5f22fb99970ad7555b7c01967f35681ecfff80aec7b33c260066b3174182c0279ab76a436c29b21f202ee85df7e88af962b08fe2a54cbbea9f1d9220ccdb1b5ea267f1a5f20a6eecae81025c7e4c04ddab933d3d6e75bff1b6aaead8a87d8f97ac9b8ddc6da0bb04a9a58fedb14d37c80f9b379f5efee5d13f072ef4290ca5d8edb951a3ce42933006ec3df9f2aae6728ad9fb6d0bfc49f85f70c59a2c42b0315db9d111cc6965365a8027203ccd1501b58b039a5670b354bb6eeebf97571dc4a9284afd3daeb7c769eb86962ed804a46753014c1929c1c9e8bc241d3174508de90f2f835fd6df36d474fc5f523eb1356e9cfceb4c66fa0a353b471e987ea7d06869d8708344811316b993b6be5d6aa1fe15d1c576fcb5178a9bc81d676f8090541d236d47c3df3ac6096c79e527d59c3445892b5ee6e03096c42b3a7694cc39e671da20fb9fd7ab8081829f59859cd04138117131e0b95a39c5b0c937b5bc459e923b551956bf442196cd7457e64827187a99bce18929605edbba5f13f68aefe933fc1f22c1d4ca8d0c2f445aeeb6a6ac3229df78decc2772f2f03a79ff58927f9efbebb9e81fe3061f4cfd55d791d2814b1f40f57d052d0e571cfaace5ea218e85b6a23502dc45f6f6f34f9f7b6b29d4a6942802709012e2912464676d58cd2d5fd2202f7c6cc0a750067f63275a772906d0db1e0985306fd4b7f2ebfcae269ddb9b81ccf0feb2f5e677829128341fe0966f16399db1ab83d38cc5f598c0960228017a03d3ced1dd6fa8541fcf5ef287a97d19a26e975da8324ad75557a02b48993a31fb32b6015391bb502e864063070e064158e8d1b3a71d0c576b4064ebb7f9e3eb675fc17246f2074b69f1e7b5d6cf663b6bf884780e426b359ba97f90f247ccc1bab5d1843ed8edc73b6a68b1900e39cc15b77de45eb1473aa52b3d55cad4a68751933c80f08943536f25b23bb27509de4b85c193ca90c8906a0e70c2343a91b009583419ea57e13bf6f3cf66c8f10b58b822cb2330e5b780e76fe4e5d95ce7579fc3f5fc387997c9e7b10d76a6f9968a7f6cce18b766b92e6592a6ab2c67f24512c24ee94ddfeb411ad72faffba5b35976d469ebaa124a93b7cf63c6060b79e1b8a5e0d392f50fb8a5f849c60ec2c62f689efff5d4008286a4ca1e4b651fb2c6ea85f4de5b8bc8963c1f36bf5604072fc62b58196ec9b5810a0a3417232e47225f0d91b0fbdcaccfdc537b1dcc39ed19d9de932a7f6d88daa7d1d157aa79a26730c83df502642beed433e8a5f9039e498183cc0a5a76c280385c7ff7c55d75139865f20db2f590e565baeb7b90fdc6c3e1e864691bb4450fa7e2a7ce4f67f2c5f6af7be3bb741a63a1e9e7289f108b4ded05ab2e52d3ed6a5f80fd6710f27bbd9fb4fc15f99e488a40ce9ccae9ab3da87afd089647b020e5c4d83c117da2bebd8386e4b9699c87c72a076dbc3fa3ed2f02544d1d5b2e152ce8a9df81499db208ad19fadb6cd1e1577e9bf02194c96bec323ec15d87eb9c69c1f0bc1adbd76d27898cf1a7c8c8128c7006151667cb25fd71871cfb12272c64d808a4694c6c4e3fb09f00ece8797d1c98852d70673f5c9c390f9c925b104b9a00ff02b8dba1c5922acf8dc5a86510d8198403a5e188b354dbb4ec7640b62802e7cbe208d5c80e9556de8f01437b907596220c1a2a67240f61281679ea78b287276d4d6dbb52fb3e38be57a6e4bbe8f669a7905854a2e930c2fdb85c474590c999cd9c7e07f859ff6acbcdad3ef2fe0c01dbfb9e28ee7873030cd00c10e1e2257914d84dd7d8545c7ee2593c2c868bf0b2cc9a8a3b128e8c359ffa604cd5a3a55f1e4d98913086dbd42bd034d1c9f37d1e965f80b68f31e040172078540fee6d6d507e606a84ce0c124dd09d9de5b6c4138f692d9b09ef720a61fc1e5da2c4940ce2aa3df89ce182b183c83a42052cae0c5adf7077b823075000bfe2ce033265a2e1d658ba9179c7e7715ee5b6c32f01fb3dc78a1f6c4c98f34d1dec4ed25f6fbf263784ee8b3407818b471d1e3be6f34c5b1c95ce6bfe806a47bc271168b5716611e1f94a357cbfd5a3b79196bf0cb3b31aea0a40cdf48b233c9cfd7d51ccc4d5256bc462ab39616f8a80eb584da9b84932f42ae641edef4122d179f1d3211f0fbe6efeb80f6ba749b0b360ecd78f97043e655a7d272126f5c499f9a291794536a129bab3c996c15ab45becd7de147f738d33973372d1a3942bc14c05885998f7d9166ced98a682746efbc9cf76725827b416257ee0d5525c3f1469fa8f5c608e987baf039f8295d4d5fae6e4167e152652c75b97b163c10f215dba6291e725e9803a8de5cf16c5f9eff83dd491ad97ccd5b7130ef439a0dae871917b0ba163e75991772ca580fdc9f3785dd7e70854a14671dc56f376461bc8b47d72fd773da90c4ac7fb33b810427fca4e899b33951dbee536cb96e0565a84377bc33ead97e89942c89e6bc2d0a69fe37b608a76d81676444808cd6108ec56a431409193e89ec37b745b068d988329ca3b18acc02e18cd7aaea4b67bd93c8737d31169d31f4961d99c350243395b655a920986eb719009c821426c416e5c1c19c4347418e48937a1f06d04428aa93fb7319c21363ac2f7ca44320d79ba9c31276140f63b93951a0ae12ccd0c7c8b308d8164adc7539189d9decd380fa9d9700d2d7cb0ed13dfb6da13c41ab752e3bcc945856371ebdac911ad5f1dbf341641695fdbe50af7c6b7cbb0f712e81e04597a455c2874ec46c82e08dc5896e2f21911e637ce86f6f8493293bcf9dee2315a557e6f586174db314df421518f14d0bfeb14dbb503210fc56427f390eb0e8524c85086d069690b3e91b12467bcb5f37cd1d126f99613488fca889ccabbee242ea071faace7317259a0c603f35ed4ebd56399150a178f408b548a4b6cf3b9c6e6eb5e06e5b56c5fe05a3b46a112e32daeada265029cee684f9ab574ef24d0466bb3bc68bedabf2cbc3eb6826dd40ae1836e62ea9d4c748260030de12c85ba5014b7353c587f03b58b232ded4e7d67890cb1ed94ed22c5d025954b401cf5bc29b5eecb793c5d6dc09c4b2730aefa80485b002707264de39f102c4c12880f51e63ef87e57cc43e80a4ec8b351f5e2580aab7fcc868812e6f897db82785aa5d8c44e360a9509315dadaf2c0d5f34ca00a913f87e6a2a7cd5d08f6685d4ea0b4e0fd8bbeb0678c039eee7fbc439b2d748e403672bdd51ef141cbf94fca0b42f6d68ebe9ddc22861179fa17f60915a9d7e9a1ec5fe88516bb03c653e238914d97fc376200ddc9f6f800c4ffe1667a5e2d3638ec18eb827bf4ca12f2ada55d2414d8846d19f6086b9cb84c2e3b0d7379ce4f314c68cf49b034e12eacbb2000e01daf96b4f984978d1c22c13695525a7ee74db14b64de81c12453fa586911832c2103ccfd9b8256aed1f4bc06c37c15dac56c21e5a024acfbb59ab669cfcb764616509a0821eb33ddf769c4e27ae08d5eba40e294cefc9c8343b7e29776e7743a9007d4414ae5f35258b690ee5e74bd7bc196421563011354e55bbe046c0345be91354f73f3e29b0f3715236425245647f87285e97fbf6da77fb7f2c9653faf5e97f49a737739efd9d4e3a4c9ec99b1ddbda3a3df15ee529d05f9e71d82f77aa790d1cf36b5f00cc06d29bb68753daa6dc638b8375bc515d1ee1caa67657dddcc68ba0ea889c5f5d06ea808073beb63da8f02d610ef36d4182e6477270777022ac59aa6fb9d57fc952784269006cca39b9fd398b2689b7c73464db5d624274de0c4b97a72cea115e591f59e23c884877c71dc6497a9034526dc232b6fff020dc34d719e3e6fa886574ecbc534001b54249e52442c9057511a74dc5b33bc3968e9dd36ebda3f9ee1ccf90c24ea894f73ddcea7287862ab57819b92f76ca5283894cee8f72d09b131e0df3f7d4d2dd75dc9924f1a13533d2439c4eba5239c5c409242cba4915d5722622a00cb1407f32bfd2ab1bc73ca566961aacf3216f2b21ad32bdad260775c27208da7bde48731e7ccb5260a966d318bb9381e3dda3bf0e66fcfb517c43c18255476cba6baecbd738d360de65537393397ced782e403b67778fdb1520018652436c4d2bf9770725d73216fc9603bc2a00e9c03e2a4f45124806300b80df52c96674b606d0d88b77402eb40facb8b87d2c8d5892ef9d657c158991c87223399ec458906a567c4b1e173d9b445abde3f6839bd133b22dc1dd5f5c63dce6a5430af7cb00a7d320b0e0165235af07c18a014b9a3c1667589af67ada61873450f5187ab222bf0e889852b1abb384fe2305fc72dffa664eb87e5adeb23717c9b5232b8afd5fe44541c10c9af45b2a30e00209bac892b8c16caac78f3902ebd26697c6810f870a584e87065618ca65cb38044b8f3390bdd8ab658675c06c42c94299b87f05e597e48f19acf1bee30df1517373c55954afba906679a9c7352ea1957ef8c2104370f71663c1fa6000d65fbd08aab57858f0f6d8115a50397a73b1c27900bd8a01736de19a5989651b55cbdd23f6b745d304d9ed132d1edd46485068650ecf86a1d443e97d217b74d2b2163f5856ea4146b4df8249e6ee44d5d5655a502dbe132177dc7bdca51af591bbb2743514ab79c7a6240df7f4e0e2c54e3cfba2cb02f0c999bee42904d47ecc0192ca6cda4c6787ae1d4f2760e180fd11de51f871a53a1ae5f5c5674ce72b29c8a860b1a2ed433a978b1d6d161aff4d111eedc42809716a7695d661f3464bb084eb9b3e144698edd750e6e1418c3aa924aab61e3e77f71925f07ee292a0a6f653948a8ec147824fe9b774fa29ce5e383c4ada0a908ea336f13a6f68faf0c54b48d09bcdc39fca5563065a2546b7e8098370bfcbca9a01600d919f488fab7ff5baa8267728a34254d42e19555a3911a1ffa58d92bf71e12ade3e3d045badcb973d9af1d80296255ff6d80f6626a01efd1373dfe6b9d096a6c974f956f0d22e18dcee7f90969cd39a08b31dfc153f75c02247e4fa0bf31aa74306ac18ecb70852ff05f412ede345a8befdd0f4af4eaaba3ee03e83ce9b897b44e4092f91be70ed6cdd2fb231099ff1d8ed8fbff84d991cbd0802273ef9bc0b87ecffb7de6ee6309df7fa8aeed5adb588a2b8ce1597b37122be6f68a8a5204dfaefe6ba260eb4310179f56eb053aa58f170e6d353cea332d656fd1b3f3d33aefc99088d6b4768a61eacea38a7adc30c3e98a82e02ecb1577189b10f66a1def4c0923646341f21600c6cd2444aba9586b5cad66b17a162ac181607c16d6948651b43deb90f568662759b332022da3b21255e3e30c1c07bf8ee0ea186df4c7a730a2be7fcae7f7b44a127d0081115af278426702d0eb1086c010492862ceeeb208f9be6a5f3b7e82145aafc90637376964e874f3a19be1701f740f735803ab987a6c75c91d263a8906b7f42f0dc20e2f4392605d04b2c8a487ff3be9a525c4ddd2128028965cc1a59cdf35c3c885085f315182eb54d05d2bf881348f565d774b6ea401e31fd0976ee8a2d6a363706d802be96bab70bd41e0a8ef7ceed9a08c25d9f3d612ae41342f79fc1c0d25bf6df7254874e1521cff7b4424b320497e4e19ae47ec0f2fa4957ea8b8c92361cfdbd453a8f90255c5b1728a879a51393396d3a47a25afc0d6c188e28b35e90befe64499330fdcbb7c0693216a04cf435a0b69eb56ef4883eb94b31dd301f1346c6813d55475261675379c7a230aa6970cd4c3fb0e27ca03c85be891b0588884b4bb5f8174f6a3e42770e0e683dc11e8226d888b8f56136c8362c2c623bb15b77ff82486f78478a4ed0c56a97c4b3d87302b02ca9269d77b25d014dafac81fd15ec038f9ed64de2ca91af02d68a298d01dc7fd997eaf9d604e33cb2ffab00d50d13d937a22f332345c579c84a8dd1248a808a3e82e58ff725827be2b5f7512b5fb9acd18132ccd0edaddce71c69fa935f4e32dea92cab6379adc9fabf03e7697958251481a234d1853592179984643ec65441da5d549cfb8510c565213cb64f88df15313638aa262cb87b68eaa667e33a66973ad4ede6fa35ebe1cbeb9182be006045058ceb08689513fffcd40a3de8a9460fed93899048a75fe545fec2d0325a026ece96d9ad9c57c60dc2eae1a32c55cd6c7d445c00ab706f92123b5d4e8c1eb2f57acc70546c7ccb7a31c2067f123390bd686efe11c03f8639b45db5a53200a13c907a56343178d598ec663e087683a1bafe6e72cddd86d188613b370f26ec2c6d6b8f4e2a9baeebb0e3c76bc24f9000e69faf0591190deb8b97a700f43ea1bf64e195965c31f83ff1fb1bd340721b59ac8e5ca72def9066e3a9c99104c7340eadc9d31d4e35a4d3b14969a7246d3fbfdc8e168539d73157d55cf5094b833ca5c8516f4b65b6a48d080ec9935dd196a04bbdcce97cb45bc815a89f497ed2306d60be8c9bfbd8f1f0c079aed01d6fe57d","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
