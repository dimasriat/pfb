<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"355b5ca0ccdaaf2f1c813bfe908716ccab8d73409e82bde159d35e0cb9efc8bfc569b8946f27a0f15440f063afd3bd6231aba7414ec67173d26bdd2e17475ee13ba8b37ea23507632bdd9e9f2a02821d0540a07bc39a2277c8a2ff60c46a47b2769e775e6e345a79a978593c564e0633a7a9b4925e9aec28b1b3c3a20777ef8b0b4a5816cffc5067da0c69d15b33beea3e2fdf8816b6e7c1c4217e485fc6f2182b916f8323c3376dca95f3182944dbda5f03644405810bacf462fa94e713dfecdfffce4565574a0304768ce7266a66df1067c908c8740676c375544be9a400aa6a89a76cff2b26e08e8631d68a451bacaf0f424a54a40cb5f447517ade15b69295adf1d721f61b5d5e84a7a0d4a36ba4195bf9a2fb91e8f0ba213bdbb557f19e6c8216fe7ac82a95f83ae85d797b5072122319f6e23d31586f36eed49f29b2da7e13049cd2c048b59dca8f13349739470b65e5d29bc7328346a9a6f6b48f8f3bd9e855e7a3f719f1d62267f0cb36865bce041279e9b104621f57de27b45ef08c4259cc937d14ec5cec303ebf1d0047985bf9ecfdac7786165fc60c7b40c501e019b3bc8c736b1dd6c975ba58d05be66a2a8c61f7ee1e2c835abe11d8e5158030d82f5313a11827261cad4eb3590262a469414119d57ca7a2c0fcba9b524c6d8cae1ff22ebf2e43e9c727894f5876188980897a65cf2b50a5676ac3deb5f686050f2b7c874d7c6c0cd35a49fe95a4269272e1929f49280b28a720b0fcebb970db0f41d9830a087cf2fc914b2a8f913e564ebbe0ce2def82eafa9b123f895f55a414ae710a2102cf321b12114e948e71f0068e388a468bf55269192f0b890f2acffc046e8055e7bda760950de17ccc72deae465fadd5e90fa09582167c5b5e4fef8b14e9ccecc0bb9e368f558476415704ee014f81947943c1c03a213be36c3968c50004c97a3f7493321f490c260565bfe991915baf6ce87e14415aabcaea5845eafa478986d3201e6a808f92cf1bc96d9cd3065c2e6cbc895893b13c094dfba520d62d74bebb0db0e1a83f0fa78e9c579c324b6e27b870d03b37d0b77ac02269d831a444a86a44b87edbfb86a049105b006b267a010a72c7269e5c0b922c81c2dbaf714d9c66cfdb4396e45ba3e7298de68e34dc4b2797b3d1531a397e92136157e14bf7af0fd536b6d52440dff1c7a0baf785c5c0398ce808f2644c40f3b5092b2a8b58bb36c94e2e3108a13a75dd288d7e3d40c5c1994468314ae90803138fca49d640b91cf850ccbd7fa4658d74c3ec62fe07fc50de2a8a9941d2b5742a764daac21d0c7c098fca662498ac048560c8bdb17ef06b7b0e9af0999bb8a5e6b52851f27a4e493bbc0e4ed9e56a1cc4fbf6392fdcf2fca6b7f65007e527018538657b13ed5b45e52db7c32919abeb217473c5855a88b96b16537a96318c235c43de24e1323e948b80b9d4dac9be5618ae7e9bd273129fe5e00253e2351eea0f5c9abf323409251e4cdd8ab8cf46a3c60feae0769365e4ae88c8142acffad984c8add6515aa782c5f9698e8bae8f34684f9df74f2676bd09b4fc7e19c84b2d19099c3414cfa79ece2422c646704eccc88cc6f63abb41e198c357aa725a65b46d29cd9038c52a01d1bb73b41ae1b77deb97ae43bd470c6de9b83031a1d923b2ea0f36e93add7daa2671596fda9fdbccf8bb9e726a7219efc5b49326e3c3a693c95cb15054dfcc709f185a68780a9fd88851e787936af3023c971f20a17370f401c7e2c5858244781940cc2945227642f44e004727a43253f4f60a0078f57e93b1a3a570ae922fe371330d7cc95cc25b81e07bf6938e85af026a1b1f76c69c5c3c1ddca257f3f0c06528cdb493e64cacbaab6ff700527c9b1d28da2a33952c45e2d656db33991c81b4f15c2993f6e4b8d2d0dfcc52dc76e96df4c9da3c8cbd78ca2d70ee14c8b736e39670465b43c3e0a687912c0fbf2450738dc7085d37380266f1c6f20014cd8f08d834182ef095519284f378784782080bc31e842428cbf67565a0a51c965244ff726ef9e29405513530cd67d9ec0ef3b5040bbae2e2f09f170e893a72e1afa8df6d1580d2458963d44f2a7193d8a33ccc438132cd29bae3caff7b3ddd275c083206bc3e8c2a309054d0776f0970bf6ddd419a49043fd0d86395c34d7c4cdcca98e48a3d19e46cf65758caab92d32de0918f84852a846e497ef8c8734c96173117cf24a6abe455b2f74e5c7e0fd1869b99a87f99e8eb79ce3e34c1ff331d104109353f3d26e74e4f52ee4757bdfcc60dfe1605cff825db75171e563b7558324d518764927b40d90d4b7c21afab0b25fdf72d4fb796b046f760e088302f45817399e0db2880f6c854709cbb3e6992be0869f937bf831f0cfa990397770c1444d0d4ac7ad27ff592c1705487f209315717128885f4072a14c9a182d094e0ee2565a075b71f2a550ce176b300c461edf369266b98865cf647f5ce4f3457d1129005c1802a3c4720240e12a240c6ffe0f99e479c887953ccabda5807b73bc698847d9652e2af487c90e106ca6ad52a0076f39c9af0ac6aaf5b8f86c8a0aef9629b8140318db767a6e4b958861d05225166bdffe3ddcdde30e900573cda90fa7934c78bb49d734afe0992b3ae9fe2cf147e78455f63fea4fb84ac447083576d3e028041fc13a1bcc2a86cc95fed0e0f99a0fb2c8f3f1b4e9b33bb5dd72d303043a7706516d9eb2ba3d264b3474493e8ce63935c90ec95e2be0a6c68f5c48485dd732d0a1435aacd4deb937b912253a3b79da0f167665d4fa92e3035abb8e7f6a3e8a57644af2d54bd91935e17f97644d0a3daac18f5759de9306a0afeba39f9a3568de8544bf8d1defe987b6fcc01fc39c82d550636d928e52425f1ba9089266789828ccb2d795a5494d9cb737316717be8977c91304a6b37c008a4a627632f8a7318c8207577989c81520723db0820259c81018087252cf6a2e175e7a028e1a43bd47f6e467f32121ebb4844da2d77fe51a8bfbe002e44d9d5232a485f0d245fb715f9de818cc299868165aa7d2048738e4a0113d75ca26ed480bc0e5fad71bb700ac1d562f602693983678b25693bc54a17c26976f21b458d34704969325360b65d2f195e303f92da4ef989a235dd634d5a3c09e97df67781588b4c0b0966f2e424be7ba2ea1c00233acfde83ee69cdadb865908d41b83dc4ff24115a22ddb9a5b0eeccf2c315a9bf8d085e01b98503606bd38878ce418f9bf115c5ca58dc58d299790771a56768a9123fe8961de926d26680b35626245984c3664daf1745ca78d5e31c9b53999c211edd65a676e25700fff0f45978d0875f3b4705c19ddf8ca92318f6dfa028f6e05afd54cf7dfdc72b1fca9792f4157bdae781f0ce3d23e66eb2cab631fd00ce7375918d03049811e3efece9ed2fee70d6f9101ab14b8da14d3f10a453efac8b340c4c8cd42d3e5508a3d47ea760668a86c387cc1b5e03ee1ddafa0a9e4f25b31281c865276ab570efb94aee809d094ce684ae2dccbbb8e3bf544f299f5d6695c8a537a719667bc98fc5c8590bafc654a5510332fe163e97fd96a39e666ed6981b2a4551984380deac5819527f9348f266207154efff3321bc4ae278ffba2f0903a09c538c557b5e7b1283d117c262538817846c60894f327661a994ffff29aa299d0d4968e64ecf1deb07137f4fd492ff04f5595ebeb69bf5e31f3969519eb13799ebb4e5602f0292d64e75fdc9b6cb378b0f89ee242e9c15849230c2ddd1a18c76b666c0af349454cb1bf4def562e9291eeabe09441cfe27a1626769ffdc93ddc43c3dc7c4f74b67595fe6bbd397e844d94a9a46365d6e464879456c17b03d567ffadfa433f5502ff38f0c9ccc040325cf2d36fa82d51406f4ec622bf849f29b2de34c4a8a9ed77978e17e153fee29f309dd83cbce344df7b1548221f9208e315a65473bb5e217a351067c59264efe2cdbbc67be15deccc9ee3f9c078af5bb6354a739d61837402f64f9d7547ebb0d2929c3fc7235d50660404cf039881c8ecb1815af3b63669194c4c187909c1e54646869cc3e97f8fcf76f44feb32065d568e808d57fed38be2b37ce7282f271d339c0a2363ceb6d9c290c670e9bb9d37d5bcc4f285d999df2063dcc63818366e8b00a9ecfc221ce5d88fea9f04b4e2ee832863dba048bbe5312f068823964174fa9d57e2d48377261d041a288c7c2ebf17eeb1a3f09997579ddf07b3492b0d0c74f1e83bf328f31e086fd44d40f99890fe0d33cda9f83d7aa466a2b6146410f642e7462e8d795b8dff8b686d6e32a7abdde0696f7bace0ad4d24de966e2408964c51e4235a19cebb71f6416b12d07741cb9393720f67fbd6aa094555b20513bf35ff317f07f464af61b54454711a7b01cdb0ff0834f6a330759d507319416436f13ff6cd583bcb9d69f4e568dca395ccaec8687fc44388ddf4296e8cea67343d9be745d944d3eae860be8120789ad6df6640ff003fd2b738a478248a279604107a40d2b858973feb973c66558ef2108d90db3b484a579cfa7af0fe464a03273a9f56b753d97944bf2232004185642c57ece371a04234c7e0ff44064271400705b1b7d1bd3388529e6b73727bb07c82f74a661db4f39d6b95f0dd110d9de73f5b66dc1515f2bd981b49c917bdea842cc8946a3bb483b19b2d526ce92e2406385d5121433499655d39f0a5cf92180fee5cc2e0bfd005abbf77a25cd81d5f977e1da1bb108d525b5246490705b21a9ec44e92c37d1c6ec46ea598ffa1487f6ccc33f84c69945373656462e3bb532bace56fe37ec8a2a661824894ebcf35b25ac21412b66a472bc9060d49fe6231f5d7420676076740f3f0b22c838eb911866d322e7b3fa1dc636629519cf6bf591b753de21602677ab091c2397fe4280909c86558256bc738501da2c0980ca8fe8b3ea67acea14fd95c7ae28e21a20d5af8d9f876ee17925ea3229f0f222da633246b21daf3b06690024b685316c1f206995d4cd7061c8824a5bef2b5ef21e7c2ce201fac7102c9263ea3879b3735d3e2b1c10dcca8548c56580e895efc17b4e1eed712e7c83f944ec4362b2fb68d4ea0a5041d059b83d21b1f0b5ef446455bd3d5efb0cd75ee779553b52428d8c48a134efb5577332b8c48d811367cf5421f242e6f44bf9c2c45b5cc9e013aa290cfcda6b386a5e0b7e96bcc66f0e4d45f24901ff49b53220171b5065ded96886fe183476b05b8748f0c44658cf660df51ae313470b5287e8fde45bc5169ef2fe6147badcc6d82c366cd5bc5bfdb9338832ee2972a02ebca2cff6d978d672ed163a9e872a286b45a8c5dc913d88f26a8f92d6e49b3ccc01af35d1e37443aa14b3824c50de38c65fdef097fd45e2d794c0a876c5442252f1e355103fac22685d274a771bf7052de17746530f76c638b41f89a99cd7e5677081d2acfca61b59845d0a73427a6bcf330401706e09b79e39f0bb9f93b700b87e140143bedf36550a17343c61d76b0eb94543d6c7de0a5a0a38c502202888ca9b307b894bf64d9c8c77977286f82747b71a9542fa9778309a2e1fe0e18acedeb671a114dea5a8f17b93a4cd7fc51c4a4273e215b13d5afc1ddd68ed08fdff8188f820262c00a87ee11cf8fb4e251e9ac9ba1f4aeefb3c6f6e515e1005a731a8b24b0587857c433e3f67dfd8f8e443b9a759b5af3dbb2b448be719d8db67bdd77698f65e87d695084c578f7d2bc9865241673b3b111e8b81e713626411e84eee150fad17d04fc11ce513be16b5b7bcae7d927f147092ab9984931da43c8039f7d31c0e7a9fcac22c51d9677e4fcd994db38738649dee8ffe30fa9052a459d5349e07ce3c42aa24ba765f02343f76bc1a42ae9902d4d536eda4d7c6250fb85dab5fcd39b246c66abd6ffd2b012fe1075f113b03e44629b8876b1f26e69dbd01ab9e757f71329e9d5c00508cff5e005ba49807e0b80667da442076afd467af994267384aa79c3168610719f9bbbdc4e29b38fa075a8f8bf6e8ddbd5469531eed798a5d231af2d0fe6c000037b8f7893f4c2edb0d250ccf670e8f0ce84da569a295d2b7dbd402f2afe76fee95e4cc5e0615c484f8c84a90d97aabb979177ad6656085f51c553988f8dcf7ebd44addf93a51f933045c0f15d616ebc1d5cb3c25324388740c7b84b31c7d662a0305f6e38bd49ad6026e2065b4c7517a0d062e483479065fcfc191e10b4efb54efd328010f6f56d0ef4b94cb1ac2d45c4806f906ce30313a83b7a265b786696546192f7be959c128e280ee883fff143fb3449932be1afec49797a2f0be50f4db28b39ce968ce95fc4c6f3f56736d11da1256ecf4808208e9e0fc59b7bb3845ab02f335efb6d47edfe75a99e91aebfafee5f00cecf6cbe62d37a134d5f0b631e4134443460c315a9c774f44b8c6b90f8504dec388804b15dd731fb9d9567862ff459d3a00e028de3b0c762152a21ee7c6edfefe372d7250a7894a479f8bcaeb0269541e7d016beb9b0ecb1eb95e52b1a97bcbba90bc4527de9868ec857f55bf9e896433cba72d6f4fd16016b1fba60dc8a48db1b927b96439d6c27f014325183ace10e1617c3c2f254c3deeb51377eeaa1e3f15aef463572111764a137c78b8965002a6ec5a155a0c2d8fe35bd02c372d40da67c6cad3918e80a7e2a8bfba796120e480b9fdf7c1cd2131438558a53bb47c41eac50e520d1b9ffbc87968e20cc5bbdb4d0b5208f3aa86ef1cf9b6bd18182821edcf16ed22c5b5f53e67391e39ee8d90ad4b4ff67c3dd629674113481587fb7b7e11e7e5abdc1c8491588091376149c6a8093ad2ed4fe732ac3de970511c3e3c63a6a2b7707110a5d3d771aa2aace6026854b3fb770d064fe29652ec68528263a559b2ec92e28aeac29e251e4e34915813c8c2bf391054e91505aba25f5f9b989227103498fcf6a5ec60584c9e17e767542db4e8d474eff74585df8545f2abee97460d93e47c78ab5f5825eb5184679a7c8ec6bfb38e75ce2b62415ed93fc7007869129bb37028fd1c05f71a1408fa553cb1fcbcb50a76a2c2afc0bb5454dab668595d0ae1b723dd50a3f145e204350ba9e28cd0c754c1b21832cf0daef69131bb39a51edd23ea9af870b8deb69f4ef469e40209e150844713fe9826352c7e2a10295260d0ee9e147d7bea7d920931a8d304e48a47121eb5c568bebb70a187fdb583c1d941f77217dffab19dd70d36f79801abb886011ba71e269d951a57f0e59c97fd5c6afc2f5feb6b6a4f6fb4bf51d973c09d112546351d77f35b4f9436e316fd6fbb51444f9ef2679cb2bc9cc3d39c32943d869e77b0c6d40234eb5a31ec33eff6bf8fbc3bf62638d070b032a61b5913ba044dd241d46347aa0518c531b147c6824fdeef3e31bb8b2a4e8bf9ffd3b7c55dcc543e6a121156d4c892544d476fc9f0e1c0ab61798641dd889bb52d935b16be37e96f8968fd28d5e57b8cba04c1ffc071d9a67a405698cec709918ed592769cd0a22e5fab7b64655b036bd493a7a70fdaf215052afb19f643ea3e5fa216526b8e8782356a55270156c20107674761f4f912081573a35c1a593977e72eb993a4ce12ca07579b3c1cc1b8f3ee2dc73669eadee08ef02ff82ca162d7340366543dc537383ec244701f5111e71bc8d71a0bc08230b1e90d96e15b16d73c0a990b03a3a9766f4f7cc7bd549113880b99a9689b94f6149095163884ad1385a07463ac903fb37288840b222ab7b1f4b47f9f38927035a683689b6a663dc51fd69b618a6e2548f8ad23adbb0fe287fed05dfb69fe770b4f2f3d8f16afe6c7c486751dc783b6021f04710a0c270b1bd68c8c7e8f0ce3d6d2a0119ffa171e3660d9a16e882d2928964be4b4eb60abbd90d2834c0192b522abf2e64b920726ced2cc8a1fa909b566e9e79488a1da61bf471357c829b0da90a3200566d5a99219c7f72f8daed95aaf388e9003ccdd6db5b5e010ebee66603151d8c49edd15a34c09a27001eda085e29be237f46b1d1c6435a522671c831e372e321d8ab99ae622df76d610556fec2a141b747c27ce7a5a2d17ac6f891d39565ac320423f9790f01458615af0427c3ee84ef170f1ff184f433144e45743b7176216c45665d67b971cbb9ee4a7f5ec26cb21a0df72b53d01932323581eca176504b173f0757842a298f940b1aeb0a014a39ff9e34c7af9162369350366d6b8db5aee68ea4535e491a4dd1c62c7428cffb6dc42e417fd42163be94894113fc8529f1657c1e9d7c8b0020137f442cbef7d551aa6b27ad16eef9c094529c49001082b1f815a27ff012f81e398b4d9284306977f79778bc9fd9a39696d4d6ac63bf852d1b3afa4ad2570081e0f9e8a24ca5ff763bacef5225f6b961135f19463e70f7e8c0fb2c19f79a545fe959bedb33c91922fc7dcb2a1485fd8940554c3d5aaeb5bbfeac1d9b4222fc10aaa41e5a130ece6edf87546b18a58a290a04d9907b590b2beffbdfc85ac1e28bc72260d16544e2c0fff258e40f44e652cf849b05f51d6dde03dde2fe3bed3b336eaa09e48a332b7edf9c9a0f13f413f674ffc3b52143bbccc5858426511ce6778ab95aafb803d01f8620e97e3a4128d29e74608632d590868b11d6faba6f5ad536f95a8b2c8867b70fc3d8e5656c3e41a6dcf738a0c902cca3c3acba478fdd1243b22448aee665638613dbe78e1cd8df421904bc2cf6d6dfbd7cd8283f936bcbe38b56961c458c148816fc439be281c03422d473707e96e2dd6b83df314e80bfe307a5f8f8ba3935017a54ae89ddfb36e465ce32bcfff0506a5d9fb9eb4d3e224266052ab06352a0dc515a0da081c3daba7ffbe326d87df6e7d1582ed33dd26463fc4ecd75737a0c7ccf208c582bf3ec48006cdddbd4400fc94adcbb73840f44a7b5431c8c0d0e6058916e375d53a4177e723138cbc8b0372655a3833b35971551a83e28447c94f1413acfbdd0ce1be9372bf14ef0d4601b5eeac323dd5bf75bdd7cd05cac49be3ec8827f6132aeca0d0d98d333c209dbe7a109cecb0e21ba5e3807be9ceeab7a8ef225c52390e65d9e86c4a46ec8c9a1e8afb","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
