<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5b7c149ec58ab1124e4eceef3910094d9eb2e354e4d1c468d2233edb99b1e997b288265c5a72f142d682867f800b86c0fdb359c0d8c191ba3f16cc4c7da6fb60fd2d420ddaa926aa6cd33ff19d44e781afd93af7ab3704b2f8a6e4a3d5dd9f998425b13f93b1cfdc83be9e9163549cdc4dd61a440abfc374d3078a58bfe2255405dada3c04147690b1e673db6d88498ab81fd1b4b141f1dbecb8581a9cc8a7e794d1cc4b5ec3c4431ba61ba45b26e807bdaa37c593207882939e962f5194ce35d1bc05ddb3140de38e3b74e2fd18b59c370fcd945e3a7828c310b4fee86e1a512cbdd7b18236448b5a6d0ad514d3717191e86d8d6f407d2c1cd4006314f507982042335feddd479686b0ffd1e94ac9a0dcc56a14db009cbc2fa15b5e628296381bc6130479a23cd6d2c8ba2be5214063ee3429bff62955f54832a1612fab6fbb0d8900c471af894be16b975f57cc34372f32e3db30ff934f99e8eab10abe88739ad2cc74319bcdf4c0b5e109787376e32f0a649c66e9aa405dd2e999ae3e43001cd811c3d73d4d3834137cfdc6ceae41230dd18ce8cd14f65ebb7aa17a3616ddd0bfc9b7b8c205d9e8477ae6c804eb8665a45497c20d4bde3daf864bbe9a5a38c904074f81cc2953095f439d5783218b3a7125f1ed488cadf740dc39e305fe9e1bb470da96918ae92f779146ada0116d6813cd8dafa2eb2de86692f95f980d4a70af6ecd4c2283fe94b2f7fc4d20f8959649638fc3fd2a7276715ebdc45957573fc9946087c7274734b6c46255a10c1784f6ea5d9867141c24911d1c4a6a07552f079def09225936f9316a88d6b11b1f8cceeb77769cd3fc81a9b86c7b20f8984fd51f6057cb705b2eb58a8dfd15713a06c2999bd650671629d6c563d18d6c75bff34549321c86dad3ed545fd41d56849645a3d9554da17968f1533560847c027436ada908a92bc887c93322c041fcd7f2c77d01a8c7fb833748aaa5a44ed645c5127199277d8b207d13f022ac981b73c7ef97aee7bfb822028e101a3160faa945a8ac794fbd6afe036f74d06c48b9d13bd4e4911d20f8184fd2654a1d16409afb95a863b07fd25d8953be81e417878e610509bc07b197e53663303f844ae4c67dab3da9aacd262817e5531b10b990d77c044b8a246755e643aad013d81753717f6c1c15dbf59b06f7a232c7a689ea47973e34da05cc2b1068cde3aef3b05a41ccd598f59e5f7ba21edbeb01503c0daea04b8a8593c41cdd72810446b9cab31eab7298a57421c8310e5b2ce53325132ef32e7c302a172962b19f074c68471e1b550b879c3d97d11086159d2739fc7692710c68d6fd116f436d3b9c429a9256a0791506f656b17310b827ebe5befa787f947542219f4c04562982fa2c6dc87f65ed387862df1733f872261da10ce205f400e0aa1edd3c6cd11b5fd74b8c0fac77b638f99b7a11d28c97e797ea9cc52148073e10e01d54482a67510b0fac667a8c7ec5da4b159591c5e35a8912ed714d112580e43bf1ef9a3a9b37406258ab2753332421a5f84f58812db20b5c33a2895655c4532714e582d9967cb6bb6271b31e9e60b5a895d4f4b5bdd679e6d92b001eae204e24bdccef71a47f4f4c58abb8c78fd10b68bdaee26df0e2e686df0c66c3261ee9c313687bc206b802bcc040766cc571ce0518576ac275aa6c47da238a81d2680f1e3536444ccabf70dc0c558f10291f3aa96f6366826d39186860883e16a5e45600df94b2d3e95843195eb10a42ddc80f420dd995e45a10d3365936836431b876b2d996be58e98ae39b705dba107c7a92fb6dfff80080bc45c2956987463fbf3f04e4a3b70f6ddab751d939c940dbef260b5c2bd30be1bb672bb04d7e2691773154ae9eda7f9925759c2580ad8c6bf8c25c0c98fe77b8da340af51b03304b99bd855b804df2ae6ff9126578cf81bc51d111d8e51d93251fdc601a5a08ed3ee601aeb62b163eef27bb115facabe03def144858a5840eaa7d48ed45c0c24d0150c8cbc099ca6d73e68116037ddcad4a5f16d3382442084f0bf0f2c9e438806a1a59976834fb78964707e845d98be6e24160f7047a108c2290cc27c6add9b14578ff3314c9f7fffd6019f5a21d886818fcd3c186bcd7806a2532c12982e5fb71bf7d9142dda5de5595ac552864d70aa841d4121b0d769a34af29e7bac3c02262bca0ee8e9f59f0c551c69cbd72f8a7851be7a5a8a76a481792379d3a72be64ad380574339b361e00919b6dba7abf44938aba7e1882af17218899076c29c547ce8130d57e23f9919e822380830ead1846f0cde72b36002ee99d55c231f5b47c20797c46597a972186276643135834baf61d03be6eefdc66d78a095038cda243a135356b86f5e266e549a4bab85ec2836d36b23ad5733b87a202c493b515cd85104f2ee2d5ba603e276424e23a33ebc75b7a801db2d1fc96ead1be2d252d5d4b9fb3aa5afac473c622e2321c99c9e5f9906294343668089788f5fd6f05238ae496fe4f4d169629ab928df4786c9b5e23e2081a04eca4517e1552ccefc3d22afc6cc6649db4ad868f8d7441924499d22d1428107b275b10e246f8ee5cfd6b4d351f9c164958db6b0f7d1486cbaa8436c09082958b42e8ae8253e75d269d101dd5c949ddca6796572885b9bc38a8f6a43b72f3d50d7d83fda8d2ebe283d6ff9cbafe8a41c0ec438b843cfc7d8b7d3326cea4abcb887c4bcf571376d0a006749fa6abdbf68345977dee5d14dba02e47d6b9db17b8bd06c917e866a1aef56ef5866d82ce526a20a6b600866f7427e19bacfd4b538b46a326ab60c2f8478caa482a7aa8237a385c21621280168515130cb32b68b6d4f965b8b31f22315d57870b2b6ca8f9b8df5d38caaa332e79e50e2e93fb8b7b55c5f5702caa86633eb9f9464bada7873fcf433e99a1b56ea8028d6dea19449cd544b0e607ca2b926122b0e8ae19ba9f465aeeae01ebcfd378880c42a5af6dd89dccf5cb44e4cbdf5dff2c3decb94328534a8ed04abaf8d5c9c67bd9eab43ed8d80640d4cbd3174ebde5a372a5f7b06a22e00549ae0643258fe0725eee574c467469787482dfa5ff1ac4f7766f96eee25616fe1d779767fda686a6c69598de8f2e7ba5f98ec18dd1775e2eb7e80582bb78350f13886762bc7964b9968721f0b62631646bb50a4069c5f1deea1554d32b942c8b0631ecc10045970d32ca5f0f0dc999658035349cbe1198f49f30b74d3fdbb4262a8079903067b20faf733e360d1d3e491df3d4380fcb4f95dbbf889b3e1fc40e201e83a51353ac5bd5ff931726424b4e71bede7a947f510fab73f5e3d8e7a6ffea056e0b38c8952287bcc80ef16c138fcd288ca316974e9738062349a7aea955e6e8dac8c3223768b7d0d1bbf33bb776b289bfe0783db9c3d3f46f53eafa7e8727d9811b89bbe7742d6f00be47026541228acbe5cbfaa9a36e7033e6fbd015fc4c125be86047fc90dfe06e07befd5979569bb92f2126ab5740e8805620206c61e91522b5d51a888d4826e9e613efa9128726ba04b981e8f3cf76920c39a3090861a767bfe59cbda925854445bc051a26621c9f3b624ac4c2d2e6bf1dbef042363f3cc6dee2ebae3a48e6b5636a31391ac8a62d3a610d49b9ba0f8227167c70eaa57141a90c26f6e5640245500829e43e10e12a9e18d27d5677089bf367b8580d14c4a4adee8ac1d716e579311dc54db8a9b6ce186145e53704eeb0ec5b970eee4a8a6719eab0c2a9d2b00da11946e9327aa2921308785198059154f9137e9e91d3fc0420a6f8646c964f7055d348e1bb048e4d37334b007fae14e1942a3d2ffb74bbd6df1607a04c0954dd6c37ec16af9f0cd9c4992eb036183cf1f10c535031f941cd9283213d0895cd1dbcd0250b848857b0f398cfb348a23d7d60bd5371dd63f9a1df883041c375b6ff3ad01361457084a92699a53d5367fbb673e0ed74277caa8aa67fb5cddf6c0d37f033479ce8a44092249a839b06801801d988883e58d5bcd385a543b4d2bc8830f62b50504943a419f6d61498ba432c0fca3b1ab9d19fdabd82a918ec5c68cb33fb1ba4ce357a747c674957386a5102be0b43ad81462f1024bcd09b2a7d5e7f1f805f3443ef0cb1ad0a25d712d1446a778b92e10fce995fdd93f2438ebb99c5d1f2817c442e70fcb1e0300679e0aaa9af5158d5552ccf5cdec10669efc6e383ed2946240672a96f08df0a1648132452d179f2849ea2c5764fcfd22e23e07368281983b069804913ea49ee52f671816e33f771259524feeb084ba277f317bdd983725cfc8f65c00dd80481bf86dc390425c06d3d225a1016be84915de4cb9a4750eb403cf5eabfbce5a1e807b4a958a5d4079357aab545f31391be6d72bf9c3f962c4dda3010962b5fa83ea117d95299cd51ee949bdfbc39488d45a32b0f16ee9e823e0aba90655f335f4d90c07cc62e601777358b1f83e021327d4870db3c8e325abdd2d595dd385e8c1264750146c63b80a45a960078ec255f7593d2f51f9eba7a411a0a99eb18c99a2bc8b26892fa77761bbd6de54f83e12373b8abf55791fc68e1a5c5e64bbe21e42688fe75e956daafcc8747895a9f65662babbd1a0798dd1cb1eb78905da4ba5798997fb78b8d558ef4e1438e88864d627ae8077d305b11774172ae7fcd03d14fcb1aee6f64a0940b312e47dca3a9a0a50145299ef07528509368e674f7b28a93a14a819ac160810207c627c52de528f6a74079e06664b1583741a58b7322565d6166d759505a4cff4d68c88517cf66c25345d7f6669ef8edd3bf907fec97d0a4a9f3b80ca52c31227503ae6a4617d5a343545db166a6d611cbb6687f211c921a3ce37409deda840846edea780cf8f67e166ed787a0784e3a8222dca69d7cdb668301ff2b2019b426f1fdd9f54d9b208f13528ca87d3e8365de7c88d8f96cc588197d536dc4548ce4db68cb34f16cae0bedb331649e34b649e5d1e23acbbebe8cf4f6d56b02d7ca504cfdc5aecae69ed4cf844eb3c2d83e00915af60197028ec8a2d8f94fdfbbbfa246a1ea4dadd15922a8840505c07473dccfcd8b40f8a872bd844e3b68627c5c8d25055c927eb16f712cfaeb663964cb77636d8e578abda267eee55e43cb644876effee4096423fec9318f714126a76521d048a8301b36982d40fa28373e190353bbbdb90684c2449301cc09506d632e87bb06106af4df3abf145704fcd20090da7e1d4e87002d9e50a9fdda0fa8a2401a1dbc5e07b815631298c5d5ab1f39518bca4c5b26bf2f31ed396e5bebe37900634ecbc8698b861f163d820f1199f0a948186e61b2fd41b012e467c3d1740d9b4c1d9ee079f4dc7115bfbbab0a58142e35fcae23e8484bcdb4bfeeb0cb546a98361da82f892bde3b0d4ff34c35d89075efe0afc8d5d80dd339c515a6000c4027cb980c477943e20a91b0793291343a112af5ba32c7ad1ef3733a99cb578e31bd5747e2793ab5be1cc874a9717ed3f2f7fd5b43be6be8b4e7bb060700675b283ca242bf435500347f10acd5d97c8d2647018b7ef5955c75666de59ea511b571069df83099fd5669f7c2c0be2261369a974c6aab3672f1a5a7f3a3c6749194b64611508f340b55696db789c5c1181c6bc0e860a3c42b602a64441e1eed35555c40f419e5edbf7d6a2e11369f615b02a7a6df5ab8617c166ce9708a4dd610d4598a3b3367ab9d1e060d586f575eb9be5597f1392aded84902f7ab10a08e5ce599e816da3c8e0271a04274a9c941e5563cbcb53fe6697b277e738d46d0e194f755cca38b685cd82f750655b8c3792da286eb124022a3836561592e78d105a6a6d33d4d139d75854c57222b3d8f4a802fa32b3def9333e68b55aa1af83b40040c15940fca4a1a814d6c3ff69cea31ba6bc1d76d4d7ccee9873dbb3d59aeace5b1f762cfcb36b560485c11d98f89daeb83cdaea85db959d5a9250acf1f7e2fa5b0a664da1ff5038b313aad8750ca2b96991853365bf4a82e975dcf3b57a63ed6c5153f088a4a7e5398ca25d5a1a9927608857815913c80fce2bb436d6465a0b549617a290de5576043f5e5bb6f4d93d81e11b54c868c2227f36aa3aa67e16696a6cea50d7a500edef891e2c4efdd159950d6af8e38cd26aa0bc168bca0802294dc0149f497e14fd6a197d500fe03bf97a0e65e0973d20a60b7b80c8a11cb7bd5abd6f6c3a3c820e5f8c60602d31036db7e40350f2de2999d8472a286b7cc6e1b87e0ce5dc3a47f340940473fbc60d9f03dfe951e2d9ac9fa64daf989ea624bc164ccbad8a82477d1a74c0034e3a6de6cd48a8c6f94fdd86c9de00f2b7f1716ffd6706a97b513653b82594c5f5ef20fc3a648e75c8cd52ea05e69bb8f6c032bced5460d49de72687abfcb28857529a0ace72062c6d2aaf010e8d222c17bd5efe23b532c723ab978bcb24f5cc82c902809d484ae8732d36b0e22e6f08a5d7d28c764af249e98a739cba17e803f5efda2f11f967cd108fe20af9f7e01405d611e88d49bb4c80f601ac87c0fad77632d967edf6276b071e7f44b7b5be0c718d2d63b5deb22be92582e90463e7656ec190547deff658b29ee9f1a4052c9997f7941b7d2dd079a3cc695a7ab9621212399acd67589c23007d4e9417206d2623e3a3ad2cdf3072109dc0e251725a7ff868040abb9c94b8f82e37929855b24bace8a909f8f59fa95c3a777e563c1620ec912c8d89625ab5e73cd0676a8ed7f655b681db17f9102ed90550b82a48243e5f9a4c2e7de14a4a73c8b8a0e9ccef3057796bf23ac77f2078575cf2fd9116efadfabed910f713d4ae61e46e206c07805fc5eaff3ac3ff4fd9095811b77a2c0bbad129e4d7fb2d26498fcd3ef0d40018cf0b7b5c4f9cc58243ac1a31c8b0ff363c363432f66e3b25c532c80bb216a4c00d4b6b9d42df037a06a0648508f199611fc57a641185eb12cef49ef6041b7e011637264861cf9326ac3f37d9a4f284f9d4626c38d87baca7097d9b5b0364ab11e8447906af509d724eb478e19e96915fb51529cd28cc97be51a35eb71b99758043ce1dc6d5d85f0f6fbefa23d0c4ae8d5405b51620cf87201013e3fed1f975cf5db57a033b7f14505046dc0b37b82f06748a5e578a45108d0b3838334cc338b13832bcea1277b55442ab3b069409f67061ef53163fd6ba0f29820172a70074b573c0f53d4de25ac2c4e05a3db129a7abde17a4432a35f996cc141cb56f946b338817741df5c2131af0352a6f86b97c34b4e38d0279571593b1b2de19bf5a8961b10fba47eff7f43cd4e502073444378fda100241f7a12c7143b57d34d345fadb7e6ddb0de8269f08348a39fe3b1ac12818bc872e330176023972abac41b6a582957ce1b971935f687b675336c54413c94a38b0a6d2e1a318cd1a922e6e83bd9d63de0055bb47c7212e18253aa1ad79191af0032bf58e5d7b51e40661d48a987e0d32d7e81d79bcca2ba3fb04c96a04dfc7856b394422a98984f79a3559e1ad1558cfc006764306751ce3dde98ec02923a977274f8f55019f4e697f346ad39aa899d3cd138171da639f1254b20bb4125cb1af0fc5cdb5022352aca81b9589bb2c6aacb7e1bfc7683d5c25feafea8c78e366188dafa914ef6cd93ebd744d0ea6a3f7f7eb4104c953602413ccb55e0203f68354c6ff2f1d0debd493e8f8cb84ef914a388f70ff55cb2deb04f328afaa825f3fc5b99e00b4daeeed883c3af718acca52453db349076f130b5a094aae874c5560c7c9522520fb0ed1e8fbb0652863bb0031eab048b404bccf7bb82704cb950c23cdd52d34e958965969635fa2503afd244e4d0a033bf98afdfb1d84f299bd0fad518b4e90aca6502497d93a94322c14fe369a66a30c25c0d7c8ffe3826f008f301409fb83deede191ebe610da26577981b582d7263f7a34354ed1e6bf0bddb447a9ab6b0f64b6d770ac4868f757a724e7eecef03bc32c5db1b4c98c20e87eef5753ea222c8420275c912a3ca5d656f6f69fd6365c177f7402794043688c9948c15b25f5078aca955fbd8f1ff5e1adeae70b0ae46b705e05f5ce52389125388ee559475d41389a0bd48f538fb09f7c331c2b4ef87a698e48782b869a5e0d01945409d4fb153c2669e1d3451670cba31e14407bba57d66bfe4a68a8a1df5aaf93b8fc76633f74ec5f5dd8da7df7afa4450d1118fd36fdbf7e631d877a80b07685270a96ea26e64e5dcbf1f96eaa048c6e6917ea89fdf64c706d2a586d78fe4acae8d15c7d50fa23f4e7c3d5910f6fa1a658e6c91c00b64abd7e1c31fa0354c26e8aa20aae2ad6fc38ca83aaf2fdb52d3585550f3c44241b7b5249c1e8c7e36e2fc023ca8155029a1fe417266a253a0ba31aaceb037f97f5a52d4ccca2d0fb30aab183244b9408b28dc1ac155d0d1f7064e57016f17cc8b29bf2e52d375e2fedf238fa5f1d93f1e8a15664fa0de5ef9c5e0a074fc9018efa88b540a062ae517bc0336cf904a5ea238f41b0b4ff2833af28b49f72735d88b523fd6ccc6c403d69d9f71c80c7045fad4c52e2960a4d4f02f91054a10754c0df0679309d5592ced44f46bc9aa2cb629894743e202ca8b6aba31db7be8e9a89d519968328e6b6c8836f813ae4bb649696f9533d45758b3285d1baaaa5ecb0f8d12d64ad72be9cbbac451acb0e01a38ef255b65d452e41714d3bd413120fd12ba4270d684081ee640d30ec7a7836b1bb5c6f2681d3c99d32c5425b4bdd98a5f023afb57ab73d719c8d6cc2ab2a503e3c7a0a89209625855c095e3a4a241a1ac86e4c310712bfaf8b0871d972e0d07f1bcdb740925318058bd6693c08f55d7054274c549f8895b2c0cf2eea6d2961eed51e96d06e20910bdf49002ee73c5f6fceceeabff779ab10bd62361d23c3cd4973514e3aae3b04b1ff72030321d0e2c5d0777f802bbaa85f85489523785f94f0ab934fc853fb3d29a4bf88743caac885f398e85735714353116c6b7a3f635cf9a63591e24c9e699276057e2139da6ffb98a968e156efaed95c89b6fec2340bea94e3e73ee13250d57b1a3b8f2a254aeea8528348a5a459abe2e9306384d0582bbddffa73ba1316b5a119e2370a83ed2876542ec3fb6af0d02e74c101f9cae07cb142a6bf4810d0cb42eea644d58f29aa6979e390012e11aed92475d74b71eea66c89fdd1661f77e811f6b73c32e7e12ae6216ea3bc3d16fac6f86b97f1b382423171bc1749f43713ffbf2cdf70b17d97dccb9fd6dc4e670aa03a0917bbb79132b97725da33d940980a8b291e8d7fb057aefc0dcf57975ac93f4d16ac99b7be029c7f1b7a348650af91fbd2a5429f292e9965f1373b91c9dc169b60c13ab43c11d46fa173bc9199ac984fd79bac53f65b4c4ba3f2389a216b7921c00e16f15bf6906dbd936afe824dbefb13b0608336bdd850bfae3c4cb9c982e1723da9bd4b69b4d504a61a89d1cf73d1dd4945bb03eb2b2c384c066b316dcee223792d92c8c1e764c1f54c9dd054ccad5e26d0e054b995b226395cb8159262a62e7e65a5f9b11d2d8e7972c017755ec518980ab5ac759f2e58e5df1880631f2eb5ab3b29d85dc5983140484806832cafe38ea2884cf4e52cf414074ab8b4c80548c1e094e2ee7e5b83f51755a0493f31c7e104bdb3479ecc856decf671713bd095fc1436fc42bcc24c36776f6d432b704c1b04c8fcc9aa33066f1f66d72ed3480410c2c555b8191574612cc977ca4b391b60897b40e2f13ce7a50b698502a6ca86506346616ffd7b95b1d1356b537ec3f445295cb5cdf3c2ed1e642efdf52ed136bccb727cfa6e2dcb7509a457d9aaf6526f5f6aff73841a2ef2549b4762240852fed91227e1024361bae5a70ea62c9b2b5662f9637f29002909afab5010260b08b814c662ca0221c31acc94b30a52f88afae1187827e87d4c230490bb1c172d91c70824e3202796171adcbc763ec13de9fe607a3e2dcac1edb37ca6833033a029fa9dc2e858d23cf935860a27a39b9c99b37298d96e7937e12d6dea72359f1667d03fd71881124f7349ea3adcb62a30ddc0e327d78a87b60748102396fd2d3746cc66a6c925c063e9dc5dc37557769cdf6aa5ff54de583bf090574f530e8ac4c3cbdbe1768754c1eebec879a46cfbb270468a0c64dce364fd4bff6b8406ad9f4d5aa85e8071f6eb698391b52c821cd58445a85521d7246dbcc83ed3177744fcccd0052d91fec79de63bf91ee2a950b64780f32295f4d27db1f4dfd23427a2c43b731fc909ea7e0d019ac6e6ce88f8dfe0c29a3ca6636244ccf912d43cf9f65122a1d4e0a08e06aaf0c6b23abb42dc77796a1c35ce3fca1d4bf5f54c6b0e7d44843e0edfdb8f745fddc525adb71a19e88abf6bb41f953c95ca295251f2b9631596a078503a212cc9c2c85f4ef50b5c4c0bbd8e7deb7ac7cca28a40aa4745776fd02d1fddfebf410cc9540598050347e93768daa6ff649f63245cabd690a390597a32128995168866873110eb3f2a899143a8fd9190fa9dbab6add4651afbbce8ec6062d50f116d4d62c3d521e04c87ba8d3ac699aeb011d55d1b264a98cb1314509660066f6b30d5e8a47c8968d4187c07263e159e69cc53b179e50ced23a5274a3a9f80f5aead2d169de88f59cbdf8c1fd2233c965a879499c0bba6e91c90ab098a539bf39efaaba6f29e12cf18b539639461f686afbfc260f32468405940d1b340942fd3dd4221e8dcefcdb99084d71b4704ca2e3355044714832426081cff7a789f55f2ad8cf8cf8290fcce5451ebc3a69cc6df8d43b5c2128055edc00b3e20b544c7f8e00a06d4b30a4078f2c86d82efb8912949bd2278fb59d3da8bf970e7f542408d596bc3","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
