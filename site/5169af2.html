<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52ecf120bf266894d75e1e49aca028fbbeec51ce0be0bac508b6fce6aa85d564ee177a77c4a1f838450e051da8f9d861363fdcc0d84241e6ab645cc984056f63e155ac575732295db91b75a4ae5ca38ed21c3dc3b91723d0b9b631a52ebb70a22cedcbd496f2388898c72fb8c8f33603ab2ca7698b164166a0aec2b852bda7ff4ab53c3681bf2df1d6640e7b36aac6cadd10ae562f749c6cdfdb7b94619f0be1784a3a7c911bc4f043bfbfff2ed8975031702447191e014dff6da0ee4d82764cc47503b4a5563599eedcd461a6cb5b01fa6d261e707ff3e5c26e33cd4fb54b8fd3db982a7156769507e620529a22036864818c485f929c733dbc4445a1b6361fde136fa5f7e38676f06f1da06c4f606e7844aa944cbbe814729d4612c8430a22cbfa5c4e632b9654f16a35c14cf1974650573ac9cdeca6a798e4035c93b65b9848d978607fbb7c236629e3face39cc6449b0b857b3ca165eb9d7e1f1212027660441bae3a62c62a52af7a9cfb1b5118638e7af175468ca863dde47ec34d816f8cc230d32361eeca8d4fa81df5f09ed27eee19ec0ca6e5ca98babeec950730539656a8a68fd42251ca478925804fd35f88bc8dae1fa80fb06f7c872181177311120cf701d445b2dd4608eb2e403dba57701ae9b03ef7d5e7b4e100eb5a2091f28d730a93892ebf93fd76464b2691da0c343a7d93201209da169fa6016611b22d3dc340e65843dc72f071e68c08307414428a3d2e0c228eaf0fcd7105f6d281e319a429d5043c79ce1caec63725deb6a0171739121b6656b5856eee81e4c2fdb6d01e0738f6b373be1251290fbd8d65aa222546d59ec26462688823f55d14d37e817576eabda26f3e8ed3b8e521791f4d708cf757e170c2e7dfbf01d0b0815113380f740032862ff9d0e60745704d990acf517c3bd047d4678aadee8ab008da47dd538a802ae3471c6af69c1d60baac0b1a997eafb192134ee09e51c61ec81a322c332529ff5671934671b299c7d20f1dd08059d89d062fd93e4c47f03fe99f00b00c77fe7c139fc11b6906ff159fc980d1603d5657cdf08654e41bdb58108e2047b255ff11caf1b7756c5b411f20fe4fc642a76eac968683ff33fb37320c3294c27906b6d80775d1cbcbbe27074d938f800c6384673bfe0b7831d21f932fb9f929d226590d2ad0d3bcbc586aef223fe235727d171d139ffe0037ce4f9278e9271671d71d29637697466aaf72e2280cf798dceb2c1af0c0617203a2ad95fc78f16de56f21b3226edc21563fc405f5c9ce087e689813c9ce0a9bc27025b7298370853135c2862f968c71fc08bdd3e32b88cfa964e806de15650211117df11150349e511f78ff6c8d84a0820563978d07e72ce68a294103007ea238bbdd94e479d05c680887c27611dda66e83bfd2e157b6cfeb3174fa0d4ed67fe47e298432152128887afbe4fe650f745336adb42ce583652bcedc28a1d55c794d612e813c0616b1e4fc688130d0397150452215429d6a6f47b5664fbe3660597b368a71dbea97bcd11ff65b434ab0414c97688550b827e9f35bf07d3ca69ea9144c3cecac8a3ddd3771e146c5ebf4e90b7f3e481eb49b753a0c899dad86a1f3eec629c039e71cab8f0fddb1841b9fcc86b4533995de866607937ed46a18e8459ca348358f1d1f3b0042daedbf171a2dbceaaaa73fbf5b2e319c60bb6653c51718fae159b9cadcf4c3a13f87976ee25597e4fd094cd99e9b56e95c7e22279567d0c70797415f8d07860450beb8e2cdc04c3c3399275e3c9bb7fb91233464887cf5b8df04e1cb71d710eab45f60eb7af05933d5ab7543b7b33bcee8b0ee77f375084e7d1447b45c4a8eb585ba4d71d71bbf9e02dbe25b3e59d056e00e4e8ab51009f47a25befef2c36715d41dc5f1b16709c1205126022dd3821bd44739c5f12d6991342112bff55bc5dbace3078c458b0c3797ce4ecd7d2397ec861cf8bc7df98eb40e3b8955306575a5a242c6995c5352e6fe6f5fd87d11a19b57f0fa3422ef31e60c4d155856f324f7288e3b1e02b7e2cf1f90ebe996e168ab0cb204b91cdbe1c143070092aaebde98f2521a5295bc36ae4cdd3ba1c0ae4237017708263c3a4b4ed9224df1d04e2386de4ca6b4f487431d61a12f5a997cd9d8f79592c64f78db3c5520f9323c713936683e3e16081bad1ee8e26d7f9175d3a9cf34d7237e92c296c4376aa26424fc8c06a5862dc2bd46601cb8bec6fb3d9d4d6e996a02cb0d2c0bde5bbfe77bbb787b7739fdae897941e58efca3e059a298a2a03bbbcc02411cac34213f0f964837d10697f4be17b577b857f5ab41d9f6c2fd15d74fdbde9202ccd9df14eb8f76e86c179321a33ad235858d94193ec6b473e7be70e47c104a4a4b5c03dda120dafd7c5a3ebe9cf6e3dcf3c02ceda6d836a572ccc9738d09b78a1a7b2c36869547a4468ff79fd49990c29b0a52bad873161fbf9c89762f72d422d529a655dccef20171a98677af3dc427fedf3a05012a5f595066d6490674219be65a7fc59443e53285e5f02028cf3c1ea4d42c67f9cf9f48ad1d314bd70f79b7306170fbdc34f99dda669e1301c8f59fa1ea559429fcc3141c74f1257b4bf37c9037ba04b9368439f41798cb4df82437df80f7312e206793b17c9f26ba75b0649343c1e544c6fac481ad15010d6117f9d087c2490225619dbebb5d636bb2c2868fc5d60260fdeeeae72c131420da22f6c1a46af47a7767f93042cdbb38d7bf65e865e622efb2f0788fb1e960747e7e88e558d7616d450811875fd03368125c0853210d7cb05406b002fbb5618cea162a3e72bdc65e98f05d606fd2fdf230fad572e5ca556dcce91a10a23405fdba4fe3dc75f64e4afca75ed40127f6bd30be43160c9fbf912d81e483f6861568c0032cb4936046f08985c176a4544d0082fe7c005f4e7f049a846a7259f0784dad030f5ea3a2c041baaa1e78c079c53b22473e9d1ffbcc9e697318eff51c2ab098d5dbd68a898c5e21f0c1ec1bc13808640e11d8e7d8046e1b57b3b07fc59bdc9ac4345c0fa09dde79df1db9143a5c180a68478c346213f108f182f253539f2811a5ec19292a66b346ea6d5d4ce821e71cee2ea68e876696f519fa6d03c1ddb3deb4ed63308843d76484dacf16ed2e2282b1b5a6cce3ae1c67a43634c949ff2beef33f4ecb26dd70a24c054a387af29a7fe110e9a14c7f15381b7b5762655699e6bb0946cb462817ed88e86377162dbb457311979d2ee8c2f96f1455a1c473ab40cba5200ca3d9a5d8937d2bc9ba9ac8594941d5f9f850baccd7496e5354f17d133734beeac9d0cddc51e34ee03da139a398ce036ae0490f357b86220adcef534052198a645e820bacfc59f45fd3b8712751562bc64de8f7e0c77914a5cbe325b1bc21838e7b30eaaf7c024a515b51d489c3cc728d51068e39af5ff9878db8e4814d3c24ec0f73dbb1f5efe9cf1b5571c61c4aac6578f266977fe13760b82bf750d2d512256ef5eb5684d1c613185e84a4e1b29555965c7f2e3efabc44b7d531f64853c9d79c71a9af296b1ffd839ccddc8faa6d2c3a248de94628fdf821df8407573b0d275ebc89df78dc3194c6c9de9214bbacb53f385579a0d7e03e9696e644b9ced9379fff8e3f5c27176372bdcadef0b49013124c177e84af4578f03b573233360db69373832e2e7ca9ea29a84f3bfc01886a38f0cf00e283932cf3be6c2d314128487fdb3f9cf3819268126b7b3fa6603353ea1434665c499c817f14b8e5010e6cc90e5421908f2eeed02284faad208995dc4b239fd482bb12ccc9f29ef410e4fd7cd18937133876aaa709ad57159502e72fb548d0a8061285b0dc82c1840a103cf74c96edad71fad9863adb698c8b27b9c05ca4c2de08cd55693f40eb3748f416dcafcbc2d82ff59f6c92cbc3a4823a5014a6afecd272a344e1185aa3b9241b244e1fb2c9f7634236c17438db86f774e40b9ae4db8aa21a62852571c7c3791e9846374e7079813d851bb5e4060fe3467484d8015628da18e72cc1a063790c52fa19a09fe1ba15d2dc151730f213c8ca0a7fa5c1ec3a43ae46f1f16cebcfea14860671bda32a6e41c638b6dbcdaf91b65239424658b58a73baf6097e1c957c332fde7fbcd1da27fbc757a3e7ad3308b210bb8718b8f4d633605828c96ec702560b49688e5f97eebd6778ff7ccad3ca0beca75b5c877b75b593b2cd10a5e22fe1bc9df8ed39b3906fcd4bd56d173651b39190ab7bc02da7d287805e385c632ff40dac67e0c2215bc441670f219cd77b85931dd7afe1532f15a08ba2959cb729401fffcafe97de313c6eda12b773679bc7fe9f284cd065d6c4777f3c9776ea8eccd54805c367a86115b0a61381b1dd19df6627af16654ffd90125112933e1a7585bc19b7e9060d1e19474f725b6dd89ca58b5c185d90bf8912f176c9db26176ee57922eaa66a116f4f04781e2c60a2c6f62975d94aba50a3d43fb3347d386ab52eaa84715c3148709a47313323b590682dec054dee07c96041c3c6546f66afdb87654bda8e6ddec37a5baded11883a8bfdc53a45c529c073a8b79b6ef125f7b6bd41b43ae9f487720e92a9dad12bb7fdc6bb62fe5be6100b6ef953abf862a882adebdbc93967fef1777c2f9e7f710db3505de7298160d310ad93c6b9fb199e7114ccba6ac335e76f606fcde8f5130d08a1a3359a4a52a259b01be2649fc13cff5584b5c719ef264326ba551589a41e111a1bd246166480b218a64e2c047b7bc84564f7f17e75e0efea35a0174703da08dce25ba347304c1f82d576f7f68719d63017462517e600406ae3d17203d1035ea15626707f20a0e886ef8e1474f25c0b83cc2d906774541ea166f8b2499ffeeb87a3ead478f36c8089967a4d804b3c207f909d8329d6a349c0b18244cb7a9b04f31793cd58b9705d46bae92dc515c6b96fbd985de3b771dd998a6a3996f98048d48d5560f4c3c0fffae0635f2bc92ff53eae72d78e6230d5dc7d2bd7fed9e49db5b0179a3c5b467a2304475e7fc928e2b872286db1c16f68cd0bebc0a95eba0212b114896284e8ca16d6fbbc22c64a887eda199e49795f8c75808eba3307556712d55452fe9f025109e898813cfd66ffb7f8d57f61e3e7c6690389ce77bf3fd6652f866c9df5a311ef0d76b331a53b34efcb62a1aa33dc4711401dd5616f602467331fe3688843ed15b9844b137f8e39a1764b2329f1ad89353d14c8f11cefb328bce242f268b8f7982cf897f160cf5197e35e0bf5a04024ae0d810e744df1471aff7115d0a0154e344c87d590698900414cbafb3f1788ced14c957df5fb13f05f3399926d87464596b77783e7a20389662a4ce073fc79589a067c3ebede554a2018560a5f943679819cdec2348c904e039b9969a27658b2cb92913c8c23998645a65104548638ae1229511cf4e093cdc7e08ffef6c07dfc2bbf26048710a70909123240861d0178df522b4b53ec919c433ef1d495180a486b5dce74e9362df146da3ff9d7b467c29675fe88b1a310cefca3cee15c9bd4de0f2029fa6ff2c2b51eee017af8e603c73c8754dd91ee73a1778aba26eefac6093460ed7a07c550c8aa178ce60168aef33d1b02a0df34a3f88f5f9a12a57a30d8edd596ab3ea713a27a0e938c705bd0d789b4c3da5700a36e739a0f21b87bb20b43bfad2c21544a4438f5b237e7f98f871a39cea412ac869ff926ab34fdeaba4b5c985fecbcdeb1968d54f64cad52b14fa8250d47c4d202e4483b9b87497a16e41822e96bc100cf5140bb3eff3fb2152ca48fe98f1fd15a786a51fb6b902602f53e1b6edaf7ca72af40697cb70d7cf171a1bb391dfb4c0c8b5820df03e64508486b1b177a78099fcced50b3ecf47898ce092f2db152d010ad8ebb21bc6df3c83560677a7c9c8d7241bc8c6ea4c2c48bcb44c9788dc145a84a1729ff1550642b7f817ac51ad13982a3c3c79d1e6a0916a5818c41c2cda48732ae5b26be34225cca9da3740e00d187a94e3bb110ed14f3828b7c55ce05bdbf08117d119bd720a76c6145b58220d23d90b894ac3577bbf8a94b69f022cd7b9b2192267a35c172380af36cb2f3371710c9dbf6302311f4f80e7aaf80462758017dd36adc07219cff2703ec4c8f1688bb53560eae8d67752e7a604baf5908e4c8d5c7640007aadd94447a1159f0061d316c6772b878475571ed795e55255ca5164513063e4816271d8c2ab56d1974983deb521fedceb9519095c637e0042e1d44bb9c51a5c5b3195b2b4bb84901b9ed9743af852670e5726a2555cc3bbf17fbd7c9d15bcb8f2a7af3ae26c7942b60da32522a885a1943e184006ddd2f3297a0914bc9853fd59ef652e0db32d899fdca476054d25453fea6a894b0f9aa6ed2ef254c051d5199b456eb233f0254d29dfa50a3cf0eb165fa0ef1a4b8e436869251f267bb50b9486f0660c01ccac33fd7ce49a41c4206984430db7e346d0393c644846267cb699c0e70ed618edc70915624555e92dd6652635dbffffaf6b74034ded33b840a741a7258875a125430b0da21339996d426cb29ae56f9a3a2740eb3eb9b304578ff601a9c6859cc05d2a99464714bced59e0b60096bd9e0f0d8c81154909c509aacdf78a545674736785224b1632ad12b8029253736198883bda89eee98447447dd0750f6bad0b5d945d5caaf9be725f5e37a853e69578817a863b20852ed72e933ee8283814e21979e28d8a0caf2de49c852c20c39c1028e115ca5118efb3dbb235c74880816a52dfe1d09d00f498dfbd66d4b7ee6723d0dc2754e2000bab41ea904dc408035ee288cbe3a337f7c04fce2fd342c0cd695eb4f34b6dbd7ae3eb5e6be25583b7676e76ab3104c864825cb691a2bdec9d331223364b15d5795ebf09453cb0ee0573b9c3d85ab070e65f30d66aa84ac35c441026900f6cfb495d6f2c6ab87304884450bf14c7e5cab5795306d6376d1fff3aafbbd9db3370d410e7d7cad8d24f0c54f181bc4fd85d752f627d957d9cad158ba40a724c86d29d8dd2fea088961356b285fadc3b58003e71a21e450a703d225e0bd811a0799837595e0da6112fadc120f41efdd581f9f6e0023569e162866a9b01fa4e128313e9257829d31a505d9cbe5a673f6e95775a03f0a078e54bed7f82079a4b0c9412e46012c8667805fa00f40a70685e2f8f12271fa5f3c796f68332939e5bbac5ac7fcbef5925b0a4ce3f479ffcbfe235502a350d54caf06a8f98846d88d797ccb487a74002ca3c4d0d9516953e2080252232d9803e3e83229633124e555c37d7d80de4a3bedb16da705763ceeab38556e48e9599dee6a2aa593114ce33663b57a88013913a130fafd2ac391c940dcd81dc1ccdf01b4b9cdf82d9b0845b9bca3a514fd9b46edd2b01a762f1e265587b37a3cc0e7f65bb78dca52413650f209557be391d7174e5726875d61c6702f0dbe7e78c6ca83e6cdeba9cc0c1532b5c3a3a09aef32d55349bc50c040b3165e158560adf7c55a76136299a4723b6782337377b9a7441d8d60d5ba6b161f6d1aac008e8a3275181a57aeff24e6d3fec90a92bf2480dedced081146f2347984eb2d47c691964e85ecf36372d9ebb5cdefaa2c55b796498c1839d334975649da7435c73be5fbba3dbed30d3edc7dd59d91d99777eca28a49e8f0d2d6196f80c1736e94839205af75ca2e8f0b6d90645a81ffd401d9072997ce0ee27084d26ae8bb0f61537b0319f07480c3a347e0367975fe5a1c525a2fa6669adcbe118b1a8f4112e8c6ba44d637d8fd385d5aaeb0762b8bf5e1eeb8d6f531302efda8ab8a54de88ff74af791774980b7b348c08e9a71797d76d46710fc661ef65ea0333ad86ae1d8487f3316362feac03b8f7c1f8e9b88d995c878171ede86b4ae8c7dbc65551e357eff2b86adb330b5eee395ae53922cf4724765fdf6d42123203eae427d14df237c6dda60b8ac9a40f331d6f55fe2496b803cc3bf8e990b4762f63d031793e2609cb8e7c4868eb4b806c6d28319dbba900fdf97cc04a587ee02c36bbf75903235c6cb69856c1775be4a7680fe0efb91eb2c806afee125a809d0548c631bdd94f9e68f79725eb193e0f5716669f02f73329ca876dcf9de645e102ee90199fb39e97587bc773ad7437bd576d0a8c05cb683c857bb28c8aabb6fdb4ad9b37b03d18aba54c673281c494587c8a28587c1c3eaf27cedc5353ee65698ffc724b2e633219604a2105017104d21793e823a3470c10d4913a926aa343f17fe306c20a7d4c9744fe442c61b851b4ed37e829f27f4c6f1266cab4260aeaadc78e5b97e09ccf253642e79bb0c1d88dc74638bd8d3001fa12b27f09257c4544401c6d41355fb346e214fff2f656dca09c85035e9538180cabadb8b4c9e1111015ec3179aef4d044dc7a154f1087f7270c8dabe5380bf6b07bd93795f957240c1a00b9598850bd2bfb3e6fec8f5c16fc3c703d2ee47c4fe7eda4696fdda370eb79089bcbfee4d6667816602c1b575cc683bdb43fb120385c91a75f3723395ee25ab65b43128ea1eb461af29b0a11be2451719056272f0b35f280fa9d85f3067bf838dd8faf8066db9eda6f191cfa4b5854a7e9372c20edec37c1322d23495052de31696e7f46f0d43ad8f34cf0affb59e6f4d45600fb48974cbd9a5b26a9bd23887de7d8c1f191e0f6b444446d664c89db78e55b1f0f35a005cb93f94fb21bef4a7bb3310288f91eadcec81a998e8919cf747f99001f53ce01b6f98e97f8ae183a830b4ed82ef48dd1d814771d2535c414a5a949877f6e6562ad9627fccf898a037ed5ee85d127863d9240f6fe08b45f451c85e7c59017fcc78c7611472481cb82b15e0963dc724434a3d8c29a4ce80d26a3142a10bd425b0f47c088dc985e379af7d3b9ee05c2be73bbab7713e892351c76408417ef1d584803e1cb9917890251f87c3e1ef56368bd525b4c9b7e5b9beb4507f4db88f04c9d38a36dddbe8088ea048f761f4fb4751c4be6a50ed18eb4104807f94edbf52964338cad3d27b36b30d949d4fed9e924b012a80de0548b7318e6e309a11de8e49ad88acd91060599baffd044845f7749597f44dd357388ed5bce0afc82ab5f4b27a820911e8f4e7856202022ef87a90f6ca90ca42688e7598c828131dc3c65ebf88ee6cda83782a5e991c031f243e6d3e82641d533cdd48041de488bf4dea3e2fa747478861817227f2db3596e8ac9e8bf19e15bfe433f94480c99f92773ce681e2cd1e261518fe230bd0cd1650a7aae7952c140e86f60266778e046c19afd1ea18ea7b7cf03fd479110f0e0316dc2aaaa2d4baa1c879da1f0164f1801d5d59f393c21e2416cba21a371ee62b446c9b083e5bd5e4d5e53d392afb6914d75e363ac2d23caae61f32b618c42f59230a5c3665f7c81fc899117f34ed2760102540beced2b8b007fc30d1c4f5ef8e285b62efb5484e4d112e1bc3b8b53908dfa07382437d94d371d822b7cd83939812d09c1cc32884d8cce48646510cddfa09aaf498eb76a956b78f5af99842822afa28a9fc1a9baedebaeede8769ff76b0d25c47e59c376f1d1262c2cedef956c6c5086b69eab52ccb0cee89fc31f4d427a4af47b1360ccb27934facf0b2e13da758835f5e14a4b7204055fd00f221a0cecb041b2ae7137f9145e8f6f5508bc099531e9413add225264661c83e9c2824cf4f4add75ecbe3b66f6489efabc4bd887ab966d1e2ceb646a57f58543ab65811a5838567e8a19658fd0c7be5661df5ce19773757a8269fc35aed2fddd34c7de03c2d1bd3b2e0256865500519ae481070bf2ef8609f9b2f2198d26e206c7ee92cd554c1c0081ad069d24635c03078478d50cb5ecde900149e85b456b2812f69335db74e9accfc71eeb17c5d96195ff2116576bba09483698fa2a3ea9b0651f56e7d6478c799ceb16d1489272631beea1767579215784255ab176b95291c08455d13883dce24223d20360e5dc40ae3e0ea986cabd040647aeef08b44850923c73201ae4eac3fdc60c44f204dad937e64951c76e253e44c060737e6e0f83479cb42e8a3f8d074001631d4c75e73b45b7280c53b91ddaee82f261f470d70d15f44cc052e0be5c0b316be3e1ba56235b60c10956b7739bcef80b682a22d986ec1dc939687f4c8de0068727e76222e549ebcb2b311284e96b87373f35b7569884cf1c69bf2f11109c8b85f7007c3c71be02011eee4c8c8ecb51926ee7a6d3412bf103e3e9a38f9cac77a84ccc10569ef7e8","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
