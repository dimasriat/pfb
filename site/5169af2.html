<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f82c5c03956af42a50413e61748796b86e5bf6d887150e690c5a8389c7726ae44236224b1f9b34b530ecf5f15f500c543b2ec5b57570e7dc8df231e30bdf0b17d42c7e3bad6e769a02563b0de7ab3f57513bbdcf2a1f4c3d72c599dee23528fa55310548ef3407b3c1643b1d0dacffcae656462c1e989a0af1d1b35870bc7713a96650abeeb963db15e60e4b6bee6127dc6c813abc0b10db0dc80b94b0f0f7f0f1b0f2a70a790b9fa06db8017a2e5092c7051b5a128e9fbb89fb6d2b412de90d751f7eac0eeb6336c2fcc8a7318926c72cdec96c78fe3447cb17608e1d52f9fce711838d31a57ee8158773c27b07deb95928e35f776383867a1ed8b40346fda3dc3987bd8168d9e6f465ce959bf0e789e61a8ba21562caba8778b589e021899b22f8feec4434ca057fb338ef5eb6dcc2f240bf6463f473d312bd150aa5973f4cc1780cc7395e488801db6c307088e60754d0f984f8e91cba44235a923642353c4ceef8adfeab4f89d66e25e904887b1199694f2dded0f084d1285ead96313abf1b7ded8b3d123f264d573f6737a4b4f9f9ff83924af2f871337c5c5566dfdd0e908fdd76b60349675e45afedeb4f9b288bfb090fe1a7bbb3d0b0acb78d97b7cdf62741782f29017a2ed6178bc5e4aec3e9049aa9b4b0e76ad55fe4863b61687d1623b364c375f06a870cfad97490bb6908a89923b3ab912f87d52b126df43b48e4ea247e007bb39f84db6aaded35f9a475a4514b213e051c1e12d62256902120f2a97573286cabfd2e01c6753b2895079349d36ab5b3a01c97ac1a8364d4df42f242e89b5b030163aef341410160fea0a2029c8550663fa711d32b9e1a211bd036f4ac7fb379561a33b00cbd8d71d19615d35f77b90a8849d0669693d0bea4a7d34df354d14a796fbdfe317129d3be00e39f41202302a0afc12049f14aca0cd5ec899cb67709279ab5970cd0ade892bc7835869ec8d0b574132882153f2fe07cf9ffba6747f5e50b73a89d37851c73d71936e1d0120c5ea4143e5472cc2e60abd88a172eda08440c81969467731cb31c78824acb08bb35b5b07133ade47b5549b5a1a0876cb367acc2e15f77c3d9fc8220092a18edf72bd8c609a338762fbe4ba18167d320a01b928af3f3cee9a471f9da046a23fd5261f53ae58492e586a931f0c17b234dc79328c286d47cddcc6307bce1309bb45f68637c5bbaa5c2396419181a55dfa2d4a6bd2270f65a69fae8ae72a4ee2b81c217007d85690bbef6fa5fc10fe20a641fb9fdfb39118bae278b4785056c58750e8ac55995a08de93f6e7f431a1fd75dd9ba45198832cf4abef409512c58cef58ff33d6379c51d82f8a4689820a682f045e8a19f9148502bdaf3c4537195a79edf09400c1cc428b8e0ebfaa4d1cf92498a24abd0c84e4925fee6fca53a8da24a0985ee36b87d1866f87c14177ed5ad232402779e456898f5f8d7f23d49547e66b9143a78f93e58484814a6e90430da3dbcf5b5ed5fa592995d2871687c4f166e024323d2e20d84a03cacfa5075425146d3f8bc0628faba5e5cfa0b278b760a753648108e6a9a64e90c13201385662d6fc04c835be4ee90cf6aff80c4bad6e8e2cc97f49f469a411ecb4811ad32b0ade9be1f11425cf8d3558c07a8ec19e110dd52516994c4f4a86f8bc24e24b4edae5e04adaa43d47ccd4be2edb572308e5f92bcd518a3ebbf2aad82028338e90fcf60bfbb7c3f0c9a319997da9aec9dfa51dc2883cd7e275757a3fb4f71793bdf194a7428adfe7ed0e51964b9ddffd6e9cc477b5b2799c6f119731082df56a833bbf8f5dc98939824b419e32890352b8d6ed19f0196453a33312254c4a789714240341f0fb354557b8ce7ee1518893b6684a34d2d0722bdddd2a7971176bd85e0b147430b618216bd8a3c18bf366eaee0024da238ce110268e90a3c59ebf9da2fd451f3e000a4d70c4e7d97000bfa81a42dcd01921ae462db832a8a946e446d583c8efd5cefe62be6a6cae0093733f6b42f59d9d2f734d287f5dd57e9117f8ea67f8f9f2fdf6758d0d1b5f65ca0aa8fff6ddcda00e2dfb16e3e0a4e2004da24605be24e1b12468d8f7868f8f1632c588bc194ffdbd8cfe7604adac591cf04afbffec49a90f6c4e0c457601690501dc44ea32be462b46f5a6bededefa07d6d1a7825b2d53c7cf6dbeafb8ed7b021c9b41428c0c885d6a25c5003fbd3246111980dfe0d2f9c755ad99c35312e085020ace9fe00d08ec22cb8fc706c9bf8d9716d60ecda94d7d2bab10f15aa1270665b1e6be6352424f692db28488fd3b63af1f1c39e5203237b3dea2eedfd0abaed363a7b9126d0b3f50b7a05c635cb97302dd60eb21f27ba92db884fa1a3c7cb89f70cae8170cb00533f725eba1b4b35d8ff858a9670c679f6a2f23551fc6811f7bc28eacaef26d49505cd83fb6cda0c41bdd172ba0133cd9f439cb0d56b69792aff300cbf5b9b3a536bab362671a470445be84510373317c71e2b476d739c509935fc1582b7ff06fe0ddd22d54c6a87803e56cd1c651d522417cfd46573c4840ea7210e8b4b08ac932088105245eee2528c285aaac51ca8b09f0572f6e62bc5dea7e693d5ce7922b4e5e30e9b42b9df1049c86f57de238c12dedbda4dd307154ddd10008017d6108850027b991c0789299846f5985b9799ee07e9445f611018085bf83216942b276afe017c62cde2cfad159d3ae2db3af7fd45abb01c384c45d029158f607789af4ca08af0aecf8b44bac5b88b4e4bcd871fbdbc54afd66812e1b97dbda03b4670b3d3de0e656001f9c73ae39300b28e2ffb999273908cb5880bdf91428b30bfca25230a703eaa02ced99e7e94a36f722d23d068d8985063aaeab3c648c4beb806febbaa2f1c7f0457bd6ac2d5747bac573e6307e0752cdf44e08c1a3c9c069f4e42e8f1196f863fc26e3e00bfaabc2b5dcd97f3a52b8274216db22499812f671d351a2c6fb9e482f679f4c986f65945471e821a037c891b358ce2ec4b5f83f7bab8315fff454a920f0b40b55c8c8c2240a5f1f4eb49f2c582c0527f99e46e1d25c8d400659126ae641d295dd649b64f78781b9f0d879f1725ef8119f01355d0379b024ed36835a49a5766c59cbb2d987f116fedb63d4b7c6b3d5937506acf77686941e0d81c5b375bf791dabde4cb4b924290a595e7e2c9a4dd4e9d854186ec1bc94124fe81c0c51af4353306574994f6668bb2217e46e603e9cc16f26b6e2204dcd3dfe05417795ee1abf46bb17300006b7a75bc5a7d12811708cc8ff9d8066505c94d18a4f844c3f107c786048705a985a5de16288de23820a68be6d3417974f7a147227b5938213f2a8f3319feb12e4b75cb2d1e39b6ca0ba4996eeac7426f59b79570ba1f48ee990b397e13a007e3adac0529ff09d1df789f80161b2f7b2bdb0a0b9d188a5e637d0a6b2c280b9de445e58a847bd35d1e5b72c07bd1dba7d56ed9e923493ae2343c9220993dbf8eda0ff0b13840c3b144a8e643e41a9c7401c6440f903d9392b99845fb02baab5c3724c88016c76808a5fc1f0f904f5e920417b62562d99578c8c64d1e611ea9d9f9dcd352431108143de269b8ab57c372cab242feba9a4fa52a877513cd4f64198caf99425167934cfebcd35ecf47ea4839a4f41db1488f8c9a3d2862067e6549d91aac44616d1fe196ee2ee8f28c59fc82ce933a9fb5a902bd2aa793d7fddd2c891fa9d633312d9c49088287b01eb52ae844f3fa2e08d676d4b182c5dc0b315fda1c1b27dbe8d956433175b2e10d040cb146eab0e969094c056c5499a85d3e6cb0474343d00e3cf0b70de949bbd0e98b6beb0a0364daa458bbb88b060b130bef598f64c028f4ba43aba4af812b7d33e1684c2661acf584bb4cd061cb8d6bd33ef9df50a63f99d5cf6d9c09b05eca86b11416e6704d4add614a1ca682153fb21252b12d54dffda64e1e0862dd8d984000afbeb97af8e3fd0fd823902d1427d06261fcbae1ca68f6bda28e3213686a2f587e9aa2042eed5b035d23b1caf5085fb121920eb22b6073a255dd90cf5adba56560acc0895536cf63f9bde74ac0263330c54ef552c3798ca4cada7f23e410ee63f77d6e9201f1d714380c511d96e238a85783eaea783a0818b8701f2734b79792ce5d1ed69fb232f52da2cc0796431deca7b276aac3d36b14a5bc5387182f1eaebbb4ea3e19057bab03057babe43d5a9724018d6b59dadef72c7a29ce392f5245cf0f049703f32364a635706c6fe4f4cff69dba8ace1cd58d39ffe2570b19563a62647fc5c9d89a7678383e11c8ee7a8e23360b202a049c7c123396ec0601c72a42246701d4f28fb3f8e86010e3de53b920d1c68168f1153b762f1d941c4b49dc445758c589a93380f73b067d4328a2a5c4ab3eaa000095846f7ec533fe39f6bc5cbc4c9e8763a95187919bcb04ad7e5a039e40550b15db48bf00a07cbe0d82a1026ac940b3df7be485c664afa0b61ad27e408b2c13e9dae4dfa82dac229c0701d122ceb69ebc9ed40e278f68ee026b62935cf525a094e248244829a8b6f66d880f8f221258d7694a700c56fe112f9c9f7dc8d9f1249dadf634f8c8c98b8f12fbdb1be1af38dc9d4f020c69d30ffe8039469bb31eaacd9e94346449fe352255791b7648c9c5a572004ee8ba6f79172e94b53a61e42ecebcdf57b38d4a7531b462bbd1af030b3b1e8dab5944f68335462f479b2172c087480457b2f8c31b33b903dfe07f67c8d2ccf0651351acf718b9e0083387214d45a6a4c0d8c413f56a74e76fef89dc94aa78c55cc75d0b9da734a01e9ffd86fc07f0229d26c67c651e330c8a294012c1f10f9f0cf7135eea93321779c0bfca6635d6271cd6721db7a6ccdb876a7e9006374d9710f0d5e61040ae08048109dad68ab6c77dc69a91b7a665220fea4f6d8f34637c9190942a7911dd38d0ba215d380ce443126da7f60e8147437fa9a7ad4c70b83c0545f774e5e8a1e0c262c5c864c2ac0c538f87f028b469777d56efad3d2d898a119c562f3bbb9c6557c4d8b1cc6cb473406d24d3ee0ec74a7b74bd67b2fc61a670f4c8f0ca4135fc18a279408631012976eb6937f9481d667e15c6e119e912fe21e211ad511b300ab7c635f5e227ce0d94514feee525a9bd562c44a2a34012a52fd39c420ec46eb346962de26b96d328cb433a34eb793d4fb3a12d645796f296c762468f5b13021a40b2b28fee2b1347ed5a83a5004f62db4d6a40337c7ece349b0f136c6bc5f91bbfb1848c5314658bdc3c9d7f8ff0ccd5c5ff72d77ed9c64a12d0048a276125b6b2ae5d689c729ac4b54f0b4e04848f05f488bbe9031205bc85eaaa790b6cdac0784fbda54aeb3f685b9d415b4bfb71ea96cfe405fbd1281cd4b729287531e9f0349436227b1f938c4186c2f9e91fff8b77a084653f9d03844f283e80216c971f90eaac6a4028b263d735330cd9ff221dd4dbf84ad1c0523ecbf6ea0564eae5f56bb34989f139eb1f707982e112088089be68ccd57c68e001aaaa380f616eb7a8aec559f34933051aa1d1a550a6255bb7834b7fdb81945b8c83a2c63f1cd74f9b54db35ea84d4070d96b06d0a3ad06a441043fe60b1f9458ebdeba8963b6868faf4d36dec5743813fe599a5cd70a5a1449cf698ecac1594ac277417655defd111301c8a45c93755c23a1c76f7f8f303344651cce7478870ef7d9302080df3453f003489d4a2f484a0ed73429ac39c386aef5d0346baf7f71ff6157e442c7ca4a0483f7b5cf55408b80401c315834486ad7425566d3fb8b322a0075f7bd83effd386503b049ebed9acd2f73dc9a2ac37d80cdd9096e79382d2b288a269a09c718f09e792eba51f4f7bcd9ccc42c10d469381605f2a8082d828db12ea68efa4e1b56a15f9164045db9b1a5590454eb4c8c358894df2cd6bba9c69165a17efaa8b8f89e809cf1176bf2e1778c6c237bf11f7f82f6d2559358a9698d7218e7c696eef4ca397902ee914e267eac0d78f6d60bce163e18bca4314a81828bf1929384817700cdb665f54b3d67a17f4d9b1672647005d8dc46fdbf4609e8ce98e8e195f3c452a8ce242b77f7ff0d81e13fbb2133a931f87af65ccf9d5e74c00ce69f9e22662203775f2ff2a2dd0e5a84d92ec4f675e97971ad109b5e508655b3cd366e7a6fdb98750a724454be07248f332a72b524f4d50eaeafe14878f0dd8605cfbe5d6bb31be1749a1bf67ea78dbf908474dec67f1cffa51427a4284a226d2308c5b337ffca48dba4ecf6d7b2ded90b607ba29f642702c29753465f6feed4e623a9c0a7328d1efbbdbb4099198305116e7296a24b5aefba5a0408593c2924de6bef4ae5333320e7604968453c452e6ff5930f13e4edf3883838740a8bce9593530473b9adb60cd2e13f6ba0b66c58f1772f1d98a3182ef8d58b63da7652be0f13a6261dfa1385879c97b12874c79fed75aed8c73f1a7e542482a87b54426cb01492aec15154ffbb464205b624ebba61daf1abd9f2662e0c20438669697919f427cb002d4eb9bb58ea17f6dfac0073f9cb195c922c9f4b8d7bec286e09e34070abf98ff2271c5064a273ba8791117509c081daa13acb936240eee2eb75597346d38b9a9a5af62d6465621a5181cd9e0e038211cc6c1971aa1b368addd42bb31cb0606e9b4ac1d2c18f397086cd21fe04d13e649b0498b6757f74163c0a0f913feee2f26a74c9f397a8de7f3b33b2d56dee0d16ee75fbc125cf23241811f2a6204595090a0db0ed630a7c4901fb22878ac5cc4e72a43c127f2023cacdc71419d0ddccfa0095888eaa19b6e98eb3677b52d8782500f5b54702ea506f180822c0a15434debc6d781a915f02c920554bf0a40c413d1442662bdc4a839deb60bbc6a27cd58648e6db99c27f355eb135b6636230051c1905ab82641f89e8993079628c54c0abda726d86a2f0ef19dc404239cff9be7208c340c1631c4b865786ed9e508cd0731396843da5853f6d8ab0910e4c4468243bd4a82d78675bcb15f122441c489ef695e8681d43a03a8150c1d8b6bf47698e568f852fb025f83a1b9074388913974e4cef5cb153977e28f5871cb5f4eb925273049f4d0d630b04aefb4d8bedacecff5e9023b082532fd8d3868c5adad8ed36f271baad191824efd5eb378d2125f2c966aff18f0526f637b6035081f71880f59aff197aa8602f3ccf790275a923c8c31efe3de3905afd893d4284c669b6172e9fe1fde3bb70b91665724f88cb22cda8a802db16a1c93df7e522e36a7185ca649b8cf5c5c8c4d49f21b66e97041787cc6d4bbd8a89000d629b999e1fa2bcfb210ad60f583cbde72fbddf4017983b88ec636bc025c2c1cf199a24d25850f8638e85ea6aaae84f468ffcc5aea6ab842dd9602bedc8795af80c7b48c857d8b7f12492306f5cba472d92397b30c09658dd10b3551c427c548a8bba09bf2fd849a749ce71ae4d15be287929d1fd32fd90f340a4d6dd960a53c87922e03f42af796edf1f20c47dc1dd5a6faf09fb348b2d7539c4618c7d92657cfb26d5d6292a20733cad724b8e346a3a42b432111af321755ec86361935cf3bfe7a7f602e41ae5b40b9dd32455b5a255c8f381aaca9951410047bcabad57f04be643914bf8d87261c073ab59de4547da347a346b357b1c29bc3797c6e052260ef54d7b288e846434870bfcd0344206b1643d8a37113eaf1256f4d77c5ac8eff2f46b2d668a46c7023287e65693879d4251aeb24af0d635369f4afc40415ca272a9a0ff0915964022b67b3e251776bf6d168ffb9b72baa3bf9db009a4342d3d8e99189f6e17540705c03413b48073b06837dbac0bca6a319d559dcade3b00fed89fc44b54a42aa4658f4e96b4d360acfbb1b9e2ddeb5d03a9c89781a3664a12fc5de3169d9bf13165c7a65dbca68417dd2a255d057d54d57db2fbc88eed654dd4b9626e5827b50c146695355d11b57c41109d8f2ca85f4e3d3ae731e5c189504d35d68adbffba96c159804a39d8aab5aadc9b76e1fcbcb6e8062298a3fa2087749789ee99895b6488077ea9bba1de57f63dbba9f8ca825e8531988b9e97a668820fcfccc261cb9a6b6800197d1199ccc7ef85e47d89ba7ac12aae2317df748f1cec1fa3cc83ad362e95a233de0d6f96e103f7498c11940a620576cea3fc9ac44e15490eb414c0a26586571c667362cad6fdafc2fe980380fc3ee07104704f7964e96d3b97bdb711b06d7703cbe5136b41f835975f14c1bc0993aff5b5f2d7dd46d45d279adcaf29ff723273fd84e42ab800911a2bb7a537e7df33b3b69369a9801f3a205c6a494da71adc9f080fa145b83597930b2aa4ed718e3083b733812dde3eb021bec4377f5ec918811bd6cc9e708b02a1f133cf1b056d08773af6d43abc171730158b962d079be8047fbbdc758878629eb55235770e5e6777eac63da302084103833f790ff0cfc76118d7550accff8fa5e11b9a43eac2c62b432a33f138f92c359c7806be90cfa5e4feec4129f492f994f5134a05f9506fb4f2c42630063a00b233416d664d619c6bc71160995fc7bb41a98b4ef9b49de2881aca321deee86410517125c5362e9e5221acddbe080004a91e8a1bb541ab190fbf2e878bfe12950e066a3fc1fef3336df1191c7d1dceffb37465d74802d3ef7f7be109527a5d09f16a2674ad08b8db9974510a3227a6f63ac8027545de9eaa095f5acefbff41e562380f7b9138cace7f5510f1a78412c77cde9c7f2a9a51be273d27735e7614873033645d85dd9492e47289055ef044381371b69e2e5aa601f21de0cda66df9b0f7734f6aa49161277bb63c6ef3ae56987d5fc6a5dfc46051fb69963bf136f63abf561508a3149ac709ef27b2ec848c839a309287d7d2f7e5ab134d66b1ff3149d557773ea6b5cf8fc7788246ebe985b6abc373f193811af30b2eb17eda8d8c27c7b349bfe318ad189f57ecb8a07918b66992262f2884201459bf7d069928db784f43874814ce9f7d37f1f637a0c61b1774ac3a84b7519f2b7c9d46a5f0e071a596c93df7059577a0430d0a7e7d6c69129c0af42e937b20f8db809f01f5e36a5ff755a6c41ac50dc3e57641b20820f9f650576a984d91225e58bd20e11b925605707d408bc4505e111905fe730af55088ea15f6962569cf6063e4432e2c73cf46e973baca4666b732411539fe4fb70bead4f2fca337b5caadf7d4f1ccd8d2ee2ebc63c87232b9fc1f1711b401b5b1a2d548be7642d77d2ae12875c99fb9e6503f01451d0f6edee0946f6bb8f0ee5d43d25c4864b1186b9c48b312080dde8af5d1a2e8d4eb6b8153304c974cf69fb61a0490512fe589848b1e92ceac0d14bdb224cf7f47ee9730b7bce09df9feadf7ddbd96f7fe0818d31d2de2c7ab491f80d070189e33391bad9856b42d8c771334d198c0bb9125b66a3a9c452b47e277e15a71f1a7f882f5630f14579d0d4a0b0912ca86b3e80df709996bfa7ce52adba38fdd1dee9042bee24d0ec50989db0652b412a3d56e2731cdcdebda7327b0505b96dbfba292acf2e327e9787a0b4d7cc5acb87026b04a00a1e200c6d70960bbbd7007d21039433d75f1adc981ad218a30256c5788c20a3c87171fd72e7b6f8b98f7100bbebbd4e7c28b99b9b50256a66a6a6a8d9f389afb800fe33b2f1a7c977c4ecaa9f895850ae09521b9b277dda72770f0870f9a68324cfb8f7d6260286e9730547c06f2be6b76784706c1d9243844bd5a66cc9856195fbeb0d3c3ad314480a80172e79991b08538d3f4dbc664cfec4bd09c07f21548ccb570354b80ed2186f9e58eec8cc29b9e155cac20a4c2745508148677791275dadcb6f516de8bb0246fddefea2e4f6147601404633d3e46a1677c7909b7025fc1d5032a733ca5c8087e835dc405eaccd2a98ebda86bbc9179d233ee65e1855cf3c99dd2c5765cb84209679f9f67693add9f241abb1ecd395aad63eb7721ccb90652ed28a409249ba1ff294336835a0c2f1bbc3a3d41800086bf5ef8964fa19d2018f7791d6f3ce48f145ee02a42b431f78a43e5b35a76d6419defd1b82acc797bfff40874cdc04a4514889f3f94e18773cc8e102c9a3adee7ea92ecd8fd20697a9957b4f4d9c4ac7b72d4db448c069cf1318f883828c3a84d411a3c7fc1ceb398431c06969be70a3b9707158a6097504d77a619273a199452c144e50943ee037c13c293fd81bc16af2fff27b30155b2d543ba78cd8913661c91011b271814bfa6c77d0aca96d370a3e1d5277a37856384e6e872ba3982f9ef5fcd8023ac85b2a1c2dfe7d9641ada0942011ad154b15180b18e0bb4b274c4909d0e8492f8b73f8d80bf4ab674b01548d13e7d5d359987d3991d2b0134b811d93fe7b868f8c11ff9496f65a8367ce58d7bf247b0a2b78bd5194069d7e79628864df303adb0a68e03b299b5f3791c1c61797515c1f480b3e518939e919eb6ada68f73972e3fc46269a844e72296c7a51343c773ea3e1056c1f962d4c0b7aa9da34f34166f50169fb17108e6b0a2cdd14a27ebf5287aebf6fccfd46ef669b6247ac54cfd73461d52f03d44d303fb5dc4d331f802cb8a1ab7b0f073f338d9606a22982146bebfc38785e4459e7858e0e3341cc61cd645f00995204103dca7ce1c46389d747bd06d8f42b9821edbf894a2ed159ac5eabf03a9a7c8a545778f47e5e85e55819472baeb733ca6c85c8f3a83819f6a6f4a1f391d18d6139d24ba32db1f68cfc3c534bb4a671584da0cee63e72eacfe9c17b53a3f9bc4c984fec1fba4e07fd0c1b894f0d6aebe86595375147f74b9d03294d82d22bebdde3bce2d50159eb1378dfe0e9fd619248ee9c9ddf15ae550151c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
