<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c498e25675f8bc27494cb429cf5088601e11177a63cfb6aac19bdcbff35bb433dcf9b9701dd0f85bc8685eefb167c9494640079ba7cca35853e65d6e3ea5aecb127223d3d1d278f74ff159bb746d47fd348bbb93156683573124602832653010bd7b3b9b6d4ed729d383dc29a8389f59d7682f75d562dd85a71163657a7654f82a71b2bb1ead1be37760ac0c56638fc7b8bb61343741797c30fb1c7f1bacdb21a1d8d0ef71bd95259832ace854cf7a90836910ad3a99ade64d4b06f0081d99d85c4dfeffa510789413c7086b6b1b901082ddf6b76f1b1fa723be63f598137cc8049b7062dda9687402d108c4d929caad3193ef6167ac6fe24eaf235c6439b8fdef3cef28f84dadd6f39340a707a90a4dcacc8f04d1a03b731f2feff5187dfe74e53a3db7aa4a5ea5e628f75f3887fe8cb31ecf907856caaca86c910b87b3d031194053c1108c52d28419495feda7f83c4a78bc4d9e9ec7b39933b3c97ceeb897cb2ccb7d7c709e21aa118b89206182c48c7cfd456d2e48500cfaa4086d0350e71725bc774660a299479c705fe88b26de529b5aaf15c6c007a2b3bfc7cb6ddeaedf9a4d14c6b7c9f2c441ec2e21742b77d2c380e606217f128e484a364dde035ab7635f704b0c445a9cecf569cc9b2809fb251eab07ec329c9810ea63356e0ff096e0d301e955e3d32ecefa67d3132bfd16f90c73634adc4fb4d101a5f2b57fd5eb63e279d7d7c873daf0b0365b2f0a40e2b77648c3f28ece72d36d9ef2e9be35d71d7819f937628cd8ea34576b2379522f1292e2ba35cb69f03853e873d429f89c6214bffc86c84cf961608d3c729cbbd3cb484acf613af501b8ff971630df76034647728b96186a160c7bdcc0b17dd2c5aadc1a86d7bd6cc60ddbd0a8781d3a1d050ec87ed7d8ad5e52c9a3d0f00404e5b1307dbaccfd7b8f441ce4a800131382edf50fb981d4e0b11e0499db1cf1cb536e539bf4c5256c95778705d84ca680941fe901dec7fc46762f9f230caa6069abfd0a0a3e74a9f9397a0968af3ca31300f5f0b29b57c92646655615765659dad83dcc9758bbe27934a61a188c090704cb732ec8d963f8dc6e5e0cd66e225bd37cec98e549dc4182b647189b8ef1929d1a185a50c0f87387b1d3f281c4117a1b4851957500859a6eb3ce2e5aa36eccf0136e51f23b7ed0c9316ef1ca4286dcd30ec00bc5ccb7becb9a6393d386e5faff19fdb0fabfcab9819972866a71628082f52bf2f9b12eac121a5177307069df83673e2863e5160d1ce7c23c28bd79f57aa666a1820f6d387527e39e624acee92bb27c1c541550aaa38763fa03597877836f2c9a9f960c6ca44bc00cc8236424d165a1ef159cf720bd691ac82c92468c581a3eaf614c37078a1ec8b2027725ede5b19138486dce75a36efa2c594b3538cb4dd3012985aebe5f699407e336f26fed907c05fc1a1d040a1099da40b7023e1abea6fdf23913445bbdae444b1bc179c96b42020f79c8d652d9ca7c8c50145926e474af7cfa4013e029ae306e9cd00c94301ce8a5d5e9587a96162ce82b26ea8c142d9fae3f0f4e4324a577f79a28f7c6aa34f82ce060d5dc2e385d13fd2b4cd5dfec05291266db001bf0f03bf0fcd83c1247599b32a54664edcc7621069f02f8c2252960d3fa33daeb1653c46fee721f203819223784ebab783c5e09ef387e013912ef08b9e0dd71c78da005b956997a5254a1ecf41202e7fb6d9a34cf2694fab16623605c6da81e4d33d3b41d7bb3db2dd20f3ee3c3684fe88b92d7794c6c2d90c2bed6f66bb7072ce6958ff3c45bdd0c131693b4344c49a37c14399b1e5cc2f83d58cd977450a4ad6bbe1ccdd313b5e62d6ef79b933c40e92b3a14ed4a82193152caa4ea2d44783f7443138450b162bba148dd614b8b51db590b42c15be11ce5d744e35f6c1fe22605b6ca44694eb0e3cd3c3ea3c97479bed47e933b556cfdcb3497985c12271a82e0cf593bc1ff2d5a138f5bb882475eb8c008e0df61c35c4f1865b4803771c561bc761094e6cd09fd0a39f32797ce6c0e1d853e29e6d3c60f55a77bee971acccf7d5e4a44995f6b31e759f1f7dd6c8155313fafcdf1f5a206972568e18cd6590ca6d9d6c37a043d53521e10d5f4aa535f352ca6101828696c10ad898121e65a268f041f21be739b1b9b46c5c83fe1884deb2ce54584b2c99db1fbb7997b6a5f3af7276879040f8089ab6f602e9c547ee572f25edb962349fe6fe2d58459010a220594ff6a01dbb59f2649d53d0f46e813a296e01d670dccff5565379489dbae086fbdcec613f2f84979dbde97db9cbf20bd315a537862bb5a2facc0bdab18cdc78651cf0e40e58339c9a71a84a34d1227324a827b1c5f3209856d8ad58d901cc3a9e2f30eeb30bba8609521a0063b1acc2d7044ede4bdc0c3b70c848c14784dce81c96430896af438eabc92ec24808bf8708f8d9d762b0ae45866beb10a66e136ce4431f5e71b7123faa39f8b31cd750e34169c55d8c98f5c0120161a1ffb66ffcac7dbcf82d20a2cdbc3764b44dbfed47239dcbad8f08a85893fd57236633fc6a6429c3e580fd76c3e1d0caad9ff7182b0a35c5c026121de22a43cd34e02aba3704f0441a64d721b015c7ebadede760eb2e8c3207045176eed8115e58a1a1dc0824e0586383e7e44a5a090f01c85a79a1f069d7b5b1df10a21968b7cc834546a0dd9d34d3a6ae48c120978624f48526303d2b3c984b70651f809563706e281431ae53a36545a2b320d37db1fea726ea588b2eb6c7799c3c5d700fc8601188f44048fbb401684db5906e72c6891c99a781564338c9399bc7b4a2ea97b688fff4c6fd21b8b02ba5b2bf9377ffcc4920e3ef5d0e9253f0d71101bb884889914aad3e12b8a8eb0c4fc4ad9787228f00a6031988fad59a1641749098135179d6b2e87d01f200daf1cccd71b3fadedc21a9829f842c027a5e6fa056f0f3bb04432b2c23befb452a795d69aff6ab81470a1332d5074090acfdb54a580529ed272ac3e8dcdc5632928e48ae84234b6a3b9b17224754a8d381f2b811b339892ab6434f85443d631ab7cd29e70086b0e5718cafe97efc3b97394df206065a37db608c269cb9a25038643c08295d8d5fa02f4a42ff784ecd78f12c617d8d977cbfc770ee3c11850e3289c199259030ac5fba6f66611ce48eade0970dfda6bd60acffa3fccbe4682b7c51f971b18647cdc008b7af46c7184b05d960d4b70a1c72371173b8ea9f61e71f74e805cb8a76ffe286ec3e6c8938b5ad4f157979d539c6f076e26ebb06fdba7319512b769d119c62efbbfd93961918f6a2c975a46e9d133b1090a2b7c6916fd057d119e950eda139120ea5a67564fb65e066560a55a83389a3ddb61400aa47261386f5e7fca5d4bfce09b4f5a71c6da3bcbfcf9e9bc367d71ce78600ae2473b0c2ce7e916f8708868959d4007c6a5034ca8c632c894c176b7244f9199f45a6515400ccc5b0b5e2bd952b1e552a6d5bb8f36ccd6238bcc72a04a43e4437cb8b1269af2f35c2873a64bc47ab95e1391af0dbb06e7834172b73fa5972553061164c9a0d73870d15e295466350031b30c6c79427906c002cf68a2436f5493cedb4c4fa9095127fab94ded15dcf654c88564762f5948c5ccc11e57e1c070bb7859a843fa3ee73bebb15f62a06b8b16d023b6864403eeb9d82ffbd0d9e3d4b574cde6b40f620578a1ff595d19ee4d57b8de647fbc2271241a24476efe93794d4bdf51f9b4e4fa3d59e77df4d606dc6a15fe8f8241a68cccdf024f325e6ad52964342a6146635bf1849e40e9c52f7d6ea352737f7ea1fbd622b2bfd2fa0e0dc4882071fda681e364b1df9b9533a62eeec3437e6045613980807de7eb9a8494df21bd5fd62bd4b2195401473a979ab06403f98313c1b60ed2a517748c8ae32a362f6ebdae9cbe38c84b8e89ff9951f7710e0ebcac7cdeefeac90beaa7f78d7c538e4c7b13eb13f01f35a40c8ae9f896ed56574e2cc22f126c1ec808c50fb443048366637d04fd5ee425adc602b5b0ba361b63d6e426c72c2c75d15a80e70fccf0bf0c83a1a8adce76459342054c3a13697bc8a4bd04d8aafc04d4482322a31431c65638568706debf5827a3c8c8a3f217b59a0633eb63525ab2b5352433d6b3a1210ccdc57503074661fb345ba5ef77ab24332a5b541ddd51062219df023905646d39e208ffba0adc6d640aecbb4411f85075b48fa3c542d1f3589c160b5379adc449eaf7bbc61def7f75ec70455c8c5f8831471fed06e0fe48ad72b83abd3115c204f5e255b0f686c4fe4f3df56a8c26dc8527909c6ada55f30582d5cc3cbb32f2acef2ad43cd68cf87137ae7c0fcf47aba93a49bc8f09ea53bb2d11176abf961844b3ae2cd9d92fe50bdb927945d63fcb180c97d0ce6edde0915b8f5fd1eb2a2ddc3840b60a6a70dc79883ba617cfedb490daf71584d5bf89fbbda3b45b8d59f76293942b296cecb4a1950a8c134f259ab09e79d8ddf3a7c96a5fdc23a3a76890aea21dda56ac535df4d342ab2305126ee7dc09e3a567374d7aaa5425b13f4fa4adb975dca762d2d1a7e8097cf6894b3a39ddea8e7e2b7fe44f858ae9614141d1a5ab16089eac41aa41f47d12c201e7d8df7e98174bcc36170d4d9e3c6759e94655b8415fc9aa53ef98571455d39d20a01b4e2fe41a68d1730f83103cb8ac3dc569eb7e37e6ee050fea4ffb36833f2c84a77fd94add84fab6593c1cb6ffcecb305922b39a08f8e8b6025fc8721003e2a4bb74fb0e55677b8b529616948cac91b7e897c9c27093837bdc44363e57261b1e2a56662728fbef3426613e66eabf7a44ce74fd794a4e644b74d06144ed623d07a5aabc1100b546f2c7238a0410da54255705943127fc7561869345edde5ca3cb52c3c97fcac68141e8e89ac624c5c0b60371e1bf0d7ecd189147df7924736ee475b83ffbe764c07ade9d9e175e88fff3b5a216dd861be58249a0db999c447c5e40db9a09f336ae906181b3c6710fa05b1c88ffb1676b5191c15da39c57a66b953d01782db9c023f964bc554abae4af1bb9ef56c82ee87a7fd73af06dc85797d57e6361acdd99a9291198dee2f2aebaad2e559fa0060becf96b17ca9ebc35dfbeb97d782960efdc194ff2422d3a8a4a3396a69050ecb6d0ad908837d50f0dceb00cb2e2934fb8c03c484a6f17580d142c20226f2b778fad2db0a7f75b1792b7e7d2981325119c5f8be57a7bd9a251c33f1c03a48714060c962907df56ea18f4792aa4cdaa9af3bbea346af8f0ea291d2fd2c9e43a663a6fd781672e6438c3f475adc21e454cf5d8549346bf70d565c288949e13768476d27d64867b3f5139854210fabf5d601d9e2891121b20b007717444a49bb409ecc8d4078f00b42be36c27fcb7064b10df4f0963823d719476249d0e2ae89d513d6b93389a545f87d640cd492ef7acd35598804c30ff2e43a5f283c0295752fb87cba5e609935320ff6c04a419b5ddcc3e73e1683990ed8b396fdd586c9c79878e6185fa4011104ce339ee77f561facbabf12ae2e0c67375c4b0020d96e9cab408df147638434d130998aeb7f82fd56f14c9312908dbcbc68edbfa850a2759adc18b548c79b5f66aef78d9a3be51b9dcabd7a4dc33582d51610bda1b2b9fe0a7eeae1b127cc15e7c2c9aed30f531353d392a19b9d8bb8f2fdde07c2c9958d2c321d342974dfc7070a439d55373d6cf1170e9e5b4339367566fcc69ba0b74cdc0c10f875811a0356d4a5d7e7ce0571c125c257acbf10f55d54d26a40cdeb6ed51e184e42e5db67609024ff6d18edd01d1a3f62f89e0463cfbd4ae7785d3e1913720a302a02e9422622d785762c784c1867c9bb3994476168062c3c7a7ee39c1accbd563f1e51eef6f225026107d88a413c9547474c446e03a5dbfccef820dc7e0133bedb4016263e207f7fc1b0e8eaa5416c2768116f3356e4c924aa5b6e956a7f050728d719288b43651ed6e8d3081a0635d72edaaf563957592f31017e8cce836f4d6a08f86f0cc37d4771a66f0223f937cb8e5b2b02356220a87d4264672bef2ad0afba8d1d3593edac8c0717df8ed987a7f204eef54100faead87afbf984136f632e12dc82455bb128cd7e21910828c3aa889140206258c5cdcda252b1bc4f5365ca63cd09cddcb9452565abd6296673877226547174409491e2f2aebe2fedb828740e1f095725785d8a262fb8d1a432f80bb978a6ff2396cea0b4aa408b911d3ce1f036e35f7e5ad42e6fc24763487011cfa7c00b55cd901567860168d8bea1483404033cf89585b9a9bba5c32eae53814600698f1383be06b499bd0b81c37d61bc5fdf9f8dcdbf1659ff642e3678c3c895b5561474e6fde7e501027bd91e0d4a75963a6e4ad7e2e9cf656f4073eb5db3b67054a0b98ae13f7515019f3add1333dc7bc0d327fe1966c293471d493e6e64911d27889cfd8243e2b2503ea38b3011b3596f289a47305a49f147ccd292cb4c6a8300b900f6d5a5702164b6a3205f0cea260c0d73c4ea6a306aed6d0bae190c5f5d9bdbe15bb8db92720f5304cd2d18923bec5c34ff7923583c775245efbe7d849d0e2c41bec7d07d34cbb39877d1b01f58035c672b8aedef9f51002edae60420c3f2c231ca99e09690b044f585a0d38cfeeb1eecb869e208048e9ac4d3c12b20d4f41df001574aa16aae360abac3e99efcf2f941dab35d85888ed30755d751c677632332d71dec660e0eed0e4d86f3c536fb4c86f65978316a4e25400156b1200d56e3bc724ab3f781f83c4dca8e5a25a68a2b5071ddf1313b0135c6bcc4982665a0b8753ed771056029fc46494204abe69326ff9594f594f24b9e3a7f8db14f2092986c8c8395c6b93f76d1948f8d5a2fe9f7f7e3fe389aa5c55fbe0ee35b5ec08e763386b2b30c5eadc751471a73578e5c676daf222789f790ecbd0c03a705963ad379f5353d35e1cf12d22950850bca0f5113aadaaa6c71d0b18946560d6cc63269574f68b2ad17b46b3554cef4dcaf8d9c4832437523912f72d3165ddbb770b1a32753e0d753881fcf4f34c56b339ef96cf612d0494cdb0dedca89a8561f116f118e19438de804a67937d353bde78588440c9353a80e49a901645326fac7e141d35b2f59b67f636c668d9959af59b2729a76dd2fcb90b39a75ebebdabbae9a9f16347b0d444aee35a9d2d6c59064a9b38935bbef32193f10ae1bfe2a33acf61165b9b7111c28e5e7af184bd6586a81b836727f8005d020e2ad5986cc4f666506234d82f3795fd350a6b438b37a161fec93617ad60484073093e8ca874c551b7160342e7bf3d3033d9ae442aadeb22156c84a156c275aa0323dfb104c862f39054f3ef78fda48423be765dc433d618ebbbcd9e2ad8d99b5d65c5886428708c4192f83fe16f56f94519230dc0e83f7d5d0ceec35298d441bad0aa6332a3c0da7e85f5ad6ac9601d50a12e779d2020e3a4909b0b5ceaeb67636318516ea4d67ab0704eefd2acea95a53567cb034f167dd9d66da04a33c771c1092fe98c188e32c77968df00a2809a85cf98333479f0c47399b334151f9bd7f41fc31f15ce0fa5d43fab67bb1506340b7192341ac83c23d8e0a945ebe84516cb61c3640cbfa2fe4f117e31d16d48b53dab85bb9d13b1f29827fe87bd663ff1988a0febd34235f04254b087137527ac1fc3f12ffc36e2d99c3e57d4cf47a632a9dce97e2f83f8a8d4304239ef464b7c49f5fadfa4c3572cfc15d62109870a7ec9f419dcecb12b8d59de0cb063a264f6d6c2a6999b3b4fcf4f5bd05515cde5088e19d96eb02367070684e75ed7b7c86b326578035ecdb007c6013ffd2c5d89daf89a575081b58a12666a9a762079f60661d007f56bea851e51abc91254303da5fbf0ae54150f0612fceb57ef514e60ec64316dcb0b19bd11bedc5275bd965ae8f36981c39d90c1151bac666e8d813445a173758ae9f01ced1afb48feaaf8adedd4f997b7c7ecfd7bf210e5374d1d6e58c63902841a68ffa3b83e0ac41adeae47565d1be57cf5a81820d636977f961a54247d7b1369546a835140528502b4a490695e5dadaea7b5521b39c59ef9404a8c92b77bad8b966d4e0736601f70e5d50438409bd3c161d08b588b1385dee85d0c7bb31b031e6f30fccf6b0037ed24a5f3b2f4b648feb6f19ac46bcef2a4bcd12e0131a88c4afb2e44367eb4d120a70e5d58b48499c2b5234882e13db2febeff082885d4b7de4c9a58da2a0ee4d9834dff8ea7ac162539820e0c33d1e20bca535a8ddfd538b04d5df6a8e75a06d2ae780f549d42ec73d5604aa0f5dd547b5d27221be0f39733380b18ae2f4e512db8829d256000b658943ab1de8389f735601bf926ef77ddf6b2d3715d04196a3b567d74958fb84d96f1d11a3685cb8239970c56b6377623915d6d3e62e180106f0a7adbe0eb29f1a96651443570812ed97e2b90efd136110ef5f7c62b95b060653a8ba974d1f207e761ff9f1ee6b3b070a604db9c6d7cccb944d311c8d46abb800cd6e6afef5a2f7d0258a5b8194930f88d1c22b2295a3d74182b934d54384e7f3c7ad0f71a6c283c635bb0bcae29d05784e199d5494b0065a740a3620c296684b3ff923eae3b1d302b2d821e5247f6ccb7cab2d872f481c68a8982dab71b954e7e2d04007e86764c2a7b658bcc84eeba2837dc72edfb2deb9c77b8e5df1e9490d68a6e9f3f2073577bd83a294e5fcf9f99a2f3a05c243ffe439ece4215394542a5ed3541712187ca11047718ab37bc768c2811042dc8e1f7b9d14a6e206e1ccfba0fb2585955402b1799ff4b3b9fefe2184acf3b58349192f351bbb7c4b4758b38ef0a74e23873294ba7fcbf5a5c501775fdd48d72268faf27826e808c7f1056f214a3540c973ba2d6dbc3f535d52eda5d9b78bc7ca9c4d937544e0a4394a3c7e4239113d141974916356453bad1ccc0aaa20479b1d9c2c3ad946a70bc957dce2d04f2df87f24c83eaf366dd5904ee6219f33be006f7ac7c18f90476334ee1f4025f8c782a492291a1c389b2cf09218e0617d77fe742fea5fc57c656c3484206eebcffd1b9549eb482d122f6a8bf96a14d35caff42c19ce00aa99dfc2ec53004a63943d6247d337c430668cbb2960c41e6a159c9982892b27178e9f958b86a92ee8666f120b3ce27eb527c061b8e7c0742963712e651305e25ccda750e440a59d8b58a99afec65fabf9784d9782f03b5a983cd8a7eecb04de4e2c585de8dea3e2c409604556136e7566468dafe46aa90a2afbe6ae2947674cc47cbb659a0796cfa890fc0c44a603104809e6b6a14dd109f10919525347573cddc18649cb48802cf40d7b67b7c2f85702f3459f942448b28600c7a0e859e97c3f4b8c7aa8b8dfdb89f67c12993c0068e41caf099059c671f015b437235d3f2e6d25cbed61f59b1272469a597fb627187db6a1999569f7b3b2f47aaa75de345b012190b409fc0692d64b7063aa88f9b17c2e6bde9cb85f175e663ae63b6a675211c9567838865e3f66c153e7639b07defbd184e3fb3c9b1b8931edfcf470d4d2945f865dbb65353113734ecf54c28dd47f0f42009538dee939f238a6c36ce5232468a30d09bb8237e20036fa8c2f892bd4041015e705d7c1ccabc754f7972400415b031607027c963a159e25840e2643b0a351caedfc57a33f92fbb0e860c3f0a7057764cb13dfa9a759857f35bcd2ec58252c9fa46139f30fdd42873cddb849d342ef61d05658c909c5b3f3c64263bc43abde2fb1b554aa1c423bc63f6d4bd5fbb917c1da699c2ac9e5c3b20833df677c1017e421a385b5bdff65fadd2dda3bd1d9ab554f806a732f4d3afee09149f042422aef55e333bbbb19597d60e3b8f842dbada8f73a7654f56e47b4a9ac31c968c7625839f7b033b1caabebd24e7723d76eb8975d919b8e4b8858374dd1bee7b15a827a6a1ec785dcc1c418648662957eba1ae58442cba5e61c7d8f4304a952b3fbd11df7d79899f8fafc4f41532e6df427a3bd59e21d1ded249ceb56137c4da21d4208de708f30944e6aba72c22efbccce9f64e6886a03a6b323741591c1ce6f4624c69209800b06c280a72051b3433f0c4de0361bdbe119cdc68ceb71f3323d1c5945875df9412c4cfacaa76ea53b272aacb69861cf149142e7eae59443b202c48052b58393338e2638da0e5588c0443665f57dffaf2ca149204dc3f46fb8f3f2ef7078db8323a215a7aeb4b219f2b04a5e3829463b820e0d9dcfef2cd6","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
