<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99ac5f0c8659c9fba6c42d5f0b70abb87a68ac3dc48477a7d3ef0f44548fe901910fa0afe8afbc133ff716f601436d2cbba422d487fb1d185e70879c0cd7bfe797bf23488ff74f32552e22168be26dc7354ae9efe372559acc8a69d26aac213cbe8aef7fed02aabb45b0e95777416c3719eb7c6f9e3ad4a3570c57684f06afc912afb00a5b66b17701529e26ce24ece059963427c008142aef33e1b22e9b792c1a9dd4e85cace6283f075a0ebc7432eef14db2cbcfda516792fc4a745be98542003cf05352a3f57b4336f2cbd65a9e803b8bec82f2b4509f9e7706304749d7e43733b684954c9e61522b9fb0e7bfddee9375027c0985aece9965c0f8f87426602d150f2ac3ae86fee2c9a8378a2ec0fd204daf0f3126c672e544ce43a7469528d8fbd9016b3799c11ed51ae39a219b78962435736b34730d99b0e81cc935af881b752eaa6f0d83b99241098907d0eb42ada129be2bb161d3059694fa7c1575bae0e28c46436aa77448dc10c7a454419fb26d8c8ee01d101369b3cfb38fdd6780cb9a1ef23369667865f98f7d60a5eabbc8d0aa77309b60b5509294fe1738df0c5a17c1349814a19536dcfc37222fb97e0fe27fe6a0ee26537a77032fb51a32ef1f8e770035383ee04dd4786c036f96981daea7786907ebc7ab80ffb260c91ff0e6bc7c2f60626fb0c8510d383c8829b4ce97eed3cd127c6c4bd5a8bba4dc717b724bfd921481d45826be54a2e57894aa25911fe4b586046be5c797d3882df6467e670832892c8dccedc980d4783ba58734963df6addf1e0418e7249a8f4b8400b0194e7b4640dd4bc8e9e369a86ce24cf28b435e794f69c42074cd91b56f7e06c1d2be0ed0ad159db00f2f8bdf8570a949ca601d997677dee6e2f547d770460ca924bcc611b3a6dfb8118154a0686d46150367c5ad16ce4d149c3b817b83a5e2e87d607c84043438e09ca76fdb30a30802cbcf45a5260eb2f4bc8f6f96cf7e50f7e09dc8dbd913eabf1ad5934bbfe6e408e198f1239745fa2cc1292636456df146cc367674bf46a4f0fe7197589efb5befff74644d86bc8cdb9302727227761a1d9f94c915a5b994a8664d271590b2a08b19dccf9a7544589c189dcf0d20023a645961828ea5876214602c400bb709993c71a8aaa15b38c6890f67d36e887d203eab6cf6ea8c07eef89c5d79e13f3387310acd95f248cc0b0bbfd4fcc8454a990a9fb62a25c5d59aed27884bf591e99146454f83ff146afb90d2e2d53e18824e2f71ac781ae8e154a1bd702b52d0ec7506428a1e3c6b8223fd745d3c437c541c11ba5a98992e8eeddab1c4df0acbfb29be807bfd636421708a88e28668418c8b6de6879d0019088b6fa1c6bfbb13bfc9c35ea1c0b3d67e2c8794581cf5fa41dbf5b586e5cf5c2ec3f69c7f6f0e4beb6d0eec88fa69061df2f9afa577c3fc0a6b52ea3982cfdd9f520abc1d692f2ce98029cbabe52d404ea033299a7390127a8544ab10f11ddf6e5b1bf7ebf93a8361ce4f15b72509919f56db1cc653f5c76148b24d026dbfaa0dca6afd00163750acba53822bc03443ec715457d850bc42197932dce64fb6216b737a1e5ad29e32cb3dffa570c523a16e00afc4d4c09d12ee494987f30c7726051ede6b39c24b50cf5f5a8e64589c720f41d35ad477c471a385ecfe8d78344986202e027d495ce7c10f7bbdae485a4b85b6827fe6320871029e6a5e093428114643226f8477a5962e80ee2229a8fbdca72e1f951723634913d21fb123ea62e76ffab11eba78ab868a64bc42a134bb2e6928187ad108b3c9e9f3f983052eaf7bbb8013d632dc7c0bc29a435091284bf801a582f436a2d6855d05ac20f655a7bbed725a2654e8ee1a03b6f6d789938875c4fa18cec92044669cf9236048e1dad7179454de5f454d31be28380cb44b06d482e327077f3d58a2e428e7b5ced43589d07ef945f4f2ecd80f7117f2d15b14511d500e4e78fdc47160e0a3eaa705f8ed9dcf27a4f67a6cf3a2587f084b144c353c4babc89e2ae37bac031c62a09c6834a3b35b3e619e6ca0983de47e40c6bc405651ec299b9cd239b3002657575ef5d4206e41f10bb4ead3841d9f72bd6c457e86dc162617f057f4102df832dd53fbdd5092dbb8e912d4455565b97a10bb3f9dc127d34404602fd9d1dbaf1e2cdd4d1724b4220b6c54407bd588cd8e927c4eb59a44feea6f5b8053ea50924c22566dc554e338125ea50c553a9465717f842157780d5368acbcf422c937bb973265d1d8431cdd24a3f502b2085d2fc648605395a5acae9ef68afdaa16211a4dd71f186cf181e882e302a711e9e785c951e40d4a65fd9dbd73e780d50fbd77280c13f909de3113715d372136bc1392a00405d43ed734123f7094c1d59efe780fc6580243baa1fc31df3e7e46bb954a3c86dceff120327583fc4be44bd2c6757c195b079c7f3e30526cf30a03aa6b937a901dbe522afce2e0fd18831b072497922f7d6ee7d9b8d09a64fa1c91fbf3684a0474afbf24eeb8c0a75f39a406a50d1d483a8465f666ccf5b9a9cb36aaadddbce0251ae05571a96faab3e9af5824e7188ae179dde9721050b230b8acc49fb0b0c20e628774a87c1ffdda6c8ba79e7c83e407ded6c3950c6c703d5134ab715521fec5ae3e6aee6369686f68d9f364f608514551de8190b24ffac812b7964230d9e66f5239f5f42e4f0e56c3a641df06baedc1aa6756d765519f26dc96b2de0c70e42889471346d96f936cb15b4d8da533d4a38cb431e0c317e0f48220a58893a10c8b2e5ba78e009184ac5b20ce77a2c2b46c5c75368aad2f68b41b5a96c7c31c31e09f6d504051e89e5e3ce2aa416ab0f9fef0bfc27a7de42c685bdfde4496807cda40729df457fdcd45cded19b997a9db5c8e8bd493d1f866cc69bbf658b242842b97abce3e570378c1a93a552947224068aea5c5678acd485009072143f3bac7ca510d63da268c45d30aa252b6aa333bca3bc4cb8d8142cb85adfe78b776de63d28da7040181382061fb77499213501a3da177497c67146adb66ee1c3b5da4e388e7534270c08fe670f20837ea5f964e5c170d4fd92b1bd5b2de6e5c2a1b1daeb7d069b8072b9fc2535f4111a921a4bad8095aa53d4849149e7c4a5bd4c1fbf169ab5baf68eed674a430befba96401b23ff72725ba928153153504ad1c23c5b9ab360a1f6447d4f0ae9d158a36e354b6787958934d135687a67618ee33b36be1d4b80e4a90865dff6f45219c51b90e73ff66dc87aa1fce4593b5d7ef48f746aac8b140eb02ed32364dcc743f74d318806c61dfc27af9137d4ba20d640b06605f449b8395bbecd4a682571497ab687d97abb50488701add66b9d7fd6192f76e8c3985722b87a01b5e2a7a9db72178e771328f48595e57277332ec6555040e64060ec6b44d5c8b1a45e02b9b71d68f42dc831b5cfe4a5e7ea7d968c83525ae4bc3ea70316be0ac0ac69130c9f5694d7fb1ddfadb8e940acd45618078c6c3ac140a91a05af860fa38a7c4c675cc88314d640c6c6ed540f5c463ce2a07f2862a9508b4dfcb25b3f94a34bfed6840393c6a7ff472dbebb6131f15a20fd7286026f0455149a5662d1f9b482de860a9ff5c7eccb9ab40089f36ce34274adc48be89d1a591e790c3032d375a0d92b765a9ad8f90dc1ef3cfd2f8f53cc66493409187e048608eac82effe672d13cda4fba3c1dda2eb9e40ea1967a68387568a1836860c642ac2273ba5cbff750d7f4f182b4ba368d2fe08b7d7d2ca32a0a9b0b07e658ec42f22e87cf1e7905f4b4edbb03ca06b4c6794c1bd7061dd8ed715d4fbd61a691868a2815856779fa56a9ee113d63560f9ea9f9e14806875d00394c73d830e586b2db2aa84a38f87946812ab9168d30f56f2634f62502cf4e2e391e44507b8673843a5daf2fcd84c35abbe72480f22d167766c643801149f1e9da31b8ee69f766045350642439c9236cffdf528c29966f14bb09e0166fc81d4a461d63a6dd168d5ad0793777d7270360fcacaee994963bb71f00964fd9149d8a04840c6ffff9af37d7d0987066e4ff2366c393777a7338a38ff9fa6e313c7f30e640dd85c7ac2afb201e80928c10946d703aa69f3611cd283dab9a66f05560e2bc536b257cd2c092712f7db9742744fc9dd6ae15eb7a6e74d9247764662d51e0864f33ccd854951c6b2ec5f7ff144f22edf474b243d508178b9408a634c6b23c83aa204372ae95ce8c44ed5faaf2dde73892021517da9064bc9864e883bc8a94fbeef5f83f132066f8f42c3a29d1b3b7abddf300a27b633e2a55d32243b4607fb7a936828cc3fd002a74f35c737dbab228b8a711057f9ab7375846f52e72f88ed0c313d906874bce7db6c890877017e8562b2000e8eaed0ad9601c8cada41e99e415b56578309266915ef5c11369ab2aeeefd343ab1cafb34aacd0e1ffd2543b84d53ac32c19d7d44ab801e2fd384adc889af80f2f8d42cafafa7a7ee84b091252280ff5fbf036178e56810e31f3434d89b8de33c77af10a3a05682093e5ae0c2b6a365f62e9afd66359f722eab81a326ea3bb0dc0a127c7050af7c1e080c66a6e71fac152fafe6ef47b599db009ad1f666afa84fb0fbacc0aa4998522b334171bc56c7e07b661995a57181225c5ef882ebf838cf3eae8f73b3edc4a999c8d0c6aeb1a2ec4fb7525c9a833239d8b24003d20924f648965d731633adde9854ea25a8bb7d66c31e3f6b189163cc4402bdb40917c222417247185de8e77f199b1eba166df41be87837a4ab7e7085f71347078d4feda4564521c93856b96f4f1ee9804336dc232d6672d7240feb216e756c8249a36e1ac2c6ed788901fa37add0da538ab02f205c9a5a6f35077dedd0f5d414f7b95a8e7201ca1fda4277788f48c52e55eb84d81cf3c7a09d508027c52fce5179ab19998bafe1ba99d11a5bc485fef886f5c7df5db8e4be2e5f4ba0946ea2668fa05bb029084dded10a3e26ed9cf9322c12f22b7ea17e2f3bcc26944eee8e84d3d032fbb1ac248d83f32cd38aaa6cb867b6e1b43e76f57796f7ec0d365c6248004988a26111585dec3b9455b395d02b8edb3b9ed4062c42557bcbc35ef69fd971e6aac3b63d0b5c8c3476b59e8fbc699cf24be88350dde2880f165005cb3cd1a48fe6a694ba926c8c8a5efcb2851ac489cda5e1fca758ff4c6afd5052da30e50464873548765db7d782077974702dbe13744a9449cde3f2fe1f39af2079abd98a728da2fa5196183d9ed23b27335e5b595f125dabd2d4d46dd37d4fcb111d46dfe2287120ff17bbaf1fa9b9b2a7ef0e72f0ffee363f91c3a93a7965f4bdde80565c5a408205e2d379322b197ca6886861f954c01cf651ea3d1e40f09273f89859cb8a2e6a19f069fbadaa2132b84c79b3032019a7f11955f9695fe3a22e6b3ba5908a04d207bcb7caf23e234b5e895780e8d578310610b089d1533c7a8b11853f661c3a9daad0feb13058885bea4a80e2aa0c961c697eea2a07c1d4b02adf2b4041bc4eb365feb2bc73e85a04c52c79d5f1a355b7dc489949c3dc6603d06946a6c3169335c5062c612f53550d47106af8de01375c8991d4f5f0577b8f6a1382a90273144e3d62d83024c1ed3c441927f7318ecba490a49644b7df69314504d6cb9924eba4429404e801091d752d6e4760e036192f3aba494aaa50fbd178d0264641db315cf60dd09b5d536abcec2f89f322f44e83cf3ba91829f74045754fec500649943725d29136ada2f05e216f04b5f12c148a6ccf1fb1c51b6837c112e49668ebd104c8b0aee1a5313d52f28ccd2d19bc2b6efc5091029581eb2a277128834848e30005606f45e8d4342693be8abead8969210b487f6e9f1ce9a60b7c87599b2169b08545440a8efeedc5099b6162304f6acf4dfae1d1ec22d3f296aa730885efbf48fe61f032268ac34d81e39181dee144e7a5d59e8e4aef736e8efe6318f7898d3da4c8b07ef0050b2b2c0f849934ef6d71aa5652a9e5e4a7f72a93fcd1393ec54e6892462ee5fe3e320baa9d0d63d196ed05aad55bf33a80c9691d7a27e2c9e13e56d0c71053d62038cb1f1d8257fdb39a6dfc6e671c2860770e23746f90365f85ed6da54aec8f22f4a20e22c22288c7884eec47fa94ca16eb879690569ab00a3d0b4f27340b18533911d73817ac2d80d769d84e9226b6d4b61b53bb3732668aafa341e3183cbd12cf84e6219b2c0507daaf52ec953a6de20be22261b0c4f3f0552239f4457d8b6fa7af34bb51577bbac7938d5250e18fc22ece70e3d86f7b36d186e0156029abf12f7a41b8cac5b76708aef17930d14e99b9b347a718a8877ce27cef0adf9632cce4960f38509a8248cf5fc683ca6c76852cb432ec8829998dd694b9251aed5d32fe9366c0da475615ba9ee6c6e06255dcc25716c89e45a6004320e991d5ef0a106b528f951e0f3813c5de01e3d8f8f84ce1f977ff2cbbcc9a5756c9663dd3b5ab6894615a3208bd478a33cec2fb71acf935443273378f7bc370aba85c76aab4d311ec1036715511c9a566cc02143d610af6a8f6a5f98e6c20a1024378a427ee5aa81e42ae08f07a03384526f37ed4510842ef83858b823c6539d042d321cef6d3e4222c87ed5b3180927e0984f5838ffa61b8db085190e597f729317322b23a93df567bbf51fe1d2726d4587eebb8fd03ad726bc4b118b24c52c4fd496835556ec4bd89e75ee7fb8a2fad1efae01437b183be14d3db2a00f14d719f5bf8bc0a0aa9467f3a0f7230c4f45f4f66654ba8ca1e40dd7f11915557ceeedb31903f1cee6215cd7591c2d4a6106bf20a8ee5ae355705423e3da22220b4f38a6b4777d0bc42013b0de8ba90aa57b7d01de10df398b997097a42436c60075b1775d69393185522003794dc8500950c1293135a155f3845821624b1f5332fdad154d5be922e2bba3ceeac3dc4235c0be061f1e3ce0c5305cd94bf02c2d073815bd6db58084897e8130a09c11ff3d80e5282a06023cb66038a1bb196d0aaf7e1adc0907ca5794a38d8fac54f30c8988bcd0253029dabdab196e8eb6654eaebdb11b3285660cbef9b8d7ea3512b9cac1a5feaa4ea1c9f74f4f4a9345cfc8b2b42ac8a69b4280ce05165129336a64490beeae480ceea4f25202ded955e10e5bfbfe8661aa220d60ec5228c59cc8e9fe6e1cbf61459d0d982a2da73a0ef1286941f6534b490774beac8cf5a53df7762dfa5a8d3ca012f25b1b398d20b27a8a53080c68417ace306bb6ad6d20ac10793328ce4ecfaadf6e2150da86bcf915c73accf2fe382a31a39cead9f6e19f9e1f74d6d306f50e34251ef294f01ddbaf5bfe9c72a30085ed497ef3a6edb41c9e100a10dfa0a04277c2caffaf1d88b7654a626bd2ce7c0a416380552383518eb8f912e21cafb0331fbdf561a09d518d634e433beb3b013730308b303169eb2235b74f6cb5a154e1880c526d3af016c97c3bbadfe5827c6d7d0dd9c9be62fc60d2631385470229f15bcc108f0327708d7857278d1c465fbc8f86e4cfc9f9798dfd7d24d14595912ed8ce1a286fc87897ca6faf7425e8be880b3a5ad2628568db1d41b50ab1b326d55d26b49c88ea35c3b624583715b4f021ee5620f50c9f97d2517567142a13fd3e0988f2036477a171c8e51b363d2efbac3b7de57e4c5531a4a246ecfdf968ce592a9e0a67576a2bb9eb02d7d10036afa532df618b50c6dff4a029770c447d1c383978c6068596f2c478d9b0a4a6963fe64ad6bc86adf2ff6133503162c92798460532d4ce11b729bd2edaf3ec8030246a3a648b8865a4786f77061fee1cba6ad5d43d38cc9e5376f0b2ff7d0fa4fc19408ef815d03579290a27227838bf957c785309a35cbc6e2bf4570fb7863633f4f30bc07baaaed96fc58ad15ad3084a4044da680ead25930c800ea1d6307a27a94336f58ea76f4343f3fc95b52ddeb0d5e5e06fa22b9081d2575bc06670547e828cf71677f032b0f006c04b0ce863b88b070ef2799bd7f42d82536b98567a7d4bbef766e2aec2e6d81d7e44f0d17f740170d9a5b3578c0cac3764e456c69ea372373205df9b975f99c8f9e16eacd7e6ded1e0f46e830dd973d8a5d22760fc8122cd81454ee89be5f20455dbc17151e4ed822820172ad0b47c426b1104eac26a5d6f1dd7d0a62e73ab1b0688d95774a5d8cf21b7653bf82158273a7aef4acba0e3c8560d53c95304311a6e5be4cc395fc909d8dfb66297f8068aa9753d7a8a269bc6c4318fc205317b363a9a6a4d9d4792e63f60a179078cfe30a1b7526a87498d8b5ae9994e6bee87bdc056667680cdd62a485755ecabb0765cd8c1f445faf28399105d842443d0bcccf02746e383f1704a591a670c26f0c1e63a0748f0ad07f06709ad42d01890727a6c62d931e5514fa289ca48bc18c642c7235c65592a71126561e7c53390c0f3b2b9a846f18810b4b16de58105c45eac206e33e158b19ee60563bbb2784538e07cf4433289be10724382845f96246275d51638f6c0468811102bdf3101a87241c97c83fd0edb907c210935be37341887e459ab3466035b954bd174556d55ff1950aa695df212ddf9b8c4e83c93450d7b05c10662c8dacb1b1886bbfd651937f5bc52936e2d8246f4eeb2d33b76a514b489188d4aa6cb68e7e690e0818a7d85a5bc9a5671733c9ccb959577955ede34ac7be4c0b882886b6bde75ec832eb46502379b6e1dedfb25abb431e7abea92e18e2d01563d29f06b9d348c4cba35e2d716a9b11f4c4f29189cebf0aa54043b1d8dc2c1ec877c37fb4939ec9f083cc7e2336bdc3cee78d78e8ab2265481700e65cb52eb3d873303e69c23f82aaaa3ae9de5ac30db376d5c7d14bfb36c7f948e8320645de3f1cacd1b879b90dbb8e059f1ac777016e21af6288f84168a173c67be30acfc668a6f12ddc1addb7954479925434bae1b0d06134d816ff823018af40705ab230132bb7ea7bacf400dd356ba9fc07ea1659598b13c702fd0bdbc1a84a27b1bd9b313f2d6475c6ea754e53478fe83992e7ebfafa01adafd5f7c11aea67d02dfdf07bebed247f47b0e9d44567d5f230a1c00a4321943438e5c6568e419c2ada5724d3a2de8e6b016929040ca24762be59e3a76d6dc2cc47aaed5b498565f84c29e22e0de788e4b82ee6d263f8613d2566bb917f30edabd190e2d67147529eead2c95957087249dcafd14084429b136275ac92489039f6905e3f78f433ef40439e361a084f22019c66604507854328e67590216996b10936993ed7a9842c7840b4769f394f727624c1e11d850b21f81fe29db2e5f040223b703789961d495bd2d5af934f7f17e4ad0945c0a6554494a32e1c48fcc81b822be7eab0756f953e64851c8f983ea012b21c6dfd5b079d52fa5ff44cde37bc0a36937b0116a7457e9b245b3bfc3adb7b69f5989122970a039d4cf40dee25612db1049a18f9ce74fa3c325bf219d08bb8aaf0e0ee6ecfd0a980cc116a2f1e8359cd248826dfcb92631d354acc8e7b22aae20e6de6cc97aea5d547443db5d51033c4d4972670ed6fbd85ce7d7a1fad31a4f8397570ea6b812b13351145e7bdd8840d2dbb8c2c960d80763cbc8bc30dd05da188ffa66a872a8780a1938d00c59ea98b5e8aee798c5569d824f932e2da5a1da5eb9c8fb7a31c9f2f12759e6cb0f08534c67454e224f018625fa67e9c07fb219cbe273a53d69425230fec2d4292903add0bce10f570a41f527f025f3f429caf54af8601b3131c324d5c46d408b3348f2753de52667f01d87a17eee4d438f0626d3f8f48d000ab8c6f4b59b6c89ecb85b4c5fea9f7c6bbbb304c2eaec6e16638f3a36eae5af05d030a8992a5091626178afc314d1901da171e6b2c52fb4db2417644379eeb10eaefeaa205cf5631475e62850fef8ab8a2b4989f13998aec2e6f5a1f394f33a4875bcb25011f9d905a225564f08336af08ebef5ea9937ec65b3a6d018e559ccc07f9e25168bff5b7310a1e0ee7256bcac735e7f53d852e427ea6289749c914f277dbdf27c6fb565cd203e8a4e2c078e965c622d535ff60f90f71b36a13b4210225f67fffd9ce4b93d8d17086238b11328f9c8e4614ab06c628f0f472d1375dc35947231017366243d46303db20322aee1619eb97924327fe60b197cd0b2f6ae97a2c2b7190225c2fe3e7bb1d2e4c59356b87dead22858784ff04cee2f4aab0c6c9c78d32ce4e373f0290d5c5b7cf42a93b32d290f7ef597de10bfb16709e60f326bf0e5940e7efdf4ac7be131bbc03180e5b34df196112f2e22934d099bcf5927149488d825c836a3b30eceb8194259bac95c0808c951c306f1d0721c313c12c26bbfc97cc8d28fc7fb45e01179aa7834f36e5094ca47c791c08eb2c73573fc0e6262ed44be1a278aa07e15e96a97a2e0745046c870a16036cdb9c2ecec66bc46402ada1f2581dafd3665877ee1bb3bce6d052c52e633a5f96113cd71adbcbc8c760cad2ddecfdf8a6b6b4ac7497a52e37655982ded12e23c39931ab315c9358a5495b37c6db118cfadff7b599efbfef4a4af97eb9ee9101a555a2157c4f9c66d9d17815bd48ac2dafdc623a4c190cd95b852f812a5eb1a7396e0189c4b8bf28f48d647957bf27bc7b43dea362dcc873095972854413036bbee6e471d353de25c8be359e14fa2f435e0d1f3d0339156fcaf69adf22c492ce782853fa39e7239915e59cc0ce424948fbd00930dc0604f17d973ed1bdc16495a444ec17507543f4ea053e841cc83aafef1a68f6ff185b03590aed559f5c0a1470979ee5bce08ee78d24afdb1d510c052e7af121f433fb252662fe80fce17343a317eac012d3141b1c1ee6e97eb5","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
