<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71ebb7f5fc49c99f2c5c4a099d639b5c10110ad7eb5844b5728d401fef74d9408cc624a6171ecd29e706c8e11c437d7ee94ccdad736dcd329ac460c45972b4d45d6a8a8aec62293b1a8712ded4c43a0a38aeb100113dc3a6d1a81122f749c93a0c07bcdf5282f6dff4d7d08e95b299056b4b7871792e30aa02520fabc7ece2c0b07fccc81bc3193b34fc2a8c7c9513d0c9da749f6c5bb9693d111c7e249383065744a2a5c0972bb6dfd3d5fd236c8c42da76b775ab140a30f136e71b41eb3f68a96dbcb66e8592f4056ffe49d1c293b00c2496741e50dd5ec7e22bf876b5b3d527c83db23059067cd8fe884b98ba7026a53a54a4de116a62cd95efd2510f6507c423a90a7a842467e062915e714d1f380dafeda06dd023dac0165044b9243191b917a58e068ee527b3d6959ad22be17a4ed00c9aa84bf670dadc3df00b7ee15a1d31a70801f6e68f86b195fc1bfed0ec90e1859e98def8c54ca83ef24ac837662d471780733da8d21041f8b1511942be93471c42812b815dc6676f4bf1c61c3ab0e0ea83139c7a464db45dd0d0627c400c3c5148e1c7aad9d357bd4dbbbd69fdb7a8457a5e335a8dc6663ea9ed6fe5c26ca131e0b87a593d393d5a56be82f1e90c2aedaaef265f0783deb38bc070ed02a18956ed01202538da80e44b125f1ffca41ea7b3c2dcf80b2e3d09d3cc2881ecd17f3dd984e67a32116af20134fbf093c9332b24ec88acf6a6e83cd0f6f0fc3373459f7b23a1325c073aced476ae95dcae72b5f38738e19a1dd1cc8f41a770023ec4a65539157236b298b81bc30796a473d39183c939951d060c83172cdd19588f0ebd1684c29ec2adf9a5a5f48a606f81ed66c3d55d92e751924ced3a35c4c131331bb80f016256c4bd4473bbd670cd9cc0db687ee40818054772fdfe1e77154982d8fa947ee5884a2d701138b09dd1b143d7bfe11aff695e8898e166b162dfcf40ac92a5f0fa942ed66c5dff6fb531ad5ee3e873e0990b76d0ecdea3fed8b203666282931b28f4cae94c8fe4d1c13fc9a649ab028d643a7f6672c0794c0a5ee16007c2f4a6a011613a86b45f829f9e1132b4dafef0ab5492b47fbd072fa8af845b7646525ff56fe1bc4bb9f4c4d29daa04b1a92d016a5037966d52ba0636da5d52df558da90403373bc9665cf1bec2f6ff8a82fdb59a36b7468f011841ac2fd83c3acedaa7458eba75b4901785aab601bb81276095ee8b8c0efb41acbc4c442e356fd904ccafc96a0b8563db1778c025366625afbb819594167a96bf31b1d2b43eb2b3db7dd75bacc2f8767f1a74d0c908c24057e50fb9efa053b79fdeb41dd2ccdc9ec87f9031b178322b3d751563913f08c93a0df64b77665fd73c5590dccc761dc2d3111aa1b7ccceb39c80f8b0dd0f243b6bc981cca3d0fd44386e4632c0f59bbaf622db11b893a1c655df208b687bee07caea18b675beed408178b6ffb36955f4ba26b1bf2bb331af67b722fc22f68582ca46d7b05202c0e7601ea257d46b6c28c115655e475342242af5f2d4b35e9b2372196ddb9aa0b1d6464ce727030f0af1b95020816c3a87568babe0cacd6a59cf784cd81fd3e5c45452e8bac71c1b468400e1ffec245bfdf56818471c0960f817813873cdfe08685550bb5a6c458f94124ebc4146b7b090da4e51fa9f846045d1fbebf02d46ecf633a9f3581380c908a4ad0d0a2e3f7c9a49b56182fb20cff4bcaa9d5ecec5d1f6d972c1f820c486bf6e46e5354f01243d39e5a8b6f393a9e458e906344ebbe673c92079514df7f6c357e9a58049fae5439ffabd7b24f4db1d991b29e31dd0aa3505450f433ecc9afc0fc0643f13cc2d8bd9ec434a7d13c2f7d91c21e431bc819d6fa8240219273be1615095093ef7c9cc2ae34e5fb8dac7904d7b9ec0ed8583a77915f931f2753fde443c373c6f2c585888a14be8156d79e6e718b6f196730332897f16fcac9f64e64444d84b14dc4da586ed714a2f45970128cdb75660fada9228d849e7ec72ac45eb69bad51163b9de41f9d6007fc9ba10562e83dd5025b40fb92221bbef047265ea3da4847c19f7bbe80d06827af6c04af220826ad03bb561848434e1fe656cd7471fa9d988afcd76b562dc168667429a20cbe153b13cc2784c0c25c018c0c2a92b1cbbeaf556c3504003ff61f0c4a69b9e38bdf4e86b24f48810892d24d293b1c0d40cfb076ae8a6ce7769ffab328e2841ec09434c60acc97e7230b370e04da0ee01a0abc050873b10486a17ff9c97ed4f659e4101c4195d9031bea4a761198237f1ca2d7da1d6336a4238d9ed4fae2d3a8534ea97609eca828f3496c19725b9dd2d5b7adb832946951058b97af4f3fa01d0e9eb3996d5c5230078bc6f8576ed313808853ebea38f2b9814c85816fc031b67523b6e8083a1b5f7f75c0f3e75a35c38242801c817e092d721d718e89c56d1230b6cd405ecd89ca1823dcb05a7e0c5eb31719296dc9d78c34e80d856763bed7288cfe1a660daa59636cc7175622c34e68aa086387cf3d1419c7030660e3efc996bd7ab1a83796685f509936150d0a20e5d90164381760350cc58569a01893ddbd9621896d5da1459513300c91fb2ce26a43beaf46022aa566db02854db33e5a5deab3668121942795ba775d5e22844b69ca858ee7ff6da05655d0adfa938586381a50b0e5b9a14d096537dd5ef5e270f28cdc2485624122b21a0095e9c408592a9762ab73935a394623d8449a8ed4150702eae7affc4b755f7ec40d2f8cdeef10acdaf1359bddad1f2b0842f6a16c4eecdd3f17d4294c95d3309a671578479c1470033df320cf751256f9d53eab99231bc9cc542e9477c0757d3c24f07c91f32a480ee4360e339d8ba94f36b0e0d9289b0964b07a9d7f52d3bd01b4b9fb857c9a274a35d935681ffd565310f226ee701cdd776ff384bb5dbe7f02b3011384c32a58d4bd3923018e5d2404ab7d2c32e79fea7bb252e3c06472291abf63543409a607a2a840bc00cafdfa637790fcdc03f6093628ba89ef89cd519c1e37b33921f0278175862faca9af60523934ce3f4c3cc0ab6dd70e09ba7b94fb366b3c4f43b715ce16fdfa32d79ccf08494a11282d928216e512a43b41f9be282aa52e47b30536d909cbadb33d690e89b178c2e6bb94e60e7c60b9fe6819c237f3854a36f59cc94170765c23b9c9b7778e8867994516996ea96f583f5970c1128ec8a558245f07ae3e322d6d558690a05496ebafad2928903c46d7f8a17f566a671e0df8c85b0704f9805de69a1dc081c1ecc82b5b56947628b12f7dbb73dc435186ea4792ebd5bd9ed4eee1ae6ab7500f432677792687629c9c22c2476119be7586ed07642b9c2fc4cea153df349cd601dd34fc81993fa9adb31ae316a055fc8bd89cc1ddfc48d276f5b50aac155398ee7a4c375b83e8f60471e38793c25eba69a42092d49eb4231de6581a7ac22652b1bd8164617a4661406f01242b16bde8c5dafd58a27e3f4b4d86d1311e5b6897ee7ee3cbfab524e134eb36e55ccbe3039572e26f67e127672546410b3c42735addc395baece7003b26b7e30eae1ac60b640efabf8cda639f02627690552401536f328df7d8766ab86ea7405acf108924fccf6cb832b990dde1d128a8e5d7b57ecfc89ef041aec2531a1d209cd5444880131613ab15a6be61574fc11cd252fbe69e59064bcb011055c7bc98e206e1a7de1cbaf90033c99bc28d7ac4e75f79a14b37241743f7b88c1c4c92ba5de294860fb9521562d9056d616fc4b63b1cfa5c971f5a601afbd1addc27d7d4d2dd8f4b04d0e790a2627bdefcd69432d6ec7bc7dbaee14be6d615b852d5c7ac20b807934ca07992911dab32e79ac40e4f228e41a4d290cb974dc3ac7080cd57249b65839a38a207f5f79c96362172ea7ddfb4674fa818227407570896c802e47ab3244c4e34c686a67f91008be3295b74b4c064644e7b43dc5e1a8e1135df65a8c2a8852418335dabdaf9425520402e0d2c60c3f1bcceb40fd3379ce4d4d0d5fd484780e38451136a04748f9c3e7948d90a3bd3f25d5240d7be6138e1b21160196d177aae577f0481e5168d2e025f4af97f053997bf4ccf76b4e88309b8ce1273f623aa7a3ff7ef4a889a54dc1abf4f892b8af966d009c900e129a8d9a4382ea08b10c0fe66b6426ae447a37628526fa9782a2acf47903c506c7eb5a07eca5d3c86ece89e7051c9321e0c71138017cf9a111f60b403f45b683f07f23e1c68fd5e73b124e1106951aa02c3c6b59da218fd1ccef520c20dc3891e8356429a2ab71e0513cef128854cbd7ec25fc76a078b9e8b6f42d37b0850deeb7893942cdd560ee9c146090dadd434859bfcfd76d2b938cfb3fa1d1f8266c4c82b6849336bf7177dda255342698449f9aca0f83b6607245e2fd9c2ad35b816bec5a16e8e63c7e66d3bf934a6be43c85dedf22f88ae358e0ab4c8700596dbaa68c6a20aeb166b5df62853e235794521de5bae445f5c38f20b216e96dffb9246900c6ceb6ca0656d7a623e0202fc86bbbe1fcc1bf8f7a3590be66eae8bf95f939f3f968bbaa344bb7e0490d51277253af4b8c28e82b6d3686e7158b614e9b65fc4ecf6d90d21ab371bfad0808be05f19054a6d107e2afb261edb8a67fef92fcc64ad85a31c34bf1f50e3fc130440d2bcad92e4374c57b0801f96733bc5af49796dbdbe710267221c435c146a79420a15cc2d3ec6b042fbba5b94980924bc2d311be60b1b9286387573ed2aff7640cafba8815f5720fb708fd614b7a05a5418ecfeb84bb8ce8151bd354874d37e156cadc835ae149002f8d16e3e1640b9f6013517885e23c2399b274652abbd79280622f5eb57272e3a948e5eaa8f1d7d903c7b77389894672f3b3d99890347d26c48f49708a997cb30309974df14559f587aa93eefb0ef6719d2cff1b50f33d99818de8d3302d29fe0984134540c032a32b9670df37d2d69eca241fbbfa62c6723c41ab457ef9fbc023e7c7cb4c41b8f1d261feffa06634fe42225102fd3d8efb7f607cb8bb1c9cc447b473ff2f6d1dd900d07b436b5e2f69d2c4ca253959dd90ba28bd4da9d3634934a12bf65cc8f83ae9db9c47113611d1a8f11e7d9f5fc048c781cff90df3fdc8feafad87089adab43673fc6b40a43a6d5c2635b1da66c1c9e3fc403d65341d5452f248201de054f6a837b1c991695d5319bac676b6721d17eee4dd99449b215f561477852c6e4fcb1204436766ca1397e779421c26269148f138b2922583e266b9990e3ba69078158f0be8f954424c19e34e47999324bdbd9e06989947adae872176c8c9738db7b72ecde7dd30ada06bd8f6904c5c200ede5caf4e3dcb76791315ed20d79769acaf9037f2bb1617dcc7879cbbb00124ba77354bdf47e690b0e8e1a285b662352eb036f12bbd321da1f34e40428767639052c836e99467febe3e890db6d0cae5e7f2537c31c3364e1d9b15124f9645fc328f7501063d2567d0e002790fcfa25a8aa5e87b66025f54a6d56df482ce1fe03d91d8fcb374af27b57234268fbf76c89cc16665b1ec0e2cd06fa4ef54ef459b5b2c67f1eda7dfeb8b8127af5e6b2a465c6cc23cff7ef196a40c0f53db87e2b5a461576c53619c52306c95aa560b48af11c95592c6cac0f615ff33f09da7ba9d71b7855cc2b5ea847c0d3161feb1461e910325be950086bafc5610e4362c1ec40091655353ffab8074bd89a11068d738837a1cdf7671776df6f4ad0f51c15b5f50c733f537f2986f9dc0ab989f5a048ef2a709c6026d88e0f6db32c78cae192153133e8a9a9d1f1b8795b993864113d8fdda6514921402970470019ff46f3715ad00b72066f715e15dd9691dfe7a99e90e90582550acf2da08d7bc5fa5fe24f2dd5e7fad76c5a2f2c93893c66f3e7e61e04b563b06a0f905e4050d3f0461c0340cd8f708d2ea3695b817a2f61e6b2c4b26099f8d25db8ded256dcf1942a388299fd3db92180bf8e4b640b7c0df446dc1fe2bec1817358e7e2c77e9b545cbffdbd4fbbbb01b22154c431be51932ac7a1b9635cdac9b047766ef4f4d397dda9cc1a20b5df10ac94e881892e1e0e0473c278152bc5b3f3ee21f4fdf03f4f2333ec15482d2bb66e136936eabda114ff56b4b4fdc132a591d2b3e100bfe2b0216a9bbf9241ca731624c2db1505901f1013e64dc9713e3e66a17b2d222f78a1edc9b2e44be0f3b73a75fc2a93e42549d13d9a033276765dd5e88bc246e16e46ecaf318e787a018c45b70fb339af5ff5f9accaa3d1196d22628e2adb2d71e55b3bdcb1a8901590e5bd2f0edbc81a7085f9d4c0da8b70649eb871920443af6e2b6268897b020ff71c93a437ed97177bfdde4ab5700280bceb93e779325c8ef2bc42a6472f2f17fa5c4b7f822618287adee30541722e47154baf8f23763b980457f6ba416aa3402b67c659a3b4b937825f8fbcbf416c9300d27df443c3269ec54af389cb99b080f433d9d6829a88f8dbda2353952d20163110aeb036f500aa13532d44c9e2b541cd9497be8473e011792d68382577aa62d32693fe6db44d10b786fc6b2853630629f89342b7b8bff99ed57a611c5046d774e1d7e725e2b8cf61379bb1ff8b4592fc1de32e939e108a9bb7021621272826dd05b11e3b24f2b3e27099cf523b47abe124b39e92d411b3f61f2a0439585466d492cc2ba07f5b05c864c94085b8fe4e7741fb2318d2e1d8239af5dd9336a8e0fd115e29e68e6b18cf1959ab09b6ea51576465de9f40044474667946ba2920aa0474f2e9f61fa57916f59162b5302afb1ba86e72d7cadca7804bed27f4d3e4102a1b2b1e34e77e60bd03f37b072612eb604bb02de01bcfe495547eed03293404ab36fdb001327bb5f4e7c5fee106d010f164af24482da07282bb8c0621229465b17dc39534bc08a656105e3988c350c21ce0650cc48626906beed199a4f543038c47f8f8b672004aaa2d4741ec0769fbd43f0864c0c8e02c4b57b0010b5b33dbf0325967d99a0a5c551136f72dd87fc626bed4007080824ef0636b8df743a384a66549d3e5c14bcc6f92f97e5c0a85f83440b2a95e44f6795dd569cd0d86469b3e9c020b6885b7041da5bd4d75ef4597bf84539e3da2ecfc6ecd4aa786900873ec000c0fc169e97b72c46c1037a2d11740b8c8ac56fcd860bad7f7feafd7752a0b6a0d20b98abb4aab10907ba85144fea509fa3ac18b7d0a43ac078daab14aa15c497d05e01d939d2ea236ed1736464e25424006a3803f420b7d9c4674a6497964dc77456abadbd917ffb937d0204295da5540ac87e281b7914239ef09d27d0f1aff6e70cfd3a26090a8f509f0449d755681bfd6f3830ac36799088ce88df7c6d3fb5adb1bd9118451efac3ea01e75b9202d0f3cf9ed898b1873ff26ea693a85649558471826cf64ead5b0a821abcf02c2b18705b1523be788be63c30ce8cd22e4e6720109492ca5d29bfa04a060a1c7448c82900cac6276484f6defc8e76fb463791a163fa545979fba71afc6e94c85550b66886f64f82f9ca29732cb6db43e82b3d53cbe0b318591be3951fb318518013803170b2a0af4db7372029289554f3b7ac7dbe8e40877feeb060ef7c2172dd4cad79fc03305ba3d34ebc72fc868ed2d5df4ae1ae000ee6416a15ed2d28f08014a3ce6e28421aa5f5ab85aceb74eb877d7e79acea799b9a7e5612b0d406cee4da1642ebf059b0bee098481b2f5b9b5b734c9af954cb9f9f098c0d5be3a7443f39aa00617ac910e5e9f46be90289c82c40dbadf4b4a632562398af075c37d1c912aa9284fc29042d72936e7b60068f56bb27902bdcffd08e6b4d377d113cfcf9dd6055e1f5812e76d2085f18c8c56a2abbe71280ae060ad45ca318168922560177950c42bdcb30880a2c80038981d982d586f4741b6cab430a57c3165b96acc6ea2587b2e296a2d332343fb3b647c900213088e08bc58620cb04bff86b7e012a2900aa7b33494845c8ff65653bc31b959efd932115b9de91800261d3e915e64fd24d309bb1bdc843d158375aba6d54adda5978e3164ee6eb553532337f73871bf6d1c167179f83a1cd74d73e1cdbb4f7c3e67a004fd253a4b4dbf0fe3436782cbe57ea0a408243813eb47e9105cd1ec445d7010dc0f68766cac2d98bc8af8f391a47aea113d7cb4f6a56876bc81efba58e6cb78daecd6f081f571a2ae0851d9d6ccb2654ba05bbbd0782fe129c594da8a2a731ce6ca8b6ce3add953d830c0700ceafdad7d6b717d7040b3750cd4c8ac0807bdf58397a4e3063f0173921fa4507954bb6391d151fb13d74e7e0fc072b3bed6e0a604119671383a41d0b19643a429811089a40e9867a39e1976400df8b581ad40b4d894ae9d8e52f9d2a685231da5b0c5aeda5f29b34e051c4601b3c906ff1cd300c875ed1f8338fa61fbbb97d49dcc551ba3138439e542eda33148331c77363eb95f4755942e5d9de079e479ffae407297293fef8d23d2db74fcde481c5efea5d319f04bc265aabece9ab3d03c8b270e81a6ebd066d7ff2a4194b51564d86ba0d855314e992f059443ac66fbd98fe22c514aa376c909546a1e0a2a1cc9cbfefa0bba0106adc7b63d3dcbfa10e8f84a275a2e66918902ec7090d840559d8d524e6c20075ae86e7d39effe979f8cc315fe418cd97baed735fd8f9a684b4d2b486ef04667ba5387bd32877beb606425d944dbbde5824dc9f0b8e607c1ef0206b310d662a4bbfdd4cabe195260f81d5131b24e1b89ab0f34d17ae8d59a2b292cc3137cc8649396cb1ede9318104c1e5fdef35016cfc7ef481e0983413a4748bda1eef4297722c5987b97f1f768bf4b749dad0e60bd004e9adf269e3471934ffd6d0d012b6d26d7bb85c64beeb070881fd132df6e53de42c656078f501baabc8c0d1852b925ce2025666684caa6647dbc99a14c565f8594dfe89c005ef51ff9f97588faf253a9399d770cf720eed243b30175bab5283ac67ddcc4dda26ef7920eb930d596702a06ea93479927cb0e82df28b5747c6bed9541c63f20291fab7cb858d43b700979309b0a1bf2bd5d2d5ead071ab72d5c71f35852d862728f225a479f46ca7d1e336759a4a91221e88f28c5ce6839a2823e1e8615a1c883d7ff1eedb71ace5b07698ffa2374c5617770515926c303bddf6c80b2b65512da591046b3d643cc81f56fa26c56dea486116e728ee387384865709a2232e64fc4978f11020e88feb6b68defb12bdc9c574840bbb34fa232075af035e98beab9c934d0da2c5261bae36d7872e5f5e1fa2bc44fa1df48162e230da98d46740956e531202bf41e5159b258e47be33e52508e1f229e5409e8a96774a64040e33befb2af4dd049c12433531a6e53474f8252ff727c68216688b21362e98d94464882adba4f6a1bc1a07ad8c95052dcd5b04f7cb63b1b34641985959d147ca74f2b1e671c988486e0f9e803da9d1464ee5b20642ebe0453ae99302dc416a8eae89c0844f327373067d22523c5ef0d7c083f4661a6f2e82aea8b0bc47326f90cef75f47eb89d45f44553543be34d723ed81345cf3db795fc5c43f5c13948bf8bd8e96eab5faf4fa2fc112e89f0a53d580c4d4d700df688d670d7b869f770fdd25d4cbc3d57804cf04caec7654997b9d28b2a631ed35dc7e6ad5fa3ae6d01f0c3682ff762ed4b02a557688cd3d6ae68f27ca1d5582c3cc85dcd23aae7bdab720499ce036f31643e657fc99cc9af5663d85002e055eea78de834dbea7529854e0581601680c386cce389fd738ca0f0892891fdc6ba4ada785ffeae27fdd9b61142f800e20586be985d11d46ef7ca77b664c1b6b105583e9c66082fb8d0f82f84cc86cc99b0c1e411e8b87b4ab42ce082b2b4cd60966be35345d7bc7c1b6355abc394dd6124f6c96033fa20c5e487a1b9a67a72e6702f79474311fd466862ec18c01b011b9f8bece2cf81162ad9aaa2386ae508ff02ace3bef50d75e01214332a31bd55b45fde07ca0fee515a260227f88496fb6a0404818716b5d5f119fee48031828293d78333dfa59f33bf7e267b817953f7c774691d940e5c019f99322f1f092ad5f9b9e4ecbd4248b6f0416a47b13517be57106098f66d2cc4fc4ac34c7ef79f6920bc8003ec34bb685d5dafa829303f89e0c90a19622a17a66eae14f30e71e6e9d9761ab5a5520058c6b724e4d4a55f6635e85db87514136fc0f3954b22ae1c120768c787b3919ec4155c9de98e426eae0b3ce8502b4a82b8348101949296fe0d9b0937e2dca5176f4b755cb29f9b55eed65c23765cde3a2c78270bcee2dbf7bd336a81dc5975b0d54983818fc13aaeb827c58ff6bb140bd0f92609bfa6e0f4a42fc452fa1f3e627ce58c8f0df8d273d67cba93ad56b0ceea685db78ce1361d0bb104dde21ee8298ee245ceb536b97279127c9b668ba52d15bb1f0bd23165f55b643b0f5c55f2ae0d6f2b3de67115c9f29343a56144b0df4bd0b7dae827b6bfae62ebb9eeba2d7b6a90b82c12ea377c0e19e42c3488d4b345dd0d7197cbe5c084b31383ec93c58e98d6c75da542a9656346681e92ac0878dbea0bb8fb84d51427c7db3476ba901728d88c53176b18a2f298903d38352194f0e2b495ed673cddf5047ab846f3868db9b34cad9307f5b2420b34db869d4e5018106ea6942a70fc71867eae30b37bdb8b3fe10edcfa1f7ecb575d2fc59e823c714c26f3c53f21d3cc88a8cd11a57ee662b5bce5799beb44eea83d968fe03f2d9574183a57dbe907402e478e5079dab605458b28c9bcfcb5deec91a4e9b90021143a6cf3f79ad14c87600fb924d88fdf0190a167ff9c503e7e5ce3fc06e30e6bdefdbf6a7e8403c1b253b1490","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
