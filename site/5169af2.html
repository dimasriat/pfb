<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e78a7a6e45c564f9d90dec19cc3c62ed4a849f2d2f30ec0ed39aa06ec544549ee4bcc2c3ab8f4f29b29a84b8f6ef79182df2879116d493a7026e2a83eca58a830a21973298d1ec752cd4ead060080a0f3642aefcbe5755a84ebab0b805c3e00f0afdfa7f6cce84eda25795ea791cbe57aaa1e3840bdca014bc1795cf0ea6e5649d44d4d001542e5a053a2a4e4cd8f99b55ea9788b4e2055025bf7dc3007c939cf82186a0289eeb2a7667cda82afb5dcd1b35dd08e3262eb397bb66602145223ca7677b5349cfef9d056e6d207bcf19e19fb3e97cb4a48536b8e5de2215945f5b153e309a33c76a95f8b83758dd098939507d9116600aace64c3005d603b11c335033773675e24675ed749969f3c28778b79fe57d9e388748c0c5c035d352fe001c5c08306b75ea4e250c00c866369cb7c976bbbdcdaf5f6cfbae505b892e405cb799525e9abc6253165f70d969b9aed36d0ed73669b071938b126c2b0852ebd6d4fd51bb15cb5d36daaec327a358bbecf01e4bbc728bfc30ac692ef7da074db2edeb04c4af2bd832a0ca5012cbff74bb7f79c8811c27a96b2fc93e53c40d934de004c26cd0f702bb66fe662134ba28abff890dc316b81e8e8e24981fe51f5523e72523ecbbd2612f0ac35de100c2cd89bf55532555b44ebce72e05bc0fdeebf0686382d5b634d6fcfed649119ca7085fab19e2face4956bfca5d90374dfd491a679c5ff0c950ae5a3131a2f46916c1ca54f4a38651e676304324e5b6afc452bcc086e723c5fdf48d13f6a6dd84850c267cb40a69778d09d1a16df665db3fbab09a2dd258edb62392d9412776bbde6dd7f238ae27e0e216a338d2d5f0edaf4e93f912e1c7603696d7588c183e749aa4181044943b48342ccac182fda40ed8d4217dc1f44632a0d3a30288220313e6e0ad89824b70e3117be493cfc714bd7af53e68d45395b9d4b1383f0f7c6181b2b3a6e662783c2f92049472db1562d0cfceb7c5daa02897b8c2e76ed9632f76374032db70780409ccbf00010d1127b3cb465e77bdba0e0ed30fba4e217890f78eec5ae607421ee12dd87713554803853885b02ebe1b81271bf79ade0583d7cb0f8d7d5adddf5c7340cdac8adf7c9e52d1e498671e0f689e84aeadbf2e388106329aae883bb420e40ea7f3b24ee654a9d373224d39a3e5e6a4ed3841ece458d9c3f40a2ac3de7e8b317177242b62879fab22495658be4e18e74725a3afcb8c8ec29f0dcfddf73f0e2eff68fd30790f48d70367a9870c770d545d5dbfac33684f07db87239aa72726d5984bb583dc665e6f1df74331cb28a4ab8429ed85912a26fe8e9f910ec22ce0de8cecc8548ac365dfdb39fd67d3d41dc70614ddde3a371e258fa50b272ea098c19bb3620ecb0d84fb947290a07fcc4bc59c9049e1a9c451972674956aaad6a3a9c3cacf18948d3753589d939df71494072810646843bf360a439fd0291c43a4ea51c253c78334025e4bc5e49d5024dd67669c3efab344865e11ccdcb82f95a6c776efb258d9371f714dee304adf56c7854791ea58b9bf5213daa83a227a190803592845f5ff4ef81d7cd64863ac3cd41bd0aaab9ae9038e94bf2dd0649fc4234424a577ab892954532910c81eb8568a274342d0d6888442ee0c02bd3f96b8074df77351c8df247a0d555421f38770cb771a3876747d4266fff0c1b2fd1369d1e52b565cb4dc633b5b62a39cec7d54647c8d600522bb3d77a9a3bf1bda0a2301cef442fd2ba34e0a54a5c4adebf8460e8b9716f6b3bc33ea59e51bc1f154810ec7ecec4945f73fcee36a13330707baef272aa306fd6be87ea7645edff47d684d5405b343cdc5f63e3b2f484b779c0ac98f32b67f2d7e0273f7ee41fb66af69927f44f03a0a6f311b567b13dffe15b3d92164b9fc626231509f0e0998d2d05428389d4dea9c6a45934a32e7a2dc5fc0aaa0bd2c5e94a16373968a5b5b0939bb89a0f29e950fc59342a9f8f02c4843b26b97814664f4f254f22895bd23ebc40a013cd1b9b790f4f78a24cc16943f9c1d8332a4b9f62de296b31ca0145b63d5b75adcedbdb39bd90c9b2596f1dd6d760b9fe8551d2ee9e4bc797df2df0c781228914325a847a15e9f4ce7a63ac89774ccf7c060b501a1da8cd2fbab549a7b695f67aaad86161edc9a09113ccbeb21dc7e928aac7b088a0a3ae214ac14431fd2ff2b2b072165cb0678d6871778aef38ddd31a87cfbe4ca7cdfb3b54bc07c359ab543e8e26f36c0e4fd0d785aef4b7756f693e56041f6676343a49028bd956f6eef8b7417edb9af4b0f9f54104634fc755381b0fa8953e17ffeb64b31bb10e2bc8a588135f9aceda277da3baf2c51337a4fa6981a86b3a8a3bdef16a95760f85eaead1589928fc8a3df06d9107b4b95ebd4334634338138cf18b139492061b8008e80b736f6c1cb9487072e550813b5bab470898b0bc060d87e9062974e50013e8f943364ba0cd015909151f3e72e75d39cdbea5626a046281bd449aae24540e56a3e8e0122e48bc9cc75e4805d92199b0e783139ae533f457be4c40468e8754c7deba275a609bfd5ccadc9e3b1b6a0f69c83c21c15786741eebcb421d2424db9b5ea8ae3092bda0ddae5f8b963789710c8667c95750f7de8c431abdcba75c8a23a00b1c8a64a9754bc36f2ed6ca20dc12ab5caed2f14363db1c3c4dda72a0b44da1d5fb337391aa13efac49056c6551b9a45c01788dcb390aa1369a19562939c2869774f50435a6657e2b7df68531d7ca0a7f417097b1e7121dea3557a0028c37304e7381b48f46df190f65fe5afd454f271c1ae81f32d8c8e1cd26f56c5d05b872113ae3faeb3a5e3c80698b9394c5a69bf8ec1422f45c14af044e29ec4463e2eb3438ce5ee65cb35a51058a3faa54d20dcc6191ea418f1f94628afd6b02ce2a1f9a935a070c0df1f74d3b979df600160ce0c49860f9630204bed598e93a4401b29559436253715d2f303620ac78ad82390cc6b6a5cd1e436a7e62a929606734f499099e5f2cee58b8f21831b44b9a4c9fffa9ba17eb9233ca786f909eaeff70aa446d6d0ae318df91f1334329132775276f4cfa476d6cafe88ced514f2b14e6f5dfb3d2eb46beae978b5188f5c459758585aa08bd936bccc5dbe86a4c76f0b3b77f694334e41d20c2cba83ea28ce4baff2662db5bbbc8b273ab2e9fa491944759ccd988ae92189b14886e0d4f292c9456901f0dbc85e0fb42a26d85db99bb44ea449691c5124227c9f6321b12440dc55a1d544e441d9e7474c63579c5b56736bae4d240123b776a1e435a661bf4a312c5c77d4b624ee0ebdc2ada172e268dbb635e9ac6415fb03a212168a3b158121baa337ab8d0521b5845ff3b3301723f00c7b40fab7ec4acff27a9f90c615f642d4702eeb9a099dd2967c826c1927e68f8111d231e4bb7ec0a42d374da5b4a6321e5dd442567b12ef087bbc97ee5e2ec4bf8c77185f46eb2f82d1a97776112755a046b0c9a3184d855a009c37ae0a752000c326e880e72ff4158ad49c03f86fb11758e40d019d0496e287eb2a804b4394bd6700b4f5f3e90904bc91830bc69d3240a46908981399c8a54e03587c59530720ea66dea6c838e72ce358224946090fdb1ac5b4a5657b1868a3f31d8d0cf86f054cee83ceb6cfaeb84a1cc754a41b19b7c94eb71cef0202971c2ee1409ad345fbfc81e9d179a40555ba5ca96f7748539b5560c3c64d700abde8c56323b5547225bed6f487cefb09175851f15c074f9f0838263c9178bebc93f5a03f931e8f0405321dfbf4a9889776d7d4423ea54471458861c67e8687c1b3e099a8b8530a00dfcf5d02a84cb652f12b9ee43ddf695a26af59fc02c794495f5f842e5b30d968ee3a539e128feb95be0d224b47e465f603ab8bf9e06c994d0542d4d1c740c6acfd7a9d4e8080f80af776cea68be2ead3a3920412c9e9bc623016562051b26a1601a9578b76c53d050694e28afbd8cafeb37b94ff111c6c70ce04a068390a4538301f7eb5f6a2cb9e80db3b557736711f5d2994ff07e978db9b58de44a562ef18a5bf90855c8087f72b2dd55251b3d354084462f2fdabc718cc5cedbc8caafd9499404b5b9ba90d44825eaccd704b315dd6ef18b1f016d52cbacbb6f58cbbeb80c27f8b805c223b1b9cdee43757c47bdfbf38b3b0b877a31aace74de11ce6c014da1dbd59d058ea981175231bef9076c590eaa30ce4d6ab70fe4e5b97cadc6c8903cd2a4ece683d07d511c0de0334e16ae663a339c9b4873df21f6e1b3dee837efc0f45602ca521a840c81c0d25a101878bb7dae86b4ea1cd62c502304b29a73247954a505d12d9c293f02fc9150622bf412f579b1e9fee688bb4d3d2aded73c184b26b29d763e4660ad65a5a8392798c665a242b237071465dbe38544e7d99fbfcfad89d3a66d73856e9f6847518e273183f43e8c26040474ba97f7b71375461d43eaddd65fd78dc5a1ff20bbcb8efab07b6c5679327561df9fb9b4ed0847181440b5e49a88c7af03fa8fd559ba62bc7a738321dfa0f242b06389964f56db2e43395b90bdba6fadbeb506d4b4ad283be44cadcbdb100f219c778d3a89b38012b78de5c047887876639b728370ed07dcbbcfb1cf0402227b4c72f3c51cf303770162b26d60f08c1c24ef7385d206b7ab42567cb7e18e2e40c266654028e9e4f9346191edd6f7dabaf234df1882c4d2acb4936ff0b8e2c8b64b7e251ef8a11fad25c6e177bc9cae44b40e86383babff1514ca5045747bd7c01b4d12ad0188fcc037afe6572acdfff5d24f7c3b183eb40236e1e21bba434b72aa77e6fcdb185e8c54dc066dea3e7b0520a160830d13c4d2cbef1a598c8df6ee740832da99da7be504dc316b5eb2728a2c6a68728cddf6091225a1e27eb1cd3a29cdb8c9c12b7aad213a09bd4270b3782e412dbfa64562fb42899eb3ef96a9ff50d6e1f4e5e811e318ec86c47bbbfaf9c57f1c5735e414fec8151b94d6bb79449780fd197d8be76fd1901d2e6ae4ab5f56ae2ea45725343bd6b7ae0e7597803b1ed71645b0935325aab8ec520b526da53b3a77d9a039c4ec0d8f98c571845e62e5aca95a918320851290da5602bab09bfc329005682952a4cdd0849e9869c9c0b905fe6caf6edb1caea7fb4056d2f6d476935a63a53e19260a2d41e85ce36c7393f00e3040a666ff99bd380d8e5b1065ccc41942fc9e5678b55b91c25db91bd02dde05eaac2a03a08d246e27044ee776fe36dab86f25810ed546af83ecf00758c139a36d5d2b396f1c5bf88a9642653e32bde01275abb0f14a622f2d70eba409c3305f58de390437ee0e7a49aef5a52fc2b5d1feb68a704a147c41b2b5dea9a03e6848fc2d4581dca96753bfbff64caaa4d489c1087c37619aa700ccbb39c70c24790090c05aa5fdac412c434d698915d02d625293a362b6a54288186c2610665b12bf7a665d6ac547ed96fb8cdd35b568836bdc05073b94b056265ff019d6e65b0589eddfe7105fa4a403d859769f23b968d1f454daabdc6a5cc027b6d636d0ae680926e97b5d6a47d7c0d165c77fe2b16d6a65c2de1e8cb5906f125081ac6105dbbdeaddbf816db17ed7abd69de7a69d30e05e8c04da99daabaff1091f7b16537c36fea316aaf3fb0033e725fb4fb5d4e227532eab8b5141cd8f6c4cd6124eccf5c2303cb8b906470d2a85a79f1a49d3c635615e593da36419a1bf665645cb084d03638a417742b8d536ca85db2c6a9b938f5f02f9a07315fc1e562e10b4b396be87e5c6c95860301a8b9eae498483b0d5542e88b163b7448c28da06f9a3e60c9ee1c505f0dce9ec04f0f36abd336b8e1ec9cb4343fd317f9d0b625f8ef4be60c464d6abac30f4bea4a6826dad59430b3e165557d7b25ab91c795c6c93b62388b1024660e7488374cf8b2783f238e80c57eb680867c6d8c8fa24b246f1a53f0408d67d62085cd67926bc0e323b92dd7c75578da1fe7c159ffd2da06b4cdbbeca994c220926564a109f05888c473a8afdd9e3d2d6567bdc598f6806342990e69a51af1b14b4b76e828c163653897abed34fc92a4a3b8bd760b0c9db795f6f8cf6963c2fc4a60b32f02317cf7752d854b3a5bd662a9903a8656e60b3d054232ed7b033cf4de0b84b3bf5ec6934d919edb92ffc41a90d4e01c83b141789d1f540db22b6eabd8cc74d81a248e4cf50caa9292529df5e8c4d1f5415b9fcdaae4150230b9813afcf7ff0fb6a02044735516283b69f9af90a3bb550736b378f4cc36b92777a29277c188cbb75c6cb5dd8f1706ab7958d4150b4b507da31670c622e19be270d7046a4e7887f1fbb1eefe9ac19a8c61d5678f565d235ecb8fdf1721a8b493c50d3c751d855fce988a0cd7ccec8e0cd9876f90b7a7899001b144b5d5cea6332bab574455aca6968c318d563abdfa696cad5a61fecd94a22bb65c4beddef6444ec4a8ef4cc36aeafd40ab13c1da074b27503990e982ab50299edd7a1f86db41668884a589c1007377272cd2db0c57bda59c33a7abbcf024a6f1d456e9fba2d0f2ba53708ce51b8e7543e72433edb44c4cefb8ae6722d9ab4a9db1870512d25a6fced1cb8ba8ef61943588b8ee03680521946b757156cfaeb9358be25cc13f667d7e0ea7a21602eee5d94103ac3d2de43f3cbfd30432d82943a18cd1208d1b67462804d356eb3b3ca147426123bb2daffd2062583de756a9e521f28c86f928423d2a7801b2ea17ff77fca745757da1090208161afc5f2e2a1a0020261e269a6534490ea25f18c92b26e3ceb7930ed8426eb62a5a0a4f07bd234f22c2f897a41b4303ca801317fe8eba0d355266b52a474065243ad1f6a8f93d7ff5e9e0cf63dff0d150c54e08e846a19d4f7a674a04dfbb463526ac1aaac533add0362420402706a732a0058c24e9facffcb93f995f2899cf1ecdd0a9e330e52b3562330738ec278e3fe6af73b109ec92243caffbafdaa1b3d156eefe8767545bd55e2099e11e78d3f299acb5d0b98d70529ac63c6ae160392b05a16557fd936cb565fe5e6ca5e5f285664892512a1aa07ec07867906a8a01008fe7c14e7fb08f5c9368e5e59b09b455ee7527b36637ffa47aa1fc8dc90f35db949d20708c1dffa25f257a2fe179dbb928e113c0d7b56fa9d21f1ed2906e03d5a54e4738711d9f836730a2419ca36cd775ce5f5be2ea0ac878530fdfdfd25fe036bcf23fdff5a3dda9f518275ba74f0bf95768522330521a83f2f4b302736a55ea5eb0cbb4bbec56fed82fc98b3a310cf41b2645d5fdaf7cd2406be63027fe41df4c79cf955374718bfb65aa81b01e2f5c5d0dd73a65aa5318dc559c161b4c7dbb350131539338cd48ced41012747a68f85ae1923e6eb89162bc1e87297db7374c8f62f1e5811952d3fc03c903456540ed5ab65937ba16499250c7186e6b59911a385d2bbd981c545dc6bb0973e53332e87d2d52be6cba9ca5ade02c040ff33a76a5a51de861351e05c7bddf343f39015c682633cd539969a95ac7a042d5265b6c49fbef34b4ad3e5e4b41caa3ab458d95c58388bfaff70c9a58102903221023328aa35cb7c39ab057438197924169cbaf0a6450d0b48f61d003c78f2a764a19e86400cba903c2295a9519577636992b6ac303485778b8fefadce4ba427d6ca1328aac419f1113e5c9ada3a6666ff2617a0185943c7c3a048c3838bbaf2e15df844d79ef6825d651e4f5e0ce2ee829ee82575e8a681505a791f1a85e7aa602bc697a2cd02f6ec0be56d3663658e15b702b77ba6c2e8d04e29f6c803ae0dc50af0d5833f587c8c5a48885bf8348da3b0990138db3e1d843798d2849f79a3bdcb0a01ebcccd95768fa9dd9d42b3c7b172b34517d4ee5ae3829939770d3cb7e89cd7653c8b7c6feb93bdbda549aa83a039eea3c3c5fc52bd2f4417f7ac5b6fbd0bc235fc1764d0529c6375d3b2a911eeb81424416b2104052b0f0f6bab3295acb43cc0375672932e5c126e70e0aee6ec760c1761a219094573beaa5681961582ff40f79ce51f11b7815259d6973f9fa3aecaa645022304a55ab2263ff62d36698517967b2f1150d9361753fa90c799b0c9a12de68eab17fe12eb21ac14e86349564579db2a3ca43b8eebec6b6a52b7030008b151f2d1237772037c1a206020d948185b3988ca5ae2404c7fc807b8cc49788ccb4f32e8070a21d5cc02c285b181a4cad070fd4fbc97162876ce2371506db57932f3a34e6c0099f397f81b1ea4fd026f680f4a2a4f70d44c48d7c492eb3cb5ace442da07507802f6bda5226f78c2cb7c4113f33eb4ae94147fd9267546023f2f86b59a0257f9ed2c486474c2b8c8d929d6e0bdd268b2f72a50ac0e9e0f04e5ea46754a7536c02d1949e749e9ce4ddd587cec46dedbceac65e432ceeb5e9221ba2fd693640a51b5345468e1ef0742068fca44bfbd04560ae72f7c22c0f17f065d231b02beb68d424dc441cd3b67e20a3b147dec900697236f33183237e40987b4c2ec959d10278534a74d0746342c985c097d129ce224112786b37f9441cda18f28a8e45d33615d5b11c2ed07e9b967d6764dd96e91a55ee5c288889044395fb62d1102fec87f5796bbad7f7d0d1ed75c05ba3d7f61dffc0941c51d1048238e68fb7360647a98dc964217f1a9d7821e301cce4d26d0cd9d4a0794b39dc0514f71532e26bf016013d37027dbd11d10a96f458a39086036358f17f257bd193438422cafb0f2f79f2e01a6b5a596adf82d1df976c5d275c60419cb183e87842057af6820618d036e98dfad44bba629b03de30dca79598586abdda5b5734d5edf780ab6ea914a4c54e7a82f7993674c520cbed4a7f9b6c49fbdd1ccf591a9323f91af545580df4c041edbe0e07594d22a4490c1d47d7265b436ef76a6e4e362e8ecd295cb6eb9c68ab5efc571b3470733dcb25424a19015eddbc4478063d821df9dba72674ed06fcee87910711e085cc43a9d2f1bed1528efff80a8646994b616c7740d2b54a59d06ee5d0dc483d063aa91096a2c3222bd251892763f788d2c6904869c0b9c30817c796f1a6f0a605076fee4d452d01ff26e381d234be02207a86f1f1465fef4265cb91bc53dfc3a737a2bd658bce93d7f69c0d3c9ce8343f9328032dfb0e990c9a460a46a5522bd902a877cfbf184ba71fb3ba6b07ab55edf7b9e66bc31d977cd06aed00f4dcac6f3781340f4596134016157326426e38fad3540308c9cbe26bc7e486c3a3580ab56f6d8e08a36baf0bbd10b4bbf1a77a61d4a19d1e9df1ce0d3cbf10918e6793dbf1e4eb4eac82559eb08d122108b39fb3be4ec00bab089ce94359e5b68bd7e171f3a77d29b19ecd2f6350bbcab5e0299bf726ace5a930f525ceb4be3dc5dbc64ca0ab97e92b588865f6ab4ed06c05dab15fa71e9fd5094307a762fc42c596b42966159fafde56e16e86aae6b66b9e7932c433262edb77535c705e3a019a16f235db7270bc2139e6f34ae363339c839a5e817644d5c6f9adf14c2828d252658712ae1b31895aba097f662278b7469a45862daae5f38ee59b7de255e294f3f6eec865afa442d7572bbc17fa0fd43e3e3fa6d0df293515f0bebd6d7c19829c3d6d163cdecaa41b9bb0544e5a17710ffa6a89b4aff23f1d0e5fdf7926d6ef48e9d433cb86889d85d6090c6a6e62da111a0a8b79543a0f296a42415d1223fe2ebc98152baf687f4d4c672d9bb1fe3b6d72ed81261d8fc94b9a1be8733b4baf10c604e3bc7e9533d2d0fc97f8865d4b65af43c35ae92b911e8276aeb816be86ac778ce9f154b8cfa5cd92a9fb2ed756b5d95c22523a1012e1fe2b0ee78438771068e632a9ece88f204810a1a8f6f0acdfd44583b6035f089567e3e3bd2ce005354c064e67ec66ec3fd10e48154c881a80cd6cdad9a8c17f3b811477acc317e530f2ba2c55de5220105014263065fc4fdd24ba351f926afa37b91ec419452772268d68b7477af10318b2c3ef02b0e3d5ba2b965e4b9ac19b8920c1c3e0970c7bda9ad118cc661ac86fd3e68ef0ef4c5f84c607ca4a8bccd6ad3124cd83be7262295cc51f25e8b86d2c332ff8e703f22bccc3d14fcbec9784cbeb9e1ca8c59cb6fcd7d70b9006028a3b1c7b8a0f24b98449d9b5376f3beddc0fe4ea0890fbaf00f00f457213971ac13abe631d02a05b09f021687852f327941f0ad055f43020617421d10be6af040d402d370e78154ce1d08556eb224b73eaad6477872cef455418f5dcf53e4333d8a58a5addf45e6f6d363f9115fac246ef6b131c7f9e0b337f999eccf7463b24693091ebd5a69e21ec578e6538633b15022e01ab96c6d39a2d9bf1a2b7b5dadcbfa66c1c39780d9e0f8d7381ebe893510f3063726a75ee7b5ed7974b17f892274695ce7a4f44b161af4a7914f4c53001a3fb0e1d120f39864c043bf69c4a1afd4ae4c852b8ad2859cf992d525a6df3381f41e3d5f313d6d547197eefd6d6f1b455a7a0c928d158d4570a428f0bb923e457a94e376c656cedf99ef2c18ec9ec03de8831e94915c58f1fe91b53b129c3aa24dddc134c0fd6e57bebfbe316c8aeb06524425a30b532ca9d6668db3a5d6c0972fd459ab6f4aa342002a4137efd0a0633d247d6d1a5d85769229ce04ab23bdb1d493a6c8752238601143931f111b80b993fd896d9320e1e367baeecc70d5f93b56d6cea8a71da9ceb5a87ab24bb2f31a57caf6c9dd0a01793645d9d6c8fe31469bedd1f4e2ee8def1cad7a13602cf6be017210f80264e77fa89f88763339f55a19a4f5c10cc04f7783a9815c00ca666478209d79393f69bd97e311ac81301743a05655eaea5b704369162d2b9b5868c5148020992af9863ef9488221795b8a7ed","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
