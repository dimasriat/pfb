<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c11631732403a6484a1653c917b9aca1c6b364eaaf9cf98fd754f7fc4915a51733bf6d20c887f32f2027676d0618206f8b05f94ac1b190a5ceecb41b7f46cbbac6d772f123ad847302d3d381aa943fb0c9ff538b6f81cf15e9d65dbc21f60bff9e20834a38b264b13139f79410daf3860a90ce3da503c2224b15a78733c21c14a4b628b1b879dbfdf3e2aa8b454b8ad4ad2888e4285d4f2b18accd0fd1f1d80ea92c5538ddbf0feff54ad3fc6ff5823fbe8f39797cf53515f873c3fa98d8e4af6646b499be6ecb7565953ba4cfcb9aaedc288e5d489d001ade437b1c040821caa5c88acd0afc57101f8e3728d69b94c30c7195fad29e8c2b26861926726e84e2ec24cb4f38e6ea5e66cae35af2596c05dd6c014aa7a598ccab092bc4ed6175c0c463679d9668fd70458cbd778d8a123beffae194e5728ec0d4039932d59a82d06aa2c649125777d26f6f1ce0791041b9cec15ab45815e765a9712f1cde9c5b3823b8dff6a76fc37056a5c447ee239712b86e8c4ad0fb593c8df1cb8bb690fd341d3014fbb08985095d904eb992e47e6fd9177492c0254d2b84730d6ed13dc459f57dd2543bca7745f5440b850ed000e3f31c5049874291a7553a5d3c987340d685ecad2c56a27aea72dab718df54ae1b375b5ecf71a96174d3b7a044053c683e112c7f39a00edf1f1379aad1e0844ceae04ed57655829763117e48dfeee0d14e76148ad1de0fee2b3101676b93e7b19f8ba9bf944dfbc600874499f592664a7599dd647dd4999dfcbca056bd13da0be61c05cafc6aa88eaa01279902099f422ddf8aec45ca9220ab34f99d56d5585cc77ea63c32e6ab46c2c74599e984ab19f8ccdeaeba910b5377a00d295360bbc682e524d38485d563b1d34d854c0f1cc948cfd8dc36fa3dfea33f5baa6d3da9d0e91429b79f7c257df6a8e2ba6c1a488530a1c63329213e04a8e20d9e044390697523c8fd8a00fda54c3498cea5002d723e6d67909478bd6432717f6b856d9b14397fdb6b8d2f09e21b2668758c43d0d11c5105136bbbaa9f6fb0fe5762724ed5e8c0f6b72b5aa6db6dade540064173d3569d5cf07e3e7ad56415ede27d834e2710f0a3a1aa2a39f64c9dec4de48b05545f58c030d974a69fc5710b5496aea4dde8e87f872f8d44ccada4a7add6831e3c7414fb8a8b2b2264ebfbd01e73d9d67aba0494f16897e21e77279db9f1f7b758706de8faaf94a9f69ea6bee889a020f84a06fd442ce6cbdb15af47964534a8a093b14aca0a6a8d912c7d5d3ffb6ed8b7e4da51722c5424c281ea4d455addb3c6192b947935647390c27b43e44ce39815681ab89f7f9f0aaaafc1b5300d460bff4115c549dd6cab61ba34f115fdb38c2e8d0633457b00e375f57dd053fbc4e93e1e6fe9fa3130a092d8b53d257d54427a0a1455f930541f8e1ee3768dfb8f41a6988cd0cfa9b13b8ffbf3835f5741592d5300ca399817d5f024723c949ee88f0869091337deaf802dfc2c04305a8fd7cc059debf3a3d57cd46e8221ee770870d955778d6028d5d9b7205c23fa523a8f0b251932c14c221b0034952074e52883f79fda3d7609017b8ee0d766ffaca101ba766c1cb78eccc864be9450d486e09e00b832eabbeb8c01b94200d4166f4796d8517e64c4b5b37858d0dba694ad7fb2d4ea2835738741e704455a465751234e6008b5b7233bcb240feaeae74c3ee3339d8eac842fb90ed22848dd3188f0112b127e7b267a52eeecac908634bf40eb98378a40dc784078fa2fc2b2affd9441fc5400cb263628829577e6a83d79f7745e4f38b50214df315796b85cd377f4db822e4c40a20593e14feaeb1f82d270c96dedb004d80464915a52e77f59a54a0114ff1f9992afd07465f1989f0e140ed76e23e2babe91f75fb9fd55df4e0db1a7003d65862b35fa37144a114336f4b3e8df51db73914ef2a20811a19875d36efe49cc2024abb08c7719f39864b5d3fbd4b59b47f45ff33dce916cfb31f80aacb092b95ca02aac6bef48c5128cd33c6cc8e596a1e225babdccac72c1e9a70edf7779cd1d8b3044683c4c4b6daf4aed9beeba63ea92b31b143aa2c080eefea998d2099f0043684d324afd8851c8f4af167c6c8a4c50804e9d81a8787d52e4d20a722ea4def7e2591c6636f0e82bb5bc868e55569774fbd9193072598c3be25910d106b6f6924e4ebf27336487bdc7c22734d37c73e0f516f759f73cc23186f0ddfb2f28c5d6ad54559df61e771ef9698b4f33742e43aa1aef9ecbce596b2553da58d9c316b2b7957a21607df813b9d250f293223e793b0ae7bd9f441d7fd8d3b60259714f57a8afe3b299aaf1b7592971ddbf475adb777a8314f8ec107983be41d199aa1b8bf03f220b6d5c9eac9cb05e68088f04c3cc81889f1271eca63731646006b3823b78b0fb76b40e5f6df7d1ca7d97ff6a7ed613a0900357484c326ad2070de54b06ea18f3c890cd2b531eb7486304a87d96aa819d0e2a269db6b99de43931ad230e9022c0ff12c65ab47f5b19bf615fe89921aef9ff8ed04a860e6bd2c1651676a34464f75c82e774ee8defcf9873e0a7f842d40eae1122c116aeab9d92e9eace618dcb845a17e701e22ac90f701444c57688d5d56b3134e053ccc0a6341b234f3c19adb096245ace5537e99c5854c55a1ec5eb193ee072de2117c9716d375d5fbe9915c9968cdae1aa3f574e7fee993d9888eeeec21c7b2f2f2eb9e48508e48badb80eae4b9440c1ae881d9a9eac637ae990c502a1ccbd4c5d2d03f8f410656dfc799a18e618dccbbb1c9982aa190b92cbf49fa45a156c2f00830c71fc89ff2e89ee9daa27c3ed940b8ca3b703fb10d560511df76996cd2e7037c879a775949bc979759ee003d28bacf33b9d7354bcbbc78d05452c566ae9baa824509e8df42c889bb8dc48141009c0ced8a75c43a06a3217099a6b75ba16cc575886eacc7237ccd5ef80b2981cfa4aed4ae5493f330ebc87b59b96423937ad71b5e29f19a49a40db68a4e78fe0e17254c5f8cec207d23c531f68b04106593dd5a22b6ad8e75907733239f51d428072a81180173a23049d6b4e7eff3f248e1fa40cfa87713af055f408262beb9e5e206afb4e5ce89d82cb2afc57aafe12561a430bbc592e2a3642c07b039ef1b670c54e9857c45edd16c0b70d51099e62d076f46445ea2ade4ed309b8377ba174dccf4d402e941ba32ca4d1c837506e38afd4e0f3b7e5e9a89fad00c79cca1f24b002a2695e1a9011d17c6315fd23503a00793264b0199bdcf2a7a3835466bc7704b0c448bdb7c26cbbab43bf5032cacba48aec0d2d7d73095f8036b0bbf5dd9d6215f64c30b3c56bb3379e43538c209c68f1f52b32bad1624d694ab7666f4bc9975908bdff26aaf1f261d81b4f69c31f55436a2c69c3c6a7d81eab05857298e35590926aecd4e3c0901cac2653bdd2e5142103afe7b3b2d7b3336ddafb62d0993c03307375539f4e203d8552fde13cc69c5c237448beb5587b4f96717cb662eaed42e97b7b2aaf9e5fbfb0dcf20c5f540f28b9c5b465842d3cb3cc9304f26b8f8347c471a5a4b634d00255fe6b205505f2244001b4a2705431bf7fef4a01f22506cb5dbc9eeddc6bf256ca3ff105884f609ae7c67f864614075c470ef09df1cf27bc42871e6bf548f7c70c52f1586243a24ab0315c55de0321e0374bbf767750b0ae81ef12d962038940e4b3e7813cce0aa3df620f03e0f45ec253d48459403d7bdd4f7c2b51e4cc06aa8332ec4379e2caae9b157db9f59060c36a35650389d99d162944f5955513e4163456d9541b8179a8a462d2c0d38fc9c5edc5192352dc1a2b5edd0e3dc71c33b9ff6f6e988eae367dc36dc58cd142669c33aa1b53de202f8150c454d5b81ae9b46bcc95e679935167e97058fdafb02869ea211787e7a9859ee9f4039803580e888434ea1ad68fd1404d29962df0e773607c8ad0c86ae945d3fbc11b8143a29fd5d0b389ad4a53ab6cd08afe7778a3e48a91e63128b40d4540f573096504ea41d2a4d46525e8edf459f3ca5476884090b6e34f4e7dbb67bc7b8b6704a759a5c847ffdc9c2e701a020d57c499efb539d030dde68b1c2144722d34dfdb8adf830e2adaa668d0424b71d0206060f4278d2c2cfca50e304db95183b9d9cc4c89a7db16e9cb1058963e0a53e0c769abeed1f8beff1d915af31affa463a6bb5e813fe3f7c64282d6dfaa976a46a677359cfa806d82b5a57eddf31d1a922c0c0b6c7f6005c8b74263ac82221e0496970a89f646cfd92a7873a07fbd9782d1c75a783c66fc96108e2422009a53fe6a78921aeadca9b5998b9c1c59da4bd6deb67bc666b7b702a2dbb6cfaf6059c9d5878ee7b913270bed3efd47cc1ff03596ba215e27c5a5767408ca7b8cc44f54c436d3785f1c2b1898e0ccdf0d6bcf1458b41bbd67cf999cf02e4c9d505cb64f0996aa6be86731fbee38a94f5d324d5b4ab506056bbf1d669b3fcd31346725b167d23c17144aaeafc3460d8de61ac3a301c987b566c17b5f93eddbf9a8b56807e059ba175267f345c452fcc43b95e142967e7b7b0e5f5aa81c38ca244d76c6b7544241d97e1aee15ed12815b735524ba4e8bca7024cacb2dc712b3ecdbcd253b259a1427479067dc35108432e0196634054020ce99746577d15862cbd0128fabbee15d3d1b35ee24f703f85f939f3f793a9801b1f977b23c1cb24a856943702f0884c06629fb0e19594625946c0b87831ae7663001df1ed9046f3ed9fb85b8ea03b906b622153eb5a6ca777df8d8db8fd82057c9ee2430ff5c4f28e6f152f46b3d349f458781fe3943357379115eee2587d0ff1d9c859fe61528d2072fb9f23a4b7594f2f7bd699ec69578ea66da6054bfdef5aca527972bc4f70c21dd40daf680cc1a32e2422568450fe029203f97c891c9f202b0146ff7a20009e16c178c73a9d4616406f516234c48d1b408a93cac68fb15c05ec26231c2dd9137ce83ff526ca83af4779116bf39c2aacd290d7007ed379c51ef756b4a48f6a9dbb418bdd75173ceef9b9ca86447437fce7a882df795ae46cc520a6d843072e56e9d102bad508750f616bf14da5b93a8bb271c7174cc0809d73365d160a89f7185bb31e8fb4b5c32848e7cfa465e849df7384081fbe5bd4bf02c548d50257258954dbef7f5f94d4eb46e2df544b93e492a661006beb219e1fee92c6c1db73badcac602e7ea674a0f0270789f9952a2ea330798f0920ed13c676f757a10ee52047cfd3dafab61e2b7a4cd6c680ce36605c6529d8b4dc4005f502f4d71734da2080f2db32f542f9a649bed8bfaf37f5c59518d3f7e234cd383f6b0a2e3fd702289fc8b68c2e144e4c580fcc0a92e88665933ab34390111e3819ccd8707e20681a00cfd9cd952fec3a8e974a6c98a7bf69cad92c86a7aa662e49f971ca83f53fb93c03dff80a014acad08ab397a6fdf13b6836a16265189518bd465dccf77a3a6757d41311b6443d7e59c6c53c2f04a6ac58c54569c6fb3ce731a899860109c864a66153eee0cd7b54105266e40054584e8f9a2d66a71a17d0e4aa068aca06d09e22954f20fc9082bf68fa6983d0cac2e35ae1b6aaeb5e29dacef83b8a1609a58a25cab26f19567e6c679e91e089daa27ceca8264b1777f69d2768a26b2adc5d5c417a4758711a9e0f7bdf335cd185d57211a21633ff92d694289f8cc24f42211abac1f542de1cb2be86d263484cc9166afef6b5c10d3d3de07c9d5068f55ed868bec557f988ccb878a5d1015ec13f464d5b012391b6af7e38d3901016e57a8b5798b7beb542ffa30c33b8d19991d25a9e007e7ba78a5a929a6f47f6da9630ea798eb930c1051810561da79a14b99d54e99d1453ac8c1012014cc8feb7f5f7c910a2a38c4d12bd50812f712d19d2371b5c19bf76dde2e53dcac28fcb2dbe0b7617ecbe2bb8b23c3060005e389736c4f01551e9c213902af97e6551ee3b857975d2bd34301a6515625ecab739b3c3b1bee6414d467bc89dc057219d16430f28f6f5bad178787412452ec0b391afd2da681986fdc6e0377785b61a87cfe10c82c877ea406a22cf089636193e8cb11b50f4f32274a2689c762b8a8f421a8f4bc7d3e66a5d38436f02965a579a8bd3adac9b979e1d744c5d44e927ffce2d28d1b8c5a37fe1530facadbe2640d48b218f93e03807f032b9e843541b8891f057dbaf1d8a24045a948bd0337fc7478ea6d961af8ca57eb77cf662c261b116bb06373d99d472002bb50bc6e1e7b6391fd3c3094699d4871a400e6c1dfcda5f64f76987439565a9bf03ced6e32ae991f73e8112d1c3c33c4e75ec43eb08be4e6f076f10bdcaeff2a34cac37bdfbce69444fced9791ae49a7e1f1c15f382785b2eb2b90e39d5888a9aa1f9b3d707d0207227531f48765e12fe1db2fd127d3387c2e9fbc2c073c1f145d64ab6fe591173a9ac9f370b4f542e5e36bc3f294b1792d1a743daf86e76d48a8479872b0cf874f07024d842834d4abafe65d92af125bb72a4e3f6d6c277fa815e84b5ffcb29930deace0d3e41611ff17398fed7015a283670896725d5209981460887f81c1614119de534b79f2ac5a19e9251f536f284643b8c2faf3c03f62250302b6ebb71a24cd5c8804f0da298bc0c3f7c19bc993b293cc8dc01fe007f2201ccc06c9839fc1c7bc0a60d4f4fbbf93d281b643f61e8081642629410078c14785d2c579a6e84b376a903884ea8f59741f76cb770032d73dd4b072f165543bd529236ff0a992d908c3e950e461c141f1c0a6f3c2de65c5480feafc5569efe0b9cd8c7016ce5a45560bda50d1649524ecc7ae8020762a3f9d8e60659da3a15e3d32da2acaa1b72466a61e062bdcd50461767e7f831fd648c1fb34463e7dcd105a65c08519edebea681a04ac460d38090fbf9b5322cff1b71783658d89069cff00d24f48e53b6d46b187b4b6cc3d72f8f9265648d54f6b8e69cecfba7970620e7fd15789554116ac16e2333c2ecc338dfba8558b2dfece39069c3c408e5e8b365d3569562b1707dc082d609e2b6a044f9fac25702d6edace7fe763565bb1abf1ab07410820ed16b1ed612e8fff2ffb32b6b14b0288268fa289493748d2499659e74caba1b6083f8a8e72169fda160e99da1263f6c198b0551360019d6ff5372dd7e67dbca8d0cd173e8ce5c0fb6a1a84b555ded6a8a1c5206fcdfa3efb4efdfe8e9fd65910bab023ab7a9f15350107837efbbd1043fd92c75765d77834f5619d2fef0eaa1cad657ddd680ee19c063cf78754031490ff3191fca8b6963154329117cf036d0a9ab608b8d3929a530f736e0e4325450147896f8b858fdbcd8b4ae39e6276f2ed3fb84a5131596b0e079d7f8df94990d039e0ace2bbbbf64c431838a611196337e11b61e128e6e3565e2f96d2da64e3d64df77aabae9d62431e3f1289fbab82a718d35aec2a0a3302195965386adf87f1d716945d0b99aab02b5d3daf767011110b618491ab26a9308d4d4ed9c187a9e7241a7fff4a77f1fb78d39ec78b80dcb41d1d87e7c2adb6cdbd277674b031ea4aa63e3050a5f468215e69e3dfea9eb9d344a8b7947148e7fa0fe3f9eea42098c51dcfeec9494766dd9b1f5d32c90d772034476138578387fa0a54ce5114261fe04c9a4ab95e4a32b6ca247fc528cfb45b0f40fff926e45df718d0f49c08143253c3983a1714f1eec9b364476cbf5731004748784ad9128c55c088a35e6dde9e6906fc69dba1154e3618795c0cbf3daae51074f60f2dbba25c289aabbf2531b8e6af77a9507ad6db19a2d63891544b7583c71ed4538ff68338d459b2178565d10df1af519da151e797782246283ed36c7e0fa1b5f5950a7038452e16e480bec2d85314a5201edc1adb331adf9533cc91f87a1adf16c3727708677839d0f3de958403fa46d132a974cda3fd33a57769e4bf4d337cdda0dd385025c4159c6029df9267c04a4590909824517ba39d1890828e5b7cf566d222dcb57c010018dc44ec4e4176c2b18e1caea49785a83e99769708d1193c35407fd372ed9151bd3b5a4a05d48e92b8c349c9d3fcac0b96a5441cf783f9a1c9400f4b24c29002e6bfe64bfad0d420f35fbc6dcd1eb419316e4dfb42f22683207aa0347442c2831363a42778027dd9cb7a01e390a302cee25b8d0efeb51b2cb6426643ce3e0bab9b45326f382d8e04632c33284e968533be38990051603a490657ab1e28cda63e0e7049e293594326c592811ea6c8cb7ddb11a593547ae80f3eeb22a7049c00416673682f77a2b9da5870ada8883986cdfaaf63fd65ac8b5016689d1fa77d058cd0f148e6c42f373c3673894b450676c485c3bd51d17dbf70cd8db4d35f3c002ad13b24db4a09e73998f2f491d14f02fd86f7305bcfa934e3ee5856b04bfb29fe2fcb885acd491d68b39c13e336d624093d738225e7d9f16dd8cb036346f4409157f86488d3da542ed0345b1dcb30086d9b05ae8da6854a26e7779a65206d23f07bb85768dda0f7d9f061b530e3a0e7995a273fc16c363dd5432f1b169a19a94fca6422df4e13a43f164b2bbcd1f61e5bf099dd0f4da690f3aca5e1e13ca2ef14458800a4fece952ae45611bf273445b59b7c7d48cf5126589b8df6949c956f9fdf8b2720b2a98e825c9cb55306f1f275e0755c9c4986f104002cf4f1adab99cbf0eda80ccf531f02eee70b0c84cb7cce0e196ab7a5b8612a05033946232b05bf25cb2952e7440a081bb464f71728cd2fb13b8eecc3ddab7a6dceb7ecc14e7702bbf91d3d12bc2bc0f128a3f58a7f9263837ea06fa026106548ad1e6035cbc4e7e555918b723bbdd20715c6aa9b3e1e995853afce3d984f6fd8c882e5ed78f3b923c8e6d26ba84726e832c8831fa49d793bad45179f754c0529e9f2fcb47f9d9af906b7239450496fa2e2114673a684e65eba7f14e704d4ad6b4e194cf42a7c2f92405e9b4ffac1b818c81e05a851755c97b734f979cdc883e02ccdd19e7466c96da7266ed988eac2f68f00140696681ade2324bf8eaaeab3ecc09747400eb94065e0668e616f8885e837076b481ea327ab3d67fbde150e5f5299f56822bfe902ab44241e2c746410cc7d08b623d78bc9b32372e6f4bb24ef359706a5ddfd17726e13f6ded22ea86aa0a7a85ecc50114962415f2ac278f2c17b3c03ec40e0eb31aea36b68132de774a7494da75e0f9cad18c868afd5d4ec8ba15021463e1304eedcf7d9da5abcb64270511f5d26bae066e9c4e1b503f2ea11023e4f5e390225243701bc5de5a12ece906a72fffad6af2a9baceb1ee7dea479a5136a671bac51303a95e079c7c5529952b1ca776d5d854edf1b7a0f11f9b3a8fa55d78b7d1b7de416d5a66fd952ba07d6548a2ded6f314d0946755646371aa2a79dfc8fb5014459107aaae3179f3ac3229ab2f035371f21a81ad4a416c4cdec3c8f4aca32b6c90ec809167bd9646d59d9666444a1d6fd84fbccebc7cde51c839e078e8b67b8dc7da33407015a77317b9df8e02eb291c573874ef86b48cfb453264b0fde4d8c8a7d1f3805631d9a719ed38ad118e24907d16882eed0792d988531cf81d89d51a4600e8e547725d0cf7ed76b767002973b8ead1e3a9f824c87b495cd70d3748bfbf886853575806075c59847574fe10effa7b311b040bbacae0f20c9f4ed3a980b56ddbc02507337d592378e04b85ccdd8fd433950e28a41c62079b363fb1591b0ab2d466e13b74a66d3481976a6ad97524ed63cf8c94a215ad72da32c2b8295c166dc93dcdf78bbad07762727716f38e731ffd3837104b2ae8e6fb769c2946ae973b4eaf25663034fc6fed42890e1b0efc7fd8c876b728f4d51d233dc3d9507dc8852efb3a4b3e768cb6029df48f386c6579145a2378cc7b857d355e7c613077da09c3d15aecb3365931291eee33a1ef3e5af680fadd5977ee8808f808c8499a4d1d8c3a94f98ce896ba36e35d0020952ddf6d24ffca2c5f7061f6e5b509bba9820ca5fc510f5207f4a19f98fba772851e80b5359c57db34822da5bc6f51b01b025d1bc076bd24e4d99c7a22df9a130aaecff40fadf965df9aa09c41fbafe2d94a41f40fbceef38c267196204b68f8506da9e7699e5bfc06a6061ec43e9d513f2683d48d68cf6a804c1795ab5ffddcab08831e3c1186d229d99c31eb4bd16e53c972ca5a72efd2a937943a42fd972e28d737db90818fc22215fc7c8618dc06514a0737b855bb136df552c0fa025b02a05c9bf991b3a0c1711993ef6ab4a1c215ce60cf56055e64048ec9e5e634ea46af92ebce26a3b5ce3085553ab0f1c10cef836c8957031be7cec97cfaad734877c9c5b30ccba598b111df8a331a0d9c5b390dcc2820a6ef9aded04a14467e53de68d37ef95c8b3019b8f3e0d357847b6fdc549a8396a56d2909dbe37f515a30bbae44548cc1e583257e93d4dd435bbbb763d54a503a2bbd7b592ad8ac14ad038c1d8a6ab26743a9021ac4f868bac953a749f136ce69e885070e7c186c957440ef355e445044b56c815f21431fb9a537e6a7bc901e365af28cb76227243478ca003d34b7c7a4b180a3d27ac3df571133bf2c26d95408751aa45709503e84c707932af4565c6fd89cb818e0d9350eddffdd2bcbdb6c5b3700cb9bd375872912db8ca3942b1d09ee8ed8183a0a90773b31682e13f6089bdffa306a9e9b1339b4576bb9a70ca77f1fc66a5073c4fcc957ce5729717efeb44fbfb4e0e214baeffc3de3c9363291b3e06e9693976f3809445d8c515f59fdbf0ab271a6ad402d21a56864577fefe29e5d897d395a304c895c6a93184d1f5ea4e52d9a825d83397b0a54095453bf12a49874ea6b67da","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
