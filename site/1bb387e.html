<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91ce8fa0861c4fa889cf9fe400859238a4edcaa3cd363718c4937cbaf5f21544e691e06c1b796d04cbd0038bbaf0afa26a9efa32c5618314ea3e8569737a5fd189b77eee1f1ed02c8d9864a9778a69e7f8a6a39769a29cd9e3c073d6156c4c989f46123444bf5bbe64c5286e00c1732155206e7ee22447720ca1e5e5f9e2c00fc84dce10af9fb30f77e5b4cb0757b252dab893df28a278b6a2774a160a5a21fb163ee14563f68204383e9b45f49edab4ec974f007192b0643845d3e048d51dbcb5f5507408fa7e6068dae1a3d381c9956f43e36ffd19a812ee5124b6d0e558bdcab172b9616a0e3d92a86b55a5ec1a08913c6c3502185ae36b129036dd32d2032369fb98825e49c1c8620e756d1b7bcf3696944a45ac99edd591e44ca475e590f8ef1a667aff5f22b35b54c099c522e71adde7d51d480de5f6f468f883b69da8b71d427702f22185e04e15397a8cfa0667a61bd3b328595523d0dee9849a4b5d5c79761b9a876f24f48e806edbbec17390329fda1191ff92ae5dd6c8ebef5eb1d615e00b77c4441d2db78130447bb83684b5f37ac22f2ef359c207d2990cfb17d4caee9e6d4b294575d08167af641416bbe1d124110ab7d9d633f02ad89914afc8fe5b7dc7504d9adea4bb44deeb32ca9570a08de3bdf61954c4ea14c1fc903866a653016ac3e8eda25bf3ba05d0a08152043904a6e95452aa7b831c3655557f6e9dca8f432901fc32275d0d29a3db36bee6ccc54b8869886b8d00de8375e0aa6b411d89a699d22c6298883f89d8ecbd76e322cca40c5a116ced7753575b52e5aca4d613266132fc708e35e1ba21648338fe0756fb462eec568096124538f4e557e5539e94ba0b3b64876f198a7b93666f3f058c53e08caae67c72b85608e7ab89021f41999f8854276b5fb8d94b3ec5af5fb66b257cf019a5e5db9718e143fc2a48ef1f446d50836221013fa88a18bb3f6a942be855827df9510c80dcced2a01e26147fb56b18bc58347f2c57b42f5e0bbb75a7fdb7d8ffa169e99760efa503c99d5f3f3b1d6516db1e3d55097e6d22e1506b80d7dc66c859b271a3818fb761bad9d11e7c24c93ea644c973114e4e1bbf7cbf2060548797f78db6b4cfb6afcc97f1b16ddf5cf036c5a6dd27e6e73a5c66d53d2036c13ef7905311451f681f8d3d95c03e3b2caf5b091998ab615efda20b04996aa3e4bc7f2821c35b6106fbf387e0af87ff29b35d9f33c29df466470e84fb9271c740ef666187598d1cb5334d519a4e2b007efe6f1ef296b2e72b53cabe64f7ed3caf84a60305e4d28e694d776d14d88c615b0db71d7d935a580d6547dfcf9d5410fdd58e65554a08a0071b5035cbf2d66fe995dcfdfa1364926c5aa81d5c5ac29564096a58241cba1ff539d270bcafc4813006619e143adf2731ea24a98063160ed591e95d477abd78dce6592412d0a515b6d94e3d4688ac7395f8058a37c958f238aca0065cdf26cb9901309c6683a478c1ed68bffa1a89f2205f1fd01d2b27cb06d22516a26faa485b6ca216ebcfcc5a2b7726392e947f244f1c2f1ebc85e56d84d829d7fca30114390bd2ec0f391ff87bc0bb9449bea434aa2b104db42b4a5fe0896aa77de888ba9a0d6f56900ae2b3852bdaeb25364db7daaeddfbf3cfa607775a922007da97b1a309d5997c0b21e0c0e15ce97f8adb465191d2862f06c44ce068ef0ffae9f2de9cef683c87de2eb0ba6c50ce72e9215a572c1e1505b98868b9c9f2567ad4e7f86a2772446a11adc9ab841ca0d14acdc24588159943ec8ac89831355cb4d92065d03b5370f6c20ccdaa52ba5997978440ff6d13822b26708f6b9f753223cf17ac0ebe2ce104a2dea1c6fe4e75bee097ac0b8ae8a5707231be8fa97b22ff926a63806ff68db4eea45ac1714674842e65319d132268506670de14d01ad3b379717744d64c8397489920c1c8f7a9d1879fb92d2201117093fc2f4ec98ef7fc8d6f1e7eb41f190d8e2d69c96f9931e46b76351a1df9992b851221a97742d3fbf120bb47ffafcaf3cf3e3363ed648e3a035ca7e0f1c97bfbbc6c9d7ebf0b8fa2ac46d3e116083fb403206b4abcd8dc7ea0ac0861f42470836ba1f84c8373e08da1013e00a283352d1f6ff79e009ac8e82352f6baf31d9ff85dbd9dfdca8f2b4c46366a5e37f8670bc93ea8b276fd67028d0c8d8446b8709ff2d52bcf37be139cea0990f29158096080eb2523b37da2f49dbbe7f608eef6523f3eee2da21c7acdbc6511756e06c876e122a003330718ce93e0a1eb24c7d9262b1f23619e5abb07cea15cab3080d284248dc744bb9102074763ff86d2be0d4eb24de90c980076238e8ba7b106082f0d1d00b7a45ef0088517c9e06e9437b1b5bf2bef222f11f5341ef7f78f65ed2c7cd293bf6e66417779bd9016b52be2384d585c416af7afd61defd481af9387952b0bcd16f7299f59200afa3f3ad2aa5b52341d34157036080f1af0dbbe54e78f745d2d629207a013f77edcd9cb8a8825d7078e00cb0b55c54e22c5f61f0302c6deeb4a93f2b1fd7f71c98594785a2ae8e3cb1b247c9a6370e20e11faddf0a607fb0827028d262b0c071c743c5e21b23241ce4b0b967c7691ae8de866449ef0d1fc5963faa065df6729d3d90dfed92b55dc9fcd62f01bfd1be9c6d2f9b63eef449cf2cea205a20e59960c80a55b95c4d5e1f1ad4c1904adb734d3f144c3a6fff930546120abd90b24d3cb6f7afba4015d66b7805151b7460fac86468a94648079343c8018576d4967ec6ff26beb78e1ea4db49f054f10c4a3faadd3d6641e9049634c0b52758d765ac7af882daa573d72c80f982c6bbf29d6b872dc9bc0046d9cf7dd759f289fd84c41adb9591d1926ac53155f237dca66143fcaeca48cd341af66fab40395b4603e1281ec5cbefc07aa24f7edffc329b751a84462572ac7a595749c536403df7f20b54143475a941ac6675440513203bac584e87fd4294bbef5c11ffa3481beebae6110922ce1e3ffbe5ebb1b4437529e4acb3c98c95cd384dd9cad8584cf216c96423efd3ddf2bd4c79f1c3f7361a0c1b23456f16b9983e93899fa1b1231101f30874383d4f5ea87179daef275c175f68b03b60ad3c9f789b7112021b161f850b898198532a90b08ea52272c45a9fcb6ebb84fb741cc083a2653e55969f0735f691e01ec138c4da04ca9d103457b94b6ba81b2cef4142906ae8037352a3e8856822cdd5c10a9fc0be47004bf4ae06cdb5e1122211186fa3b161d551b6e9345c229a117f1b9d4f8ab4ac619ada1640f4ef81806c7f623ecc21aa2248b666521808700e8251db315bf07cdddfd2c1f482cb4982bccea08b48f65d3276a3972c4d48b4fc506e42f1644f985af8a96b07a51681f11f28f5c63e1b89664c241ef208505bff1b8c2e1b0ae11e0c8b7223438d90ca55852dd7e64d4086d25a9ec5db5cc05175d4c166640cbf7c82d7c83241e809f9079afa7c2dc053c88819a14ed09946585b247b0391d62247871b31bd54466e037990462395a4f633361507f06be28522f2c3163831483b16367f38870165657e76c600ccae3d6ee38a53a87b28df412e0938586261e23770c77cb8821674b8078d47e1d85f06f841cac8ca9fb024696ab2c5fcdc685775249f3571a3a306c56476e3378caf239862f39a4f39506baec1352cae0831c86ac63d08272e9555fd8bad3c5269bff84ae9af20d2e1c08069b135f0fa798273151a5d3d79980249f097eac5775974f970a88e54872b64a1e9e95c952d3c0d71d2ebdbebbf76e20b0fb4428ede35bc64fe884c26b85028b86af886cccebc9163f8ddf7dfefab951d13086b18bcee49d8c33db2248c6e7a05835cdaaae971f5ab11ec1b934bb37eda9a70fdc6a480d8fd9f7ba1f8b4c5c3a866bc1f977ea845bab63333fbd886e1279733768f0df65d3caca9c7726d898896f5da4d97a99a84a6d576563c87e9445bfaa5458ce7c49f7f3346720d6ae69418109b1ddbbaf96122fef85fd0f99f4c614c11f86606d5d1182e4e2e00f9066254ecfcf9740a4f44d39e3e2f6b0a1792aaa430ff166da08dcb77be062ebc25529ba08131cd0c027835ca7a4fe2bdb0e053dfa41dea01fe680fe8041f3ce012caa3dd45ac51036ec1d4334b5d0f6c4b418fed94d5468a29730601564fdf49d5d49778f4381cbc4c76121a00502cda8c5496e494d2c80bd4961c414f33b8c3dc8df1557e0ba37414a36616542197d54c8fce4d833c19ef691501393a1f510ceb92069ffa7459cf196756219406881d789e4b27f4eacade9b9d0a145e6d81f9d40d6e8402e5935f70b01c52f20f0cacfef8e66a975cf42e20d4baa239e2ab23e9d60d08ba8996ca4b67e997968f517836038e241dbf9de4652767b03824c556b06df9cfdec7535a301da863d0d7b27f920c7742ced7f8c14a48743196a45782ad716d56836717fe024ed6741723c1dedb4845a5e33e3e4abb0b35d5e5d69beb679c6feb165c5b7dda677f6dd721db102263d12f813e55be98b6bb48a551846e456f6275b2a201cbb017cdccb7cbf06dc8c94e1311d84e1bcf39ee5da27ecd85a7c84ec64a792fe5c842c55eaa16437dc747acd2544298984c8dd43814d54fc40254f251de7ca611ad7e04b86a4404c4f449c0f80054f1e8cf89e937c60db24c2d6fa5c4e0bf8bd992e4e250fdee93dcab03910aebc772656ab96936cc61302bf459ea07a869f53b3271fc89393bc230adc4a33dea9646ea4231531b569d463dc4e25f572143773ebf431daa61ffb2509c2bd7503d0d229553562d0cefc7e122cc5ec9e0ad9629fd3b60eb077f6945a8efc07719dfcb51645d15d7d40470179e9ebe012e41af837111d0fdd1b82c161c0307b363c44d4b18729518158b21632591e12e3a85bf456b8d27b3b87e5ed94af062be092f1fb20b80a090caef9ca8871fed150e004f1daf1a5006552066bfa3960bcb043fd0bf2c187754463851bd893d3d75000608de934db072312b6d399e5ea10d8b494ee5039a81e859cf7df99a36d2cea94b6ab8ba6d6bfa733625cb78520d5a6d9f8a7cb56f6c2db65570a9819b6e683389ff09fba3f554effd427a2207e2ea0af71dfb523d0a0493d72add4f147abac08585ce44ea2bbf7beaaab966130fec8bb9999744a57d71b36a93ad63c7052be0940991ced5dee96d715cd103ef8c2f32215035e2336ce091e94579bb29b5b134af5b8900820f163905c68dea62a917acd995402f7c504b48a56c195575ba8a41862073a14621e593c1e2b94ac279ddbd2d81100a4729b3a060c51f733ce9bc7f9f84293b9202c34da6d6b8e11040a316c662923cbc321a6be627efce7f6c202195613ee03498c3dadd19015f9aeb8aae88e2f5b4c325d46df4eccd1a8099dd492754e82d9f987df1ea907488365b3cfc87d3c985fcdab6bc4a56db4e3d29b6bcab7203f6c7a9ad5b5c6945225a6246642dc3bd56c8445bcb71c0e16a94e76a7096c30d8e990516fc95b0b7e284f4d7cdd988c7ab4615db473977feac57e58d5d0533cd698a5bde078971f3e8798b083148813a1bac51191f15180faf900e3d8ec759c4e3981d0149c99c23ebf34db30c3167cac651eb9b136c4e6c9761bd7afb251d20d5e1de1878abd0d6b58939ebd3daff3536b131b1da14de747e8d98646e97b049269c94ae503c2e8717ac0007c3aa59682e5aa31581dc01137b0844f4646a51534f20be901b7487773e3afa1e6fe8ca219a27ae0021cf23c42a558942826eb15be5684638dd63003593953c79b6da59d036713a30701de59e9a3ec1cbd3b49867578d3d9f8204996d9af213c07601d022b8d0e471e785e0ff6e2b98ab0094200af5b6b1ab68882ce3e755b51917e452da83072d9c44276b45ba06cb4c47833242ab4597da699ab94b01d0a6500d5f55dade4690efeee6e18d7ec01d74c5c244c18b3adf74fdce845a898dac0d558deb37190cf979aec92faf30c397ea2ab2c21a8735b4ecc3ccd7b02feb0f56cb9f71f2554f309277b7b85da2b8a6417feb1af2a34eddd247c007fd3f956c8040525d911a64a81d894689e56a9a691a31118f2827b9b9d9c00e609fa2d69365983ad4cb79684cfdae8ec283dffea8da7fc3de952bfb6a3a55a26522fcd7bf618f4a44f9db3bcd549c54dd276eec28099642be5fad7c1127a8ee8d94df88fefc1a75cabd292a01d6c7653143de23274867524e9fe42cd834824f319a81185230f715cc8f843b0256d0202119423b004e2588086f3b8f2ef949c46135978c1b26cc4ec3d6985df9f25f516723bb25c7384a123437b38f7c5bc9e9494d05b20d4c6237ee9147176834f177094c6b597d403aa66ebe8315158ebc40dd3f44c63b29793023fc145bdccb77727d57787a9458772b38c77ed3c3d8d85390c1742c783b158d9652ff6dcee028f52dcf8e536ae98c82eaccc44dd1da17656fe5b4e4f11b1aad49f2f1500a732736cf2d6ca3861e0345a8b85ad74dc1a13f16623b329fe7c8d44e452e9e3ac9e66869b1f3cf25b3c4c31aebe70e8a0efde82ed319a43c23f5ae3b80e18046cf2e64bfbb135ea293882d5fae9e5238c297aab87a115ca9b029eb6f765f0b9473c990d90f67ec6bc87af1f3d23fd07b392ecbfb532703e168eb0f42f07b46d0abd195aeb85b08e5e1cb89030279ebba909b56faccb32b86ed1b5f1df0ae79da5c512c6103c58f9110d91de2d60cef6270d90276c34d9415a36b9977e9709323b6ee5547764e209e39c4c1c19f212f11a212c27e47c3ec86bcc4aba302a43c009d168c02e97139834fd2156ec87b8e0f46ab8e2afc33f649c30df3f813e77206446e51c79d3c3683c668a772804f554a3d5404719775c496238733621cb9296b805fa645cce5e4e8adce6e7bc8f5c73b54642066dbf24c3fe1cd84773a7601f4b14672e7b01643dc2b123ab944299b9095660cc10cc76d4af2e2050559a523f2995e5336fd8f964fcbe0a2acaa9caf190f8e68ab99a101b56b53ec342059fe54ae7a5d25bb2333bc6059b0b88575ed8041317ad00eac2d23f9a6431add74de3dcaa717836e06cca57540cc7a90c5587fa42a9dea381723e06b10cfdb3d78fdc777eef54443af2a6edf0a68e831660d18039caa74e17a4250fcd51af1f5e22caad21be7c58221df7ecac63c42a3e51e0503d42024f61f3027185cfcc661a373e0d52eb1cded718f471f042958c82df908a86d9e44b5fba5323370d24438a29c3cbf640c54df53bfb079867895642e4f3823ff2dbb5d4ccfc378ea4bd9edbdd1511bef4b9c14215b0c5f3dfdc9f941c02b19d1b556752b7499480fc67853c1268dd647b5997e59f59749c81c4d4781960e95f2bab438be7779c1fe97271c2d7511f21380bd05bcbf0b9294b7a66fffaa30526269d681da8536dda022ddd1dc8149c71ad4cb651efdfeab517e0aeacdb0ed788975c7731676df1c2cc3bdcb4d4177a506a90e5ece59e5da3fcbb1a2f176c21c00ea991e462543b0023fe03a132d0063f58905e56f000daed976f9dd83c7e7eef2db5161b090fcdda1d4e713ca9a2ce4667fb33189e75d21c13310b6d6190544e209e8c751e4a8f51363a936d1b4c20cda6afc92f32d6aebe3bf3b614cc38c287fbcad43a4b5cbafc2be88db845fef91780b2cd4fa86b61f5f30b8a9ca556680e6f922bfc8d0e8151057d12537febc8599f02f0740fa1444e2b2e5c57929acf69be4842a45721b5f008054314d6d284cffb46a209d892dea363d402c6a4c1ec9d7b61e1d774a63e803dfb302df33d2299f5352969a5559cd58b04d2a82ce8ba83811bd12cc6ded56c14cc30568fadfd9a14d0d3da06a44fa2cd5a94b60dcc7c480d419144348dc7716dd778c52feacae14ba3b451a9a8e9606870211c8f38c611d6ab9cbd0558e38b33cd8356f8469d49d629f2921f28e2363876052a59855a6e8270d2e9e924ee1c581e91693848e46e6786dd82f1be68059587b45f1a5ef26f2c051e34cc022b1379c0221b1b7b0386bbdacc42266a8fb9c41c373f12b2fc9ebc7f85038a2ba4349fdf2f5ef05c736f48a88b815ad1e8f1a34a802534cb58f7e184a604761d33d1a609186624dfb063e57024ad25e6c4851833eb01d31a6899fd40249c6bbf5dca1de90176281b43b161d9ba83a65acdb4654297ed6a00173b67d03ce1157dbb7bc5effea863833874576feae7d561b97f1ae19c5fa470952d96e8d9c590de7a62bb94e2b724be442c640a2f3d446bde47bafba7eda3bc6c6e02bcb9956198f3c543f737b3aeabca1f1ad2167f90afdca2d0bdd4b443ba1bd89e1b31fd4da11651fd1864283991df699c7a3ee71e54cd94c16698487d97164df33bf9c1b37a55ea0ff648e93a7bc24bb01f5ffef2f476b0188cca32bd0ab3c43e3a407200982872adad95b469365da1f23a751e4af90f11826a819e0dba712c25de03f44b0816ab16d2b447aae2bf33838bfcb8fb2ae104ed142a3fdf63dcd86d4e43479922576396006fec2223c593b47ecf05a74ea4881885c304b414435c89c2969a47109ff8644d9fe6919919f2b6e5905159fda773ca621d6b7393d04b92a09c082dbc83a45c6315c09c569918b3e5448bcc990899c37ddb967ee1277810718dbf75814494ddb850f50906d8a12cb1fa9d1b9c3aaf3eb3f34d5c2c8b7d87b8b5003775abb59b0992e153de7575c3f1cafc129962f8ca71857d92c3dff72963bf4642facf629bc79e488e3f9e0a571a5eb067f201f9e67c54f58a856e303d5ffaa63dbb641c342a680edbe03877e075436fd740005d48f3dc5c9b4c6dbb1be9b0fbdd948af4b9b4bc88ea8524125c19129509b7541dd24885ae1666225a0b5c0a95c0453cd76b433d6557078e0721838e60550ffd2523bd09f1871b02837e8b4a8f99d59eecc3d8dfb3d8c0111a137b72d5e9715e5c996ed298d64ebe7c8a90da89d5ad7d6bdbf9d8c57f44af947cd23d8cb573e495a2a22cf0ad874fcb3c08a1a3099d6242afe301f0cf54bd094fbe8104f8d76e6c320e3b0de34deffdc88387c13e85b0faa789d305a90c36e92b6b731f4f8925950a51177f2bf2d937642f718a8abacc36f03d23cf03d3d52918ab3e45c9b5a674e00568cc8d1b98ced54ecf6d0e22993b1228686b6b97f82f753ec6531537b34170a5541503f00866d1d26ebb4876a416bc890b3c9a1fe7056da533be719e32939698bf2f7f881046c0705488ea1f686dbb97833e1fd0f99e6c0d20a2f79d8355f73e2f719bfbea7da6da87de1626dd8a756e6028f4e0aacd3b09cc6198e656e56b4915b340981a0b61d84cd0117c273842596b6cad27cdb54b9753c85191ba6969cf0779b614424c2570d4def6e2571e6570ea71248caab1e19b6c20474295a54ec4a5b408cb5badc8000c458854bf9a4b480f047975c6298f8f44786cd841eb6349f826f44f88f7bca011a1e13b96ca5759cfe826293c01698c741941f5d19560713ab1fdbac6057324d08cd3a8b75a43eaa6fc6215e41c0dffbe8ed1edfcd322035f7e6e6fa6d47ff981ee0923127ecee2cb4bdf1ee44fb90b2d0cc5fa5c478f5edded9ecf2eeab7217a979276899dd1fba776bb4ee14ec66d9719008a5220bdf75d5b8eabfe9917ef4c9468bf6c581a8bc0c37133e3bbf2d3c537a5712036a9f26f51327f257c4ea00edfebe80e3530ef36b96bfabe836227329a17a806f4301e60761eb8c4dbe4101d9b6d342ae3997fcbedd8d739d2965a9e90db79ec15a700e3e3843759e2c7c29e34963c6b00173fcc6139f4805977426f650985d7abc6d77a4c2d9f3e7b10be15043161688983f19b58ddcbfea2695a26646d94761d588d3fadc9ff1fed3c3e1852b64274cce7e392cecccad5f83dc32033b98223c1e190bde1e0ee5c4c8b48f3130c54a0888a1a3148bb62af243e94d29e5b0cec2c3230fea5ab15a742ba20bea0bff53f4687fbcdfedad4b6e14510e918be68f96ae20f9c51b8d655363aa70513ee66df4acd2922c3b9253185d5cfefc449a1ac026627bc5796dc8596aac5200d3e2294fa7a2e68d200db29313a6730e38445992f41b297b0df56c0ae01da6697b809e084618fb9d2aad8593caa6f0ea662287e1a5f20e3dc720c602dbb2ecc9c9ba10757ee97a200849ba46b4a51b16786175990b847da3928ab3255e89435edaec004b0862c704e6320589b58e5b3fc3b57d935662d70d2c87c850d5f6beb5c1d7c41d0345b365a4c892642867bc51e0f5bca39dbe51c6e45445797bfd2a78404b10f6a024c3878f177f8d43a6a055d1df860508a27134d7a9a8a2dc6cd97e75e0fb6c22f826140804adc69d3158d0f3bc5f45d89dfaea8b8d69f85a082cf8a32e5ca71129d8bea9bef454cb93941aff6d35049fb63475bf1ee80451076c781bc1705ea77f85637fb94ad802dfa287c736f2ebf394eb8350cd890d0154f7105969d6859a462724a5a4660bc6c1f4e52f424c3ef3cd216bdb9761a411889e39752e2995cf714992e5453828ed81f73b7eb53b89ded14a9612ee320041b43b226c024dd73eeaf6feb8d1f872cffff8cb66d68fabb7bf1933e34c99796ede381842c5bab1590cb5ecbb6784a26ef5554677ab5eed53763990ad04bdc3bcfd00121c0240e8a436969834381d56e3d62c52057fa326202d21cee45ea1d7ad85767b75843e3404637ba1b6af1b7a56371c959d9d1d008b885171415224a5d78ac6fbdd0d6d29fc1b28b6763b704a2f58491521712124c1e051c5a632f8175dda95e8e91ca0fc4e7279fc6e4b9a60451ac6f10f3674d1437da00c7459ade0fd2178a0b432cadb496779400183ead80d3c39e568886391775519ea65e76f3e04d97c428b443626ae569c320b3a058820430c74dc1b5452743c63eccca793658d343e9891d04a36caeb052175eeb6aa4a64236ad5189604279f4afa4f2faf1cc810ee76e38c064a0fb5de3fd19df5011da6570972a532db819d58424645febe2200867743dca0a92f854cf53d9e00c750ba50e3c62483e05e68275da60964d2e8ccd106a40f0b1b324399774dc8a12856bf5aab80a42fe9ae8d11f6e5a748351c8644b56e360a2aebe295bdcb262b543c050f2324776af8c3863cbce87991542d32ec369826c9139adfa4a340c68109e5a2b6814c3ae98a806cbf58f5c55d6b2c1f31be4769cadc332c6bbbc7f8b3799ec55edc24ced1b8411772b889ed1474d168816dc02ae45c2594dc7f0273009077edb99687ea4bc2ae88be83f6269a008ce014bcaf08e6970386fa6590069810becba20a1eff9e86f2f5179d0157e4888f97d7878a133bee2d0935904285390423c1fb16b250099cc56cf724f62b4ff0965e32d4e406fb1ad4af0c8556b58306e29050f4c2c207c403ef891ee31f88e7868724d5dffb24e1abbcfbf0f8475ef1fb8115d5779b1f0bee65e4f0ddcf3120878c04ac5fd2b29e19a7f108c26dce8d2a500556ffa9dbe3b5c0d5838d2b0b1439a4e8c246101a5c667ec4e01ae875911ea13ab06936b7119ad1d8adbb422cd1eb9645535fb4f034e275f5e363743c2b7a40cf3a354e5b321af83f530b701584b31e33e9c68887087cb853247024ac94a30d2294dd5f976e20f6d2b04d5e2f5e40a654e7ee90130b77b2a92ea3ef40ec3f26ed8926d34b2db754fa478777e16d6aee9c3ac2557e675f49734044a7763becb3560df9a682c08fa32e2cd45b5a84241832d074c70e9104e5b1f42bca5ec82590af44ee479a97ac6a2ca9d4a1535ce024f80901be3068762cf8f050459ee225191c1278a1a5dffca0bf0ccafff803aa30e222f0fa5d50f481f35e0b8faf9470c9a4e17a64a57a4232c53f624f6070d5f6df6ad62d6da66d2b3d8a46422ff71b25d1a66a90cb27ae2beb57692c729ad0d6155e1a85f7306f6818368375da3925094e7eb213c50d6889fff0d812f6ff65467d8db54fda1865852b9c8cc9fb96726b1a6b0c52d2bbb9afafc61cab0aeb4dcba0da0722a0a76f752b547182ca6f1468360751ee72ff0563874be1f9f2634d863344dfe91d0e0ceaf6b45ceab7c15206bea43d43e4815823b697448a8ad418e162acc6742944717b0e16c2b8a84dd2f8cb69a1da921ef42756096e4df1346225c7ba71e72980156c4dbbdbee3a521bc3d99dd55278fc9f1ac86612e6fe45e27ed225fcefbf0a858900e3d21b6de39aa4462ea886765373de3f3608d45dde29ab342e63afc44c76b21dafe1e3435c5d05c844694a7c37d235b274ec3b38e453f20d34ec03a031103c0849ef90f489ecfd5605503367646b5d9ead1c00b50941198b2ab523a059d169d8be555c7344c44f7a8ac6fde28cc4059836767e7ec309c5ca072cdb32fa425bd58e5143c1104ddf452476b434f3331e3219a4d628402075fcefad7922a9b1ea249fdc391c6f93f16035e573bf721a2f5e7a044937320788cfc2a41f8453b87eb9f0f46b2632ff7372a91867074fff6634fc11600078c4de305176c88c5c19505fc54f68fc8bfcbb8fe17bb9cc9a54db7e79a84579249a07199a12c380f2b5d84d4287e67a2a4f28ac0d09f56a0c514f3efdb2789b5ad8047d160ba1581e7b208c34cafb46d05cdf542a539b6702b12b5bfdd50f0be20b2186790114a35b13e19c57b393a3dedccc6f4fc8b99b711c9b3b23dedb7d0fb12b91993e60ffdd92abbd210c14a52fd8a9a7abead866a9e065a1fd71d7c374c14f9966d1da67ee655d088100fa68562cf4fbc2dadd6f2b2b7e0a7145b92b91325785d5f66c74f5c354d40e795456d0b095703cd34920584876888e588007fdcd56d222113a9d1a659a7709af5141707b650aaf9bb50d1ea9c23aabce721fa0fc8f66164dfbd8c74f5e4f9a6a2fcc70b330e7f17faeff61e97a04d764adb9eab3a9e514a38bfdd5b957020779161cadcfc5be9107582e348870ef4298b9e33d1b5ca9f81dc991722f2d640f9aceb367b8872bf8c60a6888c31e09b6c65c691a3456ffde1f8bc9b98b58306c9216e31b3d549175f54dbd67efb9c8884120c460648044cf9396e14a086d093e6559a42c14dfc82a8b8a9f1ed73667d59876dfcd0c5220f876f00e553b276ae38816fc77123766abb8987236003724ba438db0c23dce1568d3147b95853236fb540715e527f287a7333fe8588d9221dbf11a3ccb20fec743bfc2bcb5be78f6dac6579f47821f96b9cfa72ed6e8b7e3501654d49af08543e75d49d68d2dae8b5169f9efc91f9274c6c3dc1644b97959793ad4a6145d299c96e8917ed1cb3e39f9549ecdcfa2f7538f03ac43562890397c0bbbb2fdd3c9179507f35364d1592a82f95c0ee0bba742c05176a5b231a73d986488e77e7ff7da169d480bca19e0745a43385dff7b78bafe304348dd0e0b591d72fa3b2ee8deccc8b9f9c665fc1962171a5e892a2c9f4f7453054c05cbd3f5b0390b33398e9ecb1ad36fc3e2f188e42ec355f643dfe50628ad0fce9a52b327ba03a74bbba3eee460cba75f9b7d364206a65a0892770d483eca09f12d2d68a8b5aa8b120e92d7d6502afa6d1399ed723ef50298389a9e0241df996aa3364fa6b3fdda7450f119dfda798f67f4cb1758ca355eba79a135ad161ae161495f663c0ed3fe305de8f8a1413788ebc320432a66218cefdd53e9a32b3f632faaae34fee31abea8d3034d3d2e2741876ed260696c2fc790547b1945d76606e6b178596eceeeb9834e8b9bd4715f31b5e0759e31ec3f32679db7f1555c9b1ca39d8a365a0358717123a0a7de6a1b2adb1a8635dba62d11e66f4c39b4e4d2f642eab30d09e4fb1b73f772118648af2d03eb121fde03f1c3cfc7dcc64061e93b8bf184761e1f643fec8cc7e5edcf9dec62137ec7809d8c048bd522ede7f03cfaedee0beeac5d238bdce80e1dbfd11becc7d204ba3b83bd4fe4447d69ce9ea2a879e33ece73e5a9d433f4a92aeb6bc4d730337290dc50ff710b16d590487c5ca92e1731f3dab7f39ed4815f4b4af9998c2d056d1e9a6f4834a1c2fba1aad64ac827ca7bcb300aadb009d012fae103cec04107e21418b4f3e7cf2a14a4164981712646300367974b37c118d755b5b36d167d62d08edbd2fae69407348a825aebaab75389997ab59651c62dd3afeed4bcd8992311ca39ebd45c20dcc868bcc715b7f39753e9d7fa1b4930f12c17cc1b818b7d2aa16f9fcab85d3237033b0d438541947ac9643e97f09f20c70ffa40b9e0d1196f0b2915dd7dc908a315f7e2f623d7ece864cabf6fb1e2823dcc0323634254f0cfb941d605a22e4b0fb3738a68f9f04fd075fa052ef621bdcf130faa5fe77bfb77d1593f99f9b9cbc94ce35091c4bbb4c045a9d7af8296edd8c453cd8423146e94988ddb15b1e42582f2f0cc8fdb255eef296674cd85aed6901d57cc5ba04243e8855ea8116dd520ed95262fe78f7866d69cc26d8a19a2281ba7025ac4475b998583277017531b2936d89bedee00ef6700d4c576c7fbec4bf724d2dcf516d6de58f34855e10caf435f45743e8d1603bf325a4d87003912f3e8aa6eef0f99d43438f541e9febe63d36fd1d60fe01f96c623d5f8219a39f6518989f3d787c23b23a53b54c5ca958779f80690adf5aff6aa320429db5a6aa3f6f6aa390eb96d5b234def2b924b1958395197b8e3f806763a68a85407f0c783eb3619e3b4dd590f7a512e1c4d96c769fd5660de61cf07e2d341d55d255c388acb86682f6f50822a896eefdb1ecfc28bf155fbc4964c03b345a699683c25ca573fcf6347f5be1f0b77696964326dcc7d776cb197df8e22e416541135e9820a5ab3068d9309f3a7a2cf71f9ad3b35c1c8ce6f0a60af95a93c090ff56c442efb5a9d6f6","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
