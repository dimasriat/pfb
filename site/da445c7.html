<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0090d3816d80766c13544651f3d4a259bc52bf5d3afa3bf71180b98e574de35d1762812229dace83f35cf89e79838bc71bbb1413caadb8ade976e0f35d06ae4bfbeba01d477d10ef8c474fbdc0dfc20588237f43561151eb44cf2353af2d7edce471457dc67a447d6634821123bc12fac8b7d6114e555c41ef61831363c673583e3ca9a07f63d9625a31805f1bdbdea239013a2291b101a4e9b58665cbeacb8ee7d3dd036818700d0d1d22a4652672ca092d84b2840cfa09869627d20c9d73b076ed94f5a7c9d2e495818e8b7ab8216c36e50d4d411ceecdaa4876cfa9bef93747cd19cd2694c584749ccfeb64999c33a246fab9c10647c4e2b663e5097cc82220d12c11a9f1ecd992429c472dcbe837f5a886196f9eb5c85835f6cebfe5bd0303cd7522af55ce8778fc593608b53da150102476630fef63c0ab4f18430f0eae5518f8a6f6622c5848a5290783bf27c97ab43a5aeed73afb9cae99903a0bcafae75658f1cb390b8ae5299ee544d9b5c25e3d13f0872969b401a5832b3657af80dceb649e5ce3781500d9c83a3c662df16fa4e2f251f538fa6adc81bc0440f828662f7383226375bbcb43e43148579317393ef6b4fa10c70e7279bf5850570d35c239545f51eb2eb52711c395fe64ac8263699260f8189f3a4538a3a1e1a5fd6a1384f064ba337bff12ef8f1ed25014f2ea2920825745d988c4cb6205ff7a68672e5803603f4963d062fb75a8dc1e076f56aff328cfe058a3cf0be94ec2796c15f8568cf9a18adc8938480ff430742cab41d167723d513b2b7dd13754baabdd9818acd00c2bb6ef96e23b72b4d62a1c341d6858ceb9dcdbf241c1644f4116222bb9281923d9ab07386a072a999375520e02e0b5d4fa549cfc0ff9a8e44bbfe0badd9f68e9f417c544d849228d8ef9528b14f68f00788c18cba63ee5185c9914bd11526e83e952b2597e0c3cb2151333bf73f50d5c2737702aa6cca6831da6cbc615d70391538f72ad3ae4ba49d973edac81af4bd5c0375a5f567d80281405d7b3d7d2b159ef81ab9451682084de873b638dfc920b1501fa2b92199031e1e6a02232c579fed8bfc81f43db7756789053364a313bd2d77c9ce2d2d19850c9c8149e404f64a1b8e9a6b1c440211de73662e81cfe1418962d4657ff52b8bc125dcb6ec324157e7f8a78fc8cd24ad9cb1c70d33e6d33f4b681a7f11819094cf4457152dd9aea1fc0b5151d48a3e69260cecbacc4408384d3ddef3193973862f5f71491b3d93cd11922ef7383b1d39cea71e5d41116954e3cb53bc0809a92269781db0c37797f25878ad793daceb011297b19acd35f9eb3f0df835cb1bcce82d03871a6ae99abd4ba06152b36e5d0144fe409f70d0501583bf97f247a17f1f0b388a63d2fef64d9874d4814df26f734415990d333d869251351e2cd85e5256a23e2f40262b0de3236cab1cfd5ec603d626b1740d7772689d5c5775efd98b1c49e8b8edec3ca42bcb2a5ff2d9471ed8a10379823b943ed97a0b961b743480fd79ea821f7f44743bbc4913fd1ffa4a46d90f66cb546ce99cd26f5645f1bd7cd57c0bf5f2a2123d2f11cf855c3cc380d4e6d786268339cfef831aadb764eb88e48e8ae99467b744e5b295100ea8d207ec02b8b1025babac194db230f7605dee5c348befff353eea68e90e7ae017dd29be3b1c5d68b7e40ee3668f24ce75a6e804936eb63a4f0259b7fe3fab7cf7dcc8d98475b767b5b3b1729e79b5cb5ff64a36449063ebef1ecc452caeeb3e770e6dcac9a385e4187b5c4420e8c90c495c4b1dfdb525d547050f03144f04123c3940cce5dee0b18455e52c05b00cb09f197a0d582ffae6a9780bd8e96ca738ca8c0277ee9f0dddf75d3f1e89ca314774dd20a135fdb32892265d12e1c194b509aa0847e45916040fcedc45d28a8d3035e7626e751cc09d1be5e686975bb4b0ef97e349a95fc27c8735e10c8f5f52c8feddd246a177049cafa08f48f345d3756b116e4b0cd5e7665c39ef4e8d1d88ae306bdef6dd55856adee9081e3d411f38c228261cd846ecdac965e2f85cd8c196b799812c461dfdd81959e61fc5244c8c9b82c0c27ad4fb836e1d01723740ede159f50eafff78872735bc2ef450cc314498b49bd3fa761c3a1bdeff501c176a88544d22f221660e18493d05f8c5b91b2c3d0ef0f8b18ed19b6f0cb6cec3662a7d40bd7fd30a5c07d600cd6db387835a0a0c154bac1c1ceafc874f1fa246e06f7aaae083f16a8b4b97e30469a8d81bdfbabf53f747b941e509575b57046c0fe6dce53028c629de1d358eef9e1b5ee19f71ef8b5622364524017f7fbe0d6a557afded39de5246af9442da1b08d2ca055c435f4c15f69409188dfbeaa5be1e4d175aabc26d65033b4478b290dcedbc38a5bb8457a9c82e703eb296e40397692c74f088e73ceb360e4aed20ec053f5ec735357a3c5f75b6069ab6bc1bd85c31e88eb2c0e6eacb0c158d9ce6e634d651f0472bfdceb84e5b6ff175e4f793d02c1bf25c8df3d3245137a7a997d9991fbe7c4e584c89b5eb66d4981195c92863cff99d662497346f9d09a8e9c60c074fcb272c3b2826f25bae805818292963ea4ba2b9ebc4769315790e0efe176190e51e1e0c404b01d559bb9e69a465c9701d893b58b18284f626c9b0f301d850a634f75f85d01cea3ea6a75b1ca39a65b9b3d088861e95580a1fa1062adc4e69c456282281ecca50e0b2bea35809e24727fdc8f69d30b956e732ac9264fd2e91c09892beb8334731de3dbb7828508480f29788b7a275374b389202696bdcd74b30641c1b5d212a1db9aa371d195af5b99eac8fdf8f12942f4ecfeb6637e8cea437f153739e9e19c0de5d852d4d412413d501729648a3c653cb66218e0c7a60ae92815ae63dc6d04c4c1cefb0f2e03ff2335b9a9c3e1d2cfb582e181734daa990eac9434d7bdd167b6e41f0cdc61c0ea15969ae5e5a33012dc27dc1b11231688c55d0fc51b6d3d131e73a3c8c9e70f7bcc9793e8a15222f7a94bfadd1b063bc75bb0b762b243d5ea4fd44fd41848369e17092aa1d345cf809b54a203e37e556fcbbf8799c61eb80b20590fab60addf691eff209b1755a6f9e35ead0e376580daaab32921442212261e7d91616f5d47e21da510c91826449a517bfb09be3af4f4fe4f28a204a0ce2afaccc553297998d2f2643f92d12026a9aa5c62b42176c8220eb3138ab2ef6b9cf74da8407757b4970719162ea3eeeb55cab3f3cd1804fc89c20e516182792d8a43af1acfdec7c414eb68ad69880a0a2afdf765e5df5716da43bdfc7d49b3f6bd777f3cdc1e78d8b334e40ccb46937dd76b235e66912908b04103c673b904d3d574ebfe18a3c683031ffcb7e3fac97b7fcfb51aed42a778bfdad6f159f15d2db557ffdc09b9eca6321f68f380f12fe10f0233fad24e7735049e7f034aa8130d1f06898c9d2a6b02484c930394bb26a5173ab3b68031af17552e5afc77fd541ca04570e5e54af264257140a38f60e9321aa8a8373c431aa4fc19aa8e511e58a6b08d796c276ec61165e283289034bd35bee8d89f71ff946b4f4fd3d8646471603def0b9fe9e9683ed5b8606f3ec2e4a7c34050724e1a973b4fce08cb5e1281d2ff8743f71e2fa6ae8f944c6e84ef9acb62e1ad5b1c6faf63e5db22957957a3379f3cf8c6e49cb77da4df85aba90802619db33c48b662df2fb99d5279b6baf67d81a3c473d83ae2b2c409c3a6553fde2f5e9748f3716fd32c48cf37c2f34acf9c7b9aaa10b1612eeacad4dd9b988537904bdd362dc66f1e923e60093135924bb2fb76a4ec2bf8a680d8f75a300929ee08d0c02ea4c4152c0a6f2cb7360859ce93ae3405a99e4d9bd09ba35f227f5513ca1a44071e65aa9b135ffb86807df393eb372bc4577a618a33ff227fdab05b124568651e2e701289eb2600836c395e38d974b40161ce40ecde6c6eb2471d1ed57d40b4c713e6576a959c700ff2a4c7af3d0c19aaa467c6365d1e3ca4a9128bbe007023c3d28a829c57a309d613cbec8ca714c3ee9d372a405dc515026255b37c49597468fb661267abfdcbe906838f8020b3260326d5bc795376b4f1f9ddce627e8e1ac372315e3d840e6469ec75cad8b967ab71f6376c51fbdbb0c81ce223d3442f851ac26f98b15bfc6c05c1585e7a61e1bbdcec94260a51056c25de0942d78536fa991a1529a3239e52fe041a1398f7f0a58153a51a544c6fff49059c4b09fdc46ab851ab84ebbcc75fd7155ffb442053e05b1722767276fb28d1434bdba42d9a0aa3360a9fa7dfe12f8f4417a4478049cebbe14a4b69c6f77f5870dedd7887010729a0684fe3c0ebea8e816b1f529f82b523f14ea79deba3d626888d947c8a4c7b85c1def6364eee658ab9bcb00f3afc15fd0be06be706f7da8c46dff89c642e854003f3fa4399267e93399e587fd39572d969927ae7f83cf3538e9fe77f9de69e65c3a09989113336ccbf854427c3cfec80478d6b02c92fe8353e0d07b22b9cacd834ed03241cfca90abf184d9cf3eefa103f5e5c40f08d241422f2d5fdb4b7955c0004d750e45faf584d63d2a51ab7105d5ef7319e8dbe7ef58536f0aac71a7c7c656e6a5f800340dc5b2129e8a7107759aa37af12ac935ac7c2b0192bf6537fd46a1357911ec6ff45df30a1be71782371f26e001fab4159286c18800f56961a7ce9e6cc8352d2a118b1d2fa0f28797b809a1705e856ec5eadbf81c3860eb3b15996ac1a1df6067482256e05f2ccca0946ff8abab21c4ef7073a417ee5693f51c66021c6db0c57d62d8f9ef986b836f0fb54775a8c0172cee025d7e1caaaffabfdc767406514779d3c25c13369e21791d38ede4e6849208ea25ec5cb45cc11d6524d7eac669e2000b424a317c4141f3bed93cb073be9c1670606a39576e1cc150a5a9d385e6a3c669faeea9631ccafcdcffed896312511c0577d83330e65f238784ac219b03e5203acae1055acc9014696bc569a70831c9ab75fe788262830b282ae03e12145976321217b70e4d2915e48c8118eed869e01a002bd3c5e8d8a6950668aab0158a7b104dda916d8c0980fb7bd983aa01d274a090a5963bb9dfcc2a063e42387d1c54e254cb2e8b1bd2664506c7db3c6fb784ceb1f70e38599622a9ae9abcf2f0a1aa8cbb974028e2014eb8e1ef26d0c459b61d2aabd04bdf7d38a6297d5e113dd228c1f344562d4e13703d2e1cfdf936e7466c63c8b6c99cdb829b12a6841d165d6d0ea624c2e3280004c5e45fd7a7a8c08ebd09af48a389cc3914c9c85a59cc7bee443471585c48dcdbf45507beb979ec10fda0e4ecb4517c2a6d56e4b831c34c9398dd3819fddbed62fb0132ec46f345505aeb612191dd2cc2e3adc31b1c96209fc942098733b39c7bf2b307bdce5522d31b36379d1613f8db11c8f42d61cdbb3b77847dc6dab0623eaa93ce3e1d9212b2ad97a3b414faa6e794c553e735596eac372bb8dccc24b06b753efacc11ce3119b5f3abdd5594df61eb108271b82cfe0a780e26bba82333f88d27084ae7b2c50ac42df67441e2928915826b775cd23a00ce5ff2bc266f80d090c8b92be75325c7db64b5bf488c332f95ce4204cb4bf93055d4770e9ec1aa89d67586fdbf00b1c814ec8cf5292260233282d0d5b5951e52de384202d773ff92279d8f040dede272cfb5354f9cb796a30296cdb5b44cf7510ed013162ce83f3bc1b3b4f3b3c7bf98b5a4523176bd96d04b6c1ae18c1d4b80d6978d5a137f7e07bac9c331e6e2c7d6fc919e7e724305238d8ca7a6c03f141e0fd9062efcc33490fa838415249c62e909855e2c8a9928b81a0329dce3d783b168542cf7a94304af52fbca2e6125ad356623b8f345a02aa9ce7c7fa989fbd537d492a6f65865af8e7e54464d1e819041fe10944656fadf761d4b16af640af9f2ef14bf3a3d172dae0659056d4c85e3c9e688d703aff08a0b21b38f5f60aa79c0379a3b88b07296d9a14951da6dda0ea34a30b9b037db68f64d8a04d86a989e7a3cad6a27a79e48e110959409ce4c2521e489a75f37244a820d5425d40cde4a5003798e2409ce20e1d1f8ebff323302062bbb276e71bd2c311709724f3e95c7f0d7ca5019256f7b94c4bd149fab2e39a69067e19f7353bc50530aba861a49995f1b3cd2b6a7b8e6524b8df2c0f58ac16b249f4018dec14790b6e07f0354afcb25ed2bd5eacb882b224c07e4921c6378f60e86232df5a3b82071ebd2c3a84a3c4e270b306a829758d3abdadeb9b5ee18322fa050318c42d4708bc46b8c8170e7857889adf59b0e2aba8da3095c33ac2de00fd443c4b268b21385eeec8e2568586a1071aa2a92be3b37e7c8c979be3278026ee50759ec178958ddef01cb0eea61321ea2adff2c203302e4fa07b64e00a5d1a765e70b2a567c46f6cce0ad6eaf7319caae9b1b806ec725b94354363d79fe9892ebff2d3a1d8e3669d17c4cdd3c3f327159667687a83d9aaa973ed84c630d3d79d95ad77edcc094ddcb324944580a673cb82505c6a913ed242376475d5dec1874a5693b54318d9994ae1eecd8e9b181fde5ca44c9d3f71c68dd56b13cf240765c0b9a0976ecb87ee7ea56e2bdedf211fe4811a2b41f74224b09d02043b17971fef96e5d994f1243ba90c00edc79291670efece380932bc0070fe2a91e51b0e044502213984da855926327d13164f3c8b983d0bd51197f675e95e5b10d4b54c201d3f17900c938e1d29e34b1b5c63e51769ab4209fb450eecc0408ab5d88076c016a081abdc5cfc910a63adb61723777948a1079d2301ebd2bc440419b960ef50f1895cdffa4bb6cd4ea166dea99da02c4d3533122479edac00c1d4757a59e50ce654f6874d9acc0e6aed0dd93303dd6fdb8a409c740e84711ea1882f1c5a0f7abf08e9efa7f5995f58919578b28dd3f7bb22aad2335cdc371b0059e8ca4603fe4cb774364c9f680eb6edd227dc3b7b9dce3ebfa6475cd917da114fefad12d8b65188f5e2934f99284a6f98ae61638a9da1811a3dfb27daefa3c4bac24f69799d88f45d7f9639a152a6088eba594156cc07196da22042535da0b112204d22e7493c0523a8b382a697b668e38e22f7664ba3a4c170a67a21994dd436c98cb7a46b23ece7f693d4624ee47e56f01d4e3dee29dd2e7b8c1d3582c3622749c012456d98b100855345f24755cf187489e923f3ee97fd9f481771616e577d3099e2bd79b174a894f9990731570997b8a0271c4e189a308faa3b2787a5a49f36864e39ce135387f592f793fa20d29fde17a146fbb8ceb6655d43f50076d577fc355cd7019e9b9bed22041a84bb6df1b21b162baca46f601efa16f3ad4f0615d6ada0564d8cbe5ebfabf0c5e855b9686c50b2858677e1e532d8e60bf8967703f480e68b08b384ebfc3b9c0a7c530ff94187986a2b81907cf3a7b0154c82a1a34e088b3f0170e9f9c358ed0299a194fa21a4c7e900787b107d65162364208da5965d657c946480fc790c629615c2751fd9a47dfb5b3abe2d3e5126418e5935eb7adb08db9665c29eee69bf19de7c2d08424b0caeb74a2d0b43bc75259156df58ceafe7b4e5f16f37676d2abbfab9ea1cdcea7b6f87c029b1c19189f3d2e306dbfb425b3ac56764a28a93d569725b1c8850df509f1b1810f2d7e5df8a4167573846099cb38846b4f20d0c7cb76f8953576c40d8797bd8c8194c59a92759d431e241b911ca2bc029e7b85b439d5b06d94b183a99e8a57ac49e195b4645bcc3febf45b34d5e14d68d8385fce7667b9728b0b72800e9496d60100632d24bf4c5c03fcd162c6f2e51ea88ff0a2aa08483f2e0e91a935ec259df0db5e16ff4cfd6f086986cc1bcfb3d34a0205838f308eb3c6b37147f178fa32abd8b68269193a1829268bbbc7658318d7c3b9d175db6bcbfaf21df454a11395edd4bc306f683d57303962f5d7b7f42bb09d6fb30d271eae1c72e4fb2c1020d3c0bca7d8840e613fe21ef5869d2779aefde0fd4bbc9e70fa0efde390d5c2d37e2dc2ed93ca5152953a06b40d2941e106911f76e317a0f749d88f40e32211fb62c8906ffaa4e656bf07f657a51fe19b4e78f6c0f797d97eb9d7eb3f4465898cfde62843e319c47a1fdf76dc0a11719ede5050546603e5842ca3882835af2cd0d524dd36e56d57225166aa4e1e2b12ad1d45fe20fe42d9553530d25592b084586f5a705c9f4a21e6e49753e7b1a57b49234dbfe3c93bc3c5bd1b717477470f791f78201385c4571b29fb469b78ba1cacaf8f3e0ef2b5f45697935c95cfd725f9b0731d6e19cd39523af4e13abfa771b741427dc55c658c70a71be90a5587bbfc85bf7e53915daa2ffec0cc8efe649bae146ca3d50ebab282b1095b3a2ab18c56a419a1106e20530986ee283b99a98ca1e6b40f0a4b8bdb8ce17b64019a021392ab040b98df9456b8166bb16ee9fcec78d8f27c8f8298a6ac3c4635aa88ade2398e478d1083a8f36a620b3426e29ade289823a2ae5c2ed83fe2f041f01c0cabbe54dbe43f91d657df315ab5c48b4ab2f6f26edb686a59ea95f451ae91c43a334d43101f8506d0a4a3a9f6dca5bdc6b5dafd9017b9967ea0d4a096f6fc8cda6291ac252c591b7a62cd5c7def338bb0ed329371bf35fa6237b0084fa1b994452561ab4b9bd7de0ace1cc6f4d8c2e164a607e083599613bfbc899dcde4acbc3c781150c98cff5ae91da33f2188349f8aaef44862a03822b3b9717d37830bcd3db6963490c1924e793e174d0b81715119bea872c2b4eb2da70277eb6aa298a5789ab9f7b0789037ffd87e944549470900f16c2e36340de4f2a5a3f7c6ce613a30856e27f7c5544ca8166a767cbccc6ac5b7ea5f892baac82518303967e279e723d618cbba566e3e9bd4735d999b0534923a0f57ae9afa16e5a888b05175d8e26204dadd74f33745cdee56e73c5e4c3f9eb345f682cf75acf745490c336e4f02e141edfa39ada57b003118dc745dba625c881e0ef21f265829c2e4e663cbd18427282d357b4b7398334f8b7f59a59d357f6bbaa92cd12dae56aa9e286ca08663622370d44d2a1dac533b0a99148558c08771755dafe912c8212a1f31dcbbbddfa9bfc6bdcb8951680fbe009f369642f080bb245beebcebff1f46526b27eab10500b060645f0c348ff36b4114d2f969951f7ac5e4bb4cc5f55c52c86971da5282d824e7dfc7f32e5f39147015909d82c5a2cf210f5d8e82f1243e83f4fcbcd859fe975597745f0618a38365e060a43b751d6ed1bbb45b1afd0c87619f6789b868b2557944b5bffd683c2398469d5ee8f2373f85453433dcbbc8173cd96cbe81c740cbe780c9fda4ff85bae083fd5182e6134c9957985c2d5069504924f27596cb9db849c65e2f3d7d36d0bf6fb7618f4005d3b0d71ef79578879cc6f67f5d8404bcfbb97f7e854e1269909faac057c83e8d1876981c5a719d4a4677c1456f7cea32362742063c650ef383d8588caaf65ac256775bc1949fc2fca9afb294a8550adf71f11c389719694ed422fa309018c84ca4d646e63f65cc2550ff29867ca95b2a1f85238ab3f7f46d7fa456f852fae77c3e792ef2198c07473a74fece0f7eee081f966eb3e10aa94c007b57eaa841f508c457b4d0233f393efaf64330c4162e9e19229a83a8f0ff53f35c5f66b4bb742cb02b50693f466a000d618c6c25f7d27e37aa262657da2952db38cd3c0364293568fc5168d08b433afcce96e32c590a9cbfa5685e3c8a0a0615fb02d098ade7e6786ebd60b6c8bbb54534d1d90d624191f5a688218b3966238bf3b92c9198e377e902b0edb2f9f5326ce68f211b7f374445d21136e6aafffea3ef60bd09c038190126b6bdf10bde5294eae737d1af35002b82f866cbfeaf4c8185b7f182818f13478d93f76217f793c92aa8f89853e669b19f5def3cdb6cd21d9d07e4be99b3ae3825e888766a15ececd2ac85f59d507dab9fef867234b16d912a8b3c05871b5e20fbcea00ee1044979aa0aee5ccb30d654ab64219d3e7ec2a109546f019304326043567038b1df5c464db39cd43fdc594039f492e7e3efe64564145fd795119a5dc6afdb309a5790c944dceb6339b750e5e18ecb2ccafea8ccbb1dd31e6dd33f6b500221b5eaf5e0c472b12c441cb0893221159eb73855e778b7bde93789628fdc446f325185912f80e6571f61d1d93fc6239fa3a447ec0f98437d14a7541ae6c462cc90b74a75e2fd633cfa16b1e7f5ba90ab92160cf66cc284c1c9dc5ae45a5fdd1d489e8264e350b9ef197adfedd4cce35ced3255ed29669f12a1d4e8416419c494a5df5d03465eec77fbed8bd19641295dff2cc5adfdb9e3bc93a7e63a2ee390bb59c66917cce30d30d2ef7e69ab91d287c7a3e42c6004a4e9df7cc239adf32154526b22acadfe8087ae51a2d0e48e193e75f527c217ec70b86476514d2e83ac525e40d0407423d34e814326ea409b69dbc8c9ec5288e4b4a0c8cfd3473c1190dbabf018d908c6802b4b0e45fa3bae2b46900250df4557a88dd0f290d27b7176c4ca0f9ffe92d21f7b4a204147d419c764103e643138f6121d8e0fa0dca1423a4dd90f2f12dab2b51fe583f555c30eed9d3ab2c56a7fd77f8bd579425fc1281979516dcc1642ff835e32888973f06b5675d5c7e1c481e361efac66e1839333de638666e92cf24df34112192dbf699e67320971e3f4afa574ea8454fe9ecd4df34ce06d6382bcad68f318f2c82571a25b237be695a1816b21234ab1fb8cc7e0886d13aece414482d8647c923f73e375631a43b865a873c81740722799c7aaa40bb4fa095d112c35443b3d636746cc38d8c0a9829fbd89117c8505b5f4876d57973176a6cb75e81f97ce10d2d39fea6d6a5e8ab262ed7d0695074c9c16384324fed38af566ddf2449fa19c9abd661d6f115093b616aef76c96a8161bdd8f3cdfbbc1820950c0ddbeb3a1686830c6617c8656dbdbe8c24133cdbd8f31363a89ee4792c678d106f3bb1af11e0ff2c88b5dc0803243f9990ba11d0aca86549c386d98ff9b5f86f7e5dfd2ae3c0a1d922adca605df091b07823645ff153869076c1981207e42e45cb35b0a9ee374e865f69e056043013e7314d8b8067007413953f3c93e67706ed24a367ace5564a6357bfe6a0fd54df3902f9718044820d5f8000a2395f20ee2d0c19fdb566c580ab52faf6376b3353810f4f1deb227ed8f056fbb7e3cadbcefac5c1cfdf166741f6f4f5867d54159fa877c98424c331645661bcfcb6dda6ffa1d9a21064b0422ad7a564e1c6988dd77d667e2ab748554aa56c8f2a566abe852fddba80722503e92a4ee0ca361f85eaea760b7379237c37aeea6ae4389302757dfef8fd6078e42779949ae36fc74a3baf5bf04e6ba1d04ca52a17339b63a9fc0e4c817ca5eaa315ab31180983d4e82d7f6ab6d77900e4e3e9fdc8a39946577dc868c2287d8f62330b5cba7c1e4fe72b59b99721c0bbd1faa27620148ff0d439e511582082404b4e319ab048ab5da507502fd9d259ade7b392ac685ffd73940666d8ffc7cf9e82849c8f7095bc486bc50d777d1e2d8a2484b1c2326326ec5283d69fee279cf421348a21350725b29d93a5874d62ec7ff254e27c5c32730dd5fef0d7b9d30fe864588017f141360ee679d82566584bb4b97fbef7d73a6a6dcc5a5dc312d5495cf2fdf57b3f6195c172efa91e8adc7346205656c1a224173297e94839b6cae62c7ec0ef576096169d2716c0a3a72cb414db2deccfe9515225db3693881bfbb9a16683aeeb7fe4700b7ee9b81ed8142809c334478685a1af2355dd1776878d98e99f7adea70d587fe23365951c59480202b983c06df6a9efebc3fb1deb1fe28151d75936211cfe74523e47ba68ec3955bcc0bba9607b8ac31649bb1b21024e8578f88ec27a5850b0d69d741d298b10d3e5fc60df5127931baccafe780a41f768aaa25ad92fa61e06da7df8d175dcc438c0185ed63e6313dfcd243809b68861d172c75f2d6bc8738c89bfe494cade24758f0161e26e217b4b2c732e6a47b4539219ca6c2763fd3b2e8abe6c177969046eab6b656cf7a90af19dd6295a092bf8778a0aa479b1d87d448363aa39f44a315e1a4fa5e5680797519753f89afae15c5268d767fbdc7757ae837e36bd1bf18b40e00f77d00f74517cf99fbc3e89325810cf0817b8daa2317d73721ede45d4e0a1b01c726c23e680d7c2e74c19f5c1c71b12c49558b8793868f5ae3b3b7bbecdbaa345b9ef5ffe1be6b58e77a2d1887ddb3c06829e776c9d49c67feb45264a14deb7ec958e4ad4cd571bdbd5010e5311bce00935023fe8b6ba0c73d7df19e6168445f3cc9fe099635133dd02b5a826173bcfadf6e0d217e9bb184f9de68b56441fc8e957a6fa850e0f111e9e930ac9cdf460e1f1f309dd485e14b42f15c316c70a9ef39deee1931d23f9401307f3f1d99d31e1294100489c9cab46eb7530dc643709c9c9478782633a53a3a2059515609c2d9ec33e416ab19b189741720cb14f2afa7ed3fd730381f03694c14651e2d8a3e9387e387a23b87a4506859c2b9c131a37bdd80dbf2ae3b14389fa35ce6e6d35ae5cf14a4fe47b065d0e2f4001c0f51ca8f8ec104b06b2346d2ca9a29156514129e37329ce","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
