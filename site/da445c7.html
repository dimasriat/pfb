<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"536dbc73b117b5f22bf7008105d10ef8ae71f3c597d048b4dd52c43d033dcdf6664251e8d4dc34684809f7e08402c96db36945e29be196c275c9e37da94d8bdb4f83940e83a7364d923d62772b7db4280a21a06a6d6caf45debe1a796c0449726607f9d8aabe436599f59f3967cddb1ced3cab7baf166fba2e757806bc9a4f569b373b580de90c6f027957916faa0c153a4de55de6d07b089960df2d4a6c4000c500ac796ff16f8c806dcba3fc57c9ceb29f84710f1ad9cf06991275326852a1ade45c3edc4d8c5773e5e67b6cef85c13c5b41250e0e849cd5c2f900880cf21c03a004c327ca8bf32ed3b0d52bdd6375664c9db60a0d29e1b44dbba7f18475845a28d8b5f357125a732302afed5fc42c1be0af6ca057dcb2b33fe4e55ec3b0f507252ea9c81cf4dcde8da8e8ab77ad0cc6242ffb234670f8ba7999d57e07aacf36319724702008b851b1e4b8ea89f82d2698c792ac32687d88bf61e6860dee9ec43b4382a7412bf217426f1dfeadedf516dad00a5e928e89f594e45a7388706d1c98d180631ebabdcc065570804ad99e35a39d39546e9fcb3c45d5bfa3a6ac6742fac4c7eed5da0012c9fc3df9aca280878a19458284a767f7238d18d6e0b1b6082f4166e73432fde18bb61d7773b14237cb420bed1eeea69c830eb57affe66e5466953691f238a4f4592b722b52a8f0a841edb9f1803d8db6bf3212b1f273e622d329374dba988293ca92391f6afc7023cdd94d8a7c5c8043ac70afd7d01646ec418e9a630739334de26f9a949826e247fc99ee61dff6a0b399fa68e0ac0120f6ad8ccbad9320f1c80815ff81896f708bf16b4e77986d17ddb68dbc81802c52ab74254b6b12b9d9e13214f676369c9a3100b7b6c29635e59235003068d782c1d958c8f26b53a0fa5da081c764386e3ecb3d3531f98017af664a272b68d4ea9c0fea66085a92e73f37e00132dfeb599d5fe4495959846630cec9379f1e4389aa7c170abeada786f6b6d27dbc1f472d96dca845561bd8e1a6921f0982b9d7424d7c0e1301c10889151a97a0f82a15c21c2461687ea7475c83b663d8b7ed2ee3cf744254b46b9e3b816e6771f94c3a0c2564eb15fc6cb1e7204f08c25e0ac8405f90b99040937903ce5e70d4131b5d758fd370ccc4ed724bd146930c33fa16cb2d8532f7aee6ec45c4a3a5350cf3aa54ddfac0c7a4cd120b61e56aa182c297f986052167c849defc67530a0554f4285a74be7bc72bed96f14c30e121b8f4526bf7cc0877c26f86b31d01949717a8107a491ecacdb141e00e271bd3931ed0ab5e186b881f10748ce8581f9a025ec18d06016947b28860ac9968492e8d60fb82a3e7651f8a97fd3275c3c358067624a94ec9bfcf1b3e63ea3fe6740c20f8ba77c68b78037b98abe49a75990bf2d960d465b9043057cdbb53c0a6315e9af4a7737cfa08e72ab689e23913163378ebb02616da39412739582e6efbe09997be306b7c9e1ce3e1d771690ec80d0f684afe643211b96800658203511d8a396eb7e27071346b9716c1407e97f3a627209f184e93feef4a84ce7188ab6db9b4f0aa14e6c31025c2cece7c9fda23a437577682a2d8b1b6764a089e61f0da891a739af2f2f7197549e7b7cba54f73d092672eb25189238be08c4012a14b1e91b5c868a58dd539d0ebb4dfc7793fc91bea12b1bf2999fe82b83354b56975c2d1652e7975368c6dba8c5a30c3d93bc2cd38654e4225b9df3e96599bc9eb5ae51631f6d9bdaa522dc19e12eb4313530bf5793fef935f34b694e5b9655ca689291ca11f7e0fe3dea0384842bce4aa125613efa46c3c146f0b983acd177c5775962723eba64fbd33770435466ff91e936f46b31c44573f51ebc166f79fae4cd5f6fea943d46de6552cba5d38a2068fa0b0d7df9eeff4b0f7875998db0680b78265e95e0ed25751e5fdd1757a2d3900cd0dda92fb9c2b47a75913368e103488d19927cfae676e1097a7e1f06b93f79b9d691a26202f27917bfff10f0f96982f93abee7012da89b7c038c53dfd47590e00a1749856e79f4613f7d0a05a16ddb75f7aac1622d0cacd1228e72c6c5093bd328f8334e2b19447d834cccf9069ce1333f9a4baaf4169fbb9bbf3f5329664e8d9537fc15ad7088919d0ba7a8941691bb3c85b8d9f66047b5feb29a796469a94e820f6eabc680364237f9805901e0379bc78031cdeb7e4b2be3542b2a327b90608ec387365d6d564eb7aa44bd3d95f0e3689dda4572df6d2d2f3a6552506be69a5639380b6f1898cc51ebebd22ace38e940b26813db427a029ce610515d3dbc7bd89241d42c9e3020e2b8a173ff582cb7e373db70df4c38f169df3e9244f3a92b5ebec5e73537c43ef0502891b68756d32cd43e3ed54f343b87de47face411fa90a876be19cd30d95789c4e7cdb97cc452d1312d9cbd19c33b4b13616b067f30450d807032432ef2c0452602aad1eac116a8a9c6c21eb676cf7e40a255e8b02093c698d10da79d90a931b2bd54b150f786b574f81f0a4bce82cb7014788d8929fbc5d62386f26d4bd01652257bc39460fc414c431e495c6073b5abf8a438c5803b30630e23bee64733813be7379b2bd2ad86d6af45a3a548ef9656442363f47e950fbae37faeb59ecc5bad1c8b213f18a46d98d8ea88479e3d8c8d53f64749fc86481b3b7169c5671a4f07feb1848cfcd74761d566769955e97cd299ec767e201628baff4e970fed87dcd24ba171cc848ee9744bb3a6937321251067965e16a95e8a2890d4a43a8fa4349f78a1dbbd7d1f4fe2cc90dc9fb2b17570e1c532bd0552a8e885700d2aeae9635b404213c3a069a974f1e4366e2fce9fc937243f9e244770d5c875fe1fe498101140b3e39b31d5060bf75fa59156f45edccbad44ff085e355c4e8cdea17d6598ec03fd54525b3279b0e399ca891763f56cedaccf13ecefac5438cf8ec757324aa1b435f40b62a46665e3bb5777ced796e61f6972fa4528382c11331261925d6facf783d85baf9d6edd24b573a300251bee8a89c81c2fe74f685d2f688b187ef6d58eb011aaa491487e1ace6c15eee850918658d1683b6a3f45a079d915c8bf625b24b40b68397c70673920954c8aaea5870be8fd1c9a7f083401a90a86385128c1d3f6b2d1bb588d858de3c670029e31c1c3fabe8f373dae359607bf86f95a79133cc0d56b3fe333824951129af5d716331b04874146cc1462d7f25c349029fa4a3e31b8cd79dcef71ff81c3c5a26c1af1751c63bc728dc299d3ecf10b3aff9bcae92dad7c988a4c2144c2682af8c81eb4e0f3f5398d18744597433ab4358164bfaf8987922bbe49dbb249afa9274123285bc2ccf19e6a3023b4137feb890125aa5f84f65bcab4b8067f453ff6f67edb0781800f8b00d14ec0d126f447548a869dd7cdaa07d23ec87be181871835b8793863a2b6208af012bc1990856afe37798cb4426dd444bd2eec57bcc0690acb24f6e020e794eb67c74e39f59332f5a3cf38057b62067df62e987e5b72315af2e8687ef8448bf47b1f66767bbb209e57a30f3d023391dda9d1339b5a85bbb3c98922a8b5952651682bf4c0c4e9503d0be2e346289e67dbf16d815d81fb0cd8a5b4504acdc9e458b55de78bb64e15e7a11271624af0e74d23abc740df9f24ebc5be750af43293fa621e956c941dc56d78b3d5b5b2f7626072b66e81d673fd805cf2f24655241358b2faa5524bf45ed575ae6fc163660238e8d28dc286d36417dfa3378abb92571640bf1b22caffa47f474a36adc6dc9f82a51ec99df0d0ff764db1ff1d03e2d24376a8e79294b105f5b23c5354926a7f954802aa29f3a124f40998074142523a9f5668147ef639c506fba96fdb4a1da7608a5e6ce0cbedd32696ee71565d556abc510348181df3ab9c752556f9d43de9c3e600b09c9bc4b4f0788cfbc01efd53876aaecfab9f89af7cfdeca3088717fd6e91a621fc8bfa1a3fa1ba3f71a9d5ebfcdfdf8523f365bd4c0e7dc775dc4ee13b5a480ebe47fe6277a538e6d262eb7bdcaf908b6c61c3341462bb2844fa362178bbbaa700e0d78bc66e710aae172057030bfc275dbcd466f014d925502470128bf24d94adfc07d693058660a1ac6a103591b4b51df0dcd5c0e94c09227bc78236579f277cfdd5c3e9fc161f45f33fcf6367918a1ff82b5e20bbf17ccefbf1eff2c8e2ddee7a8d2fceb80bdcd855f6baa315368d7072f72ef148860ceebe45ae1c13a64c6388a0a2f4a5003ee3768fe99c17cee892356847a1571570aa28f28c8af155109643a2844ad528c373ffd4a2c917d3899f5f37d473ee69dd8041236e4b630f35d0bfccae8da97decba7d1f093b2b4a24443a8f61ba0940f69f3b815754ddac66b32f459890d3ce359af663455a6cd547bff25ab8b52caf9df7bce762a12a23f7497503ff1023152d3b789e69b3938272cac329e972787125c07d1eaf6f69bc2d9ed856e2481593b87f3b053e65616691490450ec5695aeff98e29b8d67a185eddc46a2a4a365f12340be0174d8457d4ad31921f19a827592eaeaf134fa95a52f9036e41ec643f4806300e1dfe3e8d8be06d1a13a5b905e494026d332fa26aae41ec40210caa26e9cffdcd8772521c6a19b61d71ef2787e1d0a0f00ad00d60844c0a41c3a148fda2534f613d36696912dae66d65ace30ab309a9373e857e6661cd5e2bc71ed275186f4a6aac2196e3f4819d638c987ed26e7e38da121068a5c3a041661bb71c0e5b10a86b5fe3d87fb91a4acc26644440b9e0c38205ffa0c325a8a6250676238d9510ef31d1279cec3cdb163385dbf0f0d98cb719e89a3b0129430b8d872cef26827b5e6ef52c3f7c51d8c9e275bebdb53750ec7e7a143a18e2d61aaa36660bb7c1e239727f615b636b3ca11cff82505973fa82cc664328cd29e7f77700ea5ca32ff47e1db308f3fc91ba35e3cbf80493dd51c78f43ef8a225b3eeb97e2de7936641d18d100b4ff4cc0d32f21ab841f68877952277a61c0db4df261110f9a87447709e8fa7daf4c3241690f4e1c48f3ec7cafb139ebcda66fcef7a06e30b46ea9883ebe125940149149f6956a0f8201667b820e40294ad67bf134f24a28bc73c7af8cfb9fa18a565cf7cda431517eb5a2f4e42bb98bc430d542ba8e625c0523e82154e3bab109ff5cbd99437df5bbd2ea32ae576c5cc7f3d7804b69aeaa6c8c28eb61cdf4da4b2fdd5f55ffeaeb7dba3d01e6ce2bdb536c4119ddf974e286c3919a167afcc08ba3fcdee71d33b424a6cf54fb789f046418fa68dd185bc2cd6ca7a7205801b0d63e15d91bab55141b6dc5cefa2194d3438c7c6e26dd21041490465d1c12fa7b1e7ff3922773968c620e2b6a4e3fbd74413b3eacaa4644d9869d203bdf7576a25a69b3d206468bcf49df4e333f539cdb20e18ba9bd0f44c44c2c82f85ca49c23f451a0a4781e99777414c0005e21d4108320b906c574b9646f55139f8c87e6294ab5f10683a727d30c7dde0f5b88795f78e62929ddeefeedf169428a38f00adcbf3707a2327706f5b61b35c565b2c85ef2dc1c2c827be22e824f062c6d4d63d3e82b1b59a1081d97a6f3dd5a36a73de86afef26afee603bcb430280d8b19e7c5afd9e806d4cbad2269f921f72deebe5cc5083320d8a1375f3346fddaea5b1289837e408258d7c674221d6b4af85406ea7b8447a8cd700c784b8622522c8115ff96cfa874187eeff9ca4bd0cf19b0f6797b730abff934dd8ce18c433e6a21260a80a4e2f29bc668405c1a4497ac76006fc925f2c075bf67c082326e4802c8c86615ae63fbd96651c541bd4f649c7b2aeb8c5648f65300fd0ac9e7c623917520ad1f829a02274c012c939e5d9afa8f7751efed1229ba05d4057a8f3036350097ccd689077b3117ba1dca33881f41378a8204d43fe1030524807b018bd96d5ab7b380302864302e1772edb4177ef13cf97299247475aa3c3248f2d1c93acb97fb1bd3dcd4d0ab5c790525e2c15071cb39f6722e68a8252118ad5ced2dbadff6862306496bce77d8597c88733a595a53abea1a7d3a528dc5f79d25098e13cbc2598e4e4777cf98c2a289a618b25b50ff2e21cc466bfc6cbb93bb55a2a36c44ec81e4d5b75b7700d105be729251cc4ce4413b1550f0a640cdb3a19a67af3c543301fed0a770ca088b7a35b00c6ab314132ac88e8c0824b75dffaad3436cb338dd5f8ee20cddbde2026a9dd3b54cd08eaf14ab2619b86edf72cad9062aa8af645ac72c5b1d13563ec207d9e0e1049dae8e14868822d5245dcae1cffbdad12cda5792d478465a7a9130eab895ea830ba54ba91e36bf0a619a27e0550d5791938e9fbd9cc162a48c2161ebe590afede855edd7822494170da967d0e324abd3adc0ae64f634ed2835774dd4e05c4c57ce650175f4842165b60b9552764dbe3242170f064c259129aa881189b0c30dfc80022c11359d915da11bb424e835592f9236f204d691b562f506505101fab172a3fd587dc570e7af639b705228e0529b9e53c2b2df7b41e63f05f4d45a3b8236a17a9ebc51116818bb1f4d62ae669276223434484e90ee10779120c2fa2a366bfe4a7bc4e60eca5b1e53c4b20d48f9d39769836b825604e41d97f8df60f0bbe861050cc51cacdee623fdba3f08d28d971466d0ce9d126e45b7e8452284b53c16ad0a9d7ba729b26ffc38691c1deb0a05a33ee61759c6b44dbd56dc16867b3c5e2e0837a10e66f2a071d85f0314b062c97c29505d0c0f591aac46f63238f4d1f1e52544df8230c9c5a7de1e0af2f02c5ca8b2bb51ce323e4285e9cf69a762ec04e8400e3a6a62d20c76f49b6ddacfed7f223e89937033165a805db1bdf938706f9c98ba8e5b1ca1463620437034e9d729511c364a6a47bcaae06b747998805f816a8dd5e7178eb1a4ca6b6ffca35717e0b99ba1b852f06a43113f101348e416bc56c38f676a7979163b620d01bafd3239ff4c558fd64808131bcd9ca92add6d069b8215d51d38952c7a365c4f6a6119b707fe463fb9c5a81e313b3eaf2052c6e9c9dbfaf0d035e62e93de636c5cc085778da7ae833ce539e9ce62e37fe7d9bbcc10e0347caff63531268fd8dc1f6acea2e5ecbc786e37cd72c24fedc2122d8c8433e0deb9a2d42ea44ae1f1948f70580f332056b318a9aa6d15235a80b4f0f8efbef04be2f49ff0a6d229ea320ba39682c3c3ecf6a239aa13b69dedf2cf146177166df72ffec311b9be2a3d2e36ba867975d8732b9ac37020e7214c24b88f7b214dbaedaeaa63ff1a40b78c70aaa2b20cf3a15a95b65280671f72a077877a0b679ed2582f0058da2de1bf0da7405574fb159558caaa80c54c05b103a9ac7a274001a01c1591fe413ce665fd5a8c8e57cbf64f39370c6e976c90a72ba6db1c19a77508a346af2c22cd0b56b27ae10c2a1063f144a4fd1d151dc33ecd19743896957dd8964b4ac2cbefbb83b18f37d928c4097da618a29ad6886a52297bc99894310d3312d4f4d4e23d9f30a07d97f99c93a28bcf378debd8aea9cb70699440bdb5b69e21e7f7f25a007093e5c46599c11c610ce78729dbf1081bab67d12c7b299c8955c5f5ec2d308d09d1f28df5db8bad4711f3195eef3ff447814a501e7c24f34aedfe7a5756cbfc413dc2842655f3a64634910d08fbadd4e0f953eb58447ce600175d9cea41744fa6c7507c94393bff59660d527caf59de6a870fa9ba1643729ef516c0f374acd9078a61caa0e3640a4fdd09232ade6d90b5f8fd05964b7c85e7ad9e18ff49a229cea7d412f036a376dff0459ad21efa2a41d141f7d4ee909c791f7260e21b009e198cfb3aa89ec3ab17fc0ed80d27102fae6cf2ead000f42d86e60078b90c04cda55d390887af8bca371e21dd0722fe3de09677a115e7bb27d0020f3d5147d085454a69de3fb264b0a698ba2fa0817f496c0ac975eef17b3e0989d4505d8a26c0e5cab4309d8ec60c539c0d907071ddbacb22daed37edc0388faf4ea7e42db5e682c49ddb6aae8db7ac774c9a3840272f5ea8b0218626bc2a1c7c044704d1ad74e6bc0ad37a609b093c409239b8e62cef6e9b40d6fd534bb7496039bdf99e47cd03f6e563cc8d836e6afe4f9921b8d92636781e078d9b9d040b4f8f4a05553719deb34f16e1b1231d00f63c1ca58587f7c83090558637f7cc43eb95c3efee4d3743819238b4af2a2cb642af381c178a72c2956728fe0120f3be9d6f34aacff2443cd5dd95b7b607067478c65affdfca0f3130af049c2f8191e31efa284b6ba1ccf4e5c771f13b358626cb15639cace449497c46676e4b9128b0368e19fab0740e896db92549485964fb98b4baac300939083c611ff07ea15fe7ab9881c05f7bf483cbd3f11f55687ad6d905f82566c485ee6fea61ca17406b6ca09970118d66c7dba66b3cf17bbaab70bab4a5b57eede20b8b768e4667e9f4fc16426859803e95ec6f2339f22e256d07d61e4bc45c11dabdfb18d0d80ca84f976783fd9ed9cb3660dd595e0a4783cebeea962f022ca6d612ae7450c2fe2efd24a24d4e0102ed3ac486bc64591c3f216e905872d15dbaea820665cd2fb14bdfdf6a786789c3c97a6d3a6645448fa8524cdcfbb26af148758f08cf5f7b8d5a694579d5ff998108492aeea0930c6a2603f076b6fa44ee42f9d65a4eb1990bd8131fc0fd2605d97bebf72267455a5aba14a2cd3fcf871c39a7d52a2a0603921893dbdfe8d6419109571deeafbbe1eca8a3f44718a7654b12033f8cb52b5346a6a47b2cdc202b72f2203bf751e496006bce8fd2e88a3addef26188caaff55ac28b5d7c765a20e3b360d0b7f73025cf74fab715ff1ee6626facce284d67c611b168fed3539ab6f3e608b1c10b125cf72c8febdd360b7575edcfd262f8b90864f92c96d9e6bffce2653fc08669de1e7eec396fe838fa014fae95a945975d06458d0b258b2e9145ad454fcfa586ea7f4cdb434765220824bb963cf5e841c773a8436a09442d8f358e86600670a1b7c8a8ed098b2cce3b6997c6f5abcb357ff6f28abcb6c419416b752ed942a41ae5f42fe693d7da13d6fc8b92c0cf08a99f11a0d7ac04f4d9490c4b41ccc968a07ce2f8a14c6cb180b7b492fba6fd939e177211f21f2f007f7ca3eb0b7c84ff1667d448baeb8d5145a01411f33bd2d705c1d27b7f43e7830ebeda67ec2902d7afc2c7efa2b7442a87c820be295564c3b4f6690a41f5d3e989d3ed18fe185547b7b9003778798b9734c1c7ab34295a9c9e35fd9c4735fe37a290da7662d52ad0ae3f673bb07b0e0d33b0b594e8a2e31a6024120667f4337e7a04587591654ea890961afcfe4c19659132696d233174c75670dbb412266e0ed2227f55b238218052b17d07e2385014b93b3ee5f5ef74740e5fb47bbddf4033e816ab60f4297115b6fed421404c72f5fbfd67665357fd12712d1ecfdc3c051fff1b97a10d93d18bdbdc1ee3fdfc0419bfe2f832c9d5c2a97f01d3452cabc4e36db85275a23d403785ddcb77b177e7c897505169603ab0e52c19c2c9f480604af22a26dfb790373b58ba215e4c14a1e7564d8215b3724cead970a36129068ee6fbf23dc13092c1c9d47c2953ae7b322f50c85e635cf68069d2f94ee807a3a068bfaa9f9938b61b9143308d1ddf0484b89f0239a5749a2d8720995d2de8975b6c49ef0a6c6af6c6811457f701083f5d9ad2bb0bd14407280d817227cdb9b5a282311a89b665a43f906002ff39ab37026f9155f28720cfc4567069e2df0edeffdaa0fa4596d268918ab51ee8e61dd48069bc24d24299acece9eede5c06f9e84234fb1ee2fde75c6eb62bcd64e1307c55e52d4ac5b9457d95e272d1fdf5849751af2745f9283d10f6ee8d55d84e757b6cc99c96d97d62b88bf07c3425ede89102fadc08e65f039558912c7ab4d07c5f8edbfd6246068024567085f6c83d570a2553ae80f0fc3351c1bb7c000be5bffeb68d8e4b54f4255565ce24d794eb72e1eea1230dcb62adf83ad961608c8d77b476a069dcbda17c7d2a6231d8711fa9d0b4be69630876ee38b105d24334ad884fc49c516bafb6bd24e85fb907a04cb8c24bb6ba452705e3f65b1b4431fbb74648b104008a1c268c7129c16ad7614513d40ce6a52a823e661db983331b427805545351d8266a53a53652ba85357cdf05260a4a519945662cec2203904c6b1e67076a027264acbf8cb9039e1981f903b12825c10adfff37538f05c8779380dd3d9cf2c12f5cf69c0784f6aa4e462b62094e85abf592c8ef952374812791c339f8760d7a8c6357de844030fa5db29d691920356efc9d8f587ea7b650c0364123ef41379921ec706fec220828023b57c5186e6bf112dcd7dd205ea9fe407b7c5a9fc19ab699453490289bfd40a8c1cc4747da434fb52f444890afccbeb35ba57493b53cbd9e72573cebf85a238e3ea6178fe86c60093142f41cc0faea70f1ca64164c9924c1db1633ec086d7d82b3c15daa8295b716063e2d4b67c178261288f214e086dde7898ed35888dd33b00688c799af1b18f94aa87c982ad61a32bff65f1eaa2c06e374a0e4bc44af546be64b84849af8de0dc48a15477cd39ccbe2a6d6727596015e2c86177d1769be9d7e06fd0b113efc16701ca2345aa0483fde9b40e0fdde191246752b230affec38c74f0d99be931999c8ab88e27e4169aa8352c8238068fb24a1b040519d72d10909bdba593ab91e618b679d528cd582619225a7ac987ed1fe86169ce52f8da39f67bf511d3fe63e82488fa818fc382ad52243e0134561f2a8fd1927fd5cc7c03d258d7ebaa7fff55f4fba377c90476141f110bd5143fe40c511ad12bf1223272f6b346519c29dd1735e38a08b63df582c91a21cf0240a86b6e174d1190bb03d0df1bf685eb08c42f35c9fd530984b06b290c79dc0ac5cdb0aa44b3be27caafcf43a7c4d198c4e456ff1908f052f2b671192fefd4155304589677cafe0996057f1d6d2577df3673dfe79b68cb78d648af13b8c774870542c7497186671befa8225ac74bd5e45448416caad283478e7d84d4d27390e577e4b0b16e71b44518707c29133c1d59fe1130938ef8236b111a26559ceaeb73f4dead99cb1a8432fc5a64d29e7278243f00d8bc7e43c48ecde91e05810e6223b4b071a50ebe70c7917349e3c1bb13d7a26d685f5b235ed615563540e0e2a2a81c1","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
