<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1829023e7913d62b446d43f50debc0656f16a030dddfd6df7302ee12a6ad90d086141d191229ec66f397a5be53a8a7707d773f9118560a10ba2820fc914e110aa2944041262402f8abf85a62df9733ff8459e7a3d13027a2dc8c371d2e8c9efd932fa805b2caf5b666330b56e155cac65a909332259bb48ec2c66a9faac0b9b6a6f8137dd17a806750e7e3302afc84676bcc12bd90dbfe8c22b11b6f98e5f6be15b04021cdd4e848e8b55e2a7953e616d7eadc446c7112337b7e085b4ccc63f05d37434a0522aafe7a2807110866349d86ef0499e85001d15a4107eb5bb8a4a3986033cb9c33f589425a34e069ff53603ae7480a330153fe35a305b07a69de6fc3236b6346d12af546c7d9359483e5cbe8ad590845d595d5b506712ac1f264822d0d133951d5a97cbea4ba1bcfeb18fa7c0ad1dff782b4f000966468a1cefa1ded565bf519d88b9605cd135395ca61253ba83801824f55879079a20ecafb6e021b67f4b829cf7f322507c23ae6d372945e81240006fd7d1e036c60c0d789de374f77c30d4b42833ea62983b2876b50b2ac047180a5d5641d3fde2aff38af497fb6eaaac5be870dd31a0fc58962ce061e12dfa5140cfd871d033d7748be72adbef43cc96a2c961283eb254ab0115c0313bec22936a1c460a90f7d44b47f723b69ae8032b6d348a1f43618b18d4c1e5b6e5901f28be3f9e073eb40ae4646525c2d61ecdbbe56e8cc589f50a275f9645db0b5befa91a04ba3d358e29514c279c6d6465f82af07ce4e89b1deaf6cb626d83209861f81cb566015c376b9f16527af1004c81cc47ffab6518ea177de5467dd1e92d4b57571a4f46a3c7d5bb310df32adb066c2a68d54d3951f35f335c094481cdaa9f53109327d7fd78a8cb2ec177327eaf730b5dfa009eff4110ab8f19855af35ecd9ae6654553f2c4e7823a92429f8ac782ecde18745b54f11ee29515c47c917f118cc70a5070aa8d87edd61b8159de560c916b79d4a13efa07d68c29a7c3b3ffe8a451761da408a09e6a9449d27db91ff20a94e862aab3ea3e675960737c35dfec95f9671f5b31d0995b5abfcbc0ec4fd7fee363fdfcce24dd7cf0abec08b2688edfbaf17483fe9893fd82734f26f67d39d6c6e0119d07999610b673b0660b424e88a120751bb056c222fcd3ae4ce556ac7d22ceefb0332799a32f7ef298b830428f26cea3cdb1e041d3a0aa989dbdfe6177308b84ef867d46af6ae233ae3f86d3de60b394ca07bdbc15038d0effa955000830d06e8f829ec07c676b3cafb6e7ef199ec26c4a87160a76efbdbe3f2b6195f13b60f3f7f8e75fc4df872daa0c346c28395485187295680b631bff924e9c7efbd87c628f640c88b087606973b1b8f1b17319ba64e0dbe28ce6002907d6f4e26b96f83c13659867c8626f92ac923cabe18b6eaadd5db111e4bdc12564d9f423f99a3c386830c8656df362fcfef5203dcf21ba72cdfc298c2da365cb5ab0a19ab6a4578eafd36e8ac08f7b558b318859520936c9bdd2a236516fcb1c5405518e9b1e585e7d8aec6d312417e19be229ae878fff3e8672ffd26fb600441fe0b2e3cfe7ea87ba550213a7272f77510797664e6cccab92db60ac4a4380fca89056fe3e96ccf0516afa29720af59c6055efbf68c30da5fe195999473bd2a154833d6ddd09cc9020facb454aa6a5fcd7acb066fb7034eee2eda235933cc59da60513734716516376f6cd93d68516d67ff2d02f663c03241cf1e3b371268b2af99d25a2fbbaf9c011a416b12253d907d80f5a6c5597be41ca91bf2dd18f4b35b0938a1df873c6bc8be7bd9ac69350cadcabceef9da96de22b91870d86f7aaf9590daab72fc45350e6fbe2b8d210d6d599e6588fd5d367cfe129703bec0d486ee37256279075013d1bc09cf060ecb8c5b65478b76a02861eda77df2fae1c63cd3c0046e57cbe9b7f5008ad4ca06492754a89f06e0b3193d7cac3b96d05470db9b70dcbde61d0354b4d52b88abef25035fa3e40b39d130e9be5800bf2299921da0875a2aa5ae4f15ad2010f856cad374c460907ad6fa9f3d6459cd3f3df8bff00c4cb05b1ba8e42663215dccecf479ab7d712bf58f3d57a1407c8dcb04c8b49b065e730b13b472a81436be2670a9d0bb2f4a0c08006ce9877f0f67ee2baac1d55a19dc171b2c77e55a419bd9c399b70c0399e40d244cf2637d456b883bd0bd3a0b7748c84c477de28bba62185ed72aab3209a736e8629d0d834927315f45af13c8d57a4abad798ccaf475fc8fec0b1e3e8406a2369dfd76d9e054142c59ca8ccbf2ba3dc4fee82a18b2fae17680357c45bbe968c6f89fe46faa5e9d4e686237a0e13d5b57d4ad5b2bfd9ec237f12b1cc6348497ce8cb05ab16afc291757cbce59900ec3c76c6c92e8223dcb1392094a66db5c5d81ec73dbfc821f1188499baed0ce89812e173c47a61d1a67ee214af2e0cab4826867b951c9598f214e2e9e8ba9490b4073a160e6c0d7a9102cec07321751e833660343277f1413974a8df85c0eb845b7df7d385f1f194b31e6de51eea13a771fc90d5ebe3816ed0b97f242dfd414ffb7c54fd77e6f7164b3ec38160f6ae71d7a00cc2c0daf8c1f380c2249327b793e70b9216f7dde7035c2d927e05d0b8af6d4177d15e75e0cfa3f4d6f5cc6252fd258454c17969a117ed46b2a490240d1876d248aa4c4747d37b62aa788368c3cc09b7f075b82053d27db621041db3f69480d1ca0beba0ccaa4bf85108024d14407a8fcdfb7611fbaadc9845929e5b41dcf90991819d1f46974398fa101360faf99a29b65adb5c9766a4877581371d35e8107fa82a5414607f1a9e6024149563e12d4a4566a2ed42ce0b5b578e14d322c6e345e6872615c142475d5f775e680ff2b71b0d72269893132b4c4a705373c4d312ae4a5d977807b8aaab46d624e83dac39617dcb4c77df829266aab26a1ddfc6cf54cc85190602e991a229305ad684ce9cae491a70e737496edec4f0d689d57852ba5dfa911bc699bb77e97b2ca9205ab57f2c965a2a9477b86e7f72196c7c8cca014f4baef18d47230ffdc6c17c8b6cb4ed30b17946f6b6d3bd85c6394795bd1d0eb7b943946024cfffac80f6cbfd4ca68192481ea3a565e158062a071dfc2cc22206e61bd36cf3a9bec27445ce3101380650e1ebb703bffb87e933da4ec2efb2f32a678d0af1640b2ce37ce37206966d7506e899a2806e419c039c94006ef03c9415d3d4b811b0c77d0c77d9fe58a96a7e6dcbcf46980b52f3f81a2021438267a513ff788494a618a174ba16f8e146a800f9dba12955ce136f77404d8c8f1d87d495a8480dbfd1bb3f5088af56d57384edc5f3697c7943bf687d070a2621259b3c340cd64171319b4b66a4e9d74c960bf75140cfe6da9fe2705c83e35d9fad0138d6290b65dc616e86dc76cdee01655664d24c613cf6157332e415c6b8068459b6f809f2bf6379ae32774f4500825fd028782f53ec31a855ac976a365fd9ceff4bb0d3c5a58da953525ae3b8dddbd296c68678c3e308492dd2d783bc45db2cd56ae3a8e43d81705665368902c73f79096f9879349f68300808e064f22096010bfd6683f0c3596b474b549251bbbb692563ad3a92154ac20bc6fdbdf3a3e140470890b9fd28ccc545fd8363186dcd5c6c3888d19d65955ff04c62e1fafbac7e3955be9510ae5f59e9bbbdac1eeebdaa323aad52e8566b13265047098404b1d9ab751ba74e9cea42173c268de8c87c31faa674bf5a9bcfc7ed12a63e67368a9937ca866477a6478a74d9387ea765a8d85ee89ee7e1f2fe11e8eb6416b56421237c7a75847c3cd9a26e9fcb23b21cddad9ddb8328594117214b664aa797af45d7046c04667ca0bf5de9181fab72813fe916928a93d6dfd1bc866fdb6da6f64af77398e0bc5076e8fb36d936b24c05952e15bcc447bae0dab91a7fe81852729cfbc1dd673333e332fa3441b649b1295c72bbbeb4e8d07975ebd8d813a76015d42f5c25c3ce9ce7c5562b03b91278b153df6e2123d47f549bf9a1d4482ae922f9a203abd63ea5c4988a9187f105b0054332929446b7bcc872e4f4c9aad55ec4ea7b456703358dd8b64bfd290042595b420c0dfbbf501a422c57c8947f52fb18fe58f77e0748819172e4cd2e51e9c89cc94a050588bc39c37b419e4b1aab96bb5e3d7a10c57787abf755aa8e339736f6c9de64c77e0310c5c8f9d3e8680a622892d71fe6bccde8affe2f9facb0580855c1d50f35cc4142a15820ada64cdaf1cc46dcd001d10f1f44d5c1a8ee851e791f138c3517d7b45ade9aa245628e05330f82068775725d4b7cddfa603514b15f590629a835bdc86664f214d493f9e38e732101f2a2751bae3ec500aa1a2bbe6789bbb07654790218b0ece4b04665ddf061b5942860cadcfda7c6d499cd3aa30e053f737966fba044614130b48ae5e67d9790730e1629f3e2d22bf2b82cbf1519307d97550f18d6986f9714a9b4f5fa2592f894560ce53f4808860f505b40ff474518544955cb4aeb5b835d5448212e8bf9a8abbfd923d27d4e81c2f9a879aadf6f153a0f25715210e2a9de88b8b14f546d9a30171799bb003cfb0f43b906a50152cd8e18c827e3990da76654ec57415728289058d37cd40c3b70afd088849011c577eb19f0504ceff36661ac3a9168f2ebad084c34a71c26148d161953601dfeb2c5f4ce86bf825e389ec44776f008558675e8d94befb12c711e9524aec73df1a7b60430a5e727ed50feac2d7f1141cc02e19cd4b73accdd1fa0bd2ccc0fd23ddb72b90ee90a0b611dc64745ba0ce0f0c0ce1655096a626dd3eb8cd6389eec08fa982f5478df983dd79cccd868b0a9ad3e3dd5a49d4309cf23274a1aa550ed6e8a4ddcc8ced643ae2755922a6f59cd6b257bc07fc8690e0eec043dc84983e57b033c8d9ed2233d5a3c0a632890038416dc105383dcd3858bd5d6c684af4d97d4135f7d915d3394baa11e95dbfcf17284b7b8b90735897eeca8491521de3a8979d54b0adc34365d4ac1e6749a30863e0f5abdedb84344304c89fbdac0b89106b57cc3981c9154e79d41926eb91fbfffdf354b305aa8e452c5e76fa11472892716d9f6315ca84def762a04c2f88b4d0b7d106f1031e5d34140d8929dafdcaa5767b4abb6ea3649d1f351be73a1caecd7582f6dd36bcb6e51904ea5b9e8cffcc951088de9dad49c8983f829b4a113db90b873937e1567b4ffdf79d373699e0af76742439e1fa4815e9afb6d276b048e95b7a0521e53f8ea293fe5d1edfc6375df1873628eaadfad1d965750a389a9580f388ad7c1b3c75d50d29eeb690593ab45d03df6c0eca9a1452d5ed6d8bddaf2e60f25d0739bb8911bd3c07986d93c5c8322cd7de37dcdf9188bfb733bd417e61947615a18899eadf6eee318296b7f2498f794f652b215eb9a0d9ff2294ef8e715c6caa03a09753510fb3369e9061fcb1b20a49db491eb237086bb12d6de6f85f148762fb841a3a14b7760fc27e0aa5471d501dcfe6640c8f8d457ea81f0f0469488c08bd3fea31e402719d58f2e360fc4f0d64fa84fac162d7ca1b6be69a7ac379030c3b28b5875bbcde1dd38c43c16e447348ca48fe68a3389e21cab579cfae75f04853d1db833382753ff9ba48a950d1575eccad7877f5b072bca4ae1d783215eec551ad1864c9624392dec06d959f2aab4f5b4e97b20375c1c39dc7db04bdf4791f08d8e0152c53e45df7a33408a3445e219b3401a5bedb3b352d5d5b71c8a1c0366991e39484b7e71d66c73f8a0d48f765e12a9ff1256900fbd5aedb5f11bf1fe0c349aba360c59f8ea080956e1d0c9687531b03867660358429d5cb9cd37d1aa0dd4f7e484d413200cdac76e5eefb7097f13acada366ab7f99fcd4e6da2e25c269ddf3871b18f50bcd453d78b5dc626c2d4c5b088b33975eae80d5998e49a91da78eb6017194daf748c64bd5ddf45a2d46ebe4473a0d36b95e598e9c1cada2cbcd2c952fbe226b45eea12c433c9ebc91030218cd03abe0612fa57396c7e155dab2f530c90df3d20b0b1b32b08396bb96e98058d138010ee2f8e63fac2ee5278d576a68f1df68d0457a9d9594467804bb6ff9b7569d63b95be2d718afb512a33134e7bcf2e5b17f98467b64cf8c0eac79bd9b4b833fd82a899b514253729b0e922b0ddd1f36a357f4268cee65d8854051c0da200ed4e7cb26b37a58eeb0040259798bf7a60a8a03113be86f41e434d0d66275f2d17dde40eae747aa49daccc31287dac740b56cd15e5103ea0861d2fec370a0f902d4097e534fc81f56efcf0ddaf53f1922622843f225197adcd60c2478db0127698e1cb99701de158776c78c819f9e8fc386ef78f9da651d6765e30cd9b1034f9ec149302713d3408b3f111068448ae7a13981aa86ab811c1bedfa20fc518dcf5e8ad2bb3cb336de7c334ffb90a3e40fa97ab35c72de24ca0a1c84610af0e7e11f0ab321fe1c399eda115613bac62de3144709ae8f838a153106263a9b87666ff61ce361804c92868f38eae74afdfb2e0e28d4ed8e71080bb45ce62ec0db4a0be836898156a786ad87b28cec7a90d7f9c255736aab6cab3c29b1a942409d53aedaf61d7ab7e87c1bc1982a7c90559479a23934bc9cacd2205f51d329aaea97a2d11de731c015b0616359757d0f977b519554dfff34c60f46dc6a2c8ff260a4065b5f8f520b7106ac3052356077ee55bad243bdf204f18bb92153fb1ed5b1cb8584ee25e44774d905a501c91f008179cdbd94ce11f1c76efbbcef7cbf85e96382fc3dd137df8b966e3eef69035ee3a5ce54f8029a6cff3effd158b81d3adaf5f94cdc347366ff207071aa1c0c9977a8b3473283c0c0ad9be1080e29aec607f363e4af38af4363f4ad8f04e90362eae1b107a015d5813704a5f81e39b2bbc3d2bd0037687ce8544b3cd886bb21ab51459460bcbcad7443b40f06af7822a5e4de8f86f264b22adea3475eb0f1c803c29196c8897d962df0e333119c1ac001988168d0ae2c04cbd573b37ff0caba2d17bc8372d3b80243eca2e31ae327e1fbac326795be71e405f2ae2c62bb2b00843682298a31660d31d4d5fad0500be3fff4e6e68519d592425b27e527b0bce8f88264d3e03a5295473ff9d949994d2bd171b78b52099a953946d16bca5fe32bf71ff00673c38b7e5f24b4c6dcdca5402d583f338c2def1f90d682c43be2d82ce5d8e50f4f739faff1602b077b4aa631500055ead12cd55c5da2b73cea9eb64e0400361bcd3f685aec280fc852195c19d115a25ab74d2811c7c1ae5631903b74c9162c137a1dcba1c38c3b7372d5df5b4864402c12af0aaadffbde5f1bd9e7a0b4f694fe8b3273f7b981de5314941a8f5d4aa71b13be357e0dd6bd109dcb4d8b874dba384620e571452d8ffcf5b2b2b31d085e28826106ea034fe46338e6b4f84bf0a8ffaa3ff4c65a364d08d24fead93d334f151a068afc82e1305a0327df7e710801d0a94db7a0c668818655e53b0ebdb395885e495e3ac118d9a1ad31f192f4f0ba3c911ac56acea8bf3c1577b685e808fbf8f943f2dc509f1d1867abbacd50bf579b3484fa36d35a272ebba07a7e2b9bd90fc8cf4e6c91d6b45b142c3e452211721c344705e5bdc3a2740e6e8d66c317028ca5891ca4bbea0d6eb37a84a1b6afdfb9c625629337b3a547b5f1639baea2a95ca66f3767d048003c0473a238ad0441b70d087f2fad6bdb8cfa4af4d564f540ebe954d1d7360136408acfad8141a835d793e1390328c8f555e44a0c4f4084559bd0a11069bdcd23b55fe859724d6e52ca27f93ad5d3f267cc9cd2e6a2cc90cae7bd28613622ec3b9a46c2d6aa10aa401705e9958446c03122026ae9acdd624eb379c8558b1cee6863b1648f2b76ed5ba2a856fd89f216735fff276684dd26e094ad184ab088eb33e314a7b5824b8257edda9bced94baee65bfda8131168fec60a459321f00b171da1b2b7860dd90ad59b0fd34f3795919ea845db0d7a5de9c38956631238fe58c4680d0a401ba249a80eaab05b385591097ac1dc70880d86f45af42ea600bc85b6f1e871a7a053a9ee2e93ec8854415a06d70b73e013d8002d550bdbe4af5bc5aa7b0949d08692385654d7c6bcf0107586edf1d905d7a5547872b3add8c859698d4395f181004ad78de7e07e623b95af8e244be98f123acc7f122b5cda2cbaf30977a5334cd24747103810c7359a3ab405ec366b3a66a1cdee751320e7a0cc8cdefb226e540c8fbe2a8d8cb4550e19a6dae3c1f5a9384ca4775f44ed7b126be1818897328afa6ed6f9a2888f23578ae4752a5a78d58857964d05b563c198afc8397836bf5f2613b2e633f8f789fa5ed60cc0a149fa1fc4ea23f5925f1d03bb18dd792f6d2947c973c3a7f5a7288ad5b808f3f152d7354db8efc64cef4aec450658ade35639584d1e411cf865363f014cdfd658e98fa43372f403874c00faeb206bf249c67e121ec251f634f948b7145218c79010fdb1a691f17285f09bac9804e358858372eec708c4d7783aa795af673f98d9b38d650f5689d9b22f0579946498b6494628b6c83967564ed2e7de64f677211ff3c6041548f61380d8abb884b350301ad8ecba20619746ea0f5f109d287b72e739a3c53021f3201fbc4d45b7240e85b95d6ea7d0e9fb0050cb5fee9ca0398d5a8b76e47f5d0210615b5f9a377e51bd3bf081143cb1d8bf2201c38c8dfb89bb5bbe446b1e3a824b45cabf5d8bb0f51bf2e362e53bc29233f650f79e381badf1d7ba79f12cf5a49698b725064b09a2461375ed56004d784d489b5d24576103cad83ff67bb9d8bc50ab51cf25dfa6c6d8592ae156b71d6f7c0861aa2c9ec211b8b8e4a1c627d2fbb7648a5e1899935397f469a9608504ce024b1924930c2d57dec8d47071b67f4d3739f959733ff738066f9742a2d8e86022b8ae72d763ca525890664b52ff0a786fae1789bb973fd245d77ade0c1bb46afcd7a03e66cf5f525412b98ee9a6ca204d08046b1d573fb869e63351d7d2f700e855095a307502e4a77fa483e36666ad3d53406e4be1efdd3ad9ea5c54868f912ef8ed67176d2f74797b3b20f59c09c6a5a4bc0c221980509a126204f98e30e2163a5476eb873f0fa7cc6119162c284f3b635a8e00646afce0d779912da1181a2fea437dd2c4cfcb3d52fced6da7fa1a4041cf17972c4117e9f534c5b0817271a51f227208ab4e5673ac9672e7344374f56e4ac75e313b880cfa59828903d2ee1960484950555fdb369e25fa761c680736083f833ed9f3ba8cb5932f3cf45e5cd3e0750cd9b02209af7c0099c7a3fe6afac0ba6775f5a1288bb8fc870349c117616e95a7fd243f8b540a69cbb8d3f3b9c99dc3b2d1300b69735bcca9b719dde3cbd946f2b66a5d35cf994a5dbaef9f11e5493e8d23fa9aceac811d9ab4e91323d1fccc9083d47820fcc4423a8f02dacedc8616fdb29287e99c28bdc9670630a9cd7b310bb18d4759f5a03f35df61698a36327725e44daf49ec6574cb7628153ed644f15c0b1ca677652def5b9221e332c4ce1bd1af66b20195d7ee56f31a575e51bd4143b20aee8f98d951b2c74fd17f24e626b67f73b4611942e81c988225412d31ae7cab8cf944d829d2d7c499e326222bdacf42b90937577d262c42c9221c5131be1c9e37f3ff1d9df5250ddbbbed27ff51d77c939823c4ffd5fb30117a4df0d9a6eb303e4d838f21ab35dc57faa8e133588f116a01f8b55640ba5b617cabff60f758190d37bbbad9bae97e06d744b480bbf52b9245602649515337812e08cc0cca9b6e3ecfbd20263d259df5159daddd6f3ebd6a6a290cec385be49cb8b0157b2e6e91b3f43fe36e6e60d984c584f97f40e41187fc33d8fb47e9af8deb2297540eec5a33cefd0f3169a994e16536c31e948f1b26d3cbacaa17a1baca1bb0e435e242d829d5bd3214315973feaedf2d0b90620f555a15060090342ef0c772659dc67e0956b4a3a3e378ac1e153f1a509b843a68f6beb245b19552764fcfd18895b3934611ba82dc85fceade5c71b3675252b5ed1a760a8513f03c43786f2d5f5c418e87bd322e818a5af6c576763f7bec2a383be442301de982e9dad31e8a629091a40f5bffec4fb7be4a10ca4a414a867fbbd6d754e959aa0e410adc4c82776b48fb149df66f3fc6bf6e86f8067d1887a84a520335445aa59ba6f9a99b01c17389a5b69e13c134ff0fd9075cda01a4ba932dd1be9ec7e46d43e317070a935caae980ac780d28d9c94f6a16a0b686853499b375d42880db9643fbad9d452776f0febeaea5b7b5ccfd66e5fbc64d63a6a93e6cef18ff3bcbf836a1c921af96b24d9bf75611f6505d562da1c229d2d3d7d123dc083d6b736066c90bf42b9017beb3d2b70e3e070957574832ca3ae4dabaed7a8f6d56976b58e4124c0e1f21ef32cb9b5d0598361b91663ee7271ea6d84eb026fe133c3a8cdac056bdfb851f13e6a5c79dc811bc4172cac06d297bd4e81b9df08e276e267d3186d097c6d3a2473f7311705aeaa9ee45e15225e7c889222f25d8bbff68fa9742b0059781a2c5cfc319b24a9362089762e1ac90393b8a75bb73faebec20b3327631c8570ac195249f167c3581622b290e1b01c865a9052b88b8a85d7f030d2711be148139b7981a12ea3f6eb9ec43299df2d303e0cc2b758823c52b4a6ee4f69bbbd418a70d86a74c901546cd775b0058ad694f28957544e44b5a42892a0a0c76ed72a9d6935dcc67726d203c3b3e7565dfce7088a34fa9cbc5853159a15ddc66cac92eb573c7f8722741c95866446ae410e476196503fb251df6148c7020521a902ec292db8f3112fb398ff21c3952f9d98b836ff08ccb4f7e66678ea941e9e6a43a6eb23a357c266e6c46dfe400043761ebb7c28911e820ed55daace30968316d4734ae047a96ec4abf3977aebd23734551f0f16dc16c6a75f90d8831e5f1ee72698851c73fbc1cd0108014b179e1c9f58a3cacfb0198ca33c4ef47f5b920e7d4604faf3db7409c7938b61ce188f01b3323c6040b5c8092b5e18c5845952b64295db468adfcff214a62c7d479c7714dc0d298626f377f9f8d5f555983ac4a39a85da952a785b1a1e3a1a493d17f815376ef59ea7f444016d953c2d25f8c25ed5904c114b8e00e284b1d61c678944d5d366f10cb8122fd","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
