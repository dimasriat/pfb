<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c822e98c33f3e9b6d148474b95fc9d07c3d7dd27e7cc4647da52ca9ff4df3961912a44673a95f5554f2d1965665ca699c8c37316efe40f49618b126771934ff54421e4a49cf3bdbcc44df935c6df88150ccf3340fbb952c521c8c35ad9ed5a9f0a0d9f6fb249cb453278fdb117ee2bc7fcfb9dc6c709ccc5589ddab8f2c93ab853b13857aae2fd16cc7558026e6327f03479bbefa688b4d0729961ba57906abd3eb3dcdf040af60abda1651ed0a0c400d1237c1aa7c6c637e9b44c943619b338b0f72baa168731d3a388e8db3759396ee870776cccd648d165d6c57e264514fd2b6917c5b4492bd3a4f26ece28185f91feed6fc1670b4662f5920aeea5f922a7de03c255443e98335c083e92b7cbdee10e0c2d218b599ecbc1b0cba0b9a04a58cd44a824206f11e109119f6c8eec65e18b2fcbc30d2b0d0d9ec2b21e82ff7e182b6141b040229a39e146fb8dbb1457c6b97172330d3cf414a648d42e8abb4ddc39fb5e82a5753d38f06e398c441b641091cbdf5a6979d6a30b2504f30766b266798e908f454fa1e27a2acbece1d9ddb2057b1e54dc6999f1b3abca25f2ca5bdbd644567ed5992df35c9f765d4079b1bbda7430443b7781c6e5b8297859be042a033ce26c2e80681260da66ee45daee3df4130b1eb9039b4910b1d60eae1e071d77be3cab1836ee89a5272a31ed1885338c8bca2a3c62569f7b7c18681a8e9b8574b37a055b058df7d723b8e41093eaa7307b878da7a587b158d48e263554780143b9a1b5fa94c5eeb6ed37e108f3b227d5ac42a2ba1524fbcefa0e05d0f897af00132a1b61bdff94fe931eb3cbf757b0ddb19254a71c5b8cd7fc99efd6a285ac5672f33cbad438783695c048a4921e1ce4df61b7164ad342759c3ffec633f6ee59c8dd9ec15c65a76feb3f1d1e2aa0168ce31adbc197a4f6d2e3f0c4a47dc2fb37082825d4aa063744be653943c71d012b37ae59bcd711339e435cfab0ee2e0c96e70fb34abd3aefd5cf9415034d3030ff65cdfa4baca68e4f4210fca6675290252b08f0407880eace869bb24b671ddddd56a84a9cc8fc98385e39d270f96adc9ce4b142f51683ab5bd504d2f9ac2e1bec88787506f4b4d5232bddbaef4881a92d4f2dd568e540bce561fed5d62badbd6605b73bf51570d8c2b647d18dd229b1d36098c023d444f647a109711106303adc8f3d3e3ebb636474c6fde94103a7be294d23d14b8132c1fd0f3c5dd297fcba0684d2aea7cece542c8ba483a0ac90fce2369be609d9871e9ae0a727746900a0294afbd7374895c5c2904eda9e7701ab003b431fd0f2a69a707ff2098b8d9bc4e87eb856ab3ce750f00b7d3c762a88407f2791741b59eb53abdea306e5866ce4d4199db28ecb698ee69757c61c6f29e96c3516b1f669286949f2fa84937fd54f57b1b7f8fd8cdf0d2e84a4c97f5e9508e56b06adb858900123e8110a919755312d01ea6da57353e335f6415145fb77a46636119d65c6ca8aefbaf2e23b07474e44b603bdc0d830ffafc0cb60f1d4d007e942f62a0c8852354dd5d7c313be9b71769e6ab91e8bfdb256a10e87e22e2a9940bb2acc4764f1522a633a1651fc0907406aa9f2b5f9a3263ea1cec65074a258746ffbfd342dd9f41681492711a8648a3a6178a3861bc98bba222e82fb1cfd2533e0a3c8662e7efa2092f55618e63e6af53d1e5ca54edd056b2dcd343afda455494a296db86ac3973e30589a9896a453c4d4ad334f6104c4d16cc4c059d91067b15ea7007ad2fc0aa2eba46b78d656ff9b101c831d8cc1522a505f6821a29f0c480907b5fa7cb3390eec90b59636a00832b34c842260af319db2944fe68a3b5bdc93dc5a165c1db64a6f8437dd0b6203f942ed4b2255d83c8296f89d2dec3ef61cb64ffddd6568543123de3ea2d5ac4c0a0936cc367847ea10a2c04622b341fabecd7635f9d5e87612bbb021343e33dc5f56b6d7203c744bf29e9f34c0fd7ef1e933874c8acfb0ae298f8b7ef66340d7fbceaae9b195ed3ce60fcd195f94078ad6900970628fa6ed2d81a2e631075e57af3e8ea8259453563ec6e73b2315f4bb4ab54855a2085b220c4dcf2224d4379b9c717817159ada0989086a59108834bff543ce9d5840e4a722ccdab9f3a85e842f25c1fb168dc2e8a5eae93f5db18b09f2a7668463515f615a41398adf4447db7a48ac9107671125b764f6479d3133a79e44b35816d6c4cf15d7a3dc8085a93ba62596c41e2cc7ce7a02bd3ac67d7d837245faaf358a426cdead7835295c1cf67e3720e7454839fbd3b7ddcd2af89f64564066bd923e130a56781d542e43740f87e6b7fe887e693ce94010c5d8593ba2ae92dcf12a8be16aba7cd7a950b6ae40e0adecadedde55f3d836546dc595e8e72586d5b253ae226b291ed6b7d80ff07709b1e001bf15a990d61fb190cc001f1769ba684945100e9fb380924e22aaeb07080002af6d4560b9b6937d8c8b3cf2669464c60baf3f1389b81d77bc1c4295a8d9dfa22f1fb938f0477b5d5252269792b399a1b6a0b9c1333952817f27b50caf767d7d36f77740fdcf431be269a3cb51c91d9e54783dd460259aed4f454c316f3d2bc2fdbd539b0fda127006a9063ec38620684dd2280cce0f98404b9e17e89a5b327e4a5aa842837e3fa6b6c2f1d295b6bc8dc21739a47cdda2a7cf6b33dc163e0c9a5be1a75bbbe43aec5f7495eeca85ca0e7e632e5d46780d623b3c76c172d384762749d3bb6aeb73bfb5bddfbfeada799ef5a184a85cd8835cbbe3deb08f887017f9c9099220bf61b2558dbeccc1ca0d108c1e89a230d73cc4467ed05723f0c87e12947e6cf87ddde24b8e6051ff3af1d4f42c2e2f9469dca0130a1b0e3f9dc468a47f305c7a0b16888d04cb5dc06b235c14992f256340822439e0693ec47a4a1d5324ef56335491fa2ba4ffb18300e81ba187e55b2dce14d3757f0f619f3ad0088312626665f1f52922d10961837594607b8dfa406b36faf1f4b4b845c79eca2142947f53077d596c7d920192934abb027375097a0e0d60a2aefa770600005bb62c5bb3ffabf420e120390b271238086e132517b2f33e8351ae8df4075ae0235ec6115df6a7f79f61b4e8998e4aeaee8e2a3e9230ad0abcb4edaf02702fc44c4032f6d200f22e469c91545b9e7ff415dfa39d76eca032571863e45f933adc3352c3f0ab9ed78e502ad555c88e19c305392c13464f7caf9dbd2ed3a7550a5ef22b877875040531ea63f3acf8b7451c58bb82d6e787cde64affbf44c111f5c1540273c44c49ebad144eafa1065d2d37037715fc65ce673df8600b6393dc466d2a8d5ea7a2efa70f1ffd170e4fef4930109cce93ab7f8233306ceec92ccbecce6e9f44d1e3ea77012bd501e6110372188a6541f766341c5f1732af7616345ff59a8b8f3c704673318f6baf8dcd3945dd6969dd2358a7f1a49c67a3e61ace8429ab727da3397525af9cc9a1b849764e86cd92c367f4abae478b758bb8bfe667d1a28a7d4243542b074690abf3d6aea5ee43f1185f79d3d94e86695b59140bb5662fa3c8051b771a7d075deac12a433ae04b98c7c7c1d128c9ff3bc64d3615b82c0153a3c106fb39b6232d5604c395186b6b5975494844d7cf6c0de96f73a6d8a567e562fd887c57e72d556c45b369ed30e3e1aaaeb70f7f32382ca7b8ddf8e2b1a12cca38c173dcca55db956c026f0aa213c380d15e5dd2ff008fb778a9d299d0492ba5ddfd96d05ac58d81c5a2189130290ed8bc68caf082cc8ece81bf2cf7d1aa3d6ad88e6da5c67a5fc0de1644ed6d11c2ef9c40498c050f0c14490d28226a479271e2ef1b920e0aac8e5a346d0343f149157c6490f58bfddf5b5de393958d516df3fd4f345bb13da5d581857d9fee5c0c39589beaa56193f49de4d657009382c2629d79fa397ea2f9a1f4be1bf2522c400d179cdac501f7d50780303e2896f1409ae07f75ac5bcb2ed93373c6bd60bcc284eb0295f7d0ed85a829fa23e62bea86efdb6b0e7ea854c3b5762109a178bd0e1c33de7d930cb30989764a5fcd8a9aac006e5d166ca06bd59bb03408e385337d81a3e0adc5456e7c380484b5964bb1700638e2f79b0bb6c8ba9b8cf2daf59b32f93f18214ec69db6f5f93159d71d9d2971a7788d032fbb5b38ba4c391ca7dc018c2b926cf061335edb938b7af7fbc4d7b8c3cebbb4677933c5219778713a2f4ecbc182ff788bc147b36e989ff8f0493741a634802040e90cb00891ea9240af148cd3da46ab8d24cc6692d902a45d44bbdc9a1baf4b356134ca0bb44732183cbb7fb2a63fa53b8d3d8782330bf909e198aab3aa6335db500f56765cb8d2d3f5815b810a789c1a49621ee40adf92d1047d687e980c34f73463045f371ee7f42a52b7fcbe4febac67a9989740b622d423a64d191174e11b64bf15e298da7cc050e904630e214b080848ed75f32e64abb88f17993bbf446345a7c609c49adf712e2aede1053b03e2b2dfc182effb293a1d6c9f7bc33bd8de684f4bb3631af0bbd7dd5886f857c3307dad7cf6cddd3a692acc07a7647bf1ae240852a08e2807a8898d2f06aeedf97bd07c366a4947e0995ffc59f300fc59388b097ebc045696d9f9dd69efff964bb84be543851d02e341f10e64246e1fbec54927c0c592c226681884d46656d0cd343043d072351aed673743d818bb1940003c07019139691a21a2263837900f9644d3d5d184e713dd10029c352a64eb5df96a7a10218ec9d7f658f453ac7456e1c35251eb247924315a2b2b46e4d38e4561fb675a8796706c1b508c9178b0aaf498dfe9891b0a02771ea83b6d00b05277efff09ee3917ad8b8a4073bd5612a90e91b0973fe7b78936fa954319dcce40c4532f1497f98fd3f98dd5dba87604befabf11c7ec761304d4b8b65e49276ec6a9bfe2e3b17113d496a8355e7011748d9cdb453fbb3dc83049e111f65d18a89ddc67f090f588d5578747baa76fd485a9e9ae4f774e72fc198c16d9a4de9f3abb26486fd96928ba7efc4960d23687a1359e7a5d7a470cb41ec826fa5cda5fd4a95e2af02c2bbf6f1cf83bd368882963d3604a19367211245910fb35c5aa34680c2b77aa4b37065b76577d64d31400d1eb10764939d75575170c072a1b9889963781411bf5b8fa70fb5b1f07bc7c78821d84c24023219d983dd58cd136bb2f59c07b98d165bb6c65e75c67ab261094abd0d93cc7ebe234ee42ccf0cfe74224a994a1a3ee10edda47a76d5ccd0d53328ad65e21fad101afe652ce5f8ce789661ddb59caaf83a60216de5190f89d1a456c83dc4a9b0fcb960699c3c11a50881a5d95905ddb9ddf8852d1113a0a3017bca864c558ca6de02bb2d08b72a9bf121912fe309c4a991e6eac6003fe533ed333ed2cfd5c5dfc2a10580ef11bc1b797e735e47c176e1d3cb7a26f911ef52ca96eb7e5bfe525f7f1f937ddf7b79e458c2e4b5193e17ff63177590807db10fb83ad024b8a69e26c0a3ad2a61136eb85270602f042e59aaa20cbc9f613e728932d2fb2b2aa9d1b03d864a020bd2a0f3823da339d0c99a4035dcc59f9e3e897e3731c3de7bdc9440fc249ce53a9f211e5f8974b46f835411f1ca3b7015375d8a9b013423a9022236d6d07018da11b220499c9ad80b18f31ad19a53446b7df9a61f1223487de67733973ba7f15c29e83c2bf188a0e3ecc616529d394bc40020c28c3cca72a72f3cddac568f5a7657020a6ae6284a339624f6edaa37ba0b170cba8aba7353cd9bfef49d7d1ecfa3f6d67eda37c630806b68a2f307c5dbe8ae1cf9d7835f27176b6da9e3c73f42e1a0668d2671b66d01379d11fa626d6504dfca308f323a4cadc70f923407f341c885ea347d5da65c9695b984b4578782ff18bcd4227066273337d29b791daed3942bb51311fb6b35e61c476bd1d6730b04221a7e58486bbb3f82f44523bbb5b67e7a9d2c04424943b3f2ca35746acc615d88c2e70ee10c9edb1ef9ecd87c6e8e73191448d31d2c9644356f43f387f566d3d0ce0a57c2030fb5d02f734e4810dfab9900669c26fa6fcfaaab4b414714ab46c4e67d6716a9e3411d51d9a996d0db92ad22ab24e3e052fa8129a459a369074713aa2fc34234725a6ba779c90c3258b8267a010c8efbe96075699d2df9cc0b018ba68e7465dce4cc7c1055900ef8d656edce7a46dcf4d9fbcad4d0f523c870d81e82e66f50f09a0407af3aea286fc95e0d1efa2fc2bd34832cb6444b7b187d71d8363e9d5dc3bb89c9c179e849a986ea755a9cdb9abf520f35833e7ca804d7ae78cec16d25107e7b4e501200406dd1ca41b4412f391ee575d97a4dc22a181c0a27225a790ede2ce33e965cca0e104d77e1c1e2f117ce09f4f44c28ca155db53b4e9b3c18dca2f2a58fbc5dbc803f0e9c250c3ea25138728f56093ecdd1e5f544cca76fb7959c68039bc22f43f19e73ba535abf40e44ebf05b1e820ca8a587bf38e998eb0c7c83343c216e58db749f141a2fea72f4695bb367e8260e4e44dd0491e8ca7d714cb7db660a17f27c7c417e97993be1ed6a73cc19e35180621e7b3d60632dfe472d72ed579c3ee6c775be69f0214db1712ff9da8d3a045db033c04063b00f82d85bf19053599388abc52c5c8232239190cbd4ffb1383c6f6a8f9eef7cb8550070192579328a7c46b6c43daea9fd109f6003e0ec9d0e11816df96c87046bfb1e0c784dd280020e96c4438dfd4c12d4230aff164d32f45ba0a1a7625e942894a2927c34863d9fd13b704231a917f8d9ff8c6aae3eb19ba8eaef50257103acec5b08a39b6a5e83f0f14ef079aee85960fe78d54b1c528f504661796c5f27c0879e67cd4cb7155abd2c2325d7f48a18b33fd408c87904826cf141291746b322c84ffb9e71372f019f546389367eac949cdfc416b19cbb792a02472906a806fbc0f0e072ce28e2e6d329796cbeca24602e18aab8de2d274736f696c26370c319793a5602693ff337b3f0c32395072e52c38c804e3e7870e50afa55860d3258ec10d1f37faeef4daa113b4352f637db0c2d5c0c8e80ad767cad943f005fc0306e7bb4ed10036003b957a714974f676fbe4fafad2fa85c0df7086bbc7626450fb71a7107c4962d9bed8c1969cb25ede7fc72e32eb81289f478af9f9024234ba28f97506f97c736b8053f95e2559dfba5782272b4eb0d401c0a18f9b8e5bc5331fad556f60328e650743d135a1851e41b10e664cf333a7b8d918ef9491a29fa8cd915067e0355d4ffb810e969b42a405e3432ae7840441b351ab7d2b3e61780489ab9cf14eeebeb6a83b35469751b011ef5286df588c014b28e49e199835a9f94f0cefd1d798e330ad1f1014171711155cc6b1870670af7639526b15425b7b309d8045503c684fa668021a682638a9f87949fa02a4183872b266e7d5797d7abc8e8c2b56474e000ec507f82adb200cab83c1f21511027608e37a250b4915e9798af8736af15f11feaa1da4e780b296d4551cb75332e7326734847a8d08acb5773599afd7848a56914d6b495d039fb6c709687b5c8ef3fb4279a26672336e94d1b899e8a3df69157d820aabe7866fe51d564b392ada3be5ada3a530a4ec7138f55f9e26a4c7865a8a09925a208d258a00f4e6463a71392367ff0e05152f0251b08ba76de4689d37d1b2f7b809bedd8ff737fa0222b637516473b4505606193eb5f9ce802ff0ef221c77dee87d17cdd58e4c8965347ab7a7e4959f5ccc5b5d716e4e5a780abac7acefb5432f3dafa45779655410cd133baccd7a56b8e40263af1aea660dae513dcecfcc7cd128e5fe1e1077d299b2c33a40ac9952d1da6117144eefe6674703a8e08f09e6391de0940de22198f86cafff1367116fd52550aeccf335cab4c36013000269c192cd5a4be507c5d8b1b46677224c9f7cfa60fb7bb1fcfeac4cd60fc8551d7e255076507af2f29039694d4a888f0bab30a13778019a57073c210d1b5451cab20bb56e1c30e45c6cb2ddfc5a933b0f7846825f31163636a44fdea7a97b8f096cdbdd1ec1581fe7d7896843e3740213cbf11489b0fa67ec12ae5c6d750cfff0d9df3ce0ff2bdd281d57d66eef5f05ad4639fd19560e54aa591cf29ebf3b85b4b798e7677caa4b578ac7d33b7cfe207c6a9bd19bf178f2466b929aed57824356127c1baa752eeaf2e0a9018ac456cc3ef34f9c00a1b0333388c6716c18849abed02c88be63d6980440813740b897da9d4842064d876432e30815194531c05b1a5bc006901e633e91d5173a751d393864fe5e85d9e13a1c3a62a05faa718b33844854b5dfd602364dffcbada200355bfbd35b4277402fec98530cb55ae46c0e2841238da97ff25f1ec2de37a8ebe473484827c9f3c2fc84c4c1f447dbfff50ea63609414a1d3e73ae04ab7e37818c3f977285f6e5e2e0c1359c4402e5d9230bc7cd9d6a9910367211fd15db682acd6ab924c2cfa0d170722faca861d3228725b158f4fb2c2bcd73d2cf5f66e7b26588fef2452a33090d521b2eef5cf835c5a98714023d9c941794c3f09d476e6e9e61bb050c1d7050303e100badc0222a6cb5d588240e0176dc5566f9bf0ae6c67cabf88233fac38662e8923fc2ea0f1fc6adc7c017a51aa27926ccb47b7f54516c314d4c158c065f73f5c0c823d32eecc94cd2dad1e7dcb565d74b3801c0b1e827d7e6c7ab77332aea007ab2ef48ed81f98b3fcec7ccddfb447ab8d2c41802ad7bf0e6cb1a7a773cf464fa80507cc107c0cc96c274d1add563f6a08649ce0a0148b3bf5acf1fec83c226db84fd2a7b5426bb7e5998408315962b14091ff5284f6a192a788aeeb451120ed46d553bdf2405a84e94da573b895c28982e7d38a2796e14e512ecb29d00a34dd3b757e5d130bc2a53662b79d4a37cbf6b6064c86108f203241ebb248cab41b52c446290d55df2efc6fd28f5dfbd874f1b4ca6faa18160f18efc3ce680f81f28e1a3d1815df51b31748b6ac5825c79dbb8d195f64f590a4a3441b083ee36f36973ccc2c401d3f6aa0eef1a7f77f72f1d7f26fd518cbef7dd2f1b48c12ed2399301efea88aa19bbb18cca25539d445ff05e1d02089bb99d80b50fb661e375d3281fc855d51a03dafb58a61c72dbce3853ad93cb22c69fceb97690727d48faeb8d204b3bd5b165d89bc205d424d08fff268da28cc26fde5e395822bd67136d1c1ac702453995066fc7fc4555c62d7130b8d38bc59411528d8835af300c66bfce3e15960617658ce9b691c9499db07979575adff4741019d8584eeadbdbabc140ccd1318689692ea2b3430d528e2735eb23164a57e75a8de92beb9caa49adafc9d298747cc61082f8d9b3e3552203c1e9d1a31692fa7820a50fb8c1375e5cb34f4dc704c47a7427d9fc3e621658fb92f2069912662aeabb6f3b51c509f2cc7b4a1323d3ec984d93e12e1c6e6229fb318deae1b2b543a7b7c0a03a914d140635aab2d3116e6642dbd388f4081babba7bc282f0c66538b0cce1ce18925ac55ef1d39c3df462ff8c5886c46bcf1f2cb1e53bec3a06d0efe9f8ef8a18e6bbab80bde857598a7a6047b9b038b58ef35a4e8c7e10344ccdb8a0fb09715c84c661bba42662bc60e9c70dd72decb4aa4f0229cf9228bb5a89f214121f0d3ed45fff3b8544a8a2add55940d7b98b2766eb0f20c73e7384d225e316a747f02ac8a8dcde0d989282c0ff9f62d6ff1ca676e69f2a8dafe7fabe9093ca2a5ff05ec42d3d4ac3386cab2b224234950f1706932799ba735f67c766535c838b5aaa6767194b61c3405bcb473cef9a60176dce2d9e1e1e999fd72dbd8a0f9e3ca3a9da085c2c6bb7171c4b65e826e30612d47341e7b0195a4d47d67422a9e2546850773e61998165d78f0e87c2ccde6d59fc6bf1b7f4b3f9f9bbd08698843a80d1dbf22fad4b5584f903592257f06f2e6f3d217c6769b0fdb8f5e755333603af3e77e51ab34ae8149b2d8bcb70cee966fffb37c4ab31a07df7c8fce0ff27b217e924b5da3b3d15dcf28069c3f8d407e9d37ab003de6f99e67f0379e8eebad0007666e253ab09191f1d7bc4c0b0c6391f6c0b1d04eb335fc12aaf6da18191750b30b6cbf14102bd5b94f7fa01743ba2ea6a0e4a9fd514f0575be313497d2f3566eff46a49b01dc7144f240f7dfae668f59aad795bc36e3fbfc4da4f28f31e2d39c439e5335404e42ff86febd029f6a745311fbe817510b7d79581bf9b6ff5d1053004b1e94ff28e1ab7b3dca7af610750b5a677e36e03e81fbf54754cd680c751419ba43f7566e4b1b4a48cb7fd4761033e5c43331d752d8c0d6136e2892bfd5b56637936fa47cd918e780c0b3396f743b48848ef79dcaa8ea4d0bb3e364b691563696a9065f6dc78e6048fec8696881ff2b4784961ab0e0f660254cbe000406dbe1a194ae205f8dd6828720cdea09213616d6b8acd8461deef320abd34db09a02d50df5a60b2b5dc12e93c1f1d640b82fecc05108020e451ed94bd3f3dfefc5f23851ab5aede0be1f3cfc88ca05b3ebc9e26d53c15399b78052bd1f845f14e17a6fc673e94e81009607de55d5f3d292f7ecd01c3ee78edc88a13a062c69fb42399adabbb0f37c12edefa95781c30ba215bab31cfb18d2947b1c7c886ae6010f1f3e47309da923acd4b36f80af46a9e362d2cca623be0c254c0faf6ea37c3a45830cd402f7e3aeecb778ec0b9d45f690826938679c7607ac87d3fe1b272df96f61d572e8e4ecc190a612cc5ffce1dbc15a502f4aa95bc0c193d979ba5f39e3b2d28a029dd84a2a3384f1eaa347a3cba1c3c7e246cf4af046355936e94b5c8cec09ab7784a8f0b10023371bed6ee700682392ed424ae19cba3edf5d6f8ea504661ff1591d2115a9d67d7a8571cb08d72b5d768ae99f496c1baf3f400f0a3d3d384dee5e703cb6f1e241c080969a73ae87d574cb0bdf14f13a41e2103f1d774cc4a9c85b439bab9fde44d38f498df85150af0cc7a3fda6f95756fa8b139adbf55509ad839ec90fde151d5deb7d48faff3e041d1ae9cd92e0c26d9a6d2074b3af52242a8c0e6c0d2711d49df3bebdd7cbcac6487e40df04635dad71ac63066715466f484d47d5774a75ba11dd4aea5a32491693d9a1ac317a69d5c193fa61c6481e772128615a6b0dd299db8b13bc06b573112d1177be14ed236743a3f72f2f3b68c75ecbd012842f3769daa012fa2d6ab1eb85f183f3b9e401d55b796177b0ff8a64f319b7e296451a27a5159519822e25479424e3a5d0b9eb55819f971bfea8dd96ef862de613bfad78658aa3b51a516310fbf40b5f11436a55da255ea7e0b096f76cebd25c771eafa688bc5c11917606664e6af722552d74a81320fa1a707d4ff7b73a3135a1b0eefa322da60e5a7ba505a0519595e3047799657a0abdbeb430b747337cd653ffee643f37cbbbf7f9dffcc1fae358e87c454f2d6a23d8dcdfee41ad1490fb9e4ca628811f26c95224fcd1312b4c4c6d9dd534d631acae32b77fada8b59e4a0a588a8d0f03ef7dab276fc5752152e03c00731a91c09dfe608948b7b4319280d4387eccb45fcb5adb789ca8c29410b155e6303ef9ea89f668cc3ad44ab1bdb06e0e0ced318b9d717bc560101387709e0cac13ae6cda416c1e51d76bcddd705d4a3030aeef5db4cd168fe7ef09c09a2cb2b5ea4222b36c4d191346e57d018c2ba8f44a0c30cc74960e5071b10144a25077864cca62daa06fdf392277a94a673f248a4287e738ce749617e1f15044f1b57c844b55ec2b5736e2101f9d4660edff7f1cbda11d4fb85d83210985fac0e125428e79b499835868580e80beacc0016e4ac6760ed8bc5887993b203c7e26095c203aa4013d515fa2dffd1340545018f6b86c5749451df30110c8f102676aa97ae16f7a22c3594b55ab239f3fcc16009d02e709b1eabbe57b411a5062d865c60870ac38b4ab633c800e6222a0b9aa2419b8d82dc623b8e321ba5eb7c7480d3231d2b96c91e4db287ac111145ba5369f988bf1492532c5a263c05b271ba0dbfaa2866ca443c7a578514d0079cbbf92d897655a23dacc939436699a86c8533a78a8226707d73d0cd39e743fd53b3453fb46c74badcdf070fb05bc9ddcca11647e5f1ef08e97cd0160d7ea97ad9137869ece8ffd8ca6c56c62d2e173b07560b4488d6891f905f48d2587d3f6bbe0c680e4bf7af2ccb852be3eb1d3cd78122f5bc139dbd31a298dfe30497e8ab93d061c798f5c6d967b8602dc559ceffbac5ed447d4cb384628d850d2e6a465223c4e6ff65504748fa79889bf2acbac764730d0406e5a5241f8db75e03c94e1ce234b99d4ab4edff5f1193e71a3fbf383c69e25fc6dc40722132ac588f3c8500288c94c0880d29647cacd55dfa56b00cc68ce045149ddc1269cbe96d8819000d3a1c93c824e69aef0d726b659011e27e594014af3990b71d1e042b0a093a8eb3e1b5d792919ca96311293da52f24b773fa9ec64e1e4ea57c88b5fe5983532c250ad359fadb295235b8b30a2e006c0cd56717ab2c1d5d4ae29ceee300f0bd0212ab5c6047778b8e1e528ab86a2cc40aae553e25e09af40e8df2facb692ddd79aeda38560c0f94c0fb65093032d18a6ebc50ba030b9a9ec5e5fefb756035aecf938741d6b8098c950e226f9da0732afbb4118207130f28765adee10deaf07074c100b6b14365312f5494ae1da1de73ec51f7af3de4d6c755a06d5f700d4039f00404f5c1ed45273a89c743084e00c0dfd9b93cb2b9381914fb33e20496c5619b2bda54ae24dd95cdad45a14476a9dcd36cdcfc7d5e49406675670630c111991dee4a6a54317d5e169932b104b66cb78ecabdb27f413e08bfeb271f261de1d2fbde55f4af36c6876bf81f82b0a9ad49b6128e7af4e11d656fba83402581b1a681d5625473b58bf01ff5055b5843612cf352089586f090c3d472a6d3bd9d10a9fd30d94ab148a4e0f05e670104539cdc509fa711f6412d1efdbaebddd145ece157ea91ed1749f8f1a54e58c863852d244d534bec323ce709023bd17487966a65387dae5f9e27d5d98d04946d1cc6e689484f6bddeaec0ad78164414a4d9a26901051107f692711ca068bc24ac1b202dadca1835b87fc8ed69b163bf5a5ff5eaef3a4d28ae309d9bf66ad9328969880b9decf63f6b635f3d3a9dd9acb5ce019820f7a7e4703fdb123f6430f252c9658686842b94542733e27d8bac5c47b87bb219d23189626cb8226c3c5041dcda6bfa8c02298501ebec8942143681a318a2f173869907ae47116a7d0f78301def30cda053f6a2e1a573b6a34d104203cabab66fc1b625111f1fa932cd20247358cca55b80e9d193b0f8ea576575c5b63bd38fa8adfb5a104fb1551f98b08c2266bc188035ec95128e7f82e6bad6fe9546d0852f6d5e3f7baf4bf0360fc1f88a59a1","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
