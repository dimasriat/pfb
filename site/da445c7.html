<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"261b7265cc7f04d5bbcd4d9f88ad1270d7be150a323a573da5138c70cba8d8cb68997851975b6fc7378b68eb28fb00de7942ff51296a7f7d4058566a415cc6fb14c1e52e78c93a696c46e8e95a7d691e1cd5809742ac3b7a0cdf98b5128bc3ebebb0543ae5ef7a56b01df6bebd952453c3302ba328e9a8645980b43f827d5bfb18273c542fb28a196a39f28d3e6806cd5f1609504b548d59924bf99c10884a125f5c6787954ed3c6d32bfd51d48395a3ff7a23cbab2228e81b5e0e391e996d6141442142c3402cda6dd7270db3be4c563056554ccbf3b3bc88f774d20be6cc9ebd22faaedbce506f006762273cbba1232f93e5d2261c6055dacf8d23a96dd43d89f38025c0d2bab00b86e1c17ea45f9d3da195e1d44e14533e339328a361cd45f9372f94caeba3fa11d130dc16ec8819ebb650574fbf2865fb3f49c3ccfdfd2192019666026356b62646789f49c935de8f083eed4646679e532ecdd7b3141fb1e711bb2552f8a35fcd48bd6f698f0a14705ccc4752cbdd4cdafebd2f415b3897fdafe002012cfa467738226c410bf5b9951f2fd545bec6af4f4e58b0e22ddab582d8c8faa761f6c9405fa2f04100e715cf1abe2e2a9a66e14148d3cc79b357e2e3bbebc1f79fd927ac531ce2d9394201c3b2aecdf5e1735282f78b5fbdfefd88e89f974544ac9fb4061d987b00be58dbf34d9120827f3da60fe3a06cc5fbb9366ff28637e6629ca413e4a515cb26fbbfc4723004976c3396f85a6775e20e95e4209a8eeee5c005bd273b863cf60cc7ef794593dae9ea04ce8b5904b11c31a0d665b4ef4bb491536dee1ea1f64e143a4c4f8c9a5ac7e2901ecc73e022d36ef085bf697bb754b40140fb075b44d72f7945811d6cea5d000d81fb56f63422d483b94bad258d99f10200e1ac749647e4075090e9284dedb14dc29dd078307bd546843db3614fda302df2e8b11516ffd2beaa5f0bf1c33013c3ec8dc5c1ac212d05999b2cb1354784d5a0f7664c30d4c0f5b2f02c85499ca5c7471b109b41be77b3f0b244d2857e270bb0b559c83ba4c12f8105de10a803ff10f312828a9ffae2ac86ca008a1bb4fca1c6890406e5ad40e4dc1817572d7e8760679df0045a8c810d5404b00252ecc2cea6933395fba5c0ae37a2c721601fb28e3a38f362e40c6371d82495bce46772bc6feefd96799147434e227785975ccdfe1d8973fc2700146f576c20baf73762b758e60cdc4971a9850bb143a9ff6105b9ed1e6aa612033f9b60b300d3d6d1db068abb97025ec1be57cfb4e4e916ec815f66f293668f2a7de0978d2a6b51e4a2b71b760e5e6300a3b143b7efb751e7a062677b906e83da3cbd58eef6116adaafdbdc1281217a9a8c81995a7de920feefeffcb96342f0f290e483b77595874120b9acae840f25783a7ddd7f880974ce64f01e9ede757056e202364b3d404dbe17bb98dd05c4147869398f8f6419364210ae1575838396b8afbccad9f4ac9489925607ed2439a69083fee361f43be26f2753b5bd3e82d52bf665eaa271bec5c4ed7876ff558377697b817a23148a567aa3c37b9784ca5a17bce050bddc35c2fe929937162903046f9bd13e051296588c2ba4388153fc931b727bc1fe8f6b2427ab54834270a5f57d5d0c4898f488872278f84c686bdb2efde5dbf2a3c2896d918be7186d45c0878bfc6adcdc9b95b346067c31907b05132602e52d972eb82581d3d993ea9bd45911f5c7e074f80742ca532f4471d7a333326f29c449ecbe92138145610deffa6cb70cdf0d987e6f91ae15d2c760a9a11735e3190ee4cb14308afa936c7d096e6c8bd1b5a400ae8cf9de28e6cb0c31edbf7d1494bf2e7c31d45136775c65c7830f7a92c6c3e5f3a188a3db3db803bdb0c7b39e5a6142d4aa93d5bcbd439aa7aa3a6058cb8f13f7339e022d8f12296930b733c21de2414d14f4ddda2afd048ab7059dda9b46d1e36eeecfb2196849871ce9ef4e9d864c08714be9850d744bcf3e79fff45e4488eb1d9b8540c036e9af026c8a52731459a1ce80158925f9ecfcb3f300027b30cf680fb8c41bf72029a57b428d5774585a782076082044bff51817f584e5ff08d90e0eabc40873e5f70572f5d2ffcd8bcc93d5afb070ce8bbc069549a51e55e93d0aa69ddcea06a9d061313b596420ab3d269ab0cc92e28bfe153024b4aa67d3d2d191f1d25df4146940e505f386462f03dd3e4b4fb46a873a03ef25b8aa8ecb4d1c6fd47be7eb47fc168282e330f5d6bf7eddf0c7e6d769d0dd6678540a9505e2f05718857dbefd52725ac9b7b47f6106f0b78c2169b355aa1ff0baee8482d9c5fd5e480d32f1c7e44d5fc3ddd359d8173d79860398d9825c81b36d895dcb2688ab4a970fddb6273b7f5b7e3e464ba08190bdd22fd523d2c2be4742316427c5b8e18d88bf10b3e375bef486ccd71c420f1b2aa1d9d99222f4d984940f2f45dacdb285d0d5b0781f86fb98f7466c431b3b6e32c9ffe93a23bf03ea4948389599be8b47d5ccd7b8e1bc49ac22dcbfd5ef728f22d2830f84307a29370033d42616595c8dd636eb142678636d4a26bb20a8f2e235ef0ce3cf3dcd13b0533534e1fec415df2f3433b81d31167d25da52c8e4c8aa20407c96862ba64f81793980f132a1842e6eb50f629c34c7419c4713fcd474ae80773b38a2eccd8558eaca63c1bd88cbeacb736563da846e29e181512895ee2c9ba0e022a21ac8934912459ea7a32812c5b3880cfc283b2ae140da3fe8ea61ed69d21620e6b3200d5941433ff0c07336b6068effe9843b836384302c01244501b9ff81fda8a1a990e582a08ee5d4ed804aba9840b82b178171e574af7b1c019b680ee1615a4a9c905291f9073df50b8a2eb87ce7a4485eecd2f1a7f488c5d4d809842dd4c8a1b4fa4d7b9559314485d524ec09cd60b447883f3d0796510233a2ce71ca34cebe260e025a4f51109a3958ae160c82d1c3896b4fcaf8e26c00e1dd4eb63e9c05126e5253d0ee57c94d7997dd3a517137a2f77c39bcf014a8ef811e345f98393f167d27db9625a87753aace5892a87d3b7edf52446f40793e4d652c62122af65f1bec90c97313a499c5204eddd530889acb07d9ae8d98db256a74a1caf76c0742241c38fec598980b40e381722f15ea30560ea31ab0f81335a7f6e69e2aafd6052cec9444582ff1dc607275baaacdddde746436031e55bac5fa5b17fad0ade3919745b1dd9a4e94b5e2a525f003831c378321cfb2c80ca40d687c699a702e8fe2374dbf97b22f2ae11523527c0c49789dfb939cb5e52a5a0488a92e2f227a18167064a652962d60e05abcad47daa679fa19366fc8a9508e6a0c42209593d8e95e792093d11d548b63eb983060efdadfffd5629c3ec7be59486272aec3514cc7dff21a7e49f53c02dce7990acf53b05b29904bc105745694a1aed3eb7730cf82bb7deeb188f7d99d5b6b5af9b183f3218bf2f0cc12146f146be104573b8fae9be8885990b310a4b813f55904b118f2966c3757e5afcce05841013c55567a3229e6fcec919da9533eea5edc2035664ab8e7a0a045d067b701c734501390b537d6f3d717ae09bf220c0ba70a5afc05ad7b4554bffa9f4c2ccf7208be55f110d844302f0bfa134e4036a2acaa3f7e6b720a99a595f9780d4b0416245bbc8273d28d085bb31d9de72fa132e1a8421701f79b3b15273fdc835b01f7bd00c9570c127a3edd4f45b62222e5e33fe371c6fb88ae0798b9e1269a5daadac1593e3b169d95705d929fd5ff7a8c37c4bff6ac9ef645c04fadd084cccab9ded7f8fdf90dacec9a7d6307fcb0d5b7b7c97980be8874589a461f4dafea9f189267414ee392dddfc9e243dac723ab9b7dd139904ac1e47723ec416ceb7da5e9eea9ac8f6f174414101e2f14a896bd6e2b1edd7b2274a28ff380dc0cebc937ac1eb08b2132dcf17916ba98f5d74c15f1b6408a12e5e12ce4ce03ce57dbaeac2ecce7f773a0b6811e0ea65c241455befb65452b6cfaae91bffa188cb122f9fb9ff1ded060ea7c7470b6aafc75e2ae5b12a53a860edf5a28b2616afb1af089ebbf28d4bf3bc69abd57f9fae9d72bbd86c1d36f2734db00a5fa5033e842a9fe2a1c34c143ac7b48c2d757a36803469fbeaa8e17f4403d165cd3d614a80bd26011c661ad31ee0e1c089a0b8353d90906fef4b75403ad695f700eb60932de45312b2a5692b260e655b04174a3c86208ec5ab08eb6307a7fe61bc83e3a78ea266a0b157cf79cf6734d1656bce360780aa21c728a820f74950cd532cdd06a83dbf7832a7318fab475905271feee937bdb8635684d2612a75d5539b54974810989f4f0f626cb5930e4eef3064f1436452d1096d5dce0814563f9a7391e419a7060797fd61289b29795e7a1a527116780526419dccc06190d28952c679bdda5568ae876ff0c5ee257cdb709a452c9a6e37536cd6bf5b399a0fde0f2a33bf14a9c75d07aacaf5e0e6be57c9e297a25f53e393bcecb212cfd8d6a96bc97cb71fc40616eff166bea340c93c73ab1295bf0c11ec6bdcf1f7ea86170c2d03cb840b80b59fbb964621a6b8d26a7dbe015a449e758fd6c0616d22571afd588c8e289912c570fc7d6a4a369e44f3cdd25688f02148b65bfbbc742188e4dd34ec125dd8e99335af20d38e0cc3997db7bcc9208752938379ee01abe6b192619a1c73b3f9af82c60c3978a963018054ed5b1cfb469424992fba40c1bcbf7b9569d19c1f73155b7a0d5ccc879e21aef399d33794dc88b19323c5531ee5b0035595b479384da8e2b9b69b0bb822de37c5032fb6b640617bec9eb3c049eacbcfebe056b8718503aa447af8889dbe7572321cd35ed03db4e5b3a54b2cd9d684109c164e2cbd420ea24b8e649e143af9fe0119adf74d414336aa2c4592594904d537e9c56e1b8e8ca12e089618e2aa042b1b0b52e521972bb5e1b38652e76c73bf1378e3ed71c4688142202cd8e4a56d15db63db6136a0b68977963ca16516b258cc120f093a8bbc30e85695268282de0fed2eaf343f58141e0766177d37360f343778fe94e0341ae5bf23a92b659b12facbdac2ef10713e4290394f270f249b2badd6450e846cc42db82e02c7a0cf1f65bb63c3a1696db72f7babb4b9feec48f5a9882a794705d8f33d480608f764bd85ff973cad3943286364363ca5992687a2fd928de6e9372490aa8482129c93ef6d5c345d0a7a4ea681458fc236d305704564bea4de743a127ab2105b06a32bea8fb88e587f5b8130cd0e1412ace9d8b7b5215a8f9aeba7a4be41228abcc0e6f1277d58a06b1e2bf125810ef743ca53e9e1691c9ceeb8d40a0b5c3f3fbd40004921eef20283aa93972b96afe7175360683de2b198a5e77462ab6407c17c8df3cd3e961828d755fbdea8d9e502e3e749b5266bb6863efce029bc5c8baaef5a57ef94c9fe356f0e583c947e4e539417d6e8c5502bf62721a7f745d66d9a4d7ae4fea2793621b6f05b321624022c92f0dbce4a81e42142a990728d9d05e364f41b7ec507ac5215265c6cf1053d32b87f1adcc1f407f86d20beb89ab1b59cdfa05e770fd1f4d4b3b8607dc6c37bc76e6b7d906b5d8adc885ed87388d29875162a4d8f4d7ba21b1d079cc8f0eb85e81a6ab7066498e79dc261666accd27c61dc90b9dd142e6b1ac6b0913939f40be8721d0912730e0053754339d50e236e907cfabe434152650d183ddec62411b458a8caaf260962e6330c0a29f348d9c91be8426ef2296c12e07254beea3de9f65230d24eac86ea9cb7aa2219d536212adff2adeb1e8d281a7f35747c80275f3d398a53fe6de7e2c55001d6ad80b9e355e1db55b97204c7d6085a7ebe7fb65db5b08934323b9957464a152af7a9ce2230626845e990a462219c816c29fbe188bd8f1d1e64886a8012191be6069135823dc834872ab5b6ff97e1c311536f25ed825ff3a32fa5f6131350aa03d49c0eedc9fd9c7add2a342310bf7b850d4b268b158775dd69299e3c37e86a2216231c719be538c0dc465caabf087c993a4fc275e802e21bf7f1756e22a500374247a2789fcbf537f2e4136d5fa2eafafefb425f2cb9c4803d55886b113cbaa3f3cba2ebfa2edec00793758646bbf18367f42778704cf1ac1bd30cbbdb2026630b9ba999ba6030da0196fe6e9f2f0087221dd0a1fded8a0c53a6b30c75ab014a191dc036b53468e57753691c8245018809305f70c7e1f9be78afa68c1bb9a4f837d50b8dd54ec22aa4438b5f6a621ec2b29f1c92c13f89f8e758f286321afdf3c9e1dd11ac0d04ff61ee8f43595adfc1ceaafd84c858c84cc272095ec73795b64a2466405e629c38f071dc8767fa4af5334c6a6cbb28f58ebd02ec5971bd3941af2dbeedbdb0a45bb661bb1d50cb33046c5ae5cd6a9470a0a570ab6b85c613aef44643a6cb0cdd3525d3a41f900a871d239e1f4ef1a94dce7662a8c2f28ec103117fd8a171479f4d88994c524e930e947debd1a3ecbbc88758655a887c22e3c90f90c0ba2c9a8764f2903ad446dcc723f3bbd617361eb77a119a07f3f4d90f638585f61b93716d5ec91470b264958bca2494750de67bbe2640198c69bd5f87be692f92c7d1de17eeb88a48edbc8d57d018b212daa25992302e269d586921d6de998d84e79c75814f7e77a8749b90d81f440f2ca9bf9f32d7538d38ffb8ed01f60c607c7d63404ce1fd70cd8cc7bf983ef8e8c6d2a28c572724bf9ebfc0c15be02cfed79984835fad91b8217f41089319510c336f606472f8764d534ce9e99f3d3fd6f877383c6fc6ebfeaf88cbd7dadbd96ca49cf11a0899af9dab0bc68f97acb276327c06c86f87cec3b8584c08c64d03d77c679e6162d065b126b2af3b315bf16397287a9aa8eebd5976ad6274837c533d344592771b62e6dce5c4ab7c2428126982855a5dd4e0441d93f874546835b53262ff2e3e02aa6c7998c3445073d396598541749838f26d2d1792eefb8a91a028835e4c20265a880439cc0cfd09e117e1fc5373481354c6a9e1679492c25422c341e0e7f4e93578449ae1689b22f65a263dbb55ae2f5e0533acf8adb1ebcb8697a6a2e8d8f05ed1127d7aa7d7bccff393a014e65a3702b14f7c49db6a2fe164d5dead9f18ab568567575da9ddc35195d48a5346f3443891b95de497facc4b6ddbc2e2a0cb64761c3e240e93cffbadb2aef44bcc1fead7ade310bac3f25c8088d876ad28a9ab2bc85c119b234eab0d0ccb0276badf00749c8acf04923644695580f3cec6e1c5ae6005feaa0ae87aed01d2b022a0513a35943b67c70510d625817ed54c56d9e40db890c64f066bfa725ed9bcc2adb0be352812bef6549245abf692ae73d7009420828bba311ad4c09db15ca6a4e07cf995d04f764aeea02eeaca07f60a62fc2f7065307aca9edd72b730d55f7e6ab487e2e6ef60448aeca5c43a870082a890902899718740fbab7d61653db92686c3f94a43580ea4037ba7fa1a139fcf7e3886e28122061d456717a4ef43f2fb9ea4b2c604513d0bec811de6935e4e9198860a955ceecc72ce32ed73328dc34f8a6ddf999105f37ba3611eec0ac40ea799997440918b62f6cb485048a19431abebb2aa5e7a56829d13dd2182a1093b0746e5b29adf4dcf825256edc2ef2a430fea5bfd31ce549c1893360c4e88cbe3221d90c755e071838f3e1d154034959961fba5395e50532adfbac66f5576691c9af1e97a32d3c2b4e8e7ea66e574886db5708fbdc58c720665fd39f743605c520222e5f95b7afeb762a210e5bdb0a267c3b78cdda57f5bd80c41e7ced6c68e8d71efed64641779008a42f7f52a9c844b15daf1540f87bd877a3378cc9d67c122f0a9247a518f2f63ece0316254251ddd3be7d60857c22b7ea23cab3fdac993d2420b0a23cf0f6c1c8ae748551eb036eb1aad003a831a74d6f0f7cdca6bfcb51f8ea7a3c043fc696f2dc30c0487e1f90feda928d4357077323c16c8c58e1dcd885c54afd06819fd7d7a89e3de708af8c80e1384a5ca49e46284df37cad2f814f6d8ea0f8f8a03dad0e55cc88470258fcc9223b468e848985caec487885fe693fb23492fa6fda61f0782487359e9989ca0b927812c42e190395f2d6b04fae25b1e43f2e25a2acde919cd5e66f5c83135bd303eab0f6e7109effd6b9eb760e397c64cc665b05adef6bac2d23c914654f7129490065f32fff3206e531f189bd63fe43c637b553e2778844d376ae3f16b3d2efc4e6847c3a915e0fba2025e5f0e3b12844c4ecf55926c0800be1c744820254c4926907b83b0d8dbb6ae60b30d3b3b4879bb714a1b9082ff8372d48bfdc26edae4cfb987d75eb31f75d1101dffb5802d290d81373e4af014540158505c015662a459d891072f6566535f53db69f2a41698680034e4d50cdbeda766ba36a7ea4ddc5d556a507810bfab33913b86b597257edcdd97e604639f7b783ddd3ce0b15dd8a699291f897fb9172eabd9c9561a0cf64d828515868e320a5ed222535cf6847e6ef5fee7f0e85afb875157d250010037a3feb9c221a5aff11d0afbc8d0d18afc32068f19817e90674659bef397f4264a016b53d6f4393675fef73317c933447cf360400a481ee16d481f9543aefb2c0916c4e14c93b3cf06f9f8c01cd3f92413e0455d061d84a3d2b4eef7b4d360a8d1afcff787dfd9a15d56c7fa393b8520cbf3b119ca9266c7d2d57463a57cb388e2f2d7d7dc903da8c08fb3c1ef2b931ca3956fbce4f7e072405594233c3ec1dc796a969d71733697b625426f087f90bf0bc741171c19754d6122caa5f9144cef34852b93a4e8e8052e63f064f8d4b4e827fd353e605b9a2dc97269a8c74efc1122524343b5bde3841b2238a4010d43557601e4a123e924041e54f122957d9fd3b3ea41c51dc8ad0dd020c2abcfa963ba8a5d5d2cc4e294451335f150c827f8e306706ee7697a5d6011c6af7c253e7c17d37b0b44ed59f20d37c1d6a8fa271eacab9347ccdf0086ee43b06f1e7bb815dfa251a58626fb8cf2be88b48009495775c4dac9466ad0903807ed613c97f7d29fcfa29fc88489ae1458b9447dbc365b320e47d10be6915decb25e41fa2100d09913a63f093447456c639fcad12749f67ec6d7aee720419ff40076d554f013c9fb3a96032a9b54d516596e9a26c0c90cb0774408d775c89740f331a03bc458beb06448f2173d74c07b4bfaad6b8871c2442dc293e0c5100b7ed85286427e78f3677a307356b7fed2b9e623f0ad94345295b456105fa2f77ec50300ded2721cd964e604921183421976b51a4daa7bb136de70cc010e22ac8acf59d5c2762b1701529d57d4633ac5eb8770c86e9716d8265540f15730687cc7e7fa06af429314d8577d58fd7f20720d04e3651ddef8b30ee6ad4f322e8efffc63ddfd1e0cdd30633d7db24ecc54405043849078eb04c2c863c863549456c52a7fb1120eeff9576b18332c7bee4d17b775d271624d7515895d9aecc0555f34c0031fd17bba4e5ae0ca6f50cfe0f8692166a720ceb81692c32941868086fa4f61e1dfefeda9ce45c6e1a8904b475ddff0328d03387c7b05a595bd3ad02b57f677718b51f3ea936b832247f144e1705793a58fb64ac884a5f18b7e276bfd8dff6e6c6fe13ff15ae0321f17eff8f3bd90d1fd5cdf73fd12e525e2664fd896ae081e8cd242b2441f8d9cdb78d1eda86120be5510f916a79ceb435f4ce099a214e0b041df32bbb4ba49f3db877f19c6636af7de17b6f10da97eeede6ecebf07251799ed3add7ac8f13091dbfc77d9a36565f22671d8a91192342ccd3ef83bb2d1936f9a772ad4b5143de50b12189c5bb3c935eedd4131b2e1092a346faef82bfaf86f09d3113f75f2006941e8a125b1d30efcd62ae769ec7ca3fc9bf35e1e5bac4dabdefd852fea75d0300388d0dc54fba97d4318523b15dd90cf54094a0f29afb2d5adfafb145814e8490c6a5d41173f581d8bae4ee6a6a3d8391992408ef228a14d40b078a5d9706c458f111bded96180db97aa77fc7e0e2640cae7a53dce477d81437ee5a1a1652045ece19fa398cb330306079c0c169abcf88767f01e7fd8607dab5ede43781ec81cc7bed6dea8bc8907e0ffecb6a805e19fc8faf76432f067ce3f8a6ca1184aeb75640afb5e06ebc1580aeec43711918406838a1c15fef30fc9f98051adfd81e24a24a7da01fce08f7842ac12cd62b6711dbbccd9b1724c6ff65c9794686651b12f9e58d89f7905a0777751ec66cf495cf57997e6623538846147005d4e44001a70d7f5b59f7aeedad2df97c71a417772592f2c99c423ceba2571996cd52805a51f33a1bdf4babdd37df2727e74263fe60a1ee00102ce6ef8826093888d27ef5a9d7a6ba1e9e6a8d5ec94cb0758df44efb4c95c61052cd407fd6d6ffc76faf1f35ce1bc8805e867b9bdf675fecb4c467f7ea886205e6b9c8c66d223e75dc1717b25d2a3ef5c27a24c97c4e01c44e4307eb8d68adf45d8526f452d8b1beb6f563fa8099c689e2707fd97a4615cebd6b0aee9b7f46dd64213b45243ecdbbf2562c4d4eca02170a0c1f6b01162c143d36e455f52130746de3d8f0d88030e5c1e557357b45a55f5471ba4019913e82d1fd88c58aeada2107f975037ab5f03b0d476883de4b87c01363707ff6b3f7e31e055a0cfa4df71dcd692180f78827aa5e9c366eaf782dcb477744555d55c61b563978708b662438670892494542d1cf3cf7596397897e75ede99ce0a3d8cbe6c3b6c986a8dcd4194284b3f92446855b783f6473ba4e028b12c31df29283d867da1d32f36dab01015eedc8cb3ae4079e32c60ddfd93b78125f2c584b0631a5ff852d9bdb44c3fc1147c12de0968bc48358037816a6c1edbc2b5ee66aa687738628818bcd789ae125e5c33ead15efc1c59643ba376245e796c69e1f1b79e4fb7bd429d9b7928a6e66e86aa7907857b79cbd1cf1a449e32892b1fe6bd3ddc52b0feb558c39a7849270634a569e099e478bcb3855a5a4b9e4378b43255a614d0640a4e2fae14d81236e3a58021b23ed3bd64ed155e2304185266d758e457f41c8b9f90a05b34eb391a96aa5207225e81b63ca3bc174bf1dea178adb94a7745b9175b6246845412d80260f745bd558d2e6e12b2309fd17267c6c5702d788a00ee5ae072cddc3ffd2f3f996a54b9b41a730a00a79a2522d362a3d3cd463870fd8329f0aa271b15c438f977d2eec3de56dba1945d585169330d7a2ba47393198a07ff0290bf642fddbe2ca62de4eb625ef0fab5a9aecb8fd94c9031f356f6eae5f9fc374736a860c8a54dc557851886b7feb6d4035bdd24151534fc6ea4bdcdcb4fdbb7aa4b9c12d656e6c44c0f01a3e2742031df99d1f6f4076af2acc99e591b2c1fb2859248b407b8cb6ca2fb63383f558a8a146a4eae3493b1889c90d987f9822e085ba4fa60b8b63f44cf42064cc9d4f17f6f63ddb8a7ff325d7089383246fe7b085912e4ff2c434d6e194156c10de20041306edd53f8536f10c00d29caa42a0d58b5fb98d240fd8e5d2b55893e4697a978fa658da69d807c2c0115493500168b1cdf2d787e05d655be14905fae18d7a32d56f306657e2a804b93893abb581359f69a8fffb11c8dce94fc5e0b818e3766087e1f4bc414b97be7a11a5b6fff9e4fbf7f5055109396331233495f943b3657f865b469d3aea6450e0b9c38c479f0ab19db6985ead3144e911e58696f1caf47fed976f4a8c0d393ef293d8bd124aece376cc315eb8a97af7308a26c7c268c0de67dd0255381454e13753afabd9e724596da21452949bb45ded2d1b954d34fa70a8bd58de734838d033af70fa00d84b976b99c0eb98f0f38e8bac1db5084a82f39f5f1e6cab92a40f32fe9b226128f6a8ae10a70fc73989050f59510f98ef71bcea5c3fbb2a3c1799a7685516dd55431c469a8b67942c9b1d7e135fa797d7f966f1ef8cead8903d9a60681b7be178b00dd9b8b017fae3e4085e981bc1cefad15374fddf2981b5254d43fc0711fcf6065b93aef510da0fab3464ac71814073fb2f12fb675b313b4c27ac67d06a6fcdd726b6e61cce9f40e5318e0bcdbe36685aed6ed38c55378d6a5ac7c13206afebd9252f5f542a4ed99bf89b5cee04cb4566c16d0adfbf68de6963534c1f1f45b1e873182029f9ff815b4c0a03c07d7f1e6633398e7cfb71f621a576fd5dd5f41debc155fde10ca2a3c419d5a89095abb63034ea64b55459ca100d558a3d96b58adb4461f2d8ae5f8c8bfb7ec79d179470ec4dc3ca9ddd31728bcb254a7d45ab98adf0fde21df4ec5563e6b84f8bc427fec59be178112ddaeed42a0581b3e717febd1b8f462b6539d6e41e718afafe6585dc90d37be0e08d1aaea67613d83358e774c68644ec1021a92f337373cbab919edf121360cee54d5639225033a8d208b203442f78a83580d07713b06ad8603fc6f636d127a95727970c9e76d1feb838b379711d32921bbce93fc91325e329cb3d118f5050a5389361c492cfa7ebfea208a81d6f39fbe73b738d58fab269d0369b50f0d96f927f391a53369c1b1993bd275b31af9e0ffa76b7946fa89e4b99f3af2205746d97cbd812bc28f32fe1123bec43420b7ab1d34721510b8e4653ffe4aa51c7dafae62a20d9c3747a249d68d72e3cd2571217a027c5119754db0ee1adad75c9d55ce5dbfa1ebac6a970140e20a2273af4d894953339b7d8b5aabb093f7738239dd12629ce89ba01b46fa120d8a44890790d8bdc589fb8522786a37ff6ec33f26b0e488510337232e91befddc0ab6f5fbab4b6a7c153e63f0b94b10161ce44454cefc71f0382254d1646889de948a85b3e44b3cb2b38115c3bcfb7559c1d450950c1f437d07d950542b129b794a52b7abf61888ee9f616039970143ce4040f98f25cd45183dad50d0fe377332611d7ba74f725badb49b1b9fb3612eaa078880369f3ee4a5a7b1d17aa4b08dea2792a7cb5394718b614e9911ae12d2f1a4ad04959e6ad9629ece6e6996407c97709cd9b93db6b9d70d1d2986eb3bf378841502d450590dbcf2b6eb064ee966377da0bd7bc738e3bf9e4bac7be660bff61de759c90586f286b8b21d2506a7f45c985ac730c4f20f5179ed71221150ab488c7809c85d5b1fbe5bddc3d3e54b70c518791a84b725b9e41ef55e9f2c3374261dd98508b2c03efb7f637d0261c3dbac79c78934514f2a7540f89e8707d66ea26aa149206cee1e2b6caf5063099207adfbfbe36ff2bdf2788d78b09ca48cd12a47cfc23d490ae33a3bfa4d411da4ff794f22205dacd30980509d4aac6b3485a6351dfc7cc7fcec102c34f97302e09f8bf5835f3f95cf45fa07218cd0487c81a5b882d356b8b722ae9ddea3f3ef562d3accc7ee21ca0a21ae66213cff4fdd00ecb3930b70d89419552f8709ef72c1f","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
