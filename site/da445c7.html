<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01c366f4fc80e3590abbbd30f799cb6874c4e546cc64dc4e0f5c78949d3765306c640e490e7fd1f4600b75cdc9cd323f2d8357c41c55640eeb279a20adfc9a02c8b58464f1bfbc2061ac5b66216e90244e0bdc81489dae94a0b764100a599cab20fea5b2ce98345368f45c065ce241cb3cb7fe88a8bd4b31d4529deb7dd8679667b30bd5e218a5a0b3e0546a0164644c45fb60a9b1612fe28ef6ac787fa07a55d57c2a7fc19418dcdeda242d3cd1e8afc2193f923332f2316af845191f651f500d97d4b1c4dff2f68ce55c2ebd08000dc78239597368a1cf82e542f08d1f2eda58ead9cd4c50e7291742f39305de8b31f093a59bd46b90d49165027350ac4da58b12926fe416200d22be0e6dd678888ccc5fe50294f2281b223db4dd8dcfd3d31fa297329922d4b5cfdb062ff8393e6923afa7fb21f22b5eed4fa088948326ffedcedee3ef9731e4ba442e4507d809cf663ddd8fa96ab474d50d5f7be0a935c45a23a7d2e53aa3f05dd08af78c68b7bb9e5a7f737576c4c25677034fff94a204a68e28885d90116fc087d6d9d9bad256723f61c0e8059ed9d98254584b7a35bccf86b24f3e24ff9b8d46df92a81f079276336c932a6831902138d6d659c57feaf4c391ba64815816d4a9db175beea51e735e13d12f0b24143217720cda6ead93904030d8e07300c63370c8d57abd1df14576383b5f4ea0821211fda78b1e1cc4b8fcc13775fdcd032c2caa5487f2a2e25d50008a81c6d301c66a795ff9e6297eee7b886dd09a15ea2994fc988d52b1cadbede1b544023692abf3940c4055e3dc17570c50d85cfa7e8d88d17a1bf83756383a8de009a7d1b44983e90840c647e5dad7f735bd35105cf5864bfd011020d4f3dab32d5f66ebb8da691de92a9e96ffbb00846ae60daacb7affc3db522228f51e3e6dbc5b8cd93bd8a36a35d58bf9ff9ee6b0d2251751301b782a30f63511bd9b290625df5faf58b73fb437cdf54394d3a50ae99afdd316dc0d53265bf4537ef1168daede0066c2cde9918db80939e24b87e552d950d4e6fa231adf3dea0a1a18dbc9e31931a71371e156bca5d9c7afb050b8e58aee7c8489aa6e860524cb5e43b668a99d7b2cb34328e1a93c0186e28c754ccfc20582082c2e687007728bd9d97ff1eba2570bc2b3c1c5be298e25154f97b292a8f10eeb09ded444fdebbcbb85bf6410e382061dba3d93728153185afbb1ccfc3d752d221cc8eb802c19423ae93698615b7852f082a8f3d82e84e7e16fe8755108044d0b19aca4fd4a41a24c034bb3e631c9aa4fbff7af0d084e306d1ca8d129bf280fb09cc560f166a7d0a8b43824d293c32b85d54a8f75b45513d70122188fe4ac623cc009559feb73646b9d3dfb2a30d7cb89c7f6f3c7b15bcc68c7ff2318917e79c21f835e45a25c1149ccd473e6d5834e51e1ffae49104793ef0508d3aaf1632eaad2cde0d8956f00ec20bed832126e8bde597bc6068662fab2bda9d5c123c2ac213f4d17777fc50f249210613d2fd47a5c07a4fa8fc4f6f31d35a1e0772460202b0a274ca9efae16d0d0e29e14e7c53a25c281f659a2f66daea977105d6a5738b01e197aa247d7e4ee2e149b325d1ee886b03db2900d467fb41f4a6dfb5bde4039d7ac3f977e1e0f2b69a4faeff34500076c57a2b72ad171e9474444787dd3b09d462f2018188e8227b6ee826c0674ee29e93dc4ffa0731a28b7dc897d83e6dac19a2fba739ab155165579f0ed69549f62af4743b150420193464dd6752b60569865e4ace99c0d073680047c8366fa1b6a19855290c9ed21848f15287b30f9908fee85c4674b82a4027b21ffbe1be5b89da3d7638f694769f396d5e9600b2437ff98c0e9a9ed2f1ef79d5564ab10ec116276d640c531594fe0d3607b75f563f64aed4ab0ef7e387e32c1a84ccc968381cac4ecda25fd266a076c5b49d45ef9dbaa07a410e7fd83298a6149d25713ca1c6f77f4bfa840ce0b0903f3d0f03b61d3ad6018ebcba71ace2bec644ab082ec9c5c7d04120db6e93fcd91c6cfea15015e5674261fafacc8d0ffc872df15f67d7cd9f0014f098294e605a6c4ed14f26b9d5ee3758f12c6055f4e70e668b0a36f9ed8bac68f5ae09692c9a8693f82de0014334c454b751173bdce47da0adaab790408fdcafffae58303f54ad900b40bacec86987f8b448f705a5b3863d8a4fc9d886a31d81b23e97dcb577bcbb83b40f836073a46defed0059022fbe4cdb99232487646f4b6c486208da4e427000405d63028b160a2cb8816b5e6d23f17ec32997fee5e51a7b269f3adeb507f392a0117ed7dd4426a8be07964a14aa8422cbaea458b02b4d25cc0b4829a6b8a451cf4fa513a7306e2035567dea6ae8ca90f95c71f7fc3574b52e8e864e0306bbb7464010ead76e6a2c9feee8b8373d7f61063dbab94da74f29174919e533361edf64af7787e0ca46b0796ce61ff76c6b9569310ad1b57cbaf083789295acd545be33d8fe68e0bc38da00218b92c739b7844d48b93e127a9bbae1db2522b784dc1e64ca36dcd000698e51db8d1edfc655a4966fdf07907aabd29710ee072302c91df5915cd82d3eb39970873362d2ee37971e9f74f44b0b01d0601018b30abd0440787ccacd4559a0967ff62b691555ff1f02e5389356dab3c3547bd0af3ee265c69729b8ea5ccf6f15ada0c42800ca53bac1757ff5e15c1f9d8889597c934faee5cdc1d8d8bfdc22580a91b2fe8d7a41bceb1ac086b512e4c5efa6db0878465936c417bf421efe153fbcac35b0249df83ac494f4aa2830a699c34b839fb4faf1b0f9610af0ead0bdab344f68922e16459e71045ee452d7f9b49976975033c394469212822dfb268b039fd305cec529375bedebed3d81c536b916f30ed9e9d40753874febabd4b45d68ddf6546a7c657c632a9a4d5c279fe5f6192b01e6c0ec5b9071da15029cea6492a06aa29c4fe167baae8190c0e4d618bd1af52fd385b7bc950e7b2b4674de1229e84576514837fd248fed8bceec25713eebeb5fe8760e239a15ba13d6ac2ba2aed68c98725c16deb302ff16c60e6de19e5be8bdefeeba8326f65a887903a98a7ec56d51faef8e03645319de25cd52b6ebbd567cf22a44060ca8c4166f4f27d59505839a7eb097ab943c09b7f0562efbdcbfb2b0ce020acd23c5173ff0f08bc5c50860aea49f2fd60d27aba058a85d0d7bb69ca3743a30023f63ae0fb38a55d33138ad165f87a28dc4f73a959987bfd835dc71d25a644c0e95f14fff11f77999258c9a700faa1f73afbb3186a8fb84baa605882c7e58e2487e9cda8b541fb41b3d00f561db287fe93d48e3b2592396440550163a3c2e76f53443f631bcf305006996b38b9d05a0fa3ce70b07e6dd8b7f8b264759510b0dbe83e988cf869d43bffae92c4a2866844d2013d335c22d21dbe20510aa5f621b68a3fcb69a1639266ed60d65eac24166899ac525497141ad355ed6ffe6dd9279267fa176288de0369d4e178567996663db3c4dbc50193ea031663c30896c536e2987f0922ed640c7d68a215fa6d8b0536f91b5cb3bb17f3d0f8e30a5b7e307f4caab0d8dc50fb8c3a47e1916c18ca2bae2ec460fa7cf8fec698022f3ced1ad47698f4ac31afaa8daa4a95d5ef37363ad0dd671be3a9ddf8efa1b1c99ab9a2f6752a3a97c6338487113f622998cc7d0b83469f165c839e35e3a2a22f1ade5eb0de9ab9d98654b0cf04745000c69f5cf9f1cf1215a30d5021d074e8f21df5ad98faabb70628b65c4b0127c6a2e4349ca52602133a80b6cd289815781b664b407e0e08f5bd5b25bb5df2b610384c84cd2cb9a2a32f71df676e1719d8ab7b5fc521f623ca935b595b0c90a86000ebed6ea5b96c67d289513a17536ca3be7aa90faeea5e6000d4fb8ebb0ac68c4dde60195e2adf72f73e026568db7f692b038bb4a79390059094c1878d1f6cfb2fb9977d85119201de33a750ee695f9c307f0b3dd2dfd7ee813abd594060c307daad79cf8fb38abd0b1ce661e802118ce9fedcbfbb11c9fda7b4e766ccfd93d22e276a07b6ac2781919a03ab41175dd5255e2bd5f6e39228b48ddccc0ee56ca61fea4e2de8c906105ce4ed0eb96bbd06b4b03b5f9c3379517efcfa8d446dcd612ed8d48df05ffa28f26180f6efdcb86f3d8817741bc4a8d5a43a495b46357020de97e71b43b9659466a064b2c3cd283a19c5f341d3b942248acfeac97888e2485b60273813254ff669d9f207aff9f21ef4de87eeb1afa0aee347b4832b477a12f7f8111dc6d1788100838a14f995a8aff3c6994648a1861787dc03a4e461f08eb78316504e6281c348a93412e25e6855dd6e41ebe7901de368b930784927114547dfe21e06ac705c6be08d42afca73dff52411c129c07a86df5bc3351abe504a387313c81c0f4d3d2c536a2d38ffa408ba254106dc7a47a5e814c8262cb9a779f264791148e4953fdc43802f8e77f5a5766513af3254a8428c1dbed79d4718900c69b293e0be99857dda779d02350db89dc37396f62887c982878fae76c2df0f4d22e9ba3e5287bfc95edc09f171a03a0603203401034f96e745aced17e07b73e21fc75d2c422b997dba18fcb45e58a310e46312049d24922d5883bbdda0ee751649a172e0fcd12f1186b489b7adb4d639848e231318edc0a2706c4ccae721b68b9de4af987d049a37b2d25712a0db961274a3d6e457d83e35850710cf0355a3498889630c5f70962c26613ed56dddf5fd23d4a06c4505d6f12171eb3cc9f011abb4941e2e39f440b336d1bda519e4d3157fe3263b73a73752d4c5be432e5c9f70157b798e1ea0ab21c999fbf582bdfcca4db3a1aad621dced9b1b73f8529025c5fa0d0baea7e706795608d7bd0b31d7c523e39a665602c86db8c6ef39c5d9988e22c1394ddf04d1cb01398318b8a986d411faea0e9984d526b84fb830b995084f0b6ee6dc191d5249c9d9c2ada2baa9d0d39348ffd5d8a752c760ee607d9aa4ba167cae232bc58e74c49cbf0b4609b3461e527cd005075cb25c464c430428e5bf4294668d7a98517fe59c3b394f76c08b501fe095c1ef214c854fa04b87c29209e3f2ade1dea4088c6cd08bd9d40ae21b67e5c1c730c0151d24ae3e28f321e7737e15cf7fba7aaf0ef7a10c1cbc4aa30f5f69790b6966f3927b280d9e16329b9d01dc2f3e8b871a199c65be948262c532ff1a8ab2d49b91b2fceb8e57c7f62382d4e9632d5226b9d2c476348d63eac32983c6030d89e03a99c744b90b144e76cf137bee97992a903fe5b10657bd901d623322d685823328340d2ae876a964e436a1275d8004eb141fe1f70a1ba80fb96bec3b82c366fe61035a05d6d733c5424c095a62281584dac4edee5d3cf64952b820f5caeb30acfbc97dee32f2151328fadbe3897ce66459ccbeca834a2ea2b1f4f0f20b2a735286bf253c469e444d6e61cf3d46093a5a5dd9a751698a6119de6aacad0dd147e797b56fd6286f07bfc3db35a7ec3e6aa1776398892368b5d3cf4e05b48b244edbbe697f15282e7a4a2421d548e3d37d07454d74cab6cf331c8226f2328d6d692ab911f8298b1647d2c34ce3409622cf56cfcea6f529d70935676f29887edb5de739c889b2d3f0f6e297fcb0dc7826c4ec82904323f1606659e40a65265580f3f4247026addf78d02a02843cb022390b8fefcab56f1b291ef54c898514d74b2d6c4cada87d63fb0e6cdaf7edb1f3851bda7f1815d78080b5d22d01318720f681443124e011abd3bbdbc07014d55d7330680b1428901bb18ac003ba55034a70abb58a6cb31f440c487c2dbcb4266258803af4f0bd241fbea886edfc8df31f2dc01f5418537ee1f12f3935e4fcbba72e829f4170bbcc3b56a9e79859809e8b6c37be3b863d91a8d16ec2301bc1832546c7afe0d9bf81d55368a5156b6950898bbba3530742109d5cb664f53f2d1dcfc668005619e4c5478632c39f96d7af4a99d983793a9396f33fc5f22503b40730ac733c0cc6e8523c06a42d3f047623e67ed3191554a0d6732796fb6484b5edf39eb9df4d92d5a88eedfe052e224cc79735a7f83744659124c30c28ad38b8a4a56884ce79018a5b50b7a7744a31ffae93bd94b63f49474b7dbdecafcd7fe444fb5e6d358d3a1781fab186a623f24a4a3989b9b4d4bea290f352afae8ef0ce82a1dab34cd16337237fb89fdf50280fd7cac7fa1b0755e7365b5739b7cf0cb75a4c24133b0a338eddf9a7041eb07aac95ef2793b7282925962b9757262da2a684f0fc47cf164b58627db020a74ef77c3606f704e807b3f4248505259279033ea19453d02bf86734632734dbff16320263a63d116a7d5189dec8fe194b669aa9dec0e4725590ea98bba6e638bd231d06d837be23218182f12121436e5abf20cee2af31a53589be8c0e56b2867c733f27296387b83f71b94f2d6b4e11d2574dd92d347326946ec40327363a248119301d8f5b665f73804f5f0e3667837d1a7ec9af0cdb269de69ebd698da241ef8e11ef21821458b265ee00354ca472fa8289b292910a1449960207b88cc186f6cda33992d1fe9127ddbc0ff8fd7905d0d9f9d2bab07d42ee734b48a9cffd7a05e821131ebc041f6d2f9551e823983b69f82fdee8115448985c5d0c42017106fc2b83adf8cf3b76057e54553fb5a1d41167af95c4eea62d8efb2ff03164c93185e6499a0967f99680e25ff23403d29a20a7b74073a18efedbedbb174c9eef4b845b0775dab8ae4aec061f35faa67e9ea027602f134a4453585a8bffa916e402eb73db5569e7d9c3bedb6251fbf5a64bdb795279d5adf9a8c141b4a38efe33af07ba989cced64c8f99cf993d8221c149d57653e035d7fb756aee9ea9b2e5c6835d9b5d9981b4fcc787f8348afe40e3f3ebff0be0d799a40d0d197a4e45624f54f48f2eec494f0e3cd69fc715bb88f31726a2cc7b43a2b61f98cfca0f3a3460398877755482d324c7c92b46cbadfc8b5274e29859a23108a5703eb9a6575c2129bb44853d7f0ac36b4cae2a19a204f85f3d8ebc9304133bf16019f6418750f5e42cc80445c017a9d68682fed1dea464b02d17f6edcab92c1750e2bcdeec6680ca9b85eabc37fe07c533dcbb2d001ca36b146b127d58f823c44022458e7bf1c4e3573ac5001f6d4cd5e97b277735c48278170f4950fd8fc921fab4dd079cb5c12eaaf859a14b7f3056a5435cb811d824d48c1c1a828571544c8fbaef7392bb15f2837c3898be2397c6baef0d3e088ddf63f26028c5eb7391424083fe885dd4b867c991717d983cc44ab7087958d22bca62887ce9a89ac6506e4335e732f04015a09b6b087e424c724b1c2442a8e24e414ab30ad57daf18b7536da452408a6e77a1eba2e97a317cf2a6ca15928632011dbbbffa54d186cab4aea34fb9c7f2d97dbd2a66a2020896036a0ca2bfb00f5a408b520dc6d25fdc153becec3496dfaaf505ae910aa200b5188138b1d987a5d460b59ec1065765535eff40405e5c0ee97e4250bdf223cec086ad1bdfb49d26a8f36ebca6fe23ff047a41171fb3cf8c0a6577439122a719b91e046dfd6a0fb4572d97652d5bfdc72af4589c62f83b586d34a97b23ca9ceaf40d59a92091ba1cbf0e487a844475a338a87fa43c6abf3678c4a9b59a62575e6ed55fcb6041eb339048f480f42693dd07ac1d881a9d301d96e219795ee37d4847d29145deda4a6ecba0f0c5fa304b32bb9d43d8de4f4451157c7400264717f5f0356cd90cac47f4a90d41c4e626a0979b17a516cff13ba53d4edb46ba30e5f4d08d93d385f90b9dd44f46e227685daf3195ce4ccf3954e1824cf1e1c0aedd95aa898aed93cbed85563d7a2926feccd2b4bdb6a5cf3131f80ec4890b0f058e23a54d17c5d5353f2ac9df6337a9828cd2e1acbcffd291785746457f8376428eea287e7e66c4f6455b2dfcb23e8bd0510d77785069190e6a5736e282052aa3cb4f71aee8a7e1a6cdc0614b515957d91a8d5f02523d456693724a2a717c96d14d5b5178fd2aabfcca712898ce0d38310e0df38edebc68267dd3a4f8c81b7e1497ea663a6677d8761980b81f894a141b968009a1bec06eb5faf826eeccd17ee7fc261c5509b45e85af7fa008120697a64486681fce6eb2ffbbdb3b509ff07f23af6280c7a1614aedbeb3356ed54402a0c74a3677367bcd151c50eb907f499a6fa08d63627705b9b11b578c200c3f67da45f17a299faa7e500947a37135bf3af5d74236210814b2db9dbae9261aa663ae68214c802cd03d6eb0eaa3a7316c3541d3ae26e0b989edac9782fa67d454c7467dc8c6b16634d94441f43dd718c8a7b84c3212a39cf1f929232351d72180960a2d66a0860f036255d8b923c5769fb051b7491c0e58ed469e9cd85e29767b4a6fd98cd93b7cc3090399a140d4270388d947fca498579c68bcc624f0e98079fbdb803b4c917d2387b53a37bffad57cb304b65edbc6fa90748ade7e93bc4b448752cf188712a47844d2b8bbbb5712338574d94b112495470e9e05c233efffc9c8f115c29acf428cf295389150817a2b1320e7d99c9eaee2945fe52da2999a7e53cd09342e9b899fac625c8551a801dc46cf612ce3504e3eddf123d8d547680ab1713cecc2dfda364269176404958f8ce67d0f99ba6e64ebfae06fa27da4712bcdffb173f0f668acc9120798afda83d2f0113b044488b9f3ba581b048771c00ba709e1b6cc455d3f128a0ef69aba1efa4f2714463723d5315d524bcb5b9ff1baeca29876a13bcc76507f958e6364d3e78823aefe77b92e79159062d6241f252bc43ddb35af500bfb288356191a0efc528a4d3c19afab6b47073a9efc00cf90685d9fc8d62bd5aca6459bb2d3f8d6fe0ddb98f029c9826bfe914c406e17cc2a81735d054ef6403581141c8004341064c9b65ae3054f280ee1db2c5bc3bf52c9e4eb0cdc43124df95524947dfcc624d114194fadf905fc526fa0a351c17b95df7ef8dc98af59cce6a72fd76743af0a4f198bae1e20a4c7c01db94ab7142cc3cee28b4a5866dcd86d2613c067e0fff5308f3b222f77f3ea5574b0786a4f394d6be7267653e72f7f5cf49ba9a92f5b08ef908f74c5ab578c78f95b859a671693a4412d62aa17b026320b69ac0ac8221f5c7e5fb85f30606ecf8f55a9389f25ebba5799398a182cbe66748ccae55f7864dc370284a50432928bb2d0aa3f6d018c68b07169ee8bb186c17e2ffea1a6bd22410213c25b7957c714e9d6d2cef148e4419c1905a0847cb64d6995c342bf776354d8a7feb99e5102364526e463280b2d1cc713daf1321980cf89df3e081a09eeef2a23e24161d1f018943f4ad4edd527f83b73c15179c3456cf87558d7b465232072967aa428bb152babe2a5642c4160e092aebb045ab750559a578ec0cf26c242027f436f8118f6591731339a5543a6ed5330eed0db5a86049a7311c2efecb35004782df5598512ed26aac8b90df75a7d39ff8e0097fdd834793f724fb7fabc4d504e54236130ef54155b4d77ed021ae62e5fd6548d3047a30813cae1d024e64e095b3f9e823e7a7d32fbd375e5801d2b0416f8fb5329aa91e7637bc438f891aff4dc2c2d5e0719753c551d27a644ac50f5fc6dab3c89a97edcc9307b49d1a697c6c57524af23def68b488e21e47ce3f3c5158b06f50827e21fb62e1a41798a0986c41d2ea183b571e734234078abbd15ac7776eae00dd1a62bb0c65584cdbd843894978d05da2d326db7f097b41030f3c46c51dac2a4dc40a5a3393adc11c88f5aae1d95dfa7494c3fd3a03ea78ade883bf2344e2dfa728e4b957aef6d39661d3ec9dae11b2825c7eea756c78e91ecd9712881aa331ca9e56be6a3815df16dbf15ac74c3e8f4a69c8f9804d2fda25d627f7883d2bbece1f6ff9d0f150190c6afc7de71426af80e0ed6a752f369b6a90041b7719117f16253dd507ea90b2bf3eaae121c66ecfcb16cc532b724cfbf0ba401d0e606fe298afa08361d5fc845a16d1ce34cad9b9d6e2aec6ab0f20eb96fbc4852f13cbdf43eac03d059534aea98cc50b3ff17536b191b00eda04a667412273dc10ccd1d87f50a874b9815e46e10dcc4f321848c3b6cb87693575e49acad2d0e0472ed00dbfc500841ca89f01d53be609530e8665c80b8d61fccf831838fb9ba8a7a2c59fd1ffe49c261535c36dd646ac346f0514916669af4588f1344e47203536c8b24006d1a4fe33d95834ff314bbef7bd52a0e2adb2a0a1c1bce1ff4a58f46a7e0c39a04c0c5bce28743ca61698b026be7f0431d73086f755862e9a7cb0b5311e23d0b7e5226a50c048b03bcdbb491f81682a7987b52c7e2a96d041a9ff582330f3f3332abec9f1de5b4be5a56181a2666f5661da30de4344931a8fb2f0db179c11f09f30dbe068c0d9e25f999c369e97573c23bfa9a121f887f76c2db8a576293b7def08a8eac929ca92f66f9504b9f9286785d6a90113bc2f21c2cc3d632d3acb12e35adb44c2551ce2b773e60e49240354195947e77aecbf338461f969069cb9e093275fc83d3e49b0936f487dc3de7939cc720f34ed818dcd3aa4572bd588aa0b073bbcb4d2d98c19616c1de3c5aba7552d2d421833e6c9db33790d0edf28563711448aabe0110427ed2e37c235c817ebd7218d1a2a8142245690f8286f33124c75fe49e987f5e1783f9175c37ff4b019bffdee42a86d1fcb51cfe5b3fc877ee11e2bdc4a119669a7aa3a565c2706b6a1a246a5dbcf0965c17de8ff071104090224f248a648e5a94fa38973da23a97405cefb9d4934b0ce42cf75939f06b01e4bf165ee23cd2b7d478517dd6289132c9a62083b6ce2243943c81db52920829c8c712e155b90373b96e5b553d1ffbe9ba36b9c0fea163ce1b10ded271e6fe8458ade6a066365d1d9b8dd54ca02c4d422dc0598fecfe9bca50a704640309bc21430b387f0876c43a427e93953ee93cf0a276df92d1c37abc067f431fefce8c33f54f191439b6ff8068af50a8a0c68a1437ebc34197f73ab60b6f62ef5f9b06417657f3d401791e69663710b4bcd0fe2314939e296d394d71a4312cee80852dfff3e9531b4666f3fd56c47b5ab105945ea048789a28b0f34a79f5ddfd426816bbf95de0d4ab1ecd6ba8f734bca0afcac3e59c70089f83d46a4b0cd091ac83002d0585be7cdd1bca0ec4d17f8be028281ea000","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
