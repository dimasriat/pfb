<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1392cc6ff6977382db8d7c076c088e2119a24ab5046c472b87657a9c445fdaaf3a7dbfe2216578fbdda0d4225ac3a71e875a8b7d831432b2d70b6e9d8a417882b44a241ae3df1d56dbfad5be9a74bba98872d305613c23b5d4dd4bb75f1e0cd0291236b1dfc0e5731b85dcdbedfd9df25560cdfeec1a1d23839d72ce0323e02bdc78511101747a3c972745415ac5b4a0f35d5c04671162a3760e4064aaeeb1245800bd32ae7592cd024c27a527f6e83e9a3b3bb90a9e2bb27ce90d3bd87e7be03aff0a060c52b6cf7cc7d61b7474f66254236124fd902265223de44c77718bc43e8a4701a2b284d5acd3c983cf26045c0baf1b3dc65471499031dbc9c57e6de768aa89b7b99020611692c5d9035d7c50ab66edc5279b27b4bb5e0dda62835a3b0a215b3f4fcd0db1536972d6ef5bb6c952e922125232e5aa2ea01f828d45ea36090daedbd575f3bae3ad3ec507fca2c6680ca9e93665d1ce5b585f4092e9c8c2e2bd6972a945b5c8ea4d2936730ad3fd396665207aaa3a4277204d6b4fb68ce9807073ac4656b1c951cf5e99eb407ffb8fefe3e0422ee92c5e3163582b3a3c57ff02342538caaadb651195f771dc2eb0122497d0aa8d48b89562c2d9bfa6b0397a4809f6638f216c0ea8e43ca5bb9c483c5f7a18639418435312157f2df515b3e8791adfe2bac74dccbf2e0525201c1941a6aaa9d780883eabe687eccc07f880eb37085790fb16601df4647a0d617a941431c383a6aea8fa665466504a442c719dceadd991aee59a212c2caf2b4fadaf32c9c58952897bcc61131e038ec3c55fc8167ed19b07a4c1553b9cc2c105c932776c7a20eb7226ebd8d73f59c6ec9f3b8b5b2fa7033399c7292521f5181e395432ed900495656fb17a4fec968ff162d28da6e2be3e75d9683d9c169a59728900c3ecdc49b8787d419267cd2502faca4010b562ffa6d63750867d6975e40d4083a690abe88345540de23c7fa87e831e098ba39a528ed4f1f736459a1b5a6c827255ab34c5de6de362891d0917e6dd384b703bfab7f680fdadc01951c1543855efd9aa7b979d62185362fe0bd6e7c6675510f1e024b9d06d588aa4c41d5c63f3f9fbf60f3e9be781a0d9b407b68bb0a53bfae76d1c553332e2cf359d89a0830f98be6ac1478dc369c6f8779b1ea2c7c3e4bbe731de09a583dd194e37b177fb6b37fb39da56209d54c8fd6bac53a87098f3e8d24af99418c02e63dce5f7227c2306a1afeffb65c5843dd17c52ade2507d9c8de6f6693cf2cf369ec2b5bfdba6510e8106cc0bd7836d1b115b5ba215562e26e496e2b852b59cbf3c0ea62e14fd1927a3b57d8c82998db878a030f01f17dcdc44acc38296c4fae2a5cf5eef4042786ce6e34072040bcabd3e2bbe3cdc254e76b65935c95f11fd3616d2297d87c2ce6d065badf782305ba7a239fb16b003a9c11ee1d3f42d23c18aa47262120c5b559a1609a9e1ce7c44658681febe65a8d8191de93632c4a0b499f69e14814f29cf1b9c786c67a33248fc6e302b22baa2946b8cd645c4781a8c96004e8e3946c3ca14c3df39da8861d43614320fd1b5cb7222f4be3144572703a18fa93d81217f923b283d63a57635fe0e8896caa22db2c8c86bfdc79fdcf2a8aaed2440b92cdfe965db07c0a5f8903b17b22443b07b77f451d05227c41b300855b96478c29a6ba170f51531e03055569779ee964bf31d66ab689b5deb67d5fe2ee976ec9d9963ea0fa95b9ede595b99db2b07c2b863ff754148d139902785dcfdf2313f3a544abfb6c45a6d81cd57aa01d604eaca1b6399da65ab7e513ec1af6d275effda0081671bf1578816f7ea701ad62d9614a19b707419d62482a8bb71851a053b8664c379a1278d01fc7722427c1228688024d868f7573bc4386ec970d4675b44e7d7dc193809736a046cc92afbfe2a9b4f4ddf46dd9f3606d63890e4c563b36a829ae590c88369d4b7c8b1a8492df8b32e725f17fc3f7fc9a7e8c82d1494abf384fd926aa0aeea008149e339e1fdbb9892ed676eafed27a487b59b0fb7c2bf4506bfa84f965a7314856f5ccf8f1649c91c9009f5d1f5ba248701fbd0426d5b54df97f4e253f3222c85bd64ea96ed1be3923611785fd9388fc9110c160ecf66c3344b0b79f1fde1ba09b66babc321df9a4c21e1d4023fbc3d6f2e651c0c90068a163837c75e08f5dd161b00162a8f72b5d2a7dcedbc8f58d0e62754dbe26d0d239e9389a6a7e6d0d4102bec19c0eb4a7a97c2c121284c5bbd0e3728bc4a3a6799c5348268dceba3a7abad821b7bcba651ad33f0691674738bee7ccdea8d4d8dd09d65ef21cff2c73c418e162a7faebe391446ce598688dc8f74218b2546f6c522e2ba6ee4fd91eb6be4776d46096ecb0e8d91a27111792fdaad7b2c9c580cf3b8aea224ba41ed8e618c4dae18ea92dbae011f7fd55480db316e9df79c5e4abbc4405d1467c5feda432ea72e6e0d87a68ba2cc922197bd64b14e90ee8d2714a3c532de210510e362afc1455b50e8597465cb14b1433d17a4a4ef0e2f1df8d6c37f4915649290eafe27f76f8228c5f221f5eb6f0436c6eb7979b2094dd6cc6c3b2fd07f424871c860cb99880f0e8e0e306839bb871060ffd9f297b78b55e2765dbe2ac6777041409d6d6bdb27c1dbb3e008f7e6e034f2844b89ee5695a2dbb47d41cd0c3291bb6f2ca2d5ae42c1f1494607300b6b0d22720013a0c029a4c44256582226731b8d2f5674ef3ed167e1a93cbf79390fef5a2abefdec175796ae77c140bd2a3ea8401b64e924641eddc13746bd37aa14b5428e3147bacaa2a64cb951f6f4eb92cd6461a08d3c27466cee4e9075d3599123c7a07fad26cc24d5023b1a3bfabd607ff3ac7c7fd0ed646f0c07dc2026576032f7eae40168c0667885695533b4cf5c6889ae95b0962d358d1595ac6c73a9e392eba7df5e46c6ff4af135bb9609410ae913f464c7b7207973e42c5d3bdf08d4dd204abbd4f47bb87755c328d4494ac190a2cf81d175ff91fa0ea9f50cc2e96fb02dd19a2f2d541a42e549846da9a5cb1aca430a15a09167926f475228f516dc33be229b300b0ca459cde1d8fa02dd0fdb7f4f4e9ac115ae6c946fcbd0bf76c294ded781a1233bc1f116d7b2670561be158d96a1b3bf1eb9cdd0ab31c73f07ceee6e13231a9e9afc8af5c1d6c7d66508c69d683d861e837b5e850a95e2797efb3c981ccff0a44bf90c4e792f132509f7e03a84d18f13f535e310b5b50c7aaa513d40dd5f6a0971ed6b638b69b665f7aef236d151cf4b62c727a6d534ba93d66d6a885a9de94cff196479bde495a69140bb180e67129036fddde89235dbdabe43e6db4e2123fcc3a8b6849a6c71b3494201857abad7aaeb0720415c006881c3fbbae894f6418c2130d00b1d2179eaaadc0937d0e7ccff84ced28cb11d5ea09df793c6e0c7963ab3a2725a855ff821541e6cf3ac21f91ce9f049dcd16634aa3b75fcf451bbfcc216fb616ade4fb99da16f161f6ac55ca033a70915d36ca179f053e60b8aa32aae4e73020b34c6addc61b0577c94006192a4b18fe8d15f01967972de8eeed78a829c30db3a79b71395ad15057629c66d2f533ce6520b1d72b48f4f30be927349b01acd97a1ebc240b4fe5ac934a750fd498d7a0cdd171972864d833622271f826a50947079d6c6ccd140adb43ad562c61aecb98a0a30b3b5aea307d0f94260c7100d2f2c574c6577d73f57a7ec659870fcee79fc2a1a9ad73ede31b0a8d85710c41b485b666c058b48ac6f0bcabfd711614eded2d1664316b116d43db5e37f7831874d7251325909833bb4d52984b659368f7b074ef355621e48ffb97b491d191a525361e17a49db1c33e91ad3f0a6309b0cd6a3de22fb5f2b82eb4fcf21a7fd1936baa49cbd0c65ae5c86b5cebf6bf2fb842bb5c141490a98f6abbfe244ef4f3240fa207b2755c3ef5edc5b77477dbc3531c2872ad5d4ebd6728f7f16225a2cb4251d850125c666104947723ecb4cd6b4daa8b2478a605327325fd19fa4fe5d4db1b4dbe6258adc687ebd2896f01511a2abe41240a558ad576cda198eee2b603d3bf2f20a7241eb6ae044df068331b980de15796ea6edd5b275f6c2b9831620b87bc23001ba5b3e287807db4c7c497ff9a2dc2d1b583ba7c04b6c4f4b0167715ad8b7c7c6339bd0396011d511896a6ae73c1db0bc327b1e346aaeb6d0c45c6aaa10fbbcc9ec38ffff7a03d15113e28ad3b39caf8b28bf7b9ba4ee072a7b3697c1005e5efe3712fe1d1cc731bcc1386c6a812382770197498fc2169a309307d0804c053bb5ff2804092acc716577c403e2a260b2add56af1857b7aae3320d177923a5f5edcbb9cb3e228fcbd2f087df33fcd2c72b8623c1c459cd4c2110af817971d1c8468d3f44e81d3c6de0e0b146e4d7394c36c7302a20077dae5e2ce571a297193e4f96226d8de02e31337833a92615d3a17ce183adacf543f3df8f7e4e3b1390f8a1b9ba7743e41702a95fbf9cd8d70398a36f64dceb6f814df3ca95dfa13d66bcc12580c24c6a420bf4846216134da497ef2ed6ca998273943ee5e68bb5892847aca69e9be0dd8711d2f565f481f5ce468be323903ac4ce147d4da2cbf3f48546854b7d2d249aafadf898dcb37998dbc7b6d6e546cac8ebea90cb9ff906290856f68a16a6b2cfb6a606a45b7cc6c5af0e9797f4b9a3d944adfca5c15552e80078ca0e417557ab7d21e3acab927c6cbca5b9a5604dbe7fd98ddacf63c751e3b573bca64d1e52705e58dd4aefe138dc84a4fa9afde698c9797f4269133ebf6450f1bb3b1a9ac2cfa11e07eee398db7384768265d50d55f4255195b1ff1c518dac375c64fea893794454ae6434b130da5c1ea30c72df84ec2446bf8025a1beefef5ef313e9aa034384411bd0f8ea147acf8b4bb6e1d5a655396be33419721427b2a72279fe3dcddd187366e643f60fd57bcffcb15931acff9fb5d194a2d141c8c4720f4293049ac402b9ee3449611a083bd2d869069ea77d8a9d3a0df0708b362a54cb3d57c82420897ef6c755bccff2bb65162e2e816464ac9b292ddc77948dd51043f1561ab3d048a96ff084c5fe56bd5dafb255017c46c821ab260ad07fbf219a61bf7017bde5114d335889c1aec3a070afc52092e66ae2fae12f88cd993305d33007031199d8e1769833e31fc29f88b49ce3443701c12776746e49786c7f6feaa6c4d1de84b15cc1076d495d7b022edd5b25075775ebb74be2619028069c440e0f6e0a6a14604339f29dd1a393de0f16cfae93ba0e4fe5331ed77ecac3ec5de4fe5318629e99cdb7d348c5f7a6bbb80ac7b8b6ff8b6bd0406d8fc7916511970d1d8ee4f58bc3a7a58539958df514558e148e84336ea318ef0e24e9d73f3e7e30d84b683c4926cc9c460cb4dee5f6345fc6def8b5aeda64316a05752746c43831146004d831bce13f610c5bf6ea30c48bc75417c515c891c9effc8bd0f3b0cffad6d218aa28e1ba2e3ce43928b47e8def434c203e31761d47c9791ff3d992cde67d3141a17432dc3743c8ff91997b0cac24f39586fd1b74b04b2937a68aa22e269ab3449c7e5ea6fdb505653c8cfd7c22fe14cbed1dad1fa873423dca0ab30c28a81317918d9cc6564748beafece224f29026c44a17dd039bf0bc10f386242aa824e94faee62d85069481af0f4d82274f66cce40edd65c9d646879508d5bd1321726dcf6591a8e8554f6f44fe5ba77cbab641f79cad20189352b0ef5591b0bd5bf11ab91d6fcbd68b8c198fecb0f2358ac56a1f09e54802cd7c18cdae8b0d646d9cbb0cb3f4bd573e9aebcd744c9f543e41c1fbc5e244ea44c69d68a1e5e6d974a37e63729276832be7e0efd3a88a83cbd2f1bc5f33a0c32283647e983f21a3fb3f43a7492943eced18d1bb52da01546db4cb0fc251ed6df8781f53e63ecfbe98772cf02cf0d5c0cf16c08655d1b463294eeb222dea21f09a31163a9759ee6299c2b4b54a5aefd03af4d790f61434dc96486e5f1fa3a28c64e54e59630584a14a21dd966c4fd1faa0cc38d32b8167e51621be98586a748e0c3b7f95a3efb9142d17535a102764b1b205aeaf7ab08223b1de541e4065cdc718a72385e1e64a85464ae7fc744ea54b7c05327f29ad735ddb67582132cca004bc33b0debe1d1b32a909cbd880df2225b91b9d09565903790382ea28adab678b98a4a235931366d837f821e089a7d21cf68f872a709c6d7c1d8ed1ba5449d4a6bb4f2c988bad6467d11240d47d02beff2c62e4ac24c7aff8c3be4f2487e38dcad18f2d9ee32182f9940249cb01059ba2a42517e33452c3ed7809e71b619c9ec59d0ef3f065b0a0e68403730d1481039844f7122437407ab4fe1d738e95efa4237dd55d0d581b6f3a5b55d026bc36d1b0c46f4d4ad628e84f5fbb3f72326b97f67b8b69970ab914fa0c31c799b3b3ec7ba7e8d5047682b6ae05307adc0cd9b1657001de164313359c27e517c78fd4f0c65d1c45ebb3e6a7d652725956cf2b3cc9470a983d340d22ec774adc01b615b25902760fcb75dbb0bb0292542a8a8ba587747aaaa9d0ab15a6fbce5d2c01183cc1e5704631aec33e2aaa93c1fff0bebb6e6d07e475087f53980a7afb0ca1f02f0e7e9b607c576375f32379303d6a27cdb51be981d3afb628180126321f9edccf5288e96ff7f33b2f9b9eb878b3af331b5a926e6b2d58965738d887d696a06db0e30ee1e0c05d8bef76c59e9dee16c43af7100bace0807433fc37bfe160d1adc9512afde212197d14d24524951bc562066d0efb91697cf5f8395d7cc4fe1d2f83a389fb9e7ddbcb8b540c3ee98770e2121e178c4e626740e734e49f386720b3d37ecb32cdba762da4f648a306f863321c87820531312febbb2d6cd25281e25432d30e7df6b10361fc24e615d5411ffd97bd11e70be479b9e5ee77de4c65bf91b1a9c2300f140b8ec70e27c6c3efdc157e29f15aa1bcd3847d96d0e6e6ad7456a751b01d98ff44c94b64fdd034c45ddd475c5d6a48a5dee0320d53cd44cfa843da3c0c403b7cbcc901804e1a87866959230348f77ad19b7e8ec7fc83421ae7ea9246f8ba204b83dae7e814190f0b15cf9370b8da96af381dde19cecc1bf3c817a2ee4ff80e459617bff917ed8aa71b41a9f8ecf2551b0eb188a98f4f2b01e36d7a3813107d0a6c2be597a447de1b46af6d8381f832dea0bc6704c279863507eaf267e10e55684c7df09de7d665f0fb828804b53d69a604f895adf6500cf156b6b915c80f5fa3e1cd20cae3c090797a3cf844aa55b51e19e12ded918367f91daaa57b136d3b91ef6503bc2399644ed5079faa461a3804b73ddcf69a7e30930ddb7c91b089cff795eee77a8ce060b89ad424e4b7c0519a065c825b87bb3bb4e83037628855f975bad4409e88b03886a9aab96222d056a8809e88fa2d8ac55064756e2b0822ac6f216042461c2f7ac669a44af9d85098d39ddb662e9584f41bb0a22bc0fc97758debadc0db9213ab65f117cb715f7b0aa19b495f1c4747d47bdaf37e17bd67cfff5a03a16ab4823cd63de18f13f92fda854bef91e7a1ec474b8c63f1e0ee0507945ef3b38e7a5546f3ae4efb3fe03d38dcc8b7f15e0e7b397c55b6afe5bc1935063b7a23a379148feba38c5712a255f2abdac186f4efdd8e2c2a13bf8cd6227787de6d182ec3382669fc305e57a2fef382b4a651a19788445e73dfd3ac9413ad6ba98073e3b0ead3b4afa8fc14373f860fa6ae28e0b94574390eacc5fe4f9d0291eabb139c838ccbf064ccc976db592382ddd930a7ed2ac0316c6f90b74a174bbab206bf78909d0f63e678bf4763c5655e4690131b58a8f593a5641f20b03e8d36cc2590d8f6f336305132bb2e72b91ee8e09a16b85d642e2d86110ed7ffbcd57dcebfeff897a8636ce276bac5a70af7466951e651188cc4015c252530fb3136e70dfe9fc25c35938d19c596f1eb99127b45f64ceb051de9fae1c9a512cc245895f4a7463732e0fab22b9a6cb8c5515178873d4ae7cb06ffddf4e0c715f8ff1474e85640ef2268b5f909ba52a21508db635f26b64a2c20c5409bbd28eb7719c8d940c5fec24a6d70642d4b5256f3b57d866e7aad95ff0ad5794ceead3b06a2a5f02a68e29c3bf1c5b0cb41e5da42066da3b99f145c05da36907c46edc7b8a22ed0d4cab4b74fe213ebb44adaa0dae37321e0dac2b91f4a3090d01375da50ec38d68f48e0e1d5a6dfd2ad7342a2ab87a8bcd2bd7173d1a75af34ede246831c47793fe4255c9b2235fac7803f70f95795f6201f41683837f3c51783da5a4b3e0f4eb65a384ca92c48b40786606ce3c835a5166f253965c2c807e0f3f110be313e5f2e0d08fab5ff90b16c89895a19e3bb190579d611eea7baf16e1b3a239571dbb42e3615618e520bed81a1f640938f010ce18606fa72b8d9777a642ac9b9ca6abce8efc1e64960ebd6e307544fe8d88b9a3446925bc77771ac9f8494ea761f4494e8c1012f5d14ea2f2831565735dae7f8707a0349470a9347c159d3eb7ce1bb599432f59aeec7d58dd9b91abe145a35718d836641e1636902ce14fbd50b38da6cce8bc61ffed2efcc1d0b5da3474898339f27030146bc2d9e3a86b69c7c7388065627fb969a55cdd0be0d781b97ad46e6ca48bf74b0910b96c329a244918e73a337d3505f0615b9c4c7c4987dfc4e74749e041a7be08d2dcc01de1d57a0684e72f5bfadd34866e8083c2f6d6e51ae06e2b672352d4508b7dc0621871974fd15afa14cfb8ade4e620e3aa64657a780b726908f92f97d4713f3e292ea8ad4ff8c677da02ad100689e096ae78c4f1af42b01df0d3c2446f646449f30271ddd315b2e40d21672b502a8b14314ad7d6457d40aa71634cf84620224c53492f1aadcd2f63154c4cbb9b04a9f59970205dfbf0599322c28019730bf20af64c10338bfcc8aac28d4759bcb9a018abf87d73c52c3d9aff31a9a3b87411e26fadbebb781629ec2573e719ab16234991faf83ec1b38319f8d07dfcf0b2287ef3252a9c653f9c86cce672ab937587c5eb2132759dd14346d4d08cabe6b45b03f230e505459aa36c4581c33689fee6f34303b27c49bf9e200b61fc0903a31fbbc8a975e93ed555b3da205254f4db12d670e0215c6e31a1e3b90b785ff563e823b2987861a1bf84add7435db23b6d013b4a97f30ea7e7444ce58e83f101f4328ec8b41215482da17891dae8a9fdc47b0ed4cbef5701f75c50db5401cb0a1059c85dfc4f253ab67546294ec79c18738d8cf9a1a25cc293e10c71519aca96d79b7f3349732765ac9354533f87a4c9c4fb59aae0c195a12d5468f56c613788606cef90f43d8a6a09b53bcb9192cf18dc6acd588989202835b0072e3442e09f76ade76ce111907da9ffe26b4422a998e23c7dbfac52d10a086750a3aecdc1e31885d94b76d7f92e9e846156b4d17f834b545c00e924f560d6ee43c48e10ca375eb1fbbe57cd8564bbc535ea0f29298a5a54fe0646207b9357be07d9723b57f3730355cfe2dfe57c427605d29e224e29aff9cd9abd329b3e9c6e6b8a1ce53ca7f28c2a6a0f4af71fba93b08f714b33824e10fe30cd068b1bf81880645472231fe60cc28879d037b7da6b5b90a7a17cfc6ddc2f7b054fddf0a7f630c9811adc260500dfe38d10201a90bb7bdce5afe494f4669ae93b93e6cc2e125e0968ec21e723eb2d41e412e2b20716fde11974e01b024d168a8b1b6ccabac9aa7b9f488624c37e329f88e0aa69d44f42c3da8366370b86cc7a21b688e1e5e1423d54f5e1c1a17ae19aedca97c08e8a2fc042f56bbff02b84e9fd426fffcf21457ef1afb577121b8edfb33de78b49e66065bbb1c9ae19edfbab5f6cd22fc9d415529c0afd635140749c767694212e5154b2b4961ab8debd76879094cc1f20d823b7bcf716eadd598d90629c4a8a6ef25f4a90ce7acd15503372ceb79e04380b092eaa67d9e1916e406a64c01502010394610fbb9bc84f99cf76b757ee9afb8856fc6659405e7f4f0e069427fd7ea743e9354957b06e2feae2f87487a911f226988e2a6d2e1fcb93a8f2bdf0f43b0a53079ed4440cfd5e9c1375ef63345663d00f7d537ea97ca0b7badcc2f2bf06aec10900c5f992f7408832a02c642f3d2c0469e0fb8012192bc843b2fd17c3abfed469aaf4e3367dbd674b76e150d4338411b9f51a3d56ae956c23aed5262554c88128c17cc596379fd43e6913aa90ca6a2038d4b2aacd74e9de42288da32a3b2a78276ad963bc1c8ec741c8f9116ac495dd24af2f4d3ac0c68d8a75a1e6af16279e4d790bec1b52d35f3414fe6e56ad6753aac467ec5fa6dc59ff4648832c8bd9c1859c0424a8bcf8a19c974350e3ff753fccf520188f9e9e6db54c24e8a3118e0c8a5c2eada9be03328e0a59a238a3eb2670b68a747a708c3634d648c16c6231e0bde534ae8183a4093a8b32245838d76ce2a9a0425ade2ff249168dd888a8ba2b531675d5a98156c08597299da8be73e48aeae9ca4f07821b3bdcba32c37cf5e9b0251598c9e039f37d490a82963fb6333f2691462ddc78f331c6779e53e1a8ee1a88226309a47896a32d5a5142a8559a9decd05673fb2f5c2300c62b790d038193473f91c88fd6c17186bed6d3b4f2be6cc09dbfceeca47417cea13bb5fdda007b8ae685ebb9ff45df6a916db8d75b6fe7b3e1493cdda598be3ff50f817983e285f2708da1d964613e329709c3ead0c260ce46fce49eb1d7ade2fea3a0c6e459cc54c1598090e2bade7f2cc0a3fb9f55d6aca242486beba873fafeea7973564b161eb9ca8b2dbd1d7a06b00c24b72ec43fc518f1bdc0c6a2fa5586fcf9e90a6e867b743a2a584c7cc01557ae968e3ccb70883c773da828438938b9c7de46f0b3fc147f9ec0bde5597036357c20d5b3a9e1f885911dcf6a890644071614965d481e1ba7c31b4926209ea80fa2f76bade5bd5f84b2017a0a9a7e660f001499245b01bb99b27c777cb76706539d99625f68815b703a6255c2ec1cf4bd6b1a224ada516614752ad2a70056f0398a4d43d69ad0c3cab4a5a936fa999e1e9290667c661758c029ca5d1c580c7f16611c11fd543bb82f68ca00ab3ec9f514089f91eb0f981491f52852a49b0ba477c34fc7fd3cb52ef146e5112c666716e14166d9d7ce7da4eaee0955b5066e599853685c37d4ca12a81db9660ef304f0d7ea41db4003e80e4620ee71d26893ed7d9ad0a51dadd80003a5156d7a3426fe5f9b917f898e9bac1c9524fb0d1bca98ce27ef2f19baf8456e0dd0d94328bacd4d08d0b16973dff81af2ca2d14e57c810268f1168a96ad6d052c30bb370f598ae33d697430610475e297de2226912ee79ec8c69f69513f002e3ad23cbc68ebfb5a3272a7f32f3d686619a26bb838e0345eefe6992eaa5272d02cbd3eb0f78f359a5ffbe9bca52b1c260db68b856a4c06d38eb25705e9e5f133b1596d4de6509130847b38e1ccdc49e6e73f0541b3d8f3cf7951aec8097a5303642da6cd4a45a462ce45e932c65963470dc525fe8d603170588f96af45a32e26ddd81558d089a9a9c21efa8753fe0457988faff9cf0ba97c75df2e47cd6a7cffb4062da7b7baacba0da559483f48ae507e1f7bf990a413f78f51d71eb05932a7ee782273f5b6e2d68fb8036d80f2c54c91dc112cedcc1bd8500a5b5bbea444b83693b4b16bf655cb40188bd396744617c9b885b125d3b460d96ecb6fabd329ebf7381e48d24756684944febe72e70e98abce2a9a18695f6628dc0169d99a0ca0fb2d21c57267a36b7dc9d23f9ae92450629c26a01170813195cbab88e99b1e9a1e7090222e21248c2b2d6e4ade0dcf09c835ccc6b660401b1fa850580574259de7246fcb4bc52ccc4dd5f8890eb71d285676a450922ca79ade3a9c049d33b63164451461a56abcf3e228ac0b158d4fe069194f4ecf26c34996d570a1c97615bd57a22f013aa9ee03e10b514a2df674180f6636b904e2a332e22ca1eb0387b7cac50b4de6782e152b3c9a859a70aa2575f9f9e32c6442b275bed0dcadb367e42ff5a1a01d3f33895e3347fc7483706dca322cc763abf0c46a64fbb0ed343628ed0d635d03f26f97166ce10fb04cf7e1c2ac8240701a67b9c7f70340c7d936f80680a92c26c686255a8db206f8eadbe3ff963adec0d9a2c11b365e4c84918e595ee995be369adb2c84e54adc7283d424fb522a0ae043fe56f8d0e65d33806ec95d7bf17a6bb205b9df8f970c43e08e70c25eb553b5b3f8aec932064ded54835282ad9eb4ab73f2d64a7289745e348a8ac3179093d0dff482542b44b881a6944af6007f64f5b225ef30c9641c8fb30bad1ab38a14398fb6828581013493085ee858096fc760ed2611465ec0c3eb2c8349ca0f79d4d29a0a4e1a115002135a514d84ffdc79d87c898d3a1740646d967c979d501a9f606483ec0ec382f821c0c922decf9b7d87605de78e91a7b7919a9e33595c82358f2e961c35406f40bb503b8363a12a0c014e92064173b7744b7bb4c7be783a71113843af807ece418a3b1ee3f7a10126f3d17585a644b43c08d4d2c3f393998a5f77aa99c744830234c336dafe86e7738418155d1869cdcc85453818a31ba261e5c1f6d30e219d368e314750c058150f23ccacb8d54bccdb797dbffad49179d005f9e173eac0bf329b9b83cf26ed2791691b7de29442f21f6dcc6403e518ee0cf8a8e9e4c9cda483d780d9b770774688a71c385a293bb2546a4991ec4e76b74836772439b3130492d515858c0368e68f93e1fb727b031a2fd6111d4fdc2c5c62547339adb2e29f9b5d46cdebf0f50cb8e9567c6023025e803aaefc8fd8d1a8d9131d64db9e284006ad9f7a636b1ff28436933d212cdbe96f9b8c53716e08fb5cdad2e3216667e68ea4544882a22542ff99285029c77280914deb1a457398b750d55ef6334246d5da18d0324f67ff294f0c55a8eb1ffd7e5f13fc1a04d821a8e65d95c2b165ffeb9a629fd1d0c63e776e949461c1ed965cbb93f1784714c7e64a205fc3e85bb5d95647b0f341b783a6cf6fa07f25bcebd49c51748a88ef9492a23b75ddfdee4d86d8956d9f7c1254693a1049dfda3f730a6bf5777592e756c9332245439e7001f64fbe78551481890b7dc140ed1767b14934e09fa274f9ceb5a56eb67fe3387db4ba4dcf277e88fe403b718a40df64411902a52a06538a96afdb88be06aff7a9c344de218ff01fcb2cdea696263d49a2bc53c803addcf11e875185ef7304ea352032321ce529393a7f102d22a6bfe771d0970e303bf00a9b52e747ef86d9d946729b935eb68b55c8be3327613676a261d9a9fc82591a4486a5e2638220da7f6608ebfd2d289e7794c6aecbe8e45edf603d79b8485cacee8064a9b893fe53ec810bfe87","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
