<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3423d9af1c03943271ae8ee1e420e5431767db9f4dee440c1fc75e4adcddbc5ff3071d1598b355b333aee4e5663610baa8ac895708a123df2a5c2c60093c64a8afcb224f8e184ef17f7a2a0e72d9d277a8ab08ad44811edee32ff6101c125d6a11b081e13c5bb380ef9f3829c4b2dc9bf097de88d3323b76843da7939678ed659b7d481ff71aa15094b3f97d37c7fe0b01d2be56d997ecd1af4e27036b4edf9b7505647a2a6ff406a11fa6d120186f3e0bfe9a160457546201bc3d2f3165abc69686d278b16df120bea3d78be07a5937c5d2a2949f870d9b8e4010560b8afb337a7148435b5233e41f2b1c541d26b9798d73be252d568cc607ce16ec8fceec40a597ff5519988ec53f8d1962db53ad10bbba170aefb3b08451cb91a14b6a750f5daf9bd396456003b39a20151b253d3fdace0fe996bb9a0c284b93df9a7106164d0ceb4a82ba3a22f18d17a6dd2644ef1897656b0beba47c873b0c372f986eea4c2262e63f3db770ffcf60744caf40ee9e07a791b97527a8204331dd56b23782bbe34c21c30cdcbd1d887836db52379b32be6be862cb82452168248c5c1dfd94a3f58c79adbae32d8300d3c7f05526b05c4ae8a327be54ede6aeb6a6d695560457b71f352cc58a06e754ce6cb6ec17748a5893cf5d12202612eb6993fc8cdfb5fcac5e5154bf85f5f2f81095bf7fe95386b8243e6e8005b0de6bd60cc15923075c4387ffe787bd1e427f64ff2100e4e4358aaa1bbc403a0dfb4d9aa57026dfa2aedc897f8bf91e8a8a57bcbc83dc8bc3245a2e97b2879da47be9b96dba3434e338414aa4cedf9dd7ef0dab7630efa22634951d7086f948c750c5edceb00762d83d7b9680c63f820e400eb293338ede2db43694a261edf2cb9f0fbba96787fb144d307a76b4796a03a99bcdc1a84e6ce0b379f9c8525719c5794db239b3e2596f0769cec9c58d83e62aabe0bbbed642ffaf3973f8e2bb902f3b8b7931cc7a6cf9d93be7fffb989889e4abd811247241f4560afe96dce29f6555ba72aa6a660aa06c32a7f68f03200fa763ced73e344ab760f8babc8b4a57aed0d4235bee13e1bc1b7aee1112249b0a3f4070d7f894cafff3d1c988ccc191340b85652627a4321540ec46e93c7b01b757fabfd6a1524763bec111d7e4f99e254bf858adca619695bc2ff5a67c7dfe4ee5717de48559e0885aa86bc3377d5139fc814fb12231ab4ed8a323ea14b264edf1cfb3a0d48b4a8b2cdd99ca648b19466f5f267838ae6f02ce3d26a7eb4c866962abc4e9af96f3938d76f3e4ac184af69f2ad734a167db2917882b51f53dfefd9d0aebadf7538387450bae61d1669fff47eaebda1d520c68c7ac576e19b5d949064f24850f8c88ad9f5b5010d23cbe71f75b8955c575d06913583bef1c7a12f8cea72d75c3525a59ce29a650221ea47ac563ad2b242232c95004e00be6c4b1d5e8606b0d2a8622ed59d43924dca566eee6588bc3cb2c541b4824683eb41533e399c9c0f505690f04caa912efb88c2dad6b63e12af9bdfe34aae62c1ca82413b3107c6bb7e9ece3b1ff9c258fb76781dc42660ac2dd297ec907539662d4829c70f9d3c5154461fd4877cfdcc3bb598de5d0beb0b82bbe0f8d27fa6f4bdf3386aeec855fe2e3ca4d32fb6e8aecde207dbc5dd7721e65782176885bcacdd4b10f8e58e1a8ec8d8a04f823e823a328ac5eb03fdf4c1ea2df5a47cba1f89562904de6e9479d637f86c1dbb8850da197d606c785303b09b534ea2aadf874b69e2202cdfc79004a619925f19fbc7979d66048160c7c9c6f104ce6536d7a2940a57f37116b9d9adddf5f0a6a0d14e4f4d9fd8e4230d0dd20821fd34b967d57e48fa0801241f87513b713f1f933ebcb3ba77310898f139049915a9f1e4888feaef0f6988fe5813dfd4d9f93342c48a15c801dae9af7bc005425011f28c60dd25bc9c5f6819912e3ce49cddba9680d7258c8a81432388d66e4b21d4ffd9013b812825456921a4f9fe1aba752a169763fbca25a5fbc7a7e5dab5f5f9ce21c857a156ae9b4bd5712492c38c51faeb62ed677becb154e431ef581ada0ff6e48bcb78633ac3046bd0cb856b36dc32d12e5b294cb0057ad48a6a37d43d0e49551a31f98c63df46066b3e8c7f8db8a90839757db4b6161b6f184f57fba0ff5f1fdddab1fba1c3b1094a4cabac3eaa52e1ab85d62eec4cecb601fdede1a08e1b2792116c42572d1505d82fafe358774e2a68c30b64a26eccf1c9e3c14050f133aafa809701cf0de49a46b83fe2ed42fff6a9e4dd4e3662a17637223db38934b746e73272b500884e32e622418d15e26300e81bda11b4eabc70feaba59466f67f49e2eb75b9f7cc9f8be114134b20d9da93736e12e6bf8f5329fa15825843ba705171b0e1df5d36fb1d6b059078e603bd5ef6981ac9bb62a8c77c0ba44f71eec1ed5678956b623e27fe66bda08a35931dab4f41dc3ce870b7717c15968c07f3eacf51d6a67ceec687e75e8547a8c02fa584b494597ff4e7219d2e2b4f2cd850ff3585cb580f845738b008fd75c0a786261ee6640c48b83c3591d84552bce1dcab9c124f5e851cd0dd3688c0f4fc7c27454b82e148c5054298cd790ad695369ab73be3d811bec7fdf52ff1692d155e68aba038156d500a4398ff8177ae774e8b709538efacba19cb61f3f8a22602ebb5e213a4a156fc55864a4c04657e8a3c383cf21226c2202824d577ca0f940e8b1f64168d55444df16bfd2860b8c529e3e4fb54892dec1f7a4bb7e7290785f50ff39a1a00360a3e65368386986b8c47983ee7c7c6fc66fefb3dab5483dc2518191d0153b1614bb7a10d896ab6ceadf447971f6dde3dac7f9ee67d18b431bb82a2b203f2623d2f9188e35cff86a3d98bc20b600e0b868f20b5355d33b064772518f06a3f72fe8dbbca1331aa770b1de0884168f5290479e1d454ecde6153f4d3f696c2e3c332627d9b8667edb995a7676e836a3386cc703b1c7541333b7973a70c3b6050067e7d2ce26a5d12a36bc22c4946fd8a9a4749c7b5b8f461fb03da74ee5ca2f77578caaa17e34bf3621a8d403fb5fb95cca05e5eec1ee58062aabda5afca36e67d7bf2ea073cd12164dc6c9a86098bf9a612880b85f2f5b943499ea0d141c9b5ac01a6d1bca08807a3077d13e7b22688112d1d52442638fd0566ad415defa77ae0ce3a7764ab245e2229474e5dfbdc7bff186ca0521ef8ea4bdd7f543f1bc66dc05e2e2d3540972b6c4d90cc89b214e8bcb775bdc7d9574907b3f5f781e4114c4a955698f75d0b579dddca6250c98af20698d6ac2f53eab9e3c7541afd0ac8ecef33b1bf5534e07012dcbe3977faed8bcf6d4436f592ad44597103f32a200d31eb84cb09547abc92e871781daec4fa70214dde03153ea35026b1d9f3a654446f956fbad188ed0887323bfe012c693b25a587d747575a438bf07ce7795d1b9ec1cde21e15f0c2ac9525fbe2071d14303bb3dd6814062d890f8ad9601489357688f65279ea92a7567269af8b032d487265617a36100b9815b6fb8432e561c1fb72145bdd63056a6365f38e667c7eac447a377a70f24c1fc3dd563ed1b4f7781668f8691e0dfb8e6fc071317094998cfa55b073dc5d373ac623d15ea7dd4b7cfbb0eec067b58b13b172f6dae02e8fa95f75be074a712dcab02345bbc36d166e8e51e9524740ff337a5739d0c7939e397245439ff189d1169311a4b9ccfadac3960e8088757333184144d36f9de77ff39d469f5615c97ae7a72cadd01a2a58e5f614c264464d3b51dc903d1304fb9ec06361f44f86b318c89ae3b3500183fa4a9ec5ef6ba4ceb80047dd033802d3aa785e4e83e4a73779eaa0117208a4b01f458cc29a22f7b559f52d373187fe7564775756fbba3db46403e8ca6eeb7dc10ba7c57801dcc91e9aa821ab8634ba7ebf8dc31399f6645ec4186e5c9e858b42ff8bfdb2a8085ac87e72dad782bb543ddcb887362281d8f87eacfbb55304e3610b94523ae2a1197af2230b9c9b23f175c8f0f9e73de8968d4776e0d54f61d56025ede788ba7261d914c71807cbc0b22986b1a9da03726c951559426dc5e2c39dbf0198f5df67b6a6eb76771c5da424b0fe243651a3f9d2183a362a647bc526e16da1d60ac50724959ebe7b94ffb6346dc5eb50e5e9a26bd4d602b56af94a4d72fb3ffb7ba501db4eb66a84672187216eeba2ab04ba4cf8763ba66bbc0c2586c93612b6dde08bb1a23e9699c14f609540722d9d958a296056f60a2556c2171f7b9ae8bd6bfed7cf9ecad8ca4fb17c484f2dc7d2e05e4f255fd2e855627dcac4808067d64ca96b2f9bb3950be56fb99093a354e12e868790e5dbd1b05a920ac8827025fcf010b79da1c2b6fe8fbeb55713f761fef9b7902ec87e78edd75e573656af2ef3b62e23bc4c55c761b46358cf6f781dbdcc39730ce9c293bd67241e1144ee48d8491a8b5738f8fd12bbf574c75e2a0a28d1f80243d6fc3754e7e7ffbde37fbf1421e762b0e5b9f10d12ec42272791417672dca12c24c565832d441f5b4cef125e1362bb17d32f89dcaecaa6bde451a14c44b53afccdcd3bdbb7bb147acfd9c3a384dd9afa092d61c718473633fb53e7ba0a9096d8b7817618ab29052f2e2141e8713f0447f906bcc476b71c06a678e0c62b0a96ebf99dafb4101bef766db1178d554275a775b14f1592fa16ea6b1cc027edf5df3ed2a118984f741a8a6c164e3967e3a65c93a6d1197bdeb8a3e2b37db65ea674d19cbd2f375ee6222ccbcbd89666b0fe811fe093fb1b5bdacb96b5cd8a667d7a0859d1aede6dd59619564b917965666087c7f93b930c2330b6c167a5ac52fa4a8f06135cec96e417272af16f9ac93b1d0a1ce36273e3c0c026d1576dc76b1c5786d4ecaf2cbfd4223cc52fc24476e4a756321372fc0146030a5e0f26ecbbd2f32d49c482ca98b7ae6d873e5349c9eeb0b59d2012f09c8b71abee60318e718df00ac2fd8b2acb11bdc969fb296a2fb64d238ca4c77af54ec0ea5fde67414997446a22842613e1b3bf85cd9d64c83cdcfbf7a300b5ac260b252a601f69a050c11723158efe6cd37a4340a567b0bdd29dac17483ad89a79ebe80326dfe41b6a70fa4d087ec7da09fed36236056c3078ae24a55a6202e2c679a2a6cdcb295297bda3fc76db744ff8d88fa695d0ab031ceb55c52f0730d72b3f77a3ee914f3eb6bf448a1cc69d975747e2c2dd40c303e2d288ed4f10b582ce8357ba7d96a12df536fb31eabfad0a86d318f736fb86efd7dab2d513596d0eed3b39bbefe83ab979ef254d6d82c923ad584d857b30b89464ba2652591577c98307acec563f32da53afdf3317f46d036b4e541306d1d8e4c67356d48de03d18437fe787300daf87790dafe9717f59e0d26c3bc54e601e9e065b9270fb2cee245d6931d13dba9b74e43d62e605b60fd658c15c35b8f67b5f7a64255e8b253d807154782b3d04d7ce7e28d670f41d5f74377132f3a47ebefb50f9cefe20e4937d4bb2679b447f70cc0d4647e03c3d06fbc1a94cdd7715a87895b4aaf7c6416be14b665915f404950a4d61f288049c3295dcc9d87a2b92d61e9c5f5fa6aa0225dd86634f1084be07bb21dba99b8839ae2c76b4d108b1c498938aaefd684b1d21ac2ad7a44edcfe69c5b2a4d7e2cd162c89e9d4e2a0c87530e5ac4fbce431b341281d134a042bc23f701f5cb973e0508dfbeb34c98cea102ddda48a2651ae6da09b863771aaa43c4dbdede145ae8aade3962f54b72b89ba3e169f0df6e25673d13ac2edae74d6239d86da28c0c38068d44be0e5b661a7b408a085c9f02715ebe178752b9bb7f75217b3774548c5ec6a2b4e1ce5134bd9f7f10a7c17ade6a5ef365b4e212a33fe24bff5d845f50dceb8dabab649eab1aafe4d88308582a9c942f4a00c978d4eca24d61e1befee9cafbac53f6e3569c1a3865247e0bd0515e955cd53e4ae990ddfa095c7c814a5e977d0454ef746379b1a048c801a618fc8a8f1aeb324734e34af6d05a8443e886bf7aa2bb72e3e3c2671b0a2c3b26508e3646aaa1a8d5aa99afb6b7ca97607ce353b51e75ee56e833718e5145fb1b715b1a3565f0da5a813673838517a59c3141a733ac88e78e4082b9de98ad1c1d5ffbc33b418ad7a6ad062bca561aa254762e35999a44463df1348deabdff3ed68e235d6981d364f0c206b01b0eb3794c18ce8c6bed5412ebdb51557bd4e79d5a4e5bfb9e78c7bc7b10f96c466456ceabbcd758c2a27915c40cef28ca4a644cc8ae81f7bbca33aefefc723246738905a4e96ac9603d2cc355618c18c4d078b41bba96cb4bcbf9cea527b9e13f7c2377039d1f1ee10c5f3b5aa2603028db39faf5497bbe31c88f3f778a10d15feb1a41713e6ce10dab68ac7004b8fe975f97ec2e195e2fef07dbbebcbba6595f95b04eace2888c9c1bc4ad052d3e1d0d42d7b5cd5258078a875110b9f8f7e9c247071a7f45e0ef7abb58482284adc740771f876e1eb6880a66cf4f0a9cba4f17e678b5531176826e4946dd12a2f17b9b78d890205cb6f47d2c2f0a2dc63d00e2ef6cd2d7fd41040dd412b29b38d9b69a18d740c35511e43f88071da8e1b1b533220f5b06b208db522cd4ebaabb3991896cf2d586ee655364145e3074d732e30aac24a5ab2ee463cb51aeec49221716861be75882ea566a21fc4965e7a8e813e061a5180d8c0c34ead4ac03847373abfb82bcff840b99bbccb55701944a017028cde404526ff6b0aa4166ebd7d47f4f6451d59c5505da857be89fe7269145485381f7c66b4318f90e83cb329f142445b48d162599e741f8db6d8baaea3a63229c12a83253ad64b34f2148bd981ac4da2b03ee90bb255e5e5a49d9dfb235bf42659720e05a496ba025d9e23d90d5254662a0e804ea81148ebc4e7741f92296e8aedce7f1d4bcad6ad9be286bdfe561d9d2d680eddb025fca85a53e0166bcd8f135294a59f2505548231740098d0612c08bda4a06df3778612b1f735ff627d79688c98b6aee0cc2b57fc6a286d6f30dd165a933edec14a6d4b198ae6a4a5f1e6132546cc4c68846d58433208d695c3a288f1a355d3417a9b02de759d3d537c4616dc1d847d96093b6d7173479a9be9c7d5ecf1354148e1ef121321699b266bc959407bf26ce11358047b703b067729967b559c55a3092f8c7a05f6569f4337f3f84a9271845e27f7f4c46b71a04ce2f70fe0c106729915e1f9a3ab9ef09fe5b366e47d270ad7e95ca9ddf809c1b68e0aa7d139da90e2cdae4ab49d9206446aba1fda2e5ade7f67de62e1b8ee23ef82096933c391c453da7beffdfc02d7e00fa6b89ff87f4593098c4eb82c77e61a863540a8dbacfb7be898ba2fa03fb3670b63f67ed107affa10cf0c4c1e6c2ca2b69af4b8b6fc7beaafbd16248c3304e4b34d97fbdee538857e20bd2b21c841b3dbc7779a25be9283e56ea55a4319136161086dbb81fa5e464bcd6edd2b39b35acd0be1b789efdd2cbd5ed6b57bdeb9bfb00496dad3981a588b1daab65db52f8624436b40d14779bd9bde9b570a582086983a131e2363038162d0d12c7e4eadff444d394a4f117a69853af5871facb2e667d0ff0131398a3fe9253157c9d9765106e85b440dd6e249fb4ed666fca3ca37340e0433e7f591a7cb67f7acd86f25c4f1eb9318734f82f9cc38b9547f41f621b111f9e119e1b861ad07bc4effb568d9a529879814c526001257471646d7d21e02808cb180c811f4f91262709f451df067cd916a60da4839f8abfca1f3a1aca19712cb57d79e79383a967c48c7a7180ae37153d544b71706dd2fa0b715a0e2b21e828c9b5a4e4d054597b8dbb88559bab1daad2bac82b810ad15f4fc02bc4cd0bdb78a9b0307f7f161ca6326057506c92f73d881dba7a22bd4be83bda7acd47f0487747989e17a8e76b841ce88eb9871011dcf5ea2850f415f6a9ea096146ff18f4c6e18606b1d82f730cb735f41e5babfb6db88c69caa2bf6c8074e4872284816dbf79efb126c2de4c8cc404055e2151229c3e80d668b0b1f698572fe17d140425cc745b50445a845516eeb1c157fca160f28c16b57990b29c1153c867641caf629b8f643284adcec3bfd015d79f101d70750697f1ae9850b124304d52632bc3e9194849d436c9a16dee49ec4df090fa4fcab79fb0db611c3919183a2ac48d1b0383af5cc7cd5f57d35828a080894b0af97183fca92b8b864b234865eaf71ba6b022ffa61f1b5694fdfe871950d384b9081e87b4faa94b634ef025b2b9cfa6eeb9d22960bf986e668425a60bf83831fd3023eeaa93f2b2318e37ca20a08d06dc3900f253fc6b0c78a8fb614071526f9057e5814d2f8b2037cb5e4908db9acfb950c1ce3b5ea1f39099176f5a7912910f971420c703ea859f0cad053fa5be9a7f2537e9838d83b64e62eb89822386eae9ab83e6a0ad6c3f61115bbafcdeef2e580d8dac8a466f2dc0bd2f6c3ef3bf6e360b6c6a918e8cb9b83db1655117e52c8cd9a204c8603f38afb66f6ee790fdefd9be0b195e820480bf84b60f8ba904d530701ba9c150d5620a1fcc5c87fd364837c8899ede6b486a0ec0b192b933f42fba3306013e5e0e888214368e2f1fd5fa23e2000489812d570db1031475461302e3b08da57c1a79ea2e9127e67566d55a7c05947e54d5aa76060e3b89eea537e744018a90a041bc2e46855d6af3677b97dbb1b8c9d90c037dfaca43fc6eeaddddd5f6fb0fb4836fe542b02d36eb1c92eba00f8bba1cee0a2a67859e5b6deae374edfcc9c536b52a37f0a9924f3b8881d0763a82832e7e6e8f6133cb54d4a08fee3a62b9785d400112023cda025c4dad416560251e881cf7bf8967a2e37a109a788a94a31c749ff8c9c63035d12556145e4b3ca360e6b5fc27dc09cdacea9e01c16c480c789edd002c75b5bfee6d1b3243095f7374bfa897ea1c0b71db195a252627c7569d9a3c84bb35355c6cbfc4d02c8e0324574a718724585fa8849c3edc3ce8ba2f659b680294b20b228f9fc0a14ca077ce1e5373de380c18981e466738768ad13cac600082dac9bcfb40ea9161657a679cdd257c2b188f2ddbc131865348802d7b6fce3ac6f03fd63355e52c109ab925ee662a202fce2710a1b324079869ba4b9abbf2169d3d46636f598a597d69f8963626dfb3630a08165adc7405980438b4e90c4c7cead211118bcd64491431fa30512b90081f3d016742d2e582df34893681286573f46831c34c9cf7d44a0358a73cd83870b7e839a03fdf7e639d57bdfada9c8b5c3335821351f82b07b667b3594e90bbeefd589657f57e4080a703705876d7abada9fa37cc54f01cc625c5eacdeba2cc11d75bc29ee74573b5e345c23eff6e81af622d06e1d7d16cbf0591bb5ba75323048efe4345698c4ae7458c78df2a91a1778bb2bdc3cc86aa906384ed89f7274872fd6036d49172739445aaeb3c175417c8d2fa2597da6d24e24cfdd0e8b3327a83ecbc7ebe5c730109445aba4bd0678fade01029538a740ce576e94f02fcc2f785856d5e8a1ed124c7ae134cdb2e54686238ecdab5fa850616ef0ce792b95c9006ee3f14d3268faa43de195b6b3adbfccaf6695b49d4d965176334cafacd6f96452dfe40a68d32cb5b1825b72aed3de8e2249b621a92d9a1131108982ee7be5df25c9d319b99ac704a52c1aac8a74bca2107eb99bb0129362bb6daeff60dd1cc9ce4786cdd56724efbd080e3bf3e8cad80e53bc3f2c99fd1a3f9b330d14e47943d9da6cfc31746c274ddc5d5920446be9631efb99bea5d1b86306c9df70574906f1872f73f9acb6357fd28562d703470bb80668ed14f0f34d89d356e6aa7a831b6466f4473ff7e2e89a77760b0720906957934b0ef061cc92d96c206fc960c7de2aed5ad5550292cad31e3cd80e12a39638a811d72e4a4ed5b7cb5ccee23070c23493567e26577fc741e38d8015350afd7e5c396ae68028b724823d886ec6ec7f312fbb8a56e2ebcce331ff4e32873255e8c1f19d38db254dbcd432b9cb4b058b492f3e6f7dcd337fb6a017618cc730394164b013a52cdb6d7fc30e216436c2adf86579e22750500ec075ed3efe6a30fd8420e73c35140d0e9a7e6db0db315a07c9d20556e48446d44a51cd06d15278bf433235ee000c6b855b3bc3af05bfe3e9b6558edd1edc15fdaacf2d55813f234db5050a469c57428c9cc7f1f0aaf7b6086b2aa4044d88ab3f313b3d0fabf1d7721fa23c5f49032dfab6c8bb90763c9210e178e9299063de78e8476821524bfd2766de33ddf477bde0160a575ccdb59474868a98ed24097f3644637c55f5a1d86fd27839d3cd6a99eb9e537905cb6f2a9b96634621a4811b8a041571f7e586195382d35835ee57e787e78714c57e5e40295aabfc55d14f24b62b586eb1e28c83684bc52cbff1aceb7da0fe24f9d16582ea558afa3a9a4a56b9d5ae39849e8468d0f164f56f0862d6fbcd36588d1b40da6a6f48dbb2117b7607f0021ed85db49ec0567f625ff644746586b0f0b0ebfbb94f1f980c9346e745560de1a1e95504fe2760e7ecff803a5a1eb0d509fe954e22b3fa506851759fdb518e70ebe850559b704312646c9d83c2d896b6a32e8691d8d949cdaaf417f454fb39d4f89e17dcf8ec9764b5da4868d0f86dbe1312cae1a7d74dfcaee29d4717cab624e0c7e6d3fc26b970d6345cc0a57c6f79d71a435a40e1efb792b4df048c1b8f6139590b17e0032268251b50b77cc6145a0081fa5a6ac6bf4e14538fb76087c30aa8926e78f1efee17f8659afee6f954039941d5ab045ab9f810faae1c830cbfe58ac0943662c5c86e2f172089fa753e6d5f929aa08f8ea0937a642b932eade4b4febecf0dc6e6ed5fcced4c5f8d41f388c1a908bce1d9f67a0cca546ef11d9c17082f61571a1791ff842fde025ef234f86c6934ca778b3c41cece228372238ce26cd682b0c6938858ee9c82a9d5d85d5650451d3671d52f8e2452f783289bf7245004cdf1b737c179d752aed828c2ff807a38997f432502b297e015ac64ad17a23655afa4c30e19242d9b7121a6d81835c0e08c5d5d00445891a220fc0fb4ea5ac50c91c07b69a89646a0a969054bd9d215e627336847806668d5dae9d477a7f214976f08959d61be027eb3d24652d9a667d2758b4cde0259aeccc3ea0ff74bc442a825f5dfa240b10ea24a4fa10f91f0377ae3ef6c8d9ae030f32fef4fb67f735c8fe2d6d39fef59b5fafd1ab2ea8ba07941c8073725d2f04581c43046e723728c92e265426edc24e65d11041309f33dfff1164671eecd7c35141ae04fc6170b48797b8a5ea3e3040c879f8c5c6ccd9484e39920eb9efbe6e34a78537b03bae1856bbb4c3c518d4217afad656a3b26d6f9222241fc16d98e579d91804f02e33e81d77024d09425d47d2b638c697b0eefc5217cc496c717a03cc5328aa5237b0349aeba6717157a365961527e6b2890022e94c6efe1d7a34c4ce826b2ec2d68d9d5cbc69a1b47cd995e555d81d4850c07cfa22e1a4cb3150eaeb7cd0c89af59f6da53a46f01688cb433280f326e1f9ed7ac0c240ba27f6aea1ca090fd13d72a4713f1206925aa8fe572719be53406a95b06762e3c00289fb54c272286518c5ca9f72164ee366de0f706c96387a1fbbf4be6f886ede621af3ac582fb986790a11cfb4ac1e4d49a76d3e572971f29b6646398f114f6c258cdf29742dc6a96eaff91ed76c82f3888b86f4fe78dce2efa81adaae11bdaf6442dce6a69e121d0b538c27add2857a8333f7fd57afef43f6fa48ca4a10ed5494332a61763ee9b3dfb0390d4c106f8e24a41213d14cc0d63ac7dd1465da86a3ac24fdf9a7b2a059ffe1a14670009dbc52bba46f09af128849a34bfc73377fbfad9bb37413eead08e1d87e94182c4186c565493550b20a478d643670150d9fc14eceb202c47361eab756bd5a2d1ef9e3078d1f4a4c2e89a35b42411570a3c11992f45d3bf9add8293b317b0c1d92eae69c16131b520930d98c1b36f8676d73f1fd6d62dcd5de1baafc505b0938ecdc6e402744cc75ef46519495bd84bd9d693446ac7da84e2e260997d650d814efb79c39e948abbb232d48378b0a8f272a3e2668de7ec564a4b2bcba208abb26a17b00770e9ee78d2e45b5b94ab720526bfa6a059dd4f1023004c43d4477ab390388992c629f9d055a1480f83c1b85845aa47fa1f6d2b2515ac0dccff769a5cd1c83725746b733e92f51545b08790f2e9d765344d60bb9ece72f962dd2b3be0063ee74a71f7a66f2476e56cbe25b6b4503ea6b9c55f76a0be94afdf5d4e247fd2bbe02b995573eaf05c43075c750981e0b2b6a0175a506a75658a06a3bad3dd30182b24d8dfa60393f7eae0959aff560c01a9ebd6a8e18879ebf6998bfd2fd43eb339faa1b17b7f910f13d1d9a5af019e1c5feced4f1547216d50c166069a99b853f98aed7e0f5ec907f6c0a1aa00b89d57d5dfe436c742cc5ff2a9a7079d61595a42ec073e296639552ebc2565ec50427fb3e081ece300820f576def9937a7c2c630acd30aa2f1358feeda114c032f0853f3d1015f46bd42df26095bf0b83d244b1512cc418687cbb06b46ecbf108aa990ae48e5eb580b5df9f7721d220a155b860b7b866bf1aeafecdf53868beb9ecbd8a46dbf1137ca3523ddcc39ed5cb3e026867c931cd4ebca002fb236b1cf33c968f2ea66ee1d84062ce33f498f0cdd5f03f2442872276bd874c125b51826b7948a214ebebf50e7760f16c9a9810b3b4720f9c89bf64ca031bf573da83b50422653c7dd5d1e96bcbdc36020fbab08faf5d33ec9ac73f044ff94649e843445af3c7b28f3f1c530dadce7e99cfc35f083249942b95ca6d9c429b5cec940daf9f4c2ac95da564b51084567bf36194c261f96eeb97c83391b60acd52ed45d1ab97185134ab9006a0585ca22f60f22ab0215cf802c4fbd175eb112205e6d582c640a4e1667b92566af32b62fa612c4171bc2231dc6ca62721bccdac5513af2121e183a223aba70f88f8e544490106ac2ec7f6bf5bb47464f82b428b8472b659a081384097716ffa3399a5d542f455b927600144ed8a4afb44a56606a933d01fac93cca8a0a1036b70ce8e6386c56839e8ecce47b81c7ab098f533fa36cc46cf5d031643fb3359e14ba0a8e4bc0190fd43684b5dd66bee5acedb8dbfa14f5cd8a07b83d63e19f054738e4b4a5e72a64f4fd0c2170ed158d72099d86d81bb7e3a723bc7c87978500c20eaaf1a6ddffb3e3cc327789ff2d8132d5c5871e354dc913ec3d90b88836127772dc8e6b7301de1ed3217d2f1747415b321f6171fb832afd725fcfd62b96f47827261dce079ca57291920e36c0747cd47d96db8382093f0ed553c88814f132efc9bf28bb874f43b9c66b55de2082a5836b28ca1ebfa491afb165e461d139a4b4f3b3ff62124135a0dac272f786d68284e4b446f7bde4b85bea9bfd5a05e8c8a0ab4503a8c1601c79db478a9dd8c7430c14d854e23ab1bcb961ae36a1be9e9a935c4c9a2ce11394861061088ea8768024a3c48b184feed963b8f7f2e5f375a0600bf7d47f1d17a80c593bf3a41d11ff964a410060dec5c6e4ae9b61b7e46762d2c6610fd83f6b78b19a350ee62bea3f7f115bc531aeffc9cda1332ed91bc647b12f04aabafaff65c83f8d13e00a0b5dd6a91fb1e401d4428d00940831ec5aa30bfb58a20ca1711909d3ae0a60047546ba10c9688a05715e11add37188101f31648ec5aa869dea4efb6a30973f35b98ee49167898083ea11d25f5080d2855794dbd84f91febbbe09ee33eac982b65bf81ec43ddd26c6b9853ca3c7c36c6d99bd1733fd754a0fdf4b699b97a2dd25a3026fd299c9d68354c020db0eb1b413c79ae8b17350fe26f600a99ed2967dfee72980c8a9dbc63f37a9e41f29e0ed144ec555e0676d8546c55fe91bd011e2426a3f4144eaee282a725270fcdda4a99d391ff391e44f9f2aa094339f660cd3ba167ef9abc1d6b69ba45fea377622a166953ab81","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
