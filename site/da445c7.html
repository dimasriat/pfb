<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26309a2bcdbdb5c9f41faf26bfb288e8eaa08adb792903658c58af04661ea29224a0c723f62f2a626edb609eed25b7dcd10fb2a8be499b5f47dbde50acea2bc4c013d2d9eec0ecb13f02fed4a2054b187fd14082bd5f2145128d29940ecae63753de17462bbaaa0a293580c67f1aec55b264d4ca3aca56ad3b1548b56236c075f1caa7aca4491346cdb47f9921a843e9382e9e17268d7c017713c000e0723d5c01b67a13eb8b2fe1e242e9ee31469cf8b5a5b36efc032b05d22c6f8cb5e35ad937a1a829d5b81e3b365caa40a42ddd44621366b003099bf7458b7b839fc94c119717c05b5cc9bb127c14f8a2039b9e1f86fbf0eeb6b7d1fa1db0edd123a724c369c75abd25c69653d7eb70a6494a7004c8b99d5b8134c0c26e8a6617dbef12d7f5f6ad06fa5b1315d75cc66274160c9911996882376be6c8c2b4f7e2eeb2d226afce080b3074731a607ea8cf0ca34f3916e32774926467f5012789fc085f51f0e0a30ceb3c5734375013d8baf5e3293e162334014aca47967652d370d3889187e2734b7b8d724ecbff89eab6af3fafbcfb272dc338b7f2efd939102bfda9da7ac38968579eab104ad1833447f31e5362ef5d9e2f9bf0bd022afd5e3e757d901ff9fcfa7a2521f35fef78c3677f243ac22c174f45750d6bef1e973a9bc1b3a570fc3829017f2aab87c633d073bd7914f13ee26d9a1b120b0c8fd5b17d2b08084d9b45b04f828cb81c337e3e21950e6b18d829f02783da766cb9a0ed66ed92ab7205055431333c5381d6ce3383162d090afef1263733ae39d744eda974b3d008447f2f02c37658c3a1d4d003b3f851f610236e1cac95b5b293dc02479bdc293abd124e827d28ea3e42502b629c60a88779c3e1bec0049f2ff8e254eee0cdc3baf44ba33e4ca1261a3dbf50050fafc45eb4c9f7151e854aa845e244cf6a9daf20f5751cf0ea97b37f7d78e18215629f122f58248f4e56ec547e339302661f2000db3bb5774455e9271a3a63000bf876be72361b8aeb1d28ef723dbe90462deaca7dae77450443a9b4f6c2f6e2e6c660c70fed9867ecf31ebdf895bf7b7c22c23679a35c46cccbe5d45703f9ddfdad7a43c5af2989795abb0d57819c16bc1daa09474e58fe1905f4e8495514fe2bf103444105e6bce295301e57b8672407dd7733c3677af4bfa233289841b5ff436e28834d8338f2969c8741bc137ede81f6d3b3303844eda0af7e3f0c6b5d843b574bc71b542bce4903c1b3827e94b13195ba74d219e5acd6ff3c94f97b22722b6ade8eec8034e0714724c7b55a59d3d0cfd11f7b6b628ded7862cdd0004b84d6a75407000d899d61fb2bef7140d6045e178387627c8a82956eac4c16ddff3cb63809d35579a3035e6e69826bbabbb481242ac41729e7fa18d1ae46b3fe693e929b7fefced7399df816b015a79c1142f79753d1a0df732066907a14a75540ca79d90f4ceb8dfee1571507d0d41dc746b758f5518e0ba5bce2d9c901f8beb9e6db64fdeafe2dd756ed4a1ce1a9a75f21341f77c912ee3e32ff5cc548137d3facd35cb600b28eeaf9db81fb669870a4603476fdc6f8a6d56da85203e7dcf923e74b1a76481a641811b46eee05e3a4bcf32cbdc3221abbef0205788cfa45abdca7a8b5126d2de7ff0de71a9486780cc7cd51a33f1f3be45b6a6fe1ba7cf3289e1e388d81c2ff2161063542b1bde8f8b71b53a9126b49d75a210b7f6c737ec56f291f8129d66f7cddf98bf5901757de37e134ae60eb23459768b42c09eb179fda19e7e215eb0559ddb74dde3702efb72933433df641bd0e20dfc43383c95d8d3b0f3440f3dfc76fad09efa5559fdb3b50f35e0cd8f232929e94a7bc6b26ce17270ccd1af8747a39fc2d9317edd96ce433b34984625cbde68a041eace0110367b3e38eb54453470e7d016501c8411b7b3f10367909161398f73f23bdf421087bbfba62a5b5d90011ebd9ab22e6c63c61cbaceeb08c314a6ecb5c5b763f85489d0f4ad941724bf6c0eb3aee19446046fda729ab3542f519f76b4cb3ce45c46fd2cda958c85c8522bcdb667b0bf2cec7b854995a16b316b35909cf576ca9f1ee7cf71e6df492bceabe882aca1cfec93c63f7081305925ceb8fd031cc955b19e9e072fcf0dcfe45915745c067a4068d5f7d17432d03e25faa731742b69e6ccb06ceb21304195fe0a3999b2bd83c69bf88bc3898fffc6c2259986e68e93e9157b8f88dd7a0bc6c15926d518d34ac12ff7d7de12c6f3b41e67a862a59e795feee4f95d289e6bbd213c56801f20f471836dffc504f53f8a8d678231371867b4b75a773d55df51dc8cc58db002517293a1d52d6ee1bfc0035e9c9b71302963caf957c4e4928b12ad4a61a7dc47444f637bb423a5d8e06f0f28f1d2f7fa4fa2c39e805f9999e044bd6f54315c18adad1c8dc3f2cb7a5de7ad88b18ba40c06c1f98b72b16da23a3a13f132744c8b5d9523f7997a19b65b7271c7bafe3becafdc1104876008b5bfba717e12b81c8794177c4fa88724e8822693c660f0ef68f39293654949bbb5f8e1e4ca512d9e81264e8cdae91f29a2dc3c8625ac6dcc9ab4b615074babc857499b8330ab9d1243ef93034d1b90ef0147673b56acdd3b4a537b9715bc56047e72f66c6b6a1039a67fe6b7d4a21b1753351ca3f1740572780693c477d6ca7c9139743fd1b4700b1e119c7af51daa6433a863b38426602a0057b53e474b8e51fb3a5e520cc3da3880f16cd637614d4d1f46be484a5a188450234929df3d4327b36a8c0d5c5725eb38627ccb4d71fcd64ce9908e58744c51839202b6992640ebc6784709a9326ce3890e2bf71c4ba2ec2dd7b9f72e0d7b68c0dc1d75a6979ffe2a428774d0602002ea9f64f60ebc50569af64b4a48b129bc95cd6126ce33f604e4f7492f8a9723a3246dfc269d505d1b66cdccbe67794cd54efaa57bf2b0051aeca701155e6827a2035aa775b097289a79b2ed7c78be446bcd5e7441b6471ccc96bc37d5b07acf054738ad9d15eff025694d0b8063d3bd0cd46cf9c1e904f6110c7c22a75050a5f25da673c02af30bf8e983bc5d8f07fcf23b38eca517a9debe6976787fe7fff0c6f5a6919b1faca0e2113c0424aa8082f923cac283676d7a8ea0975771e2c8e91cb373db839d70d41c0e320fc77fb684c08c8ff0a9d0a23fa6935b1a09a74a69618be430b338aa1aef80c1bdb08513ab0fe9153ca6bd33f8c5346afd88d29ae7f79c34ec499c11b14e7e9e60ecfff156ab5579dbaf5ba1506b762abf84fefcf9edaa9bca207b62abbd3e800a1fb3305d2599b3700f3f31f0b17c9b4ebedf06e6e7bc6a79b5239d5fe534d3e2b6bae47a3da090024fbca525be30503425e95ba8b399517b11c4af55eec754730a4637d479ed6d6c4f926c8fe4cdf6659278c59ed9c1ab6216e3c27ffcb88d7e490495860f1d4fa3a0110d389ccbba25d95596b977a383c1adcc58ae81e33ff7eabf44efb5ba6aac526f86a6091992d6a19069ce8c326db596ba25bfb08ac735072416344aa2ef6e9982a7f1543dd73b5dde48f9a076756dde7791a5f5fd0cef325fb936041f0eca3f6fe47471999c2109f020654f66f2eb009f4aa2e188b43d2ed95b196ef3fe1c4bd75951a59e6dd064839c8f87d1a78f1267eb594e3296485e0ab357a8ea819ad8f82f73aa084325183ae1b474bf39521d9d3c7cbb109af1011c80bb9592ad0f8e1787ff67e5c8f1ad89ca45f721524896ab58646934b19bde68e3fc723d0de34fc1b87b854a4cdcbd0ee143bc7d26145bbb4ac6a52f8c26d971b9b3b86b9258fbb54e023f13c598950391371cd8ea168236741188d8bd98bbf8998b9404dbaeec9061bee8306fa573544b49cdecb854d5d2f7b9c67077e08222302ea30486612cd9098aad4c1810d1b45995a15c07dc86228bb224d241295c9b8b81ecc33e6b5a7e701e53927077f69bc0dd071b5c3642a3deb8e52f731007f092f9722ebc85cd1626ef5da429a99c0bbfb49be29cb4d73f628b64043c7cdd20a9333ccf9e3c36b42e77470c0f864b580e649944cee25a3247560e81cca0d5647ae7fc53e610b26cfdcc79ae128d2c8b4eaeb38b42367e5e016dab3fb2d20f7fad6c355f62508607829c3caf4e26812d25d936c2a751380e9f82893d4b0358555fd8fadff0217d5cb9b16e33ba325c1f09a497aaae2d5a18a72a547b71bee1e4291239980629eb60db6986b0136a5fbe1ffbcf133a65fd9dd0b15aec9f13b5f3b2a111ecd802ec0dce4fbde70152599e6b7d49ac09eae2550353774c2192ddf0a0dd6480b6672699048c567444ec1c45e629ffd3a64ea7f96306a953ff3b7236e45e90f4208001ccb1f43e4073aea382911df936201659e535e55951b04dd802484ee6d73bdb8bd6c0e4911b08632be26f6eecd92f6e016aa30fa8c112c96c16f7e571f5b80446470d9d1622543899502cfcd16821cdad4723e3676577534739f7c6a456fe0a96060c0205f00aa2d0f8efa320643cc4750bb22aec12292f15ef41b44e21e2dba1279133eb31c842bfc7b96ab344053902028575a01a745922b71c1ed534a44e733e86ea45690bb1ec13b3558c5e6d22d821fb0bd70d50f6bb2dfc5e1eb0d661d017ce2403e5c3f3f5ba6c80a23b62d71b87c3a6049d28726d6f746ccf7d129f30d54713bf415874670c98968047275e19e252ddec0c2722a5dbc8fcba3afa744df3ce4f0d55a8d5f34829ce9e37ad08ce295b04280a6fefefa4acbabc088aee0cecfdf371414b87c091714b7bcd3327475769f9471b92556d54eb9a08d23830e43cac1e7cb0178811fd00a4769a375c6b9f449e70b8a50a6093fb566cdf223c4cece0f3d41341008392860755db71aed1c8f4c2fdf348f7f2ea6e8d2d147333a5c92acd1fd53cbb5277fd3ff71eb9f2404eb94328d2dc57d82d6d8cebe2b35f250a38dc3fd5fd5eb3302a9d47ba0e2eac4f3c57a144d50d0eacdf999e8572b6adaa5673a023ddd65eb9ae04ff36a03554061275d10d60f4b69594993d0d4b69b03e3203e5b59b711df1a321e3ac456355c63bd39aafb48b7f0efe45ca699e6d6f4d4133bf356df8e7aad1c2df435f99e4979b433cceeca34731adb112336e965fe6cabc14378f161c3a03d5adf4daf7911a5afcf1633294814b6bba776396fa7f85cfc4cb8f2e3aa10709e0b810d036bb88694004159cd19cd287ece69d8f1ec620432194bbb6dec7b6491097dd5ad686d5caf58b2070ad97e116d2ffc44d48da4947c62717192537bf1d3635d1a3d7b15745ead1058ec79536d91a21ab56c6eba7646a0c269d1f9336bbb1186e366a3171db94914b6f014d476a702875d2290eddc4b946e6bfe268890691f3c98287fff8bcc11b5f3ad845d218e6831f16d41c78b9f329bb47bd8d080781658357e561f868e4e7d1c3c8c0df7041f139ffe2ac7255d22c29ce43da6ca1f08b52fa6b8bc7d1ab943c9d53338db2715a84eb444163a51c053f7fe541c399a88a22487f3488f2647f95133b08f92c238310aed972ebfd70ff3d4a0269c9ae2c113f6de7ec53c67b2b90ff653ce833782640534427397e504182744319b903540ff41b0d7a646e3be0cfb6f76d657b5bfa976970b10d48103556ee36e2ea44127bc547ae8ad06076b1743253e2798369734ccc0084f927fe8fbb818346a008a65dde1d98dc2653358312830016d81357e6ec7e562d0a9119afe1b1b4a99e26ffbe14631b6ec6d872fc56c9e5762da0c3af45a3ae59dff545d87243a971de0a432c9c6d11f38a12b321c6b639805344c1c3a0203c16ad73b0c0cfbc0e1cb281e499f744b35fe25bb02b5b73a3a307e28e274a94a87086699422f415348c888728aad3f635473478833e54a24ad9324b719643dd18825d5db2654a01f7a81cb2eccd42b52feef1eb377ed68673f29c4f9f6c56f1bb86806060b53b9bb88cc2c4ac26b0e451f48689d044ddab16c8285425125f36cb20966f9210f4dd38a9822be092db511dd086b41d5d1dbbd215e34ddd5f739de3e13da9cf69852cf6fead8767e28b6b710d80b78aa090ac5b749c970be083bb1ca4fc5774ad6b682c3b82df95323f6cd03cd4b8c7f7d2b2c118bd6ca1e721a363e70745c7ace9c8756eeda8de1cf012bba0b877b0a4e9d7beae824db2c13e3fd0f3e0ff62e5485c66fda4ee325d52c72b37cc4fcb4aac7ed9d0fa6d3e3ea92409d8c9c5a5bfb62acdf9e4d6f0c549759428d3f353d3eb9ec629a298ed43562b94dde7efa53ddef748e207f68ba52f46b4054db4f0c4e5801471c25485e91837876c5913f5de701f7447246002db0f0cd60dd51404adeb6f835ef4851f4e0ac064c264fbe5db6ead15214665e2af4edba3fa9b48ec3458100d03483084b979b0904e9c3f2c8ab025690e6005cc0f770f84cf6371b8466f50b102f4872859174b914f94f4a78bc1de5a8a87950044831d83a215ed45d9bb3571ef33c84fb8a34b31fde8c18b2eedffdbb3ffea3927c8b2cc97eb908856c6f12de4b50fe34d3f0541ae68eec993092dbe068dbea36f16fbb4795bbb36ba4be25d7541b39734c66fbeb032b8e1191f0d1b83d908f3529fdee9b513f483dfc9f47ac1535bc9af4f1c2c6d5ccc335324297726e3ff94baf34f6f6aedf92715cc583c28978cd7e65f1aecbc79570bf4f1d14923496fdbed8c567f8367b3ef6d856dfb01d865ed3cd5de2ceb10b9e71a6659de37dc631913b38f62e2ebb5b891f31746705e4923208d9725a3a1e9a93bca788d14aa1ac71cb70a8344cbb73e1a6ec7c64ddc0e0c35b57d2730b51b9f3fc19d8f7c355a384564b6c8d5fe42d376df4342d658bea37bc6ecda2aee516995a06344089552c8c51f0fd0e0baa2a2bb4aef4341e3cd50c690032bd76386197f441d0f41101c42032a9647468a950ebb7e907c35f7223bca438592ea2a2188f1f36e0d2d59b18a12e96d5732587a27e83cc70de1b2e90c472876afcfe08b3f84830a009740d0b5a37585232d4aa510a1b3d61da5a9ddc946274fce6e8b440cb613db97400ac4cb15d72260179dfb48ee3a11c3b20246670f45c7e80a5cc6cda630c60811fcf21a6d6412e85ac251b2c8b67fe9fbe38939e59103326503162015553a413bdc7d1b72edf33e86b898956f6afb6b03805a92a73ccf07fc5de84a76c3cd70fba25f794309946993bd187c8ad965922a424469a85051737e2f61fef4210deccca0fca8dbb316719a83721d901ecedff455ae3e728f333354582d4509bde4784d93822e8a80ebd5dec94403480a39c2984e7a6586d573d48bd94cc16b7e27865b5601e65027c7b9c8a5ac56a63827b08f7bb8b24f8c17c574b41f9e41a46b231d0054c029c5c3031d4f057ed5c7fef633e1e6698794968236226c8dfbb116cd90eb154b05388b8a8ed3d89659a154a053c3819b043b35562bf3a6a1c0c6e2e4f3c8999a4d539a03dd0959a5849b9a0b339b0885c9e91300580b5b4743e8bf1f1cb4f9e6d9dc9379e821e7c8f0728f938d6cfe127c3f3db6e5d2eb08038da67409b46690f102d51cfb7fb5c2e72804b230526809f46aa20493b4c1cec6959f5932ba88fb9d2c80ccdff2ba598c8436acce3db8518941530744b1a47973788814a7f88a57c6cdc8aa9497fd3431901287577c17ca09177358e8fcefe51c8effdb0fbb7217a9578ae28bd5bdc95dcc2a4ff42ed6a78a9ec58dc70cd134602b65b905ea7c7349ef681d32f8e57459f218b605b6cfd47b335289a87043dd8b9c76784a14294133a5907a9725d52949a1fa646731968f28e634e1a3aa4f386c565ae81e50b10a821589d28feef5417ab46d17e98aec429a45cca2e2e50d72aec74b274b9f36e36a325d1882dc212a096453215f0e03ece871767db8d022a3b90aa7d40ba5d7c900910f05fd4d48d34359cfa495016b16301f29ec0490ae2631620eace3d8813cbe4e9d14b03678f1f507153e6f69013af4ae905f022137a073e4b318d6b13d0ef520d50b57e76a0a1bb98fbe110bceb76027739ed5c2f0bec23fed0ae155a19bb793661fbe0892e0942f61b80b87b259cf0fe1b6bebcf01bc275d300a0674287fd88b0784bd998984e4287ffd5116a557e5f9f1163a38d1d5cb4d8b51805396e8a0ed974bf350e93d62011e5478b2462622a236155f6c385e4735561fd6cef8499f143de97e7cee3222e5bb970f6d8364bb10884448716a78dc878a3f774e6596c2e9d9f4363a6cf2b65461f911703a929ff816fce6e5d20bff88fe0bd75e47c9b9e1ccfe68bdcf7565774d18e3d817147e2b3097d7b9bdf84740c2804032918d266dcd1fbf342e62b7518b8d4ee171fc0bccc1d2df2a44c976d42f58c6d566471cd635e575fad7cb97e48afb8c62b6b8843f89454ecafdbf54fe5a1a53a583a36872b5fe11f1eda571530b4fad7d7b7bb0fdc0e8af806523df9871003dfa6da1b95ed2a3d5b73220b881bea54df0275a3d80a69bd4ca34e24b1b9c028b91cfce6937cca4a063d1be7a2deacfcc1bb3baffc51f8ed0ec4ea950a300fe9c19e0bdb51666df0e758ff22e4179d12b054b741ab789b5af6c341c66ad98e2dbfb8ce11a344c10ae0122e4b0ce5b42b0afc9923ef074d335719015ee70461507a5250acc2a9f0b71fcb01c5888dcacb9508839ba15a3afc3a83c05a6c132909af83df8c083f866f30779899769efadfef32a9f6698ccd39c6c7c93e6bbcd3dd9ff3a9cdbc3d2259e798b6a6bbeae3ea0aaa8ce353cbc92b6f653789c7ef387a7b30de706269223c03bd2645dea3ca2627c8c1046b280849f5303d86a27da56373517a41654d57f5f1648b710bc0c1227acac8c8f1b65345e8040791361e1bccd8fee34355fad80aa8e90af419c5a7707418e5644ffd208b00653b6b502eb8353febc536545a5d7d40927bd617b5e7378c4be371454199438017c8fe858dc735ae9226b44200f5950a68a94da3a54c70d950ab97141d8ddc0c41c72eb802bf4adb3ed461c28288197b03e58b62601e7c36ea694c4ab525ff838a13f4b0879ca2484682e7cd9b58e955056ac701112ab7d47abd4a089cf68d76ce94f0f62b8cef03d6adc5efb935e1a586ea22f7985d5e16a5ae346e23e21cdf9a00c965311406b0272e5d6e0f15c719bc8bfe22de8211549c1a011cb7a1f55cdf6d0d474545ecfab4c5db918549821534b3372504b7ded2b7018b41757d53a5195259149db6f5c48e1fde1a3eade55060e57e9f88b83702280f5ad5ce126bd3989d10f2ada893f78a146ba1788e4ee41cb6aec2f6f4311a38ae34ed0e1d714af3c821262c48d07f6520e25c2c29a43751990a1188072bed802b7b8f9261bc45fd2013e049152f7b1358f3583c4767685e095d979fb257af331951554f1f0a25e7d11a092312be857cfb837fce2dcd309524bd17a5c578ba3d6b6d68ff6b2199a58229d5edac322506e41bb0df87ec5c22ac2475b76d0a31db7fcdd6d62c01af320af4c982c349719cd2072871ee26c9256f24c0e4f38e094f3276ae3bc80e6fa74a7445f60a37996c978c4ffa505d4c9a41cdae5eacfed5662216ef257773f41132b97c6de7828d34b5ff4fdf60588151245f91eb5e8c85152ccd11c4149f557ccb49960e37c11992a52bb78337f0585d345a22110fb554fc5357e6feddc7733c1f9ac88f67d38c8d2a96798e14a81969867caa2f2cbfa880d0a454b4ffe8041defe72772dccb369ff5266d5397b19ba6581d7a8cee2bc96710d7ce1d993a7e1b3d03dac14b569ae98a1bdc130500a43248dae7478c4fedb89c13f8b9cc49a3cd7ee587c695829495aaff995cc7ce7e28cb08da27d206e20d8504aa6d03a7ea0ade3cf0812e63b6dca1094c596b1328da5797757c09f240ba9327eb4406327c6410a9a52800f068f31ddbe8b963c4c60bd384aa89e3f0f027de364e393f0901fcd29ec62fff6e38224132b0c40f4c8658ac75076f3820a4b5fc32d5cb45646f640b16c20d66b801fbf4d5949321b4086bb7edf36e98af90bbf3db2cb47ce08d359d28deb125b9e2486cf69fe4a51607cbfddf654d6941965e746cdbc3f481122b8c3f0e412c1452c9e596b35aa7af024368ef59a28927679bc111cab543f79e565e66ae69e61552c45359410eec91d7d4cf94cfc42276520dfda5b45eeed78a5a5c8b76f67e5b82194159031ae9944409a2ccc1e51027a41eec022dadf4820c769d7dc07cb1c9ce2e6ff3eb7c9993a7b2a7c70c7882b2dc138272217945b411446061f69f40e893ec99403b5653232d2949346f3865f5ac78c02f1381b4733beb36c30e9bea1e042980d911058c35d884eee760c0c84216ae4300898dcc52e4c3b6fad0fbfaaf4231d978ff758921ce3dd28ecdcadd8e525ef03cce005c983d0424d910537f355051054570ad2cef0981f0fabbcc0cef443cf614d5b48d43b7a91e7759e9014c6380f40a58e4a5f1fdbe9c9d4bb83c42060d2befc888faa3d1b5ac3d6231c52025e4fa6eb8f05a5379c0a013cc4af704ef81a90b9e8c90a840ea1e9d2a7d02da4a59042e97846e0397074310ca62dabf0941acbf493420674cc44920245efb30666f061bc7647864d64fd435b5b3ae44258ad7932275da3638c05a7331d789b220e4e08bd6234e3c0f5d514a0c83a4b5940772f98ffe28d9cb9d35fdce66f81b63ee5b309d1fa75ad3101c4f14f682dcf8f14d883f6fd4fad83f4f23b7bf79998c5c6fba9ef221141c699a4972fc9bf7e3be2a84187d5214b6a09cbbcf8c82401c5ebf3c6e2f31bba0935917462e6a46190cd7f55ee0e9292c10e0aa4ce7ab7942309206f7cdb742a5dbf274cde8f96ae74e8b885766551551775577322d16909cc35d6aa056e58e65ff773c1c555658c58fa25b46ef8343ea9be3f8e5cb1706382b015cdc6684ad3ed99ac14f2a798906098734c40d74303b6189fee8599ef3e13ab89901ba8816e0d9ede8b11f260cb532616a433563b3f71814399ca4f8184000178a164352ec3969d84f24c46576994264519d1ac4fa6100de1a27b099dec68ba40006afafca81e37175140c4ad1d6f73995c08fec51cbb4e12456823b935ac5e9ba108fdc58bc799c955f09078ee23c491fb33a4e57542f5f18bc33bd57f4840fb5f9e63d4517eff5d8b591abc55876feb3006b242c9bdab73e2cd6620300bba3a0e3a2a4295d9bfec87784840bf263bae3b2734373524997e0670331c33e84b7deff9782a1839227d34958a68023356bb214b123e91a53b05e3ea3af7a423c3dd413622a40210e8d65b82eeccd5bce8a51488f620b8bef9ddec457349de73b0a96df32e06589581bf42ad0ea9faeb6bd793daf458204442aa3e13a01fd68363324f893389df03ddfd2eda93752a17143cd71ac8193f46322ba57c41006d6122300359f06e946292e357b21373a03556be7071f79ff8a69839829fa8ab130e55fe47f89148df9e56cb3f785c207b7c0abf2e1f61f899507b292052eb9b9b4cd2c14782f00160ee2bb3a8206dc0af54590dffd06eea9d8f15cc69238fba64d862adf53991de1bb85731db5d723e2beb4d6bf9738b5b53061c5f1ead65f93d3f5e4e107fe50db0feb7d005170f46b608e67d2ea390bf54ac29663d18ba023b0e97fff3fba9baf82f498e1d6ddf228fb700f2d75afc2bd2ec6300ada8cabe0ff132ef2f25de2a27f7b9a62284088861b6b100b4d45aee2b17771f41554cf63a24b02da3c2bc3e4321128d16c497c20499b29a4d03c735b5604dd3ec1928ad037ce8fb9435a1fdd71d1ad10a0da4fea09bc51aeea075f8f95fd1f21beb3bedcc723be72ead32e465367939e5056dfd55cdfbb85360f92b0324b9895356b7d0deb8d1dd077afbe02e1c7452695606458b5c2eeb591096f8dccd5177b37ab26d8a672c3b32a4e105b61c66c9b419fb560bcd72547dc6e80e566d239638e71038fd74103391a634ce3f660a9ec2219b842de9750f9868b70668edc227b6a79efc9031086399ce3ab7a79b9b12a88cb07e2f41489ac597c5bd4c104622389a9e84efd51b1a3d004982d28b73bf5193df3855af19a1ce1a50a5b61ec471dba49e1ccbb05eba0450cc12f9901247de73a8b09feb2707e2df947de37fe8e51bb2af8fd99fbca0caf82b521881a61b8518a476245c9d777825e621c49877d9db827750830864ed064a235e155628ffa3b4ba869e0b71701a7be124e930cf88df5435f444281dc3f1c28f1065bb7ef0e9c901cf1b07c92b43210132ae1bc5f77f897aed7e90b8c10a792fbd9a144418379353aaed4d4b5a606aefbc88181543c8025e1432b28dc91f32e3143fff0b4ee2036ac7a1a04bac16a17b3bc5bc6aa52728fa7fb3d18a39a77076fd523aff5ab93659e19f97cf0848f1657b082a6f72b03b7a868bdad36a79adf98ffef2d0dd32620b46355de4b51d5372ac1ffc7444601d45794f1027fb9ed4b32235f00e50e48bdbc0d643244cd0007b1132b0a26ebaba15de1029d87e00136d5c04f96626b166b037ff28634cde24d9700883d5c3b9bf9263bdcc539d1d3242d77709d68cfb2fd6844c3e46cd4d2fea8c099bc8074e8d270e53dcef27b6d6513e91e960debd772a58a15f7689de3a8e28346ad535bb7cfe388657fb3e01dd93f9ed5b30b4977d2dca731937bf56bdf6eadc751107dba1114720a9489e65a708299d7fc07019b52445ef29e16a6bf91fb87b4ede125462494679f45a0a11b12b7e86a7351eabd0e5811748edd8dddf82606e5fb285be0e0671e242c2d53f72346955d157194e7f431e7ac787e1d83f730cd9ebb2fe50003c389e5a6d413cb04bb4827418a6b89873d977f49ff5865c25549c28b756326328735d59d5d9e2be5e20b50070df6231c8911c55eb9fdec0a13a44bcaf08fe646f9be3660135f6095c6372ee45230a75c2730831f13b23d2f81aec0265c4dc23c39ab1e4af393e436784e6caff9ac3a76bfca34ec03bfa0442eb822a28f40e2f1322e9a7da5d5e7105a3788317dffed62d112e7ab787748120779734680a8c7c22334b82939e12dc41b38f45c6985d6b7197ae69d658859d25783d06bbc013b8c167e2f1b84bc273411a0730921b5e76f7e1156bb91f3237f127ebb45e59ef7b20a1d2607d07cebe0d6504ad322d688df7b87521beaf4d4a48ee7a2dbc98cfe81144003e3ef0629b9752079c6fb9ceee10e5f8b51c35fedbde2339295cf670000ab570597ca4f15e12a8e04417d2e286429775f6ef9965a660cd1c019c5caafe307bd2f411fd662bd11ce09ad24ec21423dc7f386d0e45fb796f84c3bfb748b04c6d3f153363a39e1f02448d25e0b1707f134281a380affb3e012820810e9f929b96f719e5a0cdedacc6c06d070a746de4b7310eb9d54855108f8580e2055d9c73649dee78e407b72a5e326d5fc384a6d4bf7ef5126a2c90b275cccbddc33e6c160bed83ba0e368ec8eafc62c0dacb3b433369d2af8b21582a6d01fa40cf01a0f3294174031dbca9f19d4c17d595d00d25a77592466e3bfd4b1f8bbedde34fd7f39580807ff2579ac48a2ade4c07f6dbe455d3c49a5e6439b923cedf3554bb29e4ceef1dbc2e59504ae0a10c3ed63de0778a5e1ca8d8fad1ba71e2df6a1cb457d2dbdfe477b51ab1442bb24b56e52dd58aa45e766ae0da0cf09dd6f05ff555aeda6480828ef19ad17569d83903fc08525949c5e1ec158f1ca19bce6b1d6d0c850d9a18bac3c398fd8cc05da164e52f604763c98ae6decf0825b7395c23954f31109df67c18efa833c1f8098d989a34a82f247d60bce8256509b53dba9d4ba4f01cca1235664d6e3bc2152d6131867bce2b6763a35bc0214efff86341607797f812e789c45abbf24bbbf0c7e9c8db8ba04c327cec1ad712d77f6c7337af09ca7b03d9347789aecb9d61192da613a7ca9f756f144ec7f5f7d81f7613a5ed8cc25c024bca9b47e19fce8d956ffeea31cde51b13e22d3d6f608113f1ef8ef1d79074df53e0e76868c964b29380456c0b02853386bd248e4492af91a50bd11fb2036aa75bbce8027e7d5c338484be2304fe63f3601c0f5ed3664ef8a93f7b63daa3c8c099d72d0078da6ded5953b7db015a62c873cbe4b91e1ce756f0f98fa1344472cdcbee900e8500e870d239548e63dcacf64c8b49e332ee1f493cdc6ac0b0799b9ba97b7911c4d5dab05122c698c2b57bec9372495a1a894b4911d447e05e734b6dfd147e8b3e930e495db5d18547ad0479a4586212cc5b19bd516827d71a589c2393c3c211cb798dffb6e22caba226b4920e380188a45d2619c431125b499a45ee116e6e3ed8ec40d0c3a0e8881f8be80c3c755853cd48f0e08329c5cef2163153a207520129ba7202c8885bd2af2aa7ffb5234fc5512a0daae14911abac771e2c9da9c6ac1ea84283ac92894f06c681a33f78e8ddb0c69ac3b85ce69b1cfd1d30305efb2ea7b47c5ce26f4cf5d1c884465550022f591db643ddcfdec4bed97ffa118671a6","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
