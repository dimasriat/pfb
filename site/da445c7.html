<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61ad21cca62764f83d1c0f481339b90616041737d46aad5b0293e4cd464d4ce132ca1cc210bd36d8211deb3e27fdc789fe3dfb233db2f71aaf41b3e90ae855f649993b38e140793468f941cc750898426dbab65b7238ae26aff98c7c8b260f176c5b980530c3fb0e8e9b7857c98ba590bf2b9028afab3dca5879833ec148c7bc7885747c8b79f4b069ace7d226102f47a45eca59f89478326b30ac2088b5f4a5b1115569c12f7b4b5be2f5685209780024b40e201611cd697a86595c9d1d07229f2ddaf440ff1eee0c74a32cb31cf16cde3825db853e74b728e0d5c4bdce7bdeb3a18d02240fdab6bd0e949b987f69090a2521bbf0ed63817fd1997368672113eacb25c8010ff495357f22d3acc7101ecb446f79a0a5c56699a207df4e246d45ff1e933f1aad4f6acc4b1c8ab9a9bf1ca525cd60000b70ef874b66f03cc6e542e999e5e5f0375cf85768b3cd8fa228394083571333bb3c6c3a877e70984ecca70f8d40bdbbaa406c0895e25e2d9545c3edfd449541439770910087d741ead46ee2cd9115198ab0beea2ae2b443cf2978a479b395ad86b2b5e9308cdddc4ed82e7cb009da7f3a9328147071f545e23189f458976ec92bef270df2141f278ed4aad60c1643c2eb0b35cd7a6966f82b2e5a253747386090b66b7294efd4c64de79a22e971462b5b24849b2cb199a404983efd6553767ada29a5f0e27aa08f7265856ef27786e742c4c8351bc0f5ccf987af140c487675ae1522ac80e1e07d91e07b197139665ab8edbf5f0aa95b90369380f21c1c1190fceb27c58f7a0758b7c3f7485e1266fd48c24ceb1d0d68e584fc346ce4cc4b8144fb0740e082f671787ac6ec5b71d55c7e3b1224ed443162aa2efb65279a5796e76387ebe30f95af3dcd5b23464302612ed4de9731e23bc74099be35b5b11591a124e82c16d0ea0a941220abc34607845f5aad02ad17b0e1587d80056ddb5f53dfb835a4b7243dfdacfb9aea6f7106f7bbed7f6177e0e8d54c34bedf00d02ed8d908c686ff8105699b63f6f805a416ec36800e3c26200f1a22f066af1b0cb59b48b20051a5ee9cf891f7872308067f2c8f9f7a77b3d8144f89f89bd7e9050327e6835e15144c34330cb3b7069f59a9755b386ab6a20cf4de31372c67417b9225aff3e1fd22735a17b1911c730b6a7c05aa6dca9f2b392c2c1f9a94e957e8a63a679be7881e95180fac34850f8cb0b72648da704c2cd7be30e7dc5f46ee910399a450d3e8098d8d5a520266e3417b786cb741bbcbca8c94a71ad5bfeb7842d0f54af2b4b6ed1f7598f779acd43b86de8f38197ca829676e126fd6ff0b6620ffbdb5cc981aa54f52902d02e765018fd7bc1810b74ba67f2cca42041b94b9995bde822987b6127e5f2474ddec6e245fbc6ff9cb35727667c95c101d78ce5e6a0d330b219ee59c886fcee0debf4213e1538ae3d012b72be00d85564a1a4cf194e1db10959528fa4f772ecaa109942dd8fbef46ccddbe59bd45c1653f3054c3215b6ab8585091238d28eb05e4f014983ac518f7734c61caca6387e788ebccc727195f5bb8af14357f7365b1bb57c03f8a15ecbff7f3a0daa2de379402bd1f43fdc5bfd7eb4d6dd7bcd66fe2d9648bb8df452a9eb78145801b5332415c2908ee6704d2f5b8a3332381d45a025522d70bbfd545de02ace9059ac323b7bb2c1e0afc6af534dd232e6a6f89a2a877d9f782151aa8114a04320296e1c35a1a19e4d744423f65ce4834966e6082ea3119c0aa1ca4ded3908a7f904bc68e90a1f77e96998ca2b265c0c9d08166ebccdc18ee60dae1eb73f2c071e63619c853231857c5453c8006011cb3024eb38d617f15b97300560f21fa26c9b80bad46f0664a0e04af101394dc29ef3e5a8cfe82a7d25dc5e2dba34de6b862f179aa3fb42cf982a35ee3284441949cfd81e7d7f75ea47e7d65815cfa74bdbcaf27a84cc2f05b09a185e4180bd951250641bd2b0c42b8c3b259b0ba9ce5bb18bf1788dba4e08599634934ab8a5b174c3d061faa6bd6e73be4c99188623ed710f57f1c138115023372ea1657315a3bc6147d502d2e72ce0048b95bc70d7d7bf71d57c0c8fac954e7402b0c563f7291333c7ce5f9089338ef0debd5a1c3a7e5ad401d178d01eb7d52d9872fe53b7de1a13fadec566d70acc2372c15743ac815b5e13837d68bda39064f8c4e218f0127bdc182afb03dd4e770035d9515c1007e05c11c10927ed5d48e9ef8ef30e18fe8850446915ded9c70dc24463e50e441915035e9e7761ef8ae7dd358e6c2074a44223c5bd4333bfbb6b5f787c9667779d4acf267b7a8b6d3e6e62d789a5bc366f7b405320cafcbfce647078ac00597c7a8a7d5b65a266a9e60723093d460e53c2f8846b222917aa19bede920ce8407ea1382cead9f07c2fc471e86de82d32c86584b681d09115db66767e3f72f0a0e7654609b692f74037e0c5e6baa5a356657219823d7e2a6e4e67ae825b96322b8086a5a6ed829e49c97ef0eced80a542cabe69109e3e9016115fe8192867b8e425a50f40f259b0540c2819146684b9d5af3de1888bf466604c69494fc4ed4687bf234e28e74853d6cf55c8f65ad8f5d448cac5166a962fe03ea8d7138800e7e8cc8fa01b11821282bc41c7b1ea2f5f121a25cac24cae0f5efe4af984bb868987d6b218a2db193790426e3f1658ebeba758f1f29cb7cc4f73a71387a7455fa93d90085f7b36cd038b6d6332a781463a16d214a0fc433710c43fc5f024a87363b722d9fc8e5d82e90551495f3f8df0b09ab72e8872fa007fef19769b96f9fb428c1ce2b4cabaf58f20ba59b5733345bcaf0f17c716d050d2123c7cf24cd32630b1f42704960dfbf510923870cd087e0ce438375d2fef56c20b89a26abf7e2e2713159038920d16cf7afb793b0d04211cef72c7c0cc74b84c051f79a90a6c989ae8ecbaf1f8bc24e115d406aa33122ad3e901020d0a9a8db32d2d9539669caa3573bb7e9c2817af84e26c6bd949e72873271ede68fe41462f9c41bc339f63c11aa9acb50d493793abf05cc257e65855b22a1d689db584ee2cdc648f0a522f475a9f211e0fc369f14b5f99766015babbc1ac9bbeb4926d7f65e977c8661baeef5c70521b103ffd541f7ed32282461de3379c2a3d85ec8f4a21240df7dcbc7bb3925b6501885090ba3b6b26f63cbe2a7c31e32e665ea82d3ed57826e3397045a8e661b26118080e605d8663eda6e5cdc4926b4b14299dcd41b84e0d420d7ffe5fcccbd083878a3d29d6ec685f3d245b5311cfba871af10626e31cef469a30120f0b8eada06ce0c07e284dae8b1ec43f0e08d2710147c05d7faaa1832ef551b1dec596f13750575652660df1b26ec91125823570e9ee9c708efc7fd253545e3b2916f710d2c1adfd4ef232ae2a7f879508d3a3e4254eb5e7e54af06728df76853b6c4865f8ee2fce801fe76590b43a73402e05a611ef420e110311fe9fdd985d61d8050bbc6fc4cecbfcbf9eec1a2cc2af4bf0581fd9bce165cf9e18f5d45e8949fd710d9691f6ae23490139e1efe8403aca7852c9b143c54ce51b188ea6d72fd03ed156593b1620a1d6404700a4e719e19aad1ab611b499a834343cdcf1086872f26222359fd406d4eaba28ed6ca6ce77dbadea0654cb40f9300a77ffa7d26a8d20fd82a9711112bd3a63b6131fca91bc28df557aa7aa7d4b21908a0c809f9aeefa137a683b67848e49386c001a3d3b802b575afe0f0b119144896708c83d795936aef3782579a21c708ef74f48d89019e845b88d769d702deffe0a1ac31d4b95263ac7196af452970dbcf55316919969af8a94c313124a7a0704b595b43a2987433ec32ef6f8e35e8b54f684ab9667f4649067997db927246d0623572e707f007f3cc5122e8a8eb0f7094591d971473f1c1d75d6c0d7a79e1d280dbd3263c374c45b2ffcf4c17f8f67e283b934a990093a7eee3319d2c02522115478ef61c7c99cc0c27659ea941286c392efbfe98bc92d8ec8863a7a473f4a0f7322fc5aa016e46a91bca2e9e30a9557c29ee85680e72b327bad3a858f7da26114a2f211a510c4f9de2ebd9b023fff3dca55a03eed8f25b965cdac39f3137f7ea487bda8bdae239a35469f3251c0caf25e7720ab7c57c72b3b6cc4a8d448082c51f02d63ac51c7888a93be963c7087a57f7e0cb244795183227e323858fcb54567300334637970c56c07716821170b8d53d9fd8093b81e9bc4b05afb55a60b2bec39569297d8f9d082e0c7df3ea493c268f8278a0336b3316f717dc2421a7bcdc1792678e28b8149a7797d973d8e47750c96670adf878e2f5393cd5fa72b425252c71322495d7f7311c56000228aee5140e4985a347b2b882ca6d2edba8c8b8685ca0b824924c3a1c8c82cd85179c586cdc282cbdc03f13fbfb7e625f5c6eb05e512690d222cb4c9e7c78387e585cf753b02d15671054eb811f43be0cf2244e226daa31be7e3734e34ec90e448e99472414ddebb497e637b3e67242f9aa9a66a148fa113586c51e84a8f2381a087f99a774e221a8ff38d14e0030417f9e795409b8a098feca7a7fd99600c37f938e2ac1426958374a96ceca255ef1cfed72f1438df90a900d223c73e27c2fc7b6cdcb8f66cd31714d62f7073fc61f5470ea4546977aa4a1d8084bcc2e258cde3595f19cf168a753180655141b3fab204e800ea1d5d0a8453f3b5935393f673e978427c542bad8c805f50556e47315e0dd9db3c3d108f22bfd90cd54d6d20ec3b77d30b5f0f3db1b80cd26129332bbff799602da0e93c18d0a0b08ff147c7dfc5cb7ce25b5180c7069d807ab0f3f3edada8103d70983d2d3d52ef4bb681620b1165b0aa1d3f04fae8b327941a1d40a9b8dccc0c58d9a97a9a398d7eb0ef0b91e593d19a0ab9a444dcfc05972dcdbeb94b9bc45e8f8f9f603e07a364fc12993b2caa01bb76023fd0139c4ed3990d589fcb2d11a718065a033ec4af2fffdb08eb5bb2859cdb6921438014bc5570a2064455a59f7f4dcff59da266f5f3a7af73b2698d3a417f96c8466fde8f02c46e4790a97f1d93c41dd2f607edb5bcb006fcd6b29f9dddd46fb2497a70be10098d80fe5ddeda4fcaf00e03965a0afd6b570bd15b64161661e30097c5bb547ed0fb9a6c330e91314a22e3ed313fa048482cfd5dd8150ff3079f47c89bc6936b24cd44513c3bdd4be7ea7e78f0dcf06c03f29b87b6908030c692bafe8b1f5e91b16aa0db3a6cac01aafa16611b0c9e107bdbe6f0e7242542d48d4b15517e9aef645b8b7f1c5a60e0f8bc6dcc29d51b1bbe879ecee1b17a2c07cb45a8f4059709e5654df90e963daf02a39125332e4a3df71a24eb93eead965af4205478f1388774d3f29f9fa7b91883fa5f097368248a644d3a5e50c0e063ed7d0ce1808fc519830f23fa54b5c34863fd35b845aaa8eeb4b6ecc38aacecc326c7866c18970072fde403c3a75a83fe4faf36fa9f17025c2d67cccbe75be41f9e988ca5500f6bb26c0dae2e69ab4b653f76696b0443e0ea25d6a8cef2f646c6781ab1d6d28d9ecad35b8c19d4c12eba3cfe87b5fc3e5104daa26c103f1529a62fceabb3761136332334e32f52e1b25099cdf145941dc65e8d55c73f3d1f785fe10080d46310b382f5688bcc6581412dab8b71d86c12d59668d920542bf16609703418db29051f11e08dff3ffd1439840200f0c3c4a74af2e12b13380f6de6b57c75db37f452ef4c96049a24b756d3011201720d0c39bbd890e01226bcd154e6a9b2a999ba60f86b9f3cecd5c1ceca1c19f74f5073d08ea82a390f55b71a62fa845f3f5c2d0db71ea5ebcf759de275f8d6c90d63d3b4bd188ab170302edc67e1dfbaae7ab1e5d9982ed99555c9efdc1064ad46888528360a42a4597537985408492dfa7d8f2bef60483e1ed47c165c140281cd8915c95eb72c71a92627fea69afa3b305dea86bcd57c36b81b41348adcc1932e7801a80be755e403cb0e8c3784d4cf5ac60039c5b42a8237c724b588b5fd40c9e6b41823ffa0c9d00274b8928fa3d35726dca654e920ba22f31d3fe9f21a9a4c3a73d9c6c8ee1ab1ec3e73d086867a6b93a1bfa2ab0f4715a060c58fe2b74d40091240b493e9b33642ef9354260795e6e0dd59b9ec9a3f1c4e8e97920591a6da6a3746fae313906f87ebee210d415e64c736be64e827dd9c915b62fa5c290279e7fd0242c6c71432e4c882d7feac69c4bb1378e4cdb38b462c56de5d3acefe3028c1ff8878fc062cea8629f3e44819b6d8248dd47f4bf5a4c152dd6556a58eae0c556f1d00a1a8f7fe0bf3d7d9c7ebe2e0f9e97379b57268c350b7f7081cd7ade77b54e637f837c58df3b73fee10c0f835f6d51a492130e0a4ce62000046d4fb3eb19d25bc95fefc3c5c15e1d997d8f910da8971c9546d6292e646ae580c48a4cc8302f89d2410df305625d14c03396eae76aa37243376c536ad3a38897c74222553f665332e0d06920fc398d6ca9b5c3ab1f7644d1b5d1c98a9e4b5bdcadf42e7e73b469d262b69e967905d3352e9b8969b6e4dab2291eb20713d4dcb9f9dc8e192e2a379a07bcb86ab83218b55dc6c2f7baee896695fa672a9423add69c17b129a3c5313542b58543013e56e19c6822105d1ff838b083f55d4257f2162f1bcbc031237e7af3d6b86bc4615c9a2c1a6e89a949daa4adb5ffa4f88eaeee0cba5afb693ffd8c45246cb97f014c790f74a96a41af3721d13442ca853ab8cb31548d56ccdd0d291207a169b36bd009ec60dd6d6df62e4c946bff4f80c099f55844fd263011cc4130bed0ae59542b20209094652672d0349f0756f7239b015d11911c1d3fbfae95659c43ff413e7d1bd551a059c12aa51a937cbe0f0d85d2357026f199e70346383860b60a47fc6a6e7f610ff42ba493a411f3504e1cbfcdffea9dc5be2cb4fc69333f451a06a84c767388e02411e8eb2988ef9e23338d8199af8b3ff819a7305af844757e207183d9cb31762b9b64400bc7b5867ee7095f4d7852ca106c2c480879281328a2ff0cf6039f4d628ad88de3d9d787ddd2cf49b0ca23430712a5f1013cb893e5f7a07ad7e914a87c1bf489abb75c83e27f25a8c8bc66ec07a963a18451aeb08e6e39df072efd2b59742988fc1715d031db4605d3539a47ce68148b713b3a9ee2e94f6917668636f0abfbe06668abd4763673a92f4735b5693dd98a4d4d1cb68ffb87142ed406df822c66dee655454e1092b2f8cc5b1e4dd23b243e1592d02d94b56684ed6b747a5dba545afed2a8b2cd64f64ece631b8683e1f92b10748d222bc3d395d844a342c95c473cdf945210d2467dc0d653809b95b8aa822718a131b0fe2f22a0dcb1a5712dedb3d7650c23cde07865ebc4f84d276a7959e640ef3e3e9089cf798beba399b576fb548aa2f659710dd1a7048483ffd0220d50395c4b9b7e86751ca3092ec5a4dd83393b5b4e0e10cc72184c49e5140970f3d66dd15727a6b6ea834672f06969f95aad4af5e4e88030652141a99f9b892806afadc478bc1c9f7c493dd0cd6220eea72a136b5faba803d3d914119b9acc2468a7bc1d536801af0d2838b0ef64cb1f0c18ad3285cbf159b77b76041c1809f1aa618abcefc203a203db24a4061488b43a6402d6283e33285dacce59be11a322f06f297e18f5c6556a41004cf895789b79ab40f26b5c0b0e214da12b4d0c799d42e630091e273fb14c992e0fd92af6a42e69e1509a01558e06de6b329250c5a805159b02384a236bc8b5f4d1030c30e93c6a918c9b8d92ee115687c1c1843dec81965b81b4c28ce686af07441818a3c1478ea3eef39590e41c81bfa1466290705b9df437ff9f4d2fe66b84d658467fee8cd63849db2958e3c4d66f4bc2cdfa198b0422a36cd2e94d19b28ca042a7a3887b14fa878c867267823ea16d9756897bcf128b08297f5291ca0d10ca3c7277252a6bdeb3082b8f473c66c4c6fd03df2e564657706ce9c08a737400554fb1b0f05fe375f64de6928d1b22ab0f1b3b9359061212518998783bf085c44c322b331c002ecb9ebcc8e9081735fd72bf9d87ad18a02c5b8355d237bcf7f2bb061894ad4c450233416ad25faf93970fe687ed78d91a274e2a3aa4d53a8ab21f52c3a6f355163439a46822a47a6893a1af325a6c798151599eb5547837cb80e16c9eeaf2940905ed5e7e23a170001a2e23d1aacc15cfde75994c108724dc1469fd2c7b5853a8e0a944f73f5e3ffa025ed341348b1d05c7c886986ed16137560edfad4f7a5f4b74a5b74f0b853d9dcc94d77680faf490d7bb04f9b3988db8c70a1e07f353bbc6da07b05d8035077b83d67b07a3a0bd9060db1d710ed2ecb68bedc0dafe54adaed58e65dd19bf00fa1a1e46d700acf1b228d6c3df40417739c92f9e423b4c8d9db1a2136d8f522bfa8dc701e7130a0b1b11769df796ca377969f374b2101cccc5c8d7d5db2452c282a49b2e17784f8db65c66bf329de1fa4255453cf434cf44e00c0f4b6be9032b1f60f16ad64fc122f2a61663452542287e0165d957f9ee5ae8f5fec3311c2f26bbf207fa9153483f970422383b36255b1b0e74c0dcbf7060688bebd8723b2f0412844f124c736adce770eb8139bb6205a58093998bcc3a51019a704e6f4b86e1f4fd0467a538b862c07aaa3716b00594bbd5dd0e2d16dac01adcd17cdbebe8753cb02576dace06a837ca0d64bd0b1d500adca5a8c7f674a14866fa3b8e5b507fab3e74cad467cdb791e0a78d45b3cf81d7be4312e591854db3f694e8d51659339a50a25807cff66e59ca6c01c4877faa21ad97f60f4991e09dfc45d2c3abe3a73ad12792fb436100724198032d9da3b4ca93413cebad7f6b4467671d6296dc246d3d04fbadba7def7b84f9d87b0fa653762436f907c43aa62996d513ebb22ed4a09f9a6d8c68a72062105d1134b9ddcc7eaa31d07be3fe4cf539401804273c20dc80fa10739018f54e0a5459501e2d2ea40472d8f9f9218eec49ffda7d1057aaa49761f08aaef19df2d3c9ae14b738acbbee950d22c816e85686937b5927b085e900b8350fd6747f76530d007e29b75308feac3298b12f95749473af0f7f5fbbaa4d3e79863cd2e06899bfa840f66dc36854e18731a35510fcd21e454351fe1cd56b54845bb9dd674c4e12cec1c459e3165c1a139dd039e080ccf89450a8d71807577cee86dd667e305d14eaed12f5dce9073dd430ebb865f6df0d39ff4e5c67ba11191999bf3a64d72da4022fb7de8b7d4b778ae0998b2530732aee5b65b20392f481f43111deabc3257cf1a87980e585f4ca26b29eb828f490967a95e7dcbc36d0d12c647da2f032bcfef68ef03bc1b578fde81b3ae4d85459b628d56c6e90ba0739b8f1f6ad734b8e9501394473e69d42e3cb829442d7e5592d291822ac92d42584d88e2913c407515930969318da7c0c43514b00333c346102d30695b62191dbd1f8ffebbc4b8db3027c9ad70c1e9481fb05ef2b389602cf7125e61145a40342f34c23c81d313f19fc33186af9a1c99f523c32037363cbca7affb0933d46f6b41e2081ba8d99bff0ee18e29fada026c64e79e0b9f80b7d7f05ae210986c25045551f29d2ed6faefac64bca752bfb1dce47af0ebf7c33bec26795c1c7e389694aded3d3a1e545d2871c266f115f358bbee90b9c23eae8e94f2ee680f331647c8cd8d532b13751bc8a83f361baebe1128da3df1dae359685210d25bf0608642e14e7e7420de15546eaf8d70c1fe3fbec8f082e24df988e476562709ba925ccdadd8f6595bb003c746c84356a6b405b54b96d0f24d5ca0740837256aa38ed16fd25c3cbccf8272f579dc0a578d9e1de26d0d9ec079c1afc5d5cdb0ec504b4373e011590746b16d27de74de38d9d95d31ac98c5d431a8dabf8bed42d3e050aaaf297f90726cee8dcedade72625b2b039f510d7c347b0ce6cc99e650b32e56995bed1ae489ec308059cdda7173080c53ec28955f6432fb10f2e0a4d511edaf0191cbbb96eef8e225a40fcf3261b8b5bb7eb6bcd4234419d75822a2fef7ef6de20d1c57dd1a4280063efd5d56697c3a44993eb900b2aaed48cc6ae56183a1ee347552aa0953f3ba0703c538406b3be5a2d4aebf167bf968edab372b8be781b5caa9c1d4fafc5798041b2d5c7ff484edaab079ab16d1091b523315925488aaf3135544e3c0ce5cb692a86652f27bf15ec46b350c6deac507ed05d39ac684a7105f53381b41843ef1bec60c1066536b15e867158a7b3b6730070b47b7f92e5700bc033f9149d777c0945954993a357d38e237c70307d27eb9c3e69472689cb95dd5bdda53e0fead38da39f8ec0b5563e57e54cdfe3ac3e837cefc5e5d5495a84b7b9e8c4fc23ede00ad8461379c5a5939b2a35ce2192fe8f6c4ecb9fdad9bdd1a84285f324770e80790f216570e61a7f79b088e54b44b89ab88db6d06f54932781d194002d694d50baeb263f4cc3987fc69fd91d0321728c8568c1ef263f9cb49e4d164aa60b52ed6130eddc1e3cc9230c1185861a19f5184ae94e843483da1c111ba8a6d60713e390f2c73240ea90a10c67110c3d49905c3d3406a72e3a79ea4b86340b1d18bfa38b335b7905b436ec15c11da58f7d88865afb81b11e01ccaa50af91a9447a51b288bfaa466bb1a9227974e14ea80b556a5a04e6892834a20126a6a2dac0e6e3bb77341756ec4f66003c0b96943339d86cb89ba82f35220bbb55709b0015618321998e06ee9b49ec20aa6f95aa7b98d62896159ee0da910c6bc0b6e48cd864393e98f3a557e6161f415edb5e1c50790326fbbbc9ee716b97d56b16bf29a1ee5d0331b9b70d4f6dac8ca7f432737ad1debd2bc43382b678132df90b7c6e0d2383a5e6489d74125da3474b07b623450b93eab91c4a99469012db429747e586e22639517952fe69d64a390dc1628f5a20879d155abaaf6197f94d14c463a41fdcf95892fe7108c3c096fce3988664cbeb545faba71ff16f7d8e1f4def4b01ce5b0d2d366bef71b0f1fd2dfdc6993cf8c1df95f62a4ff9646206cdbf9cbc055a8ffcea9a64e520b019f6e98073a667b44f9095dd0c5cacd4140e002af3d8359bbe40bc4b85bbb096e53c09ae930c10298f9acaba8101e0e32211d8cc99da05fbfed68924897ec16e624a9af547cb2d303b278476b28bef3fe35d122c8b352570e51e1345cfa223732d16cc71c4b976a1eddade783ea5d67284dbce6a8d7f55277240ae7be7e5843e04f2ba9c5465bc62709ef653e01f51362c4d64454f373100719b8e3482f38f8ed749377da8e5368d12b02624da71e2820484a5ef0f6d7695769b794f0e31732bd84216fa6622f6798dea55340667c040fb1468b2df399b691e2c2669d1107cb40ff926ebac3e67577d21d360e533832c8f984fbc1eafc0eeb9c47b8f333e87e663099ffcae886c91d3f2b1d2861670d3e51039970841daa56e00ba38fe8e8018b998712490dedb682725fa63b5e5c7bea753ab332a9496eb7c3b36ae7ce8e2ceb37fb94395bc0a31ef57bd720105e49f4ee2f47f88cbf03bebcc1e99c96512b5bcb557659cd6882250c39376ec99cd2c0d79cdd1342c9941da0244dcc7bdfebbe6a25a12890a642f63bb0c5295fd89d863df2254421c2c5fb99b18eac3d9d1f12b3120693be53ecf07c4485f6c00e8e8f8ef0de602b39026bc2bc8e56a8aeafdef59cd18d3c9a335bc9499b7bf6d72102d4cdc58f14e3e800e4ac4f23ce17287a821421d5b4a33144e96c91c01d8c22f918e54e97d11e08a5cd0c99a3bc454cbcaf3ecd346268d65db3ad2b6448d58bf411daf32a1e27e540be95be94b331416005dc35858d4a7af36ef15f597005c80876970a60ae4d927855d7ff4013a95abb04dd654f8657f61f8158ebe2a8a978db1e2464535adfad3417b1ae66428e7bb7c5ff726e5a4ece45d744654c6d7db0ff5b9fc832c795924340dc897ddf57b3172ab1f6fa6c9183711258f84af913970231e629add16e5d3461fe00e3cb3ff01813f4206851c9885b77f06985a61e9ceb8dcf3f4dbe54d5a79eff9270e9e1cb58652f50034a769b8280a97b6a5aef45e56efe48803512a335350979b908102d2ca7c6f26bdb3cab06548b283dde37bf16398b9e9a74bf867e51104b827f5e713b0ad37b7fc851e23b68e2ba21decb584a939c80dd854e11612a549c8bf70f18d49f5fa9e1f2ef0f6797201d30aad28e8bbc6bba28bde9d90580deaeffc8dabb0944e156190d86e1ec43e96c973dac7a6a535a47cd42aaac62f5cba2d3a2702ab416fa8105e1031f7855c4ef27884ec31953db66d38637db05627cf4b192808776b6ddd8a671ef80987df0b6642467311db1af707bbfea1450a417f99391963c3c35acbd02ed7ee1e6676d030eb64cff42b0ea4b6e0729402c3f23e5bf22c39ecea2104e6fa530db17641d1ed8445875ea589379fe3796e52a7029aea5ede73f053acd94164e57979cf4f43bb9a091e63e1b3fb48a7eedb73dec8e0888543d1780c1f2d778a619096d86440f56597603f6eb1eb7c17f74222b1da0f0036c25b4146900868346530fd7890b3f1ccc8648b4be5ab009fd1e2634edd8099209560ddaeb68d5cc9e4a3f653df50b2664a51c632269782a09cea8d52298f8a5fd3e873ec9d9ac1480a37618400eb85d5b2995074d9a4415ff4a78210a0a0481606af8b0697079fc2807473d495b6376a17a6915f0b5b4bfb6041a78eaf604069a769c19ce68917b2ee806f3bd4a42583a3874be240cfba666090e4f473844d17108b9bb501d85f3fe197b6ec069637f87c85f8bcf4ede87058b79c6dc2d67b4da76a460a9a4761a6f6b2cb606c61e9bee9a2fde32b7e2d2665211bc801f2b76ef131340ee40a770bbb1424486a464298c566078c6831bc59f9a017d6d6a5a21e0a4136b89d3550f5dfd43ad424d9cbdb7ef009625a54b4592325aa79c79ee2b686a890beea9a94df307b97838a6b86bce9e17b29fbf4bd166ba24e4b33c74babdc0b21484dd4a9f0f18f068c25a65a754d1ed7f45ee4375534775ebad7a3cb672eec394dea46d3c92e85a6f7ee83d9f8eee6994c5582b2b2660d563dddb5747f794b008db1ea602ac3697577471663e2b38774ed3f4e83652e6f74fb61f99fee2088cfd2a2b63d1fb337e7ccb6bcd2f31f5fc9dc1e4a26a3f8edc3e7cc682c9cbaf2c33c2165bf7d8f59b30dad9b284770a1fe819f75e1c2724408d255d1445211719f6a2420731cc8038d59eecc844c77bb41605437e47412d9ce4afe8c795239dc7be4534f29d1bbe0b251d2239b01738f2f06e6e856524a53f7ed6c120915413c4ea837b3f88e9bd3fe27099e34af1882a5192af4b435a8fc7b3423f6af7edce1ff79132280b7f10028a909adbe5e74222b8c19635daece842b0331492e2c0e869acd78d78ec8dd4682b3d6a5de594f3f0a5c0ea208031a6840540878a8a4a88eb65020e73032b76ab4851999e54e2527f814eb76516e21f8869e8ea07ed68d89e38a5f4622f61cf30cae4304137c96b3f885b057acd1dd1057acab2966025d17e8e53a6cd6a27701442c4a4efab4b4d39f951cff07150231e5617a53c417e9c0eed76743ec74a9ee7413b2374ee7c1874d195d9409951a140324590fe1a95811bef6f1d13eb360745310bdf68088bcfe2001e1f7ceca0d7363e84f913a2a96055b35e177c07bb5c6ef41ab0a86e6c2b69748a4c7b7467829947b94498d0338857a53d5974943ae6a0e663666121493dcfde017a1e77e72f83794d9b0b627084270a087a306439279cc0384d1193655e2ec422c66a8701ec3563f88737792d70396cc5bddc4849df3f8eb0eb7887e34c5d4c977615825bb26c1d954e117bdd81cbd3e6b033b6d3561ad7832c32324cea1c010908d875d047c1dcd60e039fa2a22f7db09cef45b9b2ce5ef5accf909ee76800974f51a75de4d95df21a34cf583ab9a56d4dfdff694d629419a8e5b5cd5368ebc10c5e434488b3c1e2d6bcf9aea1944939291d3f598e5ed648713b4630ed33507df93a434a6108451584315eeb8650ef907ba179c4e56c0ab7af2186a457f6c8ea3c9136e3bc6d27f061ecca3f46dd1ca3e26c670959b1119194cfe9e51667c48532fbda12b2bad183c63d5624af61412fd287723d37d50988adb30e8340445ee1cd17625bcc5d608bb2e7be2f53e5de89db007ad29b524b5b962ef1cf6d7cef11e98b9868abacdba1df231228ef7a931a480fd423b8a48689cc0ed0e0480bdb64feb3916b7a8330c0805dcb08422606991048af6dbc054ff439992e1f1c4d25307d7dd896074c553aec179669e086e60abf18caf1742de4838c28ef15d510834b06810db51295af6f81a5c013352943a7d032ee6b34f479413ce8adf418273f5e8342a323861ca909c9f2d2ad1e96145294b309c0f58ae4a40837404768c1bfb9c0885655c40af55f3cfd314d20811dc63e8cc11608db9","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
