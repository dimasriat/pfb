<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89aedfa97551d7239d3746790e191adec6e8711357eb19081ab38e48f5de490425728dccac22655a4ec9d73d0ad32a99dc91325f45db949fb7e04f61391123c9c1d0e36dd98217556b84b23127abd50883fd58f97cb37ed14168d9bf873e913e2a2c3ce9cfce7d2390f7c257b9cb4add8ad7997da1cd7ee9aed61fb42b76580d2e5a1b8a59808f3d091c44eae0d5066325cfc908c91c06d39cbe148a892b4e6dcea1e7d779d9e0489cc67383d4f633fdfb4b433b74d4dd7206b7190cc2d2b2f06422994a117fce2ff5700548f403747104a02aa0a426234175d631556d6a5767c39a24fb1f4ca67c4c90a01b982a6b0b562e52690f9a4e5a95d5370845629150e20da8f032c8a209b0008eb512c91d950d76520c4fd580e693cf0af7baa662e9a3bcd75713b5e05157e4076f0efb01ed4faeed729c182131f03afd4553589948414ac1d9b896cb76747da56261516aee14c2d89553301879951b728f6ef1f73efc3236533ea8361a4149d5005072d79aec832fdf2a506b045fd907b54e982374426e7e7e1e5101c9bb2d5859da789bb3af5cc070e06bbef84355ee4855d1deb4801ef16219d2f203b856bb2ddca26f02690ce6e6610c4e9545ada6729157f3ca7b62ebfdf96ac4ad5b76e7ba6aad076ec4b3244342e2baa058adca7650bf1254dc9560e95bb8b028494ab3861caf135f2520849576335656b7eb492c716003bbaf90d023736901267f85f0f117bc7cde701710951238fc0ec3c11476fd9fa6c20027f94a2b3a776e94a9b67fd15298d6c3a01150ce7a30433d845aec76e5bbfc75bcb75ac0bbaa6cf5a40e842b85d11a3b0df1b7911f4fe016cc037aac453589f2eeeed7641be889791f0caf64a09d3b93c3ff9f332307b7a0d3bb85d7e0f1b23f742d6c5046c1cd362308e8f38125fb507f17bb2f2381bbdf88ad9fb25fb2889ed0dc322f5bbdf42ee5cdcf2b874e38468fe908e160c68d16e1990fcce71a285144512ff0352e15071f7fc9d84adbb27ea916a58e9786951ac83c522990a2454637fe714e716293f8e44f7466962394ced2b6c1baf2cc79d08a153d9e2df602997225c19db5ddd1d54155a0167513c263ded664c2cbab5e58eff0e501d649269d009f50ba1eefd6791887b08c20aed27649a6bd9219889dc575610efb1270f99149a2a909d49b51065be828facfb88e11673261b85428bebd51162d96bb981a42a97243a4e1740cd12647be58be20108d24b11d4003953c39e99f7ecbcf0913eaec02535729683dcc22421e57421576da7539b5acf0a8dda2147293b055e757f776dd35bb261d781a6de72eece9f744cbb8406dad4437b94fd1752fc50621f8be60f995b2e2676ecc82fee6389fb1d1d5ef11b5afb8e82877a412b01e791b3e8b8b05dc2eecf0e9094ba654ca431e41725032df1184da5d6a92a2090ae792e5188fe6ad0ad19a30e1702e56eaa389288b133ca6e3f9bcd9589408bbf51a1fc9ef6ab35a6b3dff9b6794ab3e9bb2bee4bf1f8b09dcc58ab4b33e09e9c94d03b6114d1c1a3126c8318947175e7e5e7522dfc12819f662de6ddb263c279d065551875fa239c62117806b57339039999c7e464e2aa31d8365bf3c3164ed3cdc4f093d116f6b092a42e8e1dd1d71c3a6dc41cfdb1013266421198e48bef6aa547299d9be47cbd85d83f4c736983e6ca43bbfb95372cb7397ae2c894d386807e82aa468d2b75670c0d571b4d2a4985b1e63ea5eb00c31b2bfdb87c1c2d7d47bb80d97a8697684f403861667cd99d7adab79a97ac72dc50211cc18f9372b5d305ac08b07a804614807055d37913d77dd252b22f11e06070fcb4e6c43e5159a7ee6e250a4ae817e0a9076c1e05179e62544f2d19adcaf273712a5952499b614ab50c2e868fdc06ea0d9b5d50c803ae1fb6fe44ae7c84ee13aa6b0303a9e2a903cff62bd21796a642a2da2a72ad4d8464383a1bf170dcf5deee5915e4288db77bd47329c249017bce66b0ae4b7aee1ac700df9b3e6ca352db685ff1f4d49d38ea857e26224482e5e10b9c4e6478b3fd68fbad88f8e8af51b537212a015b682640314ca771d244365be5bd138db3da8309a5ac5a97bf957c23c22f9438b54fd781ef092d855269c6e4cd950135c5d7bc833efcd23c4bae8e2816cac87bc6d6778566cc6587627ea8ac6c911b3b66c4f5c449e8a362a4b9b8c4315a8709b1ea4efbbb9006450716b333180af20c5978fa5cdb18deda64a62926a6a10486ec0c0c80b35c0748611e16646060e8c7e24e9bb1f416899e29006129e6a6a6eff545084316092dc99d0cfe071e8158da8890ce69ef5401768d8ab2faf9e8386b519845afa1d02f99962ddbab013935eaeb2234f524d347d4ac5635623decd668cac2c17b587cf547f249fe2039c3fb2fe97d4b86ee7bca5705d96b7306bf4b25d100f2a4f07ce37136b1237150c9b0086772eb17e692a30efb9980ca21061bae964d0be825cce65e86080a7b76782d5185f3b6ca10769d70a3605e332522b0ec2c5d1620bdfc27723e90ef3d95da73795bd338e4017e04417d234df36b362da4262d05adb70d16da4512ca4b0b495b4043e28d1056c0049149a3a41849331611773a0e292a667d5750afb97df1b1ecd69aa2f5a7c2ec481dcef4cc7b0a45013059164fee4b5b7bbd2e6fa2704c8a2f0a6c844a2361a7ea7e37be0e3f8ccae140983ee4f4648467c364dcef9a958ecd6655e75e7af7b1119c0ae653b2e5f6698d6bedf0c4787062a008d1efbe8d2481667b8b3ce750a37957239cba8b9c343882e042e91cadba21f1ae44f59b8a6f7e7ed5fa060d2bc51571a0940bd52f58b738ea798159611ae2a5e57f3fbca4c8aea7378204a2436372ae95f287982d0ea2bcdb967a89c9470e67dd17e7e9deb11a065a943706f520a298c083c470df6fc7259fc58b6c2b862c3df239dcfe67c87fdaece7f857ec74fe093ff31cf98fbf2a1a6c780c60a00c7c6a1f9ac5533e089354768c32cf4132fab2e1b4c4d20c3329379c1dd3f73408b3ee6b359a171f9f962018c57c6f0aa656d2c9621f79841876de7d7f85cda2cdcddefdc419ff93d84f786a816b8eaaf31c2acaa524cc53e0d17b91a6af6fb57fed525eb78debe21f959e2f2aa87279616c1b07bc3db2ab1ae9629676830295c7b921468929e956572bf468c1525ad722c7599ea3d1c9c5954a8434e0006d85d8df2eb0cf771428a4d241e785b1b87267a5e3ba6d1a8c09a803be57d32a2cc3af6e40222ce59b85ace14dad3ba45971c87d90266a5e15097a1d93357711f7fab3681ba7c8415d177681270d34c302c750165091e1a161e1b97d37d0ed55c222c7d237d13ed44f84b8bf949066db3f0c46f9884b8b80dd4f936d66cffc18b79ce6addd10254415e5b0e36512009ae591a76ea367da0f0e9b75630b09b22a99873efc618d0bbaaab39a232296d3621a07ba4d02a3a6f591e26ed1bb53d9026efded22d97658f2dcc3c68a0537e251e7aaf1b6ea41ba8e9b3fb59a991c404aa444ba101db190870d83ac4bbd7a7a142d935ea26eb3b92f1f9ddba5cf1311e95a8455e9e5f78e58c41cf5feceeecb8c1aab44c670ef2dcaa19b2b6acc5a995c21f48473eac46e6551bea2b5f2917f3faae49304bfc1a7f41ae66827557937f8951afc8ad1cff55cb71b12cde7f9bb5f0f2f1ed365e6dd3a90318d0c5d7d3218d1b02df0c53d068044b2d62b2a568c6023075a9c74985182b581f0a4161d83c81b662b1cea469ea4ad4d78a0785e7267158d1df010eae804629ec32d7c0d9cba3e580bf4d8fe8886524b7cb0549612f1c2f081e7ce64a182c5378912a199f975a94a82d3463c73b2d356daffdb12fc27968dcfa5f5bd792f324d0c2ac39836d6a094c8cc64d0cfc4c924c8f3041fe54a91b7222f6689f2758040e79281aee3770e45492b141c2153a7f03153b257c7cbbcdc56f6144556729a577e9ba0fc792731c3384d9996682cbbfb4ec4dd5d64ae667331267e218e5feccb0f2a76549b8f3cb88f6f40b121e6834451feacca8040885520eec697af5a7f9306c8ce8c631188d3274bab4ec0d08a69e7e11c79487656adfc867ed00f7d4a3f071b7691d3204ee1dd56af316be39b56fbe8ff9c79f6679eaf262a991a59d8cc96671a4ff00e8b06dfd773bf380a6f6698622e1fdb9480637b98d339a6a505d54f41e672ebdb750f19364a8eba52b7b9387b8a514d07719c86de9b5568ed7adaf5776f211db527d88e290002efe8d6c3c05aa39b3b3aac0feba8432a6bf2bbe34418b48683d7e76511cfd42729818bd8942676d222edccf51b7ae285e9a2d45686bc520d0c24411ccc572872154fb14899ba9ea7be27305d264d41cab3b53a7ec614c803430998fe8c89efe7889aff85eab7271cdd797ce756cb9e1472d5358dcac4ccc6b56aa24e45fda11cd803380ba6bd11d9659677df1f55e6bfaf65005d1649b45dde966a6be57c45db69e0675ba0a20a3f322efc525eb1a7f1990dafabdb86c1376f89aa510d6f26250682765bbc040fbb25e8d3d1580b71567dfd9251116af50f6300c6fcd881bab65b0fc187aa10da5e1bbc6302d47b9ed61f9ef724d1e1020ad1d9d107b0a30778a67a197ca0cdf6ad21fff8fbfdd5484ba1c0246d532ef2f6f58df7bb2c7b203515de032246ec8dbe0f20d44a6285bd7c4d874c2f36be2fff21981cabaa7cf8112508c3ddb3cc52e150efda608f9a0c5419a315cd204f26def5de4bb7a149348ac93bc3224e0a3c03298afd4df681828bfc470d2f968678535cafc5a47d4dc97105603f2411582497987ebe20918b315ec6d1f839edfab52686b61ca372462b54321d35b5119d90b46fe963ccd540ad625281c245f8037c2e53b6df5f590f6fb66020fdfa046b7566c2400bcdd9905726368c74b40d1cc40e8cdba7beefb7a7169d605e73c93ae32c67ec6f5f43a064f23de414ca8c34b93f4ff07d32c0c6df8b7c028be2d7f6beeb1f7a6ff799b2d8562f7af49084659f05cfe1693b3b54ffbb6c9be88562754002f7248daa7d24ba6b4d41b66e331e2023bc285cb3ecc374cdbe9b3df60a5f94e66e1fdb79c0314b44a45927caf3d1f3b2727204d09c5c59da4ddac789d8857ceca622d98b4a7fb7ee945d3cd7a6558198d983b28fa691ba08f83790a2433c9c8dd885b9cd85fc0383cbebbe405fd5376344685d3efd2c1883f036edae3451294422b9221928ba27ce9e695b3ea47bc77d10f747d119076c5ec460183afaa36a992d4d65a6f77400c59b83069999824af51f3e540f21ad9bfe39cbe863efa59b3b78c1ce10cef156116ce009bedb1cfaa72fbf54c11833872255b65ee7a50c62fffaaa8ecbaa9911175cbaed718553c1854b3f12f08801b631fcd461488ec0a64a8c8954494449c07e56bf974c668edb49808123c4ea3eaf22b7fbc64dd876652ee39a1b86ce839b21ee18c053758416ed32111957233a4152becc6e42ec72995bf75e71135548f0bfb6e7cdb88cb10216348fcf19ffdd563b208c53a0fce982510f3672efd61b95e776c2c584d503ec9317476b781bd7c5ce717443f3bd3699e106f452ea8c82237b2b623f40d4794b1d4ced652cf4f338d640d61d42b046390e884f9df26ca2b6163f69806c6d8c9064d12da560b29e18fa9129d2daf2e00836dc776f471bae9b181ce4d3f23a6fd3ef759f9d5851ced4730b79fbcc11d09874b7c75560ef4d14262f4edb63e4459bf07f1d93f6c9d9bb3acf19e239d44bf9cfc6b6e12b148b7012031184ee1901f64e866c7d53da8269cfc805be33a54d2ca17850478a00462f5bb74cb641dcee8c2745a82274bc59aee8b96507bba63aa6f32a860fea21bb38ef27cb6872b41651cdb70f7dccf04f34b1844c67cd4e58deabedff744cf5266920e9046b1dd4627735c45e9defa7653a517738e2a6035c34a8f41dd2fb950394f6c3b49011d1a68bbe76f138c0eef6e930771afa2926de2f3dde3c1832b99f3a4f2e3e37c6be2edd414a7965b157fcec5fbb3c04202c0512b8187b0cb8f3340330d3939ff991ea0b4a687a067e4f77c0fa7dc1c55942f875ef656063d8db227d49ff9456af0d17a6c9412c72d91fcb98bc0ec410e9cf80d2c4a873ef1995dac86366825d822a7bfb4629f6b30a22603cbf39a8c95eb343f70012d63a122107143bc322ea58220803772f9e0a68e3b0bddd4c0a01822cdce4032afaf9a48bc76ba7f53972de0b5855820a6696d2b4e55172c310f2f64f79260c355005232d7eaa7d567ec54acc3da52cf8a08403e292a10347a148fa374fad5b563d098285b0b4d7345f124c4253adfc4e9ab423216ac373ea4cff81e25928327d7fda21459aaf3f550f89512bed761ba5d3a168d797032cce05ddb85c1e92433eaf4abe4f6fc0c06c6beffa73594b0c8fad8908931275cc46ce7f96bcd52c4d4fbdbf038e1abfe41b7406b2322dae6e8dd980e186d98745fd0c0c449587c750f0eb96879ff278799ec239e086db803a74a2ea90e91d5a2d65d70d496169743b4be9e1abd475bf2ecd4abb760d5f700572bf422e27b4a1546047956788dc6280d35061ac205104bafd184ee60ccb88527902c54c4c1caee53a295b110a85406a954dfb2f8e165c80f645e8572d2f9d25bd5adabc65dea2935777290927d23bb668264d65c9684fadb3df9029f0f3e8aae767e1fddc6be18d269b5705832801add67a939bfb965b72e7725060da27863742abc1a40214e107ffd753980515db7ca83f7d6d4e1dab2103820234279f5b575d8064416de30c714725ecb970f75f37b4e16676a734fa97834eda12164ee374a4991bd694c71b8929faf1232e78581ce2e8efc2fd20c15b3549a69037767e7d487c42d6447b5d4a6c2bc98d3445c1fdfadfe6c41e16866bb09475adcf2896ff3cf531f5c8a88d24e814fa3795c2248fb87d776422e9e40d3533f2fe393c9f8ef9e0e39bfd6bdc1c8baaf16799711d566f31abe33e1bcbbbeeb63c9e7a27a1a6f5512caf7fe42064a12bd7276195e15c1e8f3ee8c74b0cd77e6da1296d825949faad4fb0e31903456cb618bda7baf81100a65fca84d61591e1e8ed115ea5b5bcf7e218edec7388e69a1904d893fb8832c81cdbd5e7cac3b15e473623e009b430bf4354a5523d284221a4a206140ef6c3efcfc91846c97430bfe0d0a4adb05aa2f5e43eb82775113e783e94518f15f6ed0a34bcb830694bebe48b8127d940de227398791e4a9e804eb63d3e353395da98dd7ec6ecef65c1ac686ee5ebb70f1935dfe4c21b78177ca64146f56b622b3caf48eb75682cf8d27cdaea806055a5a97bc9056b187017bfa4bb1a9411f2d7e99df18a971bfbdcf828987d59dfc8d237d774378dd2516d711e0c7241af7dfa343d9ae7359c29fef96c252e71438f81b3690380d0153a03296ab06447f80312f89e6c381f2237514d7fbfbea5bf8584a34f828aa5f6243d6d4d93c703f157adb086343a385c5c6f32ae79de5afb8747ce4d8e3dbd9ce21974504b2ced69aade47132c4d6d981d98b968fff7cd075c2d46822b812e55b3268deac2400ecbf87824ef3d7e1030c4bb36a49d46ba00b3bca0c34f95fac04d9e5a5d57e52decffd9d36d5c65c4c874dba45ae6d729edb26483895b65b145da7f804200b5377271cd3b15aacd12c4d3da2888b51b1555b267ef30c58f7ae42d28cd4b2894280b0d9f11adcb1e253d48e0e83758ac2cafb01995a8fbec84e6ecca378a3eda002363e9fffbe401f081e585fe7a29f511cf486cc3738feee50d33308313bada28b0193b1874ef9e2c15cecfb632d3f01af2f5d2be7fc38d6b465ea9b434571b0ca8b7da4ce21404169e5ad985d8b84d7345e46ac1a3da3fb92094295883076ccd59d8e4513d08e0a7e25d7e01fc07eb6865b5fcd2a89fafa95e2a3f6d2905fcdc160a977ef03182cebf57ab5e106a100041103d8ced25a78d2fc554213fde08a398f0b6ba65a10c8ef80c350c7f98e68d7efd704c1604c2bb537a71d0e4aa96bd993e278e35e83bcd0d77055654bdd52b76f60658ba61d9f3a4b4c85e1102c7b3188b028d1b0b04fd3283d9027ba278795b7dc27a1f80494c36d0fc139faf1d108c4241500fa64e5a30ffa103ee6d02700b4e34b2bbf4fb12ab9c6a271566d3368fb6e43fb9c8233d33c58bf1ecc8d24355b8fe300af5abe75d2dd22d2cc29d41047637a3207f78cc178419f33215bd24ba711e640c41fb33870911a38b9f216c358b6be834a02c64a4a65b35f49286b4cae30dc8557e0d747dd7d08697c19a73fc759061d1a25696683ea1dbf68078fdbf93b919a30b5ad9831470a787a78e96fdc93ceedf78d64436391e64ea0d925bd4a6270919c6e0047f55a9f61cc232eaf30766250b13eab785d1d468b613749b95a09c04e31e70e0399b24af8e6a2e0bea10913fc91488ae71b37012c8f1bdd0beb162b2420c545ddebe0170665dbd1f4e8d3c562151ed6e5ca069be6565680150aecd9e1335d17f39f74fd55f6427b8c1ab75fc98293255a198e31a05496411803d1b544c23f4d03367a8dec5cfa285f9ba28f0ea57cfde9c11de976b7f92fcad217b9628a1f016a2f6150b12ffd12a42c86011fac0fe0b478f81777d0d1f8ef055ffafd27a30d724cd5da791bf62f4c6ca039ad51bdee9fdce760d1cb8d346d188a2cefe52ec438a590bcf2e88fb14d7f41c10d8d17280007343edacb63ed6e8ca4932ad3a34577c862e6e64f872e5c3098c87df1efc913840d55c8f85ea4313ca91670837a86e7b3a0b249622cf28fa760089dd2fcf13bceaa21d91126bc0ac6d9e47b42be8c096523a3024d3491014fb0796556e94db5a0f8d8e6ebe4148930cafb4f3a5021fed1e168a15e4a4161f79ab3403115bac4efb7d756faba2465c0fa090d7d064742d512d7316fa193e5484a6626e734b5f89bbc98d6752d1f29310bc2207814e935ac9c82af4a431b040bd26fa6d04d6ef1210728c7a349a95bb8de754dc586ca87a2acaf0beea1629d2df6c5edfe717a52f0273ebacb9032dec08ed4c9cc1d5bd459e98864ac36a11024ae8e0246d40e1251a92ef39eab0b117672fb6e5f540b123f278b4b038a845e1801bc2d53eec62b50ef57095f684ff9c291d926570588b6e7d9ec0c0afeec869049063c9757173d67983d9f45047c311017f67cec6d1dfa2a078bd8ad3542510b9fa56374134005e7e9a9c8aed51433d6e063ce83998bf52d827cc66dd17daad5532510920656f3e599215d2da5b64f83a81e90bf1fa6a4bb4b79b6c53653c0603360bc06c27b671921a095a6f857b5f346a2096762c4905fd26369140242b2235b2a016c3471a84b507a0aebaf052e7d04b9b639ec36e34c921d696f10deef9b74e7962ad77fe0a2d0f0210b23a8f203d91c633c225c3873bbd11d7662a1a8231ba2520e3313308d4acba35d0880bc2c1b0ce0bb92eedd6dd0bf8be86324152a4c440001f26a54efb73cbdf05680957189477b56103ada8f96af0188cd10b8356c0462c6f650fe9fd5804d29695e6f273180ab4221492fd75b363d4877b7f0e5100c8f26050513f4a06ac0b301d6d02d888e4affe786e74f0cfbcb2125153a7290392de6025622da8e9e07af42c096aef303e7c5f45ba184059bbaa07d6611a4aa1c8894b3e6c5c86d0a0c503b8b250ab960291d3fc94bc3c820d7c831e990b22776d4f9cdc289a0b4db911ed7c6deaea1cdb5fb0bd55af69ae308b8e1869a8ba9455d3a26d0ee751ba8a1a2747bb4100d901cf0db379cf321f2059f034e13a232de6690fa6348483456cdff5f337fb764953bee66d34ccd84a8a6441bbb07105c300db14bbbdb6a7649cc3d96a84a54b13c64a092d75c9597adfb1e33e431c7ef1e2821b83e0ea735cfdb0f546bca751c14e5797a05ab21e9a0ae0c6cd8c56d3a0426d8a824300595933bd78d668ec1319a7eb018981e8fabf422759daeb6f6e3d1206a9817cfbdbdf371dfade637c156712ccdb344898dc28c10b8cc4f9546aa371f10f4c14bcf67071b7c902ee1999a0ff1f803b2343017990365561636d28b1ebbe2935fcba140c3f6ff3cd21a10d2214b65352f089770b212bcb111e5d2a9c238446d1a13a8e8e6485b93d21b3ba69d80a9d0f9b49817c8b69e73558d5a3c3ff8e6dfa473b2a539298bee508556a0aeedc7df6fc8c042c9e8e27a3582e575ace51af76d00a4a504ce4c08fa98ada1bfd79641d1b6896ff985e98b2724334d22b864ee485e79718400b5ec7404286c7320b15d46eb6a2d27019dcdc149d26f45e0583834e0bff57ebf4626fe5800b4cac6251efcc0f70b1866ef767926fd83e3d759bb0a7a8f608b064644ac1e3f687e682bfe3f1cb307d0e9dedfbb90ca3e3273cce26b0cf68a0ab4f0e2c73ca2c9cf1aea6bfc4c7494ced2c6979dcb6f1a6caae8a5235f56bb99dabc6673d2196cf54df0b7ee7634d0f9f0f08534310d53cdae3517980709a348335c8d2313a1d2a43d4ac7b14e8a261c0d2a3aff9dfbe36c07358423bda6b17920dba6b8a4819bf622cd2c0538a2aff169e8b973b7c880f210204033fa24904f80112aa3df39dafffd1963376032dd158594217087f2f83b86b245b545812b1f151895f8908d3332a86f215b1d459fe60cf786d49438e5fd97c2f9a24840077248abe26485e320fc1d6a88153df17a493aa3925dea297b056478b520da92374b5e9dd1d44ff4095f0d9050a24ea994006cadc038c80db2f28c5fd6d1369fb244fecd72d12bd3fff5fc3f05efb5105942d081d3a514ab1d2c99eb150aa2cbdb99d1c243da5bd5e8411a9503d3721c8e731ebe19c23e91868d90d182007fbaadfda51a280903c93120e52dafbc4aa1daad1bc0299e26d72472923614d2b7c2f6501fe3214187d9931b8b183f0a485f5c1efe8717236eff3405ae9ad695fe0f4db510b8ac81385283e49794ff24383b45201d56186a21a9266962ccc8052709a77f1dad970de1d3cad4200a1182572c04b3f976a3ec8f8262203cdcd211854aabbb599e02e726cd46bea882cf4cddc1a0748999c9cacb28c2c494c20bda87f373d5352c278c89a4c5f5ae3e2d8d2fbe9626944840ecf9a2c7280906c356c643cd021fa7bb8dd8bc330b9f4771c068c0f53c1eadceab14fa9dd2bacb507f22756bed7af0edb45c0a2c192be39d50ee45f5f257168f7a570d37adf9c1f03a7f41ed9c05725d7396982a47eba51c41ac6e7d14b1fba6f857a86ce99053ce8f45fe0bbfeb0ed9929831f612d3ebf3cc24f77f2bd5ce2edd27d9b86ff86ccf1a2b1985d0abe6cd26e4a3248229a67b985d9ee67353c10e9d0061674783b7dbc18f0049fc0c456ede2c74b23a1a2fa96a8e94ec29f1bf32181204f6cb70207282add60a507f5af0b5988552e7a552ebf1de2c6234d1f4d3de0b6dea77158d92b494018fd66f1576ff83bf685d3f915563f932ee71788caf14672d7b2976fb5bed5924ff9120f50023555ff0da6d35aea54bc11f9f9eab69c1c9b2159a92e9f572165eb5db719c30c560a4781a8ad2fbae7277ff7015a0a99032b9c94060adc562d28ac4cb9d6d199ab48ca8e088fd038a330d2ef1c37aa4d9b8bf54e0043d26f46162554e310b3059d264975d1e38f04cc9f14a8bf8afa5dca425a3a6432fdb5e3597f4d98934a0fa91233067fcd7c525dd174fe3e168f8e2f7d560279fef5d650eaf90cfbcd5d37de17e597370d450f74fc70e933175c1846e1205b14417a51cac1e976937767318cb9f1251acc50f3a9010a71357b874116ad9fa1227008e408cba0e1b11960dfeae0660c2fb1e4aeb954c26a691bad32850bdb09a31c8ae44a1b968e51110c66fb9506c11f4501f07495a5f8cc96ffcf7b98303803762bc110080daeb3cb699cd19e45e078033888104f2f763c439723271dd5323e985a73906228ca613ac4155381f7795d59283fdb8632203ad490f9c4e77e794519b559073fe7a556279dab1b6b6704e1adb5828672f957d1256fb88c15b13b75a1dd38212ae8f2751b4ca2e6d5181256901c472bdde1c7b78e31d6b6fa8792da673a9c507aaa81c0cd78e3d5903b9e2dded5cf6271982df1cea19fafa64359cdd994d956814215c7d22cd166f40e238d4fbeede620bc88d21e37aaf97f88716620abaacd62c0b92728103cdba0eb07a99e29af68582a1883cf52553ad67590299b9fdcead129f82ec9f191519df7a86e01145c2de243311d443f8b7dd8ddf22fa3a47b41de1bd4dbefc8601064a3081a897e0799f69413bc22619902bed73b03b79e7dc627e5f67389c82f9bf54e6058053cf5701007cb7141781cd7433068391d1b9044a60d1dc55a846b6cda20078a19596e8b04fbd30a612aa54b5283688d36c8f52ac3ca2deeb0729510a15fd9d1032348517d6e8a24b5fb47396be1c41b3911847958f678e6d3de5fdd124e2378425d14daaa78e41f1d7edd5e82eb4a273342b8efb33c1145fd8aaa8d5d50c7fa7a829c3f1121cd858586f8084404c2e4deeb9369f5321c6e90e1a7750e415b9cf960385d4a4fb87849d053c7a43a2b71605e416698ee641a1cde725a81f01732b825caa5cedaa8b5cfdb3bddb471f4028be6313edec5e57248086b378fc5e73824866a91539023f2032d8624a288d4c54869e07f01491bf272ca31c240c91f8ad7d2f6d723419c26b3e643a436f2ba3c06ea1a9b3d90436d04634d43efbca166f71fae06496662f3069570e9e57c2571f529dde926eb9b974cd0359508f432da374e0ce0f9d44e017af192926c444b05fae1806d92a91b6b2d64deb21ec05f7c6eccc0cf135518d44a982427991ed6a59e23a1e0fc1936279462d09031a82c27674e10e3fa84b228a86b13ac1dc8fbe96fe3613117c3890ae1b4eaee393ff9a7846cb899cc001f5e98ea427dfce35c812f3c4c8a2b4791591acd81d8f1ce682cd191b784eb9214c180dccca1c24402dbe876d1684dedc3484f1513ff23be2091f003cd44de1ded3bfb0e9ddf6c3adea92dae9ec97e2ee376121bfaed2359224f07b34bc07e0d97b68aff1e384dd02798a20b20c699dc5fbb79dbc6bace9946f8e4b3e4c71b9955180b3f7b5ced08b873384622acdbe05c9a6fa6802498674302e38f03ccdf8b51f44e605afb35f80bdf1e160f2f8ddb05edd58baba72d2ada6032c6f8dd655f0a448f9f5c892a92665995dd8758b7b0c0724d9ddf016b080574ed8c95115890168dd22c74b247e9a2259a95e98254351543d3d3ce03fc86b4aca9d904191f859b7e51cfa400ced43c7fd9bd9289b53d2d27563afd80c2cd7f02ed954e24f80c5023f9b2598b025f22df1af1ccbc8bf3aee494ad5c552b9d541051956a8e16298fc15ae2845fb39b6cdca771d57bfaf0903910ea38d6de634f65fa4919ec907339c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
