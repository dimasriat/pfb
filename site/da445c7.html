<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9305edf310d49a58704c3b9ee8307045d1f875e149c3d727dd91df90ebbac7a6ebfd567b0aefa22638ba98aeb7165e0a84bc3acd35e67938264e2079d18bd314dcd62de7b7eb33bd1d183561d867e2730fc7f07fe80d1e95993550beff638236eeb1e008f15e264781b39d83b877cbc265b9b15d70c49abf379399292459e1653695bca255a660121b19f496975fcee43a68ea1e33d048bea689db6b5a3b780da11c75a4ac887bea1586a2cd448f145b22ed3bd613c0ce11cd1fc8b5fc7acf9ec296ea139ebc9b98de9c1c193cf4da023c0e7060ab473de7b285ca3a1abc898fbec941ed4274c67f727ac8316bfaa775a0afc7e550a47c4a19559b146542a1b86dd251740d04a42067b8f65d2480ccbd3904dce9b4e32dee156cfed08172267c35281501ed79229ce54fc41b6a02d618019565a7f4d7eea38e81a85ff9990a4d83464fb90cdbb8cbc33a40aa0208aa12eb2be89a5729ea3065a8f465ced51222ed40bdaf1a3d7982674243c287d69df2a8643d94890185b6101d3f4f0e8beacb19a706da0e48855c4077de2fa2f9894c82b3c68bc7a648b00c0f1b1048e3b235a48dd4a5e6d542def2f7c70ed224c6c511dd14448ac41be52e72a486900aad2386188fab34570c760f8c4e361748a914dc7fd82c5970b6841e51ed68c619df5d1411cb40c0e29136284d636cee623a58e56d62823070daa15aba2abb6f91e99305fb4cb8a58c45e654b141368aa26ace5a1261bc02dbfe187d031b2a212d7b48a36560aad14e00007d378dc6cd27add362b4736c49aa38f56b2113c4bb89123d60c0225622da6a2e92e7abf1ab64c09e912cf4f6fde212b4dfade8031ad0487f1db21625025af22afb88843a5205a992f325f4f2fdd322f078eb2a65c53018dfd377a9c051b8a71e6622fcdda642993fed1179885828f62d89ac6d29d80b567c8bfdf7bdcb0ac9cbe5b647860ab76acb27b89dc43791d0679e38ca0c71c41347f41c107d416120215cc673d03788cbf7204e1303eadf14cad486e54d652a478b2522e2deb42cf94f614c4704f2864f6a24c13b5f24fd4762638979a91617e65a211e03de3219d976ed0f7113f2372d887235d5e4200129ccc436baef6ab9ba9a3ef455f8c139d20f8a431f4f4cf361be9ca7df63fb7a5ae9afb09eaa1299ecebe0267c0c26efa31b3b205459e6d17a46b69c8aae9c8c35bee28e01af3fa020995f81101c30fe0c76e53fab0bf2652d8fa9053e011088707b24f8c9d07a8ddb44bb10aa675336fa92ce0532995cfe6d9a96ea4f347822332a36d06473c007787899575290602242e848be9cafeecdb762bee75be146151a5b11e86c7e4ba99623f0e8defe70e1d6f3648296a653c476b778b11cefa22b4544ef9fa9a90cd0f2f00f582efb29d344600947ac856ea0f9860174f0d33aeb4ba25d14f0d9f5a014f4293c8ad347acb2c93dcaeefb1e114e031a2168e431e4d2c57381a72575ee029c57135d05b2a577b642faa0f113b826480664bfd5be1fa9ee1f0f3741fb3056cd3e6f0c6f4ab84769761c30649f02bb4c6ae7946394bcea4db9d2c64b0d874c3d5379f27e453e0187ac19ddc150d539030af226b7f539c61517af0f10fd3e8185459d0d0bfc6232bd1298b7c534fba5080da54aea4a9f3b604d2a9c25808bf1108a3d907f8dde0d4c5eddebda4f3d1459c5de2729919fd82893021b425df455b40c4189328a9fef1b3181db54c3a518edd6002bda89045b93d82f8096b75cd1b29d1ac92f03db5405ee0e3c7c289bf820cb16820dab13b8862729eaf42c7cdc431b4158898e423167ae5fb371bf28a674ff5eb53846103e816e24fc4a49f22502c2665ea8e340fbf1b30f836ca381f9dec6a67bcfe646630f052bbe20f869fe54a138becdb382cbfe11ef82fa7e5b0c4fae7a497c30ac800c2cc6bbe68bf918964fa4b72cbbd3b41c069cf3924787c1837e86f21aaebf4403cc628bd8dcccf6f75d37b655d6aa8c79c9d92dd520917ead58901df170a9cf7ead5824a77b7ce710a4430e80caabc07e06d570f138c084aa494084cc39b81eb3e8a7bc50333539d8e9c2fa0a0343aec159fd8cb7a2cf34689f2bbdba80f5e6b18b1105604e10f3686ecc405701f33b9af31f35e3347a8e5ad438ea68501999127167a698dcd841f9baeaba273785157054c428f5aed9f084897a59e73417ec6911b5c21d6dedb0a55245b3c5907d34113163cfb1166005f3740643778bad60953a651f98e5081ace93cc722cae99f6f00fcc6ecb42b71ef35d1944126e3cf0f5bce6812253e6a3382e968aa8ffcd19e1fc36c0d3e4ea301b8ffc635fedf3d9bec862a69e24fd95d83b7a29953f256184217e15438055de32011fb0004c0ad2debf59b2da766d678cf92975bc23e9a3efa32c59c8b3f60685d67f24837523105ee270c68e200e9e3f290a55f3e92d787a83ad1c7a341043a33d28cf0f40b5808a58d8a7a270addd9e92162c2772398bf9d9cd6039c1ed8fb04bbadd0cd163225c5df45e2707cd968d4b71af6478666c5200f48411aa0783b52336dd9e375323a4d7b2974d83e70d1f2758f9b3af6269ac6415c663fe9b94c865407311f46f9cf1accc75b1678860350161740e4119da3e37cdac201c600bc35fdf3b28d43e00c0922ee0a781659008002a58bdd243fe312e7d925cc5e6b62b6d8d6dde260fa84bf05c08cdc1dda57bc29938829824b3c74b47c397737c5b3b3b52d7d5903d989dca15533eab829011f09e99e7f12d8eb854e516af2a48ceaba841e20d270a864bab9e8d6505650384837a31579057b658084bb56f8dfb671e85ba98fa1123ec94292133c6fd27f438fbca23cb317e3a94a01fe55eb97aa9bd9515ea5e26eb862af106b387e62fe98e8ec562d6bf7f48c0f80129f061cc2d96d55a5b26952edfbfbd5134f249bb545a537b60ee8183ca78161758319f740a57cb005be54b60ef9de4fc7fcd0fbafaf31fad9e8c23f42221a7cbec07820057911f11cb44eff0b10fbc9294858ff4a8e40447cb1b344451560e64b255c54d3f5cc4894312b82917c90a69c0c379271c47fc1bfdcac795d5ddb1b7fae209dd3a7bbb6501781008bcf7a975a782ad9901f3268523e6164acbfe978725ad0454506af12de374df7ddd2f4ea8e5328eeea9b274ae381dba9f5cee81c96d5c7c8308f2b28c08a6ff71f1a8a78417a72d42e881cd786263659c7d4e255861328fc73ca918338f6722ddc5b9a7f77e6300bd57eea89b2d62d890e9ed40efbb92d915ab329c2de62d0217d3715e61daa117c02cdbde042084834b62b81423451098269f2cb2825350548cafa3522de1532f745780723b6469ef7901d9efb3e0dc8ce506dee369915568bddd429058b02d3a8a7a891207c3325b14b37a5b20fee5288581b2be94ed94669de4072d2a0058a4f336044e07a8c73e0f791370eca38ab88b5286329da9003c861f95cd0acde1583a93c000b68c51565d672661e9ae71b072ccb23c3fed14f27b3b86d6b7b08497c2065db5c911956e9e01690a9f7d6aee53a8f440f62bb0bd905bd82947e5eeb898a40fc1dd010df96531469614566122f930125dc894c9232a6a0f3f79751b3692f6a16167e000b2727f9e4e353dce2446306d2c61b33b9d369e253185d334072f3039f9db5a521fefcc99bce98a8482fbbf12ead6b9a0c4e75e53c1f909acf41e58619a75a1482c2f6cdd988b7038fa530a5c6103b7b416b7d7464521f0a0670a2a2b4540241129f46a28d4cb90ba97b30d28b5521c2b49af4b7d22966cd4aa866473ca0f874a98000e940d75609d4db945fd68a1d1b2843ea7b30bd344f77c3edc0267cb7c4c97a9cd07cde90816c8aa0e426430f0ce4bb5c685d637a984eb51f989a9fb9d0dc69f64f1a44a8e14cad202c167592212bc70fe26be5526d1104e03c6566d282e9ab4d09d4a95448a9389f832989e39e0791e7ba9f34e80b4b411291402d2c77e71906e4de3fcbb124af8b90cc36d3745c8dc5d0e81aa5b44dce5f6db800faf91a082ca27176be6f50f95d0db6323e98a1948158a69677a95f6222397ac3346caa6900e804ccbad16599339ec43c6d5becc98812cb186c600ce0313650d8c6760474b93044ab8dc18d06ae2461e8643b34b5a0e0c0a8fad1f6755010a5c41e9166ed6810a7ceba75bd119a47b323dc2c6f2de2ae84c753cfe9a959895920a9e63257105d3fc0b8266751e6d41494460694394543480cb58c11d390c39f030ec857521d625061ddc2ed1b25c8f4b852d2c93a8fad81cb2fb53b279ecbfe1cdf734b534ebb04f83509c2c9fa5a835c07a572dc07903de52c25c25d03b85aba525275696c6c0324554e803ea6aef11f2e6b80e3146265dc75a1bd02e251eb7fbc97d8927a71765e3bf11dbf744597bbfd2747a90f0aa391232f5cca77c1f682c0bcb316a539fb60973b957c7559b951de97ccea6beffcd3ca0d7ba7ed7cb01912c551a1b1080ab86a3f13f62bb3889e7ddf0cc9ec47bc783c26061efaf5281f8795d1b57932318ce5ef7b951d33e30d3066ce243398246a4d8a7f6a48d070d3708579c2b12ceff51418f442896280c67da3af0f7f1b98605061153a082e7cca9fe697926fdb36b7ff90612fd7691f566e9d7f147d14fb7a105459d515032ab4851984634fe418ba916ebe8e32641275136c3fea30f09af67e7fb5cf9aacf0b188beabe78814d4962837a1c4a613263822e690840016b92d05238ef5850969d22377585ffbdd1b07b267f15fb056ea8479e961b46ee0e77ebc350bc9b5a0b48109d30fd8c0e43cdc05d27671a901697a21beef1e02421f40296a7769e11393ce34607cac2a97523e11639354ef44118e4c4c73b3ae8088e80bb0f12708b9fb43e6553cd93f067e308597060549fd346b954a88a0f48a6c1674cbf66648433ff63074bad6abd1bcd2122be6d04fac11ac2e77895e2043c65164ff42315697bae85aea406f80dbf46f7cf29a2ed29cfa42e51804f1a6c6b5f79e7a943bbc73546a9ffc11b92846a7ea7ec923d6d354f265fbe8a0cced6bac01fb10cf834e9aee1a33beceda70616711d02b03b0734772bc759c893239a37806347f6c7e42e133f8a103d4892aa239ea35cd608ac225ed19905b456a7acd2a58025267cc4898afc240090ce1b986c9647a89e32133bb988cdd01765dcbd8f163b428bf896b52f9fcf4aeb580e691eb099cfd9c537757fa6e4ff2c14d5f4cd5d4adb4bbe7e324cb0a1a02ca6f64a5dac15c5110af68eb8f90ba5ac7f0115a5390c57ecaddd828d108fc7490ad1d708508d6d278c72704774dfe7ceb25686457a2a819fc6d51919ee605e68294ba38bdda29cc0dba503059f4b60fac947ca1f53ea08d15041e2a9d3f28d91f2bec04d411dc963f6138ee329db83dcc61ac043c27d8d6a6b1b56c0be87cbc1e585fc941b54ebd37834516a0f3a3207bfc9ac88cc6eb720d7cd65cbbaa319c1fb7cee37fca9115cc0c512d60b7bb24e5f2b154f3c42b53c5f39e451cf77788932d3ecd4ac6626a1af517e3018ab77ef5ce3f50aae4c3ee7566d29c3d628e7fecce0d3470ec7c0b47613d125bf2c34b1b9230e8182c082c957318c9475fd9134ce3c6a8485d60b8324883b664a9aa8fb1feebdf6207752ed984d3af7ad26dded14f0ab80b7c3438461302a5be8e86ccdaf47be8c8c718efbf305f45df1b256b488615f55594803f30d277333885b0f5255e5e81ef8dd8cf9d117992dc0411a2a5f18fb7693bbfc57a0886373a4ee38513486b6988ac02a5a360ea91026603586861822a8d4cfe0c8646c1687068a5ea01d36525a4fa2767bfde139518aa8dc43f9f2773fab6c7159a936e0472b17758411a7abc993e02b209aef051c9ec6cbd55a6167e7f74568adf5101851627dd944e5b7aee5d55354a4c50890e51d376a05976ea26fd3c5503017c05b1a6a9b22768a7f740ff0d0bf43477a237135ef6817986f616ac45952bf59ae273b6835e43424d00d35b9346e1cf36748669305ccb462ba036187f225c5a7ab29ef3cf0f3144755ab10631e7e7de919b3c21b8ee2f21aed663ba7e121d39431fc10be8ba9b9c8879819ceae39ec2c4cdaa9584be8cb2444bf11efcb6472856736641acf27aaeab424d0a24b4ad7e48648137aa1cc7e104d68a2adcc4d3ecad0336b3b82bdcb2a05527f1374b60923ff3833ff3cd868bb1c581072af76356048672e6435d9cb59055a0024bdf9e75d6db497311c5ebca8d024dfe99dc3052f5a2cf86f2064c910b6cab8ab2c634f0e3af019e0ddb1cdfac7cb09f36267f9455d61041ec66949000d0a8d5e22ec6c2d91c2cb4f55bd66aea9ab6686d2b78800241d1228ed1dea230878ee1fbf9d5abbe8b8387fee4ec92339947c9af9b73bc2e8abb58953a53f6270e4f02795d70180946680e51bfbb423547d7dd20c4502a1e1f67535445eed451834f6d53e175a5b62ff5d54ae9254f978e3343368989b2bbd467325e38e845aae7c2320706f171a193fc3cd30944ad4fd72504af7a38e7f5db3e496e05f00adbea28f5e7f8c21de7032fb300c44fd235996ed5ec45ab311bc60c4d748edd7031c29fd0f32014191dd91e7a4fba25503630670b6e4a5739736a0134158f0c89549497f1513b2e9c3863a48f39983448995eb02b3e3cc35a5d2259c48561299f21e1fd9baae1906dff7f64c0cc6585ce6b95447ecbb795164e374ee6ad2f8de9ee74e4f570c1e537a7134731f3bf2952deb79d006574a05ea0ac8d472a08d5a50176cd0b36e0ea71024081ae763b97e72bcfce14e06fa732d422c15b0694638ec84f6b759f35055f09511e19033d14797c8a846e930e22777caa62a5d9c6827d31ac447e4d1c6f3fc728ee6802c181c362ab18ca4b8a858db031ef2c75615b41805e866628220b26faec22a61267d33daba8a5ab21deed28a405b68d7f07f7eb8b58a60ceac092cb4f658384ae18f614b4282f7f493b2cc9890ccb06afed3fca492df6cd22b1ef985657c4976e944d9cd545ddb79128e04f0fe0f391819ed52bd173b15a8e38b16cd81b3377ee2c5e45a987795ad3ba8f51df3b526c7730b35d20c765ce4ae63c62bba2c0bd5e94863e25b1a3c86f288897a51922801194ee4cab47c91a409fc7ff3da3d34f8a7a6cf184277d2c3b987446320c51dd11dd42be37ee6c30ef5df8b4839048f1bdee9fb5938f60ec9313538120a0f3a68c46eb81d3970a8e144078acb975dc9502bd301673799bf3fdfce10414ddc6191a60dc48d21fc5cfc997fd68e53c6d78074d08df89ddfec6a85c75655e79d5a4b047822fceed77b2b4714f3ec53c536d1c4d69f36a1845d5211d9f17afe0a816ef4ea6495f5d2de9e760961978ddaac21e9ce16edd5ef4b7eb8992a8c474aa67446fe2c41ec438876efeef39e794c212684dd913f9da63eec81a60bc103458dad94b7a689bc3138168289f6d3acf50fca74c0ca0753189847083a57b2e5898d6717e8da31c59d3eeb059d84d3babb43b80d2fb2631df0350baa89e7e9f03a1073ab9628c75dd32c24895686d1a3eb07b7adbd8171cb0caa52a5aae4cc886652023520fb1c763add639aceedb1e137215de94961ab3f6a99f5f46e08b4ede7fe5cb9c436b40c262fe9c47fbbc0b247945d4bbc696dc81ef710a886fa347259e27d73c378f976900f9d9bea3c50915f27dd53eccc992cc76e2484c32f38996238e8fc3b0187069a7f8b6aa4e2bdc4368f0c7bff37ae3a80a2a28f4e11b65ba134f583bb5d7a7567f1f9d5e5de4744e842fa5b29b51ed2e3bfae2bbe709928c25ffc0862171cb2794c1ec369f126661a6c989bc33d28f24d263d299e3bde000d65bb63f89efd20a146f42e08d42074784b8a6263832fbe9501a25d70c3cf62f14cfe82c09e1ce80b67f3534180d00dd0e4f297a63b615561a9f291f7586fc35d283d993ba92a11d9ec53d45902a821856b4263e2cc1382a7551a9c502b73e30a0c8e1b143653375520da2a865aaedaf2da58aacdaccbe0662de0cd94085fd0e7807b7d0a30b6ab21481476df17458be1f4c63c5d2c0b45a2579a01a2cb7674af99acb07df26eec1946ccde20942679521a2c2a0957184cd82b316cdec976c55c72d99ab1ae2a25e5a831dc981a3cb3a91f7d6c8a8c76fab3ceaaef95a1be2df3eaeb937d204a741f728a4df9b3b345805ff88999e94ce677f1c45c090bb26b802261789756f05366c87473e085ded76e22f81cc2b7572a6b12dea72727cd91b80f8b9bb6eb9d7a74d454a99d752c9392a051c0a752a8c7457aa23ca127a42ec977b1a47abb5d6ed52731c6098abbc14f136f70cf43a98d389b1964e64f43e61314800ae76c910a28058248e15675f629f9d70a50a8c025f463421f5488619981cff5dba3e2ef3b7207d7ceb8d8dc97a02ff6beed1d92fe435867b1860fc254435fe2421ff066cffbb61f764258187709e70a15ffff80b24c6c4a2a7e875fd3536f2d1973f8d4efa2e5c8ca56a957ba267f7b3590b0949a823f7d3d2e46db08d5899e0f71f97a1d9f3197475d08fd11d3f69d20b46ea945c4fb9cb50e3155b9b2550789ef77c2649a9ef273144b6327253b4fcf8ab97cec383a42dd0721754e6443292d3a6d0a83adbfa65cbf9b75debcd32cc9a603b6e38a0bcaaaab0c130ccd2b8a0eaadac50a04fb9b61c4aafa0ba0c34b812fa2c175fbb6992f0a0942a1f1f8122fda7cd09fb2102008cd84a1677da313e8d53b0128549aae253a19a6d4a4e385c45fa1bc60d0906f3a4f4b3ed4fc4273f57dcb1ee17b30be65aa286252e299176ac8ac4dae01df2e2b64de3ff65e10dd8322588ce1b542452bd58f1baaae50d459296cbde7825aaefc6bd08b53b2ade2770cf5499a91b5f7ce036f2bd9b328accdc8f3d12aa8a1136f875c7d7fb43fd2d87a639cce4b49368842472f4b392294eda20bc520420733a1a48ab55ee9e29c3cd6875679748330efcf838c2d92946dbd699e00986e593fb2efd96080dea225738b7c0d6c6e1237efe0055524aab9edf1736e3b5f5cbf26fd8d70d2bb65220d15032a5cb96af8d809ce35092816895eb365db0150b1f2cb44c1e7798e411ce2c6f4380fedcfa94d06efd9fabb62193543e95768f69c1079455324f7e6c199f12181075509aff52e25c507c207eb7a44050ff643705b689f88968b48aeba9beac4d841aaa7df85d3982e7fb473ee6c7e6b7d642fca5a5cf71d3c17a30691e12c045a488d2af19923c417fe763d72fec4668c958caf54d561bbe5176ceb593f3b4cba83653e24e53d401dd476387d221af90223dad16c67cda40b39c76a03886324e7b5b256263cf31bd15aa58695565c00479d73a7e5598b3851bb69e26a36ef4a74d401c79fc2ca24a048384496b710874f1bd24b1cf53ab8965523d5de9f8bed5baef30baff9b3aa962352826cdc388664bc8d1632d14544f0bfdeb673c3420f0fa5913f4fb23170eb8f6441fe1b8e48ded6326ec50fbd3159cf27f5f163f151efd01a4faf19d09c34ded2007b7cf9ac6829d5dd55acca1efc5373b2f1d0a08c861fa99af8491cc84f492026c008ea31c10e7cbf910a44bba04d1b7cc1c8e778fc5db49e152dd1ac7dcaf18427d3647fcff9cf7d314b0d5ddeb3a3f737f41d481415b57b3969a151ed39f812bfddedc0e3b8dec7b541bff3edfa0c0f9b32b36681fe13acbf6d8e8df63264cb456fbb6328ea7f12d53419dce7851f588dec6bebcdbc1d4bdf2403d82ef7efb2ddc1638ec21d89bb4096e91ac9778325a6bf7b1d23bf299988b3fc45125c18b9487a6d4200ba9c63080d3c43443a3d621cad1c8c3eb4577874d3561657fe4e25d717e5e7a747b8f36a680c2a0f74d667511adc94f6de175a1f1e2fa3e7025dc275ce7533b031d830ae0133c23b98c4978fa156d0b33852f2d31bfdbc6f3c3b495da50bb6451836d75542375efad95954aa50cbb83e8cfda944f0c2792835be94a1e06f2e96c12afdaf3fd7b577c54f536829f8e1d4bfe09fbbba8398197f10c6d95a9a88c7c931ee6d149479e1029fa4f83404b3a8f2e4034962ef890674bc0f4835f0431308a0bf8a81e4ac3063e798132c7ef4c930f6109ddf1e61c63644904a9c825d491931ea3d54d907ff6e4b0c5c5f5c7aa8dceb41ce79b5d2fde1a40b575c4e76168e627b668e30edb51847d1cc14cc8bd953ef0c385cc81e3860625c002a592a375d2a70dc866c9ce79490014d3100a4f1cbaea2edff761f6f2b036e1f2ddd804039a45f919ccdac3016473eb0889d1a591689964be1004423f3e5ca35429258ca1e496c64d12a062aad30501b83b82d30b2493e7819016f03723c9aeff54aa3c1f98b32bd32aeda6d20f214b9353493128bbf685063cda63e073bcba56f951cbfc250ee7003fb1c17f469a43b6230bf5652312eb9d2e5c55a7edab2694918ac94a8e3718b5ba6053d516b7eafdcf29797c385458612ba7ec2ac4ac4fa770f653ea44d9039e94add806796d08bf78d93bb1761d128bdbad19410b11377a23f46ca8703c9b8cff58c9e1c66742216bb4227865574aaf32d19bcab5dd71eb0b06774437f7a5683ebe8a0debdc516d0b755a6012f7d9bd12522a35a193f8616b67fcf817ac2a36e960fdcd1aa50fcb24440d0c488946440e36a1d336277f1304115be4e34896bd7c258ea1e7fd78df419c3aa6c8257a75e6643cfcc74d5d492d09a3ba510504635f1526430954c6ae4d0f2b7aacd7422d9659f24d011dd557c595c5cd85f478e4184628a688047f4c190795479e2adbc2d37aeed822eba6a57b66c9fcb96fe57b963e9d1f7916c6daa684517f9267373dd447aac1ceea73a02c7a2a17817a7a77318fd1b756f3d92420eb5dcdbab81bb10e4aa086d610a091fe2145be60d69a8ba0bcc8c7870ef5a27495e19bdd29e7dc9477e4105f13a4da38609418c19c0baea623f27f15a98472d8457ae7d6b174414bbbc7d7c5dba2b41c8f0ff25ffce06a8178f2fdd9abc63aeecf54c21bdca3aeab51d196bfd74a1ac141c477a0cd90813188ea6e7c20f99d86a3a7e35e068c82fa450755af76c6f8e057d37ec16c7ad9ecaab2f32a4bef7e2bdb42727cdb6e59fdf4581eb400f521b0443dd54915cdb0fb25d8d2b5f78da9aadda3ad41d63b47481af4f268bc6f51e96f49df3eeb7a771eb286db11e341f34","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
