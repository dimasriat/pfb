<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e00dcde255c17b81f2f24328220af6d7f7fb07a3ecf5ee8eefe43090ef5f14746ccabc656307f8289b786898038b06bd2c4b81e637170bf599dcdfea8579a123e6a9adf24a63b893a9507a2b40e24d1ed1e7eef4045063fdaef3dbf224bdc0859dcc3f6917acebfe3fabec63931ed203fa2cd76de5e70fb5501146ea817e71ba5dc74b14d4e19540f0106ad416e4215345c2c32224d2fe58a2fb066fbdbe7151289f81c7de630eb3e690be8fc3e413775fea7a5a4db40720f0c9c6bfe18fece872faeb9910910635aad3b4e7c08959524589936e28896aa15c49060c388a68d9c1bdb0a3a133eec77ef927c77917369633b9c84c6627b101d15f6749d06fc9edb0a5ced3eff6847cf0cdc19227bd21861f4915f563aab79e7e35e7c4f1109b7900164ff28ae6a4a9841ba90773e511f29c595d85f337b4bf4cab2b23df364cd7e0b89602be02143d1ea6db65cb33a5d2db9627f0c106a1d8333cff90d15888ed58fe9bfea878d3ac10169969af58ecd64537abc94c2f8aba73b2a066723cad515c076ed3ee17b4c60e7e364bd3b6953313f14d61d2ffd5f88f3696a067bb162bf6fc057c48e715542c4821901ed8fd1357bb3aacd0817b89297b50838f0de2312528feb9411a967a93638934b3b9e0d9c5880c527840e4bda71eb3ecae87220ba18885889658b2ce179d35ed288b005b6849136a7e09892f87fe2614c4548b7853df9da0edc437e0620bd06d2b32fd84063806b350215c7c8ba0709a58b51083fcdf66ef1d11cdf638be376ccd03453741068dc8d665cbdfa9882979b93027c1edf4b31fc2f43fe5838ea6b1a0ff86bbc850093d9fc38b75742881d309e52901da53a3069e54393ccbe038cc5e9ccc18dd4fdef3d5ac1a2a886a2cf3e4f70fd544271d9e5a805983c9f07dfd55ad94da66688cf2ff1c9ba7ca6dbdf37086c0fa4f2ad354b743fc5cd4a3db06b61866892c251a432f2cb4d7916bdb5664e8e0fce0e7d81eeaeab82de2e5fdea8f429ee53500fbfd69633fb2ebff590412ebd309d8e7245beea1b6e5b8c74e7fbda98c5a04543547bfc68cbf21847a5f83804f9e969d61a4da24bf6b64ac7e66368d0608aabf17f3038cf69c88f8ac53066e6c6c720c66ea4e7f31d8da24b7e4439c01331b0e5ea533cf9cb7215ae61ad1579753ae1d7ce98f08e17c1fd0a8614153fa59466d9e11a5beb224ed2ab3d1f401fb1aeef6e9b237e551c2d58e5317631e233c0ee69b33d8dc347bcbfe956df1e518b71bd5f6f9a2746d8cf33dd10fda7d1b7bca275cd222af54220247d9aa317590f100ef0bd0f9ddaa267d3e9505676d5786994be38986a8b742f99719f108b2420dd6d16f5860d82f1c7304ca7a14325d7da12b47a1e80523a9005ec9f22a984a59b03162f909340cc832ca26a5ff29c8600033f35af121e204c14a1d45f71f463223394da77a096124f51823cc3a6570ff78497e185274652fc309c74c3908198a1aeb1860be2e8821b19291d8f457053144f6bb7fdcd332a70356913f67e5181b3495594f847bf678dc223268ee8d482a369e71ca0349fc9eefbeb8acc9ff121307d642f21f404ccd037140b410795a7956b59cf5f9cea1ac7f38ee097fb64fb62c71e9cd03986ddb236471293c3721cd03560f0ee110b62271f55690f87d9a5c6c973dda26114b1d6735640b3d23e4042c4dfb2f031580268654f03ec4eb52661d0336717f2ed25bd422f61f991468465b495e315cb33146e4510b3d3cbca495b32e7518e0180cf9e50ddba2dc30511b5b5882f88b546f7ef12a2992934e8d22696125f2403e585d816734e1a9c4839c6f531c6b233f27fd18c75a0f3bd0fa5b97370d8a6cd67282eadb93fa9ab26624b87b6e0df247e157ee8516d1229372e0452557b397a6edc0aaa7a0357d8e1704073b227d8ec1e2604528117bb4e2ad3095221e5104c38e6b9caceabd8c4d2336e968a3f8a8e5d1e15fc4470a8a299ddc3ae609c4bf0817c738dbd5e15042dbc031fdd8790737287bd0c12ef8467a2657ab83094bea9efc1c36196d8f42855e89f5c44ce851a78e1a9c3b03838c100c70b57442d6149bb2b4d21850651d53a041f6baf63b6a0bda0b6ec7ef2f8d40a6a15245f649fe2aa569c1737e7e6805671730ec840a572e3edb073ed2a5720a610cac691bab070365d8bb744480502ec351d262d1abd30279b08c45105bdcaacb073992b1b594ade55d95d0ea3d477c2b62ef1890ef34767f5ae7dd44a0f0f254cee5b06a90240b8a451bdcd12f788aea84c470b812b5670cb4ce8a95b36cdbf9dd8318dc8b423043973c963926a38849a662cb2244c8fe5fa0f3df6696e736f2910fe945028619791cd762da47f5bf2158ace2620679fc5f999bf8d5f482f8d56a685541ce7d147b3f0e9e9d395fc2f5cfdbd49fc497eff6c2ebebab622c2bec2c6df4d5dfb54e606fdf70a43d62154a3f9145ec303733f79273e737e48cfe343f84118a852b76371c66d4c52930f53bae32e1f93d292b4843c3eded72d4cb59d695ae5b9fa11a3fea0913c9161c8cbc019dc27d78f8da8852fb8bb41bd1fb9d485b84af18a441d17173a043d2d47b896580c1f73d50cda3739b9ab18342f533b09d385511bf618bdbe47938a67078363c33ea66cc44fe97b6450dbf4c584e2a3d7a94c3dd92872b270dcdf1fa242996ae84cb65be1c03d15002734b4111d20cc224887bc439cf424057b69610de63481499f7572884633090d1c8731846ae6eff8f12e5c2111eb423c6b519f45472f91075f1b1d679d485a7d7e0ecb6d13844af3c27630b4d06840e1b99539b22cc77fbbd9c4ef22191e231ff1018a079fc53b489868145929325dfe820c1694a0fcaee01623617a238e20b64200e8247e89ec866b39de2393fe8bf0679603105ed975e3db99cd7324016791b17eaf6de1a5187fd666be5451b250db1e68bca6e4dbcda0ea100ae41c5e8cd0db69d2762899bb2cc6a318aa29e907e9075d17aaf20f115d1d29ab0d723392740fcd52f4928ec8b6cbda5f646d6128265cbb9ae1ded4fcc34fcb8f81cc09f7a9d9b5fde622f7322e5883f7f39e71b4f600c875f036557b6556bb19fb73df4a2339d2af6d532e750afbbb2af641f7608bf569cf6546de5e99cea1731fd935981a781cd01c965885f0e5a5b2f9b0185093b1b579fcdf6c8e3398dfd030a33f0c5801f578af4f8a2ce81e75f73f86fc27b13fb24267d79a8d7f97cfe20d49225d78f0c4eead065df20735e0f3b414a64b3a10d536ffd096627dccf09d90be13f2905c9cede5878ef96605cdcef9fddfd146acb534b3dec89a3beaa6d4e74c61ab65b322899613c8a1d4a3978421f169af1664404714c0a551dcfe75d4294782c4a27246ec1e7c3a05f3bb9c6a7392a5750785f11cc644482fc0a625481daaae5a876278da1741958c469542dc026db53d581a4d14b4ad0bfd23ead867e938eeca20f87159f8508ef7293181caa71913f2d7c6d67eb5beed8e02cf45493198c772355912b1b63d7be97b85ba6655e5f6a95e2ef2fd7aae5e25a91a1fab0294857556c7188816cf086bc314ac1acaa09aa704e58744f777f18e8c61cddf6a0648ec56e74b2983af48b3201f39b92dcb0664a286069448a3c16fc1420970085ac0ac0745fcfefc087078000b0520965d95e0cc6b3d052a681dac8bff2313400072530690d9762c2a93fa33f5b11ac0a745db8c9c910b476da4755c7235c6521309d44d40095ab892909cbbb99aee1230e75975ff4bf7ad4f4c49f8a1813149908bcb1d427ce80146ec416ef6f048cf2299777d5bf2d89e195fa4013335d8a8b022c3257a6a28c863a8beed982136318ce359581a4b31463cf7dc41abc41b65a5911339c35e331d6b6ac614c93a2cc805dabb90bf4ef851376d23eb390bd87d8b7404af180a436e5233db0cf9a8fdc275c9b7ff89760a7688223b7a7960b2749ca5505e65cad22f54a4637d050821cb01268547546c2c7dd5191911b7206cc29d9d256d72da0c7c6289f5f7717918e13afb58f628605339559b58c9b117ef01c503a9e94669a8ef24119511cbe58c003fc94279a45f07e9f50ae209c5b37267f37eb0d91196558fdba99fe1b42e7f46f322d811e9954ab00680ebe0a20d1c49113068ba34bc21d137a5e24809b95fecba43e7670aef062e8d6534f16b96ea47e7ed9ad25bea0b92de6ec8419b8114345d2b2e67782d2a2a3b7a08c2da7aedae5cbc68bca43d510a4f1ff45220e0152c359a0ffdd6214b9e0c2a6493ff676df73a41b8984ead2f8d660fca4b26f5e681e358c49fcbd9f9eb2d443c5537a14452f2bc55ba487865bd4746c55758f94c6e64580cc8b59a5e1a24fc33d77d508fc5649f7fd35fd9bea34beece061f3261a5c111dcc0d52eb1d7395d084a24588b05ca615be1288f9a98320ce24b5ce35ca29cb6df2230c68e6cb10d96465a082752b94a5301ab07ebfa94f63bf5f7df7699a44f129471ba90f75da9f7011c43bb737bc8ce1d33632a394b4b41ff770ec8905f7feff56a86050e4f44886c3c3a6aadf34cb4645245c22ad6bf0c48535febcc2cc428296d2d351e66c8e1d0cee7021eaecf3bfda97d18ff23fd570690dbe8c6bee39a5f13f93d53ab43767e5a615b998c56108e33f1331ec4fc20f4609fa839fb9e3dc956150c641f1f0e0ded1fc33660a594c9ae414c54e0e7924babb084bb0da5737a5f4a10f595092f7997e590816d0c0df680d6a29e66227bfb60b92e2f76759178865a688c4c6ba7c478805f4bdbafde2a17ac6e76b73bdc3005dc0c37c290a97e1bb08476e2c122ff0d68523bbc245eae938a11dce5b7830cac429d6138cedd6229ce6b2dcf8e5e7220046aaf203339254cc3ef9c67b8a5088806afbc377566a7bc651c1e42c9b256b1e25e7eed254a1f4a7a31ab3323cdd92e1c22806ec5892d4341c53be01e721dd8886157e1277da5cb6e74bfdf5a6e5e917f261f1c3dc21c348c0cf102739c5263b78f4a8a315e1a24726b305d8ac65b3fefb0c883ee45bbff94d9ef93a458f2615d3a4299401a59e23ee27bba842439f05fc1b42cb6220d3862a9d38a7cc67202206a8048743eb870e23ebf54ce33519c135608ea6a1485ad7769635553a08656b914b67e394fbbb9dc53e1bc8869c213557af805a402a353b450e614fea9b2fb8ceac7e5b6d9cdf04fcb3d4aad669e1176b5729972e2f8d1903d35ab17d2d66813390b4169989e2a6bb94b87979a2830d65fdae62d834de4b50a6a3b5b465cff0004888518179c5702812405366a2e352539852dd2c41b5fa81434eca8d00234533e44733428aa656a55d5b414af514884ff3571abec865d32caad0fa2dd708b780ada5803ea379578044690a9d86bd0d230c7a1122125527274179c8d95368a448abcdfb87b3422ac737ff46969bb76103885fa96f8c076a28ad667fa318aaa23a777f6a19ab7f4beee68d82357d1931171c06e86f588764241466eb35762daaae26163b6f7937271a0cbf0c004a4d6feadd898b1de038830b2e0ff319a7be9530377f2d0000d254b2d77488959726783daa8216f6126a6002271e502f90bb0315d185d082a1a0e87af957d75d125c429866c24a3813c5e7962958e56d260ef24750811215d550dcaaf8b3955d2149a335b91b9919185d5d8b1f31bb967015befcb25927255799478a87895a9f8305cefaea224f539e6299e4ae48b36d284041aceec6f045b83dc08f42fddb6ea31efa2220baaff9f2e80fefa5bc6685948c25601f1709847851be4dad32d12670792dca1c738bc984b1d819ef265654a7685f0f43d45f9d85830faff6011dfcfcaf075cb6d0296afaa9831737be5c2715891f5e086df6613d89dd82b13f84b643920a20bb3c02d32dc8220b0739e15a26feb6378c60b5fd25b4d016a158bcbe533bed6d0947a76a0b03828a5f23bf8a62429ef3c55025c570026e5b8c64159b97bbaa1d3c22f7736b43e267a65cc602dee3bfdb79edd85321bdcd1aec682b08ec31f8f4f1ad137c15082f9cd3fe6cd9bd8f0578c23d16ebda7bdef4efdc29df0d42c281e250d10add336594c2923a457581bb729dfc3181e22576742f28f85b573703ba3864d6bba7cfb28773ffc11f16bf2abc0804359c93c4c34edbbda9266abcecf48d803e393fc34d5edb18a1764a7f41250867a99d0074c9536fd8432f2722913cc24f5875d4439f915382ee22a66da63bdf25893044cc43a624b7ed66a86cbd4c8f7a846a79fa123a71bd742c312355a79171b499322f677ff7211f2fc52a8d9d7e3bbe2cd201dfa43f949b83e5b99e28d590d25c67e4759fb99fa10c959bc43320d0bccaebfd8e85d4c1615b857f2d030a92c787937d6846d0ebba8fa483a6bae641e788ae3c4fb6347f007c368feb1486a136ff710e55bf5835b5679ead444518921bb4ee8265f27349177f4fdde4c9da3bd300f63cb5803b839d6b86c11036cf7aad735441ef78b32480898a50b8c38834e3f7c1ddf07598bb23508b435db115e4191355da3904aa8d53fc9b1e7f76b940e06bb4d17d68548ad680da509cacdeb0f19358a63585a35e5570236c0b6bce0e25cc735a351e90df03a7b7b3ba52147fe7a89d5cd73dc2202d2665451abcfcba7e5e9963f4aba3c51843f42727c72ea756a71945769e67bda1071fcbee01d65f6384e49388fdcee349f7cb5f2f82b639bf0a1f60075ecc1d4168b16dd2837b5b03c11361f2381b26d7829c4b410627e74e32633ab4f13a34165692bb97797c34092ea306656341d836fd0bb605f496c996f96a9f21bd102a04a082a4858459ba682a19fdd4e32925d9c3be1435c6f381acb88b0122140f4c9cd8ba86a083f548755d28987abb047e29bbfa3ab1f944abd3b577938c4e8b5fa9a693a56ac16427c45fd33a56a1b7f089931ea44a7aa26c70d75125bb8e34b37bf0ae32e77a863e6eea2ed0188b531a507cfab0724ce2a92e9cf17aef2ea2d3c63527bb1bfd4f4d6024cc3db591739f3ddd3f64f5c62724103d138aa9d20fb988ef9b89d2660b7a5bdf7f168ce128353c0b02560e552a23dd5586e79290936f7a199a51f73b970391c1743e882dbc574df3628e184cb822fe10c3483d34d8e6f40b1e523c5296c0b62d2ea770998bf8a90cfdd9d6c8a451f36a6097e8b7fc8bb14041ce462284c19e4ee51522d8ce2c6cdd156b38c9260e94db5a236fb871c199eb37f7fdd0ba15ae986c66244b81ac0c41f074684c848d027d8551abc9df5e1a3b69ca840349dce6e7d1694b72fbc78fe1efd543d99c79444a9af1413acac7f13d0b763d208f0ecfff82258d40fecec07aaab29806c571bd74f0ffe88d12cb9f87eae555b7800c976a1f1913b817cd78eb4f28f842f4e1a5c91f9ef56882be607df5b48c735bca47c01114411e31cf320fda68fd255fa528aec859507915be9827959605db93c48cc05987652ecfabb9bd97230f1f1ce57e911a2a18f2ffe3d638a24f0a9ba0f3105a246c4805a050a300099d0009556724e8f2ed43b4b6f07b89b5eab1d5fd1c00db4de0a351849a4bebc32f8f657e9bd662b38abee60cdba70f573d005df23a5880d97f034b2ca7bdd3a348f653ce177dcf31d2c64f6e82c8ac16643a7ab8c57c4cb7888404df6f3584680b93af1b85d490977e20135275d2e67adaf0a3eb1fa7b44f378870ced158a2471bd978b8ca347c344fb11d130c693347d6b1667603ced0147a43d3dd466aedfffef0e8f52296663f0626b947eb56d2a90c7750cedc2f8fe6831c14e981013a73bdde90391bfeb86ce97efdd784d6f750278e9e3ec9ce8333484ceead4fe8e71b4327530f29ef5364bf6b854fbe187420fb0a50ddd643c1fa01703ac012e0efb38cd3418a62eddfdbef338782a51759401fb651efdcdbce3850a18d7a055660158b13a2db7b40a49fb54bb225534f6f9d872fcaab083bd4158c851d2f3cca629602170b3ed9e590feba2aed470028c9c02ce4f9ad641d852cf0438b626457d4fc537b3857f1fb67ead25bb1d7cb08bd30088ac1a79d4cfceb957a0212632c61ef45f567b0568966295c145e0795ebfd60c382359b646b474adf632715fc21714e367e6cf93726d099f5a8a4d02469def00d23c17f68565a2894df60da2fc4de87bc3d54d8f0dec5ab80d8735aba36d8554838e2536bf55cdc11dc42f4aa5a0c0f8d404181e6d12bcbd9e71b427cb4133c722aa4d0148dbb485e66445705bd54ecfe48e10f174a93fb5d2cef4470fe412b5bbe471bed2679c2bc66a798805bc4e1db6598cd1ec888d89721ef75894e869a0f6506b59c2365086b76b3d4ccd39cd0f6a44d4d0763f73747306dbf9ca929a8bdb72d00cec17eae282c4ed9b73d44e1b2cba2854df617faeb641b9f3ef05c46c0ff2e969ad65601f5d57214cf130f14ffc0276207a2ded0cae499a9df310746e00ea3dfd3bea9cf222d3c5b2b4f6e519e07b65bf8da235df208917e1bd42824e892ffb96a38dd837046082e3c6d41f5e68b81f73aaae30c6e13d3f7311c1e47d9b8069607807ba4ab3fb9d2435966bae153a2958a6eaaaf53659d47b4281110dcbb7cc65dd01f97067bd2c6e59736882f21c0f7e6c284dd6c77c4867cb7e9dec6081022bcb62bbf4b861864f3e69e7bc6697abd49e43896dd95303f9ed89238fb23c46dec1c95fb02143a91750c3dc3452ba7d75a41675a8be588f4a352375d2ae7941c7b7867e38d7f56d306d021b4c435fd659a0779d9b455cd6aa38c10fe85660c5fdb448f4067dc13d1be4b45f3fa079bb54dd35dc83e57b67ec5cb367af9cf23da923890148b18728cf5820ad6fcc2403756c8eacea27dffe3829debd61609bc4178a49225214b253cc830c7774a694b0fe70030f2f19377e50927f59c9ec9c82e14e4259993681e5b550b4beb276bd11956adc371f2c1d326a9a48c6ecf21ed5c7a3781ec080fdd10241dce2e3da27d8af32028e2af80d051007ca28dbba6e732558b79a8cb7030d1204031b7e87e2c99944dd3c0dd31181f4dc08af410ccd16205ebcc61e31f8b66bc0f46e7554c8d9d6d564a8862bdcdf7a04998fde5afc12fdf1292c6f23eb8324d783408f80b706de01c709b55d635e4734cd2c9122db8f15cdab3340bc2f5d59df9f65bdac72167c396abb1cf6356fac61c163fe56e776866a775d37065995189a346a1410c3cc998a2b024e45ffcc9a9f9b7aa1250f491e11189cf414cea5b90f8517bad32f23084821ad4f1131205b71c194ec85d2d35e167ad6da2771231f5bfdb632f837c94bf3f87630d4f756d97ede67766a0943229b2c6b4be93ed924aa097d303b30053a836e641218d65a997fc463cc583487cb60693b4dece364625bec0dfda687e67a599baeb201dca5a5477d257b4d3df77ef51893ab518f96ebaf1be1f0c6e8df3c4180b9b8f195fba6d88191e69d7c6394f4feadd8338ce604927001885ab86301e5bec88b912fc264d2a3af67f093a32014ebf62de1a9179b393ba9534a5ad2bf178e116abf3b3513bc2a7b30d6e56a58a31f61ee94d14fae6c63c0d11d6bd573dc829dfecda56077a628bab9b20c4ce2e06a219247926975290875aa465415a236d963c4178c6da64cc955e25f2660a901cd409e2c96db71b08252d359671d2391da23040fbc7ec0705601319941db9e92f4a94289fbf457148cff68334b214a0970146dfee9370741db4c5b977640a399edccc4363cfa5e132f071ab777b1a6fca43ed3f9f420461c96e6adf0d01510694d07f11b29a804787799d4ff4307b5932c8a5cc25736d30c8ecfa77a4f12951d3708d75369afa2167c80b3b376178507af9caa40359ae0ff4229290eb078073a0fcb59f1ec2c1190ca508def35fe3986ea188892e65d1cb9adf455f052184de195713037c195db6df017756a9e3a09ba0de5f91d3d7e006e7687cddd495e442771c6de51912286e9ad0aac6ba787b1c0c52963cb05cb28f45232bfc8f62914e6cad619424851a36bbb958e2cca01f80c2370cea5e3d7a731276db9e6e8d6a4b6dcc4a5c9bf37c49f092d58f439caf8b567b07a4f360b9e9d8babf14639d4fac84f8e1914a8d5d702a40719fc98efb108e8083debe8744363b907848351d0febe7755988fbc95b00574470123df3852232b6558087600bcd92ecf0dfc5bec583600d455d1208c1733c562c45221a87f38966fbfead6d3c0dab08294a08b76b094c45321b68351f3bae66faedd846eb33a0a3dd5da76e7d161ceb24e0f67ce049f4fa5ab75657c02d66c49b4fc34c8eacf4984e8bb3bd8a93eca427f75454a03c79f8e697c965092da88e9e1e43c3606e10bfb3c378986048f12903c017391c38e2f373ee5ff11faa41dc8ca3a5ff1b3afdd1f0bcf8036b16182cefe04843d6bee09f9ef8d84b6cdddb048c6649727dac94fc611f2862a8715ed1a6cbccd371a37314e7979f8f0d37a634397e6ebbd92d3201b1d3b49413d217d951886b15ff05c69f3ebcd3eb972e5fa3da3f1ad2f3a596e69f40e9291e97fcd75652b73236df0a48b5c662bf52be97e4dfbd67b087b5839299b13f31f44e08d68b5082b39d9d1b8d3af67b66933da164a85a1e93760a77b0d8e0250663e30bb52aa212a8632fa53a168f29943d47c4faaa1a5a1e3ff547d4a222fd97208e0e2b301e86a75a07046a346d32233b2aa6eebdbec02f9308d62bc95cd96ef73d45b1d0b40b26c88c828f37765718d7e49bfc2403cbd0e5ec1c4d49d326416044f4f70b782c35dabfbbed23916d42de875ea21450b79d56dfe588532a1a10982f0da8a5153b17888fec13c1a93fe0b23c43cb5c1f76d7c4784c084b5a5340114cb10664771c8fca6e78a68fbf5937548f7a896c053b3e14380c1e6f866a18a8c9a2404d7b783e5a100d8ea8526cd47e3084d563dd148c1b61387d6400ab500f7fcbedc15809673005e11fa3787cfc03db927f1e662fde63f038828dd3d89bba1eab79e64fccd88a85c224ecc55edd59bc8fab31dd3766c86518a845928e7197c075653054fc0ef58920b308a2f994733a0ef073f1a4691a19a90a0f0f9b46bf866d96878a2d964da40d10648ffb5ad0b27ad2149912e80e55230f53aa2ba876abd9feb01e0a18983336a830017394ad6acf67666921422de5bbd92d5284c3a7ec1a5f2146ff08234cbcd814aa3dc8c26c87a1c24e5dcf765b3f85ad128433e3c07bf3d1a7ab87137abb90684c9b0c97ad3a70433d572af45526ab62cc3c2eacb024955f5080520f798eaf69acd2374d5a8215c79f5d3bd808c72cb64a6b77de0bdd4c12dcbec087847706821bbc1a0f052680ce7ea288570a87e4d64a0a007ad3b371bccd7d43b4763e95a102cae15e1f3e5d05ecd77a52459eddee315b2cee982a69c1d97b6a693684f51a6d788f7e7794c1276931905a3fb6ca32be4b4eb22dc4a80978c9d75ca3ead8c3aaf8b2c8d16011b2de3258173230d18d027db481f41ac2cdd844faede34c479b388e660f2d0cebdc614fd1e1f18b4eea7eaed42f8f0a3a633f71496b2191940c9ea7f78a8989e41d2620b5aca5e3428b930c438b927caceb657117a654ec56ac34ae82833025f4ef97446664fa617c456c5b175953459abf17baecfa1b459331b7ec382c11d11a58ea29f49559516c13c2e004bf43d1a16778bbf32589c342c61fb1af0eeb00fa13ffcd26c68b78177b555fc21feb4fe8f87f9ef78343ff78fea765a80cdd08c35660160108aeff93840d4588a0b035ed1ebc61aa51be8d242e4bcf8729ae1d1f048a9058b3440890382d52112f817c053f226f4146f3e87c9361ce9a18daf67b5aa2679b82044bb6e4852048ebc86b626337290e074277c682afba90394b717502f7e1f057fe4e887626388ffea7c3c8f78a4ba117a024cab2fc6ec60ac3e610865a25596f3b5f68fd65addca943dc1522c7fbd3b55a2b88bfecc7fcb16c9a43474d7c21525b81528d2055a3cb6ed0b3e87126832047ec3f2edcd6057ca3ede0318f58de24c3cf85b0153f4fe89fb698d995072f823536fdebc7243ab29cbd1c2ff7af85348ad9b456a1076bc778c7b2a0bb918676e0818fed24e0b6c607ad0d4a3bf244478dfd7bd907165e576454f3a87e0eb0ee4ec9a627fea658fd0075bab0afa666782100f19614490c5ff78848f10b8579fc45fa58408aa0c0a83fde97193d0f97c2adb79418519bd60906d742ee3b9944aca529277e8c8ada0b41fdc69a35420116e9a94fadd8c9b101656582719de35da539f70d3f0b7724159467b95cbbc5b7c1431a764cf7e952153338fb717f3e2c6de04803089e4719d9e0ac7d0e27c20731e28946bfcee9f2e797dd60f7a8f18a178ce0b5c8d738b36c35cbf8c7b2095af79aefb5920533c1535ef2b85c76cb1542cb2fb67f3b6b7c71d62a8fc6b550e76d7cf80e057e8603e64b5bfd290a3996aa67ff75d012e2990cad26e5a8d6c3055ed1a0c3e42d6c5529a9b187ffa91059bcdfc548b05e16c54b5259a4d56b31986dada70b321c4f5c14c6f4c06b2456941424509ee3f7aa3363740bdb03054a259e7086212b59ebec7e8f85ba960cf23e223636b07b83a839755342a8cf14a75be52ce1eae325fbe275dabfd040ce4431eeb613c4f42b1760a5ffc31f08253567550083f8f728538b3ee404e00f0da309fab25e8a64aa61a489c0345bf271501cd82f7e0e5ef807878f4bc804798f5fca2eeb9daf0c0d9adec527965d7b61ef7c24a2394806f42b18cb972388b38d2a5c5b7868ec4d9aedbc1754b04c5fdcbef6611922f9f109060528ae04e66ab0e6df709cb444255c7bbd0f688d62b668a1c9b8573a7dd87f5b942fa450c12cdba5329e8c160db2146b91daf1eaf5179b5c181e68894faff15cfc53648f6f17f47f41e529956b571eb7fcf44fab1eed28ae210ec595f85d069bd1fd2e3255fda6766cb4b27258912c1173866eab46291b027a11082e7720fa7afdf509893f80564e849193072fe0470d06d06b96f6652c85a932f174eb76de0d2ed502a7a907f789b932f46149cca6da924bbd8a53663cd75bdda4d059353bbe6bb5faa9717bbfbdedcf5f4cdb75b5c560d012cbd7eca57e63b4358dba56e5b15b39329d4f07bba141a6d958ab4b76c602e3b59487f84c377a819ed47584d64e857677106b2df4892db203299a84f26b289b52141090d2a9f2337b5ac70d907c7b054326361428949079ea86a54eea3b7b788887d02e51e8187b75606edd9bc5e7a39f8f0100c2eb49b8503c42d71677c88bfb89605a33c2087c3ebc9ee23f8f83c5676b1dc33d3c80f46b85786570302b8b610804bf15f4218a4eedeb3b82be3c3023bb7e4fbcbd60f7ac725cb6f63ce7c6bedc7c75401df36e4f00bd82c2a4c0feb354215e4e3101412afb43d17842f969c1a4455","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
