<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33c93f114c19dcaf329bf6286e48f83da010c40b61edc945fadedb3cd61625c4e93c9d3361308835902554eada4889513e5564c9cd203364a60199f475bff159dc37a7ef2349cc01a13cfa933fdd23ffb335c180878a36e6a7c2931238069730312ae433b5229f712b5999009db0ab9289358a0fb3091ee97452a65ca3b874332aad0c67926a61bdcc682c08b2927627bfd4d3a731bfaf49b95a03f210088af7657ff1e21681cb96f86cf2168426cc1e91487f8bf6e886827ea40481c8b1cba50dbefb0731952f4082a6ce523ee422539a5ffef1f3e91839d4134fd3d9e8d236b6b585a5eae1a37f53391c16f797f1efd20ad84e7d4d7ef5df6cc739d20f86816e7e46543973a3d88054c6a0f9fc64a873bc096dbafbb86bcd5f060d961bb2d02bbaf7ae34a7eff82fefd05f405cbb23bc1e0d775ce5b7ee8547a11a5c669c4a264481f5243907229fe6ff534a8e00c84f3ca41a5759f3d27c673412963041a49fe37ad34e3c4e1f5b82a00113ec0f0b296a7200f1ce4b05def16611657d66af16ff2efacd3cdb19e4ac2058c03e675a9cb41b385ab18749236d5b2d9046b86e3e1c38c6489a1c3d2e6ef03e572f2d48656e9c93649eff1ef2416eadb99d386a42e1d00058da97718c1c4b52f223a0bf4b231c1d20f3e453986dc049e6523fc5f63b5a30fa415bbb5c039c9fc85bf2cfdcb8aa0fbd1b9b360a0b07391d458a66e753cd52cdbc4f997c6d95d19a84996d65d9c4c82905850d39192d07e9e2ca5e24303226514b3b2b131e7ac5621a83c9147691fc9bb4689b032e644f27bab8ff592a8a511800f4a0c98a6ac811ef9366a0517892977a7ed54d21074dcba8b7e50523a37e6c09578faf11936781dd410f5f39354cbf6d1302c664e6b8679c060323ddf66d92e50386dacebf3f1ad415ec815837e90f8a6b5294456eaeee57b98b9c40203c926b164846470b2f7058f8371c87507c59e96dd409a60c2986628f74a03af22e9aed3f8deb4284e22b6086cce3708f83af600e87026d54c872847d2aec941404817935b6c39cdf40770ea4a82f3d0bb484d50426480a423f2509fa3dd382d2083564df428dc44ca0d18693b9538418fe0b6a9996833311e573045b382f9663588d2bd44af648ade4f2d633de126ca7f0506b9544c81a14b584d329bfdd08dbb74115f65fc92d58beb24850851eca92400edbf6352815c284edd777594cbf4f7f153e3a6636aaba0e90e9dc368d2bd624e0d22e20290b9e45e34affa6681d638193a41d2d3b106c6f539b9f049db7df26cb4eff8aca211868d00d83ecc965228581361fedf11d6889b23c63c5ca6f141f5c82955db1b8455db6e130a07b18bba08292c6923a3ad9769482e7996ec1ffaa099abde3d2660be1b48e4b6d4e7371d6db2356708abb8195425a51c72a6ff7f5d1a8a6f2e4a9e898111acde18646c9839789eace90907cd7ed3239c69a1758410e0584672b423b6f79b800664e193ffe24ee7ad9ce2781303af73e80887a42a83546ddf37f699a594c0140e653d7e29c69cc30afb85c1ff1c46d7379a8e0aa31a68fee1742b087d92a3c30b55532800964d3f5d03d61d5230aba6a1b3f59b1463d021dc9568c4b14213e5c1e0efcf7257419c147d8093b3d634b1ee04c2e69e0b3e1668dc9a1d8749ec0495517d90d94b582bc751c62d7a74076226584e829c42508228017a185b8fac895c9be380f44d94466e0a68074162abfc82deabd1ee5f8e5350e030789dbf1c96664f4a3c10ca5ef79978c754e8546e19185a22ce985f288f162e0121d3f6d8fe006f035bc6cf0771b731a9ca7a06d30e6fbd616d1ccc0f96a0480fec11a7d651aa7816aa312abb59cb8992f6cc77b4119cdf88be8375b87b47df273f5ad1820c1fb35e564be7e8932862d53909f4266d0b7020ecbf386309dbc8a1276133828644346011f7415a7053b7382baa9bf7f5d80a6bce5c8191e5be4390b575112ee1d55badfc592de258535880f26c87a7d56bbbce5750bbdc52ef78d17d91217d1fd540d400552af932575ae6c333c2a32acc7b8b7645fdf1e5b725c95f2dc00da3417b6fdc5397948ef08e22f7336c6e5456afd06d0005f31db14c04be042ec69ba9280485c8c8567ec2f88b3dc5ada0b50d9173574a39bf2b233b8948a5a1eb2f8fcb7668400b8098375c73da6ec5fc2951e5cf9ed0adb6748420ecb4eb192211565d42aa92ca44e26d51ef1243528ead8b4cc664d68b7bbb2517143146a111b8734c266993703917cc564ed40c532aa52c52f7ed36245a5bd6b8cf5b04757b62ce22f99e53e51cb81f9bbff85ceb85aeeb69e8ba7ce04d6baa524aa97131012b791d3ead33bffaf6ef2bc97350efc5052df32147c2feac5ec820f3f075d578c80a6c1b86da63aba516c2edd8d4bc4f2f955135af16ceb10cd5dac450df4936a57c82302233d0a69d4b5238d51f02c1080f74ff2f0c7202b2e04510cafdc730f3303ac7c2d1fb15e036a9a4e720174533fc65bea4a9cd78a679788732bc2beb53ab28ba130f79be2e9199f1fdee35b188e769a98f96ca2e05622b2de1dd531a3ea29c6d50caefc60369ec1e061807aac699c2a63a3d5b190d17504c02a9e4db7fbd511b510920ccd9048b89e16ed9cc0ff3b188a5c7c7138f5260721abfa511118848ebbdadba2857c272ef6245814d6a2f64f131d2da8427383068405e8b804e5d6f3aec7011c6adccd03cfba636522ba8e88d21ddb5a6a2097cc3f62354817e8171e2d8c8a9e0f46322dd80910c5138918d7e0a7d7ea6160be816e83e4ad76fd63805d6637ea7c38bd607213adaa118f823b7d5eeb2fa9f6a6faea1060da34685de0d5b36e09644c3b934011b3f1a22776592ee559f8207656ffb0f9b5730dfc054f2e0d71f58048a6dc2c8072ec2328b959ceb7edcfcf49d71222cacb0ea939299d8a3f6979b5f7acea06f49a30da6f3da76aa4aa81ff59435e72a0d1790df892325c78d38b3f0c715ae459ee26b7fbffc1de36d9f236ab59e98c40dfcd18e53b1b2433bcbf00d77266f11e960c138d037cdde44340a287f6b4b50d527be08ab2d5ae49119add18da4c3024a1c9ef6e148a43ba8c8670207ba9953b4edbcb841e8401b4777aa0dee5e9d5d710a0f391c48068638e53de4e40af6fc93c0f89df72ae10007396f4634606c0f603d18f7503c4a3c17201a96e6c57a80bd57ae8110180d43d819b82e6db5f529a46080b874b56f4d804f0e3f31e7d44f938d9b938d630e9babd9e9cd09f965a1c83719ae860642302e30521bd63d6891512d29a315869e357627367bad5f9d9505b75eaf9ce857c01e70e5da78fdca8ac75ac1a4d6a275f350103e3bcef26e7ed53b2571fbbea129a42de04285ed479c442a551a18ffcc337f18a096e695c7da72b734d70399a62852850cc4a63e11fe47c135bda1c9976b402f95322cb041add3756044a822886fe75af4457b4f8b3196e05e595d9ba938d2dbd04e293f9d4d40e0ff1b386bac71a7f78430329191084345e934df983444ccd99b2ad03226f61f60e7065123d9d0688b799a3efa6ff0d981ce6347640c3a307dc7bead52b2165d4ef36d9eb3b1d2628e9e8652b738eece10558ffbfb5194d6f7c8d89d7d2b10e0004b0db1a6c978fcca2cc93713cc3b2b7a5f55200cdadda515cc08995ccdc9a1876901cf05917e5dda452b041d6e868a0809d27aa7367f221dd43f20334823863a4c661ecc964aea6341158d3e6436dc9b360773e930f751d9073a05109ca9965d72f43affda9756576194b7246753c418195d39177310ea840877ce03f857f4198a0832918a0adcf5db8713f056dc1a4f2246f6a4cafb95cc06ab4e76ca5b6888a4c08126f85111b524bea345e3d1be8a2d90d3192f9244b9ec64f0d88859bce9dc68cb93be74f89fbf558db643bb19c12ccf03ebac90daeef73edcf30652171d4132dd8e37c8d059e945b93c0fac9e4dcde8ba444bcf436921f4f01e782dc0d7ba2d2632e20eec663c2e2a5e191349a4cffbd5d66b4bd76bd2996df55f6fe773162810652be91b2aa27284bc7ba2835af9f8f8e1ac9981d15c0735b282eee42573ec043bd8bcf0387d01151717a882a03bf1c37e4417810c7634b9b6271bd11510c85479c5a3c8d9b3670fd825c9ec8ab3448954c19c1d42fd371c9ba09be18df59f616d23cb5dbd4e4fa7181a3192e21f08bbe935b8881c836463f49ffca3fa2552f96788c9388abf9f47dcf8da18b8239789a0a801da79f98eb1cf03f8f5926d48e32f9632018b3478cd02c2c452ab702901e40576722b8e4ea3ee5077b90b8feaae96cb172410c450b9f59643583894c069ed07f17e9e022459eced5d878e566ce8140292ff1a78726da24db1eaf25d32820feafa359f2df0f7a0118c18e3cd57b72a73073d7076e443b20e3cd900c9d16d3466c6331bf89e32ac7e3dab10f1b18c44747148354a163b6e4aa9bac2749a4decff95231d4bd3c9968d8d81a2e70c326f76a5450d43365bf2944b07edfbcdc11a1b6c5354f39a54fa64db667e5d7fcc2ca7bc13eeecfcd79fac46783d4057fa9cc22f1ca077ba1f57511c5a8f858707d1d5feab724c6bf74f9ea9b0ae2dfb39157d842f6288e7d0596b663ca1c76bf761436f62409fd4e7571f483589e3ea95df0111e38f368380256a046021f37c52c80e9739108a0c40804f7fe9d4bb9e3f0f9dc1bc09f9a99ac6f31477ed7ff53a851c5080867c60a04d2f12a311295755121c3d49d9b1de22650bb9ad01225ce0715eefd4eb7ca006e6cb48e62c81715da46da75ddd69388f48dbb5ff2f89a2e6e28350657c8f5871ba64709505f90ec4b502d2208e4423d913fc39af6945bd1291ff3e94758e1744ca3ad751e7baf7b71a6657a3367b20c8897b22c0aa8609f4e2c31562a149f4dd2af0dd7210398b7bd5933847c32f8ea1b50f8d6d1c68fea70e9213622680a019697a08c6912e31901d03b18da0c0e275a75e4b7e913c646f19c08fa0d45d8d9e4bae46936912237f550cd45b135bfb574863dd2a908dba378863962a5319ed96e776a890be93f48bc939b73006627da064dcce9da6a4834b0007ed258d4455c1cec4afcffbed2cf040947944e978d182e87352baecbab3258268328f4184321cf0fd70d34904b0b519ea065e34a81567c9be17f9ad88ba8d1c1a4cccbf24d4f1970d168670545a80cc31dc1f366dd0f2ba743ca0cd50e0efc2cfd1caea05e86fbb5328f909e44649fa044e92711cd754f51733fa172efd7a3d5ce01b9b193936d89ab8386c86ae2bbc2f069f9b36f11af3e1232cf3a5ed757a9ae6be4fe9691c3ce26d353bb7afd4f5ca3bcee0c71f2d003d075feae508c45f82655bf8768c00204c83da5863c7333a67fbb02cd2f01885acd7e98b6f34108a96d72b9c08c262fae80dbc5c6c9a426e216dbe8e98f98657812208e6cb0ee24faf866fdb04f06af332500844b38e312f46310c5c8735e2dc8f3b4d0fef0c4f6ea117e8b1668ab6d276bc3b9dd4915c511b2b096ea4d5d40334cc65bd87a795dd8e4a19f03fa765151a87d505c9b32b32a461edfb9a598b1a3f8b53032d68aaefe2a97b78ddfe6bc070e6016370cc9456f9e2b4c47cc15685b93664ecac1e59d2a4c3bb73b6b5495e9f897e70ebf324250ee639707ce2c2a6b5fd3b513d9b22ca521bd09babdca40a48c63d7b7e76c93a89ea88ea1639f2ced240de05f7ae29f97045331485b9aef8c3159dbd95743e0eee5f567054a29f2b70ef4d94e76981b0f6a67c759f244f1e914a9fed09f874644415ae141a43650f5b24ef74970b2172b347a9012d80330c0e7b9bd3618cd1f6c4cbc58f82407773c74eaa9d4a2dd3ab8e679bc4e74496816866b5b1b1b4b9a10796f1d09c4d341ea27f1f4be5e8dbcf7aab05f26263098ccfae88c103505d1d87e26bdfe15d7f306234775f3668322075efe80a0beb4ce08c828a009e42bff1611ebb4c00fb58adbb82540694499e9e0708e63d35da2d168dcc31448f7a330913fe60c4ee47339e12becfeab80ad44d6afb329934a50e43ab28193d882b5a1e17b469269790d9c5848c0d946a8550813443baf1d5a7554aaff446c5fb8657a8164df965c74cd55bec513b95d1ca3ea569538657aebc54ddd0e4615063c5784b6ade20d2ff07f55d42f0a6debb073ed3a7f10ec1ee20c345667347c53c9da21ff30ab2fc3ceb234fcfc21d0b2adcce80ee1b11d4b8764ff572b015e2214695b1a2a09c8d09184217ad7fc824178e38fa4f81a67c09100006b8bf850ee6ca893196922e79f5d0acce078c5473a1ab8ee898ca613307aba29aec554ffd05011befbfc4d8ebc1e451e8aa342617652f738fba28eb8221854647cd03e692e9b28ffba775836d52656a3405cdfcda6ddd55f034828904e91d383d642f2e31291249091a17464558236a2cd8210e42d2d91c012a7b3d087038d1c5c449a59eca3705c6d21b09c35425f5c4ff037b5cad3dd3b84971329fa8b65bba2bc45e75ddba8215c03c479d41d320d4b883952d3cef59d66da1f26af10f3384e0f4bee3cf9c358bf31e967fd800405b4420b49449968e7ddf989d0aa4b611ad181a58df250b32c09928103ab57e4cb3b6817535e9830e4c742be26b937ae749e14ee8825d8c2ba65b350dd1dfcb900a42f270b5e010aa3a32be97176659fc1463b2882925bdf8778d287cb59333ed80293acd2504a821ad36d29cc0ea9c772273fb9ce7ff2e76136a76e862542559190ecf944a2f1d2b33cd76a521fe5f6f449b95a1bd61c54e0c069d55501add919d00531dd6aa07009783f23e7ce4b39d8395529fb395dd38d18c220a01d277c64d95f0317477068a533f1f8ef7aa51ee8658541580e37fb58d2cd28c61cdfaa02e76c9fcd60fb657dc11b2a6a77ea2b3df51c66802b388f61346e400be24bb5e69a172e809bcce015528b85cdab6d80a0c05f9e33b1960fc3b5797b28935346e10940d3159fb927ce795009732743c4dd7641ada3c37b4dafe31deb95917e2f3cf36af576f060bf1eec9a8b52279567afd311bdf7efab6c2f242cb01a48f97104e49d0da169e0a4d832e98307fa8983e5b6458593007204f43ef99890c77f35f301acfb220ae704a69fb972de8d1c80bd559379f4494f085bac902141b116cc2d00ab0054a63b803daf75ad7dc2616c2c43ff689e61d6162a8c3d9549925b433004d12944b0b0edcd87533bbb9ab426f6178f501542eac20881bb821a104abd38086fcb0158d0ee25bd8bba187edc4c225b232bd97e9fe02f34f360d236ec04d232995a2cf1ab39092789ed4aba70934e53351a0e37e783f5ca162fbab779d447a6324c4eabec669eae9f5d4ae30be8439744fc66e01351450b9d1f24a89a3b89fa1d0545ebb415e0de76d84c33694e3b84a3d1ee89099eb1d0f1d4ca2f7eac3ce249b3b64824be79e9540b72863600ab46559528de641c93251b1e5995f521ee2678d238dbf59d521bbdff4056444abc60dcc62c96af2cbac7c0f0e33d7a2be85e535bb02a892f9c7f08f91f3d2aa518343fc2dd0a97d4acaf627dee6f61ff5ff685f2c4f8012eb32afafbc6237d0e99d28e50b64eb281430fea4bff4c127f34b48389131dc61c78f515860a16e4e6ff77d1ee4cf72a4aa2261287d4f0c34645308188b5c106df7138b029f2add20a5ca7b90d01aaae21b4b62b911e2d06b73dd7f420b89e5eaa62c65f9396f4ed0c9e3340b507628244ff83331ad17bbdd80ce29742c38ee6031defbab73f8ef4af83a76c383b04ce8545980a49f1aa75f4bce689d83bb3b999427de72e039547e074cf7bf7461de34b1c50e7e97593eec1249c4174f1b4dbc82811116ec216b1a551e70dda08c179d69bcbb1c4a0c0ecc5c621ad65f9b528666b437ac99a37a329596b7b3cafc40c8a0989b47527e083a0a332b665ca7f9219d039ba0834ada58a688bd94dfebd8ab64158e79836d0227838b6d15639bc09448e279545b6a86584fa4dc66fb4e9f3bdc311c12f97255a102a9311420cba00206f309cf961bd701ffc1cf3c754e6cc9d4eb15932b140ba857a170d43c480fe9dad4e60a902335dae7b36c5ffe1b5c1d1f85d26b503568f52494e015f73cdb8d1aac397f08a8ab012b484f8cd09e8abe3f00d914b38c7bfec54d3215f0ff7cf02c17ffadf20ed8b1c167415922d7c1b92e7a238f57b3037b3124f585dc7b67ad791a8541dd0dad1efb7b3035b2ef9aae77382c3e691ee72618523277b1e4c2364e241c47126874c3e888c026da6374d03260bd665f3657f0ef55e06f18a8824311c64e71c9d800253e1191d1aef0a68590ce6def8a3ed4fd1c970323a3481923bb89647d6c7a4cc42917ffbc091c608dd9c631e211ced64a98dffb339d07db7371ccaf4ae787ce5462dece350f1254f4326013ec893bc2b0b0ae512e5505fd99096f8cc10d33197eba0c6091e6b75f4f648fcd455c511b30d21279dc5ff0fd6d261cfca9f71f58b0663afc7a188894468294581c427c115230b29b533e3040540b60d8688d704075b08887e6ff394b6e47dab7355eb5c859babde7f74b9c12df7afac6cf576e2600e507216f238ca541be1b227b2f594eb0446ec16442a0b75fb9b19b0613de66fa0d6ca108ab3a29ceaccc6d1318a10ab83f423390db8a172203812a21e0c163dc54dfdfa701fb5517b6806e881f7e27444585194059b8db3ed48f0ce301a4b75e8babe85e3d16fc892e30d25cc75826b5ac60cf1f62d0b73da8bc3737339f44a85b418f4bdce6e9f1bdd744e0af99b70e233978b24e95726403c70a34111dbb3da3ebee7a6957f4edf17f44cb8196cbbf859c25da798180a77e685fb583b16d6da75af5859d0809b68e8c2ed91f702c678e6a108b3697f85324ad3b3dca8fa1337352ba6daf8bb9beaa4320e087621ac1aafd2c547d1b9dbd20e24b77ad39bbad40995c078dfdb6a57b8a78bfe06b83ff480c2e1714f9a1d5724c4a5cbda93c00c41be2bab0b6203753ca7b822c9ba54e0b585f6b118132d174e69a488219ee2a9e9af609d2ba0b44cfe24656248c5c67937e9bc404c8e04340a945c88929f85b1f07d940ac45aadda5a0c3522139883690b56ec9c07a3e5e0102c5083169fbc9c788fcaae891bcc91b9a90fbd703c779acc293bbc74e25c5d39c407a99bf3a7b8125ca6f34b101a0b070c3dc254a0feca28e5d5c44577f6ae63238e89ef463e5abf3152a9d9bcadfe9658eaf6d60be6a8df445abd36b03f79cf3c2beb9363288d7db15de7502c8b6cb57ac22bf23534fe2976cfc30cb8cbccc6f0936da658be7b311db73982f6a568e948109affc71e0eee22c255957d2ee3a8585df91758f30517c0a3a18af2ce234cbc794b44749335dc934921bd29065225388c2e65bc7e59f3964deb958b838fc221eae863d5330187d861ce24198c06405c34981d5a5af3718b102dfb402441f1fc9acb7fa165d49cb7ed662e8956afd1ec514fa0147cd50dfa45f6a5feee1e8d55502afb9dd21d9a8eda79c734182aac7c018f566f577d7950b327174b96cf558783bf3cf0d1d7bca08321c7e233680d84ba591350e01187cbd0ad814544130754b8e7b9deca1dc296b604b914d505360400230cf8f7b2b88229422ae1b35468aa56819ad5f701d2f7a7343b05b1e6fb942263f1195539519ec778ff88a506e9bdc0684d296e5358fb7b2028c9e5760e81d2c2a4362b6bdc1ec47139456c0b3f6f21d61d12f8fd17557356ee5a0b34540c7f57ebe76b5bf66a3c291e21ee2662a48602f4761974258b71f9624f1137d39c8f722a452bd12f392b4f159e256b534648025269495d3cbd042b76db693e77722627b52aa942eb93bf5df5c9bbf15904f6ce8643206038af45079ab738384a6cbbca74ee9bba7c319102ce79878894a48cc46888322ace65134f3a783ddcfb312c8a6527597a38118021e7e72f072236943b65127c9d1d0706bbaf787d05fe7ee0f22dd017ad21a20846574c6c6d442dcc5a1602ba940003d1670f450c46b605020465d503e85f919e4832e13c7e0efab4e66a2139d501db9224251ed8ccb2503ce331eade7ac4a9119a4b60253bc9350c1f9afd70791dd541b6925f2e29f648b16340eec8f8fb39b47f064a9c7118514930ab8ce370a2ceb4653c04ccdb7db12cbecd291397cd7b8e815c547f29f371e2c8c55c8d8144e6e4e144e1acf7e73cfc7b6cdf479e632f519e73baf1a913cab6403091ebe5b6f2f095670d0423c66d982be82e9a728b6ee621142fc003ad0e03b1a2d3e9fe62a98b969c069807cf23f019cfe602ba2ca6eea7e3b385a72bdd565fc52535350bb8bef46cdbe9eea0fbb60644159d9a7b61d5e8de4083063e3cdd17695e934b3a001a36d3f667ffca9b24a8517f8a04719340568789f2aae39ec820b1d74b7ea20615cf2efb5d6feba4e6a6672483cf92afaf19e82efe7a8d1e6fccefe47adcf58fe526a4989b11e7d977a90a8ebe22ddf149aedb34120a4d7d426c367651d1ceca25f6870c4f59726c51f00f98dac75333bdb03d1783efb9a2444e2de4d86b0a89e93e9765546d3ad7a81b4e4b9014faa079f3afb55724e8361ee61ab2bf2dccd96d8f75bf2ce52ba7350aa962eb5ee24b47b45b2651b7b4451494adf3faae1183d2733b970b724eb1b329550e7c4aa0a37fc226fd166f5ac06d1d7c430aed0e6c785de907b96d8a45a87d5ae7c5ee5029ce9a2b8d83ab30ca408aefab9c6c4f2f1eebcdcf243e6f4f3b8a686a6a02481c06ab4dee37f33789357abf58dcb41a2dfc732dbec7316abccb8df0c99197389b6bdddcb180d5ff7c246430a1fc9bfb083d1ea3cf79063b45b4f768f1cced3944d454bf413dea3e31c75932abd93b78ae1eae27fe32a3383ce13338db6c4cf7c4e79fd3ebfccfe6d920c0314d077f12ccc7565ff05db5fe4b73891f5257e1e7406c3f3ad16e052804468b3528d7a325f38bbd02203342a14336ab367458d8c9b96e717e49d4e3e8572c02fb0b2b89b4ddf676dd220a69aee7607d760acd039e35550f273cd105dfd3ae2bdc778d376bf29e42385001f4f14efd8a53920e3ce0cdd289e6f68780111c025c3fc9c4cea3c2f18f19459ff8a161fb7b67bca166f093f7ca3797dab6e9bff394684c9270245b5baaf105a99a4a4e70b3d43df5059b7b626aa357d89a0aeffa7d6427bc45bcd27d0e5e32166d311be8878bc0771282bc2c10f658eef0ceda8a07995f2d041c435b54a258394db69d21d10a54dfc1be5e0d8c46cde834302c7a7fa921c46a71367b4072e4621b6319a3d02165e787c8c87c4a6eefa84be0b5ee0a576df48c305e4ccdd7bc6687bada2cc020e3bafc1dc4affa6a36fbf9ab1c739746f5ff8587880b541677dc7265a0b94d96a9eef5b700f728a447878d99dd6844dc3808e0dcfb90d4bb45552dc72fd138bd02df8371051524dd9b593ae7d3c1dad1168c90f41d3838000713018f43a23bfb9c594fd69aa0152c251a48315aa89f2fec163cbf778550b3e130ce522a595376f7c093fecdb6fb1dcc42ad2714cc92154918b355b9a5dd31800fd81aa25fd4fce08baffcaa8913b7bdbbd2aebbf20ce35491a0f863e17d6b605dcc38d11d472569953ee0d90cfe635a39dccab82eabb179b2d81791de8603c7826908f87379f2bb1d0107c100d503392e9ed5a307a0f8f6d071198d720faa6ee029a21ac2f20362c3e3c42f0703f4ce8f4c7797ee9de5398c8d7f1ca301d14e544b28b24a2e3e951973f185407ce13ebd7585290905c294c17c78ba60799400289966bb4fb19792e60b6c4f3092da7a25cfeffa07fc73e755b5ce4fd413e263bb3834d0c6e5fbea339c998c5b9a011b3b3795242acbf1a35a2c9aa6b57e12f004ece58b6682749d7044fafac1f292c77dce4a617827ddaaf39105e97839049cc8d987980ff2393d74ec2dc92c42d8596422377de563ee7f321e10605479df4bd21063c74d24c6e1e923a21246122d550ae31e3bac35f06850e0c34dc741bc7ef81971fd151b403d9a2b575ad8c8377bc63bfb22dbd2b1fa97730a3379152321fa4ca689f8378a721c6e9977aecaf5cc2f287bb78dd79a55807b1d2198ea0e17177910c4f3995d7641516b6a7822df95be72ed2d7a8837f4d6fb786eca96d6def7590d98f7b03fa3ebc06755fd68e0dcfb3c5762bb5eba1acf8dca0386a2c6ef5251e95037aa563484e1d555a1cab9396db3c5577350b4a31c62dfd8fd99d159b8139f5b67b6ca350dad850a6f7b234037eb051a1900e7bb51f598036fc03481c223f3048378129934318986dde4c046bb6294a1faf31efe437661e16f54a126defb599110ac1b42cfad6829ce5ad7fc441de61fc5930b521db6928eeba86b00d6faa48797b0019d52dcd1f6b0058451fe35d115fbc4282adc2c3043d14ec765041baada2d14b3039aff0038c83b57e178fd31edef417131254237db69a48ef6f47384f87f54b4560d6903b6288b3168b78fd41102433c1d860c9a36fc63cdf405328892825dcf7af3cc27c115b1bb3c3824d08be23a483e84fb3add46ae4ab9503e54862a0ae008051a57cc23e6f27f0d3ff2416ee6aa24a99942b399648996ea0d6aaeba0ec3869742a5754587db73526d52ecdec02b7f5489547eb5de6627efed32c3475984c9526099a029d1994c5aadc2448db8cb8f3e2ef066b7cc690ea52f090ab67031f1e4c837b81431a62fa529a90c46e6a0ef40c3fd49d31648259fd0f0e1534f3a8f40df5742e799eaf9cdf60cb36dc26e3fd625d50c6033a474617bf3fee739ecb7ce4fe8e2add8bc47d64039a0952ff3a7251200aa81f3e0b87d48d910039fcc0c663b2178b78a50b6cabd3b79f3a812e2ba54d69218685b57f2404f5ebeea679bed8162d3b067b1256476c8b811691d57bb0ff44d6946472eaf792914f18b8aa64c53b27ebf251edf3232824049414604c93ee5548ee8116824f35b0776b1ccbbcfebf865b0f0539d0e634b90a22980222e487c25b00a98273f670ccfe548f4b87274b61bfe8f646aaffd881f5455067801936c3a1f22e2694a3d72d8aae499b476f22a350b64bc02aee1798296e4cd1fe6a60c10b77adb2fa9b5a70224247e2e9a833838562aa51e167cfa8ba05d664f6dc15cc99aa30ab1d007b647eaae4bd18f3a7047631cd95ba95462e9d9f7338a0efb1ab07e4765b91f09aae25a10888a33633bad01073ebc5e7bae257a25b7448b175a124136f92eab461f73a40b09d492e15bb5fac97e6d73fc5573e2c860c275a7bfab3fe9409d3b41af53914e9e5ba46e647a7e6ba2c8d3815e75ace41c4d2b28447e6534f1e2bc8ed9581da9700433e580123297b509aef19179389599f22ee3459db47c4642a415a20e48516ce26bcfc52b814ed1b0a41ffac5c1c51608732165bb3769d7ea443219d161606ada396d5097f07e2172f2bfa244e2e6a7197b7dfb9ceb84e0680e8a1a2b693d67774be03919e6828114f0102f6c8f0ace06ac31d983114593062d8126d2cec2188de1ac876cc827cda04dce1a9e0a51deae8ba87c08fc4790415370da43f4591c37ef9e60b82b8dafdf4fb07f514fffaa7678c10700248449e160f198b7fb79a90b07f5f2981bb9eb581bdcb651d5aabed3ca13f9fad407e6feacd15e6d9e34ee8f01610ef2b4a7ff560ac601d8af4c1e189c04774cc303f6fb53a33a23d1a2f9c8f4480660662e9c657e8bdf","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
