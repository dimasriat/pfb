<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3d7ae4a4244ed81051a78aaa36a0054936d045949de642fc623a002bd14032fcd4ad0fec411bcbf2afff3eec546fb44f71e878c34d081aa27587f73843d8c5ab23d3c79edfd7c58052c9b9df358e9eb3c7a0259904b85ec19f95faa25cfcd00acf5486d2ea2d9fb2a4c5eb4b78ef5458214108874683839a2a56b230f4fd7da016ec297425c0728561c08085dac91e1113ac9aa796ac1b4d666605de56fcf360940c45ee1e079742379007649bfea707fec7a04fec812b470e5d0accfa1d3fb3c8eb51a879ebdbe5ccc10e0f34594355c33cd68ce239bc8ff52649ac334b55d3c1b39698ae179f2f3f670933963257461de11d816c7e043ce742a07b774d3df4877cdcf0e9276248dea48f4e253f95ad4012f23c00bcb65eec9c37373741ec00e1c38f143712e676e4b53118ea85ee2e57e62c7dfcef1f2da686210e48a5929ba92357214ad30633dd5b257ab2cbc1b92c29e76890e7f36e11907fc102a9868b6f0917d75de5a502e7a13ae987c743854ca3a652c614b74b3d8a694f51f16f55c189ff2a05e2f73d0ee8114ca3873317a689ebde55265d0c98f45e6acedb56cdffcc626d21360a8b23442f8e736db826459a9c1fa994e479d874370c62c969e0e9e6e315a20108e59dbb85a2f7e81b0838639d87c5ff64a9d9a0554923ebdb24179099c280d4b2df6648412a03487171c3ca5916b25017fde1c10b88899b9d3e9bc640a4a4fe2ecccf1f615f7b32194c627240521944d60f595a3c291cbc211f00d278d26d4510822d989899c8105b15c4b883b15e074af47aa721e13127c143eaab9c36589d18be35144e7c37267b350a7bbe90d69ee3dcae7805bb7f1a1404776eb4e159b570c4357bdbe62e686358c31c837621e919f7e34aaf9e0171df9ca62ebbb65949b83df516fd45f0ded3a17c9ab7a1419ab75e7347c5505d4299f9a71bfe0c9ea8a22805eb79d107a686fe38cc6482bc9ee9b54fb684af0a42ba81ef0a987f5f491f937219c2497f40fb2622468012e46c1631d4561e792bbe490dd3996c986459ac54d265ef1d8b89e16e77f528e54a5e3c982ab9f29114efa1ceafc30e9e234cd17d4ae6cc1209254ce9eba93b5b9f1e20ab8d22c838c86c9f9e0007879341d8ae36463bac936a1b07a46be1cf8cd56a4458afdbdb5afdfdac2378652b76673edb1d73872e40a638edbb1dd47e941e72cab35a1099929695d7bad62171208a5d358ce4a28a77c0d4def912dfec9f9f053b55d9e67dd95757ee203ef0415d7f7f3e38b145a7ca0c078db0adb8e4c50960d1f0cbab906216d725cdc0b3c4578e25c874b842814193ae119a6c0faab9156697daf9c2a20771809be2eb07425fcc9b6154dd01d8f3435c00579f638d4afcf02fd0811fd8f301ceb15f92d3fc2e37e2710bd674d5f0c08c7d956831c3e32650455c2332df42683613e248bd78f4ffff99997b5d002dd931a60a0ad16928ced6cfa2fb1041a19b7f08f81a3ca2e472dcf96569460bc6c5f7cc1867057a7c7026438dd2c15deb9ca9fac1ca9cd6e9f2e1da1d79db756db8ae55f9f94ea5e6ada663f1727deb818763a3f5b85f41403fd6544eb62761c4bdaab5c5b95b380a26279ab6ec3d8f3b02633698cf64b77288a1fb7ec64409825a8874013fcd785587b480d80a73d6d3cd4793f8209404dc0bd2c6ab3f7f05e4e428b62c1abc42914c4a436050a13d622fac791c53cf45e53ba50474ea03a5a4d68861fd47b9277084b1bf1400321a5b94e2756f459da562045a2c3bc8adec67e6385f506282b2bdc02a3e099350f51889968aed5c9b1164e5fafa0ca9683787141aca814744c39caeed5bcdda2ac25d2072c8beb92ebc0b0cdec4bbfdf76cc27d91218360c6de8cd9efaa129de31f6f6cd54704bfb0854f2fbb0605f0bee3ca6558a758ff3310182d2403747ecca3ffce5c5cbb05b61d894e3cdf99dcefc24910e5d9d47f274cc207d0f01615ef7962ef62b2c029ab2d453f6eb15fcdb78afa7bba008b7841926685163569719ad8d1d6efac9f8bc38e846129344545ceb0e058ac47c09f9d348e16272a754e5d5f36f65b412d09938db1b7e4a6dc541b06925dc4948990bbea8dbdf7e44a3fdee4e75b9c906c800eac88b8e5de4017fb9e623c38daf92a72440254401cb10e3475318b684f7c8daecf715a61c931c52a66768326c2d7cf13c3c5c95171039d8561cdd268a596d61020bb35fa1975e71002bd1c5dc2c7696d0d186d8c7f69dad04164fb7914f870c3f12d51b4f0231556afe53052b6abf4656a995c9886c1973537e0225cd9ace4b2d2f9ec7d7b5df74f9943b2c1e5914711126e01d6ab34ca0a5702ad31b738e4de6aecf46fa5796c1e1ffee95d2d64f4dc47abc29cc037c390321ce1403fec22d24cdcc886b68b3d92e091268d0279eddb503110a491d6409687ac7db32144d415f5ff810ddefc15985c59f4ef2c232bfa983372fdc3650cd2b2c1d0de016ede91b86e106e3f5ba2391f52629883cab0ef63198b79e5083e702801661c0515cafac1f7f541bed550e4e090589435407fb500e5fcad952c490fee7c59d54dc5c33879c1b71007ee504fc926b543a1859d434218e845a0459ec324f9eaaff3d6589acfb89f1a9204014978e93d81a098ca298a989ed058c469c502a77174df61fde6d31fba312954508282c4515b843a50cd9884406692d8a6b5e4b51d632875b0adb2c789ac527bc6e1996c8a9b2c28819edd8abd535f81f4bb27b02f334eb5840d1601619fb5389df1080f1dc5c82b5cdab509bbccc153d4f29064d350440fa1cecba3bf864fdab4e589f57c1e8bbf688c2ba10f00f83ccfb05d5b6b336ef29e969fccdd63dab62be36cb9b34b5af3f910caec754f46105e47d5262c22b043f21a5e61cee909807fc1f9c3f5a6873643795380f71b9816da1a0f11625c79807475f2e30b02b7b072fa3a45312d05adf2d3fbbf703be87e7f8081d5655f96ea7ab38f2108f97e5950230fc3178f120e7654c4eb37fa1c5ce098c27ee11b8003e073b3e6fc8473dc6d68a097be0796f691cdeb3ad40062f5d13a33a24ee4d1b45abee3cc961347a8f6b55dcc693dc7b168317a4432ec4109bf3bd9c0c1dccbaaacc51abf701d19274342739856a8907b40456c369452761c048765341dad5d9aa5003b850ba50718fa0d762004bd7ff3a44137df4f04bad88231e1e7018fb4d99644d19d9414d97dbf8830ac6e80ddefc6231ada044727b6f5844913d168fa171fa20389734b8b53ff7f04cee3bc7fa73908bdeb8fc2d8a9e7a7db6a041d82c710acdc8a0115140c2dedc7040d9d690b3d8ecba61efdd9d0bc5ee05df11696f38f9bb4eb16841040a76fe40bfa36deda47ecca1bb649b85dc3fe9ea39a8a75c3cabbadaece289b8b9794d3fbf2b84f2edcc8f210e9a261350587666db70bb3e6b71dadd8b7e648468cc34cb638f251865e6c1d1aca7a563d687a4e69445feb38b83de18f047968e847cf6e255f9e182f7fe6f156194108da3039a4d72b5182b2c76e8013a8e33155a77873340a9c9f6bb432a97b71992e6cf8a1143076308123455ed8d5d8dda30b3e29144d1f66047572f1cfac3aa92b2ca1ceab3aeb2c00ecfaba77987d5ceaa5c75759d0c71852742b6762e036654e6e0920c9ec2f901887ebf1ca2b1b42c1db5b2550d88914137bab84bd7d0c013b26e87d5bd9b3b466cee48a51b72daf4c58f0a633b08825a5327e331aeab7899934cbb04b37a7f96b6c77bf66a814c1ef258b47be935a235bebf2bab36230550b543c8134d944a7da59e6f74a05519005a9bb53eed6b5e266d3c3924222fc0ff71fa787d11c6187c537779904e678c54f4ab7756559742130fbcc8d533a026bb5de63ee1228eddf4b308beeaaccf4306d17382b664d668c85e96237e16adb0dadaf51aa4d75884aca15a982a8e595da7901fc1334af7d8b85627e16ab828d7d4591f0336edea5bb409fbde0ebf8c38be757c3b814c3a2083201c6fcecbe7629ead0cd26ce821d3279546614fb6011ca62316d97717137ef8c44e5e3f3310d22dc413a391715bd41cb0164cde8ac12248da4e725e18c5af098b5f31b9630544d24d9b0cdc71e8f94ed475f645368870af2536e6c3711421c1c771ef4e9ab5d29d848786472098eae86044f178db2652ef954d7702e6cb3ef655959b9df3e769b877a3b9b9670784d93a7b6d063e08201af3281f203384859223761d0f3d9f82bd0f5a56046b05ce3647e201e7fc021b7fce60a58f61e0f1cb8a437bf18e5f2cddb39a917e7cf9650a27ec7f641b3503323e639e8a762d916659698fde9013426fff50969de75e019bb086d2ed7d70301e7afaf119c070d65be5e0da89a631b8862f897edaefd0382d079a400ba3529d30525299925e91f639b88386974c4d1ba7466b121ee4e315cb8d2d6a65097c41834c418644fd118b2da2f981d65481589a0d1932fd8dd446d954a5d1ea22f38fc9c4cc99d717329cf2abeefb6355d466ab54d2c6821eaa57f17304bb404fe38bb16ce8440b09931eff84fb57bfa716379331d624f15fd08e0f67d26ef2240ee794374dfa53ac736ff81c3bbbbe87e1bf289e0df0558e0fa48a1cd87f16efb80ebee753ebcfa7deb8a13cb71ffd21e932c6f2e5239260fb02634acd706e7f98b1f3cfc099a8e817693d284a8cb223e2dc078900b6f0f460adf6c4392c68c0625bb60155942452a78d1f35c8678567cc25506ce76f402210805ef301124f1c6e4922affcd5c592b75f2153ac726a31a72dac114e1bb091ecca6adbf0a066e2f9f6ff9072bb43ae6e593f0c9f741d4a65295abe453d1d07929ca137abe155f24143eadd8ea3dfac341b164acc4d8366c5359d233c61787d8fd524991596de0ce016c14cf133538f3fa56ff43961341214b7eb338f6b8d4b1350e7467eb3348fe13e6b3b366964e40d89a42390569f5174c45f957d57aa30db4c3e182265c3d11afa5e86568879b274a4bf6e700fbf339352c2cd23e7dfb8e6f7b4cd34f901e1f8f72328e74325ab72b88f67faa0d0653dfb5a2752f1e93fb4bbd7f2baf98da61127df3a2bb43daf1f301f5d8169bc1be342bafbaf95e738b0efd9d37a64961b29cadcb5ef6dac10c943fef11e2ab2bac0fde69f4230bce4843c653fe6bd15538bdfe604dd8128de17f13cc37a73763404d933674002cadeceedf90a19d74dd2958d52e5328f8629691eeca0fcd7132e14bde7f27dedd7323b8ecacce33a3b0d4053bc49b51a424a9e81db4e400ece1481d2f92e390c45e4f91975854cb734827f8e1e955e73cf466d7e23d2d4b5329eaa741300bf65ba654b2a3b436ccbc91b2455dcec02d1ad1581fb1b4962a64f4361ca1dacf66ed73ce6c8ae16a8a4e56e1ef87c551fa7c5d1d0e35a5c311289b35cec258aa45b3976b9e9b37710fc7a496bc5559cc5e6e83caa93235cbbd668ebbc41ee133da1a626b163a7ec2b92397540b0b1dd12c73af01be46f523fe2369e25af41aae8fbffeb6f43c27d5bfaf496ea390e8540b687615e8397b7e4aef5bd5d378d57b11efa84668641939c05321acf04653e8b6b54430fabafef60a245e6988efad8d6012194e90b7fe2396f0b48ba92c21785be272348489ac8e1ce7e66d2d79635538681c364f53bf2ca4a034ca108258d1c50ad2fb0848d392b31791a2338b425c8b2ec2513b2ed0fdb4e570c5aa7b1ea4dc183a2499a5af60d2ba079321f54139465cbc4edc541df3146221462ab02a8a684cd4dc2e2bc169fd9913baa296e00d7b48bb52ebe5929bc97eec7b74b515e132e8c9ea71a243ccfcac92c7a36a2a599396b42128d049c2a3bf2089dd225558babe9ac29ac607021d51a0af95cd22465342060dd1dc5a1a315f93425446de2c273efc7414f645fb43cb99ca0e870d533d1824ce1493629837e10ae20c0941b1bac825897926c6ebd3049a6552522f11223078408f132795e375622ce8db43b717b3b11c883b063544c5a71805f054e761531dc517696933564b23ec65095c5dbac60dfe11011c602aefe934ac636858f84bf8888fd6d77b339c99de344aa9fc19280b7e9d6e202d1e91751d2ba98321e6c264d09a421987ff68b4e5bdb67e3defcbc209ada0a7cc4e0665bd315e87c00f701081636845b47b85b1a6973044e817bd9f964fa63e4a8120dad5e66135261cf1d7da25fad390575644eba8933bb61adef7aa6afb5bc50590548a4c11f94bf1767a910d6f1aa9ca2cf972e299300f3385b315de0f396753ab3348e20250827ea63f0d1f6892a857dbddfc70029ef274edbf82d981062e130f2f61d3832da29cd3267e9578fed1eaa673488de90c56bc7746348eef9f5575b67cb1b20790f8b4f2d9e3e911a22dfa4118edf13643f986700fae9936e2e50922103b5d38ed8e1294e41be0f5916e21472d70b8335c98b92e4ca33747547d04646ce3f8eb3e6c544a4adb292af2ad424e2f5286a116f30df1e717e8807f0e3aa5e5ce3b070030be77b7aa7bb77813bfb7dad90bf2fea6c810ef3284b34c6d737bba0dd52f2c3dd6536986cc15f34b171e7ecaf06602d75d4f234baf235a8991a731a96c188a9519e773a7d06026381c155c7217987b2d28e2f962afba595b64b495de174c896386e8befc1483e16c24f7a4064d5fc4fc57e84bd616b35b78a71af3048d73d449483647497b5783e422ebc43fe8a1b5e1ad1b423dec8a02c7326344c49c44b56358515b7fedea803bc50e51d52b93416d4421aa3444a4ee0516e104b393e6cf36a3f7ea163ae65623f55a1a04ef30c05166d88258fc3a622f46d85dabe3caaf135de37ff6ead91e807caea402293326f8902ddab7a15dc9299dcdeaa40440d8c919761507e023c68d15c360637c46fc25720e1bafcb297fd46309e0838361436f9e3eb4c730f58481adab24492c699d10ad92a98ce6ae2c7366c59b4f14e96955cb1e93d85284d1103a4026dbb910034ab37f20bbc5c82696f1b68ff1388723979a564409914bd98f830bd63c005b10b2ce17fc247eb43ee4fcc3db2660f6f124789a41176eebda2e77c6ca79aac37e59faa47dd34e84ced97b88ac9e0ace2fcf128d7226066f1c2f2b3f8bbafc0b93078e046fc982afcd8338d5b3e052b4448c1cdf81d418bab19679ff7a86ee0105e72590495c8305be925197340dbe35cf24b7a94873866fe29973e551d16ed4762182eaa1d3f99bbe60e0198e7a00f0410b267a1cd5f093c5421bf560b59d4218c42ada3315d047b5e387335d4c383f839874851b4626b98ecf7e6f817b1c196f247fa3d906f7e6999f9e205f5860c845d40225e8e04012e1c994158a875d3a7e9707a7c33d9f6e7f82ba36f3dc0a11d435ee11922cfed08efe7ec16bb59e8c40abe773af605afe4e03fcd399c14b2485256bea9d756c170743f410d0f6662e8158ab2e66fe9b0f1b22142f2ddd7b190eb930d2df14e1f9d484b8defc62cdaf9b917a11de129084bdf1e94b0bcb69deb58ff6df6a02a28e19070089c2b66d3c807101c0d50c71698692815fc094f36b8afa9f966fd69fffe800ae4e0424316f0d741e23448fff163453e6db734809114b4b0fed7ef18734533d9638ccbd70f9889c31d35617dc9564d703bc411a964447a8939b9305f042cb59c1e104d498e2afb825ca16dcba6496e2e1d99b3b03756b0a5223c47fb31c313b07f08f93aad661fb1649a6aa1963a388b39428e3a9251d0e1c6e7e56b7e34bf41b3f96705e1a75c079e97d719f587fe0de73bf33c629e466b21502de500f4119ccc9e5919781844cb597fc5e199f4fa74261a30cab8708562c52520d7a70b56675615ef32d6cbb312a58cbfb8f06b639b95ae67ec2d53068fda0601ebec5383933e0b1f5d251d3c496c120b89e222a7186f63e29e895fbdf78217551c13a50f659a91933e24d801140eb235242bc830af59f03da7644f9f0733f16e1b04b34c2698f89c9aa42f1bbf4eee870543b97b3bc767f0a359b6b3dcada890b75270a0e21908dffd765c5f8a1548aa8a24b56b2918360119bdd4f6fa93262eff145d1d2d41e2b553a81ef12cbc4f168d721b743b32dfe39fb27ccfae6e277f4be75a33867a8ec1e7a1ce2e6beee1ea573a15a93abafb2f84b91fc80f491b4baa258f14b7f56cd3b73d238e5206244d6fdcf772d1e38930de5034ea84daf3fe0a425596626c2e011011016d2dfb3743df4dcf73f09f0f0b08e41cde96ad1de29845a821f27a07ff0e457896e6a2dd04586e1a409b31bb99534cccc425eb2537eabb3abd430a3e11ac4eef17782d014e8eb4557025a87f73b83a2cca3b1321fcd467998191634b0f0508f7899c5dd83e297f99eff8cba5ba8e54a8a55e7a82a3349d1483d4d8d232f28b811b207ce3094d9e3eac2c343b7145c83badeda1a4516d696fa0f1634e13a72b0768191d317cf53c12478a3b75208d98287da4aa5b7e54abc5ddc3b8ea86788a90acebe23b3760305e19a719501b4a68f7fbe835a45dad15ae459916d84bef52407cc80a15bb3966e5ab29e3e7120b9e01825fb9ddae2b3cc9d4a199db45e3f78106d64df272c8725c1dd6ee007822c18b2c728fde4d2469711e5ce840ba1a75deab8fc768166a10e5b23d9f221ba877fac3ec9f36e2b1d4f522a1b26f5cb2c351421d2d1ff78722dd5c073e736865df74ef79a8c7161219b898527936d5d139740ade8a38ad2b2e8393be410498dccf5516325477bef40b9670eaae3d9c021f066323cfc7a663dfdea5163a765ffc906ed68006aa3384886e8e1a35d9dc10bbdee0b9dfca574b342bea67ffd5317a55942fe10a58a852f0cfa010974d091efc1011cc2b1361246a1a79124a15e25a158836919ff2311bf96ddc621e3daf42415c362073903919afc4d1ffde0636776b0a9d6597588a80e10ee426d766b4ff2360d7566dacf60efd3f0f3956d9fdf5dd79b7dae239bceabe7e5dfc06e6c711a0f5bc1dd99ec947f223fc90c4205846895b40815fc6f2d724d2806e904ba1b30e3c9e1de21ba9ddbb1edc2bff44a5fb12b8919a55ca7b3f533090a2efd2cf912205a934c57e37e740420c7d8d178364e26170a041f1a915e1bdb6374af9d9930cb6f3acc34ca47a596c4eed2e48234c9b7401388626d3ffa8b401fec6a822b67624c69b41559a92ff80fcaee96523ca6657f63e79a7c60bf0aa5d43f82436b18670fb6eb32aa93fa0deda9fc7d797cd668f88cef39d6afb745b9c536a0c83583329ccf8576458107154040a981f351e85eb9a1d65a4aab18d20fe195076e11ec6d3af7dde16c20432d025b7a1884a4f8567188e024891d7cf0d4f586a493bde4d2e09d8b29518d9669aaa4248929972ecde7e2eca33eef9a0e44cd2bcec7dcf309ba713a48315ca9d02d974158759366c67a2c2cd68bafde0842243ca8931c31309adb963296b5d53ed984a04647d3b4a2641898433480ec9f4993eb50bcc68dbc4a896ea19ed41462182054d2b11c896a884c45553059d11bc809755656077c42a57aa18bbfdc8254ad9bc3287ebdf480a87137c7bd4e9ed82a7ed5dbaa5182219b47ecb97e2c46e745c12759b112377b0e336e31a5e366be0428fddcd3ca3de5c29be69a82d2f11ce454ac1311224b646ee58eaa66898b3dcc37d8b4f76a048f02df809ddaf440a21a583e6b4e6e5c1929439669fef613fde1b41e5d7b7eb95f5c7cfca168ad8e891736a8b9937cb2d38f2d83f332f5444f52879c2aef77437456fe76b4ebd06feeefd2440ccb0cf7ab32b020926cb474465265208f6d61a1afff0b5879c66847711bcef01bf4d10a2cd1941cc6d293452401cb2dd7e858c9f211a2b37e26de7002bb867477363dc45860b0dddaa6f9104c582d6fe00a18f04af8bd82932e46af754caaa0f600cfd7fb260a659cb54da4747ea075f30fcb8bba0863436149e018c3f5d695c06689541c86487ba968c864ce9a6e01fdab222f34a92dda49f2a2063717e85ede86dabb6a5ccebc4920022131f7ca143594f85d4024ddb63f1feb30d227adc02317c137cefe826d75498c3fbcbdfa26cbd346f15dd3d4a0b6ce0815e27f088f42590c54135dab6051f9e257bcae4f3c829e0be9e335dec8f848db01d63acb371cc636af95e27f87a6cbacda6e71d83437796deadf3af8b048c55aaedd14dbf653293cd8e64877deeae21972d077f15eb0a39463d78dd36a56c11a05f8948df43dc17e10de93b9e49eaf685441ce54e6563acd5c38e321a36401a6cbd35a3783412c66446f2ef7c23c71e79da980e1b7b2bebaacd01888c158653cd0d0c63f4bae85a9ccdf4943cdd1af5967629b36e9d82a40cde046bb2b11a93c0099445314407ba2446514e84e5bed49e52aebdbb35489d1ccc6d850db8e03cdd5d68bb0a5d0c29f59badfc8710a98ee5e6848880ab337b8d00b4e6fa4a526bbf195169c5a3f5a569dcf198f3e61a9f93ef62b2dc79bf6638be408a89f8237d93ad9beff7f6bbf45c3ce2a563adaa53a81b838366958a08916f5ec3c8259ea6dc7980f53eb6eb5d0c0435079d45b6ab879ccee45846142becc92656dcd7e4baa443c20055f9bee0a2f2303b9025bbb8033ec6b30cb2ec38b04e0f57b82815339ba261c97e7d6ae0686b8287cc85526b07ff8e6b35d8583536bb6df21e1ec05b9770a8e56fe43c3260f4c75c289b537f9d61730de6de4815a2ab8c00681b5daf57fc903b58ab56f5a33012c74dac93619a87d9496bc829ad1489222064454e4ef60cafa614aef26341bb0be4080987ef1d8a51cb03a02cae2ca60a8725bc858b1328514ba160d9d6d78f2f1edf156ecb3d07bdf0a2ec9eb15d8089fef7add4ea8c59a8af093e9edb15f498aeb3d187aea3fd700452e8d4cbcb8f2bc707b32b4af9bf23be88de1293ed2bbb5d686f15dece24c22cebefb14473155fdd0d6aceb99f1faa9a2b56ed3d73723076a9ec41ec507c42fea299ccbb7bafcae716f546054119618b1c9d0220715b84e46257fc98bf1b7239ca521bf49257fcd55a5c47cbdafe3e4ee53f6d121c18543384193bcfa5736e505d5e52f09b11bf2cfd1e3d4245468825bde7564e1ba69a656af0be3484aa48a68abbad349b814f3600b8d052194ce1921e7698feed2644e48b19daac652764da4e329535af2c1f1a7b171656973587eb703479692803b46711ba4517e1111f8ce9ce33685283d13707d74679e2da148ceb0947c054c670b4d84baa96c7fc7dee91d311c64a15308bace1d2b4bb7b737c970494a0c0cc52ef7f2087d49f903caf2373dfcc244a762adbdc594ab90e7bf3f9b31408a892312a04ff21f2f716928b2fe140653d6c688837d0feba2de7afcb6885f68107a7c3b78f6f393aaa4db2f8c11587ba142a5b38aed3cc3ddf6e20d7fa0d032dd297b32667134b09fa4d896c7af13d90585413006358c904630aba23491e9f7c04a03a68f8ce33d9a6de5d815355d8a5adafdc0b2b26bb5b9afff7fbf74c74a409ee7377ef127b4df2aab7b7c2b5d677b2a565561216c0a093b5d9f15472f40f7b287487a4f2909fa1319d9712b1e970d8803e6b9907e291b7c41e618148ec380d5feedcac7253a8ca986e5ba56107171a3904732a821389b43e0fe1f7ef6a2f8aab0fbbc171d724dc2972653cd7900f447921cf89bb2d36685726aeb272e17bc74d12675731550094e4d1e073b66f01b17e8c52fcca3760b978f53584459897086ae23a0b930f98b72d8eefc531c9be4b152a62c51eff227fdb3f5e6b1569ca0af0ca248a7e9982c16b6c57886b2b162bae9f89ecb9c3b717ebeca2f0b4f67993662303438d772422487b40f60aae6cfc40f6d83e026db475ac174b7f9b823ebebabd0f6784e22ccbaeaf89c0064ce9bb75b2ebca5b1dee3d4f22a846f3cecd9b04fd55fd4daafa1632e0f0ac36b28d53f47eacc894c43b6e9fdebf1a3286cf71d10f7492258ad3390a46f96b1d4896d52956db5860431b88f0892d747b25886e4c415c68a7ebcceac7947e63cc0ec02e780e6642f1f3b89021953f58ddaee9250ed759694366e7cb33e1118c864ead7701efedffc2276287d3f11591f8f85a9ddf81a270653f7aabca86a0cb793f07802b9672f34760353579c018e7d744fd98352d0941e3cfd270b94d7618e3a69f538bc31f5bb58c73ca2611c14a10cf45cb2f6967d2cb8e7ef7e87ef7c09fa3df5df5d6cc565fed0ef82330c5e7ae1c3852e8e6dc78d3e7f5acf930708800b683438dc616570cd0899531cba374a262260a57b42f01dfe65ba581511c25228173c7aeb9dcdde3a761c253de14417ca04bd4e93b5cfed614c68f899ee01af378a6792d9d654ff35f76968e5ee037a0c9f8da8b16eccc8831283b99c2d24fc5a8b5f784da7fbaa9902bebc298ccfe4a908ad61dede58848b53246a609dfdcb45858852339ef0509e4eb7655d7ac508b8f16b001690258dcf4331c2e7b6c6c5155f6ad41ca8880c42d484a0bb459b92d6be0bbbc6990f5a06d7b9d42f75db594519e2f62f002d9856dbbdbc9adaa23d253c90ad052925e5f0fc7492a948e5c97fdd1f26bd592a749f7db9b49755aa6239efb3da297cccd025c8ef401a35624635921345dad86e88a99247c4578c0b11b3d6563faeb1fccaf25ef7baf7c0dc8e91a47b10b9f02dff487320e41e8c6052551ca24a7930dcddd1ee85a2ba04cec95dee1f1ac2efb3269097129630a7b242e1e4cb28054fc44715a46f4fcff2d58c2b1bd6d008e9f9ae87d11364983c2f914d75e678e3cf57e781a11a617dcb1b64ce03d65cbd5b5a952c7caa70d5e4d89b252cde3b6c3d4ce2024323c1cbc9b8e66b6458b7472e155682033945ccf2553632eb19e88c0619726f8d2eb5f509e742f2318246fdfbb8da1e2071e1a0444e1e67388f21fc417edf7c16a5a6f57a90b4c57bc94b547549ce24c877eba9cb0a9511cf1ad2737ba483e6946a160df289c6de6646d846a46b26837277d46260937670b4b1b5d6035faecbcb87deb26d0899dfb6d5b419824bd9a11538f7b70a1b3a5d0f6947861e0ec66b61c7e2114fb584d66458ab267293f4dab86340c04fe7857c24d468d69aff26b70e02bfe382b714deb44f5ada2f6ba6dabaf2d1848140bf369253edd8ed82e37472c1918019e727a8d20997dbfa2827890d48a52dacc3501fffd2408377dd2d152eed6465034c65b4c6d3edd32178c54291cef384cefab40cf466b6baf943253ada378a5f87e39297a1ddf474f9e3a9e8367d5d336514d5352aff8ee5ab6575d4344f6e69ea09f20e670c70d7303070c1e378edcea409fbc353ed5725bbc408c8f4a0c4ea5641582a8212224160763a6459ff304e622faa09371ac998b73d748e96b0021edc05645a6b2fb0eb2ba44cc1427fd3ee4ef7ffa9942f1b730bc5e5a203cca65cf25","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
