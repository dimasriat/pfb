<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af5cdd7505fcbb153b76dc5822fed949b4e233bc01cf2452a4fe82997e722a391ce4c71a02017112b51bdaf9e9045214a5b10395e2c173602ec19c58dcb3fcd792c16210f548ce2ce1995ad99b4bd48ea36f72d594d69f5fcad5d920597f84abafdd28e207bd9360d6715be2321d51ccdc9cf443055d2c685102328a7358eadce05f07955931cb1196d11a34b2a0f8ef31151eca0c64ac0d61326822f3c45f0f0005e66a26fdd17a1ffaa35e43c794ccdfd22ef5106646b8b5937c12205908b3e7be8bb441685677141148fdca5053332debce6a8cce5b1f6497eb9ac60be24a928cf29f46fa92196b4e75a900359b50e0105f6d3e3c08cc2689e8b1b674de84bb2789c0a01be11589f9205764226a77a697286cc2ad60eb3066505f065f7bfc9864ed9c300b8964110df9f582425c448a0b6b8f2d187fc7d91da111fa1c5ef482a72d147cf9271e46d5ecb02d29cbb0d801031874406ccd6acb5a902da0b84d7d4596fcf24d5b26d240a335513baac0ee08b4d766048a987c5b9e63c6302fd0dac36a5855786664b01e6ed131e61b3b0ec5dbfc50032466a5473fc5e06330aa7e34939d2aadec63bb6af2082c3967b771d34435cea2cb5dc18afc256066d1d157780901ab07d95bb848be65dc55dd0b828cc16391920633dec40c3a2421ae2c2e0b60ea34ad0fcb63f9d3623deccd91df51f4bd544c0e425c2f34964ddb65b5e5170efb31737025648f214b0a5cce02257df366c5b02045cc865c8e6c241d50d0f7350f7d164fd36dafc43943b3feb1b4f22e9b4c621a85d8b9f686e1e6e012e3c5d2d78e9329a01e27df67a23e7978f5b6483eed11b7e02981d63c10e6f2a2674b0ac05cfa17d1d8ea73628e1f7e3af4bb1903a9f5788ab925c1a53f9675359df35c214d1f2e6ca6536ec36429ee9af79596aa2c473c71b9c8dad95d4a240643cc89ae0e6a9878b737e855f8e2682f452e43c76e9f234165c382a3aad990e7defe962900641a028edf66844442b136833e8c9e561a777eb7c73bb4059c6849338ab6fd9fc78f9c92a5c469ec1206d00ed95fadbcd93d9ad8532316c801fe9cb0f77ab010a2cb6009cecab0a515ac99cb55a91fac128af46d08627a5108fd75c43ffad861e0379fce9ef3a934b36864cf874dfbab474ddf92fed106b35e8993fd06a786b72c360141d07b5ea6b562c7f398bb62a8e9bd0d8e3ce2d1aaab8ad57e16a1e321ffcd6337fcb90d6de3fe39c5b8170a8605fa2c179fedccc14c8d6df1a8bec0dc3f095be6ea9423dd516c6b44cdb8e2c6f4c27532819f49141c679ac16789ff1b3286517f1a4baf12a0c5a804047445a117aeb83edf7c0a49292cf489464935e759c775b78e236c572e722ca71504ab3e85e29b684126b06128b17c66d47caf45b51797fc9dbac5201d9f0da772362a1cc41d6dc12155e90f7da12b8e2766c5ada1106da386e2781a85a8ca54a2a6750ebb8237238080c60cba57edacd8a2a5530527ec2d4f43ab9f9fddd72c332fd2464b79004900725b94e89989e26d72ee431df92b864a9470f8d60e9fd10e0065846126328ad570ceea8bec683f91ea3b1e299b8b14752a8c91ca4a74b0d4d97647d05fb48cb3bccbdf15ec3ade625a8d7cf3575d9285f56df2909a253b24cd483be9fb2372af3b5e6e01ae0aff5a13e03e42a018a031a6cf689965e16116bfaa0899610b1ee3a93f144ec247613503ade3a5e741bcc6159e57b5b992018589aa2e42204cedf7d3d9a6c15c3bfda2ddd20acd096e45155c0efce4e36164982833328f690f80f8f537db7062f0b62337b445734e7a99c9a578f9df65da51c71afde5b9a207869ddcff75f633510c79d02dd1b0b22d8d8564cfc55aadf191c1cf3443e50b93e0b8bdba121e959fcbad12fca9ba47f8cc915468df489aaa98a7e019647507d8de9bf4ad26dc4081b29dc6535368be3ce1bbb68f850ae1dca12df95074bf4c21cb79764e4b32afaed498e64c60e7be8979bb43fcdd3a935c3d5039b4fc3ed970eb04bd240233f9ccac930e17cfb0f08985c30f37f8a8c5e1469a22477798cf5741aa3f00caed534e59569dc9a95eb64b29834676dfeec9bd6522a6a6287038118d755239d22d990facccc75ade7d9d36e91278971ae8169ef690844849c3576b461321e4d7581532cf943568c6445706795be58833177118777520e8c83e09934e597c927c39be0ce6a7195711606883ce22ea9344c14838d174a9d010d29b8659ba16cf644f13e59072394b3d837b77d79ffbbb72e092fb32a48cc7d81a9e25c8a978f7aadc8de6a370c1bc97edf2e70c0caa2ee6e15060c4fe00580a86cbf0cbc6ddee056f2b45664967fe8c352f23d97c571a8996b46e74ef7571ce6e59f4eba5ed9ab91476981cced38fd8662a95538f05591b42938d204e2740877084a0f2ffc25db5c09b480add36cee4d184ea5dfc03ec4339974c2e4f133eda132f779b0b4daef023d72ad245693083e94451538510cdbf3d91f7f300c6d5c45c2aa93a0ca6680e7d355c666394b565cae55b43c72fdfe1b8b24e5daa92eabf7d4868714d58dbeca1d3286e6a28596b48b93d3ea7a4e8d09b9662d7ca57a84f5e1e518cdaede63b9dce498e4c5d9028340763ff467e5f1ee9bdf5a423118c6be53684dfbc73830cdbcb519181dcb7a3a900908c4d6bd664403f2de15854d949c46a9a18f3c1aaa99f00af46d1b05b1bbbcfaf796cb56c2c3371d804d32a5255f3f7b224d5ada00d957c6938109979adc281033e4b2bb74f1b6a20b03408879fec687908356aae80e3e40f72ce7a5c6b68e69f1f59f1c621080bb4c401284b0a101bb84abf1590c9688621df9876a1db587ef64b0366515ba4732df75de8e8fdd8fe67ab246317065c618853b625df7c22a6b17dd97a056720f6a0c5b76a65e9e3e66b593090356e1efd6833bb9f55990bd3709c60ae47f23ba86e09a812fa677193bec99fdf34b394191c9df355eed6b32ac6e9be62484a4a436328a6636bed346ccff967e4acc1240479e88b1fe6137e1ac920c65fef35dddd4987e2c90a757aec8cb0e766c21574f3d06f15a5e5082e0f5723da3585fdd6db6650a9e07eac3eb3b6bf31fc068533142eabfd0dd9668caa398fefc8c7a86086b5671526dcf5a1dce0349fead7a77cdb66f8b944ec494a2692b83a6f159035e6252343ec977ffa9d13b05c837b115d106365b54226e28bf86dc425a9b369ed156e1abfbd72924f7f300cca6efa4da3686c276d3aaa38ce76d015b570d43b38ba604f0c06f2189258ade8f8de9d8b97eb26ca5e5866c2bd6c5fdc5e6453c05adc8aa9e99a27a7a9b45d62d326d5832cb3f9029196220ac3087d63dc828bd6acc1ee3794ef4596c987e990c7650608bb2a83a74488ca57c569a22983de0c0fb4c2e5c52fd75a31ea890ba98f12371041a89c2edf9e3f6ad7e6af93d0cf03278a2cc02133f7eb1a879c33e8f1a879fd30093037308b68bf628e8e7aa08ee53984f2b664f676278ae6eec25e445c94cc58576ff639df0ff991df9362acd8cce10508991e833034e7d4d616d0045d7021b2b4af8f75d10967670646f920904f497b6b279dfaeee1a7beb796005d575044e252d348698352b72f97f0533bceb6992c7e211d58b8caced2e797db37f04545635303febf3e5ef99e2203d2dee985042f2d4864117b3f13927f32229897faffc5bef550903caedd866b01a38e1abcfe51ab4245964d1410755912e0a6adb355dbd810facb325ea168be7f03c3b7a0776606b14a817ea1c0e8a7f0c42fe234b74756fff6b3850aea4daf02b892b878f3c1ab0c7f9ae19dc250a3b71fc1ac237bd29d83842a290d95b078184966351b5768e9db7e485caff824860508b4826014bd39bcccf2297b44022222a5c695cfe5716be51da49ecab970b5ea4dcb7650166bc28082222f1ac1b15a3da6333db725d222ba288629ff3f89027c87f400c2df0ca2c6f90e45834ed025106d2afec7aabd2cd1d2e2bae78911fc58169a3daddc0200a7011b1017ac91d160cc6cbcd42729ecd5bc3076b459c08f1abf67d2b8f545b00d2f4dd7ac49ac12e4538b0266f2881c5d98929b6f192258f60960bca79cb0db901c3d70afb05a33b37c4546e1e021c943c6d92685122f1129bd771025531ac9d0e19a88de13768fd35cd67f410a676f3c881cd7693e8f809421445117bc52d51c945ec2e27de584a1ea6818d086a010a0a54130feb88ab3965af21961d12359d587679d1c7daca46832b9f74a34ade52a554134d76365a9c8ed8318a53786e7a57864a094aa84e7c8bc9e97ef34bee0f3bd9d57a651ab63ea30885c68e708f11291df3e4eaac2052f6efd8fd07785027eea4165a1aba3f2cb9cdd627de6414ae86d361880c213f42b32001897a107659187879b9618b58c4cad5a729bdd05b9df6fcfdb993508e7bc9547f86c0751ff128d83d96c6eed20174ec2b8d81f6040b1ceba5780654f31ca811746b30329b42dd634b5a5061cb97a4236da0134ea13c774a9d1419cea79fcd13b1bac4479d4730a2d0fa10b8e6695c4efbd05cda875c88913a0fc60abae4865ddeb7db93d9073aa313bb5605f811537a622618ad1d8982911f6931ac3c40eb385fbc890d9565d5ac8eb17317f150edad77c045aa8bbae02ee85af4e500df129bf97d04fbca28c50f9fe9559fe1e8247a8a261b48313369630e54302f9f8f490e3a8bfb0a8923657d376b1fe90f85e2138554feac26b5225d75473e2d2e0c3aa270b9f7e9d135a71623da8f3287b907952fd15c43a23b58f827734fc24c01deeba9cae1082c8b4702c30a876b972b36b051ffde3529da111e6449e5b38950e81d1b7b48dbce7863be35d7f02fedd982dc36b42a7870aa9d388f39a5a3f09d11334360f95e8791a027268c6cd2355597d1116acb270c86b6c43e166fc302a319ff7cc7deb6f8bf81a47639b2fa76d6c6e4250b19f6013dbe37f3e4805f8af6c1db79672373a44fa2037837ff6c75105f434c4ab7bba407bb48e3d1c7a1e92a94c3159c2440bbd2a006c8bd4c87ec1df653f700ae89a4edeeab9e564b185e0cd71816ebfc3c9bec9c191697e56a240dfba23d26441196ddc3e52264ea0004dc30b3c3f2679cfecae9a56a55893487340221d8af93345005ef8363c949a858ced81d598dea72c2e4ecfbbd26ddcea03e8cdc8b60adba2989d40031d7141bcb3f14a461da161ca4383a5c129b5fe26815625356f5ab7f720f63b0c3494b6105c052fbb6291d61eb03807e32d8b24ebfa89bf376ccf8b37a808a9f6a749e4ebf046c9c977202f4259fd597a2c286554fa6b857773a73be5cf8643f1e49e53c62e0476ccf9f7f5d742445816f5fbaad73967ef0267ced0310c6a18e9aeb86e1773fc9c3cba9ee40a6601341b8b7d615df35e93cf40c768f155835919a8d49979da59d15bc6880906760fbe93093ac7ca6dc17e7712eae331ccbda8b8e8f661e36223305672f401e350cd2790683c04b7b6808c670fca0871b164f775ac61cf59d1dd5d9cc35a7f12e45040d020cdca7183f18830998ba6f4069e9eecfa6abf9a84dcda6dcd60c696c216984bf7bbce2015c592e6662e6aed43de5b0e5a5cf9d862e925b98a5fa0bd84aa853b64aa5c94f2a62cf29b789d054ca8f72bc72b05b22e4d3fc1f5b5f089a14472097b18ff91398d31537018eb8d9c85ecd1a11d31a61cf74f1058f8e92b8b2f030743079b7b9f5e3fa0f38d3d6838dcfd8914294350c2083a6ac6e08da249f8f8275c3b9a6ec0c9240b7ee57e07925e565112623d69956956a174b2262d34fb1d63f84bce762efa3ba9d95da561fbae371e09ed47d7a619711fe290456a32e7c96bbc847654a2100f481ee58c0d6df6614f5d64945bd9938f36b10e0290738bea89b6646d884ca844124394b7e97378ece2bfa72802a82d044bdf4b50e5904f292087b8092f7a28f96b50292200763cb5672f8aee2931d2600dfb4f53b96188d96941c5e970385215584b49a1c63d9ff71a12deefc9a81f94d44e8e6f67898e1c6146f9ebae5184f38f6b88491c58b131a00d2e87fa4a68e113b532cab681e9329519ca7ca36f1e7bbe686c7d06646fbb88e23f8e434412af743a41eed5a36c222405c42fac2548657959cee57d06077a513118288994740bea8420a2230732dca6d4ca2d914768c072c700db5df58d21c9f3256a9180a2cd877c008816e739c9a7c5b0d7e2126f36f221aa04adeea05d898f2b98e568a2e0166891d08a3999df769b5f971a58722782d49cfc99d846e55f28b64a10b366afc6d10e02d17546142ba8cebd34641b2c6682d8d2607b77125b94fa414cc364a1a39d25f9598005efdcbcfe8eef423715ff0f484b47c28c2f88887fe3c3f9ee68d43af9a27fbe411fb76aed39de6d9a044b50c4e012f917fe081684b4ef737055230c55c0029779beec4429268e8605890591f8d6f817b98a0e46a77ad1e4e364b2305e9f6e3235da2640bb8743efc404bd0364c1d76469e101ae0b971a426d414b0e70e3e226e7a6ca4239c098001bd49ce791cc266e70afb27b1446d2198dddbba0447cd1a5158f45fcaf30d6902b21361e53aa338dee4ab129fb89b4a824f9003e62fa6def9a1c3ec7ed3f0062e332e1a6d799222f58ec4246d47f2c03b0d166ba54e0a79597452e27020f0a902f1ad5ea5251d9a9bba0bc908fcff9f870008c773253b26ffd80cb9702f863bb70c0ee70a596a4a7596de9546aa27a5c8242e166bd73d53a07adaf1b9344f748514e37e677ad2eb7ace6756f9a5538ec6a57d26582d94dcd18ec5e52ccf099e06e9af55cc39efcbf6d2a7039259f069515929289555825f4a8a4e265a43f0615ab156a3c55f78b7f4f2df073b87dc4f31bda496ec309e2b64902f2b0c0caea0644cb5e236292fc207e555fc226ec90784a0f76d34f96f8e48fdfb6b2d038eb55256f22574c7a6759985f4df7b2bd6a49e5f359927bfb3cba6bf4710eaaa9d42aaf34a97ff3c96fcd9df3b00a723ffa62912ee3ea522209e18f46ea5a0503a04eca99b63f2aeb9b3d3719c35debf05a3f26af1bde268027aa33f1abfe7f433573f5114b5b2848f00281df52f3585bd275be251ca033d11e35278a44140e2f47fbd657c0b3321554890e825ddd5a48ee1ee9201a0d65376dd591e9b1676e7ef0cf756a3fc1d2acbb01efbe4183e3ca82e2918fe4808238d0b3d8e73acfacb6781862d6422a4d557b23d7bd320ed75fdef0df5d5a1e0453e1511c47f8ef945896482457537761a123f08d5f5bc1752c5ef00e4c92912374cfaad0d94e4fb776f800ba31ca8ddb896a52cc3651aae2c12d56fb026381906c9062d787f48db8b72ec67bee9470e2f496af89bdc6d0e166e77b84fb66b6d9d650380e66ea4942c53fec5bfa69919d345e82634b8df3b2c275509c3db8129bcfd00b74c025a55a2f979d70f5b9553820ebc7adced020d2f14723a18a9aae9db33179cf0fa6ca9e90e2ff4a6e7eeae53d75578c4a18604104ee3324066efb93882d3e77af94dbd2de5323ad48ed706997b91c83068a1eabad56a7d82161ce3074f1e0697fccd8539d47f441478b2c90d396147e4d716468694c651331f6bb4b146da1ab102ee6946dbf43501bca6e3ea956438ecd0147a59bee615483892408a4fc431d85d1515b61ca0038e9bd915106ad263a12c845d947c5a0574b6dee9d8ddcd9987cfd4de20f008de3f0393d8209483e38616c0b45cd6ecd5c7eb744968efb0a572a4a72a3f3980485005fc41527e12a56bb5e43cf077edeb92db199e4ddb7b8292ba9af58c08b8a74980fd3f6f0ef746a8b26f5753e8815253a533e1bc4277442e4ba9601dae995d13baca250c6f46a6cd560686de5e50ceaae2fd8ed1fc35155b9bfc6679297be0c142685c9ab118e2bc949ea48c422b01fbe9912281ef3de7156af3a53336dce95ce16ccedf6f43ff03bac45c36b1657b0ff645be9879d499a247ab57bdaff72baf7333dc889e50b534d279dd3c1a981f2291219cbd7ee567bbdea22385085dc5f2d111538930bc7cb310ef753bdce1c7543da4e32fb5262ae5150dd61586c3ea8ff93ee80061e2b493f916137d8105e63fb749ba1d2ac89cd3b09015ab20a9bc108a13af4c102f0b38d568bd90aac77139aa596c11ab9803214280bf56ff06804cef66ec873f909d082a3644255264b7213190b9dbe3639697affbde1de5916c065d98491a6b2b7267ebef47a1f4e3cfa943d7ec94421ca1c3884060e0569f8c62b02de59896c7fa423925fcb2fe624eb4a0a5acce9f59bd6869d61ae5b012765c98c3feb8ac35640914608e5e1560f3231ad1f22a01eaf6f2eb5417e7f84daef4a9884e7da9c96f0af38861a2c4e1ca3946c058bb323a9eaa55f86839279c0bd3b5683b74016808a6785a27aaad985e01889862a86d5719bd7d254f0c63f3c7f6f10b1bbec390c97e398af345413c8b968191f7b0e1e18f931a4fb96a57238ed260e196321c5688085de70945481d040e1966a8d77ec2d8c53fd9d56c5f63adeb82bde2387f0ebf8c7be1d6c68b1d0179e2527b13a9af5c22ac24c405b5519da2d20d7da342321afd1fd93e2df13b9c209523b579b94a4b8e91c42fca1bfbc1b5a62188bcfe121d8f5e37bcaaefd0623ea391418296d8c5fa618781252ab51ce9acac5c3342d82d3f9381fef52ad6bed1fe5b26e53ea2474fa4f8a5e0cb562b2dd80706966cc9aab01e72ce526662e83397046ac6820ab4468faaaa8d86bf380b4ce5fb614c1001f91d7e7f86e2284f3c09fa0e9317fb22ff5cebdf11899a5d8e684960b93f3b1316ca11a2c8f45b0a47aa29fbf59668e188e8e91afe2d412e407d532c721b64e33388cec80914ffee25f97221d779586aac2384c22c7b15cd91acfd7cb29144bac3b020341cfa981179f2043552ea788f95bdc7b28452b22278552609250306bbcd1d4731bdbbd54e7bc664a7e946192cb87ed058725d930bef74e44a77be51536f6819405de449e4b774ad879bd7cb49f0203f2f9f41522dd94a790a4963a9f34229a9fd8dbe5d8db2fc60ef702cdf21e3d96fe422dfdba90ce27893f42ab92df9b2ba02f4fed6e040db07a9be4e9f1010eaf21c0282511149d68327adcc652091d30b232b75b189822cc10940f23c8145999d9bd0ad44e5d4c481c1a963c722c04ff13e059425d61bf6d7482fe89678964e97a34467668ae1ac858262379885e9751a5a499271bd79fcb08e0b79d401ef684205d7ea19afcce1d5797dbf672587f6365afa75cbc467b5641aae5c272d648c99c196119f00b939ff0ebcde514519d608076fda0e08ffc30875a2f108d0d4056c97dae02605a8d240774b5f0deffb6ead3cb1eba716788137b8450739934c7e0800868dd17a768e140cf207dad4d9b9a27ce886f48736943a58446f81456eba722b5fe7b5984b8f28751aaeaf7c0548c81477b353d7650e397fa93960f0656eff16df43c1c28e4c8f24c6e8786651fdff6b8ea735aa182c5f8b480eecd313040d20bb1b6f6d25174fdecf1e6ac2437c0eda3a4a3452452aae47dc821cccbe2d38e6427e06dfa03e681915b53cc017fccc7b98701e30630f759ad305ddab25372a2b7293c1c16cf7b1e62ca658195ab7e0112c738446722c1903043a0650abdc074b4f60297af8f0e6a7df130f238938a7172c153969f268c969a02ec49996f586d1c823b63ff49fea2235c1edf775a7d0cb1307af54c9eb2f621fe7be191d2c75d6d49507b8fd916f37e0390955a2a46bda7ee14cc7d1800e1f2cd2f6143bd93bb96a7d483d7c8fd4119fbe2e081e0d83936da5fad8051e1ebbd2a1087fa88120c76bae9cc44e236275ba2d35bbd17f069f424ca3072da20ca8ea4fdb27ffdcc8009c81cd6b2c936fee57f5e723c9b2a0cd859f1ed78df817331d3c1dc215e73d68856c3c8e75727862283ca94d8e8f876a395be16f6d0e781d6c7988a8db3fe510edcc5dbfc3c1373e531d88a48e3ab92ba49010c6687864b59a304c56a6b4fa3f2a05c7edc5a73d86b9947ff7ec8355ebdd8893040604cdf40a2171d896f042f9ecafecded26ff5d2c78758a217276b9e3781997527e6b11794ebdc68f06de2dcabea61bada6f89f406168899edf6e003be39d4198f8987ceeaa85840e5c2f7a4afc460288ce614bd8428a2116bbcce6989095cb1d184fa66577f6f83f5ffca11db12d4919f41628d6e03b26885fedd5772a885349ae3058bbb27e544f8a2901d5906169c791354b186c1649324e3c2f912609bbce0e5bb7033001e638a8c961200c8160b765790853903a2141380f05132eb809b2542c1532e4c88660095f0345b6bf7c92bc5c219098ce355ec9490157c2d215f6c7817116acdb67b61ba936a0355a60c2a98ad1d91b7c61df54f290ee7d85a537c8186c9042a560c5446ebae5e82dcb9506f86b3367191829aa3f862ec599c594cce135709cf921435f0fb200f2a9c01303ee101e6a38acbe7636a72ef88a488a5f0e8ab17052fe3327c68092aabb1f7cfbc47480ee6ddb360b5b4a3dfc809174c3d1afbba984bfd833ce13fa25fbdc4a6eb76cd788832065fcfe49193fe414430ec04d35e64a5a4049c7b781f05498727755e241a192dca0797f3a2fc44977e8a522a2216bc68a4bdd8911728ad256b65dff8c4ce8858d9fb275655c9288d71d1e5ce342b645963548a3f4bd7842748fd3ec3aac07ba36c2ab338e6758ef05d20f8d3738f4c8b36975b06c0e80335fdbe2bf1ca057aba29ed6c9efbcec274373cf99b2861b9b3642cb0687b614f629b8f57e08d764d9b07fd7cdc18020e029e5f38419768dd24a067db90425b1cf37f975a2a876f95f77fcfac435204ca0b0c76629cd37488ecda063dc17ff530c89219ac84354a4f0b08dc2ddf240ba1cd35463febcfed679aeec1a08325899727420f3c1831fea8c523b51b625fe22a724bdfe60b16949a2699705687b48191eb05473c52ac9578d7b612503a54c7a33ca00649d00bd8904d0d55c0791808dc6636cb493939961cb89ae8040c58a6cda19048de4eaf5bea1050629c8a0eb4351c71c02dadd4903345dc0e2770126e762e712444e17b4c087cf223a0560d043269ea7ac349b076a1b5717a44ae99f2386d65087bd819ccfcac3698d2595f57d9f1ccb9339319bdfc21a7dbd7490927361c6f048626e8760926ce7a4bb6afdfa38caa18b13c4d7dd2cc6cad9d1644d525a10cf59d02275768c039f830aacbc7f61f968a9ed2edfc8c77b7ae08ec391a583f4daeb16150c8ac238f83e3faf1f466d6a598441c3721e82f78cb6a2e78411395a564f7b0f7e7fbf562adbcb0cee4d297f0834140ef2ce5d4b2d19e64e583e6914855abaf06d2efe26d72438eaa12cfb9bdbca523e75bddf8562c5f0c9f6024f005532843770d30485c5305b7c2faae7084f9f76874d2abe4ef9cdb6c9948883150450c724cf95b878b2207daf860d29ed7f11f58faca96c032e52eb500e17b73aa93a185fc9737d2e15df39398ab8e5cb42ab968b55b399c57def383257947a531015c21ce02d6826caa5c641628e5b4025126a49a6f4b096b787865ff8516b8e21a8c00351d3aa1b66cc53cfe3f17a90323d1447510acbf8694f4bca7641928524a3e26723391647df49a4c05d90eda1f1e8f1ddc4527b9be9851752d30d6ab0d1e999f9712bea6f8700da907036f63fb726a25d3682aeaff3893e4d046d2a0b899e24127914a96d70a60ef28ad21d6b9cfd649a8e499ae2183c958cec5c2245895328b8ff1384d633f241129b76c45df40507085d19b6eda242ecc3054e770c01e6c6e713cc0b0788483cb0aef3b4a62e97594f321e4def51562086bc4733b0e6e275f7f5b964162cf207dd165905a6526970465c34feda6fe95bb10eff13996c9faa894ba7784a0b394b28255fe7719d82a51bed601eae52c8f119486d29e645643767b5900bd91d898a2f7c91197e9dbb110babb2e2f18bfd634470d11bfd4d7ec64653bbf0f5c2dca2cfa5285f42940bb7a83bb3529ae8f2606589cb0c6cd0b5f0d8cf97a5651c097b512dbf0d0c41c09fdb042ad7bf1213d47d8425666a01e0031b84aed5deb8de8789dd08f03b3dc7ba988206ed9170479372f888753d61f258f864aa807292bc0ad251d4a804dde858688e0911f6812fbebe561bf4bdf53f4c1dd38bb1e903ba050fc32bcbc858f10f9428d636c7cf75f0594cde2c2040a8f82a6824bfbb6fa24dfc4142d64cdb4241cb69852a82b01690b57e79725bb39cbe8c485127ad6e4e9f6a0fd7f88405551f47c3144ebd67caa787e27944ec8d10db99b693fe810a574d0b31f0e0287572b4756af170c153f69e94bf7cf904bde06df76090a2ac2af3c0d1d82c5f794bba0315ad6fd9c8eef64b7fb0c0f613dc5a070a7178ca8451c6523a5bcd6586b580786b052f0a64d2d57c07e4a35468ba7f2b1c6d1ea4c128a2d534ae34fa23cdb4b0f5018141e11db12d08feba7cf754222807d53797db2980ad7dfb999e213ff7731cdaa3913a0ed6ced92dc47c0cff9a08c1f4e22063c0651e1f6196dceaad06551b9c020a9927f8461a84f4718a64f2d958e748d8d801a257b1446ed0d15d0e5be17646418e0ef9b8a713c20ea9543b0e256645e7d7c551b80f3ded2a5aebb6b1de079b248617e4f78b9a635b196185bdfc5ba955cbd477642c90eb2fc35551c60f2d0f9d47944abe10b9950304314d65e3ce91c99ebeac476542cbefdae4221c283cc051280d75a932df18cfd1dbf02a9495e826ab45cc7a98b292d0da607b1a878e0bd3d2b87f87906b7d4546401d80b329808f19045eb5c35e95ef1ad092dd15d6b29c9e49e93fb91ccbf90a3e2e15f71d453df69c075f00fe6f77c189b16bcf91653e73a3c5c5a90a9270b106acdc82c5201b4fe293b4dd656009c9e546afa8ede621d560b366641ecbe817d8838a545bbbd3595d8d7aea052725285ef230046efb1a1c2f612baf076f045f84e1f64f4e708c767d91be8538c23f51ada69b3f1226df9623a987120613be9c47679fdc1b935bcb06af6c3963317d69b636ea1a8d12d57392922efddbdd91dcf19493721dacd05bee27ae00f1edad3a8a459d65844995030ff89bb981a739594c190987de2f9a7a1d4a28964a47f31d495b0cab39212cfa03a171a5ab7ee8f7b132dde3aaab9ed6b3f25a99282a21a9623ad0c7f29d4bc7b720e8886d2143d315aaeb4e7637221dc71fd360b934f634edc76b45c47246abc9086dcf4c155c01ec9da9114198749713055125da0ccd2e2111a5b3607864874b161563815df95bb6e4957465a9690132044f87c723e15f37e8fe37e74033bf29875f1b3586ab5e8fbcc8c37d4e217bff2a8f17baad8cf6d74a29f98deee4dfd594614d308fd880d1849668c73532de936080f87657b31ec48f8674a4663af959d7cbf6235570952eb1c6e12d2242e02ae5a3f73657ffd01be3283b7ca3aba680704e933c73ce782b73449288dc9d0fafabfc92d0cfd7994d75be0aa99743c40413610eaa93732a3638ceeaf700c90e2cd3da6c8eef950c332e0282e2e896a178af5ea9c45d8485f74c2f178c548835a3e4a6019996ff969f5ba21fb991f054207714e29c05499235a1e348f3a62b7f2745a3cedcdb600a54470a3735ef5668fba7cd6229639f3e2cda8177df68e30c1ddb2e9142116843232fe191be18914d5783e1dd1a8bc91c89b7fd76eed3093b6beab330943c559801d81efe493c5bb26648f237a332079e06ab57d6ac2143556ffa5aa51047f88548c15e556ddecd637e0385a1a0347fa6f7a7dfa12b7b058a62a5c8c2e9726d58786440e8974e72cab0af068b1882424914e829527ac38449f6631821243b3e674c83fddd7459ee9fa4fe43786cb9b840b50ca93bb75e4da9d257a2feeb27a91794f29a9ce32b3d7d9fdb5177e15223b46eb964724d0f4435114da75db382e196a21a407b198034b34b159364b8b32a1aa93ede699a00154baf","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
