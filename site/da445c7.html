<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"439c59adf602e5590d44bf7cfc909223a709dfd218999fbb68f0416f5f1a6d99b258c86b050927010cf03dd60c6cc39a1a38aa4c46de09a9572eed4fe50847013270c80d9c017a62d4c946fd14c795bf0340b7577e97d8d7acfdb6525cf81a256c7fdfd520daddbc7ccfd901c3a2046b371b017d52abf016c752ea97791d8e9392e50d1f8372b9b759e0e6d97be408828bdb6f6d9af205cdc6f28da56638086661cba72f7031f366381a11b4339be409b5cef6124859f4e6879ef134067dcecf8ae3889588dec68e82db56e41d4fc26d642fb1f6f2a6624cb1b549dacd6058f8532989419a2cf492a378574bb891deafb019c4cf14896f68dd803cd5831c5e628f5b7c6d6ce6db7ad84bc50fd846d30153c3c5575aa3ebd6e7d78036ffd12d0e3ff929fede624f3e135ccbcfab38a97e3c190140c16673c654006a0a80461014fca2795c9a8dec6fb069e4c479dbe7da1397763a54ba77982512aa01aa87f4a510c758ba111dd9f0f8c45445fa2e704541873fe013903fe1f7e42110f72c1e8a9bfd0fd28f69e4a1efcc51131ba783e50ae935122254fb91d2879f5b50271b421d468d86f0dea9039195d50d08378c4ba6d22d12b1368455db129ad909857217505f230795de08b8e92ae0fcb93186cb9783fd8b45723e9cae6ab41a9a990136dbc74812b171f4fbf62ed2067d07b0ebb619d2553747b9be4d0e803e6c2c757035d65df72d4bae484c1c0bca5b0214d85888f8789e03ddc9b7779ad8781cf8d804cd61018ddfe8dc22f1820b1de61fdf68fb17f6bdcfa38396fe04909b82bd111fc11d28e78c8780c80588703a1a26186c48664270faa3f7b9a1fee60fcffd0ed2ddd23d791ef6e3b89a5fa4b4cd991c2f24caa95b134e6d80760979da3157701db9886ea40d694eb3f0b727a57abfe76be0c9c1b23b9ba6ad02c83109814809fbb1c84ac6bdb493ca388cac16d5bc6a91f76b68696d4df3cc7663b5ecdb49e38073c89ebd83493e31ef4d5ae5022eaca94c4b8e35e2f37e9459cf3f7ebbd7d5f1579c6f6cce63e0172e55024d4850800c10f85db9c01af11f4521995beb1419eb9ec5d4a94d91935c94d5967d602a49357caf24e27e5709a23300bb993b726ca9441b6c2328c93521b2d9970ba749460f5611622640ebe1a0b55baee1e88e41c9316fe80b45475c9aef4f421e9611f480e8e1b7c60a5d012ed83f9b8a30c6fbe5c926f9c1c580b83c9a1592df7e9ede2bdfea320e9c4d4bd3116a948f6220e7864098088a0fba3195938d253058edd1b9a26b458074e1c3c031ac67b03d537a7d8f6aba24152a352ddb9858c38a8bf1acda7db13bc0b5eae71b4c17104475f3323f640527aa36dbe73cb1f65bb3932c3e78e49a9daac380dff9cffd2af45fc27771c083781166f80e5f715f99be8da96840ba5086f8700af129174e1bc88cd149487759690a8eb85390963eaad493b2329f4190799e5ee2d4cf2eb83dee1efaa972eec0ab0319ffdb5cd8cde51bb7bb027d0f55e5118ac7dfb3ec42cbfa7fb5913a2d505052360aaaff29fee4b9f31d7f51cc5333ab5d890dd2508bc5dfdb6585b07e124cde39d52807531847dd7d0c0b58ad5450cb7c22cabc596724ace6d440e88c44e9db0aa18c007d1e70e075f79c6444a7bf53ec63626b93b45800f2bfec595ba7f7df0b669da89b7be7f9bb57197f440fdff479d268b0d246fd9b2078188ec7e840f114397019a5e29881af31414e29ef3f135dd27e70c3699df4ce1b8bf1b2420444c8fe775ac37b5f72aa61f6a6b8cdca7c4c1919c0e6669a26af313b99f0afc9eb5ef14563a039abfc13680c2202112029205fa4844aa1e0a4ca7bdd1eada1bbf8c278728810d8c5720225d76af92f93f3bcf9310ffb73eb9923e54bb2d0d3be26f7d6d608b018bc43b1fdef0eb1e6ed52bb0e85b65e46cb093c96a3fe137e31cf28ed7dccdccc50b4e8adf43222390392f108df631ecb1a70d13bbd31728e0b2d8cb2e8cf5b8e1d0c4f7c4c4406b044f2ebb1fe3f252ca4b1dd3e57bdd415a4b4ae996059c9652955b3ac40e90413de613c2f7bbaf5e0f46872807419db4774ce89dcf71e411cc12f387aa813f8cd3b2e52efa64d500ab4b0c7bba7bc6f24adaf21b03fde978f6472e8f3c6b0771558c7c54bdcffd822e609c5e0c156024d5443e8bf7e4efcc257c792d1262c23b669ee2914815d76f49d521ef44a1f1a17ed00b2d9151a03c5ab3ea87b4b42783d82b9d34bf7751c176afa4dafb3d5653e7d5a03ee0840def1cf32dd52b08ab9b960098981e9d8635f1398c85fbe0f270d453b98a5d0ac40c4c05f7e7f70fb7265eb68274d5ee8d1c6c5cec33ac992bfb3b232c56245fb7c678eb56fa0145252ba06469f11a5b428797a636410148872d262114778f3efe835ecc4682c5d2b4350ae663e78fd21d2d45fa2b860aa5a20bb072945f8ead836c8c7c747deacac39008fa01de9acbf071b0dd2b0bc2f5f06d4277a5431201dc388d0603e41b420f4d43d1ffbb3561c541b31c126e9fd3615da9616fd0211ed911ca0f04cff4e43d5b67455e79d941385685e79846719a4feb55d6aed72ae3905d646696f9ec80a31fe97ca3754ae2861468dc5d91aaaf277ca437fa5df32b050bd2e7763251e72c5cde6f8542ad0b458c20f5a9c8990d36498a06f3f8cfc473342a57b84c5fd588815fb2459f1acae25fcb8d840b0979974c70bc68450bf6e184ccd3d809e6b6a07cf2a2446c6bafa055f0ffe5729f702571c6fe582d6714eaecb90dac3b9ffe856e40d905a6705903b1ec0e1f83123fa14b6bda9ae9a660726fd14f57597ca30ac96466ccb1002febabacaf6e7e7fdb457b68c70f81a1e92234326508bab04d275e7d319fe2bd642c84ab9b4e2db4c42decdff268aae54f865f00d7454724e652e5644908e5cf7af4da61846fe70819e347190a1a7c9743a7dc6a867caf08437969c697ef807ae9c0031432326abaa864231e058899aa5bdee3706258ace4bf5e594d98370723f7b93d76060e6994c9b0eae222c9344ba2553bbbbeb42dc9f254a4da95df97b3d6a17bcdcf7645bb7f1270880fb6843fbdb2f92a5943799d567767222abb4920f541a1bb6ebc4cfeb534f91ea563f5f15893615fc22c66cdb323c1e8fc9b8aa1b9a3cb9a735712dbb87c6c8f8a9f857527cc1f3d032bd64edf27000f41a3b9e9e0eccbb95f619a823d203161561f5ed1ff39575d771a20a055ee922e9982eccbaa1e56f8855436d6e20dacdd6ec11a948bac469f57b492789b9dda3b06f6ab64789a50a526d8e1bf5fc3217a35d9c9c1540bc071d0f5cc3f0fb9830c7c45dd7daff60661cd772bb8b5c0a02008b1549688eade5d42de487af56cc60730d07d1793195c8d080812dffc44c888e09dcc0cbd355e5bde93d1f8d32c5b66ee049efa62d5f8e111b85329e47a3616907c89b10b5196fbb7fb7e950eaa8f529a17f3f1967e9109f4bfb0bc364d915aaf305bc95ec264a5eca9a7aae1086777ea69298e65d0876a2de34158464bf43fdebe4be4e6d68136be50796e87f430af528ad67d7c410dad26a502d9640ca7b61d86529d04de0daab0cbcb5e5298c1f35821c08045277f92ab2df82bf13161cb72fb6749f9718f16ccf79728d3251666270ee90b0c724c743170eb83dceec922abdbe746686aaf440d54452ab947def51c3c485dcc6aecf070fdf350820acc9b84d320026191021a89098f927ed4f1e3dae2360c5e06e9b2f75d5eaa9462265aabd4d31b15abe2ba50e5dd922c6fa28b1dd96f9899161197c5378ae76f5ac18135d387dc6cf86f85b67f9eec7b767c5567dd6e47d27db208af304707bd05c9e0a15a1669059a305a51549ccb083dea08490b350c7fbac512b4a7d9b9a777f469b42a96e2044e3869aeccb72168be8b634400b57f2180c6a832653320da0b47780dd0606de184fb776fcf9dbd96052bef0958fb5a0b6b41bd9b21765a877f988abae192ca0df18a2b940fa5b1f06f160aa2b9ed5ce5644f14b575c01a1c70917b3869715b708fdc184ca119f1e140070792a2957d4ae699a191d59823e9d4bcf040869e18b452609fd0ed6dd809472d15f4f746138409acf60ed4b76a07e0e793f92eec383ff167296b0d4c2fbfbad355107121ac041b9c6e64952abd670bfad91212fe60ca388b12fa18d5b3bfb24f7598a9ecf3e3473a551c61d0fcd59fbd82e726a293d68302f617dc62ec28e60059d12e99e2463265885a0b72ce82e4332c5bdc957c7cb5b615c4cc1167f135f03c809a991d8d0c09a8b6b027ee5c4664cdae9e8d1a23bd144a2c6d03e2f25920c9151be9689ac7f662dcab4380551adb161a0b755a0e5c9fe315d580b7459d3a4bccccecdb59c672a25920e8f700f806980a819b18260dd601e23039967a89baedfbde9cbab4e8041c27503e5585c09df0eed2c22b0711f2b09114308cb85ca4079838d6b20006d6475a794ba01930c1e319a1ed02291c761ce499f80713328b87a7dfe74a814c1ed531a7f3477036b78636041fd8c27021cc0a5e06540d9480978c54d20764a49794e10d28803ec886f5990162873404413c5860bc5b39020068d16d666052b56e8e18d9d8f07cede27546b3f94271daad4b3051d66b409e8e4ca6b087d87281a183ea075dcdb7225a666e0c4231eec99a9cb927f6e4293c66d0ca145c60a5238531f3a0c98831fc79f3f96cec4b4e6f63dfca2dda778106a2f177721b6d159e26fee30e32e05fa553ee2ab280066816c5971c882b20fd5b36de0674026f01ea64f525a0a0dda5938795b4455dd4ee31c487d776dda8711acaee06bda187d751d89fec63219c21641897bc9aea3aaf43d73535cbdc9b5ee50404351328d6c8756ff297b62109b1711c76f597078b3f831674ef14942eb6a9cb17c8e0eed218bf46aeab7c6dc572233e2c904c3c352fc8106b5a7fa1b4c4ba515d54e12c7e31cd979d59394ff376a228482247c8431c42f2324ff212cd640d8978fc57c0b59442afa843ee145131b54d33aeb5ac7664e0335715757ab9424d4eae206538050bf6c486d5dcac3790b414a205df73aec80bb161457e158fd370c6a04582ab8b666caa82c013cab5f09e0042b9231f56d406abb0ae8573f374054180020d720d0653603b21dbc0a1d762ca1af03a313e3860f781056ac1179f48d82221a40f63b6fb4f67a999ec8615115d17cc52dc1ceb1a891533c75e450c8cf93c1cfb3689920482e9777f3d4ec15de7580fd5076e4d8bff95357a052c60dc045ad956b797a5fd8f0f93057a2572a464daca2ce3bfb7c8255886991219a3c04d735aaca90bfa5de62e86f9f866bb2a03e4ef8acec0eb795e04e2fa493154deb203df29a292d37eb6d47bb83ab8cbfe23d7ea068b82f811ddd5189883af6ba94750393fa9339c873641cdd8cd6f14f2a775b8f692893483adc20eff2b128482b0014821889221394a8ff3c3ece9e7ea786a605bb928534a7ff3ea2677a17c0a11418cdc96ba8206346420f63a334d1deaed5305b07443a986cec99a9a3c85de413b55f339a7fb90a6de4ab88badb592cf56bf4094c5c3c4432a5cb7ba0704711998ad021c1b06ffa5a9a1c413b569b50273e7a58dad120636accf6ccc421fce9818907cfc5377831df67c8e1fb2b357221bbb770e4f3da4afe6663ee9873f98f968a0909c5a739d86501d50d744226e12417cffa5680627450afe67fce31d7e4023712cc376b97fdcc0f1790e415697752549a884b1db537c627c4ab13e3894fffddba6b5a021b7ed10ec7fc5e3cf88eeb9fca24369b879fa1115e3505927d9e47cd9118c7e633561861ab14b3707454d00fe609a98461bc3410186a898469c4a2eedc3b807ac5a5839d031a57442bfe70f186008625d54caeced239b9abc0590f4dd5fae6347c6ea61413cafa4ddd7a1dbf6c73004099c23106bbd1655d7c901e8d1dc06b42621a38a159599c9c97b1da73e4099788d442976c0f2d5bf1973ed55e34b7a458630b0aed3c3a94e94e1117d9dbe05a9051abecae73b8511232d5890dae24588b8045afd2ac0349a1bc0ae01e374a6e9f6b6850bc818c4d44d9c98602ddf695f7caf59ae2665bbe1c989f8e4fde644d9a2737e26307e94d41444555a4727277b0ec335a36ad8a03ff7e138d32805f0429e771d33cf48b6273fdd0c65fefccb8414816999dabd9672180a9db0773120992c1f82e5efdbdddbaa8f36112f0b17411d6304fb89b8aba7161b14738f7ae3b12f81e094a3b888c4e5bd13be633a538f6760a8e98bae9092043a72858ce18f4a642372b56861036051dc095b3a56c5accf3ce88092263d48ce4be51878789fd5e150455d64570657695d0f944871a56859ab266743e6d1f68c8b797eb146345ca63a749b15419a66a24aa0a006fb604b027e68168c818998d2acb27d6b746d22916441482574dadab7c0d208f117dc4630b90ab62da7c35b60765f800993641d466e0f78d51e31e91944f6817f250b4bddfc38efd4cf3a1591e1a0b2968e9413094de4a7afd66f7b118f63010101f4c3bc4531248bd5f577b4694d052054d85a2a5608fb82fd05470220a9f64a3d0038f6a2a5f298851a80bd09654c2e1e9699b165dac90290473398b6e85e1ddfe9503288d9344410c66e20a8e61460708243ad18238e3d00689a749e65ba12f994b382d0aaf972e7e51fea1cdd404bb7d78d8e7e618aeb31efb754b56239a3079a06c31c38b4467adc8a32673614b701eab869a0f55f633e8c08c7bf888f423fb4875cb053dd33285bd0f697cd8dd29af4e4043c33693296d561bb95bc92a0c31a4dfc1c471786ef347ac7c81b3dd9fdb47d30e6d6a9327777dcb94389fd84aebaaaab92abe5d050e3c2297c795404caedcb6ef95d9bdf52b9ef216d8efb13801c9e2b7a9ceba9c16d9ed21927fff5f0ee6b0abefc5eafe41f096975b936ae3c16c0538ddd443e83f63141514643f65a6ef94b848984b03bd7c774b89f32b7c40d1eacc1e971bb240896bbe0cbea74f0febb383245b1f9b26047f0af6a11750f57fc8e8b46cdb892ea925c7b84b87a55faeebddd5890ae557aac7e12cb76066420c35deba38a19ef5787dcd0e605696012e73c34cc7cc1b967666905825235aa314e3b0ef9b0cddb366064abb7c4eb78ee84eb72f3111d0f7c2e5a8515f4749991d3846949da35b4e0c98cdf258f028be65904fa98c17efcde6e69e87fd1777a022c9cd2f61277c5fb02ae07cd0f8fadf5b7209c8e0b5cf6e2f101043ec4f5ab82d3a727f736054e7242baed5884fa7d9e0e09f017547d084cc1c8dcca057a91168e008681bbdeaff38f7450c847691e67e536c5866c295e64b2e9d7e6fb8d1e3915ebe8891ce353b368fa125d864da76553e54ca5a544b6899ecdcde336ea110a2b8a9aebca29b7cb815ca8611292b96b7f0afdb92230074c7505b3c16bbc0ae704d318fc35a8660a323ad1fa68cd79b54d8ee58aac4c0cf7d5435e607996af2cc5b669b30c2a4b1409208d9806a303e6b0540cca72c4f846ea1a422934f4f7e77505c87b20aa74cd1babd4a38ad434fc75f7a79fde790ce8e363ec4e3939314dbaa76ffc4db4d67d1a3453c16d78058eec458596e7e6de7ed5bee72eafbdc05a7622bebbc51293b5093617cd50d2c6b233c7b97e28749d5e9dccf601d17073da86dc0d58248da78b26de277e477557d18d056cad054b49d646c50a0364026877c7e5d0091aa8fd21146561a7625c4d079fa3b80fba37863e2a7c5cae0bede1654e98aa9ff832561b75d6235eee0209cfaa1823cebf46ea339de172954b7752b24d8c82ece37d4e61d69fa3aa610fa1e9fb50eed2e3d2e2a536549231ae5f901cbef6faf4f806a3785d66c33ace194510a8ead1153399a8caa9cceb9c1a18f3838f291180687cb587abb7ae9a5c192c2bb237ea904eda8c1830a2eb474db321b95b863ac267be25901b5c53c21a00a70e5b6961e3175fbf68d4b4b4a0234de908411845fbd60c40f5e667eb68ce40ff9609fc9dc93feba168369a27c3fca15478ab875bdcde86ca8089b7ceeed5eda446e47a049287c0ded524ea60bec5ed15571bf4e8edc50a7bba71e7a42b7b4c4004615d6234556ed6a97c29d418e1d88a8e7647228e4f8ff0e36fc9ae42a91776e3489bca1fd8fac65f6dc6ad76fdafbd53dc25a8455eeb54a341fc5b20376762294cae47d3fd03007c5ca514ceabbad3db80cb3aa5b2145d0a53dce006f24c15ac35f0e8c75667dffb987f6ed372958b30b386d4daeb1675fc381a70e502674469e0e059722733d757f6e2ef543917f052c94c6d3741a7367b2aaf2bb7c3b6d44fbc15e2c27b7afc7d5f847e86c0d20712e7af1c096d99e74d4efc2d479f9354febc413819c58607d2c15f1bb41d9d222a9035cfbd6423e86a6cc5f20e6f35747611b99e298dc0313c0b2ece71152d796229265822a3f1b1dea215a5dc79df8525a8c056cfd99e183f79debf866fd3aa9c894ef08c20964c15321081e939a1fa83288ad694b7b0680a39d27c9e7ac6f0b536095fcec5f96adc019170997dd47501aadcbb3d6aa2633556ce3b8d91ef1ec55806dcba1b584f85a15eeda4852a80f7111ed886054387320ac6f060d8cefb9ae5ea1f07bae69669554329097dd8c6e215099d0bc17768caa60c37dd4fc8a1ab4035b4e158603ca3433ed26d2862bbab9ce1606c5f8730f1a4ed8d19d25c76a26c957e058f11de54e4d3d493d7786151aebd25c12098325fadd62639d944218263f64ee989f008bbc993f74067de59d2a2eaa8eb16ba255ab141f4b2419a6524753ee0363665f7018bf73429689bfc7d630e86ea464499a0c270a5f09db5f49890bddf17b3220aba573c17cddd9c72e4333c0a14dd136ad10cab4b79130a29d4eabbe7fcbcd8f73c2f4e7b22733858b874b0aa9bce8aed2039c5088085776ffd324341d38c8c469dfdd9065e492184cda6af6036fd904dfd895a2056e28e35b083099ac630703c41a4cb212768fe3e53f3accdb69d3d56efa9d4849d3a973df81f7fcd35e9121d54c3ac980f12be14a59b49a67348e96cc31e2d81eeb07a2b8d1d3a0bd39329b676bb931359788184c6ac22faab48e68cc2d5e76141eebd219204660ea25c00c3dd1d55f659ca93645753942250c710d56561290b69073533babda376096218c74e1bc0069ff686e29eb5d8116999120a63784f79e6098328e85f67bc0046a9b23262d79f358102f0f38230babbee010612335a892754ce6674f95c4154e5bb446f35cdc1a16e5b1861bf5d81c9841d22d96d428607297e4cb1649f09299f92ba53c3706d1ee22721243ab281978e76fbdc72b29501fe47351b50d108b09d9789ea46b8f91ca5874e5201e204dac59806efbd6501f0d43556ed5e8f97ba8320dce5d0d7a580f8b2df99e5500ea38c844d533d6d793cf2564a85858c86b920a5af6637319b0683bcca55babc95f04e70b620e765f975197f4eb6d18907f23ae9179bfe4148e8c99255168126cf9b0b8ec53ec558118a336c8053d6a47c24ccea3902b31243308bbcc37710ad2977acc744ea66bbc844396d8f132910313c277c8d746a72d64d6ab6b4a3a02284397bfa42e13ffb510e0a77ab64233905437bbed869e7a4d1235d1762d62ff10bc8200eab743f75f7245d9151d113ff599b3b0c82c324aa9863e26f52d901a6f01cc66d79af4e047f4d80ccdc1b5f4f06cf50e85028f4020ffabd9ce4e3b670997e87b0a12dfe8d3ff35636d8e1327f13d5e16b9fa8d7c571206f532e45c3f9d28e12cc49a52c4623085ac02a24097711f2d7f07ee16b7ee5321a17b44cc8001242071e240869ffb93f27908618016a398b910221c85dd1d59376cbcc39a58716130eba34c1fba09051691ab92ddc0f7b353f05e5699bf29341b240213e7c6a8b10d57258ae14074ef4dd0624fac208933244f24c7465319f0a93233d734588167b8a3021ed005ca0eb966ad9a626bfde743d6142861bd6dcb13305a39f9a5dc97b980ee69cb91267afbed327e7a62e694eb8dd68df95462db3308e7098dda4a18fbef31711ca28214c5bf0e3c94a58f0a342c83d449ce23b8fa7ef32ecf30d4e466ddd300ed7334d80aee145add99ffa9d5dd4ccef0841c25547fb5eb7b20145ebbc7360110ad0bfb3ab11d558bcbefceb8e9e96619835522e343c6a62433b85a8bdd92d8005662cbad53a9f77b00f59df38c0d5ecf278c03e0677e5084ed65c7b7471ef5e38de83a592932652a0f2b12a7ccd7b41aeeec6bd1ebbde3eefd3ddb9fc76d872435eba585d8c2442058b23cd3608bd5693aff8582efc33cb4885a7d0e1959fd374b0470f6eb5b9b17c5f9cc76a770a62e6da2b5118ee220e4d95629f362b5cfea0bfef276e47b43c658ccc559201c9b22411c77bb4a2fac7aa2dce3ef73c773a515e63509dd863eb077b95763c4ab087dedce358126783c2664138a63b383b4f4de0dc907ab8284c3008b4eb0eb3599c76808febadb860a1bddfe787449a33dba1c4f54a672909847a437312a5cb5f292f50dab89dc068f2c7cd45f39d4cf42cb4b4ddff01bf1dd954e8f104d5e785f8a146924dcd0fc76b7a4ccfa071a294c3da35cb00e4626d7ded38f3c48ab7947bb6106133f1c6188cefdc9b76c23db3c1c6268897f8c93339fe3f2d13242cdc74f723492addd1eaa63f3cad965db9b82bab153a6970b1b6c76dc71a2b7cbc85735b1fa648ade0422d4042c79928dc809e3972992cfe218d3dfa5cf018615b83ab9c5f20a1de5a34e8bff40636a84a349bfa18ce54ed262f0cdaa4863ba3b732ced112e7c3c9aca29645f0fca0d861a52fe5c36bd114b347b4cb01d42062eedcad418742e0aae1cf00f3e21a8a94c5a8ca2aff395c032484029b7792f33a22bcc44f04ced0f6643dae41ec5f549d13e8dafdc3b12f0ce7ef5fd059e3ac9059cd818c1114e3eba840336ef0a0d9ff6e6cb1470aad0665a045a2ad9e113c91d23071e1bc9400831db4711c4b98b6620228ed3bf77ed9ea0697ef68ac7e17f6b0f23eac9b9b72995c7d9c9f667ac8ee0462741cb3e4cf4306a227099d0ee023f89b2c94490a64d14f4556fa86426ee88bd408ee22d313ee036a00a4373ca9d96097ef112cf22189db82ebe7c113a6d7fa85cc3ae9b9341769ef74b3ea646e7cf60008b19696bb856b6b4f61e9215e15a9e28b852cf13b2f81230972e7af78ec9d86babdf4e3daf8b661c4e1c449420683f40eb4128d4707e14b8eb653262a7361a659566c8e51385b56ba71f642bd4289c30e2d5bd515e39883478cf5b18fbf4581bf8cbac989643a0afe3211559ec6947091fdc20671f8a3e56cdf4742e2d6cc2a7cfcdcd28848f81040d85ff669fbe64c3665ead4c59ccaeaf3beea0f6dde43af19cb85a5c32896f54812d4ad1fb6baf217a6ccc720de553f391678e8fa16a707e20a38d54e66bf261cb9f72aa4f8886f18357f5795a64f1bbfed709a3f71cee7164bf6cbfbf29bb6d9b083cf7eefb70ff404a27ee3c63f69a8a98ef37fcc264d3666d6ac70834525c4b6d9f94d22a8252544784b676dcf7fe64792aa29b0b48da52a5c44b6395880bc463d3ab5cd17c68f5d97d5bf70f2cb22645ab479cef8501cfb2f9e81fdf67dfc14b8349087d0a5ae58257852384e82c98a7e158f9fc41485a5c63107b007e31cf659a2262406b65eb0fd4fbdb435994210c5792e815198d07000515996f8c65045a248249498c05e46fd4025313ae17aff788eac5a3c2dd4fe3fc4c19173a23ac2d65fe479e521103432c00818702dfebcea4e173f93149ee70148aa80a52554a44df3f03529bb57f89c3c4454e55209b3b160d4e5e68e6133655c5b115deb6cdd18466681c5d14751e11e23c38958293b5d3e492075de75b109c9b4c7e67e695839c1b613ef433a33704dbf02df54387e073ec5bf8aa71bad98d649d4d3edc610621a9c94207c3a36885073db878146323de86bfc8faf6000cda1c64b61d53a4a707f03d2672eed3f8294bf8b039675724db80e7e6787250bff4ed91df4987d191fe1dfb5c35331b3fa080f43854b4554852ff472188fe2f0d3c61996a8bd773440d8bc67da1b3a166368652af7424a24521478866e80854f3598d439bf655f2aa80232eb7eecce6db92208a3f1663d10a1c1982db07b32482b84346d9b29fbaff1c1f0c5f8b1b3455a6c84f020078daa5e228ac18916d2e1ac39ed5c5fc1219ca881cb3ea5eaece1f49021c53dcd68ac384897f6c9cf2d50d180b79a9f0855ea0aa323afd29b6eb8f4153f627d6ac3d1210e7be946071c6917b6eb05202360d58cccd128a32ac59f6196b3fb7b3457e11bf02076dbc2173d78f8223d43754d3d84bae57eb63975430a40bd1a4afa29d8c54177a187c236460cec6cfe1c1a4bb6a01c6d75e88777ef9c3a7027f8283ecc4dd530bdf5ed51d81084979b702501bb1ca99b9194dc305c7dd7b7544f0440209f9642fd2b7a4bc521caf9c1e3865c04b7fc908c2395a3e5b56ac1deedc3739af068761a014b2ca0729b58e7191d05d52218339b3fcbfabbb37e4bc83115604bf87184fa5a14e55c723b6c6d74ff98c14f6954489ef6e45e9d5ed5515f66b7a292c048e4a6ce891ac49fb857d1d4063add7ce9d179023fe7720662f8a1b171643b86eaa980deb3f946e6534e24b5e6e154007257a663a1038a5406f0ebfa81ae8d67d682abfb34f57e8fd67826c4eeb32c38b643d1101377e06a114ed32623a8459811c4eb64de44f09178b262640df258bff50a73371c67b487817d53613eb76831a2c8461a5ffbc27fbc22902c6d880ddb590fa71e5315679de9f18d1e61306c08f3e743a511d12429ed709e7e1070341fb672e72b26392ea864f4a283ede28c430fb1b5857ae799a62c63275e867e4e686e34c4f1ae143bd7cd0cfb7c7d0771577168b5e0a0b70578d7ac3b77881ee338d0ee0c17cd30e72c75abd6da75d695b0e8e09c9e1da4769f6ca16f1dc658b55238cfb5a561d733791f47e991871a5a16298fdf6d696c76a0cdb0928e41bfaa3d6f879e0913cd561d4e2e688283227b4173c44f0317d90c4bcfcbd0a48b4ebb36b8e9a59958b75e03437f6fb7d9a52f43eba34a0b54f3b2113a67274abeac35acef37dfab8858d72ab0f58ccd8b282c737af141f6c0e88aa11afde1212b2bb8d04979c448bc9776e29e5828f9ae6ab1d38810fdac9bdb55045f07666781243b7cdc649154c7a5920db3955a06481d9f4694e0af2f7d2b1f067cf54f2259401670fc70f2c2ec7014f60c2e09ef9d0fd45d39145a7acc01da21c10f38bbf80de119a044786f490225e36c45232d685c0627a478c7d8460984a409eb141d709d252ffd455d3d3282005bebd34b18ee33937a3ca56c9da192ba68f5148df68773868cf352b7c305ad92b3f36ea6fe1f1a17d4d2dfe27b138536dc8410f767037db971f386e4f99d523a8997b02983b285078ea63b8e32a0e6df9d6d16e98dacd5ef32d202804ac2b00b24b6d98d34ce96de162d9775cfa5499983e7ae5b978bc795d3f318bdc32c36e8c17f036704eaf6a62437149c31f00877192dce8197fddc6feecfc9d6c012a9e435d3620c11ba3360cef1e30a9346da1089cfe7224ca904d0f26922a678c99f5f6e5c1d9e293f2788c7d5ed5614422080c010d65c32887652b2d4deb2c4482c2dc491c74af8c534338432a81e500d8","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
