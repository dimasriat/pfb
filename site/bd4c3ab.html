<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f6613a2f19104ddfa8223e7fc934eba3c40766ce9338ef04283662b6d539dbac42bfcb34223a9c803e7a3fde282424eeadacb3adaad9f79677083daefd5b036c75b3ce1254e094a78add0553455ae1496cdce2e6da7b2303526c4aae6a10cba5675b7e747b3625b7c281adbbbc3622b3a43ad7e29413906c54b94a94a36d036c2e092e95e348096b440565e017b415ae8ad011e52d5670d349990285f8e000bff09f8eb5a7bf9989b715913b1c85c793bd2c8dbfddbb5929bb17cb65492d7cde3340e60d9a45ba461c34c25fccea9979072b6ef69465c39899d962f514e6f1d08f78ecdf93c6e5b7c2ca8b3d711db412aa759e8648264f15dfc5a58cd35ac18289c33eab6a1bad9c68bf8e13d363488c4d018bba4a1c437e7cd347c286bb053788143f6eceaa33091d81d47446416a22ce446cc355ce5570ec82cce39523c1fae3a309a57973a8fdd70f79fa57fd72f90ab7972a7bb3fb6b447a64e09bf6b8371defb3260c2c9cd2bcf6def4d6db870503b75f74ddc7f7a2da6a0e3eb7c6d7739c87b1ef03c30d5bd2abc30ada543de11cd5de3b166dd8c73d1513ea651378423e10538526a4c9e1b53683762f8b72b224b0fa84542165509144faaa1b59a1558e2c0b094f47418d11888d2d751a5bad573b5a720497ecdeebd75af244839f60cd80eadc78217981944a2384d4fc2fd61d3015928aa42f589ee5313ff215dc3286f37ea4b7576c9e87f595a7e6444a214d71074ccd372eb6fa6aedab43fd6ac7382335d05b6ae1e908e9ff4eaaa316c58a2890e1ea17bff036028fe16b2ccefb4255890f2fca639699f4573d147c0e821b7e9d43e801ff654e78cade147b324838f4622160ef31fc8d3170c72c6a23c69246c23ce890707a647b40765a22771f060df6abc7d21a621dba85a0d317ef054a22c1ede965fdc70e088f8cf7b4a4fbd26aec177fe3b836c0e8f8338b63ff778050c0f2f132490d0dea2f77acb6698935f77c58bad7bff7348f1a2e1b8c0f673d954ecab3408123909ff194779ba19eca4667f6cd65126d875d4673dd087f84e267f85b1132cb0902bfd608f26d781e58b2c669f987fd07c2315cad0c834634434d231ea1b8451fd3f4fc81a3b22d2d90a41cfecfc6c2713757c97e49057f726007359a46e464ff7b7afd1a74425a22926cb97da6d9da7182a90db4400af09d00d23be3ebd5b64b69e15af91b37467557d3540f92526145e296b26007d0d6ab76b7e7a18fcfc7e3622a4e3bcfe8bf5c8999e7502dba3b7cd1c62ce9f980967854ab9ffa91eba32dd88b89546fea9c612fb977b741934169f635475097ed3401542bd6372c3d2e2c5632c17fb69c0cff17b2e715ea109605751299adad3c61a261740b221f35ecce7e72d52bebdbe6aeb25f3ca3a3c429b05c31c19cf2c880d30e48f65860ba7b3af02218701dcb3e331a5a9e523a48a9c40569a95f2de120f990ba79f568505a1835d8da60a4ceb4da002c3226e5964781aba854c6b9064fe716f3836ef8ff305ed5490f8040a190ed40cd897c40e8b7cd18c8d01cd12f758e2fa20151114f7c4fdf96d2b8614a019819a2bdfef1e1bcad7b96bb18f7dfb5cfccde61b3df1b92f4b9fa43f9f26404c272933c3a08f2cebbe2c5f49d2a4ffb3409d13a5f1df24b081aa45857f76a33f695c0938904986e68c9e2ce92d5df3c82983050f564dee5cc2dcea859acb36a0f5d1ae220adf72bd6a3b8d3fb701287766f36c685b827aa8f35563598c5aaef2476d6d0c8db6066a0c89210f97839e1d7deb3ef928fdd092fa6cd23402908c31777a7883d13dcb55757d79254fa9fac67a4c89201440dd672fd35f6fa3cd0998916166e11219cf480152c4ec3c50f54dba7ea98d16b9bbbe3dc49ea510defcef29c375412956886a671ed5b5cbd032e1e87305cdc9df5932f87e9175dd2104606ec80d8cc7b29b0730172f222b2d6a0e78cdd44519583efd928341cfacafd727b63f66acad3d9ef1f00347f748c1246341b8f403f3de59c511363f3571b43884325b90889b334d944146ce7487058cad31f77fe677c246e542816906262e71813c6b51086c90ab66739f4541299a2579752c3bcde174ea8a342b88c3d9ca920071a8c42c238137e154b1b99becebaf9d288183b0f4078dded70ae30a290ce6dbad408adca477ec46979cecd4fcb514cc09d277bf1482721b7ec5500c32ae386b4dd082d7867813f1c9d31bc3b748fa5c458e35651b96d94273e8d20756be940cd0c2356aac7245ac61b27aa11432a64fcd9559351fecc6273e689541c0e88c0027af1f4680ee4e9bbd2e62142b19c2e3b5bc08a8db2e1b55820dbcbdcddfbd1a90a9872a91d5733ca21dd9b2fb6dc24c2a17790ca3af90cb290fa61a0b358e2d65ff19b51d58f0086d3f8e11812a02e1d5e74c13f680c1f0821dde91f70883688a8254db95dd95dcac0e8065916ab9813a9525371c7de7b39a307ea679efd62c98a2d0e01b21718158a96609def11700ee495d4112329d652bc34b3abf708b4edbf6442719f331d63e4f2e86f1bb250e951abd99ddeb44d550c6f2c9bc9a30a8db5e671e7fcd2d4f68ccef5370a08f8008bdc8f64f03a9ef7bb4b80e904e818a4b6e79f5b33d7919d2a9601442133d8acc4aea410e1d37341e5bc35ff0e32513ab3605f84911c43058d69a4a6853a386fdc244626a62ea5c5764124853ecc794c0438cfd30db9183721b166e547c1c6ae1caf01753ec4500f90ffb051760f57c55b9ce67590ec871586263ef8ac0b3ad7d30ccd7e96f185d954055fa1e460071f33bc0a3ae97725933f32cbd094b0212b1c1e7e6a72c947177343c6ac0249162a61149ed93c0582b8d419a9e8715149263f8bb59e29908344b96a5ca5068c6bb6dd59d7108bfd2e8a1d4cb041a7b5cf9ebe377da9cbdb8cd180e0e09200195c209d5ee0e456c99633cd4c5db428952bc8f7dd01a285ad4173d9c76f70cec6d40d21638b2741b401999ea845b44654501fa303c7a12fa8dea5d628126253a281e3925cbd3c63ea59c827d3af103e441f7d34bc2896ae1c170265d988f4e55755f6263dfa57edae4862936d9c96ab1b1a1605371835dde417e2972ec9cc87c8fe879e05187bba84f9812e10e88941a5c416fede83fcf4adbcb92503f7a8a446b4f3368ed2692138ac36608004eb5fd61fa2ac40f350c45c8c72e3dbb598a8ee94058d05af02d752dd14a20e135fce73a9b68b64c501a364dcd682696ef6c73ad406853484e78797dc993b21e75aeebf47f2b837ab4618d3922043e0c2a3e5f09036f294b583d147a7b432a01108cdf9b9ae367e68eebd9339587293b44cf1e96d1c1b88a486361598c947820512e1e5b61db2f39fd457fa19f01d15c6e0aa8dee72f90736cd623b5489ef90027d0fb10a83a0e7039030506dc9005b283c7e9b601a611f119561fa1e30acb9060a248a123504a40fb7e8ed162b697ff03d1d825fe703d1545ab9ff23c1f5f55c3ae58a0f89c208640c5c66915aa58cc1c0acc0588715499cce21785bcddec7402fee2ddbf01a855d9e45c0ad8c2437df228b23320c88f863d5f005fc88e2d41b5d687e3888e44d8c2b349efa19ee86f935b2e97634ae9a79f06dcc59a0f1f9ba0522b080cce75bd32a1b6ad509ecca41582be570119c71ec81d7fa83881997ac5416e84b2791da53583e9d204c8a600d75d12e73eedf302ae7cf16c16ef8e5633be8eccee421c8789213dbc66ce0cc075306ce98336823ef513fc394684342a9d4f3ce14906a2842324e3ad906f9537a84f34a0c20c43f2ce3ce8f7163c6326ade0ba1437d0804ab9b88ba9f0a843cabbba5718cead40fc79c28a2771e6ecd9a68328928cd45ae958a4d89a841b94249925750bab142db9e5e48b5c6027acc4d585792ae5de682b50966027d8e3becad5687b7a8bbe5d23763c46a14eb5accc37870e47c2a9025ea8c3d3e2b0a0c05bd6030ca07df9f9fba4beadb585559d36c9cd43e2855220bf8e7f4f8314285cf705f2c3d37b607e74fb9a114853133284f304379b1ac79ccac5fa04c4fdbc96210235007e262066d093ab97026d43c9df78223b319638c4a4ab5acffa4dfb6cd2b981dbed6b0822b41d594c2860a2a3c79bd647412d4238586f279afbde7fbb4e11dc8833395901ba4e588cc3f6358bf386dbac7685b878ef00144234b077b5363f13bace10cc75ccebfc812d700f5b40f1534c49806cdb82c3e3c0523e4c6fbac2b7df0acf94a95b6b99d1f33d884e7aa1a78f06b63042fa195cbeb5de1ad612d67f4444950c112dd5702cb68ca55531442ea67c57892f8a249127bdef2feb354657cb63486e5821fa9a66fd55ce34268d6ff1e8e5567a21b4628a925e55d36f48257cd02da9f50d5d83106d4483bfb4b6e93064dc1ce8cc554c6ad34d408938277ec46fc72583e8c0fcb4828c317427ceea7b038e9789023a1ab33252361da58dfa8721a65ec39cd4a9dbcb2d0cc4b396e31900767932240e6d0a59e8b135b7a66a9e1e406e84a90f2a141bde3efc5d4172c55b07ab7d47623b1df55abd8dbb3419f1a72bfcf2e680177cd30ef7aeca279940930ce74d0f046fc869733d9f0a56e408250bb50595dafeb1d9ae5d1fb38fab0ba754cab92cf6749267c4c90984e5e130b9fc8efe4f49754f23883a7e481abbce66724853c34aa2aabffaa461f551c56f5c072f67911f61e88ea3c658223fcd90176311277e404e63eb5214c264e49a1d31881a4a665199f6d4a6f10069198fcb1b6092f1599888d701ee414dac18891f4a425d3112bbac837d0ea02e37eb99f36b3e2941dabdd21f57870a780242ee23fd990fd5904fec2d52ae50f3566a69314a90dc85c38b6147ad9596b1aa75d6101d924c1c880ef01cca22687b90c60c407b46c639bce32995306fe33a13b6d5b97d1e8191e4d61d55ea4625481880c28f520f1e0ed2cbdb696fb97b89372d39cc11fa31686e00a23d17e36d5b7b9dad76eb558979a7f5fa4112d1d7d329abbefc728bde8af54fd6d7423cb377bdd043b7246b2ededf4b050a627eca85c5cfdbe65e4ec09dc0c74e530e0eb8e0a758607da7dabded46f10037ddbdd5d891c6856779cef0549aaef38bc247336e9849761b59ae8642941a2de02b56882801a654255deeecb29626d4755fabd6641f9f1c3b25c7380e2c212199353af8820eaf2893bc0feb6ee19fd365e6f76798d7df0285c5d0a286cb313e0113d58c5a0c47f8d947aa9768462708cb032146a4dd5da14e3f6c5fb343b73df5a0af03887fff343b40e2d92c4cc922272568b3421044b0d5260cbbcb2e54e405d054e300e69a0d05434bac1708afd584fed32fc4ec14e39d1de13929be4a34e8aa8c028d864ad41303aff1cc0a0767d760dc0e9e77d7adf1e023c770a82751bcbc3c47a3ebe3e99727e6a86f64836445954e3309329194fac0bd2257ab570d083cea8261365db6a6e92b03e0c0a21cfbc27ab25d26586aad66043dc06a41e8028ce14da96b946999517cb41f566843f8c5b4f4712c19d5f3bc2dd88e14b610e594f22132ec4d1c4620a8cdc572d0a14e43324992cabd7909078f8c403e5d558363b891e584d29b93c89df46543e7939427e29ef666e9008f148725a884ccb0d9bef2e3dbf047e0d78aed8f0ecbea245512ebc8c2db3d69115344361b1fe4790d72ca64bd3f53f99d702d8a69a52975f7b796f2ed63c5dd91bc499883bc60c56fe074a05e4b8891508c7fa31f51990996887201684f591d91c70efa02a366055b98f4c73081f666e9ecce4f80298f7ad36f957a1c04c905d9288f828495cbfe0a4e06a8e9bc446f8c43f567a8a287d7d6b14d33307b3ab678d39a178f5e1b32c3f6b1f328295ba3790f3ed7112a6a2c6580bd9521bbc19651df4ad8b377d5551f7c734b5c28dabb8924b3e9a758d650c5dcc5b35bf4927a931a2bd62afb609cca53d09258d13994013bf04419907bf7935639a68725927f06c27abbbcd3c1483deecf4728d63c37d4e49557bdc5c21ab7a03cf180f8e1ea2fdd297fb2d08da2f19b88e729533da6e866c886951f2041590ece3e6d120a00352c51edd21a933b11a1ed1f9e673a67f31ce5dea716816b13ec49b0d15611b7900cda42be2e07960a0996bfa8c408b9f71f6e5171c01333bfc752d2440177443b612721b9a23131bc9251f47dd2833f4033bfb5f038b4f28134a30821a38b38a50ed6bb3df0b64062b66120bdebff0264629667210ea29136d58867739237cbd2d491cb4c44a74809f0afa285550e0e3295c73eaa2a7a8c06924db6a974b50c08b58038b014d1f1ead04486f9425459a437961b336e3806d33fc2a99f1dae2220cecad87113cc7a266ac8e7afa7078f66b7d58caee143556100e87f4db0143a5370b27c918f3de582d81f9a657b0c8600ec303525fb624a037fc6c1fb45f54f68173ebb9f4e35417f1cf47594f533d996668c58f4e65d0a710288162841eb9fe012cca99719bcf3c41ef1552eb536e93922ae80eeaea4cafc2bd1752e5a9cae3c090a56ed8c8eca0a6ed05f081cdf927bb5c9b0fdf854b08aa0ec6326b5caf0c7a7516a921ba0cfbff31c5b62eb7e1a01299b5f00756d1999ce0b98c712306142e2f9579f3334878422c70c9154658dc8f7c295a2e795b796e9b37d146c28315cb03a7cd2354fd3838cc3938c32c0c0d486a22c9673c557c5d68fe7e3b115affabe5feabe4ebc09d64c26c796ad3c7999495f6ab2719fded3ac9c94b9d3cc215664270fe0b7aa4188b9445ade26a829c30747d521926f7790886afa082136d5b84df69e2c445b2a72f417f2ee74c4228cee29e44489d6177cb1b5a5287e1b1cefce8a13549b5554a8a8dad8ddd1500f60460b723fe6512a840fd665601e8bd2d1eb6dc6f98be897979a5c59193a01845eab6f5195542394b6d2d36eb4447e7e9ebdfc5344cb14d30b833901697bf27d75612d4ead11b59b5eea6a0651fe6fed688b4d845f46c8dc2a5e4d26711f5c4d689f491cc249526adc426bf6d60be0ba0d2a4172ffee4374c9660acd778ddcdd0cbb262d918414d85861aed324d423290a376ff896dfa611b05cfb9acfb07a185eabb1fbe1b7abd1641157a73baab214538da9488aef886495bb338f07c4b09e82de5e98305b7c6c688a8452444568eb948b88717963b9d20fe7e012ff456711cc4ee5757a1da6c04e28677a25fa65c6f010b81a8b0c2b124f00833256b91dde6693b6ecc3cd6d63c584e2b42d3b1ccc9389b00b99f31d475b56360e34d6e8253ae30dc22dc1abe30419737f8b3ecef3be00a8addbdae0ef63d4375cf29bfcd89f6b549967738e4a9cdaabe4782db646a34139caecdbf03c37c03042f01da793a4abd39edc65ae1cdae45d462ba6813aa63e07d2d7a443efb5f8ffe6ab6ffea4371dc80f1dc6bc454137a0ba43fbe16d09879897b05eb9c31fab9a1846ea459daa44e1970f86df0db4ae83338ecf40a233e47e01f2e3c81df7f6540a491534d89d370d1d6896e37cb4549ae82916a5b10a1b4fcb89d2a1d8afcf0e4bfbae2a453ea1eccf727e91bf721470c92b7044de7e81ebba4073663ffefc00e407a430a27c18e07e1c4f66426ca5f30ee6a180e5a45eb8b0584803f58d5d3d1b65d8c257b23adf7c698ca7e46e814f50dffa480efbfda2c4c85e3c5fff8e9d2b5ed8df32995b50c46a7a62a23abca80ae48c1047af63bc6e760d6efebc0ba59e0c2eeb4d65837317da7c1ae4d8321a303bd9bf6438e12f1e6cfb2ba38e7bf6d009617c5ea89f4b7d694a39fee913da71c02d56a646479c916f9ecc22bf337b1b41e7abd74719227c5c6b83266dfe16575bf4172416c439e93efb224738f9f2541760dfed1fde3f7f0ab28de07db8ddd9f75f65e02f23ef9b730dee94e0469b45042df3674361bc1a035c0ffa828254243e6fcf6496e1b4fe483622a856f853ab370444fc1446d3e841d7dd9e41aba80ee9bea2d880fb16160779f80dc0c1af64c1d555d2f0c369aadb5619b176556212d7fd1f37eaf89f1584bd083d923c02f8a03c34b0fff5158ec6ec8979c02f77c32781b29383725f40b2782372118d284e0508d43e2b53bb5a6b49e35234c76e314470065cdafac1c1c9362e86be489db5146b31f1caa3a15e4b72223bf13713f512acfda931c97dffdca1016a267e9e50c86f1eb0254697386af07f7516a2ecbe2e8e4432cab7be2fdc3ed0e00698b3be6aa1e689d6f9a49570acb593a21bb43e6ebf3bb03ce2d4e08b529e1c733f5e14ed34ebd50aa8a329e7945a13a167f03a342ab67db03832b0fd093c4623aa727657a9ea28c8e2e2e0bd17e24a87efb25aed4660b12d140a3bbca61c12fd196a5e200b9d5e83adf458674fcbfe8a2aacdf5fd5e44e0f1742a25014ee8a5faf85ead54f8809d93290255584a4dcd01f7184e1d838a1a5b113e3239be7c7a10cc3c219dc452a4fabb19a5637186f7d324a7abae49dc961036cfe8a787f7c271f86556f5cffb3599c6eecc452dc29a027f7c120fbfb572be3fdb1bd8c6b8df050c429df5e64fd0c1f15bb6ce054e042e1916d5292077cfe904785b721ae2a0561e06d2d573029353759189de677297f8398c20456425babd1e17f43dd3ecfb879cb9ecaee0eb0b87e51c037d76e86949c1492a6262ef55e9dbd1a4a9c82310f22768415fdcc99632ae402e39c6ae431bbf09f228279d727a9e9200e8a75a9bdc468df4489a297eeaa1fb7612be8ac905218d69501ef8c7e7cf1d481e398a38dcfcc9a64c487b909517dece9ce596dfe4d56412896f41713e1a5a05247bfa5d5d09a7cfa04d58b6a9b500577d00779a6899746d0bdcf22f315b55b6560c456b58c2781b55144aed4582dc8f62e3b259e8fb9350421c4cbd54a8502650672a8991e4af6545520a90cd0df027ae59e609746752d7a10a86c22c620ce13192cdfb69b109d4d79fc3470a7ab204c1ba3e498715da21c310ca30f42e420e17e3102c4233edac53a123e4527111e0743855bfb7f4fa59611ce4210ebd45946212059f8337340b08292fe7146bbdf4d024e07281ac190ac3c8421472dd6ed67b3cb6f6eff3f7217ade439f0e2784a8a0b271862c20effe9e29304b02a919fb194e3459c0463524e70dbed19eb482dca821ba292039aa5e71ae44504278ed02aa8b8bd9b5f2d61fef20f98ea70986d204ea57ce1eae5e59dede73ce4d19359e2a11ecb4e62017d8c1ab9afa92c8ca9f35a98ac5deb3c348940a5486ef1eb8cf16c40b2632e6642d3711aa5ed67f94e07a63cb54132d92eb9bd11fb8a149705f10cd5cc3dff5d0256babc28f3ea2bdbcc7f6f491665df5681867d43520e03bd4315c5e363ef8c989ea1907eb87685d9bc6148d1003e09bb8e4b0d6b1acea3ccb28f3aa64d2cae1f5f1ec5ff0a269529be56de57d6ca7e4c27af27cdc4ad55c2bd4c4237600a3c378e9049b30694dc60b12ee0eea2a9cb4ed7f38681ea059b3bd754280d4cfa0b5cbc34ff17bbf91b36b9fcca2206a8d807ac1532dc999b8cedeb51bab97c8fb507ef0382e2b0b34583a417f681904efe94818f32d3a187e6db779cac28d6b1de4bb315050877b5010bfc77c5eaeef64bdd60654c67e2d7a2121321bf47044cf4a9c85686f34dced370dc0e98e5867092406a5270ac9c9acd2c6c87eb1c7b1ed90d164626ed8d145366858a3eb96d997c83aa3a6a15ce1ef5db401669ea01031e2bf65b71cf39482435e89bdb0cfc1a369de2c57615c8b7b0b4e0ca190ded4339b94e6184747903513236374770fec1802c1cb421402e9f74a3122d946c585d8fa3aec66b55c954ea9329cc798c379992730fa8bb3ae48fe1d92023e1c36ae583a26281950bad84df3cd97b3acf5747e20a0ca4b6dc80b0f29135c93566a4c94720183d63bd8a0bcbc03d23b25cfdcce55ab3fd21d3b0386f8eec828c89a20596e32b5e6e0982f4bdc18e5abfd8cef23915cdc90f4678c7311335948ec925297e31d70ec476f0fb325d3c2479b292f4d7a8ee05fdc14c0f5472b2bb8f3073016c8b6dea164daf2865daa3d5fa10fc6015b244b5d1b978dd4ff4248c4e901f1a43d5dc36e47d30cb96d6b5cae2b14e8f9e03acc7b09b931ca551f041ef3061b678bed9627c27a5e17f56f41b716e3e5bb38fc871bd9060bbbabab6ca37592b879ca61eb69e31fdb52fd64670d8296261da3157b983c7f22d428e844697ba501b86faeb03145894a962a94ae5d168e3b78d36d5e28df396a3851c10eb22813fc548e3a785024f22df911d089456744c48b1376d6abf4a821df550f2a2b596f4dd0e5dee5ac8c2e92f10d070e1304e07b838144aa76de35922e1f41926c31710cd499f86dd575acab271a6234efaadbd26f952de57079d6d3c5af05313370cc5729ab111263b2dcd246ff6109742cab374215b3e8f69f57a39a8a2b9fbde437d52540432d482f2b5d0f3b5a3ca4c550383ce6828f5b7eccd7b623511ab322429eab6e1d4e13d107ae9efaf0bfa6978a4e42b1ed2dfdff38a81f785262ad2437b7cee62798c571b6a4efbd1ca02d71db5cc042be70756d02e92ba969515d022d650c427488da14d2a93ae7017ea17a55f86b55fdb9ca32965c989213f30e60de0b1a71847d4d9912e04aea56a31127f0cfe7a46973e1d3bebd36bf7f546c0dac321012fad82dd8ca7191d7077c8f4742d33061598dbff228289e343ec511687fd55333ce8476303e8352505853c5472ed2ad437ae082eaf9a24f7263ec871182bc9f9814e28b0058c7e575bcc6d3d2c0ac2faa1ca585d32609a2f826c4de15b2165954a85e505603a7f60bce8d79121577620124ca7e5da24aae7876d97051a241b58e3b8406b7d8a48892fceaa79081477859258955c9dad2d0feb8f70b9a07a86bd0bd51f390ca1bc0aafe168a82dbc187a159efed3c787e4a96e2030962ef8271fcf31f5dd5763a8ea19834f95ef7e1f04892d87c24d1419d1a85ec55d4f820087d2aa553bae7f7984aed5839e6b244f28d4576010efe66feb72a13c47802db7f129ca0ded090887dec56c3c42ff9ba7f5681e52eb005cd66206d9a09e37242cde3140e7139fdf9e3b22f0c9c55e5abd3173a627172f65aed7c3505b5a6ed70c03ad745808ad6e6c3ccc9304d08bb9c800e1d24746bec4577b1a5aff3ce0291da593d4aa00a80f746b275f48aab5a66d03039499d6bffb05782c11449f2cbed980da7189e25b5c2205cfe112424efc83ed8b655cfbd3068950c5712776ceea34388d848e50448022dd078c1bc2af4954e8e8f2709bc3f325dcea721876ade63dae1d9bfa15e84c4c5f5d9a4a35949f93481969d7bbe7b3782c5bfc8b687d0558819f1fdeed1733da3b376cfadbe350e2d873493963d6de96843caef8b1a236ace792fc75d9d93c88fdfa69a87c9327fd4fe27739ae671c0496203e0ae339a30847fab6ace5c5b909187aaa1bc7424f3c52c1842721b35d8c9359c9c907e13b07f89328247a162210215629fc92cf2cc5f5fc281d9d4c0258cfb348a7bf4b0b15d96688bd8ca4201fce5aa22625b149f3da6b2f9d492b9d18bea390eb32390ea1d1b029a10cc3aff9beeecf9f6b67dc49f7a2b4e3fe284116c61f016974dd383da17a5f7033c6eddf25c614f412ea118937cf7a97d73a91dc3a2c1c1c99e6fcf880aba6dc3c9211558a7a1f2f572ff75e2f6857ec11251645aeb4b244221af452619f15b48b7762592f91e3a378f2f88c92798a5cef06147f3a669cc049fa010cc03e51bbeded159e803931b8e6be99d474d022b3ebc8a0118082f10986feb5741ef6d82681cca17a5c1a23db5a5d68423a9793ee4cda1e78dbd9f61f08f1bfb07232e9706a62daefa76cb7c063c6d76e28026531c0a8b89984bb23b4edccc0f2c587a5d77710f07a1ef0c2a31b40da868fa72af1b7b9483a3c5b2ccdfcd00ec42938e21cdea3b6eaade1906147481fcb831cba08c798160512725e98ff8cb407eafef762d022b2c75e646f7de0c67730aa57afc394787ebca6cfdbaaf891c79c7ad73c64ad97e4da00cef7419cacd947e8ee56f70b4c2eea0d7f09a39cace94dd0103cb18d640278ccdbe66f4d20056f96cda4db110da157af9dca80f13f03919be4659500fe45ffb260f7d16bfcd97be4048e65323e2db7ea6e99aba0187be22cc48f4611d71160edf2c70f208db9279c528298b7746db77a29a24e7e93a9a1e4200406255af4e239e65011620c27e443d5c91b40835d98fde5ab56f07dc96e0b7d016b7e1928e10e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
