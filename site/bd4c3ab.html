<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cdc0638b102e5474f81005419f3e5a8183c659c754e8384260d1de86939ee3c2d27e48d9f2e730c5bbbf25498274960ce13a967d3dcec35bc207027f471fcc80474d45cf74045db0a1da3a0dcfa2a8cbb52314e30f3fc7c432a86a5a959729576c40b947a3172890e0d942c4d49d11964a05df0afed1c929adcb5e39308f32973a316b7b7427d8b42c6f4eced15cc7ea5f869ff3d58ca35f762d0328c5c4cfa01d30fb58ceed51dff3f5bfc8d356f7bda684c4b80b6b219b159643f536d3d192ee1508e97081e62cc4ec2bcf60487ad8aab13ca5cc3833878dbc8873949d0d2691f3d3cf3c3891589264c6ac6270358e0dd1ec9986111b4aa1e45f2eee3ff079a44c7fabab924393b61a630733b4fd194ec134c6a16968718c9691aa58d21dacf81489f2acf7539d074cf54732fa69357d2b518e040e4f22545c47142179604e2435f006b28677adf11f902a85873fe5e6062dea65b7b3558be34d6c22348af970aef2f1f307233a56d18a9382c78a404b571cd925f021aecbfa31d4c50cdecac5c22c566f9ae60e5756405f2e45b2768db03b97d99b35b136278679ab2afca4d2dcb7c8f21c2a59514707f2bc03b47c7c0c4cccfd81fbd1429004d84806aeb4277d421c01fd81b741a18a06a826ec929cc07f9194c6965fb5ba4247a53d68dfd0da73642e1fa17fbf9736b60232474dc660cac0ca785b625a26ce3d8085c5c85cfe0adf60f1ea7e5e4db20c9ce1c14181b1c92601af128d5352a998624f0c27889a752ce4e3a10429a5e871816cbbebf9a6ae7d0f6220aba42d5ffaa4561b4a13d40a9b815c9ba9c4439dc776c94637d3b29ba631179fcb3bd0d4b02ab36817627936f9bd5e691ba4911748f82db1da908416662aa8eefcf880702d41be92950b6d399a892076c3513d57f07f7829b0eb121683ef0026ead62ea80a1520df3f7eb3d2aed41b88964034e875dbc7a814791c57799d64ba700f846ded45d7fa88bd9d033d8e4e001818cd67bb572a08299afdc95130ae25bc41de5bb1a17da6b09eaed15deed55f0ddb8d9d604223846d9d3aec83090a6d6905ebee23353ad96df9b9bea94144a4a601692d362f8f248ee5ef18627269a992623b66c862a8127a01547367e9d30783b2a57b784d968b22eb5b618999445186272996ac2559dcc680699e784a45cb4a604662d13f87eaaf6771d307ad176c263566b108ce97620e73b7f06fd9f531b1246e71101eafc3dd52d57bc6bdc2724117ed8e44a9910c0a71e4c2533b199e7371ce58bc3c94655d6d1163a9b5269c8b08a8e22fd3b375c98d0348ad43a213f4e60e29db7dd379eadebd8b8c7a1715c2b49886362acab9b788f90a38d368860a179428f8b87b55ef4e443d95d8d8c5af7b71b7d5d6a53dab93855c85aa2e2b1e4f25f86f6097c1be1acc2e5ad44f29b7ba5a8ab91e830aed754fc80d8f50b644c9c719199419029e81553c0ec39f641b791ae95aaf7e099ff268c60a08fed77c5e8bb9b90906ec485ba30867e989a72cb90682dac8cb4b36d42af73091d36987160603eba40312c677868b39292389040bd66cd140480b7ef8a8d461aa33c14567955fd1b06f75dba4064c62b82d9494a645864e86204baff638de79a25261dfa934ed65927bb97dd146f01171845b500ddd85ddf0efd90def8c700d41e9dfe33a09241ee9b46c6ccd843a66d929c6939aff67c0d9888d56bdd2e8cd33919e21a98966e45b9aba1ae8ab9555acdd8a22c8f37256f15ca6ccab090a679280e7bb8f37fb6ef2f330302366558d32a4bb26f490aa4b3feee6b35d2d7e32959b5a43531f3a233b69cb1254d379ba20cfd1b5a3358a5f62350a8ed7fc77af76246156f7633af18a272ef6091709e6f681c712f7534f5f6203b8eafd86303828630ef0ee5b3a322a7510803437594b5a9e13022692dd9b9074fdc15c037caed5245757b2b2587661de634387639878bdd72289f1328b1ade11eb5fd16387aaef72eec3a7f8cfd18e57236cf4a6914c1625df6350cd2b34effb184994f2b63a493e68b43c6bab41c005cec91b5a0e4bc19f315b28774b2a8b98c885605b6f5400ce8fb2bb654a4502f47e4f1faaf036a2141583bed633761f41fd218a196dc6875f26b6a1cad7cd9b2e650acd32c6556a1e22698d0cd337ba616035c99e1197272482f01808b210fc27b3f01bf7f942c04c8ec635ff96cd1c78cfda13463ced9fcfb10ba47f30602162b4d04dfb1c228fda5219cbac14d375f1d0a35c6c7ca75487215f7306463dfeb0eecf2cb4b227f1670c65e2263b29c3c9181ac3451c0994d0cc3b1c30ab23e7e85ae3760ef2d4053220e9b86c6508e3d9827dc859cecbe39656fac2c5ddb2f92b32227bdd88c6a815a32de4ff9f22afd01c7c8331c24fe9094a96125545b00795a1c7c8397b524bce862975752b61097924d5a50ef4a237980c0015e86622f712a6fb1eefb6048a5b25a07c28d139ac56eff37bf20bde4debaf18412a2e818859ce226d99231cf856b77236b83c56560cc568d5188ec4e52c4f776ac5c7cfa2d5709b0caa0b62fd3fbf6d0be95decd687c3c9af0bfd41ce4d3f7a2d5fd603a265972cff7c3badde166e8506e1eb600c70d3c089b19417e821837f133d6836c9bc3a6835cfd4e9f67d73e6131d6c81c36198777f4424f0037e2105531201e11f45d85120a151c9b59afa4bd3d1dbd301d67ef42b601a0691d538c6243ed4196c8d4a745757b46b07c28c3f2bb2aacb78d0927b72c1b0b62ad1164b621b4462c0bf395762440cad1e1415ed0d084f7c1f81d394bd592c7c80eecc13400728c9678672a77fe7409f175d22cdbe1b0ad1e8f23dda167723c86ef51495929be32d2b55c788ed3606552183d0db5e52d4265431c1b18070c0b5c9d75dc399961749a2a439d25fc8e66672dc515ef6bd5cc2bd1e9ed6aa69972941c98beeadd8272be9f3775f5f7785c1cb76c1ad8df7fab15f21898c8da7728b9ddb9f68eb1550518f61d4edbb0b79faee495d3fc374edd21b19989a4956bc9d6a261c09d8867a9bf1c049f7c452c18cf1d31b42a38702d010dfea70f157b339c4767f9a128d0b36bf16c2dae1a547e396729904df16711d2937c5339c431c3e8e27cff6d7f9566ee6a9b0248b70583c8255010e45c935c8fa05a7f517a030654f8425c0ab1c3f8ffabf8c37b2674e55f0f089dece10ea58eef9a4182ac90e9bb913e422821426f5e39985337ece712e099832f8dc448915acbaafe129f07b7a815b2b35bb7f711c105baf1a89e8aa0686c9d25acac52a70c114defa4db618ecc2391963d36b922dcfb3329c655a37e7c73ecbdd35b6442c88c712b492527b84f1fddefefb8f795397f67f60efc544b8fe8a6053e8d5b694b352b58c3893a2cd2c3198098d3fa07362d5e37498b84fffdff6d0801d9d4b7789e3eee8f20b914b05352ead528a80fe6054c9eac42e1c8a0906336613a47c44fabbd313d64753fa0058cde170f466c3cf77a040be9599ba8d0e7b3580beb83f0a8ee730eef555d0c2e61b1255c4c006fd561d5d153564c5b03b58088f829c0800b794343b9705e48adac3830ef8ddc459e094ad64a8b981f7bb143907cb4dabd53a9d09cfb0755103bb85e4a75f46d8c5fd0b07e74b10fffb00467f37f867f10247c9603b0ea78570f574335c28acc4647b837b785497d8fc651284b60a358d24f9367758208c60a98a914d2e56bc9d13aedfa78a2e7e782f073635ddecbd737e1ea7067460dcff18ac475a5560c512e20d913cbdfd460828b8a1bc9c79d39cdbe06494ce65a6dcba7d491a7933f30ec3b97d551a50b450e76afb102971245c26d9c282240cbc2a76e540013fc7eec2db36522396e0084387147ce173c60eb96cdbed46c074fae62313987e410986d0a94804bd527954d4c3e77ca25423030dc553fc86bb0af0b2f234f03ed6f5c9c57e5941054ece5b7931bdaff2e69681fb1f4a2402f7f964db39631ea106a1dff1c702d166faa078c44e57217b1a7f3019e97ae054004e6691f7fcee5157579755dff47d496a389af16916599e60af67ed47955027da94265cfdeefd868e47bf9a8bb57990fe7ab13f97eed6d794b2e19b2a916ed86de8cd1215bb36149bb533e530bc7d50e53f6b1c83c96f78119058bff297660238563a1d9658d7086724b53b7161f19e86fa62b4b0984bc24b186a88ff476ae04fb262e555c00e678040c8a7d921ba9a128640e2fe1833ab9ff5b2d29a629ac4d2712cc7e1d28d115cdd0a44bf07ec8fa9f0f8b3167837b21f211cecf35b1d48378f87cd80dd53174a23af39d186216592f0875795901530f497e0c7e0daceb46380b6cf97ab7d7e9671ec227ec48224fe152217cbb6971c9f5d0b01d38d51b232098c25442a4b816ad3143a1aa882f1a390b8c935ebb2af83c463142d5ffc0410fea393334c459a500cd136e8b936ccdd5cf65844b0d0deec9915d89ee2994b6fb68b16a9381648b1a9aa1b4b0bb9f5ce3f70dbab0771c1e99ab60c27b575423d06e907d0ba5d0e007639b5c723ec0096cb3538e4bc023ae45b79239f8dccd7c13110dfa335d006feda5146250752ea2d262d34986175cc2e900f711699cf1017b74dc1e262a92eea9147456be005dbdf062a010ab09bc06ebed324a1ba3f965a900ad36b261fa1603360952b77479b24ea73397cc455bce6edf43b3b191300add0dae45829b6c2ad8688f9f736766ba23b028ee7894f97dbc9229028dae9a73970a55fcf24d15c967fc0cbed907f8b989e0f106e5f4c961c9f01b55343606d41b3ba5cdd99c7b116bdbfb9c22309637c95da3b0c32a94a65cafcb48ccd66766286f9056f0cc2025dd2f29f95ebb0c2267d49932db22270b13083bc60460d60a51a4ae3e7440fd0dae93fb1dfe985ed98e94ef59ea47c520615ff33f1f3bcdd0283ff8d79c175852dfcbc76f6256612431b0e62d2439c54c1158623c32cf1afa67be49366a349224f54afa8bc0fee5af98c21a2cc962da5a79a6194cd432169cfd4742fbd8e77563627e51584467192149ec2abd4c21f9afa8b1aa8eb2bc024dee3c33bbf8539a5cbba878cd67e55b1f8c0abdcde644fc8fd1a4a499399560419e5f2f0d8ec303a17d62a7ec68aa42e32c62b81555fd8b3a08dbac17244e83120db2a4f6531789dafd3db5970ac46525da3afac270ba6b8374e758148e064a46d70e1386a4f11e84608f849bc61072896ed55bbde657f4da78a6732473b659bdc03b041451033a03cf59b8f5cae1c40c62f2efd42bcdf242a84976c3d403ea41b141432d70c34ba72c48734ba7d42dbe5765927a4c3aab05f442a7d4d3c25973f7623acb5ae813be811e544d9712d6a12d041b602934c37a9073c0c58bb5073f6b692cbfd75ba3901bd3e9ad18ab8b81fb43183a6cf4694491fc24e1a47d7cb8c4509777db411ad77c9966095b796b975a7b950421c28c3b3bb48ed9c89d99ddb60b5b6b8ee611e566fbc9ffdf0ae7978ecfabea4a0d88176c37865fec29961a24085774f2db045282bd663e1f3cd39a0a2f9e14e9661ad94c800b4873707bd8f4d4ac761e6c48d17852034a73cd2669bdd9a14ec1329d3920cef6e4332c620735e357f2d59e91a92fd78daf662be008e9a2c404a25d07d48b38d31d40cbe0eb0515977ff55717588282c839730ee6f092dc2c2b0ea9886b0d314ac55dfbffc15bcdec08de657ffdffcb5a6b689e5afc5b9be187687ae327f7fbb4793af7feb3aa707dea26ce31199b74917511da722e8103d7e12f0a23ccb27a729d3cf71b41401ae899775adde601a0ee62d5c1adfd2f34cadbdff5fbfd1c9659a630f2457c04d13eb842bdfd2180250d62b1318421a6ebcbf42ccb242a953e79e6c1c4f049bbdd01164db50f1236c1aea2f0eaa882429d8f53db65a1a4dc4b23215ef686c01722c01c099dbdf066c42db25a71aad97806443aa9b6f94b7daf1ba01a05179bd1ddc1e9bbd119c1becd3b36968b580c45105042a8547ae49ac1525b0130c0cab6063c12748f48be7f2e7f486a2936adbf206ea96e096899c86bef21f042452270c6c129e9f78d3a60b102ea3fcd87fea4d7da41dc78bc1b45834a5a917a6d9ca9dd7215a7a9a04af54820415dc47b9575890f40f59f2efc0e6b1924a786171fc44759d2d4d08100ea62f44fcc38c85279c05ba44c33e505c08d1ea22d5ed7d36a48c9001ad340a624f1293dd1c915e35cccfc821e74e116e74eec69859c05c12c396ddaca7fa2e6f127e9a54e847b1583dc24c8bbdc224c4101ebe14df34269acc17605c72b73e7fe5ff50d9c7ebf534df9e82c492de62498dbb05a16510a44a8266ee01ededbc34b6f4d92ce8050e79270c4da29d1d880b4266fef735d631164f08ab21fb711658f0f49ae93998e51f0e96faabece5ec5ba2481b2b02ae9855e8200efbf81fe10e27397bd73e5c4179adfbbf7105ab718591a2b3da5a457bfec0343b5475a79b98a0f4cdd6f1f99783c6dab278315026b7f73e1a10e5e05dd80a52203cdeaa2342957c8388eb4c110eab44812ba0f3813c3b5836013b1a39dd70e9906026b165ea2928308f5643a98bc39f26b3f36ee26884c4314577c5a2b9ff0a51663f2d4fe86c64a1338dd27f2ccde4bbcd8d7c3f64b42200da5719474b47d725363994c3c18ca4e32e05f997152f3442eff5a2bbbfe4ed7a71a5fd1776a1e3f993c048cf8f0cc06aff198b36efa2a4fda53de918afcee850e16706d4070cbbd9188d96bdf2e4c58d63b92154b41ebcf7658a444ccf2793f476c4a863609898b23e6d705dd4c1ef9c6d91777d0a1874b925967c320f2f1eac37ac068930c16c397f2de154c4fd506638e7656e619f1b827c3ce4a5e54371cec3d5dce0f0bccbdc63a71710b3b7e5d8b046ff4f3975e1d82368585963b6ecaf97f2e25824b594c46da31e22ff4e6045a0dd581e2c8c4c963332ded55a06d0c74d1de1e3234282e5654638dc4f7b654b72b8780aaf97d442614f6f2448b35ae9571537020225066a3e00fad7f34e1b2e5ed028195826124a48c4132087f01360adabe33f3ec2c8ed7b2c46519e1e7f13b00ae823b0fab7beed19a133063c2b849eb80bb775344c58c9810faa83b4ea434068ca3f8e622f2e3d7b9bf69d320f30097398a6f09aabd3b36abf0b84a0cb30a94c56c8f1130ceda8ad167307387ef93ed108d7d12fd0b3ee2e56aa8d32425026bd83ec11ed5a91f5aad9ac26724595b41d21cc469c98bc5a63cd94826ec004a297c63f67827477b9dbc8d2f21b03ce2508ab89ada1579a52f6500425d2e9ddc833fba6df4cce022ed25fb7f8f3cf608f54aa1c779209d1b168910936800ea66fd7ed515ff83489470a48a06870784d14c99d5e359873703b09d44b924b3f522c4468392acf7ee87ce482cb08ebde6ab6ff4e399a42288697c3eaacabd28a5aa939507464a6b3a2db554ed82c8ef87318a17d3a0fd5659a302faa5d69fdc78b893ec20acae8caaa1dc07abacf400a86d6417339ca0c015067fc57dd298dc3bc195a7e6b42771ab1dd8c17fce61923e3cb9932c81b33d6408ea9f41676f4e9dc901b4392ab23d4c98baec9f75c97a735eeba874dbcd043a5d6ddced3aae88ec3fdc5f11d7d7c75e58584aabf872004c77302aeb2ac553990d80e8ec50ebb92a3767b3179a55e85147ae0aa1198cd0cc2a827e8271115381aca3bb57f9b97afbd9409db08a02ff6466caa112e9bb9017d450f119c97c56011b8b9d63da19ae4b7c3c101f7d040259f600e4c173fa7fe641783f3ac62897b1d954270c92f1348e0778449e980e07770000af018bccdc8991bfe0e04512d6dec02fd41f22e31eb91e2aafe6c4a528b6061882591a014a4918de89fac2b071f5783478676cb8799f61aba22d4941149f42a09dbeea44be63d63a936711bf041f27218e0a70c84f8dbfa0ac2d16a939590f8c3f3f5c297f81cec9fe606e88d2f3c6af3ce6d64b3a23fb991f63e645aa7549ee760cad07fad1a5db0cefc0c24d7d5d0c39fbe27ee6c2ccfa088ebfaf5dd4ab18ae4f1042dadd5001b3759d467518180243b59023e1d672b730467e7227ac0f35ac80b52638b19444943430e272dd429895df9780560cb121848920d6379f8e9fa4d19b9b19c228027f7164ff1ea68c0f748cd0034b8712f474ef0c7cc33ce579437b3487c97888d6e6d7ae1291e0e7770e4149ea1d252718c6ca4d205a9c0ee6facbc969517bb79ee2bf1fc034547db94a32b3b551566286ae42aba3f49548bbfc772c592a93be223d13c2739a9dfb8a809602d28e419048c7c9d3019458ee9d33d0514836d301574777221ce5586fb954cc3cc3b6e5cc3c9139e771e0e3aaa01311b4dbd784cae5989ba77276acd70ef17879272b6b1b15407f07a9060febb7058d21c534a2e8dba8064f75014a51d5274d7b318a12cd23b8cab69086ba578c00c443ec6a1c181a9e649e307b43d1f6c43bbe2b53a3d75d0087eb66b9c5afe3f1c63ab4454fbbfb7ba4412e810cec948991a6e568f9e24cb862d88982f5dae14e0eab17edebff6836b558ad66befb9ac76dd121dea8525054b6a042c41ac924edab5d0a4fdf62234c11be2b46b613b4f43cf887676e215c75edcf3c46c07f87a08279c315ac5fc014ee4cd5d984f651a8413539d71d4c2030a8269bed8dce1a589a0be4b2732c42de42e58fb132f257293b09ad7090685930a34fd66848913d665f55fc7d612ffd6571e6cb29cd665a14e2ab2d080dfe0110472f98271f7e5d9ff5f6bcf6a9dad8d01800c71634fcb8a388a9e2f58087c06259ef7b3a4d837578c7bf88f020fbb33f532959852e40ba78c80b489169a219fc7cb0faec6fc25beacc1eb1af3f1cb9b269addaa363a62f9a2935ab0d00fe7a6762ef036a87ce543e9526b289967f87d857374d18ab0738a3631bc8896df75d5d4c4ad109b404feaa4a14f3a0c99975ef627949fe8c827d427050cd2e6f5cae50e2d4ddd4034483ef0127a0ba683ca33745dd8118bd33df33d8ceac5e151f7618af6204d570ab3ada097b94bd7c8a42fd91b2e0efc531a87fba4c1f2e7c970677b3ea657de8d287c0bf30a85852cb951b1215c19428989315df61a8a551e0d37c39e72912603ee128fd64ca16481f06720dacc98b2fa442ca2d3464dddf45f3add0deee538ce1313a17624b0456ff785289c046b4e9a429b96f48668029de4deb38bff6b22776f61d4df6d9455e5e583161afe68adf190cc876f772930a09f7662743f5ddf2961bde83fe53ffcb334986c11915e9663a3d22a887353ff33f0ec8230ad074407f331950a3e691683cc270326971a037c6554e228f7b2da9064711e3bfe25788ed5f8e4e4999c91f33bf684f37240c203a75e4aa133e5da2f09f63b0d7b1be344cdea085e47500097e6acdf72d578af844fdcd4bde57beafb7cda15ddb0cad7e84fe89bafe24346ef700ad4132356acd507a0c99275befabe6084578faf2e63f7461efb40e56236a888af49325c8ee0066b8db91739e52f2c8fb3cd7a348264f6e6e4f8ae8630b8ecf139f1653176ba84b5a63ea0fe0f1eebf516ccd9d425aa290fd65d58ab5c62831a536ab3a3e6b706c7b3896c7577210bc07daf694772a356246b6bb080f35cd3b02d873129007fc860fb42992087b81d0bb75708d429581251cb857ca7f11aecc4884ac363f4f3a94a504151425056ec3081382a6da4b5c94315d123b79a42fdacf0868af638195fb34fe4c8d9dced6368bb310dd29bec5f64ba5239d387bc686b91d7a1ae9a4a7847d21e7936bf0a2daf8f25592793f5d40326143b7c8af2806cbf7c7f987e5ca5b1fe77dc0707849597c7ef3bb25cdc457b9c82c3e88e65252b793e635e4a7c676437e0a40bcad1d114e9262d1fe9688f3d3db46ce30e81fb2fb434d3d3b4a7f5c67a2c5bbb5d407bac6499b559f866c129b016cde1d47bd8f6d4029788a329f6baa5cdde2f76eb576e67d6e9bea1f48fabea084b66c9f679b3e1432ed8fff18e2ad18c6e437d018976565bd025aaddd4a4c61f011db963ca3ef8e89f2f80bde4dca11cb0c81c44b5fb4a98b12e05d7d0b778b5a2af424ff3f55dbba88a111768e30351ef3a75f73b729a11d9a318e11774c148404ffd86cd4a2249e9d0c9b406225638c3429dd7584e10701f91c1216f8536a0130c9bf7059caade250035d99d96cdbd0ba515f2dd4076778e6b544b3e81aaa52ef22d17eca7075b5c5f7102048aecd8ea552d45414e997d8fc692039e229d658efc76a0549d614f4a0d70466681c322464ac16bab16f9d2b208e596b83c3cf4a3486281d1cce79cc69bbabbbcd64f04c15d59ff942378b4a011e4dba7e8d4eef663a4d1b2e85cc56210c05f0b3cd48d976376f5e78e9f0788e598bab6673a5de403469cf873e17560c1d0012f785820537b3ec57f61d63b893d2fe191717b026d68db8e2cea4e224deb5a390efda3f2903908ad20e94f6621e62d35623afc31a5fe52bca642f78260c2a189d490bea866fe54900b28a390adae7fa3b2d78cecbb9ff357d2ba96e408840fb59c259ed548168667aeedeb8a2627ab689259febbde31b6c729e90721032db4a9c12bd39291ae4d628382c9124ccf8d605b21b5435b92850849a2b3ef4519e4dc7f5f16ba00071db5d1b53fa100cd705eaa7620434126ba66723c5844e7ed1a7a3a002d8abe8c4f49e26d55fb92c7ee9fb15687e96efe9399963e7d64fccfbdbbc062caedf7fab0911f6916ed559a81d63894412465f5319820942be07cf531d7eca70a4ce7d22a464be696b2566f4a02501629dcb7b107aac80c630222648d9e2095dc02900569a22f07cad343ec3ae55f4d6a2b2ef7bf4a32421c2a2168db19dff87574faf11e0b2a370b865a2e8cf9fef7a7716be12d0f7fff24ec181c5abd80912b46df329e223362baae0d3ed315c14d2b432d8db89b31e17196c90c0edfb24e33cdabb67c33b7d44f5be10a5eb6f1915535063ada2de3197e7a5429ef6ae3c14866f4799f0d7f1c74b3aa00d70400cad52318d36c14186c00ae20c8d5a0a9e6de2be24ab38e9f7e3a22629b27bea7d8512bcda4ca50c0cfba5d303864d34e0eece25cdb7a09119981f9352f8374eacb5c32209d9f084b6162408ea60ab0a72aa509c275b7e64be324e080cca5ff62be436f97926bf33b48b7292941aabca2a6e7f656ae178cd4760b20e1d617984b2a0d6eb72f172bcbd3274b624822305db00ca4c8ee48fa12488c1e46cd0ddd12c5e85250008bc92c8b52d882487754cd2c7de67a019ca2f08e73cc9c9d97d3e0af838419d9f24bf8bfe5c820c8aa5915b307833ec98c858a134d33293cd2aaf8df6f33692a05187b07ea606640f9adab8b5a7428993631d89cba58c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
