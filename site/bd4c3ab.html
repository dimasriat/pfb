<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17f89968347968a4d53adc89605002f979fb5c86d730db37055ab3432717348cb3cda4829584724799e4622f741a53388a7fda4d2a4019fdd1cb085bdf8e6349f0bba7f40cb549786099de3cf97aa0b426f9776aa5cf31209533a8ccda4e4c8269350af9acff0ad8b490e881a54f465e518d1f08d458f8770688a51d931ae26ba44d445dccbbfb215a5ac51cd067c160783fc9ac2d60d120f1802bfb0a47757e9bae37679b8f0d456c42f5bc29d7aac0a621a4f385a7aac5ae835bf6795469c6346a51f214570e7695e1f744e5af2b74e3ece668fac7e8fa8dbf0410353ca15e247fd48fbf8a385caad16e3a3e8ec908df801e270c19d32bc8b1aa5d4cfe2097a17ce0f1e8f48ad656ee447481ffd59c6bc8adc3f40b243ed7ea26eec2589b098a739e5c99122be8e09b0f602601a899af99a888fffe77d801f8781d1d7e161c0a5855a24f1ce51fe8d883e150b8b964d4fdfb18ce9bbcc7fce3758dc8aa0369ed7d199347ce7994ee755b95387887bacfa3b2a078cad45e081f3dc5fab4b7a1b7249870e00f11cc9efe93122471b7516bb854be2cf0f35b33fb8685b3c4035450937174e6ba8cbb005f9caa178c6e160d3e6b4d074e949a3877aafd696abdb7671daa1ac28d90d8142eef24983e1198c3a9ce30259b6fb289cb1f89340931bba2ef7984a17b9b1d761136e6897e781c0da57a09512bcf36784e5560b58d78931f3a6fe0f6704a74f0f98eb1f58bad41d49cacf527e275901ac42e5a2a186f1079538712a4322b9b9f5e94c4dadf0aae8dc44b37b3e8a51604235e65ea8d905a718f98e19fe6bc670a5761c01ec9e7cf22f16a82e9eab2443351ec77285706ddc878860a0cd2c7ec498e81cee55afe9f9fa31cbd254a9bfaece0c0573f5714854719c00f9da4e25825b5cb0fa8550546e4d05cf3d0e36638df88967205fddb0a33a302045af536c23c3121c6037a1467e7cb77afb4699dfa2f9e0c806f0cd950ecf0fe64686da4345cf2ba09f3bbf4f7bcefae49775dd274c14bedcf9a37b93b78b67afc7be9a2fcad2baf06dcaa9d4f22c19790290fe8427e6860af5536d7ddd828cae12df2ad78b38f6c2cd4bd91f30cdbf5c750c75272e764bd199f162571fd3e462c0ce02887964f04c089fddb02d2b529add2bc414ac2e36bd4aec2b39cb06a651ed56b0b6f2f3c17a42b4cfd2aeefa208f0bd55def2f3a71d5957fbe3e6afc77d7251d84ab091e4bb43446583e12c412c6cabbefa7067685195bd2570ad5b5497738141ca5069e2d5d78f981c49c40fa71755fb1f51c9f13d105a5ce6929bc02263ced74ffeb16063209fdba7506de0aed246259b6f820a33668ddda7c5b63f1dfd18b760daa59668c62f944adec4d3cd443ed12cb667f052b7ca0555dcbe3b43b75fddb87e0346a9e1a839dec3c2ffc910b2d6182d67f1e1bc7fba2dfa25e2e7ce4ffe6f00f7b939c274b2612a65fb649f32a096025ce62256b62360b7683b5d9944163b7a361df94f6c72028b0bd6db4e1ef8ee116092570d43f4686da2f11e2ef8630f3d4263d248543ca70133758e5aa976cde8f7161c9414a2d758cc4576c97705c74e344c51f0bfcf298a077c186185e99c5755075e63bd8f12869a84c58259a83384e5756363e2ec61d54f795f27e2687b111383f0dec2630260b79f349b1f4e871c2c81ea810a254aadc947e3ebcfff031908ffeb2ee334c2bb975b6690f11a7f4375a62c79407f9c316a57068168a2480251394ddbbb4a42574036beb8069ebe790a0ea302afab356c7d40d60e7090afeb5fbbc7d475718e9500fb52bef89c9a00d0c7bdd68f6ea2809a1ff4ff4b299142fb65b9283c8e7d13083510abf1aea6881659a2d18fb3d288af684dd65840da4ac3eb994d880c5cc776a6489269741ae917c7050ccf4550de4b69ff6e010f09f1b283519fdb7fe40f60647ab8c1a01d7e15b1adcb3043d3282124818e3176be22cd85384313b0b75526a10beea27d735009e0d6a36adb3ef2df0a760a593fb8625ca147ed9eaf8bcf47b014927be6b0b9968c01cff02c12bc519f02e2dacceab7ffa403bf516d28da5a794b479175ca4e5be5c83a88b5fd5ddd65f9998464e51496cd7b043af41b3ab96e655fddc131b6ac1fa991bec53534cf492bd4fe53a34b03a37a1ebe02eb7c6a4a1561cc1466ad726cfa34e80cc8bebd35e43604b1f27e2285b6260cae1690a340ebd7853ad813df5360ddfdc1ab4918e0fea39797ac6ebf47241f2bf497e14e7e0daffb24ef6d929ff3e1c77d6279d5eb300ec1777ee92f20df4f663e0ca80172176311fa1da626ed208545b77bc719af8904fefcf26151a6370c0db53d673864465069f37c3f53bcf0ee2fb80f02ef5bd1038818efeeb7faeefe5bd4b3af32cdae7a88aae954be29432c1e5500de07bc845a26ed07ef818bed98c4301b5698b42c08e04cbef67624d6577cca4bba7fc7cc1db93e934dc4e3f33d4e7713b744ce897ef131bed9854abc24773f7f04ccff230ac2c3b1deb2e40c477972702011eac4e6f4c89aba08dcd6d9651106d58dc81a42fbce75407d0d4b133bb3de5fad520fe8d2d7e4942d0ce74f576bfb40a34960fde44e6d0cfde2b8fb5d985ca641620770169da0162068a6c89a97b3286cc7dc9ded3659acff95b3a2092072e0a680b2eefbf317a1eeaaae6f57194962bc8e6cfe466931444ab83980445d0cb00b5150293739a3e98c3d2e530c25083be5ffbe2f585cccf0882e8e6315d291f5e4f41f0b5d1d1a714e6111ae6ae05a4a9340e247cbb69fbda23fa6e94a02e9858d2dacad358a79b6db23a3b3cfa11985c1d4e668796d4f528828409dcf81d3b1ea77d2464b0dbe6a08ed433b42f267af9ec7dddfb9fe5c486c8aad06953df6cd8319c27b5e9df31e789b7d8adac111d6c74010ffdc45634739e495c016fb6861dc6674624eeee56a0d955ec1f06044f9a555085ba4823ac77cdd85b6022cde05e18b93db3f9e327b19e7904797daebc0c67742c48227e46f52e119e487aba585132a60bea1fff5949752240414850a5e2b66ba8543bca12b2320aa07007a3e563ec474be0f486d58fe7f3469c2652e2389b5729144b6b143e63af2e1c37c3e6315e733e518068c30b6ff751531ef89aeeaf3cca1c5a56097702a967da595e75bed7afe8e97cdd74796bef18a4ce20f58f5e9ff6de8e65cce741982bddeabbfdb11086f81fe9db668458d67d4df49e04d601b98def0042224a43fe20221196d6aac40f8c907eb13466cbaf47d1c9e201d856d96c66ec670490acc62375e99a2dbfaefd817e80bb8785366c9cc1dd18ec02ee87e14a8f902f020968772ae3c5d5534234a60b9a693b3052df6fa17553c6d3b2f0e08e649345580c7c172b5b4693307bb8dc24f3a9be78497b5fcda819986e5f4691a588a009af593f69f147bb94667897450dd9408119c5fa3555131bbea755cf5e500f8dc9153c569456901b7e85abdd2606cae6bbc93569e6d0e31115540a28fd07ea83c0c3797c7e95ebd416c98d410fae97e2e23c8635702fa83fc51a359aba4e0b3c91cf133bf99c603b795f74b1ef473755f14b63ff4701a69e86fe2345f2c189c200b378d6b2c0b6e6784ded2d8ef4c85abaf8320716f3c86318220cadc356a8743d6a12eae7ef754ea097b812370c885766d5d5c1dd1df0afde1e531084aa6966693c9c786025f8ff0aa79e7ce36e62ecc34c1be13450a71a414287e8f22efd61626b48016f98b518035bb59a0377ea06bef359d9a022619a7a8bb3bc9d19451dc09d564f4822f008a8111fc2598c8e1264c1786af6dfc1e770fc6b22614482dd7d42e2acac22496b982d09f281da03c4109018b2e52c1dcf1779c79ef18ba180e9e4a748e7d0cf92879981bb1b2697870673f332d575da43cdd5ea76c546aa135859b9f96e4a418a62beb64eeb77734fafeb49e6d3d62c306e93bd9110fd52bed0e300fc4909db0620fc5e7eacf5c1c37702b7a284c873724a396af78a88697c5010bdb172651dba66d166ebd8b944d77b48165b3e6e90b8db3fe671b984aeef890c7087abba789d0c52efd8cbe1f3de456618f0b5fe081c0bb768bf0cd311774c2e3315b0f4224caae4a360426b00b27533307f775d07fd61298ca192e88e3a39ddbca6b5ba89552addb257316e0e0c6f8e648ab108ff9d0f99c02d3518c7c19a1230549038be0f9690d20edd842d48345dd1089fbbf82e32e5718fb6f9298cdc6796c3aa829e178962a9169aefa10fde55ca2cf6b7ef309a0308a1bc153871e6a5abb526104988a4aa91c453132252405a8f717e5a37d6a87b4f77ac6e3278ee9878ca581de03844271cab9f096a6b4da93c92a1bd37876cdbcfbfaacd0129f474006666b54d99ce1ab2d6fefd5adadbf499bbb0dc6dd5073b9056fb4c93e6bfa15848b977ff5e21dee6d07731dbb3e529950f300d6599e6759a3a47cd4a776ead96db9972bc8c3c3f187510b30f93a6e256ddd50a39ae377940efabd2b87cc3baa3f7768f0c6ff7af6fbb397c840a012ba04ac13119b9e46b9e9fd8eac107f798f4b7d363369c5636c13969367fcb1b467d86b246df43c652eff3d8f89581174fb952649bae7949f07d12ea577475b464db5ac16a4b36961042a52bc611fd3bfcd50c9d0625144214bd5c9605c98753803cc18f44682cd2943d002d839e3e0e11e89d1468b06d4925c6575acc5a3d85746492d4b52061e5b91c5e854882b9dc7cb9524c3f3a70f7d1287fc5a6f28ece17992374b43a7269f67a572575b0b77f8fb07459f9b99ca2b38017a4dcf6d8c6b2f37cfaa7a2e8cabd3e3e69c81ef5d81ec28bb68bcd946901da648f806c1474e46466db9bfad4e8ca221976193f2f339db29a76b230c11ee352db7fb2c4f27781a4de32725e8a676536037a318d076c98dbe8162183b852323407a5c098e68b968228d444218a0c01fbeba0a6f150a1f2bef33fbcb2cbb0338be2a0d4d36734a232f52c7e6ddd61e52f658701c21c2e6b51dab4ea5aa14e3c692ad21e11dbb1d4f193e8976ceac84976a80c388cbb5e8b34e7648f3dcb6c9f90a65b3c4b6bddd033908a615bcfcf13d685e64cda4dadaeacc36898300fd682bc5818296a28b00822c3d29c93b857c95cdc86359a2a2a85eed2189205db3415725b1d29e550bfd6f2d07dfda00bc33fd88fd56632dc36a45f722dc82a4cc0e968b2416da5597843273dd509f8d360d714623e8676d5dabbfd4486765b30805806468d7275ad93c1f14cbbaf504ff742da3e7ec6c825d3584d74f7345ea972cd201758ac886793abca467394cfb8a670c4473c5b1f88e291b9fa71cb85fc7e4c55f55e47042c28a23fbf65ef16aacda63ebfdbf3e1df7c3478b03a2fbf7223cc9c5b35b8284edfb6676a133cb0121923fb280919ad5f285262a04e4c0664274103bcc16d375831ceb468015b220e69251afa3c7bbd0861c9b858106ca7483b113f6c0e6f6eaa6865342defacf4cad08162ad717e219bd89798cc5a2133d8d71142b8d24c4e1f7b293d9ed1556d3225ae73390ebf3be12f31a78a69659b84d15a301114a305aec8f05c55287b0ea4c7fac746706765b59028b27138a502f3455ae0129f898e6f0179cafcb7caf2c092d42cf88be09ff00655b0a9984f61534dd697595caaf5b94f27e11137f703cfbc523645c6167da2931236e7dec56c49ad4e13c0d6e386cabc28a5796e6963619fe1c5a217ea7554f883405ddaea181b58a03e48e6de33e3c6133eaac52220e446676cec935f11906a93e0c8d80e68ad61872c619079d4ee14d491d21afb0d2b59b0a12db120a10b9449d73ddb8d63c00bd93f2788b1d37ea53156c2c9742eed2f21c9f8790b71fa73a923abe71d6d0e52c6c52e5afd9c78b4272e8091d858cd9feef8442b44d2498cc85dd7b78a8c6c0be10669887229c573d0c1ad07be55fa147896fa5a7f3872fdf26ee134c26e548a86299ae59664e936816654202ef9b3d86d11fc293234150128ef0997f762e228d7bf2bec63da48488cca185eb2b0d2aa77cab513aa8d0d3513ce106a2407610b3ac3a325b0d1af1dca06a574edf2c71d4d7ef9220ac258bf0e57f143464542708c8af69df33aa3dcd2fcc8b75ae250aadea78dfa14566d1dee9ba53a19f8cc2cb44fe49e47957d4494483cfaf37aa1118409b4e1be4ed0efd036af624217687b3a3bb86dbd8489a46d8faacef4191c9c7fc23e5191ca3fa5e37e937ea6b2c44446f7452178744601415921709bfbef7ecce7df6384d82f49458c44e2bcc8e0a84d135a8c524de53166d043d7e396a64f124817e905831eec21d102eb60688de8ec91e6f0e663e0b4c59a5be4f091a5602014076470b0b1f06672719468655238151e51d226a73120ea13244b2f62524d3b2792ad61b87cc6569fb0eff82db4734c0cc683e72c6a9ad4d219a5250882ea130f746090f846723d157d0ab07be4ea4be1eeb5a73db2ab94d12cc9f0f63209ef426bef0e576d937450a6da2ff33915523923e845452127ef5654fdafdefd27ccdae395f54f8eac075d6e31e49864a6e804bfc45a3c294cc6dd211e0bdccadaf55091ab214262f55374d6630a684ba9ab0f3c43aeaa94fa8ea5a44a6f0a59fa266183944f972b4acbb0d569374e8bd37389ddb97c9868e923b71b60b68dd1ef1f57216fc1a07f25f56ea5599abdadc11831ca002f337a961afdb6a515affd187997daa5b2f8f1e466ec1a640d89d76483b83099d9032411d8b80bd0bd26791dde0b43f0063783a58a2af573614be921fa8ecfc87f0626fba456480f181684e64cb01902bec30c6f39cf22b7836892ef0dc4bcf775d2275f257da2bb2c8a7c8b4d4ebb09b3bb82e2afb7a7a470711573f43c2ee62fed52a683ff2db7a9c898520dd2e1a5a951d674290bb844c0b15cc8a65c8ff53a753f842380918373ad5c1da4462ad776f085ab4e3eb4cf7013a1139cca9b5349df206c114afd98025637b382d8cfbe3619c2282460a2c252474964f5f05dc4d3fb9e15088a394c662e4c56cc9d5177e43de54cf37afe2037ff22e386304583752e925318fb35e14953f3cadbbd90998116954c5281cfeafd757d104d37ff2a20da05386adaf47bc515bc6335f5f5e2ffdafacdf068cb299148f09f7c8cabae727c5bbac03b0ac71b646035b2e49dade0f79e6baac43aab9275245a129eb3d00458811c8372c4fabf260d3ae041ee8bd5ddca5fa56f142b759f948527b9cba688f3960a111dabe1cc264cabc964aa80de7113a3f8502a3e1330919958d1eba7d469c8326f1a03a1bd96ca89a034ba6bd0850b418817fda626ccf8a81b574019df5ba0866f857f3e115728772b339518aa32c230c1c129df4521db70eea15ac1617e343b8bc1f66b760475df1e691afbb48c834978bb9b68c853f785598abc24a1e2205ac784f6dec4afcfab181cd887ae6fdbfbbff251ce12d8d9c8ab94ae08888c0ba09897577911c2bfedb80ba57981a4a0cb22626280b602e2790996419f8268f3b1f3e5f111ced74a4071276900fa63133965f493724602ebeebe07e8ff7577e3895264502b58e7e6fa1098cc3d5bae0fc6ef4cb983b3edeb773f1e0be409f312bd8f1eb5fff2ef8cb2f2b5a02368c74b8a440e7bd7fd850ad218ab5c43ce0b64d3d46b644eeb96a8f314d5dc73ff65a620986a4b8fa93f1043cf87016c6939d6b4f93e86938ec45958323fc4e0d3f3937dafafbe0209c95893728d877f0868b162d3b828a5d8f6ed5fb2bcd872a0895a312912f637ce74d54d245a247c7466f4039e72d158329efdac5f11738bb76ccc31339b89bcad5f0a252b203af3b1762cee16142bf9fc76b2de42dda19c00c1b81f6fff5d8d373ae15f4fe9bdf714266e1038512eeffa4997375f1261a4680d03ca71bc3be520f634d7b6d4439f60ca92e3502f4503cffe173105b6b2068ea6d96544cece81715c01229ed489c36848251548f938cb97ae9906b11595f5f1de20ee42f4ae35a2a9c7d9fe1b51daa2f6d4804fc6a942b8ffd9768025996c59bce2906336f40357f819b6bbe70ccfa2f5d3096db3204e977657d5908d53e47734830b5d239eb92f6e9e4754b8bea6f3896f226da534e2a70b15b13c2718ab315cc29b574457f853830964e808d0a4ad795ec9fc65a3532353c297915274c74239670f6aeebeef734f58a11af1f9dbf8e578c6aeb0d5e9f870a12e2a784b4b4e2c5f2d2762addbf98271b0bee7bd1ad7cc9a07e30cf84b975041bab0fd0c18d615f4376ae90fb9e6eeaf735e3da8a7ecda933d471cabc7914068b42227b0133802ad508d7348e9db3a65602f46f5bbc4cb49db0236aac814217709efa7c0e93bc4b4d398a9697870f76a3162194b5d7b76b85648d591fc2eaca7db425bcd1fb12a76efa38a296c00b6739621046fda2bd1325832223161723ac9a8d49d56ce6002a55e002778e4263b2bfbd5a7c58a1a744c06b011cf348c8ba8e570e1d7d87b4f071c6dcd039d513c3c0508a118e7f19d2fa306bd3b507409b2faf3001b701924cd103e03ec70bff4a487e0e43670f6d31d5651999520a138048533289afce7c00f9dbf39c7b9c5ebdee42213ba65bd510762261eed5a9cc010381db0a160ea3ee192b001031520b6691b3a0bbfb9f87e16951b5a9294d2721506b46c3d5a2780ddc39083ce78e759eaa3acd1c23f88e93f5bc4f3975516fb3ebddaf0fc3adf218e422c8acf5d1326dead0d80bf4b6574c474d8a8f2a69335653979c68af18ebea57a37548d41cf76a52e20447568b44fc0f722ff2dd2d21a59feb486b9d93e32e63dddf90f48c75f7e49aec35d9f200383d50105d45323e194680d1818f51b16b18f9d3af81df7b284f9cad0f2b296b5c1c575139da5d96016b5b64612d4aab041bd07b26e2b54799a63a742073e5a04ad82b807f762770eaa9eb5727c2501a8415bdf3a29ee0ee5740debc8b0275c79f66712d8b9aa05d54c39cd4317853ac4c9a4b12d1b395e181f48b39a41f6d27d7ba05177fe85571891632bedbf4d81208613a75227a2bd68b897273d9028cbff624bb2f10a1c79183838946d5945f45787267ef9b6b2d328e9f6c0213496828ca3dd9d2f4d9dd29303ea5e22ae9eee1a3de3197890a9d969deb22982ce679ad4e3035f9bbadc26995a35722592c3a89e1e4a0e24db212f01d5e14718aa250aed9c6fe1978f453b3617a3ac1be85d73a7a05ef406c1430d233022fd8b78e53053a8eb857da2623ca21918b8249bd8840c390d0638721945f83a1159efbf2b45a5f4eb441b3fe64377a86fb888fb936ab31e7133f6bc92b4e353507207251110d34c0b8fdaab9fca201c35c726977d4f61f9576150e0119c6ee844a904b70ecb986560c329f866516c7a88b6daea265d391661ff458cc45c14ed2743862927ae0cd5a9463181ff805497b7eb6f1b6ac796c4feeefd2c7f2864d77288fd7f8e427b8953761c1e239903c0cfa70700a3aa2ef59449595b248c7e0b4cf43813b16db3151addec94c2af120cd11c148ef6bdac94c8705f1e1bb9227b9ee020887f4d9a2d601b1404ebdbd8682ec01bbc541224782b379203a362deeba6257fffd73f9027209f91a3293f9546e2d79ee6e1ea44d2e2ac3eb2f6ad5eba2d784b39a4132f4ac63734284ea44bd738c27321206d7f9fb3055c8fb5f79315c9324318c1de4971e991b32d99bb4af0fde69a735a720a9010aac0769b531dbc0a94f74901a5a96bb7e8f85c71b418a77aa1dc5c9845b44106e4ecdef258c2c49074c015679147c55db940051e3a031de43b26a9dd72bf214b7b73c8139132b714602cbe48f0cfb90cfa3fe75e93cde8df33cc233193a6bed7ce2533f344b25daf2bf6cac06ac1707d117f02dcbc6546b24a44061b430f8c82603974edb91acb3f98a8103836342261035f734eacd22ec978e9806d3c0e9a38a742c92f064090d23e5ef622d065a47d60f06cad541b2c611d153a427d643d57ee10f60ab2d2b0c8717cb1d889c9214ebb322dd955692b16fe34eb93007721d38e340fce87d9fd8fa26a1dde2019c933e98abdc5c2cd9bdec60f61b1d7937c083b92f4b9a11e41ed57b071bd8f796bd732d3269c20ffddc5eb49337e3b5652ccc04661abe3ce1a87bd8576382d9e392e53c677d2689ba44a73087a70c445d22980333d3c0d889fea97a93faa6af6569a1158c3b7ea1cd2378594840997b3b22e9a253acee02458abebdeafc5471dbc711eda71d826ecbd4b64090a79d7150ef4ba59910ff3936541dd87fafe59d37216c20d3fd8957a1cc61ec6540a70782c7f0ba92cb7899a37ea9267713ae394139b0d280094374b3af64ab342afe998338dbf5e8417807d72bc715b9ba2fea41b35e8fcd3bca21a9e4b6564445dd73c962d3dc3efa47f9752e05fe1102d24dc3c7da87f139b7d18ebd0523b5de75c7e0332e0559ec0629e3749a8b7cc5621f10dd22f22597bf3b71d14e8ac7a25d4a8c1ef01b039f5a9c2d832d344fc5982ad0bdc2ac195db7d1c6e3d19a3130e5c030529d0f526a45d9f402336325d6b87356f8298428d19753eb704956cfef2206ae0464f9948214dd5d9f4dad41d348d9221f26027bffde98d9f94c02ca8a527459986f3b9424461dcbea7169246b62c2fecf7410657f137ffbc9295f3a5398fa6232b52e5d5ba764ed9edd99de9d68677ec8119ca807c30d4add3b9d46608feef4a9390eb81b58a0b4050d8c638b65e03fb7c00a6f1472ac17bcac41762a00dac0dfee91b17c2f3b7fb547a80ac6ff378c35d3d1acaf414107e7cf28b56b81045075e3231c273f77816c1a685203a83ffd455d40ca32ab8e2b5e1dd7e128f38417788298536507c9f9be762fc6cc55d5e8d2b68a31bc2135d406a90a3db262beda9798f973092f5d4d4240fd5538567080ca3f0984cc2cbe5d23b3d45531f873e01d83279368100cbe642077b8f846a94e7f0686bd375775211d566f925650a7b519aa92dd621ae624db899d195584673b778cd04f09410115462bbd3723566f241ea97036406df951a24e9e43bdb23e5469a5b3c114b08710494c300dacc1c473500584fed74505c685cdec73c25a4d45a7d42934125c47c3a7537fbe3acbf99d5b1fde70e74e65e41234377e1b67d3b2fdacf7890c31e9edcc67c6a04516aa42a18cb06833fae4cbff22092e0bcd2f4ffe210509da8cadaf304c4c3d1b4bb8075d264c5fe1c618e4a577a13a366bb1cd6e46496e2891be3a848c247d71a7ce17fe663e85b05beea3d8f0a815a2a0690031d006ab279ac50b376e5391b2905c2a4afe80a022e47d6b7dff823c8906ca65e4e25f83709c7ea704e3ece5298ae5ace0c21e846f5638b6b785ceb744e6bcdc890660a11ac7988916be0ce225e8f2261d4eaec004f4e1c61c55d5b0fac60f6d1526fda927ba56b66bec9a77b80e7f6c886d112a8c8c34a5ad5cc4603b7acc3c8f38140e00497c0cd26e8c5b782fe8f87f76f616b3363544595401df09911dce8fb7b7cdccc906e32ccc4721f2c87aaec94059142f5f21d0c1ff8413de691e2fa941e65169847ca2350f3510cff192e1304bda8f9ba525024a48698dd5acc055031a1e71e104cf63653d00c6cd2a35574a73b24b31f9c2f2edf2d809cf9c72da68b7853cb5172d8575db9ae5d6ced9173ec0c5c8890488e52b540a40dcce89c35914d1e996bb5925934233e83e64be3bdf238c5b07d5111634b8c2db901fc37d5465c287265046138d06e6edd221133e524064e326739c72cdc7102411fab0199657ba3763315478b047e4afe1644f705deb78b0830d92093b7c02fed000c967cec6272f000b5f6882d25379344fc19ee42b0022333cfdf6407a0feaf673905df99dd7f469f42d83f53872ae22e0c4fd1e9a25b46eb529ec29c1a9aea8973390d6da6845e34876e20a815a14073091a8b5636a4562d907b794cccdd3fa4c10dae99c8526b45690684f93e1c91882694962322ca53f8430c824c15d2190c30eaee8f5c96ab8977eca9a531c8d5b662d7507d7f79de29018621c886a3c7285499f42f135c6d7c22174eb755b59f42d6f8ae7aa174b0754b95a3973fa17fb36796dddf883137f7b2d4309433a8a56face2bb352fb58f5babae3937bb6290cb21519497c709a1707c41a982ca4cc2c3ffabae18441aefaa1d6ba5236735f198eb90dd20f43038b3a8ebd9a7761fb33a17ae826904f3a78e839277245278bf1b5a92571e5b6294049b61ac674eb9ad5ac47be19eff46f9b00979efe1","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
