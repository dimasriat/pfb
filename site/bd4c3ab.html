<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f858a6f3918bfe4a94b84fbd2ba9ab2ddba3e048a03124c67a2f388587e006098308548e9ca248d607e458883f344819fae2c2cc7b9300ae03f853fb4b37f678c7afa10b8854b81d785e6ff82d219eb90ec1fec32cecea5b875cf0add6e12ea9658fbfb916007adb4c05cbf4cf16c5dcff6110fa7bfd66895212a2010ab03073038e12b7753b7e9bab28f9ccf7fe18ea0d21fba10d63bca1152f59bfd7331c05179d61ea105d5cc58320dee56476c7e578fb5eaf554dcb61e561d3f2c0083f756afae532ff523ff9bd98866f5b76dd1e099d995ef5803c8dc706406790750628b08c50cc6f5e7179b5e9537bac031bf5d6e3ef81394c59fc4f3e57afbc05edf5620df49eaa1753d35f3f04d739941265b60024209354740ecd0b59f67a969c5f2701f590ef80aaf72ee2fc6b1122889756997710e016fc9161719081e40b1652bcb1b57f56ae10cc5e7dc3ef9ae5b058662182586816083cdb3e82698aa9b8830c7cd0e36d5797ef56b22256ec06ec75d7ec300ec5ce42895a5dc72b8f9e8d37e6b4f72a8fac34dde815af6c53206ad33b4688f6edf19dc80497fd82994e1381b287a024d76417ff84615dad97c7529c900bdd7a50d040403158cbc3cf9c335318e231af536fec9aa237d70793401f666c95aa7d746623efcdc6523e9078a5529ab0b581d3eba3c6457b6e9cba9cade51105a3be56a4e29bb9e4259c42b272d61578ea75b05e6ff7222eb5f9f647458fee448c591a3bb98f668c98abba2ff7ff0820f71143f05849bf8ea99463eae7214a4ca0179794abc3544c682b16ef2323910aac5471247d548f7927b6aa7a89959b4f45049649eace8812ca46c5e2e97149584aa0e819a40c93d4f87356d31327c14d58a6d3ae942faa858701e1d49b2ebadf25445ac3295b3ca89089de3ff1189df28437af878207d45c025cfe4e2b13d53734fdc3b3919559b669f6615e37273f599ae9dfb364326d9c6cfd594880e4aab7186e45e5063ff819ca3b26d3e5e13eb5bd51e35bfa263271e3c0ef85de1dd114842ddc8520a496ff324c696a12e2e02c99cf9e0093a6bc36aee66377cdc592768f3f13435433ccaf220d8d0c4879ede12f6209b8e4f23c95e1a8147dced9df5b61ee190f5d9c8150ec1887ca3d3b24e15319d030e0d1a38836a7278246f77bc2f56f992c4d1daa324fd9edf88301c91e56f8ff2023c4ce99509b3fc3b955f077fe7dd19dead21987f27dab2aec72ae7b594000afc760c26c60125894ed196f12646f4a1685fb576733556eea2905c96c91e91ba7124843090aadee65c645e9594650086176b0b6d661233b9793e54eb06a1fc83b715356a97ee68b1332488a632f93173f3bbec0cfe88529d1e1efc64e0d2ec7e7b47c3e3018f5808afe57af37253abc19f1735776d075b3bfe0be6d0dd639aa67300245cdbb01e2350a18cb1ee900f99b3bfad36a0927456852f094ea150878530b94bdc200b318b169eafd423dd4424f4058b49c7bae2b834a6a4c57780fea04b17c6e02fa1e4065dabb55d0b75f8fbe7d51a00cfdc733df7847a086194978a84dc7d1a48713a617b0461973034325b7178a1d5918e1270acd9dbf0b275c23355773fffa225c05e6ad7b9cf8e4b358e1bb1f0e413bfea934bf7c5fa7518b8b9fbf9ae30f805c9fe0283f0a1d0f5ac9fc59fd03b53bef61a0eac2fc1331513675a41b49ddd3e54a9f1b34b304f0de08ab9325cd0c7f96e57f9b5af8e9605824307562831fcb9714d5f266a73007d0c35dee630293d2dfb5f03d70fb16aecc4bcb40602a7fb37ffd4694056bf2c40cf219b11993c74ba7814c98558865b2cfa22b37e4d1c2f98640aeccf426ce81d2bec09244a27699d26034f8ba3262a62e39d3d754f86021ac4679665f14ea9db1faa26c7e48b8aca73b2e13d5065d8d34bd74a690c8b041a6419734a5ac64dd979263623a99603be5dd5aa790f8a0737b9f6efba174cfe018751308dfc883d4e19d6194192ae6db8a4b137c741f5937b51542a6e92e9140c13d0b635e2a8aa651942534d25ca8434fa395bb1f2044f82031e7ad15089f52adf7f1d79e9f4e10bee46672e25d220583a4feb91585e8fde5be23df1dbcfc43da0bd3b20dc4acf4ee096efa110176388ccc62066ea54f43b5b65c2bb77f8f9665fd152f8c84027d40c9bf14171cb5da671d3703448ac5238108803036eadb0068a159ca08d5750c9ac20bf9886258266aead27784754be2c8de2ef3453ad4dc9f53c7fb107e9f2365a5781640a8110189ce4c25656f7e7bb295fbb096bb5abd25e9df7c90312928fc278ea3a5340a34bb8c98e471e7f74291b3465dd3acb719e5ec759f85514aa6043a56da4569181d17e550a5f54c8012daa21d4701a850d2b95967b677575b130017f3d3e6c9815bb12d8fc2ab52dcda9f7da6442a425aeadd56f20f5042826340fd0ea98d8687462006117a88c148c3b8d19a277e2b86d545be1cf82057da8626ecbbbcec87bc53a915939ad944bc3e166adf3eb7885152ef9287c2de679354931a968917851e457d4f879f8cb0eebfb7dd5be929ca8f831ded6d4028b89f853616f00ab0efc07e6f72a40185a49996b5d6bf4b69092220b0d09ce6afa93e481943826983140653a5b9f2147a752fd34acc7a111aee56e19f180553e47433259c6d306383539518725593d33de3008c7861875f1f4667603c6838b22e4e35c0386e267f3c0b83496fc3a6f7cf03b758435ede4bcf5b87087e63c1061a2be1cb1b92513c4935cdeb2512747265bcb89dd9f2df0153f7c25881bfe39510a7f6a0fc62fc522bc40a5eee6af791d526544b5093270ae4b937a452f3b3127aa971f449a68b23d7bd567da0f8856e81ff9f8cfed0d99c222a17ee6d5fe3012233950d676c86819cb763a5b0eddc62077c82fbc4238703d35e202fc36a40d7677d10bda48a73c8476908da13138435dff2954872de729093fb2952441f3f8698256bdc66b6e2347f331d99a2554318f4c3b1ad797a6dbd3802728325a0451ce1c0fbbb39c4a0c9e3e135ca3b9c68a55df83392b7c5d98fc0c7012a8afc88f75b4fab2cbe009c6916342b573210af1aa86b657539829068d2bcec080baa4366bfc0fd6ec6d89e94a7f4f7c8eebe6750e78817c0d7b2bd4c389f13daca3b56bc1a5cd9c01c9e200581a52a0aa0a56b44f46329e3a7a7a1ee3921682d83d3167492f889abc32107f03ff8fee7733f200ab1310fa66024558d3c28ed4c911799dba61f6c64f0fdd9b1147a7e0938e14007a620a2dc66877d718333fc172d60282d512dfa793900b587c236a698e38766f79daa17df43f8553e857b92813778ecc1209810095782d8a6808f3124937eb5731663910e68d977fdb1d2000562046d5040b9fd24f88257094eae75412b971d90ad33565e7767edb70b7bf40da39786aabf8f30b8ed3fa9f16a5073bd275d8f000889e3bb9aba49c1209b8783eae2ece026ca8cf9d2c7274ad46c9ab7af824a19b9251385500d0eb294f7adba212896dd2d44ab3a35888a9984902537cc3b2ab2906ed281ab5581668acedfc7e69b635f21e24d7e653eac57f6c9c25bdb6b810776d80dd9300b9b029ecfa5a43d2cbae681da7e8774f261ce841c9cfccd6110fdf226f25f38e352b31a19790a8f092cbdc11e9eef241d0eb8cac519c0d7cc108b4d5a51b9e2d835569c1014db9e8f51ce56072333e0d36b693ae2c3699a6bc57c72cb301277b8e320120590537cad0a025493012aba51bcffc1fad6b91cac90c429f827ef1fa9b3c07a3e93f4642e001b8395a990369c87ea2bb7f622297d9021a07dddc2376970d74f5de546f4bd4ba90532c29d73e41bf6b009c49dd89fda57733f3e1eff8b579afabea71dcef494e6ede92ed20fcfe4d11c47ade7a9391925d29a7c084b98b4a1842a152d1bb68fa144c732e180e99d817f038da7f3572452d95d72af7a6011e42edaadc86addb1d75f7b03943c5ba439e74d088469c2ad445cab80d8910aa183852ed1798bdff1f178ba0bc11ee0bf9824a4463b621283529a3e44802176fbcccde161366ec687dadad92a185bb4df39f3f66510647bf5296841ee8fd17d1d766f73349d720b7ec5d796d1c36cba1f1b2b3d6089f08b3fb0bb6d85ef91e8c6da308f68945a287f4c5bda58129ad56d7e60ec20a89f4ac18f7de5bf362c94f695a82ac638fb1ce1c7797b53ed04604759754ede1b9298ecb70f419ec3cf5aeae00b62ba06e479d678a480e1b428b8ab325b181f400fd1bb48ee5f91b1dfd62d0e7717a675d2b7c977742f08f0604788b34d070240c07be2d7c96d5c5b4fc22831c5063763be6fe4e299a5f38956e3f43bfbd9b0673767d8b241ead0d05d72a328aff8a5457e55a5b0e0662c0acf9396868a18de84ce618b7dfe819c5e5c886e9092aa5ca989bbea159340af346597025e03849bde401028a8a4b2cfd418b91078ac2b5458790da366e541a461ac24c07e99388491b9617ef3c8809b61ea72a9aadf1ce75a5653b96035994825aba4298cff692eb96edb2982dec428d1c67c214f1e2831ff92418caa9e90224f66625cc53f3bebf76c69c88b3b0a7f60dc78619e465040be83bf8c976cff13f11dbfa9b69a024b10f8fdd60228e81d827defc734dea179b6c7e3e4a333bd671cde14ee39a7d01a2ec35223a17a0d58ee69a92e232e54de4c4fe1794e15b6feecaead96a0658874d21aca5c697302a7e936a1888171f5f411dfdd3e62543ef1dd50ffeed8015835dda6695986a5bef6e0876138f92ae45c02e50a41a174bf47c5fa66fa7b0d984f25d1ed911e6a099cf68e6b4edb7febf871eb8bcfd0f69637ce58b62d5a7f486bbfc176af3ebe8623556e2b63ddc905f3f862ccc7f12a14b3a6ebff7094c7c9e5181f31cb505d3f8027df9499f8d90f1bbf4d51d85cacdbdc9b337865e44759351eede405a633cfb8366f77b4eda6bb121aa6fbd5841d497f0ad6cedf4cdca76a06653d08b1dbefa89b3357fcade282b82b9eca663eae433697273d8ae51bfdd7a56c5be2e27b6b3c24b065428f06df2ea2b9afd1678a7c0367197fd998eeeefdc5a262e56928b27096d61fe0fea77ca359b2ac0630daad015eb56ba02e364bf2a7c25bffe55ccd709521034fa92359234d86732d365341244348c6bcbe0ea734488f5f80385c0961c810c2303deaea813bbb8787ed72ab37bf4ba65f1a52710bce76d4753277793289c5287a33f0e8470c54931604c9c06346ed9d7fbdc6f4e415db1641c5fddde754f5e44cb2fa4f92257b4e55e2d443d6524759aa767a55dc79b475210fce3980899c4b0dc122fc0c5a434343c3a6793698dcc904d79fe29c0dabdb3f7fe7a370224fa83e822971bdde5e20eedb87b37d18f31177c281912019959532f2f982b0978811ca12a797a3f7801d1da24f4cc9c8b90821e91a7cda5f524d97c71cd134f29c98779ebd23917aa013c8bd99d56414c8a853235e227bca4625d2c1762294d5a634bb5dd9da8a676515b141788ed1434f3db510942d097d5cab7ddfa20af97c72e32d78aae517df42a621a3ca46066e6b79f640296b1b41bc7ad5a5df31fdeaa12484ea4a7f647d51512cc488a4e055fd6ec063059058d63a61cc984f7671e465eb821997f76b0107a7231b78f5573fad49b24c7ff9ec3eab9cf7f56a9bfedc23f6f73c0553d3d24df911709538c851eab7d2c76d84d772218ff3891feae1555f6b079857dfa02a2e490e6c5dc50fbc2bcc1d51fd8d8e215d26cafcdbf20ce806a4f42ee796de3bc7e2d34264abe184292f500216925956355569752e866e35383d76785e57b0bd1c25d2dcd6669522bbd31d4b1c52e3e08fb9b5cfeb2d899a84c0adc0335494a03afe2540c9875c2938964207b54f752b82920a8279519c5c8ea9cc283104fc5b891db7c9988fd3cafb9c99b7c3d1e4926734f6ea91c9c809058e18fe7c1c863852cff1659ee23284668386ed4b53b457456572bd08343ca26b0edaf497db182bd9d6856da3fc8e52ab93eb174f0106549839510910642e0e61158e2cb4914dcb716bdfd8582e0e66dbd235d46414f39f429022d1375dd46890c72d58afba2485da89e2334eaf7908b52b77286097400a348869f62f007e1a51cab009201d386f96cbf856c5ee9b11c5a54fc97feb55a743e000f1b24526a21aa720f9f2bb501c9fb44934e726d1c74dd96a4669889119668fd7cfdf86ed3a85ed59a1c4ad9975dda2041ae2b4967aa11946c53b24fdadbe49270e2be3a299aa8f8c33f40c6bea7127bf742e3e26dcb1514a6f867efb2002a24b76fbb2f849079a1c2c59faab5bd895c17359beb7cd83b189d1646d78fe8779d6e5cf6e2c25f0a6cb9179e265eb5f285719e8dfaa423f26a1c9700f08672cdf1cd8d00e41aab112bb6dd35c73ca793a3716b7d318d5c407bbc1ae1bc725b4cdb01b3b426021d5716fe0b52a4bb2ab2a20e282ccbb85a359902c95ddcfd33367174f8d71211540f969b740fae85199f64893573262d1a8053b722e98e0ac94529cff706a42a6c24e2ba7a93ef4b8cfaf498734fe1ca8f8b4a4f2bf524f482c52243af8133de251652ff4f22449a5b0e8ba711707887ddb8dc8e318016fe28ea6049c6a00581487a259cb3bba7affaa78552974aeeb3823e42c921eecebfe889d6d58513ab58c6deaf6d647b84d1f686a10ac166d83b05e453ee4c065faac1eda8860a7f2feb0df4d8ab2712c0ee410cc6257173afb4c09b7d21bae5428234757a5223619268b0729448290aed3642558e41a1fd6b509e6a1235ff499746448ccd4a2e974fc6e2e86b980f3db61125ad972d30eea0caa6c6ea609a46c3b368501e87e0f264c392612e3ec04d7a4af678670cd36760a0bd6e429a21596725fb7b324356e3aa01009154bbc4d55fbbb9bbe04c740f58b2fe53584007f0a34fc6f6ae68ab765d89cf462be34c28c4743b3f0d29b5d8018bc6902c8191c6f246f09d9a7585381e1b8984127bf23dfcedd6cf4085d5472df33f7a2b196bd0c7a62de27104db76ab98c307c1fd962bdb5798f2ea8cd1df011f54f10b318bfccb3dab0981760c28b91e64ae7fa5b73cd1752ffe95d4f6a87b7ec7eb813032307a44d3374430f2d7938618ce88006324f2d86384db78de8ad445399fa98adacaee5620af0c2ef8d7a48dc02da96ad97e53509f91c4d3b3fd815c25903417a70afecf170bdd780be1bf88504b333327f4b1a442d5e53edd4b3e3f91f3e188cc8bd30b739c405e3dfb389a84eecaee18415401a241b5644890b92d284bdbfd20a380a582543fce3a50550e5959673f1a243e25edcf35acffb8bbebb52adc8503631a4f5669957163c4377964a9cdc633590dd75125e51aeec06d3e1c885b52519d3cda0e5d66510ccc3e0abe528e5b650612bea60430f76561e55174f4a520b9267a5ba947e92d6f8db3467d0507f0a939636a79eca21a3ec716bb1029863498de12be850877fec85c976d317c8515f05896e0d30f57fcff56abdd74a7b428b8d00af9d6cd1c11775a6e5520bff172aea53c6e8185c282d467b2ded436578c305a9cdc4b6d43d8fa3d5cadb3e73bca10b2f36039d02500d959aca7db8d7e0b9d78970de122165cd8b8305128c11a8b92131109c77e1d6d1d47718c2310e09389f21af7b4f8b5b2a94baab0b5272ff2af3cf49507e74043210179b142ceb0274c15e7d0f9943fc7456051d75addd7cc1e97ef8c2570410b88adf4e76c3b37ebdc276d965ce54c827c4c6735a1294d4fa3e114345e67a1d47fd1a66f9c5edf4890eb67bd2cb5245168a43c368b74f316b6eb3ae39731227188d52c307bfad6a53339274abc05af9e1e00ff412302420a3c76a7a6db15ae4c2f163dd2268a75e71a90312e65c7ac6f6b2aa2b7236e5cac176dec29f73d2718bfea4496f42c38a31b9c929270fdc890d6c8a622cce350ae0d16cfbab874bce9eb6da6f69f99f258945cfcc224477268732744c8648a3564d72d7da11ee998003331f991750cf6e259794d456c60f48ac11c93c56676b04a5a2d96a55116cddb2a69c8adf86dd3df2455663881cae73abfb6f935bc73ce9711d976689eacb79000070d5d06bbac02363e044768bc099c3e1bab449a8de26ac743decca49a352b293001a005aa3f8f2a9817ae114ff555904e63b28048bc35b66be072c9abcd3f1f3c2d5cbadaf8140aba8d54b5f2bdbb6d885ede7169df10ab1f95874de6353a4fbad784f8cd5b15d0ce7086ad2f3a29b424d947b83e4ee3a9966b743756c5c32c55299d96473e5a674e51bd757b47e94a08595b0d75407b392db4563c6ea760489d51f37c3fd06f3a3a32ef330d01eb768751c7beadefc61b735e2459a791a1d868f501600703599bffe21dfe7cad6b633b4ec22ee6ca725d4714d724df71aebed4bf480e7b017803a3063b3f23fb4b304e04556a11434412f03a1ec4f58835032e492f343a7d4be690dad3f6d47a3071e39318f5b6469ba0bb3c777d1bd8f86440157c36749977d3e5e91f808b2e3a27a082e9528a690148d5c4286cd94c3731ed6c5c2272a3b1b8d0b5c668a636f17576843b672b7de11dbf0ca0182bed709147b057fff58027beb4504ec23dc33fd946281708f1d785421cd719f02ae1d8eeff3508696278c445d8e2e453e71150b3b890643823c78a33d7a0d6ccf5450600a38637982ea691e9c04fd853a51bcd37c7b3877f68935463f10e042ea7690b5b707f1c1cd5243ba81db276f3e4dcbf48267baa7781c67e949f3a636eeabb062ad225598ff12864f8015803bda0ea16ef83ee5fedb223b0879d0932376a34eed3a73061f683efe3effcde04bd96fe85d325f29c9471538fa5f4187db53f1cd98e245df6f0b500894ffe5c51f0f65fedd0b16973a2559f36a6baa95359242d0299891978d1b706cc15ddff0426b96ad077c6b17cb5a0d92e20ef5382eaba30321d09743f903cdab8659c316461a63aa309c2982cb07a7649f1724de671c0183ccaa00d8a85548f08269b42d7d361149c498df8d384220e2835aa35d879120a35d312fe663f8af225bf1a4bac16b7135d59766b7ef7f1e8066d63b09818e1f061b4d2bdabcdd33fa5ca86f7a2c73ae921fe77288e3f14287c38aa167820393ed3d3b33e220ee40075e375a440cd9872e625f2a43e40d98d09ee5b5eec33c6a07ebfe1830576e5d9900fe79f4500d51da1798f3f2ba0e49a4a0e4dc89a9026dd9a3defd15c0218dc81a3dcec89399bce38af2e68ca7d054377924408194ba24d4fbb7d2165ee835afb9515fadde72a2202f75722558734f913565bf614e1dfb9034c396cd9b17981414c8fb84d05e78a5b14f1ae2549bfc1051f29331d89492b5c89471efa8bc0cb10333377a4242b1a8e00913c43f0574582fb1b2f7c44beb89211cd399396c86e7c34fdae27a40ce79e159122f58ec28d482d53497106005728adb2250f9ea7cb87e9677702f92a081b13c1893f0fa9e240ccd843f93969a4458981ce0a664c8e837fec34983d5f4f7ea14188ae4cfef960dbccd624fad14b26a0c96f056c159a85cc30f6887dd7d4e763b217649055e7bd381fa648d75e4603a8980140f3cef73cabc2cf8410216c61adbae8067b79c44e3170e2fd51b1af5d06d3cc9038a51ef65fc9deed18fdadb86a151c2efd9e135a8644402e9ca6d3a303534f879cfecf8f1e8b7e2ef2bb03b67e74e93e3c56deff6afce6e249614aa3a1fc9d2ec16bf78897410ca5112cc2c4b2ee73a7f82d151fcbc6063695b996268aac2f7f0c3c8f7db84aa7686a69b0f66e3c61078eff021fa528364c2db47ec72535599de5dee00335f2d0f8bfc8c2206be16034ddc7311fc16b1f3222215ae567a8a9cdbe1a89f754c118dff1ea76d07c4c714fd1b026f0bc87a7c55e14c389ae665647be567e542a9497197bf3358fb3af2584464a5bda9231e0677d783f5a52c5f361d6290d702b3d640ad8d2b339a8d52f86c4d9e8bafbc90c581f442254f3d0fc65b9263149c68caab0d1c2a0dfd9256e171c27216f07da5b2c1a221c76ffafa23ea1fa0acabeea57b50b2f84e3d6da641a18835e43fd228c2601209d00998136d4c10faa337c4f8a6240d026969bbd8a2dfca6d8fe7a4feb9eb21d7c339674af8bb15488e097a3488cf24ad595d695869b80748d4c4d12c6a72311b9a05cd39544ed1cda1ff9ed08f37ba546ad35cc537fe32dbbb71e9007b68f808d52668a488e4c7b50ab6dda2226a632e5ddeedf99fefb1393cf7ef46f610c6b055b45b8b8a50b721a0144424c28734c7f836e1479db5bc489fc51705d4a93dd853733722d07a52b82ad3de9972f498cac61d28406cecfea102ac7c44022479055fd7bba69782ba83a1348c41fa01bf9c7d4887ba81e08216b515033a9e722a0cff4f7e7e3cd2d3968d0202a1a4b2d036485b7e3494055e071456d44541b8d1ef9c77bccf07c331001422b12cfaa1acc051c3bfecf7c9010384a8d4e3041b67f1e7b940b1e894d5dfd322312d8a23e202bb3f42d5bf1f6301d2454bb4bce91c0b2d2e90f761ea69bf644440e6468be24c4c76bf15250bba8c2ecfc94e51ddebc08f3698d91b1be9d4d755c765925e1cc3a77717df51ecc2c26f1146273897e68dc33696f76b86db883be0ca4c54be7b3cbcb90f5b8001aab5fb5f6272b39ef09abe9892436bf434cd39da95ccaabf0dd00dc4535aad0039a602c40dc9485f00d7ac2d0cfce1ffe79dca2f58d34c90652b876096d93fb6875eef736375789aa83db4579d0f551ddd19c86deda6581d398635b4ea59c3119d5de302da43475a612b38f6d7b595ef1e0bf6c0e715fe9dae4b10421fb9087c4e60ecd4c561266b9a0184bb9e797384c63f4c5cd13ac5ad6f9c18ec7c9c59a15de5cead9d9000e615cdd6c940b9b6ae4e59c4e6ececd6b609f398bf0ef6fee9e7d7ec876d88f29dd3d5940ccd4f7b39e07d61c09e047e2fddbf3bf4ac3d40b73bd2a0d4b956986a7986f47376c8df9d3131ff515c3472822884cf58f235dda08188f0f54a98e7e5a2ad0eb7025e94842030e6d745bb79b30d3ea7396df8840f4659aece172f46c48dd3c08b8bb21c2a989246625aada9c8165487add507c488c10143cfd534465072f79f5312f84362651c0ec7be3ee5aa2b784a5f913b8029d2a948744c7f95ce524b93dfea93d95620c08b182d3f352b1f8b39b71c133b1ff2b531190a3af62e4c74b1207112e04774995a017109b2acf85f0e7f3bdb359c89ae189fabd3b85fc15fbfabf6539821eefec9b4750753ca2e723a706780230c1dce946995c009deae7c0cfdf420106212b571a916874f5293321324ff2e68c19d20049b737643f52bc972c6a7fcd687790bf5b39280cc5d80114a43ab8783e8e002430e1019bd7e86febfd5707d559c29d6637d8e85438a06708b87ddc6f079931530346046d6e2d8e0bd38ed0f62759f3bd251550fe6513aebf5c317c3327212845d81e0785661143e8fd5d86bfbf52442155d96746d3dbfd2810faad7e7f17a2ba75744bbdaf8c2f80044883e31e88a80e3d35fb2cb79cdf85d29722be82e4cebe0db22ec29f9cd61dade9aa0e9cfdb275e427465cd7d151332f00ef6a438ed02e7cf47b4681baf26240a1c2028ca961b53b4e7dafcdad103677b4091422df59425de94657cf1171760ba621e2d7815bbfef3c13fa0d6565d11d9174c415e1e9fe9d33b5ea8401b3d0da57f6069dc78d17d5ec9b4c4dfd2327daa3ba05ee645d14e5f0405ee79cdd56a7f1502f2ffc2a70d4192714405ee082065e842f1da3a7ad2c71742444f1c8edf52bd96b1533f911bab73fc561b3c31b8667d5e87a58b79fd145e126674c554a4cf17092c0a11719d378752991c3a48cecf33cb9f99de0e542221684e28d55c209d04d7b60e1f8558076884b156a06bca185b3c0faa31ace8a98c55f6a8cadb245b250f8ee77af4d78b078a3f09f18a80cece5d19f3cec39da47bac737189bdd6060ef293a21ec20ac94f1905b2be594881e645650179796a55516f071570cc6ae808145365403b8f298a71c70e5602fa56a60f15d4136a96fb336562fc7b72e4a3cad38f2b206ea0c4649e59690b5b61d06152f66b3ba60ae2bcd589a566c22979b9f93e4799c398ef0b90f30871207568704c9fee15a15766ecee4e785feb0a1f01537d16d13ea4347fcc577c676b52d20d9cfc3babb141c045cde0d8476aa4f672863c644f6d684f97e73aa7a181627eecc0c7bcceb397356a64b7d8695ba379e","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
