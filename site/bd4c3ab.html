<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b61bdcde984e572eb15c830df4b1889250d0fd85655cda50af956d869465d3ab99367bacbe01412017aa703fbc2f6a37702d6d877c4fe49e8c773607cecdfb4e6d8b095055671c946814c596ed5e4986f6a40c09a3e5c0e14e8badbaa31b9de385353ce4d9f6fcb8d17e6c444bb0cf60e24e0bbef96cf246a17f1e5c7897f8ed0349e025c8c4afd349dfb6cc76cac4ede47d4b862e08c00e5e5f321ede3eeb271b7fcfee88efb0d2881fd941b9ef50c5724cc0e49e2b2b71a2af36dce40eef222d758f15d9c521e8d01f65a614daef2126a041d405c28e5e95b15b6e4eb3973d2e6a16647acd3582dc22d9425dc959d6479575768a2591583e84509ba506c22f61e92902da1c0783f67eee27a9e8f57ab1e920f03efa259af3094c6378f8a247feaf08b12b93dfddd3546ad7fc00e3584eea3f3b9607d8b8edbd3338dc564829473750577a6cf454b0f3482f31c361de24981aaaf1fa04ffe7af28b72b0e390d95954333ff2a7e5058a08139ce19bf141f35161690207da8447e7b8725009992ff90474fa08d0ad3d16bfc3cc580b3a830b135e11f011c5ccc3025da75ee63a6bacc57bd2588988b8d7a6d91ca683629a1db3c09b4d0a77c6896df40bb12133f6a3c66a95e79eb8b40a01137a4fd8b832407979f7b327edd4ebbb9570f6c0b30a7085c2d95e9a63ecabc6e4168918876b0716c2cdb810f79e2fe18bf5b8f817b90544f60bed42ee06300755e08c31502d4657e592594552d321456b9accee333a654714686f8e611088fb379388000a7537f8d6a1f5a6cc292948bf56196c851ea6db938de70cc944482f4350bea5349efe021e923c1b2c7801bd9ef43a003d2216c0c0ea918eb29feb253540f390f06c01d61038860385bd3515c6fa7f36695ff8d70639357bf4d8e4f861eb72bb174a389457eff4373b610a13f52f1b5cae9496ba2d3794d4f776cb1a78fd8f85001d071ca68389415ad6dc037beea6feaf2424b896a4fbb9a7e2d1b9568a407e21b97d59d23a082259c7629e2091ccddc4a73038d4556e8687811d41d6a9a19f43d3d190fceca303973c1ee5565fb9affedca781de8b6ba8e944d7041128a86852da3ce4c5cfb64029a8515f97c59c4853be39adbbee74b5cc00abbdd42f68902fd78138ed6017374455c9a47b78b62c94b748a70a43ce7ab7575c1b76d0d039f5a92c9eb8aaeef7ae066761011dc37e973c55db2660cc51396266cbaf9aeca9d2df9b68c792f3da77e6a50a1694bb2a43025ad134cef6f56d1030c094c4573796fd6ab5c8bce4c678eaf749f2bf34d8075e1d9e3d2b5a95b207dabfdfaf672329f083de3c3177a4f7c27f56d97a1e4bf56995ee1e2649a58e3f6ad5d3749e4f809d5f569d27ea933aeca34dc7d5e2e9381eccdd8939d268b5f63ab1fc56540d5a801f45df9d941c892db4bb4be0d1170b5dfd64ac7355f2687365e279fa3b5a420367c77816e78746b1d07a35f86377a94fb1554269c21c5a01d938e43ecaf19b99a066817cad63ceb6ed71610b3ee56547b5cb923bb32dc9755b69449e45a2d3ab772f3884df2cf6c9177b6233858b3b8c9d09048073d00031809b77ecc1c69d54d19ce5fefa0650d37edd1eb823d8cb7d18f6ae45acb03b5b7e728755f817e148ab39a38e1c9eecb517783c6781d466b3838f742044fa7ae2045d412cd2aafc7b62b85a7ead56b2c759f05d8c040b6e80d870b48891f503760eea301952c6c8a33e4e82c47f6c2ad359db2e940b2eb1aa4bbb78ade427d19fa921d25e40c9c27e373e9c0919a6bdcdf7bc3ad8d1fb8d55194ce44a9476f92493c702a3b1cfd1f3d82c9304cac04c1b7ced3329e6bd0fa85113b664e2eb2741f7107104c9bbbe582f393f2bc8311cb4fb03f12e554c1c5ce30ddc57bb8f34fd79aeadce858aed5164ffc2766c7b594e68756ea879f020a9420e182f6e44298c7669d4a41776462d0d5254eaf88fbf34a7b8939eaa583ade0e25b1a11dcc1ea7698e3cedbfbd5cd1c878aff04312413aadc11cbbdc830bb7408d6508f394bc257ce1955444d7bf6b9b9e72fa91a98404acf72d3d1c714ee20d3257c1c5421bfae95df9b79b33fb251d026070d0f4effd4dd046520760ba5eacac8e6bb647ce747bf51f8880831099830fbaa108053a7943f0d4d8c6680a3013b95335494a7cd574de0e9581a74c77d4ba832883f4a5b21f4692c15727a27b2e72f615331c6de00b1bf18a0103b51ad9bb6bf8493f4fd793e93150b09ec871b829c2d0811dcd3b7d912400b5024c134daa977d68883890ac098a51be2d20fc931a471de8af5c933152904c3eceba0abbe65df1d7828efa576daec85e78c270fc1b8a10231f9942087babf19085cbebbd95cfe7d543b92f2b97434a349019edb695dfaed8f6be348b87b1d0376fbe24c6faf668c4e4607fb9c249e58bb930e9ef4540b31495be2bb9106c131923eb54fba8f246c4fa2f42f9b7be5af0749f5335ff96d0e59990f9eb89ff7fcb5555f8df16e57cdec3a73eabbf4281ff909b1467ddeb69f5930439313f8c8fa0541559de30232226e84fcfe511768413ea5997b6f597db2325e7eb8bb90a59e0471d9c6b575c30790ed40d7ef6bda1e89ce8304c2692ca8908156fb4dd79f5299abf4e4098c96d9392bf9a97b2ac9056edf814ee86d1c4c43da3a720f6cae052b3b58b7460788c06027c796bca942a46869178103cf28f5d14bdfb7515ad92fbd1a141f8c956e00425d2301be454bee6663582d30d109091ddd3b8aef31bb3b33e5a29ac889c58880f4e9d04fc99bd2fbcdb680591904ab3b9165f0e242b4aa994ecc92ae50b57635d5422dae17ae4f5fcebb808081b5658475d7b325f59d3c2c1bd026be9390a29e00cdade86617eb601c3cb9e4e98a72baa12320b24fb723fa16df5e7b887bbffa37b7a725b512ef3ca5fe96825e459f2c318b97771ba0f446db5cb8d4b2ca5e61c5b7180183526c13e9bbf691ee9ec4a2d9d4036540f70d7a8fd5f516d468ec4f13aaefd1574193aeeb049abc6170294cdb74a266cacecbd90826b3f7be32c0ad4f40da4a4d025b7d2bdef08a1255e5c559962af8d170bbaa5beb72e102024ee020ac9424ae8061bb739fc571661c1efa54f77032d7db9ce0f15bb6fc413e1abd1c50b436d7a0d64f894228979f00a39c90889eeed17f594583355b4b7ee1b89c225328ec72c55b787493d46bd89c6e1ffc672ff6d0d8c90a075e9811d88c67494c1c2e986dbf48f516e3c9ae390e8e9c28a27b21e3c07aedd9fa855e28f47cb349191924a09a1e4f7ee37edfed41d344974c6dfb1cb3f4837d58895bb9beb3308de100c981a449e8b1fba5b7d302727cefa098e8cdfe2618497dd0da5559e5400b973c3328a286a5c36995f96ed87a646b5312f0cf046eee4bf30ddc814661be75f4691f9c1f3240a6a8cdfb4b5e4f6ac918c89f389a37778fd23add093fd24ec559030581278d426f03cadd204d84f5e830a25edad2ab4a5bd2d42707af858b5025f61c3be902087f85a3f27c282cd4282a9f686fdbe2d4bd97984ec66d12be2064f99c25b03ea6a6f4f76764678b75ff32660c6d8754a45e1f9e25ca9fd43478bb62b652a14f27309c31125a8c8d76840fbc3427c484fd8a3b7f6536653087b934ea7b7fed54344cf9e9f8add01337ca939f1ce1b703db17cf8dea6c973cacf566093aaaaa7a37a2f4bf2ea860a0864e03a18e68c69fcd9353ebfaf4f2cf1584431404d3a488b5fed66b6c8148f83b1207e10bdefd78496e22d74b3c5dfef6d4c155e2352f3728902763026baaca29d25ebfa0e943c45ee16533e9da08fff0b817abba550ea4b419c214910d260c7092e967f71985d85065822a7bc7347e8a3bc70e505977b070522b04848693a7e8e79e3f10e4c57f8666274d99ec05fad7b5e53d04dc39a7e29910bea90e09f909fda565ae0300be98594ded67be1cac5fa1f8d06c29c49e3fc5b61b88cc86e2a199385a6bbe174dc692836dbcd140f240240f0a650a495d70400ede0cd37d7e76f741a9fe0571b888c957a9c7c0ddc7301260a187ac0261c22410cfb09c488482f7c3e9721f5f9f05140276c4ceb0311a205b84ee1ba42d8e2206ad3f065d4732eb72d9bc33665c5780d10a14b2af061b226493ca393f1118e45a3658fecb8dadca87386a6bf56e49c63398454d5fec728430bbee032b31b5d40dacc5b8525f841370b6e49cae1dd9c42289c12816290e27436e3d43c816d154caded647cb6498886d927462d6efb3a6747c7e55a27a9a2275906e363de37e3e36052151b57a876a029b0d30092e5b4a868e515a6cd137cf92247853ee043bafdeb9afa110e61724121057a87bfd476e0dfe784a0118936dcd0f8619f7c520a0b6761fe91ea053f7da5e93573e0d8d491666d4e5e7d41d42951e05d7dc5a63a8f5df29337ce6198e8f065ab8e9995602eb40e65c3a3e59ff89f31355090edf0a0f831a6d7c6c31cf75fb2c2ce0c4f10e8b7ed035fbeb33d6e9da533ce92b0ece07366e643412146fc989b1355b3891ba57850f916cd05f327b4dddecf2d3e9a1487bde281c88e393aecdb702c94ddcdceeb2d91284378677eaa2387e999ffe403fbbda9cd07f04ffe76a27803b66666a3169c55e89683cec38aab5407d76ff9733d617314ebaf569f2a98f00c188332bf3fe42ae52fc829db90296c7f959e2483ac836e7277e05961a8f69915160caeebed39dd81a27f49a866f812992ede43edfbb6e02e8815dca2260e1413e02f159b2193a6e76af6cc739aac878aa48450db73a4f60ba12c05370bce07d0d6ecd6a6f2e2c22e9fe432edc74509ebaf54d4506abf18f27daf1e78dc1f6dcac9f99cae900f8b968ea890f07f7948a516c9e5dd66e603a8f78feb5872e304d3d87c2befa367bf82d35b9493a10065dbe22d1a47fe09a70227bebc0feeb1ca75ae14da2c9022992fc0db4c76be9b8827d4ddb318c6aeafeb03a68708ca0c4af76f11d03fa8b06e9276461910b7ab1ae5782e0c450189e6ffcc0b5c9537e6a4a6d6fb646ecf63f3c30616034b5076a87ed0cf9157b0fc269e1e8a5492eb571ef8b0cc3545e43ef61e6c3f51a98de2f5ea92d42135c049be71dd7f5ab1b68f1befbaddbdc703036c7b95b738f0ae6ea3416004cf38018890181e65246fa30eb1bd88a6483488444f153c645a8af78c300f6983d0679ea5369415c7c8118259e61ef421340e0f4c4ef2c4c4f3a7853d2bb5fc008dea0c5d9f981916469827825c3b277265bca13479da33b19bc91916e9e71770c432e45d20890de89bd9eaead977030d5eb30f9acf9c0bd53ef571bbdbd334a141eabcde03699d4523a5b9e2490a74831ddf3fe69ccf4455c94e4f742215c6d66d40dfc60d70b081eed2b19434e299075c599b488e8366c9e1ba09063e0b23d919f435dd3027dea425ed27dfef92e35faa20465d7b42d23345c2c53df212525690772eab4c58c544154a7287b7b0dd26f78fa7daa8e382a37a8aaf835fb44c9aebcf677dad59788de39f9bfd73c90794b2551bead5fdd57f4de83b3f04bcd8a483128a060916ad3289ceb666aafff1d4aaba16f42ed8343ef0782f3c5561a6178e408575ab07e5eb2d9f2e288ee7adc5d6c7e5cb42b21ca85f910f1448ec0360934d60353e23d091db2630cc9a3cf598b7deaa0a1d830f849ca7a0822175e3db44de0205b3ad27fbe4f15963902bdc8705db17fbce0610d4cb2d168f4070e6401bfa3c54432b6851cf7ec88698760c1fffa74c6b191ccb119030ca654661913e73bc3f3ed94f9c722a6334a01dbcf6c058d3608990aced7bdb11d0294ab49f5774167fc2343aac6db8c179a3773c43163ac8b4cd3efe58a42b21ed4c31db59b141fc3f9a32bee5ffdb0b8ba1c39d703e68c6e61684b31658ed50fe0fae344160a301ef3596cc72816e14db4f0c0a7956a456202c4e68be0af7b754d9bb7b425457d9127357181d1978386e2e1e5c68867ee2d5206b3aa64a4ade679945b77406ee42d1d55ca40d03c4cd3ffd8dc81438a01d34ab711145d10ff46addcc36a7d2018a89c4240a4dccae3d2cd9ce07e92ce9749e02abb009bdb4ef8f73688f516345ffa4e8bc8f2d190012cbd03b06dd0b75e83453dd7878e579a81ff9649eb6c96e6eea5ac89c5c80e38b94e87c11a71176c25c871199bfad01a6aedc2a403e6ad66bda8819f235ff2daca637b9f46657c5b97bd54a879bea38aa27fc84fbd5869dd8784e033b0f3fea11da8683ebd19785988fc4eca53c3b754b6e9980ecd56740383460af34d1a316da9ee020f205b71acaa3cb51c78cdf773ad74d854c63e7625f5d4bc52976098ee1dbc6cf3b6c62864b9d8cdb62364ccede0fb6f7f50d47f2c5a2606da16bee33d0c4e40c9ef21108fb184c69cf47bc4c6c612e7fe61e09668f9f254adca0454f459bd825db28e49acbf3059164f45f17e4c31f1eca078bdef78cbe8664ce84bbd115b726fbc3186b8fe67ec28ffbd5f42c4ed0f15cda035c140f7de4eb5534543be169e83360510eb5ef1a9859fb2879a14385a7fee21630fe471918a59ca3a84dbce523d02e1f08bfaca0d0208038c6a993bcbeffe58e561be3be37748fb59b7b8e660f1744fba27358c5f9f3d0cc1cfa115a55e4cacc1f703e48e4f2d7ff984a1d45d21cabd7f6f4916d6f05954606eba5f22e86cfc1705292cfc626f5094fc03581c6b0e43a8de80fb010a571070a83cce04388d92b5293791782cbdbd2ec2ca27071688cafdcd0e1d73d4c534c42cbeca7eeb1ddcf2da43531d686b1c156eecab1dfbc25f0efa14aef39c4f282d7eb8ff80d1976fa264aea1667895708512bd281dbf02de335f2c0563b953f086dde71b696c3a616d1f0ba0e98fc67c9f8210cad1c8924aaf0526b5facefe35bdeb918cce07710bddbc875d4788a8fbb04de30611120134f8ffc512bc4e6475115a62c40282fdaca18b6c77277b3a5da1af96889f793447a633902783682480388f257d4ece8e9e8d0a976d19a23cb180e7188cbb2b98343db1b689490b902f8268dad8b4e2b925dc1421066969910cae3b460ed7c0e1a1098ea6ee7eaf2ab7c09db44ef5fed6f53c0462faa482d34f8c9a7f070f9c550e46447fea177e9a895eecc0ad905e2fcbf4ff3078c19cf70480f278ccccbbb596a0884b76ad4415e184a0790b93cd479fbc2864a60aee50e9e0dab90e25103f1b9a0a52ad5b9f5d0b9cf88b87612d01e902d757ea438cda090be4ad8eadfe57dc5658b17b49cb3a88eafa19f1ba39ca7ec3151937eea60541d70b6fcee1e962235ae03e0117f342b55f289df9ffbc5fa6908e5a69b5b54134e22da782a225a58f3b90a8154722b57319814b296a0aeca0e0c964f0171143c5cfd7d86e510d6f83d0fe89698f61e309ac65773197b22fe3bd46a88eac55dded45888cc2132eaf15b44613a06bf29fcbbfbb6d6a1567fad42fa8272f650d4d55f468115b1a0855f8f22aec90144a0d5de9fd349717a6edced035984e38a48f07fb5df88c12ed5e2cbf9e7806a4540f27b66a8df89ccea3ec5a6d48d2ac7c615954a49861e8306f5b19c9e12a8cb423d789c48c89144719c04b94b00950b36c7e1a863eee4a0e75b9a9bc029145bb599240665c428ca3ec0c20cfb2aa4d752aaccef3264bd83ba4cb115a7f0e54c79b172e6acbaaf08fc4caf7ad322697275fd7892a01bb1be6402240f7e1251c196f9f8035b8540fcd8aeaafb080024a05e8f40230e18058986c5f961671c989d39c8224b61d186748e75d394e1c7493dd86a693109d19db2d6ab2b68db24e930a9f5ec79d4f9e3c0ff90384ad6049e2af209cd34b1796daa8a515c23ff3fc98b858c8cc158feb7c0ec083d407cc16617dacbc4208ad5fa2a290492a0ced3cdaa9d42c78495c5d2ad8a61d692b852a16eab1d9995aa94b0adfce9c7d33928bba567274d3eb4e235cee2e8bee94169b17a127b93e4dab4f37d5af072c4a170fff6d5596044bceb997931646a05921290d6ff4490a31544672936f0efcf173b3288872a13db951eacf640bcca0c4b17320c2a32efecd0b4bc0efdce706fe70d052aeb7b321d8882b306f6cfce8496838039efef6ce85c1a0865b2cd158e23d8efabe6aaab8f37fc66a2a14b573b8ca9f9cfe256f14fe7c17c179ddace7ee5e20d03a9d137276df1bcdd03255c3066d9c2d2aa1aeb492f2ff3c1ca2278355ce59eaa1c0ef4d6d4019c7fa9fa53d11dba114adafbf40f9c6dc2510c353c1482a03d6e071e3465173100a83a5a98c34f53eb3da870228b835eeb810ee6da3440fe7f2b7deabe02821882339d3e6cc5ce3a9cf5d8aeafcde4fea12427041a481dadcdf5c620492c7fed888739d7759827033724cf3802866da046cb5c357f18f2d723fc7aac4b6758c58b0194ef419baf3ca5fac4ef647e629d28b29fd08ae2dd357bb626a99ba0bbf710521a6ed0d77fec15c5fd7470ce98c4d72ea80c54ad79f81fc252434a8167b276108abe82c52295665d9642fb91e4ac60d22664d840e32231a4601b326b2169467f9cafeab2e2b70a0438421bf5c66cb09c013d0464442a571ff877fe74e20979f4da7b357aeb85560de38b6e0e1f26b761a3ee80ba1643194244f5f0291e05c8fc654f074e4dbf9371b12880ab193b510bc3bec4b727ec8693b140f4d2c41f68d703bde72da8cb52f334c13fe990d51afa4602803908a7cac2d2207dc2a9cb792fc6c030aa4ee2aea19b05d7a7ee07ced6ebcb00fd361842e52aa5b0b5ffe9bbaf833e17aca915e1c0a13ac726ae6f1d8334cc26f787495986b981d0df7985f0114fd3c37616c50b1d3d489c5a501e9cba2554c0dcd01cbec976bebff0be22278f1d53a24d915c8b1380fee9402c8d42728fcd2cbd160bfd56f63483142669f10a816f29e7fd471351ebefeac053b47e76164ddf6416645676e526c7805713d7b2cdc6296c71ed6ab2db1b8335b45480e32b934f2ffb5952aca86a2d917656c2038860c4826d74e6b3dc8e427a4820df60f85a2bed72ce64638e3fd35cee76710fd0c29c68689e5ff754decbcee1b42c4776f1f2af8a4de6dd339ba0ab84e36ce40a4ba0229266c87c2e803eb7c752d413254be4c0bee8bb8d2ad7dbe9a170eb0c7bdfec07c154f12d1106c244c7f5bae3b43c7a2b3b227091d8a5985ea5639ec85e0ec06408185c89821d37d14bfc2ffb75ed80bd15bfd1e40662e8039d585ece1a29c7970b9bd43c1d0209fc9decf4ebd11288b58bec3f939d0f50678b469407b089533dd4ef1a2bdf2c93c42da6fe54adbce4ea86af6ea1fe7aa17bd65b1c1c4f2f8ca2b57ecd982830d38fe72978957809fc7011c88e4642f41f77f5b82cdadcac4d29c7ff959ee0c92996d1bf79730a36f5fca3ab6fbd9f90404820edc8bb096e30c691691786a202a23dbbda17094d0a9b922d53c10c5acdeeb6806e3b8a7f92c5cf21f994ac7fbd01caecd029df3f4fdbac44f1edb471d95e59a6d47d3ab8e7b13ff3eb02b3ee3b04dc80124016a36e0ac01986a0b6839f782a0dae900c6cae11711b573bb4826e702e8cf99433c063a44266b45929abd9f017e53fd8de85fb893ef11c284a5476b58a04306e7d2b475dae13c6851e298d247b678313f138a40614d658e9ff466e659e1a8970c932ef55cf635996cf39961bf52042975335ac04e4e2ea8b5066aff1dc3fdaf157c19f0eb0e5c6f406b44a6f991a6a53b75c1cd0e7158884d8cf7196e81e53fbb532c9486c7fe5a665484d08fc00e8f594a07d214a0a51e7134cc3cfae7f9634eb8fd8d228d28237798a090bd51a39411000730fcf9544493aa4292f187e7f6bf4cb393959e6890570160e4ce8997b030ac483d493611de35eeab076470e230079f5267eee3fe388e90b723308d0e373f18f2f990525193ce409f3be82dd3147e4cc24340bfc413c1a59428a3ee0d52a968c437440815bc27bcc2edfd8a119703c933e2a23fcece2407f16faeaa7f6108dff6eb5396a7bd956b88a6b5918e98ed94735065af62609668f6314da0c09f80356e424d0f168ae54e0e35f2f623b75adc2a1f3bf24dd0fafd166be0a89e263ab72a68cdcb5989bba097685058e00531d65fc9977f74a604a73f884ac8cb5cbabe30930d0a78198191a3d339ba94631197c16f55626da939fced990a052933cfc6ef20491c2f4ac51a8753933e8f280a6ca1cf7506d4f978552bdbdc33cb10f7ea82cea6e254106e68bc4e9fc63ecd05f81ab667eaf76fa23ccf71418c8921fcd16aa26a0f5b4ecc51f9a9360003c72cefafa4c90b89915cc7590550b301791a23d4669643e12191d0853b3c0abe5eb96d9f0b4fe81eac53a98fc83a1baef0c177fa055bf5c4132ef1b6638adbe7219238d252715ccc15a5b519ce378d055a5e6c1d85ec06ba96d1aea9d580c583cad435f2bde33282288cb813cbfa3bc66d5f6e20827665937ae0e79a426ffd90febf6d99db2e7aacf156c8d61e6d726c15430b326cd5cd034a6ab01c7f2a27bc26f93982d40db90d4c39b8722ad1207217fd0152ab99c841fae75e12f48be1065fc32c617345f3986c24d97524b24c353a221d550a5b0b45f93a37145a1dcc2988428d0b0d1d9a5f6663495795b73ab95b2923d42eca05b5f681880b8e088aca59178d429b0cf741dbd00ffb1b654ef1facbda07fd7b3f799f91c7c673ebcb3242ed55f13d143d624888fd7e704fede2101f1c2b35acdb69ab44af12160a97b0007331d315335207a0600f3df9b5f03b08d72dc2edc249e4fa73d708ea4faa7e30872feb50a88425e1046e126c42f2029ec369ffcd169e7858889dc2d739b57da3134a6ad74ef938fb9d0ccecd0bc9d96c25a9a1e7516a3aa913062c0ef18f9b649bccb6754d742d5610737d5d1d4ee7f83b1ca520b222a974bda7ae142c2c09f3ede9c51129d1928ceacb5c3b8d77bae86db67633727b7039d3facad10e7fd6c27603116df82902960145f8b2a0dfda69cab5123a09efc82df0d20a7914359983f60333c1ec34d48c8407a894108670c18cc887bfde0523c2bb979fae423f92b6136663ebb265acd96b1d094d5dca17e462abf3feb9d6b879e6d77f7b2b074a2579f2365caefbaf4fe14e568e02eaf1ccbbef10a22c709fc1a0e93e2646c5b69434f0d3384b2a5e00ed16502d9d7fab471bc01aaa6b4f4e39bd940e854ba19dedb8df540def21c7ccf1299ddf4a22b132359ae1f6d8e7a5836b0ef864ebcd1152afd15a4bcae8554fa5f397429276e7c1c9b9ea54d4d5cf67df17b2a1ded8d20728a98917c38b31293f9bd01cb8794d6d2cd4e1006a961ba671429795b98b258ceffc22111520b38ac16413ff1a7934270a0da80f59da0a6306d18d37cf3a0b9c2d7dcb007a0785f20ced7acaa24199a6a63c36b0be7f4e545ce618f73efd4462d512247c8e4ceb6b50626518828ab334d420fec37df5afd51473a69dc206ba1957cc1fdea2b80ca46800408ac05279d5849f0d368483856ac6215f7c7cb1ef6c7673bfa806f576784852a6215452afdb5ddf26399ca2c6c741f0690fcd4a752484f1c31dbe38ab7bbd4ef0921233939d7c7f67ea068ebf4e94a7df505ea756b3fced2f4aa4edf7306495a7949bea09978fd1434516ae067afe694e3b2a90b9ce78ce73d661f524380f102d08cd4b14fd993c874841d3b7679e10bfa40c7ad30455e3f758318c0eb17d074e9a5eefe2a2e2351d33161a0f33c79848a636e3b11ade1bb8a510640368ae7e97999f05a7c7574fc09a528bdabc4416113eec812f79c8644fe30dfe3713db22d8abd324fbc7d8ec2465da7cc49006f7461d4b5be71c72ddfc70fc0fdf178485850cc6a5b619beb8ee2a197565385b0bda8bd55a5651747c5b20c91df72c601d31e3a488baef943b085c79782f444a661cf4bc42a1d34fc16283aa31148d623cb675f7c3805b2a6c28b87f3510cb6372baf599904f8a30064b6981fe804ff8e9219be0a715f944f5bba62838dff125e81671cb16a5a2c377d1e933e1d67eb2c0247465c214440ed24945a6a5cf841dd7ebd81fddf210d0122adc080504229b986a9352bd5b4c9dd148e1055aaf5db966bc8c8dcb73a77a3386e53565feef834b17c82b30fd5e69bc0bb510476740943101c4a89b163cb2b9ad5c7c46db84d91d6493896e27df35c3c77877fe524d29c14915ac32d2543d96b15bd3bc07e09921cd2b0b788326065328ca2b7d4fbabb786133a96f2699ad90a2ca2ca7d31326f590abed71bdecf3d3baa01bb0c5","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
