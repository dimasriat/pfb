<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df7721eb62fa6e2a8a54bbeeba77e841bab0551fd9daaa93dd605d97c9e5fade9b0c47ea9b458b2cd51ae8ad2a40f44131db3aa66e047622b0c1da0a2a93d79891e55a294df9b323423388ab9a3528670d595a2504c7f972ee5cdba6f2af231e10a71a458c7cad79ae21e8911fc18653837d42d4b92bfa50abb773587b3bedd274bfb3b260288ef60d3a8691d547c084dbf675f4902a85d10b971718c8a0996fe7071a86080312b78baa000c1cb1a6d8f4985923aa2a494935c9a6b07049ee015f13eb3ccc895fb1108d467777c1a34e4521db17331f42b6a51f588547ab86fd0324fe56aff1464134afc0cd15d90bc4c43e38669ea10f41ff059e5dbf2e97c569368916909e07fa4722bad0863eb6de35ab6a1c2ea04cdc0328f86c32e0cd6590730cf8c1ce656895c80d98b9a3cb1b059a8395df533d78234261142f46ca7c009c0fd099fe9695f7927461c36181f7bb93acff6d76d61e67a1609d38526fc5f421ab71bb16a1d2be5a6c811038bf5e9208bdb299deb2fc7fc474699fe310efce7ee7c56d282384e6adb412d7d9711ad0272e08b720141f47784988b33e9201d165106fe047c3e5704f88e52bbafb03ce1c6a7249d8b5e714c4782b35816f9c317fe3b5e737c321b08ad53d36ea74b798e01e5d7b1ba1a3c52dc146fc0d96bb2b9d9f9a89862c96e1fe5134fc60e326f95d88361ddbdb8299c658edc4b076efd0c10ab77ee160b52529d57cc6df41c16f62b866efd71a183c9c47dfea01c2c48f746badff8aae17b2d06551b2579bb4b03907fdbc9bf6778ac0413ed3b28d81fe522eb8993c20a1b802e6dbc181356f70bf0208f6780751ac07835981cd0074bfd83d005b4cfa09ed2d36a9609a5764376f1815ee577b8be0f0fc6c734fe719b8f1cffed2b94e444e92024cbea330d2cf88bb8674c8035436e35020a505190fa4be3b643e56fa0fc77221e4c38bea975cdc388feaae5c3e6f9ba2e00f9db873945843ae1a8f16cf1102f4980a70bfab5dc223ff6e675651885d0d828cbf44c5ec5ada10bf14f0f63257107d34f73f19c1bde760de9755c78d717f1b5e5001fcfd544813c2fa82463c9d5ff31df6b860337f037e3f778762806d027024ad91462d7996e58b0b40823559301423f1f785da49f0c731d55c8ae96e8399999fb6ee571752fd224c8e6e182d7bf6573570689bb71d3115091b671a644f562a0fef876f7169c62709086a6c4190cdf3f7850ed1908d79b8677a5d094366408995cb5fedf908d82d483d4eef2e4cf505f1424eadefabf4b3e2c53e0cf09483fffa4081515e91b094003580798e674f4ec4295e1298d3ddb984695de2839e6513a6bc31694c89afb11d382facce522ed372df3a6748ed7384d4a7cb1d6c3a7456fc48c4cf94faa03acf24afa28392bee6a3fee32450ac236611fad1b90c79f82ec4839de7afefdb56a7b506437737214a316b9b0cc84d09d41edc8e2962022a60a122dba49df44dd301be3ac4d47302b2e1567e149ac117c1354bffa2326e4dbb1c45953d7505cd7d63b63ed95c53f7849a8a17013b13b8728bbd64b80e10a9baaf5441628aa6df119c4ebb3b9178138e874ad67a469299bb1b11d2e73fe8826ae4b463bbcb4704f7aabf0696c48dfeda5f9b7e2544163ab524fed037100531018479480965b7985526ee5941eafaa0b8648f01117fd93668cf4e1e1eb8bbd83ab94f77dc095da93dd31f4f5281587a92efeae15a632c36682497d66f6153225de42d11e7501af329d24185c71509495d18b3dc4a9f1b7b663d37399f5983b181fbbd14c44957eff30cc010ffacd77575231a66c6f013f792452e8b83b8f026de6f848246c056989c290515573ede2977c4097010e5091267c710fdaeb335018e99b54cbd9e3127e5dda91f38dfb142a6e14e28f98c5fd97ea47908e3d6fe128b4712cb2509e761b77158926862f9a2687168d7556fe26ba8d350c29a821a5923fb630a6f2b080d4202d0de471685274cb1202e0dd018bca4ae1e8706e963fd65ed06d824531cfe48ae273a962eac48ce81335a2e703466fe8152e9fa17d690bf80125fbf6788d02176f1d44e1fc5eeccc2122a9ac8aebdbdd42b2b8e7622d2bd15fdeccdc0f6c93f3eef92c4e22aa9e0ece5a4e5c6114bfc90462033895864da160bcca710b2cb36b298b3d7674fda5997541f94bf5f6357511deb40c223164ef44ac3e34038e1ed1a852e603ac2b3cd29ede2de1eb7ebd4b5c62895434babf19a48fff00ce493c60e867c9e49c7f1fd216fc9dced14927694e7853384b11ba43a9a4a1252b52ec193d19423c35597c0769f77a0d7f7802058ad7ba7fbf647e3468d7f1fae9bb7006adc45892f73ad2344eb966b93f845df2e435c3f8953141b507d36692e77ca720df7f8f251ee6082bd20fa060b39e6c31046752fee0ec742abff903f98e8ca7f3320e756ebb90f6f9d29c49d8cdf9830452c835cc908da9e41d290e322f92461889223dcecce76fe480ac8ccbf8ed5ca598d0088414daf0d9b2204d915bcf69c3ae84611c26ba5b54d1248c064f8b50b7d321d0e5351a3c88a150adcad82df9c88bd38b12adcddb18c6ed8da7ec3be92f426bac179bb5b92b5f4e01a5035e70708f0527cf4155b174906e0dda23342cdb4cb516b5bec0eec5ca4bc7ed74bb0afc1c8846e8417a661f6073b94514b7a8ff64198c2212929354499c550a259986e68673de26ec0fc71c188608dda75b5b875f5b8649d5eb7dfec60f8552b4eaadc1b936b067d74074686f1b383a2bdcf991abe3fb16ab6b3f5d54c367226d18dff50de6704ed0f8b63ffd5d23ef4196444fbd82ae6477959ef26b0a3fc0c03e0d23af3937a3f8f9790b82651dc1651cb77653ac4ef20d87b5239c5cc7c06139c3f37383f04fd50668dfb03b68fcb47fc9300572b777e68226e869d5b6fc85254541d252e4096bdaba83d574e8fb4b0f53ae6fbb0c34a96dd4cb8f2cc5e1788c3ee077ee1de2e46adbea4e1e05e9ac512de83832046cb7110ae1b85b762e9710a00ed9e8a273e5eef85ef678dadd26a78a611a5b59814e722ef851d5ee267ca985939e339ec79ca85494734d48f450eb3d50ea4a1f829a984a318dbd0f7482f67e6fc1009a9c524488564a94b0f2b45708985ced2e4cb726229933fd63dc14fd05fd36aba7a43678b0ee6e09c061d34fe795fa35f96e5b650577cb96fcce2c104efa630226661a8dc801690913583892260c3d511f88f523e37cae9192c9a35f7341a6618a451f37ddf1fd44006a92c8717151332c322824b41b0d9a1dc46397874e29798a3ad9b59aae16a1f4ff73b4e04aea77fa9dbf576dd04da363da44f60d061dcb20104ff8f06b3606924d9296d9827583f399535905ee7fbebc3093dd083ced6510519a3ddf4e02b59b9bb166d4a4bd12342ea90acc6ce4f7e7e97f5a4c9b51a12aa3632e46786bb6034b7d017e650e16f062d6363124cf2cd0e0938cd7dfb6b1255a03d664d6c45f171474dfe01cc68efd6d711629c3609c0b6cd01315a39ef3f97af5ef3bf8e14f6ea66b8ee046b57acf0ed948c59fe5a5662d4a81b9338b95b6d0d73458fafa438a1aba94be99ef88419c8a606574f74e50c5aace922b4be8fbf5335a14e34590bee48ca3f6e92b1a730eab032c1b81365ad22f32aa910b7e14bbaed4d020ec0dd959b5518b36f4866049c3b9838c246b9be9b66579276d514c127303142891e0ff867465e2358d3b2f475eec80adac41b0c9444b367c69a5fad036dbf8aefb2000a92ad2d995970885611aba0ec07bc1b145eee2bd45668b47e6f1bc83f3e0150c9786839c5c3b32756e5543f206091ca7a23790ecbd13576070fb4f9dfefef7c85da07f11b93fd7b8cf57e867a00d9dfd57ad733460a1511c977d24f3fa82bc4f52ad5ba71358e6c852c54e32b68b1e0a5255d1429bde043444579ca9858da4220fafa240c0d46d03f2188054b24a1809ccafa574556e0c1daadda72732e33cafea4e8d7b3ea0787f2f2649a2ec5333231956df690b0b91b7240dc09364c2877e7e313107c61164b4a319bec0a39adc8ebf3f7589de966b610be01d3ab080db2f8801d78817451a831a32e71c168f9b5971758f69592873bdd98a38149d2e04877e7a5659c3b15a73fda3c633d4650c9769589619c502c81fb84f19a708c91aceddc42d9543329aa8b040d3e20b322355500c9d8b6790588fbbc90b8f399ea30db039a50bab57f5e9264f146c16cbdb790f47a601278f459f15b36672feb79bc499e0c972b179f37f9643d375d8ae5c3634175153589863a37ac2f85cfe27ab362ef5658f1b1c710912372a26b0ffe70e27835a268217e21f5cd306a5a69aec8bf217789b72f26617d92a3714049445f573bcabcbc2b8304d02e7c8aa68e35f9bc9c4d9fdcf1fdee876072cf7f142248c79f7c7885277d80ebb652fbd67974ae973ddbab2523d2c35ccd83a0e60d6546cdb647b474b3a6cb5892f03dcf1e4cd875899afe287537b9e437f9ac20ea3eb4f3aadccaf4ec3c16f669e454f7e95090b7998500359d120cf0279859d5a0220da189798af7ea436a8e2948ab7aee3d8a791d2cbc867f1242b7842adafa6080137528d8db4db63aa487269313ab30e13719d63caeffdc3f44e237044ebc6529d93be1d5b14a19097e64d4014afd62dbaaea98dcd27c0ee2478237d0ac3005e3c11dc39b05278f5f8ffa9d76343567ae515851351ed9dea65c336399d56769308628499a32126bf804c071ea2d681c9bf29e047b07a8cf538a762222e14e535f3460b3606c7502d3d3094a82cdc445df5384620d4ab0eeda48299915747276692d48a2a8825323a8bec69009f92ec9bf3eaf11e0e868aae487ab5fbd26b669a1589554cc79ec96814da19a04253bd89ebca33cd18cc937dca0d28aec848cf18fef19e826b353016092901f51cfdae0ab2d26bc258eb9f904c284a77e7c1fe42d892019d6ac31859b9bdf3c9aba4a47d27bd59368ec620c6dd39f54bc0e8e1ed7ddf1b511a2195b6978c7fb48ce96ab7dab8397cadb2ba8b5b76f45d77069d6cde073e24317ea3324513bc16d41b2716f85830561edba2fa4023212f998e221ef5d081f89394c71eea2793b19ba2a1f2efcf00c250c378ac7b9e4dfde51805cd33241f7ff8f720a10369ca29438dcd62e738bc7585f7ff84042f1fb78620d5658ae4efae0bb7325ff33c508ae9e5edd1fcc311c458f86ab38c15bfd5e682344273ebb2c8f121ffbc0764bb5251f62225f468e6d052de3f51d626a4ced6667444ac50c9498a050dc211307086bd72ae27a07ea59ae82362e4d48d73bea8e44e117943003b90fc8196c876ef6fe57ee39a7631dc63011b531d6578d26ec31581702b16f8067ae864100e95b881043564b13b0baae5b789564151935e9b1a7c46386bd5e9431f63414ac54a0efb315ec80e001d5de7b002fe05fafcae969742fc0c65cd2e34e65b81422b05dae5e39a6f9a000794b66a0d1cfd8a917fcf495870b9de124ca69d284f246b209b4ffc66555bd0c407059f65affb87ebfa874bf7925dec71349d2e2f9d4942d163e43ce374bd0f88f7d72e24f00d37f543786290b102c6aabfa8b689b2790c967fb4fb5c08a08ef85fc61a79f35bc3295c5576681a720a96214e2a95a9bd40ecb6a90747dd7129aeced6ade270c4e28df27e8eb341b93643a2cbc6d57b010779778fd0fce7542230eebd42e5eecda24d429d37cbe4f00dae3dbdfdbc777711bde763f1aab6469331ce652a0d037499f70878940830546f2b5b744414a6d5ffc0543187c825e8cacfc2556e15314e094064699da3e534be255568a750f7d325ecce30a2dd74744989ee1975ceb4a5bfdef581a9803164d21a598a6fd9ebf031859c1fd35f2a63418c2c59e037fa153f006a1e4326cf196cec69bad78546e9aafe3794e803d7d7c64dde4d9ee8bfef4a2e390b82a1ed60ed678ba275e433a4029b644ff47bb5fed3e0afce44fb90750c338a929c8769588b8cd1f2d7e7739e8c15b58e980ed7be9208bd61a8523db1a9759e78c0772640c93ad2c0c47b3d5c9339751b8370ba794939d5fb7086c4fdce36cc01babc38d55cf5cb314b606d099745dc887a661e10f17738756990e554d7521cef111b613199e89d22a0f38d05ac596233e27ce859820c134e25e5cdcb39bff5ec07fcf26412f038386bcbe32dc8a1fc330f3f12260094d0b68874db2bac1f18c7cbe04078d0bd587629d4737a70b349576f48bd940db5e5b54d4bbb58a81ab7b128ded4c3cec8b4f5800c6e1c29fe2c80ee07399a4d46afcb42ef1d876248115b68eff82c1f7df3dd10b2a050b052b191170e0c2e957fc471abcf7d4344535009297a50d6c5995025aeddf75f3b89e7784120d652bc9def3026ba094d4c4b9db2be14f96a9124f3d59eca1e8792ffecf2b969d5b49c9d2f64967cfe6cc9ee60c16417868dee57de412606960f42b7b0c11f766a9cf0e45af18ba0789c0eec97eb35d8df363a06129a716381fb85308aeecc8de4c013ab9a08390c826e69a54cbff863da84d48de96ae34f885520c2e577e88159ff8cae9ff78188e346c836ceb566e1731c5318f238478eed7c9e64203f3d51a4980e2c9499289586f8976ee11cae339f696faf58a0a606be5d773f37037ebf171e84325f3de83ed2361446b508b2db6980a340caa387d89ab32aa20ceac0bc77b3c47d643db4acadcab339f69c1e399b60f1070e632c52b412d16182c0af0b8e4d640eb7c525f483997a90fb018f01dd02bd5db7749089d09a475e2fa3d263ead8be20ca86e453936ca07cc6d754357e272d1c520e60b889d0302957c7137e3941b3c1e9bbc5ff0f6885bbe7c4a5d6e380a4d25c37d2e2995f67929a37f25dbd2c254d9b939c1ea29452934e307d1b71128fa290860056fed740022c6e8411382ed62603e527e6a85064f407c943193f33ab3f6d11d59493cd49a1e3c5ecc1310da1060fde193b3123cb87fb049e5c868cbad7c811585d45f6c17b4c457f44121300ca2df3099a1a19e0dc498b7fe9635345abf90e9c33bff3a3dc919a6283cf4b8adeb57058524f64649138886dbcbca6e8dbb1f4392893c51aafacd65e10c7aa70a8261e87d3bf13fb4a8634ee1fda80a41c8e1e1f6be827e7140e19f3dcaa4afa6e9bc72ffa926439eef7b5b58e669dc6ec06b5718d70b06c47f90017bbff6a7eff3f1c0a7d72a9accc7e43a18a050158b754e0c348242e27f52a0717a81b4acc2697a0f3ed4042f6ee861968048c034df4908d00cb0245d5d0ef26a57afbe90e4b6870f234a3d37aaa1c466d1b4dfbaf2e6aa9d794fe6b9a519901b078e754dd1c8cdc0d177617f5e2e62d9708ccfc9260f211080ee20b9852d8403cd9f0749c37e2801e3c203bbf38361e13ac28ee753e835ea7a4a02ded8eafe673a937dfdbfe46266d6e428f0648f96ab56ff5e32cb6f3c5788350538fe75c0afdb2eb5d070b745b8c9c189d39b133148424c17c7d73aeb8ef8147fbee579514cb9f463efd0521e79925ae73ba9551e8b073e8e041fbb46ad8bf86b9e7d888a1c762dde695f0504d1f520dc4216d2068173fae6726b96fff7831792f8b31a304ca37479111a05f4d234de061ab55d38277460ae22a6d3731c684e3856524a061e506ea3343f3718e071c702c61e0304a884d05df80b306ca6169f0eaa6c73c9de126d880e05831821fea688f6b7d919bc6af17b2637d012a361507c7fae2e8a73759a877d8da82b33d4a690cde56a22b495dbf17e0fab626761a770097b8dea757164882fe062a4eedaa60e99f97b32050967a02933f2526df98ac25276ba35cefbe3e39be74d2bdd967374e017fe5aebcd0a0e45cbdcdf7dae571da371db3779281323b5a2dea0444d2f8c0889e8cdbc8ead7b0d6ae3d5fbda613a1859244e6894316403d4d0491b1f493a562746a2ab693adac5c88e110339b378179b36a78a5f5c852498b1f4338eb36be61769abb3b93a8d6839f49271c328bc05ab30c11466eed4a25e1aa8ce8532929be49972465a79e7808be7d91ae299d2f478d15d45b601cf7a779658cca1d1c261665f4746a49bc6936fc92a5bd66bf7848b4a992fc13ed535d88a7c66e3b019e27df77f1db7bcaa76fcd58025a98eb378a7dd92612b69823a3156babd9548d3b8c107e81ab1feec69b8d16b1926220b3679ed5fcca77778effec1e5e0169f582e00364560b48e82f19e561500e3d7d506afba9b7d5a5c9949ff7b9bcfa4a5794da999c633ff4915fd58f3c0387a7ad63e08bae24e337260c0e81b5e556ce073b57a35672553c0b7c2dc0749fa2cf5bc42402a4920196f8426faf7d70143a1f1a699799494119295107325e5da3f5c19dfa9ec0ac44693b6b622c01107cb832a4abccb47f2501ecd79ca3074a29221230bf3026fff84ea0b069e000f9b623c9bb9152cbf360585ebf088775afc8a9400e9850c557f2e19db1c957e0ca8e45a2b978c51537606172955a391521b3585e4bc8b8a0aed85170fc1e17970b324f400d0bc928c1371b47a599d40e68bcadafb5228455ff1eb23a3b8d5a72e4526cbfa702afcf479ee0c7cc611230c79af8df78d9c71218cf2600a05eb415b54a58e6429c536af5b84f00b9534d8bb1cdb858070033a14c292c6c3898e766610c753541427f5bf17cab3983abc0cea4b68c446cb2f75eb6df502cbd0bcc7f787665b5f6e85410272383ae0e8d94ac7f5805cec3206239e7e5f1fcbed787139f320411a2fddba1bbb55e706cb0647d9ee1f2432eb16672dbf86be7ac11b1c8c66c99708199e77fac6b3b250e837c6632367a07d7356e1835c6a6dc8869402244f93ff2172be36904b99d3cedf1ed62bc158e54e9d9a2e15fc82c2e1773d291cce15e9838242eefe9a791603edcaf507ab93110799da4b69e4529b330270e8ecd8f9e08da170c6e348889489d93712df54e4135b0e5ce2bc2601c3fc6dd514ca63fa36ca7ade6b726f3ed18d6b9d19c95ec73a06d8b004d17f3346530a99d0c585891580bf7ee1ffde383372771ce0e275dd290d0dd84729ed5aea6c2a03a49efefe86afdf752167d6e1a305ef20775397761fb8bf9c0fc376246ea15b92424a5c69b05efdc29fce10e68c6ba345ad13ddcffe5c11bb1cf7ac542580e11a9a145162cd8ee10f724f6cf506fa39ab836b7a232d62c79a192daed4047df7af5fffe713d8825a24b44df688b3010a56631182d0fa538bb9f1f516e1172c0c614b791186e2a3361dcfaac7e8d54ff9426dba8a233ffaced364ee4e94a698216264ac77518bdda47d0e984dc20d1c3de19ea121034f22d5b95cbc96b12a7744a73ce9312e9f771ce72e5187b1af4e0eae3c84042482223b765eb282d19607ed868c3073b1244b4ab39ca8f8b0a6c665478aebd58c9ced9a5f734af3419da83134870252a65fe3117cabda364cbe3ad68d3183e0b787203b1ff37ca9bdbe29bd6d8bc519e463874926e235d7972566c8e6beefde45b4c190eb05f67f8409722cb28c341b752c12259eaa7f372bd5936f470d73bfa36dc4bba9038d8a4708500cea7f66de090d6b0471ea01eac8a1873f2960a2c627b558cc0e185c34d9b41728f50e30b877edbe9b531a04c9fd97ca325053ac1db62e9bc0250430d6c9959c6ea65464b6e0832cf492607875f6fd31bac2014ca80c28bd888d717ab8b8cafaf58bc2e91630a93498ded3a78f784a632c041e318d3080325aa64533d34115ceacbd0d2260fa57f86387df736a0c63b2d3989b52e0e883f7d16f4251eaec017ef8e13b8ecb875ef25378963a446ae4be4ae633505248e3391c4f5ba244405ed4684d460794b6c3d89a6f980d47637bad474366a0c50a2e20d95243fe4cfdbb8e55a6f5197ffc7afad479eceaea3709b9127e13c847c7fb6b9856cd99e400a9ee1e3c439ed772a98b8b906a510d739c7c4f99484b45e448dfe1ad69268cd8b3f07bb2b915d9fb7145c4e35c60cb631f57ee308f98bf4072e3259c4fa12d919df2fa1c39acd1b7aaf3e12d85243a611979e8b2bf59ac3af3583a5dc52b8a5cb5ffe298c6b14f06651663aeb3a5a1c57312fd6b18f0fa1fdeb1e6163c431db1339eeef3fe75dbfd8ef2435b34cd82d3192fd6e781f52c40e93bc9be0bd4d34becb25c0e18a87d3b2bf94bcd08015e7d9a66a752b2e623b49c2837a82f2a710fe1fb719ab27d76d0f807327a8b6958363c73724cb1a10a924964db4c441c55d2c4185122aade6a3c057f232ff7452df1792fd9269a930171216ae018ed347993017dee7cfbdf782b38f5612d93e08d9e22d90c91dd8d886409d1cf5bcf5539865397d75f4af283497bd43edd66e11db75bce15b97dda448711e33abe10c9b52b943e1859b06fd3df8b99257422f5cdbd0e3717c2525710ee0225ba1b566b79562e90ac3360af537e3b28ef197c34eb1bc03697501b12bcdd8c0cfbf6091d1f2d233711d8de865391ef0bd1ce9a22990c78d601ab92449e1370dccf4f2ee4999fa3b7beee2f7c48782335c225ed8f43d1654c3a816928937b45dabf69c597d84982b01010790b11a9474ddec4e9f2bef947343b9cebe8db8293825a12ad47d033835d95463c0244282542c80ca3d64889df1a488162c9a3e1a782f99908c92d40c83c526e1cc2b51f06c3e39d56b3e5db31459d83615852d572e750df2599070106ff0458a327641e8539227f610de0591151648cb2ca0d351aa7cc613a9c1226f64ee9cca7c10cd4d56a7b52f43d50bea63c231adb1798da71f7777b3a355afc996405071ef59f98c65f466459fa89b8f52799dc3016c9b47932c1fb1f98e516297b8c0574a8ef4f79f6b1529cdbba50eaf6e37bb685a4013994b141ac7609258df48988e58fc9a99834eb0e5b19767efe324a329945f06b4b907930df07a272c30226469645c8784b1fe30498fb8f4e2eaf66e1e587b9ed87a7310f42560426f6b9ac0b89a364827ad45d32b89cd88d379551e03d043baabedfe82796cd1bcf636d6b39b3bf4a112375da51ff86f3dbd1c34d7a45d540a0955f840e6d13df2a8ec6e8c9e2b6008e04aac22f2bca7fe89d9a846236d77ef05de443f66d889a553f51b0591ac3327bf014c78e0b35f3aad1a7457bf64c6c854408e7efbad6c99b265ba8c9e3d73f6af7c545553bef9859b478e54789ddc6ccf3b58bc2f757e8600759bc093c6f7feeff424d526109898ceafc58f59c633734f3a1ae306733279f20dda650460e1d3401d6bbf606d5c97b782683ce020ee1a1304ce4cf36229b65364fccbce3fddfb561915c8b0f0e659fbfef0f24ec6410f617cc2b02f31d0e8f85791e8df1f3586270cb0b3714d883f1a5d64f3e258ea9f82b3ef9982b9e19f2ed59474b","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
