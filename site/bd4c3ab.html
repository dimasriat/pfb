<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed177a75b9c98932a0a61b2c21d7eead13006731efa55e96320a6f226b8fdf63fa320467feda8a5088215bbb2a2e09fdf08f22ec5d0d8360b4a9804f0f865d56631d9788ddaa883ab72dbe74074d6ad653d171283184d9a60223c12004b348d5080c47e36ef76df472ec189c90d5eafd8e346d2fc5e8564870b5f05694cacf9b04c9b164e55ba39073403b72c181a53ec4704197a5f073abb4fbfa80b7de182cbf457ee29708ed8413b811978e129d272936e3e809dfa5f98219e75cd07d21399abbfd89e6ddb8718902d0bb8bbc80fdd543ed90836ba85f93066930c6f5d2b3be3f05ff0ac5b9e54e0c6043f5e5e4651e3093b13d3119f43d61d63c0e700e298cd86e4bf44e2d516139831feb14e1e3c77940b44e20135c18af9ec133622bab8c5c8da05c28236cfdccdfc93bf7a6e6bc131ed91ea261f9fac26e54e2751d0ecd501a78f903557d4aa68ab13c275cb84251c30ac13ef80a9b27bcb5515b4fbfedf96755000e5d493dfbb7361858fd122201ecb6162e2d3e7c9f47cb9feb21478bec667450228d312661b6ed99008efc972dc974566657709aca470a0f9cfc5203863be83701a3b72d578202105ae304afaf8530e77d332daa317c50bd46d212bcd9e7cb4e5c4f0728dd4b7efdfc6338530f5c2e38cf6446e65d68256fc5a8ec17c3f7b4af7f366344a90289fba79527a0b6555ecf6ce7b231987abca6b7e4fec37e632a19c01101eaccc3d2a45fe6b5807d57dd168c8cddf34d2301033c9b13e1f0f61c245c76d00feb872764ca224873db5bfaf15f29368f78bea607b41fa364c98d18ced111c9e0eebc549f8798b29d7fc046bfe45e655d0a81aa35a3b60a577fed7854122f580e8e5ec3f53e1d71f921f5cf6f3810008135c937d742bb1ffad652c16bc5997268341a9886f86f156315ea7c77fe19e072a1f6c6068b3b39470dd4385b443db1064503a450ed8594bbfcf33dcd47ec8d8012732af5fc2f31074e3d4dd52aab6b1c26ad4963f229f260846d0948db8b20bd1918edf210964ce35d782117822a0943354008c2125718c1723edbed5cea90d857b5c3c26c85527ac5540dc97995dfee090fed5022bd92b0d2e6229f2e2124f908b3f22a9ae82c7697a00cd9ec6daacec649988c33f10fc45676bf71244ec13a4a00802e9c0e2c4fd840378b5cd66d532ce2eaaf8c7dd4fda0ad969054283384aa76bf060c31a93d315713062311bca13ededad4aca1ed2bdd67314354260b7e38107aeb2466d44fe6fd5c55963c144adbff28e9e102696efe1e9438bdad252ee83d31bcead07840825dac5957824ac12cd8d6d7c21affbfc7d7654a410dd13cf4539ee6f6c79fa0c5293ac0c9188cf0f913613f0fe6e56b8513c543eed96803d524c0f842c7f0946f83b3ef4f73a81a629d0b8e3180b11cc4c0b6d3e7ebd98bbadc5855a358057cc2d10d2c8b286bdfd7b4ca1e1b54af459a54a0a76b3dd0ad54c2fa83634b0c34aeee3f1ab7016313035aca18565ffa26f62da436ebd4c038a9a2c25d9ebbaf6611c4217abcd69a42230dc7100cb7979555bc5723e43da48dddea7af6cfcc65756ba1c3371da59d5744cc47f862b53dc20e8a48a36f23f87bff19c20d14e3d58935dba252f1240d7960e1e728c229fd84f8c933da612826af58c0604200a757e4e27ca6884082c5fd5942b2523febb06df0413a87ea6246d3225be29ec9fbe7c3e2385bd0ded65525e65035eb444a42cf453d51814ab16d03ec4870ca965e370ccadf1dd98e3ac32288389f02ab710759ac2e9ae7c55c05a3a08918ed0be920351f70ccdd66414ace61ae7af663acd4465b8255bd484e5f299944cdee7f87e24f18b33c4975eec52968ad16a7c60c2f2824668324434bbeff8c4e9e5ed64f4898c220bedea968ff601f97013df94d1045d65076dd1858c482c080482a4d5ba7a01b3062a7610ba512e6568d56fb01d25ad00ef0c645347afdd27dfe2a45e3d7cb948ff76b7a9e155fc362fdaf72c5853f07c910c86c34660fded19c639cf6738b5eb685e7a30f9c1f144ec297284b819ef2ca1eff48b571645c2b9f3bbbe7918a524497842e0306719c86c4d643058ff3e66b8137acfe4ceace911f3bd253c608ae20cf9899ba983e834823eb01f3fb5499fcdde31f6109b85630799ac012dd4ec2f4cd3f2fd25f24ac5f85ec97a6bbc09d2adbfcbabd2ef2a87c5b098427cc1c6d64eea29e8c52575f0a920122a46b5b03921ec20b46274d755045d5bc22b46ea741efb008813ffaeb7d3c9964541d91585a1dc30060cfa1e52521251ed87ceb87cba6dfa78622b034bf86207a84c4b49622cc0c768965cdeaaf4d8d385ae5741e52b6945dfa26f153773b171ceabe7ece660a6e611405339d0b3070d8997bbee38f15f39678f4af8693f8e0f505687af627f1ea8e9f54737fddc1c3babe929a3ec8acc1826e8d5f8b3e9e131a3f6d951bcbd6abece7955c8006de9926f3eda224ec429b3cfc52fe76c778decebec391a5b1020cf4471f0bdef27b580fd7864f103b9248bb09cc67b1ba5bc2fd4a827beeae951ee568cb9eb0dcae8421caa20f41b99aa3f96d7ba1ce1a81c352dbac02481c737586ccf24fb7dd94cd8f7907c88c930af483528ce5773a738436055ad44c83c20a08eb8d8cc055e9b6d9d2dd32455256ce681375684b0d3815ebf7383b375cc093740c10127c53ea0787f3f22ad0596609ffa6c91a3c9314c536220a2b78bc7217aa86d5f966ac5de33b71c771d6a5c481d6a67995d7193f4b8ea932a27b36512021d65e613b057161558c12e2d12130a9c0a79cc0ccd1a4db77ae1a660d51cfd1f9835f0c871365e99c7a91deabe98a6aba4ff01e95b474b258fe992e307517f0820e6623b3f0dbab7c14a992c93016d28c986a016912af53c743df39723b4a7a514f48e4dec92abb3d1c48576c651cabaf56225af6eb219e921d44c993a6bb75fab6f69d0d5d38a9ca9444f7d24714b642ae23ab4921744f5f5d0bb886c9a95c6dd2c4ec1be8ffca55c913d322c5b687a43c2578d6a4642998feee409a2d7f24382d8ded2274b2db0351ba08f237949f28d50ff61019b07141e705e5574609e55c82de0b55f91cdfdae43ff5823a8425d4082c5f70b4bfd95704e1af0a7b7388de08c21f001e31142a984566d3a1ecdb54c7fffe10a09f4aaaeafa104a2c08453994c65679c2846c21f8d7924b77be9032335b6fbb65b72a256682474221900488943958923fb170daf64e0caa123c138aa3c0e7d46622975f823325c78008719ca0df6d98fab414fdc77c759633d70a1a0d2a9e7c1b80bcd4c256d5c14662ddc65a8abab8bf642352fd9a89b9cafa4f287f18ff527a955ff8fd5ce3669dda1fd6f96fa10fde8f645002756cefcd4a5d68ca86716e17ea3250927e9c04390d444ea0d19438f02050561931b6cc70607c0152ed6f9bbaae8d4b58f601b314ef98583b37706e18c9bfc8fe7fe9e5b24de9805bc983e51b3d597372ce313c1e1149bf80f959eda9365a8273e37654297241013f01e88cf288ed2020fcd71c393b942c36cbfda29a26bc30bba4488376df15c19b452db906a005c87841d4434d881b377881fd2f3cf5ee2e80e353a0cee84973491f7c327d161e10201f1560dbbdbd3be20ac569cf5a25ad18213127349cc257f0b5c7f3340e8f9f98ee700f1b61c5deb188baf19e2a4421d78dadef17b1773ee20ba8674d4e4af82c3f31fa13ec48a67dd18a46f2d0e2b4b856999fa7381f98f426bff0d021e446fa4659f42994268547b74c82a7fe7a7896ab284b1e3f0a848ec949a5514a6411f4c6a2dc6a2058bf750d03399497f9ada0247a33fdb6170d7ceb7bf5ec7c08faa44fb4a73a853c5fe63bbc75bc18a7261487b6aa021e9268aa538d9612e533d413c64400fd80f8f474cb7749b44c1885500a65a2f7457da5ba8c077a83b91a226dca59b4fc0d0a212d924413dd365cc2b781dbbc73335cd621ff1331750666aaa84ea6f49c0775e525c91c9a0a31a6839fdb10f034d93ea64fa2981f9b62d91517db33544d65307e775191f8b71a96b2d3106b26eee55852138c0df2146404b348b3cd1528d151c84dfb847356ca53b39bb1f4bc2bc9fa04edd084c62936d6ad5b3ed742b6547d4165f9359c5db883a137001a29f0bec10d5a1e9f341cb34a4b434cf8120997beb9073e4cbc56268b43ef72be9fd41a2bce95e82b113ef561d5119ad41811f606b2abc6ea6606b7d97398e9ef7084a703b0f335b4c05b57ecf33350d194fc88b1bb33fc2e425ecd8dfad715347c75ac72ee8663ecf47010c3859eed98f54fe35a177e9fbee4cb9ffce881f623a2d3113b57ca8aec909ab0d3fbdc5c0b5fd8374725f3008ab90470b45ae14883a4f87017ee6185de1584a28389f9e12b3812e94f5249f2638c429a42dd9dac0e44fc15414b7bfb807adf65e8aba990b4f415ad4730c61116b1a6411a3ce62c60644e1e0e12da669056138ef116004f0cd5dc520bc3d0eb39c2e41b914aeaf7b4d6a103adf61aeba84077f6687dfce06a549aa09de4a572d8d824748d9e9715425af04c20e531d936ad7b7a37d16d1af8395e34aa0647d7604f1bbd56ef715c567edc3a05c1bb8f3b545b5df19604cfd25f35a8b9a061026e14d73b9a2e84d6c0fae1e96f6887e88791d632f2fe6c0c1ab4faa63f61b162e942738302098127477308e193f968ee9bda83cb1a04346ffa9bf1e386e26bf8a111f49d4c19f2bad12b62e45997370fcbe299a232d2ca1528b6414f87d9ea051264475b3eba0e6748b7fd2114a86a54f4ccae2c683996f61b2b146359e485e65d51719220036ad1ee7af59aaebfd4f7343e33e924b1d713c3759284eb8e3b27614f7d7962e3672a8a53ed48886701cb80f570d830a9aeeb50ea9c6972d58170b254c7c219819efc20aba3129450580dd4ee5e211c9a92c0448a51096f6ae609fa7807fb9e7336fd212f75349cbc483de183a7900c3acb87dce92def6579bea2c00b64ab89eda1b6c56616ca4b75eb0139b74fe29561e6d2fc4b3491fb4fce64f2f1435e17867c13a4767d88aa5c890c8737aa05e729167d92034ea737f110f7d835ccd26287f12d85bb331e9508be8e712b9617f557ed45b7579e6fce8ada0e8c4b3f4ac890627a52242fcbcb37253da693c2617fd22952bd37699cc45c603b94312b084b7f91faea0d9859ca33d0b48d9db802a1fa3cec8e37051450a3688df2204a4f5b889ebec1fa22e4faf9a101c7bf99870c0d05ddca2f61a2850da263343925d41a90e7fe01a2e5f92c87be82998e7c46ac74186801e7e71d2e171798fcde27495a1fc3e312d98382cf5420188f133d5aa832cdcd1198474ddc6de23cc0dc3550a895fd973a4f391cfea38c9f1aecd101ef056767b80157bd3d286d25de7aac8b89002904838e0bef1f67b56677a4995911c201a722addc7d8abea4cacf6240f232c3983d691c24bda13ad65f705ac845257ae8cf7a80a4e9ceb9b582def816017b9d56712bc70a7e59be2b948954c0af63b0ed354371e6aae35cf129d3be31a61a89f2d5e1d69d0ca411a19c16354095c6f01ba9c36f9e59607a446d53988bfea7cab7f817a2ee0b693ab9eba3e93ec088d0970cc03cef0b44e8d2c68a68c68e5b16476437f6e4fffb16c964c6064b87dedae2c751ed61a14fcef41fe2f5cfec70c98eefb6b39c021c5ec4d5d39febdf4a7b6a848b079953942f76d767e93699ad4e207358d01d41e0427ad1e08b78e647967060c92b22b563ad7c3b6a3b24882d0c45fc0561508e1ce8609f330b5b4dbf3d3169838ba4a31d39f60f47c0c0c515eed396e52f34a0ae7652f6a104bda17fc73447580fcb4f5a5fa9325f742119077772c579195a11e4cb36d9e7f0e3ce6019695328b5454308146d0604f144352fb87c0a7c3799fc3e5b7e3b3086001fe97416846bda85a5138d1e77f700ddc1ef995229573500b9c40256559b94185172a7d42da4198c420cbb076cedee63d6ab8d5fbe660f0053153ba52698047b11bdd7a36fba7ce841ea8c3f7bfc55d68386c105afcf5c2febd7e25654d8b44220be4cd4101894d89203f36e68c0dd84510e17dbde566dac1ce545f283b9e59a2846c658897cb28f49b1b514900775c619852c50802871e2caf3a8639db8664b665f20e9f09409eddb56da0aa8de1094073bf3e5973c5c33b038510dbecb2addcda638610adb75ee7c01bbaae24f312f035144d22acd6bb96f9baf329f96337fac90c9e7103a5d68133e71ac445fbf58130e9e0f71fe8b62d6d167a75f0a072ca30a8e0d374d407110013efef2d08b346a9994ce8866b57077f42140762d06d68675eb53ba9822fc3ef85283d04914508cc195ced6b8fbfa15b7d08a59b73dee48db6f31356021ba51ac84ec4fba06d84ed80ee3a59e078f2df4da3696bb3756867de300e6e4bf9aff47c29826bb4729f464ffeed5e4bd14158ae231efbb5eef2e54169b6593d361dfa77101ee92c020c8ab91088ffe62ffc33b8e2077645790ee4c2cabaf5cc182fb0c8a82e50264dd0488e2d6b7f2cd6f91ecb34951ff08ae1a78470a4688c0dd5fe7867558865ccd8432626e4f2cde66d4f0d0a06ca4838becedf6b3668b5e862c150bb025f71f4da3cbff742d1a7442d20bdc19f55482a22a60bdaa6c43b9156045a74aad9f99a4d1ddc48ce701849698c8e7a7a4720e856d7718d07ae08523461a552b1fbed0cdc1d71f0be686b04c36c9b8f379ea375b007992787d2bc19773cbc2983ea0248380f85e762488bf0416fdb39f785fe92ca9526471a6eb602850f6fd67a5a4ae3c0eaf266ec26f226b8e0b80a83313b1b8d5be31fa8d42009e33b79eb6742272d7599a1703cffc1072b2ba71f048c96319a9c43c17f74a084a59633a37018bf5092c3c0b7df0c33712d29fb0cc0a2826371816fcc5eeed3bdbdbf9b7c1d85a1ab4cd905640487b75e870286e7dad621d30ff7e12160c14a9ec0ab68b27e2a9afa9baba8498d12e3a28fa934206b8b4f1f3a880da8a080084fe89793256e3241cfaa8697c7bb0385cbef0cc136e054fe2aed2aa0f33aac323c4ef13b63f2cf8fcc75fe40289e62147b180bac0cd41ef172ab276d98c4638ef93f2214fc64f9199c59512fb5de05db164224326f9c92aaa0b4ce29b015642e283693cec9cb334d8baaf702438426ef049b6bdf767769642aece5367cf0133beff78c7637f56cb2008503f418fd2cce793ee883a9fbad22a7cd5ce838ba940fb7d5eaa177988d3aa475c1048259a1987d4757a2606e8aa3fa82f93ddf2c2bcf5ece7f0bb82049021da1c80ccbe122f0d3ea498c7b91c348f90de948bfb3f6f7e4fbc143e8a7366d8d95a470d92f487f24fe8580757f562afa4a1f43807bfe573286b7a7e53f9eeca2e0f7fbf5c80e8ef07a92168c81fc93deb0dbb024e23891ceed87e6f7d5cb7b4969d4a413b83b001d3868e5865efa0cd7dede06bc5479726d3f2bc705dd070ce606605b61c4990bf80cb26010ab3ffeba911ae64ddc38e79e7fff0d08e9d1a0411d57e5e86cf23e5b9e5c0973899743a8d88cf5867f72a505b45371833da93c174810647d2eb7533c8d2ab6c1ec5d55a971123429fea76268abf143338c6e5e41e7c8abad065ef4dd1804d29712dfdeafde6bb5e326fcced8e387f39fae77770b5cf769cb901588e2f852f59b1f4784dc405e0e5245a6180e7bb393da1f7e4b2651784278e629b518175e953f70c7e75afff21982363551ca1b8391236814fc40f4e3900764bec5d7178b068ac648a8c522811307915c53e1027b4183f6fb1e3f7946a29e919f291faf9427a4970af6ddbf9cf14661411ce4ca4626ba4dc34c5eab62f7446c5f7839e60431a60119a2092d14abcdccefc11e7cce45988377e72abf03b591e4eca272b7781ea8334b687968f33e10f5ef9e22ecf4366cce1c8481a1bdc116ef39dbcb786ea9bfe04eea36bd1ee9d902bbbb10b987aea5265aedcb395d6bd37a187311c46204d0359925bb0eaddf0d9e150ad186114b09b2f345453982ffbfa8844066cbe6c65fd818695c8193ba01ca4f8fb02a3d4818e6138626d6b47dd0ef7d18d095a600902a8fd8954a94480605c550fee09969a7c81bb1187091a0ca074626b2bfcfc9f9183c00d788faab4860d335eead5f14350bab320d6d61c08d5c94638a85ebf56cd01c4a1cd81ffb5cba4d8557aa8bb235977ecf12e6327c7e6bbecae57e29c8a72257f60c1596847a48422046cdc74ba155a2d1824c15455aee82bb0a963bdfb27289f00ec3fcbdf759a0a1ddb2368160c1b2f388f78d939000577c078496d3302ae089a6d56e69a795e3985378c0d40bba390ea2a590c2cd22868eb80487e21e0489d5605e55af41a3e7a252ffb864275d291cb34f9b8f705e28ad5444696c5fee62931070ecad595d5aed27d4d39d71bf8a301025ec74f22771d249ade78539efa4375de01e5d8f87511e7566cbefcbda2c143edba39ceb718da2d4659e5ec87496d5444ca32779f581185bb2eb3a0b5a0ff0e1d8bd1736208a935344b2360a80d9af9dfe330c0274d8d8aa4a561c8c517911a09b02e97935298f2830b30acbc99d0477b3c8141c707c076697a101ac0e98912bd9acf258e72749d270cc5ffef1eca3026238be51995e6eded0dc67aef934c8a84ac640887c0e57a7484a353b0ef511f75e186e1d1e77983be425fc9c84984c8f890d3d99639e482a036eee0ae6e68e63b7ec080e0294882fe9c98947406d39b1537d196ef2b70ffe5b4149a5f83e0e559e90422a32d88bac61cc9150fc0fca733a61328619649c6b535c51569809d7ceb24e95effdcd880bd42d7dbf3d6c777a556ac7879406ef6f5bd8080a613f4faa683b5aabed918c6fc54a0df09dd3c2a114c7fc84a13f1a7fc7f44b443f764f0827bb7f856391c6363149a8167c820def538e9a46245cb71d55fa387002dd2a644d7f1af18d7624fa94c1dc4dfe497ead8af1e78f9f6298d7e2e700126a9717bf56dd5d1a6d984f3941afdc391eac8f6b74033d9ba59d08fe25d048c3cc8097b8c96c1935a1e3b22f86a48e479cd2f0bca2fcc527e197fde2ceb78c816d8fce750a4e439cda6bb493b764a05dc6a322c4991801f120fae2104544c6702710c49fdcc74be252e92bedfede929670129ceccffadc111feb53c5a3fcd9750aa1fa22da072e5ad1a2159908bcab8d5dc43cc2ad4fe583c032efd054766a82149cf0dd48ba74deb8a259ca1dbec88ea3c6c1cad5739d404d57f0518edd036a314345a2fb205f5fcd466a3f455fdf91b9ca41e664a418566297f7c18fed3f61fbc0014d95ae4fc6304686919be089708ab9285e42bbd265bfa0c23924922abac7bbc85fee2d84c96de2b4032b8a94e9d0eb382109db96ca3c06ffb2092e470d5171b4e82c54ca293c9e1c402bbfa56ee4251dc2ca88bad531a29a228019366dadf358d714fdf564cb30724d85c5f9f6d6f30c957d6ced6000a2c9952f29657c3f4c7e1638c4af16c0596472329cb44bc1948261bc3ef6e0b551859452d38ac1bf9fcaf71c0ccea6c8770661d491dc3f3f85af3e108290c273e287f7feaec89139d013a6afe8852ade015dc604874c40490b71892ba5c6df9fffb4470e82ea50380859ffaae7305586cf4a63b65fdf1e70ee72ea8d5fdd3a4fc1d89ea0b34885cc8b65774b2de7ed63f9e08a1138711cb757c61b0182083f1ac7c2640db52e98101eaaa4c85b33ec086d8bc5a23c257911d586a9892db5dc87d31ed4dbc1d3b90c359e40610866158127237a9be6bf78a9642c8dc9cda4346908e8b9ee76b73e8b5fce2f0fa4a7a85a245ad8167fa2626cde581ffce601f4c001fd6fa49841e3d1c30874cd00191a5a37edfde85cc7d65465f88f5f2f9dcab5ff3bb7cbe6f201576ee0d74c1c1815e420bfd134213ce5ced5eb74885e8eba365652308e16195061cbd367ef4c315a6aa960868dd324a71d88ddb8e075a3626ed98bb3760a0c00b82be3d60fb4dff23a885985c97037f48a0a26753fd1ae72e03f6a49363b6b14c05b654d4009deea708a7b907ac3b95c3edcb189a527cc36662ab7d47554d64e823e1b00c3dd2e28382ad27df8e8511dc45584979e18c997c75018e1052be10daf915dee54fa4283902a59c9e90d4659e0206cbc6eb6c9d66a7d0764455c354ccdd9a453fb3b293fed7f98ec62b3d40261f7bfd3373b4a841b40e9c6cd9ce9a2aeb830409145d37a213dd29cfe4aa39c02737018ffb697c1ea99c916e66e835b3292c585e486097dc69689fc91e2d8e4bd6d032a96ad4b6fb97ca362d91e033a243e9b3bb15fd46ed5488313b6a72b7aa8ece218aa968a8a78bf11d0090eb6802f9fa97715e3ea518421f500acbb71f8eb2e74b71ed39d83cdc5b138b4eead2883702dfc93e48088b44eedf077314b26e41b0f579ab4e593c4b183e178197eaefbd1b445c98f8e945aeb6e028f85dad9cce242bcb5f26ffd45e5923780e52488043bf08c56e64acad9f12e278e2f14a689566feb4c3973df70f954821b850183ebd1901d78a14723b8d88efa0333aabc2ebd7b63e54a2c761860997b848ea710d2982dd7acd76d391b43df9f3bdcd4aa796f53cf63fd3f703684e46e2abf3779a1298f982cd1a64530373d0f46d9caed34814f3f81c03376659e82f181808ac61c5ef44450ac6c25d4a039b6f409c6d9f935eb3b3357e8f5b0af473522664403466c8feafe80943ab2725cd76a53a0f884f9090326f3679cc7492f51a1758cc17d9ed3da87dd443e3dd4731e01b81eba2dfd657d6db115b659cdd83c78c9a85a54eaffd7308c749046a4dec8e82559de2a8b98a5f29f8625a22f1b07f8fb0ac646a780af691f910d311dfa70e72f2b9e733cd47eea34cafd7b9b710fd3037cf3a14a4f244b05bf833dc3f389cb707a4724da3598aa3c1e8efb030ac8b04b5d1cd6e5e6adceaf2f661175cbabc845aa834d562a832487c8a7498bbba6d4a9a0bcd263b0700bf0edc854bce17ff335ce6d871e5c3e475692a0ea2abaaecbb0fad60b6454800196ea761f3331b459d969b5468f443cb0a1844a8a246f05d07f55b223dc918a37501a6aa0410426d8226ae5301bfe9815761612327b300890940b8d94285b650478ffb218ac8c89cebfa528bf421fc60a4b3bc61e1234b27414992cd534733ad80643c73ac091f2c232a715224766ab99ca4de6fcbfc5ebedf19af2b1d5c6dab2363ff8d4ef95b02217182b0e67dfb5a589580a6f6db0a4fc96468c62b6d60bcb238b44aaf392adc919611db6e10210bfa465b0db9bf32784566c58790b998b76a50608d7911884e2fa03bcda60e28d1a806c26e61937066dc679a1cd24bdb2d0763977b53","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
