<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"68f34d6a989aa478a6f53a249920f5551c50c380f68085a347c12bff3196253996faf1bda459cc1c6a831d3b165fef47b5f61ddecb0890607c3d2bd492c4df96246dd844aba2a490d273e3f22e7bb0cb49da1aa372c3afd83091b1c0935dd17e15e1f21865be165e3df90b27f3a5436d4cf340fb47445f88f1da4accae4d8ed60296754803940a2521211fc02f852e8a95f96e6a7467561f96e825c193ac215600c7886df301d14a53bdc480931e771f5053dc9557c94caa55a6f22298f93155b982a599a636c5e6a916146f359cd839139fa72ff9d603175d22908a190f5bedee3a87ff2f28ea198d53a9c1fc22d3c0c09a09c658a4bb568eaa4e49a0322bda0ada0e1ccf400c9f69a8d78d7090b05dbe8a3529f6352c0a91a1fbd3c51e307dd6db31d8b4717f0b3c2cbc76921dcd2d61a5ab4069843bcf8ee9dbfa060874b2dd68d3825ee54cdc37ae19366fcd4b99b0dd1110a2ccbd36160672324f0ff9d86bd542b8fae9275e06185ff4be877b23389a15cf7887e01e502a137ba4ca22fa9be22629cdb318862a19679904c3ce2f7fc611cffa7429f76d1ee27987b87e550c690c484ca46b4e2ffdadcd588089c6782062b3dd13e6bae7e250483a469d139fc85f88d1986df2d479dd9f15926b6850bea29165ec2bd831d5e03cdee95b35c344dd2a78aaf8dc2a08782d11656ba17cfc4bfa27d89dac8d5463e914cf68c54701e7af5d23cafa60153434a2bb00dda63252bd1ffe850e1720b5bc0e9e6e73bc29d098be38110cbcab8c1ad42aa60fb25b3ca8b07c468d8f2e8463b2e5ea21e429100e43fa7d478e0c7100e1f5ec55a94f3a43cf32bc6522130331ac9a725e7891c7aa43f47e0a1bf0915ccc2011f40cdbddedab998bc66708519a75da8f9066efda1fb8a49ac87816e029d0dca8ee29c918d92c22ab50d24afa6f813a1afac1129baaac8f96a56267dbdcb5b9be0fd92b87ec3229577ac0077929d0f5d07979f5f8b25657cba776c031e1bc76974de396495ac0684c0f4cedd3d26ba68c6c12de28a2ee8fb60165ed9f4c84546ba3392d7ce9f733a7519b279b3467d70625ece360d105514b5b252cb4ca6d87f9989bc4c2605bcd7323eb44cd987c8301953f7a4d7b3f0e1d2570146e3c299be2e87c588bec53e26f0856823415458f5ee7aabfb0cf2978e6a8b1438ffea50a58920e1b513f570513fce6206bb0bb1902b4662e64c44e0c525d886b8fbbb28e6ad66ab72c7e913929e01dd54b5de82128d95e09b45d58afa77ea02ed0b98fea5ee984cae2242f746edb72f450354ad04e1913c68cc439ab52f24767917bd4f7d5017a37a11007b338c947e2f176e7c7c1bd2f8f9e9c821e5ba7bf6b0ce3d091dfdb06294ce96de06eb945bea7e096c2621301bf513efb1ad0212949a773b0a34b6a89651bff426e57322f6e435258a499a294fac882011ee643ef31024181ed251dc2479f3663ecd7b031a0be733e9567ea43d2e16c93385766d7e7a27f154f2cc8e73386bbc1aaf3def816eb426bd31f56a1932bb04bd4d9915c695ce5d2f1cdd69d746eecbbf4b42c83e4ed9dc23e7391b9ef93599b49428e9775f3170f57432a1f25877d5a024ea49081889aa976396ed935ce85980d3ef4b70121818986310b8ed147fde794bac81843a4cdbada516eee88f61b0bebe853b77be82a80a824b29e2220cc4178211e22f65d1efb97cd890c85aaf34de856a8d5edfe905bb1250b6b43101d8e842970d0c8ea0ea7fd933aaec438154caccaf68af0bc90f1dd6af53a90786ed6a3e635208b1c470050aef55d93ee9bf0959dc4def727095d14557186c4c28bd3dc129b2c5328ae01f6259fc2febf6b9787b40811f81251824f9b64d827bebfada6a9fdecec168b0e078a4003616e32db8dcbe3463186cb4049d2f9cdca9603f0be1c280db80ecd995aa8ed4508c7533e62c7649d551d0a444a8533815b808551a640647bbf4eb721d2819ca007b38844fe495ba455bba9a1c36532b58483d7bb7812558c2b84ffd932a19aea929f6624fb40c64dfc0e40ccfaff688468b643bedd0488f408ad635de336c5fd5a0d4bbb5932f1168c597cee1d5b3af3b0c87301013dcd36331e92f13369167171a869c2dc0235e54a5702ffef58690953730663cfcf2aa069178ba3ffe24eb6731ad18db8a9d5b0d77039a5d829a62e5e2e2d4acd92abc0c904d7af007577327d5413db778611f9200f7acd387f3d2464931071ea5c4c291867e0e291b024acf47c45bc4ab7b62c642c20656ebe58a469d39b64b204557eeb15a6c44830bfcc06823dda26ee805598118f235fbee84bc5bbc83581fa6c63fbcc6ffd37d4c8dfff2c04a85e38358b00c256f4a06a59b7e84c0221ca5c4d703f05e8ef6f0ceb084fd9df0e4f8a123d4ded332b83c354f67b113117b2034245a715f400cd6a48e7c3fc012479b2bd8ebb3dc7c694fe0783115927d613e396489564a8f0df525ccf467f740b5d4fc65445dcf46b8916b3d7818d39cbbaae6c7889c1883afd7eb4fbfd75bfce3feed8d111b935d886d21732bb45c86744e0f010161f2cbd0661b77b07f7b43ff68e284dbf10b36278ac7da05ea28f521115cd5c168f939f064c4adf262e5c3b21dee23d7f6893a8eb13da14d46a9482423bcea123f4a8a1f26ef9d9f4f2d269dc63f0abfc974d86cf4751352b0ab17112e41539b1885203d2694b304244a40fde5ab3092685879259eeec01af4feb58b828e32fc515024a94be312c8d285c99caee6702215ab85068c899cab54355c175f25faac355d2eec0b34cbd8a8101b5b879637523f1d24d6c7d0ab7ac003feefdd711ce3969f6df4c62eee69676983ba2497659c7aa41fb6dd6e8c267477f2cc17f1a2918faece6f35c40a59f6dae3e6aab060ce04a308010a5bd697e1c67366c3307d4996a0e2f96b79f39d26d42f16c49d2dc40355ace08699b709262bf3024b561758a2b1829cbcba8782a5060a2b8ad1e4ced72c06f3d204e2f3ac71c84652bfb241655a1fef91a28c037379d2a48dcad1eb9d6a6d0bb49449a4472384b466ac70e1285e383ad292c575daa096c82adaa415c0d6c1da21d44309cea96c16b55ff4169d02eee967be81312e7fe5b2423588226cb5d26adaf0bee6d106901744ff07da72babff2e89aa7bab12f381976a600acb64b3e3a6a562fa3c40a3479338f5dc41b2fd643375210ff544240bb746ce0577c998f4d1977176f1e8e25860d473cf47e355dc4e8d09b78b59fbf5dcadc4e81de52963c42b5ecaa766847a2f5badca60f8785e957ab465095d7b1f2177ed4dc57e6685de6b5ef1625446030ab30c2d6a3d8852397efa66bdb97b894b532ca40ce04a8217c8bf323c9ba79dd47ae50d6d3eff6556dd04094d986c772b4351a64c6ddfaa6cd1f3d511c8ab278f550699ee011139f98934f7d356c3eb4215c4f6e0d5bdd2b1dcba427783fa1ba9a015494ec5453d1bae97f9123118a3d4652748cfb5ef116a87a72297eff94b1b924a87e4e9645db3f8ba4c607b7216d8dce62ae0a2646c572ea1a8920b6996a9ad07ba3d0f0cd28861a40c6bf6112c60fde9eb7c25490681e9092faf0ffcca2b16f59ffa38fc32fa086c0d332dcac591f573d10d1a9d1d2731cd32e4be9e313e5518749b78a48a639455ae124ce71514096f198fbc76f0f6d0f608b1dd499eceda8837cebe57b14123491cf2a0e6cf7a3ad0718693feab947f280f664cf57eabb86c978a45ac98808dc9354dc3cf9d4746444bf4993617f112530fa046c260c93ae6b177e46f4c99c24e1dbdc1f65efdcf3f5dbb3c3ae2691b801d01e38d7e5aaac29657e88f40af6a133788d506d5c7419e2fe2118cdc0b177a054da26086eb52323ba9e2a70820d4df266e38f168daeedbe182134498a33b09a89d7dcf56da64092ca5dc6f4bab8fc128099b1d9b705fd776630afd8db88866b685b3c72259a046a4615f27d4bb068236547395820f977bf08091813ed0665e4a0946d07cbf645d472440e7a7cef895e161fbdbdb735b80032706f6f211fd00a57241373ef2e56966dfe54a415847e4a0684fa9b1a6204972c6a730c4335ff2c8f95b8fda620c96ab99931cd42c6660030372fc77609400cbad756f50b761755a9fa92b04c38821d33e7975e281b1a4a15d48d5c8406b81b35e916b537d5dcf1929c3de1561dbde168b9ebcb49f6189ce09b94e33bcff14a2cdf47add19a819af17e5a2c2b6bce3072bdbcb8e600e1052e4af9fc0a0ac6505fb360d550eaf1f058cd390ffa0dd8b17f5dcbf0ead27b693123debad9e6125799248609196b89a8fc2e44c574b72116276a74430585ee51d441a3a869520ce098c65aebbaa5dcd6afa90884676ea9fec5510e53b69b6d57db96da386e2e267893a3b9bac7b53e1fc395dfd9937aa3bab6bca6b7bbdc0f1c44ed6ed1a153b82b0bfdd958c86937da45b6fceac6c7ff0b86bf797958a606be4ce248699f2f8b7cf4a30a2a6bd1d3637f3fd00f8ebf919710639bf8dfa785c2f83d96687fc7d4334c91e8c6024762904c9609b1379c5b2fd4f520ada154671390b30271a23f5bbd61ef58e92c5819424cf3bb26267efebeb9d90092d3b656de0ec509fcb49945c677e0075e998f2da2a9a92fb178dee42bc49a1d2fee76e2388178429fc8b5456c264ea78508dd8b5f6cea90ac768074b30505123e85daa6f563414410e5a55632f7b61c30d8fdae7f4f9b5e61ee1d7ce973ba7702bda152de6d5cffcf8ef8193801a7da58beec64bb0419c5a3436e3efa6966598bd995766ffa3fee46c125a74e2fa4d0d5732e18aa1aed8f3af8962089335d6a476990cb312bf08b4c54dc3d6c4b468d42a9a83211fb8f8b84909e6a0d2cc6187dbf4b112b560a0c0f1802e9d328b23a7ab0864ffad791723c3be02e7342c2047e41e0b1dac5285bea21c69a198710edd3dbbc54a83d2d3e8485534ac1c7f3d56b8c6a418cc2ef28de023fd243830f385b82273aa6a8ae077c0197229f8c17164b0dee0411ef38f86df252d5e618e9df24a9e19764646d44f04d9b015f714c885b52a73062f1b6d5a27487335fec52d183b55f97b2d8bc7102246f12f23aae0b1047ad5d3fc92d63a692a33efd476625b09c87bc6adf8acc71909373b1a516ccf6c92790e1f42aae5385d35fd0d9dc7e8e52216d8e78ded91f2985eda555efab18049038f771e2b2a125c394c85d0fd1b0385f9bd017af03cb45afecd721c93f0dcbfeb6055a813c2bdd83d57cb62fdc74b7dc24b55f280825191e0a4fcc294aab4e0c2a06a0eaefe5b16da958dc8f4098973bfe130db7140d80e96a12a8da5afbc95a8306dbb5434ec6692c71203e2d6e8610a186fc4c7facabf3839ec9978a7ce56fff346685cdd04b0aed29d0dd1065c14a7f70aabffabb47a3d4bcd5ae8a9e7b0b42b4efbafb7f9ce419327893565776c16932e1b13bbd37875d86433e18e23c37768ec5a7e3ac1d9f7a8d6454abb7d049ba005a81514188e96b531f6447d64dc18f61d1505c6e9ebcf40228c6458ba580ab40ff423fa9de52784533003c6f17e5f47d5f8311f048ca2f119b009184fe1a0917785f6f06dca63755d8fa88c0d08157f9fd67a59fb5dbb7ad07a29a84531468ff636dd60f4df9b16edf19f763d97350b6963075e095a0bdbaec3157abfb688e186197ab4483a4ed2e490450e42b39f6be59811d8786bfb3ca0f7f30ec858c43c80c3460293db619f8556a367770f0a01605abb296057564d4f506dacd70fafff6ef8f73ecb7db92e254197deb1b4686e385393d0766c30df001a068450fee44618189591957e5819a604cd6b67bb3029a1da2e2a48cde56f4e21554f688fba1cef94f391a297505f472ba70144711cd2ccbf3067d507fdb219d239781241c890e0613f0a82de91c441b7fc42a1c6c81813cd09dce441092c85c10e9896a70a1416ebf7568fcde82bce6c43616419306c68af4f4ecc8cfcb6a0c29576d4193667d6dff7fc9fd40e442b0736bae84874836d4fa8ef894f2ac037cc5c03a92cb753365357a0fc80e050d0e134b4dcc4eab1b60f2a4df33a1c7117c21c1186b3b3497ed40b301058ee66afe952745c08fa628c02ff2fac15890702413310f163905305163e930363174de23646cb76ffdf5024aace7ebcdb5903726379be948b871214b7e9988e7693b789f9a0824f68979d69382df2b7a2f340d7656e6767397f92565451c481f9032070b912db82d5247e9f69ca9ec3795a55e95fe6a774d7932bcac70964635cd032f9757f474ace2bc06aa0ff9b51724ac4f3cbe5abd61788e3d0a59ef3ab3e5ee93e95a8205869225a83f9c0a7a9966f8397d6230ed01f234a3e3619526088f2e3f0d711fbbf3500f4de23eeffb9d3a3f8e7bc2f885bdf76020cb8f4420bc026a69a5bc5e40bc60ec9a021bbe05ef5dd70e5ef56fa7ef1bdc7c50047e6fa05ab6ffd463cf30d7dfefd22aa7768a525e41c5a78b6d857462ea345d8d4afe033c4084959fa93ecd6806c02d2b946da263731a3bd21d052dc314013325da4ef0ba36fd59fc4dc662ee60adf42818214fc00e24ad08de8d4d1456ba74386d1ef720d9e83010419e07a07b3635cf8c028b05fc6b9504b98938230c0568191c8e00d69a5d6700cad7432c45920fbe47a07ef889c97268b3f0acbab434f407e55019c0b2cb8bd5170160f79c19f86020c18c96553b549a2f4b21ce14bbca68332e91ab4a7fb6ab10f502e1cf7882716c8f07f4111e00199297ee0ea91f0ce983e550998f570e7c0e0aeca8275466a5d11f26991e343f055f508b871488c39743e1173c8cdf91b99435e095c45fcd2794e4142fabee5a086a49a039da183f606273fbbfdcdf620a9a5fd9ba8316f90fb3a14b668b6208f629c33d382321c693ed33607a7729e88c6f6f830cada7a60d3953d3706cd6690b7e17bf4e85740d399dce60eb22af62cf9c330538526d27030c0410e624e1f7d8fa8a0bb5a554088d17b498bd5b079082cb70872c19249f312da14735b13ae88be91a60e460ba6bf96bd653dff65eaf1d00133795ee2e6adab7b5805fdf9aedd5ec5250780363e25f6246c7af5772116f625cd4fc106536a536b86ba820020352eae1eb2195e404f0e7dca6cd65fe48e7779dd0f735161a1a464b61c1c629e9b86f338a97834497d5c657dc169cec7009b7ec528fc18bba7e1d2dbe3048c4ccfef3f70b2b104f57af3707fc9f3acd041fcb9fcee4e400a77d1f5d9f7997371bad5e172332cfc56bd6fa64759cb57a952abf1fa8dbc1225f0042434cd5a2d12310d2ffe3744151212f76f06e9c1023a8e7288bdca3d9d9283565f29c3faeedba46c1267400344780523de1af7a0e88bcafa4707a816c8926f4ecb20d25709050a950588349db7e8ac19304f91e16caf097adb3d4d62749943cc4a01fcca0e4ae60a260500fba47d77f11dcdb77b9a53635579f755b57a0269c64e53ca9701bf301e33ecb52f0bb218a365ae03b5a60f4cf41b1afb0b3ba559f0ccb5c47fa1e9224fdbb5da78995387f16f8f6b8259907b3da60191d5762c41e22127fd85f7eb626528333641ca9dde4f090470ed0f0b05178a487216e71ade62221e082fe9a92ad7bc9e16891fcb5bffd875084387d225f5bcde299378c637049763ab3c35796dd7ac7b424f2852d3d5a6625a70f097b12b00337fc67917114f35fcc42904352c694c060cccb591363b1fd20aa3bb7b32739e71352c8641380ec79d992a23b3fe227fe865e56452bab2eb5f43855ffbbf23c722e1b5f76a913daf85147730201d80c66b8b508ef9bf212b0cca4530dee9f2441d43bc58e4dd954a41c04ec51d2e4d35d2bcce4fbf1fef3d4026d2bcba4f752aa02007196307a9596de8d3f7a615a716b70a77c0f1939fb18ea73b7bbd504b24718ea2ddf2e22375e46fdd61aaff3fcd13b832ad4ed4a22149f1db91be21b60df904ec078aea013a9b6781a826f01e9f91745b7f22a73fe0bc865318d31a4b403015641dc65dfa1dce6f1b45a72543bc822903def7abd51661eb5eb1852d4d01dd2cc81932bb769381c3f016c499dc046ae97fff22d5b124612e00fcc0a586cd63d482ad4f2000085be4bd999e5faaf367a973dd7c3255d872f1379dc51ecb95e6b435627042428ef7aba9aa69f1020e302243ce9e897d9749e0621861f93830782a0e0839be8bdae51e48eb5ab595ae7971464f3b35be3aa7e1b60d7ed36ecea77f057ec104c053fb2a4b7be5e6462f3900a28fc55a25b85136f657d446911f321357e33844232b4d2f3d7c53fcb8ab0ff6fadc99c5951d2c116996f82c81011289c9479440380fabce41dc05bdd6224572d7db35db8d4ec46513d42236bcc6b802b270163b034eaa5aedf997b92c123418c8a8040a8b918f88c893f36f19f9a80bf8a123c246faba629f1d798c6ef382010fe71daba54c3541e3343c3b2a15ceb3ef922220a3e2e4f672c2b943b59263f5935b1526d3d1bc43edec4705d764cf3e9bbb3682155502db0f4889ced14ba6943c69c31aa12edce6f4b911e858a6ea76f9544943df51e62198cb4f6af8222e15e67874b6dae180e69c980346181ea0412a75f397d5a7c7d2ecd92d911dea7307f88c93ed5396e7ab79cf1a35804cbe43823882a20c1cbde7a1c99904845ca35fd91c952f1a7a6264ae5b97c0a07c255826ac978be98005dcefed2f9bba8b61d0632b8438a87635e0c4a02072e08397a1fb2deadd20e9f9057477f066ee1979eea49921befa4d6b89a1d973d5670285f2346ad303f8f4878abd66fd711d93538e9a9f48c0af4891de75f18552a1783a608c5e3935ea1e9a282344bf2ec6d971f82c0afe08f7835162e48cdfcd35ec3cca18a58315ac83aab7ac3821f72cac1b39e0b573f329cdc7ae255b5cca4759966693d5bd9988e79dc92b3e88048ab5c9fb19546c1165acd719212264c377c6594f92048621f39bf7598bd5837298a68f0c4562287bbe75244ef1aa70470b9e38af7b786aefc7f2bfc9700dce2e63b2909384bd228187bca85e3cebf52e7e076629dc299d0382d6e3a2ae488f2b593037f648357cd6e38346570e250c68bfeb84ec152d0b9e0332396749345851e009cb070d9856bd5c7af581946a69183e66d8952764bd7dafaa647da05a0af7a82ea074682e8b7c64bcfc46f2ef590343ed2d20c50f83238323bd241dbb1eb7ae33cb4a71ec60048be5ac2261e76952efd4b678075618236c0f508c181cc4e80b9efb571570d2f74a7c96ef9c1a8a6bd7cc5241491e6bb483b3e26dcce56b84b820c032a973e9da74227bd8588b6ccf874773c1ed021543fb7deca860c2653262b7ce89125545f5627f839f4031c013a19a9f7acb556f2e389bbef8c22dbb6925b651670a0e8a13e38b6d02b430d8c3bf9cae1d7930585fe19d6276102d3a00114c1bd7d7f1072ddae08b00f057a87ed180f823f49bd369592a51e67947d4a966fdd3449b1494c14c63f7567b4cb224692d868df1d84c92608138e533625343aa93ba88c3f52a5f2a61450f17d61295baeaa0a7b9363191b11f2bd9f895a297e6663a1f8b11648f167c57b5486ed5245f413ebd9c3ef972515f86107be255fef5608438463e8f4d9d059829be0c1bfcf997e295772ef3f5994d5e949287442cf8dab24c56af138b323a0cd00767a27885e20ef9697e070bb6d791c1d833fa758bbb5fa10aae7d4ed63f15f813d0fbfc998c0e2ed3eb2bdb1acf6d5fae52b9a81770257821eacabcaf7092a89f2880ae94a980ae4d08147e7b3951769d53894dea5d7486295e226bc49df487e4fd5cd57ec55e2a5a7d74bd4ba0f6a66d198ed6698770bbbdb672f3014d2a618b2f3d00bfc4288961976dce58aed156513d07e21c9637984ec3db57bda35fdc0feea060f1725fed3d9c61307b3c7fa0de5619356bf3c79a44be1ddb89b5136d1deb403caf371a04bf0c578c8f4c48262ddfe8383aa2de738bdec006b2d47235b8963732307bef64052204fadfd5aed66f67639ada27edf9518330a3e77636fcd69ef2aeb699885f0c1761b711819611783850d4d4747433f847924cc4b1f5277e1fc2f84b1265a645077e45e5f0d0db68c3a2fd6ca256fd31f975d816fd47998aea566d50cbf40718bdc4c352fedfaa2ebba406e7578f53984ab0ab59867f19d9ea3a99c41187cd7c1737dd08193db7e045bc6366f890144ebcc6cdc3199c3758958616f6795903e001c1325ea3cfc9b43fd1ca88b299a4837d08c7775ab911fb0ccee93dde259a41eaa1031db090506c327fb35c4ddafc6e1b4baf3b036c1bd9a691beeb9283a079e9b0ed46a4715725eca1ddf11defb7df10d9d06ca798ebc0a81f4fda26ac43d6cbdd9a671f928294d19de2e1fd02ee96a250ee18aa635bb797244ba1c1b208cad81c13263c411a38f2036d653590f18b7e34835bf7d788b662456aa5da0daa721dc1ee9c548c5672323732c24f180783895fe7e8ee3d0fda30b283c0a94fb791b05cda1a7628118c6f2c5d7d59ae2ca274c471ba251dfda63f214785ac507d4502d4d87a6816f4061d629741197f15bed1539f6272b13c640a55d60da9842bbdfad9a380f20051702edfa0a1ae9ae4cdba88972e3344ba1d7f5cfa3396b307d350ad29125c33243584926cb928423298b8debcd2520d30164fa297084fa4a861fa3e7539e2d340e9d9c639541a71f63884f8b9f30dcfb57071aea600fbbc5a6a8646e9cb5cfd8b3233c49cfe31739ed2742fe4657b69e05f757cdf1cfeb8c74c262a12baad564e73cd577e308f6b3845ba457893d12c948b9b33b052c836f73bd05424a84b16360df9f50103676f458bd05f389d9337290b6c605cfc9ffc13f8b37112b1d491aab334d9e51af91c141269449f216f328f38b20d5d0cd80b12a719837d89b072e711e40e5fdcfcf278ad587b6b137fa55ef4b93d8f0922822e26742d50c0467851342320c2d648399af2409ab4aeeb34b36369bbabe59089ad958d2bd56e2edf5d32e4e4eeabec5eb257d18e6cfc0a9b18bf61681e3073c3c0f9f523577ede76032ee975a68e00af685f9aa37148c96a47b6efd76b805fc06aba3b899a784faece84ff09937cfa1e800dfbb9bcc858b476390b7788601af5fbe6555214fc43ad048b191663ebd339a803866de395e6fce0b05adcbed5ca97baba1071acc7fd461e99f815695d14eb3fcb84a5c38729c0e25dcf16504f879e9618438107c38e853a61f07151d1ae2dd41113e38122f7652ff14a7de1d28f7612768023f501e6e530b143dde05fdcb2c2c3e9eb07f301772d0a893d2c855a574e347167f41637aae6ef67b871f84b7768201ff5cbfcc1a3c4bc75158ec9012df6be68bc66502c63b0b77a6fca820fb6dd091731a755dc32d4c25ab2da2496392f8b4f4c42b05ea4b0e3956bfc54b05e9c594eac0c3e6040f84cc2e44436d50248179ce1b1b295ff4c3b79428283d1b6ffb314f8b062d94ee01760f3213165047eea88bf344c98035d377fb1b71a42311c2694812340da53ad93ae155da4e18fb93639f20b13ab165ef0b9d45ae038aab5cde3f8b8e596684cdb65b39fc9a043c1e2d268bd5127b9bb93df0aa9ba6434fd344985e47b22c9067e9a67484798bd8623c6f86dc0bf963cf278d0c54d8b073bc60aafa1a8cc62992d23e4a1f28262027e616c7381936e7cab23bb7fce3397f8b6342a75338337ead603d4928b48cebe77a6168ad7f3e0d9d7daf994eb3dec8b392d48e89fa773d2cb33cce65b63030141bc8178d1a268920f3dc21fc3c34673bbd9b182e3d18d0a26ee6e7609b9c4db1f316f9833bef79b3c50cae9a0faf72634a0d57145968ef382bd5610a2feea7d02f34bb4fed1f436c9a03c3fed2497e246604a0b9e5185187f480dbc7e1ee9655d878a1c8afda8cb44be16d059fab97e2b095f2d5747c22376b76a83524744ecca1e267a48e6bab84a3ebc83dbc00937ad04a456705de3227d8ee194e706259bd188ca785205bc0a19b67dc44093dcd37264da3c82e7095f70f4a55244205a81f6641680c30cbe8e6300cd5141cd96a8abd4f228582745f7e6047f9725ffb636af68786363dd5508685c951f10109bc81ceac731d1895aa988f30700ac86fa5a0e6a367c6269fb6a64f320b19b05c7c5ed2233e81d6ededdde7069239a1743aa2bb2f10606ee5863be803aca7cd8bc71259ec0cc3f83e885cb20a0e5d57e244fd5cbc95f212032d3a9bbc2c2cb79d357a12420c6baae234d7511ff1eb3d5776f6189","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
