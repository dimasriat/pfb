<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"abfae6ea2991b33e95a7809047a50211af706f1266b3b9c7850a01ed0a189bd255545e9a145c460957f59e2bba0248a2ba96b2f8906b76ce183fd3e901bd33ac916ba8e18ff3c34bef13b5229f7f3357333c1ea4041e43d78e767f63f5f4a67666f3d6b85d98e1a665ca988b39490894c4f6a9ddb9f1ee33e6b8f25d3ab2940941231441c246e1cb85559eda95341cb08a73f3ebd98da59f79abea7178a1ca134a5304ea0c64dcbb7a7811dd13703f13221598cc352e5d77e6720d04eee03502771d59bc9374d654206f47838c321a43ced0526b6d8c461e69d98d6ffbaf4ce6bfc22c75eef18ac3dba2007ca1b31a75dd8782f78150dab2b3934e09b7f30ebe385f33b1ddb23eef95ea99c932ce732f29cee3e163b27139d5c20b880af1855006705d03ad93e9a464261d9a1cc04d8ac1dac83fa6c7d8342e3a2b02086132fc856c68ee4aaebdd4eb6027c99675880cb3a599b355a47dee82462490bc0b326041564e427fefbb14847ea5254d3a3d81b989c25e2516da5ef36f773f2e88ae4d4aa0393919f09d13bb4cd6e0d6325a839a15e45f38f6fcf43c387fc6d660bebf170579462df9a51d875fc903cae6100576400f3f6686141f3d4a561e0b95d29e041571d5c5f0e7e5c0c86e1e77c641f47e9ffb83b26119eded71aba3d62dcb55d1435c2cc64e9921b0ed4b54f203cad41d6c5a10931d2bec2a6b60a90432b5c6c33f86c224627ddbc13075db0a3f6464803861a3f8df1d8ad69558e090c92f89788b00a51806f378f9747a4c1d7824ad4174c9943e1861fa280db1ef9c601f8b58a55062fd5575b8455741bdbd8b0b51659505d85503c44c8c3ceccd4a6d789d8ca7e945bef231d924d624710ffbb09be16ad3814bac58651f21a7094935a250d157b6994ec1cb578a505ef954dc3c89c728a927e70ea992689da93393a96495f22375eb0788ef18ca1f537d81841745a867347590636c055f46e9a86a95b428f5631eca4ee7aedc5aa5c7c7e1bfcc4ca20a5c57bbf62d4a43241eff0630c7ef5481b79b5b7b8cea51571e58dc3cf15c1ea9b057b4b8a027f86e5983e7b67c06985cb590a73659ab485343132cea56d2b2158cdc0d08b311a83c6bf49e7454c515a69525ce5d95a97a7a364a8fda829ae0d2e43f89f62c0e626664a62984ce472ccc1654877bd054f948de021c7876a7d5776679ad4c27400c3b71948f933001de9ffe6ed0de817450c605c15982d3bfd56a8dc2a68802b1725c55d7dcbd0b357d544dce48982686ea9b46f2915b2eda73e31514de7d5b5bd8118da925285a40c49a4aaea1f865c517261308334eab751440ec265a4d4804a94e5ce0633074aee1a30fe615e1b31d7ba3007731eac29b6f098aa6d9a4e84a54d19dd26f5a708d4eaf807931a503805a0e05862d104b06083ff63cafab87c89c15eee7051b65f9c3f4dee41dcbd5b4e64f3e035dc4ceafd550039e126e789b2875633c6275b1925ef83e7446136a4240c7f9e8bc43052dc303cc042fe7df7d4aa8ce3a9c620a23b947265644385301a14908538b22d04cadd37bb7de0928a3cb77d9e9aed869b89d8d3504ada98a02fc39e3ca0c705b1e479c694f86094def00db302b72ab6bb710996994f40fd72c420029fdc8be4a33a7ffd684fb9b21744aca6cd3e8824c3314dfa3b346a06af0c413c3d4e898627d05ecdee5a7fe669bd24a921ff8a5071efcc941e50360f97ca6f579667b8ac532ecf45a6245bb05c1d29a29445437407d3aa384702caa3d2140356176325118ac90fe8f9fa3549c1b7dfd90bf22fbfec206f0167f3a331f1bd692eb91805639d44d0e61596a6d657eeb49c47a4a287cf87f71560e843e3c1aabc142a235b106b71def73cbcfd27d08c393f99c77be0bdcac7ce5accf3e4c2ee2eb9408a6d43387c3097a1fa19bdbcc5bdc0ae1d01c7aa11b688cfec071d2126a350dde1a5761052170d60d71e938c6a6219e40dd680a1412eed2e1ee848fb9451ba4098cba808e114ed92d23466d3b7d7cd5882009a518fb9737565168b47911479e396dddd9f0bcec7c47d8f8d13a737907ad853113b52ba755a5ae8436cfe164a288a7439aa9928a57a720eef501174e745ffe0ee9b4a6dd905a87002babcd690756833b7811b1d3651fa4821594a89f4228597fc582ba5bcdea78828b1baa005a6f18897f857e51e9d5796e6633e09d5d1e221464d3f277133d18e0de80ae75f0c04504fe9ae7b2a78a02b60567864691d0314e268b3dff91a16284f336505213c9c9afc25ee345523bd161595af217471a8dd5001a840b737e28b613c69bc4d23b3a7280c2806f0d1f26587d2189e2bb474bb7b9d4173c16f2cb2bcf864be9d2c01e945fb5bfd82d33c499d98694deaf190f805859092d901c0521b99f3de6e95a4a4cc7254c849c34059978cb70f6f8a0a84d7249784cf4521c5656e7606a700699362dfa81129152cdc65afa7d3dd69faa9a83ee4465b41a9d7761d1a5f75c83337e41e663d39634ac995b0d2d930c4d7fd74144521e441773f84623d703599f6ed09c77e3a86252958260381e56d6aeffec24fc0eb5e3e3779daa560b2db3713454e1aff0286b7713af6cb547dcd951c37f17accf07909027f3fe0e4dc5559079fd6703b8ca3395496b118c3424aa849a7d551e03081bde9bfd6c4fe3f3196c08ca99232967be30f3516b107d9140807e719e47fa0e3e03514a185701e3b143dfef6e7f15eb70a6e8c985906dfb8f77a83cb59dd9cbeecf757ac763485dd804a1efb8f1475505a4451e7f051efcda0c572a9a8c23958f46f5c97b9ab5fb4b47cd5eca4aeb505df86dae673446befe423cd737e6505dc4e5fca52f6b5a492e337f65afc17b9699d7e32347b1eafe5a27889a9f1c8e84b012902bafec512fada1348d09eb0f065bf9cb88426f4f6891d1df503caf1a09b86ca7d0a5aca07a9e9e9c5c94bb1e77fa04a6e61903fb8231dc25e0474a0cb7f41f5afd4cedf77e59c69a46a708cf2e8d34c605b9361bc23380384fe6a672b3ddb35c3a728acbf99f6ffd76a028c3b9e9305ff6e4ab7c6f6e27d1ce48fc60bfcc2b51861098e9b40afb9dae792922de8aff53119d9eda45ec19039a14bfcda19faa541624a93acb8f00c75f82a1dd892351f4aa6ca3c9146dfd7d4c6f9caeaf4be657460834e45fe8d0416d8b5dc1ea8f31a0501ea740e8fdcc6d5fbb6210a26e6863427b407f55025c4d38d56d00a367fe603d3e3ee6efb5ca788053fb6f456ef1fa6cf04b2c2e817848d4b3e802cd48e6eea73723f4a0895ae06fd469e14293773afdf86153fccaf04fe4ddc7295e12e9c9f9e8d8677ae722e06c69b6083fe9663cffe4e4fd2053f02408e5d126128d8a29cbe77548d8d5e1edf76d7aec883841848b67a248a5e1d517a590aff6c73405ce1a21d6c69c95c26057ccc6066feab76fe8be9a965cad3a4f28d37ef1087a4628abb03992be3999171a34b5495c8679d68b6cb3497d57c100d76f347d4700a12082b460c818878c250622aa29b2aa57514453bed363766982981b36691e26358ab0c46efc8e642262a9d77678184958933096a8433dd3abd2191ea5128eb1023581c711854ce150b3643e696a068a3a38f7ab39f728bc69c12dfcdae0c18046745f0f03def5103f24f4e424ea8e9435714b33df57d089961f2ddacfb4d95d4b1232e41fdd64e3836eac90e617e21ed8ace983663f1927819892e416e91bb7a68386f93b1153169cbd25b7446b72425a3cd2b8ad0f315f7b1b0e169661c19d757cf8020b5f378fe3ebd620431a931e13ef096c9f335716070b4e532b758268929ffb22bb313ccc5c5f196ed67feb2b88caa6cf95d3344047f7c0500f932118c6d780305f10e45a752d26a91678e3ff387b1f1215883ee9c718cabbc0edd86f65c2ef65cac4832931457e3911f045412515cc88a3828ee7f6c435b73bd7eab6d765dfccaccfb2ca1f608ea6f6d8879d0003b1827d1bdaca0c84effde5ec1bcfdc1ffaa1a8cab2dcc2941bda5959c293f05a23cdef14688c9dd1afb7f5241834cfe0933586ac06721cd75574bccb43169d421e333c44a26c8cdbefc568ceb437b088c4f1c2da49fae955df9cec113793df7c3dc959460b9cef78e582fd49feda25dfc6c2a7b17d47c88bd1819fccd18d3f2d02a619bdef624a1cf24775fdd1ffe03eee94def52dbd9c595725bd8ddac3fabb2acd22f8fc1f7aeccc18ec8ea5e35ef979649529a065533c04d21afec60850d75f8fd6bfb50d2c17d5e0f430f708942098cd7a3820e2fb8ae400f8a6745fd0d1539ab3ca849c6255e5cfb6615e46fb90a84cb7259852e14acb64d28b6449c36966eaaef9a1e8d08718b848f587c6fc08d0fdcc2c4de397d5a54469090fc025c829b7be617a1926a2ed679195bd77628cd3746d75ebe20d372186794828b5010c8cf9aa2158d82d2ef2ad7b6219d3c760347a10d5b3a5e645437610191207da1334cb12140176f2da3b0794eda54dc1f3be322699afa75935f857823743c80422a5fa679b32a40562723bc59adbb0ee203e2807b98214c639e27a378850dd65d3d36174513dcc22027df4f22a1cdd46c2612ba1745b958d949746028513257043eea1d535a925ba93706a9bcc9a5e004cabfdf92a057d1525a5b84a5822c435ebf963e6581007391a7df1982f9c893520353c72a00fc57a24ae0ccbdf0e92b6e7aa702ff26de9a4016a362f7c0f54813b830e80c77ae7e4599995dc8abf7c62aaa84f92b774683d8fbb22fbe22ad86733071df61d8c2e4e1d7430e8e31129b4d1022ea0d97e82fc9854c200f0db056c466a447664e0e7e870cb3f5a4256a692a8d992111f3d773b8948fe2acdc121ddb06e8bb31682ad11d29be24a9a95e6fda85c5438c3eca9d510db4805d67ff014d32867982231feb0a6b303d1d6e129c6032e64bff0f82ce882e24845b8cdd456b54acae160709391f04051b8065704d2d1020215f7fe7aa32a2f7f5565e8660e9bbf9dcd982708601b0308930604f76b3c8fe9ce9cb56631e6ea08c5923afda3da26cdda65346f06d292cda428b4a9506b3af173ccbeca57a4b13344d881f5a3c8f1c13b9ef3058b7af28782a4c6ba26ed9b8057509fa81ad3ff8d239c0b09fbb7da79c742124f02d1c6eaab2a200cfbb2e09e7e95e77609b26b9ce40695028cfd31ba98f319453fc99f1ede3885f015fa3bd504f20b7baddc7b828c3ddb76538613325ddbeef3c61eb96429bbe4ae609afbcbcdd235958b853c0a233e12789318d4e29a0dbc66bb475ce820c1a9829d755be6bce600ec235dcb8853ac07634590cd6fafa67115b2fd34e0a914f81ca2de6bdf9330d9c7307e8374de4b1aa85008d278ac3462010b9c77afb5c5e67f22f08c73460f925bf7e884584a374ceba460cbb7fb3378d4f6ea57c39e03370726212c7f04e72e64c9b10b693314df08ecc866bb73c7a3203a299dadac53450124a45b67016b4254da6a822b5d65ca2239b9ffa80c1484c13c10b84a9338e39b032eb9f401ea34ae6f17018db4f04f683b5eca32b1dbcae08872a5fdf5dc378c233aeed6edc591004d8d940489ec47e38b9347489bbb360bfab5aaaba5758ad92150ef9feac16794d2430d3f6ea493f8cbf0c27e01b99ca4a3073951156bde02aeff8b757a091676670760317c0d3f85699fac1f364bf45d9180188279cbed99c8c69ff486f2e73c5058d424390e6c6777f9e9dfcadf834e94de485e5caa9cc609d71b2f47a627678125b69b7d82ae13fcd1866cefcf6e1553fd83252da4b282b354076beee210c60200ac358d419094cfcbe7256e73fe9f9ffd9f592a069841ca4bac2a27ac69f6ab639c16b4e9a342a0df9b1a1ff5f2bb2f264f96cbf23d72281d15cf27ebcf6b2343d0b810e6544a53b42bacfd7bf20d5b7cabb51b6d9971097d299f91d8287c7752d035f160e8feba2b5bbe154b4f6f1c443b1706a1fb26454ba33c6c092864e46818d977721c02b0c4299e9dcee5a804fd363d8258571c2932fac94e0828ebf7a444e627eb2bed7fe5eb9d1c72169687f732a94045a9de31f5298ff0d127191a71ebac4da86edfdbe8cb9a2283f7d840b465acafe580b6c5fedca02c130b895a735bc463efcd11ecfe6c0c9b0ffe08dcd8ce2c1ae92aeda12bae0489b7a2608a780438d620a433839321dcced17db3dc5d41ce33e6b74adbe815f1253423bbe4ec72fd7329d81bc913699cc5eb83fc22bc70829523784c10c2f1d8827469e99ae4404ee543492352266999b1a0021e3a54716578ac8774f207d624631c2e8082264e0788a1576e5a866d738400067947171d2d28cb46ffb588ee6021afe666ed331b5fcd1ed9f0629f7d9675fd7d84bd570ce4ffdbbc8d2e955fbc4a25545531b3713b613beb2b5066f087abdc13177f16c4a40b31ead38ca771b29ae6a592499e0a6e08fe4e9fb031e74006d5246d90ec7500b192eb3e64775d0503df800f7479f5744c63ccd8d7c4e0d8c0450edd7ede998db42db8a284eef01a6876f6d144051c21b7024936bc2eaeb5a1461ba2637aedd22db109782ec95b4073d300c2209b986109e8d631af5db7205cbb288260e775426dfd1904a2a4c9b916036e81ce17c4852e2e51a8dabfa687291bcbddf68c96ddab501b470e4161a3a4cef544687772cb109bf2fde69122259f54be9fb9aa031cbe71d0fdc1f00b5382820fb197f2ae11e7119ec4a6f4ff835f5dcea652f906b19d3ad9ab9e5a9a67a3b0c43700602ad800acbe1703fa3e6186a54e561b7a51381ad16ab139d3c10c4b2f79c43ab1cd8c7d3243c81016c2c846f173eee6cfdc28a3d968841e733a2d00d517346cbefdf0e1b0c3fbf7ed6e1d0f1a85138b5994222656055e8af74b93d62bf1529b97468160b8ae60dc2b1b77cb416443540a384b9828c78f9b11b2be2ce32b333bc7a014177ba3bd15f0375cb56b038e30a8518efccc5bc0276af1bcd55cf816fe3f2812b4600cb23d7a934b47872f50744f31ce69faf69c1fb5be693c6cd35d14318d097bd19302ca26040fc22d6eb5ea410cf9f29bdb4827f27df15076e5ebb34b0a0f7299fd68c8a0c075ceb6455d760aa01aee31cdae6934076f60da4b7fd666a932d243a587edf0fdb8db8c261c3e3c7a67b97c2c08da015d3e838957e5709bb0a1beda46c6034b13caca1de33bf972644670fc8de924bc2b024e42e0e77a515dfccdd91c6c4d8580e09e1cc3f6de51985834fc452ca05b8730d401fbd181b354518aa04bae8b2532c5f360b3f252074a673d2c9b13ba54c2ed85f6d63b892aae049768cb04ae1132b3723455fd993a36593c3a347c9081afd1c41bf8ca8fe1161a4b89c6aae65b9aecdb7ffe171a2d0ab288d3c7e9443cd3bc15e994aaae8655fce394ae1eb482615417aa1dfb8237123281994332b5f32241464270c9deba7cd45e38c5b15c2e37a32e36915bade40db9a53eeeda552931a8a2ae80acdc7418d76aa009ffd6b40ceafa0a55743a444a157ffe4ec2057a9b3a7b4f69348236ac58235b0dfd317df2cc4ff25cd059972cc290b085662b9cc20ccbe04d1be8e871584eb1fc2df1ba4ff069f2507388f904768a80f6b6157a484d421f1caf12bd97a8edad5e4c2efdc0bf9efdd0e71288c498f549f3d8a1778d989fbc6ff6ea262156bf8c6cec224a827d18279ee75535ecc3d2c3d9c1d7c28b024be958e86b9039b30dcb8d86c2bfdab3491c875aa313dd39d67b648f382520e53e86e3c1c11793641643c89bf5e56a7393df1d1e39aceefbef814492c77492f1dfb322338a5bc4b6c2e84fdb392070cf8bb5b34883424ec4c48fbdf6fc10ec28216c753834cfb31bd1a06546fda3ac111ba2cba2e7c39fc403bcbe54a6b2ad13eacd6756eb9f5f404ec24049079bf548f8bc5a92ca20939e19d44a93540727536be8e78098d1e80d9827a25ebdbf7a4ef4c8be4c2019388564e934d8fa95f541ae09248d50101e3dbf94e8a442df06179b8c6b3857603721a7e10e96bcae4e53e34412bacfb758746b10e2940161a4937129876cc9f87e21e5eabbe7e3c9d73f7d4bb60e92415df11e2d84e36859fc008ebc9cbb9c05e35ef3b34510c04aa55de828a9b2aab185ac52f72a0687f33700cac09565a34779bb6b2a88053e940bb1ebfee5c372eb6e9e590fefe06ac1e10d6afcd5f1401f60ec6bcb85977ee2d2ebb36c43bb45d55ec242ede088f9848dd387f58d32544ff22fc178fc236b60d2d7e866614473a6b24e8b5e70392c96dff5439a10dd539a09cc62275eecd5c1634cd6aa70221715aaacf6b63d6a7c11bcc1050242e6dece47311f881eacc2200356ec1b0c8e7073d30195782f9a70be75ba262338a6a3faf2f9f99f2f9d717869f7b9e8e06e0b9a5f882445450490a3abca412c14b7726ee85c921fa43947fa3297d5e577bea5a8b9acfb2d370a2d8889a275688e4c6c84f8394a949f5255116aa2ca8f903d575f0ef586c256799514a5af566e6f318644bb1d07455953d77c2f63d163ed99c2f85e8d6c598a317bb7419275482d26c2dfc915f320755e88464383b11a3d2e52b7c39592ca4a1214a89a84c902b970d4b6264cd3ae4cc316ab9d20dfd4fe074e79678c71b1d92f62a394e2513852ad02df9c05a1ed1d82439893cfc7f9bf72d9271f4f13dac92b033c4915b8437d14b42476f7c9b23975746bc513d688158b1104a43e6547c7552eafd7c23eb26720388b71c338d4a446df951f1c1d755c29166b70a4bbb1a6086764413c5e1f371cbc59250d496c3786746f85e21bd62dd78a2a7adcde84a236ce115ce83f246f28f6f5ed787e36bbb395235210cb4712b4921b8f8728ff0e30910e045e1e6a0ddeabcaf53ebc13622c670b1b9ee68533ab8ef819056936d23fbce991b819e97ed4a0baa6f421f8a08e09f21919aa9eb280d40e8d01228d2e9b0160461d9de0f5455a8390c7df38dc567550bb4d3a846f1a70e3af816b07eb8f3c135436835833923cb148015e652576d3840a15ec7c7566d2655a1f55cd66f49cac1d12abd774720a5d1e95d12a9b376d68433706b909e046d8fe57a251c8e0b929d3ac7fbdeb804c58803cdb05ece5cfe54e0f2df09a7722cdec180155a35cce5742d000f68f047e8db0802977f5af704e657e353deb083e9225963e76f6c8f9b5d5f2d1e5d3967240183348e8ed500e500c1f2b2072dad6080935c42d3390c5351dd03b079cc541ea8a7f95d0791e24650da5a5dfa24d7bf3da6cbd9d13a11042141220f83a17a495aab9f91f9769aa42d44bb44bd052f77b85265e11f699c5890cd25ebdaab1e6e4618409fb976501e8611dd99fc0d8186564336959b8976001f1ca1711d511bda0fc76a09bc40b88584351a239c12773f5819254ad48e93fb1cb9e5aa3d8390ab8b82dc68587d9a52986a3fedb5b747aabda921a7a7568572e9eca70f50298d24858f592752064bf8213da3b0e138805570e83040761e86ee37b341d34e74603ac9701fee4eb8ee5260fbf63a16438e43e9ff6313413d0125b61aec329907c248304320eab6d04d338135cfe6287b209254993e3b3611d0917346cce269192574064358353a989e92c233f7ec7e398603075c956dd0d2cab8531b4b2a31ad4d138424843ec6c79bb478810f8474048661df4e1c16fea2a75af5cb9ef8901e18edc039a4bceb0437db1d20bc7527806d97df0a539748f2b88ae93d02d36ae50cdec497a70cce934b68081321af9ddc1e528dc8917e90d6efa5c7b5df43e2c709d44e2fccc49b2f5b61e286885176dbb641c589be6d9b9a00c4402c920f6479d07236bc3aa81d446637510874c90fc9d3801178d4ada9d953c3025452b9ba8474e4d60bca92a07f4495c28ca29885a203a338dc1f7c3d0f1838540e4d4e10663a4cea2a7c493c3ef6885b947007e47c12c9b3b9859c15971ba5e4ea913d4a7beca76b02129e55d39815100e308948ec17880632f9b624e1887f64e8b89f545ca0a1b1cafba9f6ec54f5c9f5b88243ca40610938e925ece4be814d21c71f1fd0ff9ee8fa57688021b827ba8f2c24ce8d8f73adf06cc1acdf202a683902bfeaa73cc2456f49e381c67c35a1e40d2a9160eb0b3f3e22fa1b4ed542a27e24dd676d80e0f39a11da3c92c88eb79711c6c2c8c678b657fdbd1af948f1fcb6c62443b33c8b9569cb1f97754ab0a672023458fd7a9e55cbe299c8f165565ecdd5083090caa314a62bd0b0c724b4bd6e7bff9185dca73faf00a0c51409eeb7b15db7dd96497f1e76419566404cd5d8da8a034cf074341566ae4d41e5523f7b1509d08fea7baadbc3c7ecbcd058bf095c3520810c58e833dd8160b3406b16589e8ca95ed743242a88f2cb1ad0622e4afcea321ec9ba1f691fe36cdd9b1c6919228fed1f88beda36a29b5f503d42c5955cf7aad591e90faff339fdb77d86cd66ff9ab01250b5dee3d019dac437cd7f6e72583a1bcb3daec52e010735b82cca1cd64228f593f67ab331404e6d020178a6c8432bb40e0edf5d0bb3088321500294979c8fec38f870acc736e3ef94de09f228fb65a28e4a7383df4b8df1bd6a40fee57b26445814a8cc5d51c610d06474b8dd3606c8a7264b0b4c7780e0694ef6cfd9723b70003ecd0dc49af8f8ac5e5b55079f11c31740aa3317a38e34ab559a6be7831634dcb359bf8cec63b5582efffb277f52d591e46dc922948d408dd46a0c3bb91e32c3e031ff1cd8b47bfa5dbe4aa578ccbc0d05a77124ff3be39a68556b047e1518ef504c677b46b3ebaf41abf5633920d60cfe5d14c58ececaa0ec36a39f87a39e2d3dd0a158cb5a63b55f98bc4ce17091186c33d0a29e84ab3e7147214cfd595e1782260bbd39d9c7fd39421ddbd14ff14716f875d8928b8dcaa3683a86dccce2486909ad0395edbb5989936030442ba8eb6d926d0778d1cdffa2d4cd01de0359ebfa24fbe359e4e0548bd6261fb34f80a856588e927e7e9baf802e126963fb3a30216d4a30e0a53d353f11ad8b5f013a95cd6a4cd92fd6ab80f90108fba864143cc9f78001e8b9f90191ca7c1167864335f565bb872dcb66402e405b0d27b7c27a74fd31d86a655973ab038f8bca7e8a624ab07676b77413cbe3e293bb4c78aea32631314346d4be8bd0323994c1794977bee93d18133cdcc8682416789a74d324b7e15c4acd7dc3981215a79f28925ffdb707f46627ea1c2765870f4608370bb468af15befa5f7f5b485f5a11517e9fa114429d85e6c2f68e1f2a424192bfc06fc3eec8ae9bb5a32de712a979d9505d2b701f2207db20edf6c21852f5afb580259afcb4a8d6997ee9180b2ca216b6fa39e88ffa27037312576afa1bdd9cd4e634cd5f3647b3fa1559116e0289752142acce1c8f43c504e71a30d1e26e9265f08bd4ffc3cdcc981b84011ec66c7a9e00c19bf6a1e388b0e79b80a996984f0b6b98b0f686586ee0821bfaf6b510af03411ba53de51504ea656556c969bfed9b7f92f3b039f054eb90973a00b19fe16b4fbfef6581196af53de5f00d077eac9b2b0ffe7409b5a8144dd30be4f84049e290eb3eaa9f5008d132443acfe70b8eeaeebfde1bccee22078f0ba3189af6e3abb50822a932dcab637a3ef7647a4b47c80cf3ec0959f0d99d5e8380d6561a861a294b2756b3d160c95b1c676a7276106fee9925e59375d2de904518f1f9ff3eb5c883d394eeb3f880811d27055337453625ffb25a414cb825bcc547d572d87dbfdf4660fbc6a88cf3a2181dd573656ce9e6fa1bb6cc13bd356713395af08bd5f6b05bc461ba55205af0522a0e91daef055277baad8e3437044bbb05557a895a8ab3272c741e025dde117242038e388c2f80bb84344579cae9d0baeddab61686c9226f6df341fd299180bcbf59b48c59b4fb63a526f0c64fa824ea9d97883b32f707e88bd088c5a08edc2aafb7d1f0a38e9d926e753df87642538cc88b0ef8398e3b48b342d5063add4934f9bb91df930d3297c5ac468f8e7f4a4b65abfe8f8a6cceddd351460ebd1822c137870a10537092bf31046321a95ef69d95afe309a82179d88aa20f2934468091b60bddf31934838857612242213c1283867ee24b4b4ae3c996f388734a429c15b920ce6bef0433c84da0353edee02344247d35a8474ab28b9875c5a397348c2433a1a97bea54760d2932309933d77cf9061a2bf6d2c1dba7497158684a59ac9d27d9e22eb832b4c9aa70ed81bade363e0f6c26353cf53a0612484709489a756e3c691431257982227d7e3f87935","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
