<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54ad98cf6f0b1411b13ed61beea6e6608dfe6b75bddf15994ae68b3e29ca4ecd08fcdd7659833819a044ea9688ee0cf04abaf925734d901f7254256c1947c7e614a10dc3909ea1ba11a54c0629470d130a6a676f26323fd90c9670ffe51a3b260f7285102828955cb182f353b194dc4b20f9fd148bb7d3a84833a2bfeeedb78b28e5214b90c52d883944ff2366aea3562c8ecfc57d3adb9af7fc977ec321b6ed80143715d89203516a2e34a40004a19514f43cd13ccec1cd866d8c14747758fa438e52e0b39b7fecdfc285687725780699ae9511d279f5a119d8d34cbcf9fd68b42396b727a4f2768d2963fe73b096788e59d92f0ad990f6feece784fa5486dae9f618629c42c05acac0c968e2b9aef4b9bd0d99968b4f948fd631bda0edc185ec200255602d55fa2d0db619058e50eee9f63ae5a39d98bae0b9f8b74c60da7e1b7cca2ddf4f6af45391fd77b1c0d7de1962a622c36b7e3e5c12c2eb868087189eb4de6ec8e8a4e54a93ad056f6d57a90baec7085b85d31c914b64581f22bf6de80d1fd7a57f8efba42330dd8d031f2f29d353a6f155b3343c1e3b8c19b7339fe2ef6a395f6205162d5efc2e8c1434660b2c77aacfc09645a60616b9a7835be823c1889ae51af225aa7b95ebf7c2e6155851b734fe2c8c7ea60f0656e975800629da61ffda5c80bf22239ec8c4ba7c39fd5a4bc35bc19f9dd5ca023dddb70d3dc47fd42844eb5e50d07294f677942b0ccd6bcb23420190f13a46398c0d288a7f3a60bc60a97e31985043f51bc1c39b6a09b2408b1a52c06ab7ade581b753e5fbee4c3622a01557045c0317d60d5d3eb1da5de14ec402bbbc12a706d5b87a29be2dda3e3648989a8807840883e5d49218ee58c10dfcf27cf4d34b6b5aca5fefa5fb1f052f723325d830ac5ef496987962d985e90aed2c9ece12c90403cd45e439a3e896b6e8d5ea4013cedc91a594157b171e4e9e97ae8eb58d5bd4b248177ee3f9a61d36045686a0123dcfffaa16bb6b94e6a94527fdd22e9b58788f3649f8438146d576675088bc71c71fbda6d1ae0487a3e36cff0e190d4acc8b084abc119e0b235e5d9abc8d771075da9b93ccd21e1943b4fe454b5ccb562a5e7de4ff092585bb110f0476af4600438d415c3f4433c60be981ca847aafe9c4f691a6bb6ce4e5642115f321aa55371b1f6b1e603db0041366484f9aaf800629aee796f17cbba9c7cd7a92da48ec0dd2f1ac2757910a207b5b9897afeba654602fe4a12996da714bd53852cb43f36e95cc5103ef6c49f07cf5aadecc314c64123d31beb513554e9cc11888cf2705f36ab9703aea20e243f5d161e134457bd1c5c9044f99e76432c5deb91fdb6b7fd99fffabc9f694e5cc3b464c010a039d344be6c1c04791582bf5762069fef191c39828081f20c0c7919ac1435b0e386c9e068bbedc53d5f88903c307058d481e59b6b6910ecc9427a492927b50741a1610ae7bfeea6b61a9284abc22c1b823c8d6cfe8724b60b4446d3aa353fac12de13d6429fea53a216cdece81fd5de925b7106a9fa0eb675990d2d01a880c363298ed4677966cb95008507c49f55179a6c81a8fbe3bf74a5f1706bd130188519195364cfaf19d9d09f64155565f11e83054eb1efb08b2b4aa52f792e8c7b3ab95aa32b359a95fe165c65f634963e2c47d03d7de67e1e3ba1c2137ad3997f327e3b5ced4e587b6d0fc48defe9c795239199ee47cf276d5bedb671090dc0968ccb31898fd9925dc4dd37ead14a3509843830bacba5d2f18e7c4c38b14f10c1a5b7e211178f9720fe6f5186368408ba96cdbc327c7c4bcbd3e02ff86769337a5c3577c47d0eff9b2f39cae7ad8a525d40a97c321bb5112941c59dd8db04c130f9f57e2fe665fe1959b8234cdfc71d5db36925a584b3625d9b873deb500237dd1a1975c9549b496ed889a973c72765675a690d7ca03b1678f47abb2c3eacf76d27487caf20b082cd58c78e2f8ae670e551c9673eaf85b7b2930abffc2beed419cbf3225fa5db47d5ff958d2ddea30b07e6e267e8dce36f8a3997963300dd60751d1dc14b9ec0738807513bc07c47b5574df505ea6103b02358f1775bd58be05f87ed681a5d56febc177a92f49436d28cc3766e62cdbb605da95ed8cdafaf286bf80fb8807075cf089b59d731621c0d04e015fb999a1271d9f2b30db7bb4c6b913371ae740dfe6227236567eb1adba11017cd22dce824abb2480a2cac1506410804df61c65183b02b2431dba9c258b4d6302380693de2b76fad7de399aabb81e2a026fa3fa693b7402d524fbbfb71a1f03d7449fecaf7b092bc66441f7d549cd5c16ecde53e11b41b655543da23155f28dc4bb55a12d470f210df228be669924f7df0190af0e3882b5d804acd78849941510532dd2d36a03302881a56328fa096e8fd92942d474a061c29909265bc4e6657924de74dca0208c31a47487a10c09f98e337597b6cf4c0fcfdcd50601fa92222e7d57b14e8425cb037512dff0e8982b22c1f6b6ddd0b3d32ec24c10a5eef9852e4cfa3202b0429cfcca16f39e9b992fa5a519e14ae8c9c097db5e579f92fcb1443728d24814030b7905dd1135478a5c94154dca47670345a450970b2f450cf67b7093012c2d91094cdd1beaf333b124c6614488c76c8bed8e7da53012a998103c316f92765f10dc7ef398ae033b6f5546471428b44d6127f66f3fee4fb8de3914faf10e943246fb4604b14424326614accafa147bf8966e60b3438c17e472bda42e6aa1db200dc361a0a9def221bfb6b214e978ef87a8d6396035d4f3e4307c9c657148f3c04b19e970cb5fe626af8a8eaaa2513fe68c72ecd1910e87d50fc1706d61fcf2369d4d90f8f0ac74c7e8fedb8e5a61a0f609417bd859ffbb9e2e37b786e8f16cb8a60c4b91d233ca20b8739cba5fd1f18e4f3ce500c1af2bfef152df64b981b095ddfed8cbdb2a79ebd6c7ebebe739154e753aaee47549de65d855f2f77f5e3acc307510f76cb2992e015518f081f052572fa885d2618904c0fc4e73f7ab4ea457cfc226c8e09f025b5540c03b0adf4a8d627fa284d418326c360b24c92d0ce71c3a9f2ebb843222ce61b3e67d739dbb60de2fab0cd7fdd8ccd46a4ad61dd13dc71296e10aac1dd969c84c7456143d332b6e55e6d3d7af9910e88c8d74492d8aefbb9705335630dd0ffac6950bf503b683eccf0a2e6485dc6b8185be4a437bddc3139aa729235177585f2485ca449fa3600a81caf68226c3bf294e58a98907f61b63210970fbcc8de439409c3b6d3b962f014f6fc4102b26009ca1613711d81962cb856a04aa90f6526638b53c138cbc6b9e1842540bc1e0cd34785ca33fcadd9957758de4a213167dd12c51c263c5ba271dc405203e83a257c979f9cdf3de1916aa64e167c7ac94c5b6742a13dbaf981893fa678b5a00a579505af62015aa01b5b837be2030adf9d538232d8527dc9bc3deeaa841b530177fe2be0cee5abfcaeffbfabf9722ceec21bc9c92bdd246b9df3d189be611f844e5e477639269eef39c2642abb8ee5a9347e7b64a167d56e0bf2b867e17de6713b2506e7739a92e90ac606b0919ba0c5e9d6e6c109d19a7c1b13fb5ed5909066cf6584815b18568893f1044b34f509df3efa6ac22a959e0241a6bf14356b8adeb614c256296e7f58216fc72c5429aeed356a0122bd48114f95968f1e34686ea210322283cb6c7d62ac81a39fa7e4339ca8a0a2e1e47f63cb8fe70c523d5e3a946f1fa94bf6a60001248a307715890fbaa7a50350688f8c5eb1d1b8cee7e7e5d3c3c2fc84d3b1e7d2dcdf0d729c1383f03c4e99f984f774aa272a467dd4cd4dddcc970d13ae84a33e7eabd840338f354ea13100949efd66b0f5784b84fc615d347011ff41a610540251120484137bb16272a0843d7fbcc635afff3d354f1e98a91f5f6c5c0d1cd87bde36da305b67a96a2364d0dbdbbf4d59ef6ae938443f8d9f05b5a324c5d7f933d6dbce1ff2bfae57894c18f5d155af662bcbdbdfbc701e9a9e6e156b5f9d93af19de8736b7fe62609cc41d538f1acf9f811d8367bf45c48cdc4cab0326af225318db7048a967cded9769685129259f53594557b6585666acb0d1ca7552f2a4b5d6131b474866911a093e77e9e3b9cef08e3aa9bdaa208d9cc3dab8222605c02a11f297012d85a17e87c37eb166a779054cbbc759c7f39344df4d5ec2ee7336a134da9da3609a27c7419881ba9b52f473fd025d2b7e3185605eaf0ed5f5df721892ff440b6fd1d6a2a5aedc4714d1a027fd73059f913dad878df686bf74c793ff7f2284e54cd9f2f6754d5a088eb9f54d7c3dcf68bc0aea440bfbbea4d5346ce863714e657e4b4274c7fdd332920bb9c2ce65eb9d8a5986b0bc8cd7c6c328a06757f1fc7834ddb1985dc8d1b7c8406afa559767395c6f504fb8ae04aa4226079cc6dc96746633994e62714286690d46b3d9faeb68c3eef1d7b9aef18f8d3dcd1eb14145dc58db365fe5554f1d27c14f87377fbef0104f9eff9accd9ffea6e9040e2549a33f7941deaff562e0cb3ff84185d543d9bd6b78db25af3db5a058e9de27015a17ea349ae1dfdfd5a539d07f1ec1fadbeb3327eb2d8cb215bb51a20fef91b9beb9b8317fd781301df52879b9db1000f93f2e493438ed4b973b3b56e23ccddb925d19700e520a770ca60309a5dde0a4df31cf80d0ec9f0bf7fa731955e26aa69805cae02dd2b71a2a429eccc3f364bca6f92a83c4f261d7caa9c24e2a7278a68f08ab72a7499faf3f40fff1484bf1dc008864f9c397bf2cc2861d1c5ae4ea5b2e31603c94161542588604813faa2381faadd1c3cfe20beee417cf7a0c7b550ec6edc16fce7600996929bf49a06ab7992af07e109932c446097d731c28d6cc390daf6b6b9f6dee3a47fd619ff7cf703727cc873975a9007be29e2dd31dbca8abfb39304aad61b3f86ec4175c78a9ee80abc682d9d31a591277b7c728b8cdbe3b620e40e2f190497fa204b34788c9c82471e6a3ba9b07906cd70a10eca8b0be80cb65c82dc76305a4ee9dc72f62ad197efebde801dae2416f03b10ef2ee568ce6955cf76f2f178d6c0a8f8670bade69e28bccbbb9904a6916e89b459078dac76d74ebf36f3c1b0611640444fad64274fc8afddff2d38a5144eb5783a91c55222a0eaba5e5bc5f931502b193c42380169e6d5bec99e8a0b061e487b34e456f0cc9058e016207dcb9e8eb24e14bd19748de9e84efee66e6650c391e7169348ecce1ff403fcbb9b392f2b3fbee91e7d0691638ec6248012b2e1ecf269faafb53819d21adb5c4719765eeff818c43efe34d064cbde88312a7d1b442277e7685a7fb3ed6d0fc87b6ce4707838188641a03ca74f14d4389491c3317f73841da37e08609b6a0986f2f745edb45992948fefc1841a956d3ca733470f7f834abef941a137d7eab7d53ded69c9de234aff160bef2c8e88f97956592445e5ad627e8fbaacf9c26407d9765dc383a0fc05dc28308482bc5c8ce87f70026f33116857e46ed2b741e99877348079a6ee3dde4588cde5a737e7666eac93ce75009164e3023dc103857f711dd448c8c6fb8a1e670f8cfca07098bf709746d28ba5897fb40678a8be688a7b3201699b5afda3815e3225866f7f622fc90c448428b856cd0c080e7620c88a9db0d2be9e3751112c26c1fc5ed71760e0a6c0233243e6b92a3a296c9121a0d679d34f728d6c205538764ccea945e2ca43a5a57a8ee4b2d1186e563adb3e1f8fe1b04a9f263900d300e525f09940ff3995659d85f398cb035bd065e1eed1e4465d1172876e6f3f08c943832c51b9d44af0bf0c4eecfe9ce3cd92402df7febfa34f620db1767178fc9a3e4827f8f82279e3858aefc6e67752085a95c3ee1f6bd19ef507e61d4216e3b95952f15b4457644269478a32c0948dbabb10c0866c223dabd255123e38a84f49b01473c772a56f8df1cef068edee0cba35523e3a82c1b402e68f7b07103a9d0c1b930bb1e19e6fd8092a88dc483dd2c9e0a08e85c4010fc3fb56fdc88be8bda4bb693173d84ebdd49f24d23f69d57f3dd6bfc0b52577ab9d0d05808977426c7cab1f3eedf9fa0af305b60e122983c1ad03e6c60d79953423bc76157c6b6555e800c834f3dda22da829ea49431189edf6e029eb4e555cd7f41b67796c0240549e9fc77a140303ce14f1d59ba5df305dd503f2a2b39412c6ee0a8ad3b25c8a375641553a6f742a990cb397bdf2d000194be737bd23caf8e0becdb01b074766734a204598b3de3e413089a988a1b876e527cfbd1bbed2f03c8ce5caf99bcfaaebadee3a57200f6a170a354905229657693ca39198a4ffb95d04161535a2ccccf73d04e66d7becf05baa8a01e8e971831bcd790a6b765a65b75543f4f1bc9560635b317b90e1b9c104a2592636a9c202f6e763720cbd3a86ed8393fa31d9c4e28864b239e97077b2c4df9e3e89e38b14c1c877cd303b5274b650f697eb7dbda83fe8d82db429e2209416cfbcb370fe38989cb487f4536e6a499b760b25931eec330ef7ddb58de0733e89111f09bec0805b5202eff04d54a2e8461354cd5fbb59f5b525d68b3272c832a3e119923ab0e95872cee643350d41a7ed3cd89e15bb2b1429d9e3c772b6e1d06ccc0d6f4df40a040c77958c42b3bb1cc5ed544674693eef4c86328d68cd28f1208877f89bd9442bb93bfd903dcfa2f725580b82333bac3791328fc0d9e953c26b0e9499485f578aa8f90a0980c397a2b31595ff714d4e05c88a5ccf8328c1365ec41d8e6ef87ed5664971acf9068d0686fb1a2af8b020efbd769e509c6bc4223b2010500eadfe87b776bde06e704151797cd392241daeac5d3df7d8cc8d6744050024ce2fd5c577962cbd8201f883c61f73ef05be94d68f7135d785944e6288c86390667b7d7d5ca0b81c3a45bf1ca6306deb2a0e11cd843a58015233450afe984942689b377eceb8cec3b7eb812f6f40f06274561925979a59a21822d07835acd79cd2e14bd209788f87e2dacae336e673f4ed9ca4fe48a625b29906301bc02084d135d0e924a1022f9f8d0b78b9c72583f94bc9c541ee4d6e371851f20dc2977855de3d54928746eae6a36ea395014fb43117eb3be3d5c71d5debac8d5c8ca158f6065a9a158edd614b71fc39f9532275f52476b82928b8f8517577eab74b147246964c334ceccff77f340d0ba4509548a418094dd5e7c295aabda374959782b66ffd263a0c586617fe7922bd238dc3eab319747f1daf78e6cfdb1b2d6d044ad9bb23816cf90c1216d13aaa69830f4212da921cc6868b2cd3f3869f24dcfdfffbb8fe1a6215c37b19b264cd5a1c9401448f1192bc233778f0fbe1600c957e9f8c77f02264e477955bfd80c3dd54d2b0718b39c8f5363f8b956b8514e816cd4d03ce439574489a6fdbe6e543e7d24d7baf432b64dc55207db2576f193fc1313b7377c96a1de0938b500143ebbf8853330ea5f39343d16a332c34bd9c8d4f35eadb5ce0257122c3f1cd0e49b69466bf6f87e837a808b8a16bcc8dcaae0ff0115dede7f9bbdf0c290982f83a718f0800b3eabc61f6062ae108b64ee7f50364c2b68f69fa15e77cce4960332f2ff910167e87e0363a574fc708473a66db0612f881882b11922b15fc6f0c44956919858a4ebc95539d75622740ab97628df9f50db48d194bc6e850a7c55435d58a9046ce1660cb954c179443248d884344dd9b9fe3b285ee114fde541b20195abafc5de42f4cdde1d57a354dab95469b1c864b8964520d9fc76a3ff2bb36291e68105533a08ddfe82fc050a856dc4577d975678ac3a16ca6d19ed3433c04fc90e8b0b34ffbd66af1b2a7a48e411a03dd746fafa31ea84215a530ab24728d0fa1779044a4c1c855afd997ef72a62c4d7cda56f9703d4c1af080494482dbc71f738510d9e76d42d371448ac557648955e77718707100b554142b7243cd514e5c56cd7c646441deee2e457beb6bbbb5092a811599f8d3dc39cb3d325261f892ce1fff075aa84be0dd9b4bc3eb4896ad6eaa0985c4cf9531424e043ef794439809ae34bb0990a3da0b688f90852d9d32d3841b8c62149bd7e3ffd2bebff5c6b91627c221edee9dacfd906b0d7230cc2f7f4dd20170bbc2119e855cdfa24b839597ae51d4e187877b9d3914b05976e91a4729547e294cd03fc36d06646a65320a87ae9510969459cfbd6a6bec45b3e794ae3019e0f855631f54fa9833ae728b620649d3c77b0f0c79c4d41552660fd9a9bb6a38a77b8ba781485832989fc8ed892fabe91ba5327bb91c8470400aa4ee99c7e6f931c07be1513d07c875687ad5913ec8828fccd9f0016d9da39a5b757a64ebdee9065d41cd24d00f78d2c7adcae64a42805c1738b563f3733e151cb684ffb770127f563eaeaee4c14379d75539dda16d90cff2d06e3c137156a2c9cd2f7d4aacd9cf925050bfea63da16ac8ac1e9ea0f8b2eaaf06054b726a2b3581e1d129e1b9f6732ee6e9f42e5a60b62f956748104cdbeb74566b96438fe20ce61f565f2b294f176e7a61fe78d3289cbfa52fdb1eaaaa259b1b1f193681eadd443fe4645de79d629180aa0acbb53cbd4b15de23bdbfdc8c615ac2bede75bbd11acb6e6a3d3eb2107132511e37913c889404dca02199cb455c40a1912fc8ad103c16b07539601f0e760829376e502ba2d29ba36ccbb3342997cae89f31ab5f4b6e12f9f8bc0a60496948a3c182fb87e50c7f725e427614ac8bd7e51332c24cefb96c03c7e5ab9cbf3941566d6559e8ee82f126e5ba699c6fe9c2c715837887d5dae31b57dc751086512648fa56b93f6bbbb4e5aadf5607138cfd9cdb0a2c4d4593c623350949943735e9ff686009cecfc9ad735a7508706fac07c305cec31b034ebc07f8d33290a59b2dbe75c978644ed22164cec33fc7d33724bd3b8ddfeb112eb0060187f602118b82e9088aebfa3f30c048928439d282fd062f16c443688405469a71f171f2e1f918e23b3fe8d145e6c117487a632191bca1134e377ec5a8c9d98268ca9bdf1c1871387da5c886c910d2591f69eec66ca951705729957c6ceb8d99cb5925c4af07f3b7c38ef95a75606a6f2cdd85a693d41130ad16c75637d585b165e7ea76f8442ae21de2981633a8f83a2562c42a75ae142196a5af06ba7c353b44cc87b8ce0c66587349754f0f0bda80b93478a1c7562664e71962307e2cfe438b7642a0237a71286939cf46ae03a3111ca571283071016ddc7c6661f13bd32b57a865c063fa0cdcda008c0afa82e21daab6b130e847effe4dc5f89a2dc906c182dd36199b06d3e443cef19b685d903aed683e3d5ff7691bc4d106093ccf8817428364f2747471468e8e62b69ac13beff2144affc39779dac71452088173e0b6ff1634dbaa212162a363cd293bba6c027d229a0c0c3db1e7f857f446dfc2a75920c0eb187d8c84695f448c2ad896c397ead9767d1c82c473cf861cfcb95b61990413657c6552901794aad870316b343c568ecd655f84258c87a2503135b34791ecc6c6dc8ae88bfabdf051cc1e83f65d4eac7a43c3964c5176a7041a2fad3203507e81fad998633757fe3713b1b36a83b0850dd1d9c3cff94a4483938474b6440f039ef56aa8266c841f9bd1b2607b1d44bd2719acfbbd76544c4d8b2a88bf872f2e2d84e1a6432c57fde21580f34f6d2a43ca77a8c1fc75d2a259b8d7adb569c7152cf3e326e2424ba2bb8b332eef2793a3c75552a71e5c5972a132dba338591746d21b7baacc714bd696e1d8450f02269604c24d5ef5f41859ecf262516f0c8b9f6d1ad9eb25c9a1d3502840dbdf109f7ff062c811307b027cd5c3acfedc104738dd996a8328014e8b5d3a048c6b5974526414bf185c5c64ec1a69177c1220c4a3dc0edb44a582f55ec9d121094b043549d3b54cc2733bab5592d9b323241a484b92b0a05a5b5e7ba41151ce5536593ecbb00ac711491fa5d9cc28feb8efcc8715f38d35b7fb4ae1bb59aa50775ef8ad0b056164f49cfc4eff553d0120218b8321e0122e8d79fce071e7927f65a1ce9d81275b0ec9d4ff444ec8aa5e3b6a8a20b55d22cba7638e09d26190b53c8afc532fb3a76a4957904259dc3df27856c5fda404adeb7775b11d64cc6a3fc869ead437a4188f07bd63569bcda93d2dafad4b3d514142cd985adb0f9949a5c3729905a552cee2c9556e0758cf5a10f243b4102ed410c78f675bba03c4174f59f1c68d506b2405613d30141ab56a43884969a713a670e35d7dbd3e56d2a17cd8106ac77628fb34dd746058a03797dda43de6edb63811e9ac88e52d69d571dc5a45a62e6a5113152cf61c9ff277096e9a7c37e92983b76982cbe0ba23c43d4611b0f019f582537f14368a7dfcb66f43ce6581b29bd9ce94d1e6feb0b99744951dcbd5c28dd78c64606126578fd4000384966ca53e4973be656a50a95ae757000cc1b0137812ff1e24dac1ac10b8b13a360878b85f108b7fc25cd4242873dafd4ab828cabfd45fb3a46c50d97eb6ebea7dba89a0e4948653af010026e9096e0e9a008934009b850aa0c39075e07af9a5eba8ee9050fc45af43de5847bbb3fbdfe1f7a8fe86f6ff3a2a1e0dc86f3a214f97da717713bda560e7d843d4536bbe0938a085ae18bc672f8d24e43db665aadb523c2c17251289bb462278173baecb3983f768140f9ef54eb95e3d4c7c438ece6a2b0e7e84f85c54bd57744e08b80b3714ee729d786f9b295c3e2b2c4ea1a21670b7e8a780ef70fae225bd69bbba24c3b58d9275a1a0ce3ede35195feb12ecef7d336315702222bfda0ceac7ea9ec4bd3dd6271fcceb1935590c597b777843f52b5b0b90ca7fa986d9b1fa6f9b3d173b408fbfee6cc5f6551eecd6d66808781bba23b8940dffa126273a182f33bf37342b3b5887103af9cf74ee64cd769325d9cc479160266ebc7c2841778c26b73e6b8e14debaa7b3011178eedb645df272da3ea722e4a54c93ab6f90ee43c7da08ccc49838f209ac17c15c837bf62c7056c2956813a8cc0e26306ac0b5dabacfdf79f52d8b8464621434ffe3e7b0b9dc570c8608ee58cec73bbad6c1aa07d1201260356336ba78ee48e93437f6e047abbf7a9f6543aa0a271ebe32b8bd7bbd33b12eb254718e3914a92dbcfe9d97039ca6f8c008d955c4fe70c9847414572b8f808652dfa91ffc93f203aeb0fe4bfc4f0b31077ca46ec2a32b1f4e6b9acd420d39477eedb86dded2b7b4d50567a4cb8bb423244fe4d6da398f076ebd32c206f2ef14ba34a9714323db50f0e8889221269e3f2e56feff1cc21a039d8e6d0445a8680dd22713ab9c2d9696d3bc3278d799370cc2af79ae406eb5f0965404521364101433f9ca18033f33fda88206361719616f883651356d0b3a12f967a6ededf08e1580820677be6aec818113292c56f7b71c55f76738e9a51e711b19bfe1b8a696c6fd2f8526b27e38565aaf337464059360459017d915a04252cd03f6fe56ea8b881e49531e4f285708cd960efa2cc7e06128bd6ecef41672e96aa4fa7e787960b503cbc6c527f422e0789a33c506a9a3b80719285aed1efb804361216945bdf20cfc69fccc9b46b77efa15b2db099c23135a9729fa300139c90bb4e11c3d327e989cfdb9718f000a424b28df5cfeab90dcd7f5897f12432cee7f1fded44726fdc3b6c39b51313c8350ebd8519f03e3d1e2b2908b8a16e3338d48e40faf25c88c32f7dc7cd087a2f1145449a4c7f6a48b3766db004ebb961a361cff037a61b88074a976f4954a4987ff8d49c885313a205404f7e5cb5a49f71ad72d79e61785b76414c0a1d46aa0f71007487231d9271c8c71ef5c79096b24449ff7d1d35505dc0ced3732361b7faef66e13da305a8d3750513d3cd43da18d8a63a7d66afcdcebb70ec92de9ca358dd32210d5ab6fa55523bbb2f0386351014a91058a2a12790640654ce7210fbd576c72bdf9aa58fe135a4ffbed9196e25e7581d42a03b22c70da21851eef021ccdf20bcd9e3b92564d65b80e55d9c1122d59b5d7ca23c71cd4fcf3dc71595d3d20d76503697273063ff5244c28e3e0a26233bbf2f584eacf052b3d494780a0bcb90d9e182223e1d0a9046b3059e39b429ce72095d1aa4a5e445fd15b498a7cf13f516c6bb1a84d68a23c112067d91648a99fe62b908efe0abcaf4bb3d82a705b099a6d43195ae6bfc603f451f81f5a68ee9c013719f716ca2b1d0ee68a201e6587d52e8fa0b7047f9b092bd7852dc27e1e783a15fc4e4f","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
