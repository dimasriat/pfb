<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b60c385d899079136b09b4c8a4cca035aec17989b11e99d7d5a752e4572a7052fb5dfadc486cdebc6d6da0d04778a2d65bee0e1af35901fd45f69bb436c682cf1320e742b2e4d1f2dc937ca808c4d6bb6b63f1529555fcbca8678141b4618b19ce2171164b8353ec1fc775f4f6c41d4306deb00de1ef59e1d438ebec1105eac18bec1d9d0cb8121d9967c082ae07f9769ccfb2d15959b3f1d64263983c15cc7a007a4c08c81096302ee9a06340809b26d473315d3fe6168c3256b04218ccd0ea06f1aed41ce9ea81a16adbf291389cbdb819cdb88c39aacd7d216d08bd873e9540721415219a6b590a1580305d5cb3b66d3d0b1dc71659e67ddd8ae427d61652970a737a9ed305a095fff7b1bb79808b59a6e56629370c485954b6ffd6a02e512f132bb31dead3996c8d255c6e8b30709fc354f5288fed4670c7b9d78ccb55752cf24eae9111c1e9be59df4dbf622a51bc71afb39f2e821027769590a11116ad79edd34953bcb95f9d620a4b5e122db904ec1e066124234a70f031f1a84e51ff26e537ba5373bbfc61acf96d5c35c1cade3f0fc04269cd3b939b824465f0d2650d2a613e52f346ddb87fd97d6e62ec09696d1d97e2ed27ecd140cf0c3f785d20be984f5bc9d8cc37358649074774bc3cbd493afaa5b0f4d96d6fdcba82ba9e0735a340aab803faafaab10a637d8b78b6fa4608a9825d09b5bb1ec8b2c330a43c10e2c1580acda4b304e5291cc44053323de3e330be58326620544c977aa9bf93cbec4b6844349e5d7cd001b8f4aee5a753fb88a7af39179731bbe68887f214424598c912b7614748f0d129df3d12eedd729c4845612878f51036362728916006fee363545d058e1a75fb1b14b80c3cfeb5061c4e4c7d991be4bb24408f16ba7297c9bb2bde3a96d5181010ff73be044f4447328b8bd0fbefc37da9870baec398a3cfbf88a5f6e6686bc1ec4cee56068ad772b85dbb88751955de29b20ba540d5116cfd61623635ba5c587f9cefff427f4f67a65119fce8a5a10aaf28f3fa239854f3ed6f27f08bafe8ce43369b2451202385dc87032e4c7c375a7494bad2b683f86b0b3167c3cb1b5f8696b28e0c1d666159ff5105cfba2667b24f5f33c4c5f1333f61acf0845cb64b5e7d9e718747bb549886aabd374a0991a82e86c2136e0327375922ebad24beae151ca5db7803ee836c1e4afc931b0f5ef5c19f72425622fa331995f30f9b6984a030cf9a6d5288a25c5d828f5dc155aab3e11c3cc73ab0fb1655c08392fd294c2cde395269db38122890669ce72506723114e3a6215b5423f9d1847bc6fc3787e254d92c49f2b6aff38c7fc4d51fbe7efe765bf79fb890947bae125ab108b916b35a92fae00f9016d6cfed1f660fec9616a78022d22f7ca5ca2952c5d7fcf2ce78c9e20e078186ccb8831b8e5154de274918ef7c106035488e6ac8912c986ffe88ca6a4688e91c9aff9d60b044474328f827bbb8203da3dfa818b94eed42872c853ed9664909cad7d36f437a612648b7eea36871d3511bdeab376be666caa422cc83b49ce30faec137eb4cc6ccd6cd492cab588e37a3cea4dff8d8323fd627794d3059b99a5d496c900796b79de9713edc64a30c44c4431fd54786d7ad036816aea2da7b4ce3d2c47201421a2cbcb1fe98e41a6ee44f29e5c6e834b1e9fe27e8c9e62552bb8fa6cb0a6806b6d0bb65a3f2701e90862b97afaf582d23890291b48c7284a05e99ebc2f11f5991d20d4bc4696b76a13a2a8179c499150b8ef5df3b4bcb7db5d8d1a88636093d580ea25de8483f8c6c656e7ae3320c82e723a464cc77445d5eb530e9dd6447ee41290df8290084535fb6297686b033281bb3609f72f4cc2a8ac07a30891177a4b018fc9fadf7e634808308d2eaf059810017f653e128e809b59db9d6e4b2cd74913124b7d9ba5ebcd2cf7033b3fad79bbc61eab8d58cd2d932eb3db10479866dbb714d6fc53013bf1d1fe1aa576ee79ee439ba624b98c4030574da340d4f4de74df0c4938a52467117a57fd90e9b2c5b3c4a880fb035c9203e3c236f571e3d309ff4a061d156169d88314f29daf3bd1e69ab60ea2f3ea0ae9016b1970774916f3454be1ea276a3bb4b1d70f30523ba9ba9411928a687d0371e211b7a0f5ef12527ac4836d99821617d7e179072209911f98ee0335ff709fd0fc442e2302f058f2f624564138f5e71f00b90bc51346af761ead07d3b37721d38ec4a3e9927dbae51dea14c4148dd34e64284a92b115e0a20b08adf91f493663aea6ab5d7213ac5d704a464760e931ac4428feefbd0ffea505732d672c49c7d73579ec96a6154ea87a5a52b60ed1ee4d7c765df8a7dfa4a211ea5f034bf1659890cac42c02e177fc2f2ba8b2da1be1c7ccb839c3971e49e29656e0d54777a8d049c91486a2bdbf1fcdcca52674b898e97786907c4f7207abe81ef9a2339e88ee91214cfa9f562119e6450c962aec78692ed05adf08c2038616923df01f890e130520a7b7b548e01996600f49274cfbbeba1dae1556537ea754422da2f63930e9e16642d70c4a83a1399814fe5032339d8558c613c9a6935e4fb59ed4cd8615dc77e4f157ded5668b36969dd63895a66d9b90fe16f5b968070fa910c702cc17459cdeea9970f1506335f677e717bb33261b800c94eec08fb49adbe234073c0cb449c780c902098e3e57c06be65249ab86110006ce943d8db993e7698e9790d6359fb2e4ffac61cded2dbcf4a16bca34b91d1bf6d8b48e60cd2b3576245d4a0493363c1184fa5edbd2bd54714e0e5e5619b762efb9bba42927c60d0c50de174ccdec0e0716aa0fa1bd672caa7c4e11da47818f13ed3e229659fd3079b909042469f6d1967bf0ac820cd1cf1582a067c5cf5678b7a5c2484b9d27123b6685bfc412a8bd0c215d1aa03bf8b96744ba3c69d54e8822faa529355c8c5263b826b695993e810350617d94144dd819588b4f5eacccfa58a8ccf9733987fc4e9e635d573cfa790f1d79c1ac764b2183f66afd38e4a52d106e234830b06cc17cf8407cebbb8d7f2218827f184a62345f67ada1f0d4a0b8955058072f17dbfa1d9f0f568d313ed8c3a82f6110481d38c25256e2de53ae890ba6ae376dc4fca51e1b1f105acadf007dc01fbc7be8fcd2e6d2f0a8c9ddd763357b8a58760dc5bae85d58e2a018bcfeb5afb2b41696f99e2863c469adcc9fe10b6a520496305069d20ae229a5b47637a0b6fb00755c98e38ed1d32cad865b9cb02056c6973ebcdfb79943eea11936d37f1ec31510e01bf7687fb6a368efa6343f7485a12a27cab39fc4baf00249ab891b7465b5c80b61b1ee5c94272b752d808f0282b9ccc2cc6867789a1e1a9b72e27113c678c6c20bc0737357fed6392ec92b70966d92ce1b94d53b831d42c186afb53bc85ba76fcab8bf8b8049819a39ae7bd616a4321504d65b444672d48f2029b603a1aec79c493c9aa6129c7d60c5bcdf2aea7b3f11e88e5732e852667140ff5d6b1237ee764e624849f4874de4fc0bcb5bc65c158801a558fbc54b7c5a106453c45f89dff0276189fda0c78820191220ca87efb2c04aa2db942a321457918f180d6b73845533a42685ddc606c01a9cb7a9db17c5cf6e4a7222fb4788113d9230072e7be93126076092bcb2755348b26415c86e3d4c7b461cfa9a878e7e973407084564fccec6a641ccc43f4a705dac23680db39d652b7bd313c1ba8870d06288bf2893dcc725f3c78d504ecf50bf6b18185b115326ffefb8e68cf9d75c476800a60a3a24f951780ed0b616355bedb8db8c630eea3107e71fdeec42c338eac65fe5959521e83363737beb26d8ebcef945171d929c69ef478904726629787ee00329dbbd9ac474a3fcfa77062eba503a8da3162e1ad873cd01e498f4a804df7da2b65545c39dd827675aa3940612acefa1dfb1c2420a59430c662f4c68308cac05df58bfe4579021b4562831835fc2fa0ef5d6292c434bdf21b3e36384d23f1d0062846736a906ad3913dd53cbee34774adb49a73c4a15195471435fc2cb16bc34850cad58b4c14e97ce44e5a1ebfa2c5336c597d7bb6e351fb77d49a4dda8bcac54b5a04b181f2e21c9a37d8acedd899a73c4932b55bd670c7a8b49ee04b362c0de479b67fd6d4ef2402d702c1dfa2c801fe4423470952e09e554135f5a86a252792825ffdf589b259a7e6c09a8132a6b7eb0b8a2ad96c0a790b5e4eef2640ba3f49dbe16519b2554e73a04a64f0904516254a74175a0f369eaa743cd676efe6576b75553c56395df145466fd39ac9fae5d4c0baeb96de58af6a082a7cf0df837c9b825264d2479d1ebaadd285aa09b645bf202f3f935ace4fba87cf4f042a635d4198df77041971cb52c0a783640355a8bfdbf827cfba49cb7a6ee1e9f0b033e3b0d1cc63dce66d285a23edf60c0b818caab430b9f9caaef798a5f6875f8d567ce6885ed6edd0ead55e0bcb14f8c64547d619f31920c5b8fbdb3b3ceaf31f4ff996ab038224c0ad3b6e0586c46a889f3e3f39d691b260723517d7846fb8aa7ef897d8687cfaa986ee16b18cc938faede454a291d4fe0b813f85027e52d2b65dd0bae9822f3f6ab781714ca34a917635d52b919efe47de57e0ecf3f26eb8d76b49124f66ecc1b05e41e11a52dc0ca9cd5e4e19883ce69547972f08ff8eadce0537b675768bbffa64b382a33d3cebe4191a42cb33dbf2c3a38f79476e713ea4edf8671669572d990d0e4fa033240fecb5c1ed76b5e22834690c93fbeb4cbd453b46b6f78a85d74ccc075300ce5f578e4a544c01006e5158f8db4de923b0158b3f7c952d9ce552f8f549a944c79927d3e6a828c59828ef70775d6da0918a69a05b100c5596e7ff003700ff8ce081e5fe67a1b094b0d1289176cfc0525040b62dc4dc61382ccbed8dfd3d819740feceab175ee66e56d5bf295bb77a931a79fd3b03ef1fe84cbe44d8046c0fe74b1f4720a50b26a0a29c5d9613822a4bde3c958d9fac2da270821aad3eb88fc266951350bfe5ee50110ea2c73c1d3d195f96df255b356e8cefd620bffd9ec5732bc8c408a9caeb1771394624d7115cea74a53d15ad3d4ad7025f2982732f1d29c1655cacc2be32eccd39a63bc360b60c9fdf38bb14bba198cbdb7070d14a480e10dd03ee0a14da24fc4e6e18daec4b2be42acae19446d01f20ef8c109d4106835fa1290c14f839fce9112b4eb34a111f7a0ef61b9dfdc249405c8b3601ebc3478d92e791e77eabd6c3d925ab36c2de342a2c3c02b5f39abb5caa75d218e566d83b510676163fb3827e25fff0aa8d3e793c05676e5f114908c8e01755628644dadbfac196dc28bfaa70de84b4da877b623b91e2c7cfe74d958ac8145afa7c4601066042d272f4c6239511b0300c1b564285c079bdf065d6274bc6d86b20e382cad6a9cfdcce553a5245e2849c23300fa55f841db8762eeca7e50875bd4db54e3683e18b055b53a54103569d28c377e1ca5e62d58db413280b83f8c1032a0b16bfff962380820043612a95748cd36ff99ad9612c9c02d6fdb1004d6966585563f85626970227fe79f8723ac58e11b3cd94e66c7a5f5920bbe60520d7465ba3374c659084c0c985be81f8687016727c043365b97ee86610607e797a6b4b12dd367e50838fa7ea7ea229e8298f23e6ecabb2abd4d91933bc3e69a7bfe41d5e895c41bf1f53d3746d92959af050d939df8d3ff153cb21309055dabdf75b168df5ad291463552c400a042024a85e592a2b9021bfea83a6e55f97cc477d5cb5d962f2a4528d9e2ca227c7d1d15f928dee915c6de28ec84cd108291e9bea74fb536ee65877de1a37aab232feb7acb7e0767d47c1457124be8901fc8a93e9cb693b4b77727cb14958e8f3ed2ac2577c992b6cc10316d9ad788489d7a6351378c92917e89fec1225fb6d36467432264258a752cb3c1d5a4ca28d5ecdc6cd2b328a2e7a35a26431477b6ad93c793b258f8403e61b66555599b59616a3483f19e6902a1fb8fbd8e65abb570534018f26f1be086fbc91a173198fc41e30cebf058ed18c42df33116e507085dedd0117e2ca34645be26dc98337d64df93958a0d540dbf7992895f08506b0a2a28ad883e6e3972af55d3567709bd310e5a126ad58456901045f95eb2aa69460311059a06f71e24cb58fad9682406e4765bb190e18428c321211e0ce3bed26766fe9d6c44740eb42981d328ceb1906091d4c3fe92f01f9007df4bd6d2dd493ecc59de7e9eb284bd198f1bf88ea949df39ffd6828567c71710df52304e3c19d3527622d76db3718683091e986b62e99544059bdbbe9f1655837015c85fc7cc2c488f8683de62cc77e0bbf6401e5a8e546269cde3104eac76ddfee9933c4270a919ad11545a4d419b088f30157d14625fb1a89c0bde2770c76e94f9e787eda3302427214f6407ac3fc44c08a87d28eaff5ef19d4d25221b746a73f98d8a564794a838b6a03d576b24d4dcb527a8e741731d4acfffd5c1bb4aa71f8150297c5253c1e3b14c15d465af91287b57198e5a85d295a01559cb8a1b1d874f9c4670389c644b3334ff7e68a4deea8281030338a3488602bb444c9ef37b8543859b827f85e46ab0079dcc9c4b065a38d2276714f0a3959335730bd651d7fdddd5ddd51df382dcffe761f52bc6367f3030dee1d6fecb889028d9bef7ac652209d3113aaf8c6972dc2aeebbbb4d1de54e5a43ac8ade1489740bf0978430b436648de6ab9a71aaa9a2c16c7c467262ff5f34227b1d18022ce32e5e7b50a6990b9d7025247cd78f4495cb3ae14027abd590ab4aa3a1c7a7a6140b22deca69efc6b7e0231948a1e40f4b291cd47cac625f2ee8e0aca03b45b7d60c688d3027bcfbc937a198d942fcf2b1d8d563f1aa49b209f0f7ad77df9b4b69f34c8242e6b076ace47392bd91cb5010d020acff92556ad6521b5e543c415caa16efcbbbcd36904ed7c293fd7048f23eadceaca753a092562c89de8ba44700e006bc3a19ae674e54a4df59541ae5153a238dbc1f4b68914ec725f5b26551d8e5cc4d6bc10df2c205de32afade6f202a1e1de6f093d4feaf8df9921e67c4365f3b3ea7342be8226cb07ebd34425fdd45ca1ba474973b86c9554df2141a698e700612c4f211c8507d6145f4500f96d36b21bb2bad04b1e390736f743447752dda282805d3c94721de1b493cda95b232977b8919746dd7f808f2bcabf2899b70570d3cc51159d85aae0bb2471ce459f4c362781261552cc75a4718fbcb9b0bab0f279d0159a131c9f014c9e5efc94f94a9d83bcbfe379df9f08365be1199361e0c5754fd54b2ec5584b4dd62ad48a6e77671bfd9909935dbb60a5019cb3b25d38234d56c350b60fd6570642f44d7dfd4239aeaab22f579c4adb0a2b51286e3e971a0c1b6e13705c3c5cfd49b76f7f76f3a5930fc7b24234bd63247e5cb98d96ccf06c23183003b0da1c339d6000d7dadc7129c70e86e18c7b44da3c47a9c1917dc9d7b26ae99095b5628e23de0e0040c62faf23b65f3ca52bb4fee4f07898a69d5099a3307bc7860748eeba213cf92cd86dd39b4f6bbcf0ce52b339d997346b6d59c54e2cd7c85f64d479857e5d439a38db84c3dfa62a78a11f7b907ddab8ddb64313b73b1e850c99f931cc88b9c39105b7136697d334b9447e00d16f660215b785b196077e1e035b169b791814f99e35616690ccb03ada4a137287e3f6bb96bbc9c7ccc181bca3ec15a15f41bea093b6e27fb1a58c9d1eb17269354f73f546aa83065089f5b34e151b0e32e3a680dc90dc5e39d4e00488c441dddf141cdb426b9e0489b2b6a29f6e0359ae1b11fa805e262517566f106156bff75ff390b458a9e26edd4bce2fa576f70ffd83a6596a6d017443deaa158cb4bb60f625fe57091203d719a759c93dc860588b81c171778d894f99ed44e1ff6515dc80e27eb5193c90f68febb3f0ce4b95822c92759d633b62b0311f891148bf40a093f79d01cf6a2acc29264d585aa010689ce37c2abf627fe4d19c3937d6c8e24930c8df61b28ad5c636e6fc32eeebd6e2fd9d291ac7ab11e19f1c00eb8f9a1034d1b06b1a5bfb095840117ad8d09f961c0f994370a4b17e66025988f2dc9813295178c26e6678d8384d541b16bf977387bd5d3a5e97c42ee85bdfc02296d83e8953fcfd6e7417b488c2bb6ad8042c77ecd264d927064f87d3dfdc71b9e737cf19dac9e9b75b1aec180209a807c284f361bd91f3bd8c5385921d741e7e728143124b7527c4bd6420cf5295fdd5424b0142b8af4abad0e8ed505a02266daafac5305f5ca0ba6506e9f1696af56ed617c1708b3925915cfac2882495e0343192a40f325498cb2014f2e3e3569c1a0bbc56f12adf52c9a08e1d956db9890b7766728e317dfd8c26f73ae4e06e6d784693591bd006599b06bb5e9edec167d52473d97ce423fa498df67254df1dd5bd554020923659e0f54f4df249dc41badff40d8c801942bc33a03f4d86ab53098522c6eb6e2f5b3c4d036f486d6b15280dc1afd3b82333035730427693502d30efcfbcc432f3b1e767bd94f05d16fe7cce815cbf0c3cff200b4631aa35f2075309dc4cca61aa4bd931aaf4d972bb7e35f1869e5fc5450c9a20c21101445a8ebc16451c91cf70d5e1159e5ba6ef9fe3c0ec572061281cb7d1ccd88ffc30e15474b93422eb9ce8510c6c72fdf37ab34c46c95c8969421bbd0931b95f6eeb9a82c21034c0d339a6435cd72244fa6cb91d0e169a6ab9333b7e67c0c6e3a05ab0251b5fe508f78e253b51f51a9d8007369edef168d341ec3ff0aab86b97aac925e7116913eee9ef800356481fcb207d4ace5082f5b41706dffdafa3c15eefc2789a85f31bb2a793717ecc3b49b15655e615a9b616544881afbe3245eaa78e19b1e5c033760e72ad75979e6832b32006fd06b324824444abee5ec1c325aee734750355cafa79ef13a3c5379a46cf2b695fd2cdeecf107ec9bb04372d3cbdd1f587a565bcdade1768f017d4ea8e9cf7fd976976fdfdb9614065b7ae641bda5a8d5cd4bbfdb496d9e9daf4cb54dfb46fcf22f3921f10c3b44b94e00154856f2522c249cccfeea29028a518847209a4fa460b2141f3c461a75bbc569db93af6fad2b560e8f886890c385479a379ef3bdd140fe646503b9060cdaa960e07c12fd8bfd1ccf7e486d6cc6e48dfaa806bdb823ced1623ab6dc568257630e8ee1ccb1e1d0633b0da3e7c8b3d6a664ed39cdce24571098f43c8b8fdee51546a96a5198147d407a27f8f9f152a8a579a29da4894af99815862bc88de888ebfcdb299e56ba41246723b90e020bd0f4b4de194a650883d7ba244de075ec312afa9b2a3e9f2bf858d16b01f49a4079b37b273087cd37fc8aae314e0169fa28a2fe0b1b938606a8a866fce6a37a57309a4eb702313c165395c99cbbc269269b22a5bc76a51ce2641e1daba90105f36ad17922d6ec520e771625b3f882de7926f0589fe34f8c924db53bdfc31ae49a0ab9fb1fc15b33490b0c423dab460972cd929df3642ba31a9af5756fa97fee6d2676acbe9a736be034680d3875e40acae693bf1ccafcfd9d9ac004bc79283eaef411cc6ae20b1af842e96ac16becee7cb4845707187d41de818ff9b1593e23907d6bc620c7ed1263de29d240d70c85710eb9bcdea9712005e4426d89499e2c66c90b8f3ef42eddbd16a2df2899093b2ea54da7ddb725bdc0362f55b8045255af506364905293577237474ae33a5c74fb8cf7c89bf1b999bcaf32a7b3be5938dab2a63eb47f88b9b60859b32e286165402b50a0b3afeb008053fd6eefa7b8991c0395a795cd2a841049e0dcd871ce30cb0c1f1cf48140e7da28fcd26b5906f1ac45b304c153f9a0a6b643eaf2486265961365fef02a6fa849eb98fd3a1e41b819f8e19b9c0f03add3699b0a84cae235c3113ede67646ac9785a9bcc04e3348f65677e01926ffcc3c79a0f9bddcc1de5bbc4ff84e64e63dc56c73318f645fa609bada3c297efc769477a6bd0afaa5ca232cedbb563f340b467da3c06b2907a9a35bf72fe1f7c6398328e16b721103e4f042b49140c48bc5383afa6acde0480f769299fb0f4ef3453ac69b4d41d3ddee0b8c265f2814f6fc8b3c679b0ef4f760bc7028977b82d50dc0ba2c2a58710f30528b15a07a1e67478bd7e3fbbce40487a320b85e8d69fec5804288797550f8446802dc4f31742822319a6ca227d323e6468f8657c7b7670e7b0de547fe22e8c7236000191aa3a8e8ad15837f2fb13c59d54e266751f19d1e21f820af7568f1e546ef81d58f7b6edf393aa2ec1914365454232f47ce58a70096adc78300d7c13c677b19fadc5fee64d3054e23902d00172674ef7db556a401325415b66ec8596eb0a5a9208401862c4e92a61c70de66c8ac567aa498e5abffaeb9fcfbcbf83c66928575339d99ebe526348ff5886a1ab67068995a303944264355b756560702a33cae9dcd143eda32f277fcb1fc7fe1b148a99ea4c2014d61f319e110c244bd7baca38ea8754fa095993a18d43f75ca9639999080edc059aa653a7d1926f1f1bc63f2d5e9c482c7f51d7bfe17e0ff41f5462f0877bc0ce2c04f6e6a37208ad05b2a790f9b32a99239cf7322af6f905e6a3e7b7a32434da74d06c2be48165b5dbceec28e23541c7d3207848065d6b5b2e696ca0de4c35969ee01246a166db74aec071b20e11dc95410dca245a3cdc0e38dce88abc9d305746e111465033c249f17ebd6feef822b22f6c6ec88d9fb369f023a5e703bc7f908e8bc54e1609c86a0ee0f00839a9dea92df80a67004a1b621f1bd938ce66461118004344cac530eda4ba7a27eff61909f92fb4cb626e28101c5cf4752fcae7982c013e33a85af614993f073e83fa45cf390294f305de0444fa4e845973c727f22168ded6cd84afa09d0c3f20c914ad070e8054121eb6250788a2a8643e9dfa39be723b07632f997beac614ddde9be3f0a86c28c2c96a14b41e701ee368828a084a34d2396a7358a4b9c51ce323e2973895fb846c113ae05f1243f0f713de2348dee1e217f33d7657d7947d34d6acd7162beb4b749a92d1af105cad05906a80dae5b13f4e3128ce47b2b7a9c869ad1ec4c29a132fe357f4b748d5740ae4475ad59cd002d59fcf7df26c2e9fb783a18a52cae8055e1be6e8016be07dfbea341992d4222cafcadc44a18dafa4fe52aa08886991103bb11c617241038b237f7ab0e2129900e730d80176097ef97e41300c407fb4d216a9556147fa6a536a66f3ddbd67cc53de04794c96e610852b37fdf7cef98fea43e0dfeb0cb9ac79b6b31a2cd29653e7e7c04e1a9e5dc4d7b3412fb9ae18960e29c769d206ab868add2330688b6eee89345f508cc348319c5eb41d2695f87e2d93b704651f7926790f46285b0b98a624a2509a9e7d26e1c10eaf2c031280db08a7ac63a71916536d1cbeec41e03b1bd070ae8eda075ff777aea61e0c0d89e9832d9b91657245a22d022a48da5bee2a4af75ab3509b04342d2a7c60118a71d833cfac5f6390494f2339990028352458a755b36a468f8387d4d187be206df9fc16bfece74d44a676dfb3f42d1e5f7a39c10f3947d02818e1f6ad54a66602dc2737b711cd080d4c1adb5707e9d4b380a95fdf3170abab1259fa5cbf7ff6dd135b625bac53c9d37925559181e6d5b23b9fa558ce3f29c7787c86e66508e22d1e829975f3d03114dc76d49235f96b017118d6dc5cb10ad2c0089c6a5d6429175a6a198f8ba461357a878375bc760ad6f3be726d82e1132aee93467e640b40a73758b273bade1ecd201c130622c7535fd1186452787c27079d5da8b9cf29789ce86ccc415db5ef0399c8c22eb51b936f676c058a97afeddc11665189f0167aeeab3b7ce2c0629322a7b3dce4d74788309cd64a59cfcaeeff9f7162258e3f292285b7ba4ca0518056db8eeea9437e441d52dddec9ebe6ddaf873dd61c7258b13ff1350347cab77624482a4911b5213a88aab7fbcf6ea421b9e36a2e5aae54cb234d8450f4b27f03a396482d01571d1ebcd962b5535d011b4f6be58e24dfc0545101efc0e8e30f71dd2cc8d6bcbb605e29eb11c1161ad41b76d2b5d90fbfbbde484953d24167dc24b5bc27d2612b417796bf3194d1c226c05187ac581a7ec9aa1a2d85f8b6310584012188b18cf02fc32a7cae93a101c3f8ae051cd821d5db1abda55f4de5753c4eab86361cc52b7bbcfc9b51435c58e229631f101fd60e6d0c6cc9af14d5c9690319fc241f4a9526639197","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
