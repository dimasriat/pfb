<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4e4edbfc82fab761201ee6630aa6ad3d06af48bd6d08e313688ffa86ffadcff682bb9984306adcb54f58c6277c4ead5e64c9eb69c9a9b9672a441aaa4761de1a3e3bfaa21883206b08158ac9423011206604fa3adc5d7be07bae226ccd1a92b7e7466a2c2295a50e7db2eafabbe160347bb870a8af8320e079c1c1dc0559191db1419cb666c997b41dee0b73e23425d450a8577cedf78a7b54cdb02758a6e50488306ad5b72aa15536f19956b78b263a78195b6dea7f8c5f6d4cc00eb072932105c6c5b4a69dc56d097def72a92f8676e5693ea7848fb24155ad513f03d3a401f4a09ac4cd80b5b40f4446f4d054f623e8c01547f5c324ae9628f332624ca0b1a82f48cf167cd4a7d38c4a0014ae752ed6e327c3f10dbd1ced531a6715412ed129f7e3ff1ce19336151b450cf352a048c0a2370027df2cfd3c6132c4a0c7cf1be9aee73f2442f8b2421228d2dce0b513b56278a7e823ffba7449fd6e6f8bde6a878b881242aeaeccfe5ed882e82a3c571a30690c1b0c24d62b13d94f014c477cf64d2a737fac65196277ba5b1f8f5231f2c60727c290274a2979f0543d536dd9fa85477653034db9548d7a04261e88b69c3848fa7ddc00a8b0e12394e3e920dbcd8d92e9d3dc8a260aca6a0468aec8fc025d4c4a953bbdfa83b581616211ebb8346bfaa3675e332f1fbdca7801357b23c5fd23d650f5c618bc04f04d9d1deff800523ffe3b02029035888864dad4d5f77cfecf9fcef783756f7b463dbeebcaa8ffbc2e966a25123731f7f229b49b310e4c1de68abcf54be4443c1c1bb38d21b16b9a8571d7edcfe52c9d8e209b54347d8c65d8dbb0d56be6fad59ad6c079d966e4aabd2e26ee8540f4d2bad6fe2b6d4976df144796f8c3300d91f541bc4c7c7926fc8de907c950fec6ff8437c675721f3515eb85751921be3e99de63452a98f10419a46416f31ba3d2e5e7ff0665ca65f67479969ea12e8f6939b7f4dcefef31a59919e9871fa13c901b1a79fbf495ef32c6a3d9169daa3694e8e07474b88b331c947b0b0bb4e1a164935001841a8395d5f6865a03c73543c00efdae4947bd73a20012e83d4d23444eba2cdfbe485f96f5a019f64bec3bf5f10c22f3f509888c654c15a42d04e75ffe6984daed38a7609be0c862954ef01f16a2a1f73334021acff72730c1e47a4de58a7117f1cd2f7cb9e07952fa3b9f33331960cd51b1f8ec0ae2f60ead017b6c049c1e4f392a08c0fb91b29b8f94f427d8db95c3c60197fb8859d0fac63f8508c635ef633982571a1f39295cd59f46ddebbd3ed81baf22996bc436117b08a7a27a9ecac71748ab67d51dcb130f5063b51f6d62ea6aac1989bb4ebad3121c912e73f2082f62a446e5487485a237ec00e47087285f4acabf4ca96cae8f1684439b4f629c28c99c2ea6a9d8ffa6bbe87313c69bfec13e861efa96e393370e0870069ec193dfd0f7b609e3d8655d2d63a32d62c7e83d0ae179928513fab47739f7e03047b0a0659a8aec088f78aba144f4d8e64370d66e1e5495164b971bdb5c850c0a35e61abc75289e581a715248af7dc17cfc8fbb5b15e41f561617779277b2ad0e903b73e60c7b9c5c21bdf150ddc3d335efc8a8211c61e972c1238035d940b3da91704fbb1b5a04412817876b6596701acb426c203ef45e01c8ef05dbe8e170d0878c2c1dd2d187ba24330e8e97eb455ccbad4d4fd06cd782eebc503b7830c15867d229e10edde05dd9189f54bbde38733ce5e755353a969cb24bec29887da15fa643ffe0afc083b3d20acc87343132f8fb9796d8641d91be4fe5af30cce5f0f0f8f39e68a781cc13f1765bfa81fb8bd769c96c239143e8af211d25fa364c27f26172f172ca56480aeb1686de067eadd528f997daca7c5978fbcaa3acf4dde172fcfd197cf48827ec2fda385259f0e64fae074bf23da6ecf227c0676427a8d8f5980538864642b9a78058d343f3bf18e3c208ef5fa75ed9a528537beeee9e00a07a48ce0b23d85e7ba815493f34d324a00867d3bae870c8d9c9d9cb12b3eaba5687dc3ced5ef86014b3f2505c94a512d7117b1b6e84a25bd23f09f459152546f329666713a99a5af4df0ecf0c514c1dcc8f34394af498003c42840af29f26c7efcb1bd9119fab374506df7143e7b55f0db1535d7289fe76838fd716a6c4125ca737931a85ac4352c131b42e9b1941b58e4c7c7edddf00b213655d629cb317acbf38a765b2f11dbfd513baff789ce42f6956bb0b77cc9ccd0a15470c12cf71b2c97546b8b68a389c944c245d2e17d0d066503ffb6f04015b208e26f4c58ce30f31147d5967cb362d37bc449d8e47e310eefd8f744994feb29aed482f7f6b3263221cd48693f894c6aab5ebbdfd0bdf1dee71e4577d9fc841a42c2d050b155e4e7fd2cd989b01cea561ef6659ea5d68d980fc0463dad27d206dd46e2e37c78a3ccf0fd089d58ee70f5c0f6537358a55c2541597dfc1bffd3b6ab96edc079688cfc2514b49b66b4bb073e2f46523a14fbf7d4a4e69985bd16a22226e1daa6f51da75a22a7f87ed47dcac7f2686b36dad2be562fb6fa8a71454f05b46efc8ad95017434b338834d33e3e91c019e2c1ba2331b58573f8517dfad3798eaaf51639e309625fa33af5dea8a1473af3485a49e27cc7cfb71986df3c82f01a6ef523fe52b659b5e04f919d05800c55749c33798ecd97a53de1dc5b044b8815df0282bc663fec5e910a4d353a207bb948a3a2214bb4f50bed585cfef2b70266aefadd92a2e6c4e6d561486d749e1ffd2856eb8be895921d8971b6937e9532bb493893add12d5221696c04abd14d040fc52b39dae58a765097a4398444bee7d2e54238367b1de4cee75c84adbc2bdf68ccc90dab3bc22b495dc371b52515b3e6a7c03200ec55d9c7921b31573a02685ee65ec29815cb71f3bdd1741f267aaa4532312a336fc69bdbcc93512500356b7956191221c68ebfa71ed8fa53314401eaa30ba91bb9850dff2df76122a306490b5f869d9ab653d9fbce14bf6e189ed6bc5fdf7064ae7a0aee6e91ae7be49c5d214728a32ca3a23472665456a133b710176f2f4993c2e65763526c2c7f120b108835ead6b2b2a3d35a72e8b2f0fa262b1b554997fd745a244a64f1b0809dde9e2293343fc7db958e5e1163e3b48bf2576c87379242803862d2a474344a11142484af202df2a3c1fcf392bb8b9cf9c6a6b9c3eab48d9bf04fd39ea6cceb7c30cf5f28aa0a697d4df1ffd1fa37ed0d8d543a39227856288a5187fc55be9c870dee24874c67508e5e72b386b6a9c8183981348cb645ed3dc08c63500c5d7fb322da70e30f08ce576231744c77dc8231e8ccbe1f68d08c514ef020b1c88d4e9165c83c060ac4d5c5ee0fca2c41e0f1332183939bf174966c93c0a7764eb88dfdaeb3a9ff37c2c29716487b85624d7d9e0e8cd3cfc4d959b8c27aa644096b05b526318866f8b2e6ac20f9f810b7745c79e9d2ecd2ad13f7902649d663f68cd98ae14021dfa0175066833636cb28bf1a219a1ff7284b87f9d5d5f9adb66b2ab0218d7c374de1de51e45c2874af3e6c15bb1d582ccf315ca315dbd15a9789ed229bab01976bcee84de8a570afb4ced5d116d11343fec5d09296e07c69aba212919df97586408651f54c55c212e3f70d3de4cc2e091a832ff49156bf2356b9241001fae6a5147f84008e5d77dff741ec8c17ccb9bfe57fab5d63924415edd3459ab28e18eb2b45dadd206f86f514a3de327f1d20e6a5307af32d9188d4ee537748e455638d1ca263dd0d82e84faa66c2701f630e09bed8438be54da5de1844b133e2e52a48dae902043b5fbeca0820e7f5db77ef0724daf92a59d6539e407c973c0b1331b1e53d2c789462686425b577544d1c961b210e2147638824c2c9132edb0aaa6f11f23431da92afd99e8f4690d19c6f50fd50fccdfb85c3eecd88f8db3e2ea3800721df423ef042af3f76bdecee78545be26eaafa92dd03f3c7479bf5127819cbf999e1111dfb28ff582cdcbebed629d4ff4323cd3d696774e53683d9ed5801f38fe9f2e66ee27b633f110c09eb45143bd87eee485ec043cdc1521861a6d255aa2e8609dc818c4feb4ed5eb4a030b1a26ffe22ed83dbdbc648cbbc8b49f370485f89f893e197cd2cd59581e242eb73c6ad9b78fcc5481765ef2b9e0fb678cbc35af122a0f534314e14220c78253e0f95707cd80a60b927b3eac5244d974d1769c289bb276f0ebe4e43e42a0488038a4bd5469d859061519740f9d48da8e64de6cd8bbc15e202e2a4957569236ccea0cdad136b7a133f9d22b40a963ba20198479563e5e5680e11b41431e1143633cf0304671feb1efde7d7c89055f64adf27d31c69778fe9d2f460d106247a9a57185aa06837f21c5e266ded291044ecfce6d0b5bd622a3b51635c2905778f46928d15cb14200f32f86d57ab22ef83b1fe65a48fa10d90383149352694a246398daae1be5f1dbe1129aa42114dd97d47281afe958a8487d7095a19b19f91c1ba5fd311a2ddbe109dcab8a9a1bd95ba61e16bc9ffe9b88f684aa4270ded628d885be2d73e2d3cf9aa9232c12a64dd7bf5dda83179dd36791c2cdb8db8ff9fbda73540be07bf4da90e56ddda971d6efeaf9468c9ddba28f17c5bd2ef0db870af43b9d17cfde8d70f6328fd7e6665685bcfef9a35bc9e5dbdd1f15976715f0e1eace9c6a21ff4fe15b4840d7b5780c3021500341c60e2e505dbad9c340a6e54063695fe038dffcb53c7b5531bf2b85208ec531b5b4d8da02c848eef1bafb8cd2b81de0365866e5babf4b0aa30509215dd9d4d6dddb8adcca4cfbf013b74674d2051698fe80f6f0c03cb7c6917c772e114a403fc3e884277aecaab2d6f2137e76c256e29d63649089f0b7565759c6936d7de5284b0733b155efe45438a07160af037ef3db4f7bf63985b04dbb4e315bab6bda6861e1dc7b86933e67f2043a3272c4dbd0d189ba4e5a029866ce4dc32433a7f405c519886bf29cab8ea88b655c561241a863b76bef1d62ae48a49df584f44eeb844d0dd2178183fbc92ec4b402c4e149ccccb2c145db581ed0429e65d555c20f531eb3f13c89232668b14726d7f05089dd2ca85fc86fe7df0437296fe25e22cdd3af2d1681f0907ce6d7c9d23d48c8188071c7441ef0b4de103313f5fd0953b5882cb6df60efc8692e0f80428ba8ec751fe30aa032b1671c8e7f9f8cb8f8e0651fb6b60bede52c84f2270f97fdf11241cdf5439c64c3a06eb4e74ad875cc199a1c70c7ba94db5f1fc41da4d8b58ebb03bd58379ec03b7594eeb202340cca0d0450483d74d2e8b69c5118d5b47702f4d185028c21e71ea43fcc1083aa048ec00f4552cb13e3f05fd06c3e0b214dbd240fe5018a35d95c7b45350ce69ed2c0155602c3ff4fe300144851fc61af1e2f1156c772d005329d0a43b0dd940fc799a73d3b7177b83d7dc8bab44021b8161c5289eabda8e0cc8a9ee934e8ab85a6dddc3b27e63541a06ffdc2616d428560086359f2bd87fd13d03ac39bd593063cf9590025c7371f17f272e7d0bfab37cf9ba335218be97a2aa465fb1a166b62243bc91ad4724b11f1993b31ddecd644b97e84dbb8d2c0ba00b68719b964f35e21a73374ec69083a1280a8dd40d7bb46f077db84744049aef5a39782aa2f47b0b900d2e376281e4013a2c3001462a4e2e37e0e8f71dab7bde0e5de21b806deea257b2cc046c69f7de164f4bdad19705fca493048aa2f40c05307e4561bee7f2d7668ea56252b733c592aa8c60e8c54495c977f1bf8d297160ba37e0eae34d4319bd15ba19b486c476f1e8b28b0e75347448f97d01deb1965ad830475fdb65bf89fa4510df99125f939b752e3584479c1cd9e1099816ff9c69e202082f7d41a1a2cc7ea3ee46a8f567703c3fcca21f89cc0eb1f795369baeee1871097fedf7e22cdb835041bf6d93010530c86d3a261636792cd5f9f77604d13b997ac63d8774fc8bc65e3cf3b8621bfd728425df884e3049e1a33a67424cd51df4bddab61b685bcd886d9c7cf458ece355074683f9337932d6a6b5935c957ecd43d8f3cafe9764365eb5e0d461ec6c53f26a6976a10d6891bf2bac0ab5a2eeda7ede6a81582891af69b3865cbe4be92187f73194465bdfa358298447febc4b6cd2e3863af0056d20eefef36f21a259b8e3b383c08d7094423b15fc7fee954be391cbe746bf57bb272838873bae8d82781e297e0eae1d1dacdbf5ba59c1fcf58cc5697959e54db0d70029a516584479a7f2f87264ed5a0255b39671bf1a9cfba5d9b5f0d3aef44a8125df03d867c559892d4d7413fb32fc8b00402edd439f91a18131d26598b2c289cc8633149f0261d0c4a9ef934ab497cd6ce1173603627d82ef3aab2fd72bfae3b141a1baa5d41e6e307523432a5f41c43822c501dd7587cd89cff0488332e84d4905df8fac8af73fce7a11372f7f0c5373ee674037e084c4769d78cfaaf0a8a70a2497c42e8a67f9334620a64de87f3e9b7dc73168df5a929b48a6a69b42f07afb5ec2d26c2d343bc40f3428b88beac6d25f15ccddca32d1f7cf01cd4632eca1579c9f352b3c747958af7c32d36eaf7785ca2656f2dee3d626cc88880c26a319c94c35d8d0b5d0644fcae1f9d1f287721018ed5b0539f51f3424d4214769d2a7b2ca6d426ecf5d52f2e5774eb66db434b5737bfeeae7d3263562bdcdb6015570ca175e3987b2d16c895ce4eaff8cbd817bea4a0a3965233c171d8546743f4d565a4f595ddde7ea8e39531a397e065c329d489f9a1cdace447ee8441af37430f5b14f1d7342d36f530a1161e9d786bf1ad12f7b8e15e8230ae0086f25ef91e06587f410cb918abb773a9781afc28224a56ad7c5288d6516ff10177373d7698c0f418a3bc72311eda0255730232b5bf71bae6b0525df2b5bcf0b3b01afa8aee128dc84cbce3b98ce8d45ed25a55dbf05e76a63f5ff07682d19f39acc68053a8bdea7d2920a4f9ddfc802bb886cbdbe0252a97a584ea43a2249d36247fc1dba49ed1f8be3c4483099599e2d8bc57db22866dcc312d6f0bd6183b193ad46949ee2b44a9c62d9e9eb8a465e512556bf61fa4fcf1360edf275ff181e5040dc299090cd0e91754f5a16308f87149c1953002d8f00c7cf85f7479d3b4c33eb066bb1150652ee2f3628457e5cc52579fc83254de014f5e2cada422f1ca16de98893807e2df5bed5f39ab0cc53bda32940fbe60cd85ed753e1f7ddc1aa0200ed37a2b8601fff8da9f56dacbf2779f9ffd2996b548c7048a343348fb9623b8ebcbbb3b62c473b17526521de3d23d5764a1c6dab6e3202638af116dd13e25d5b4a68ef1ba8bcf7e7fe58cc1f2413ee482d7be123b35756b4fde464818c3a4591683156b85830783749c094f291a32f11679055790f268c8409f30e714b19afcdd11f46fbee4c4379a5f40720da4f4e4177a0a97816454e5a2e8ad97c140079eca06763784084f5448a468738f9a28563001b6e7b5a121f1dec23bc10157c3ad345e3416c876edcbb98f32b25873087bacbabd6c5909d1adb1ca280c8180df95e8ab499294cdf78d952d56e6a9caaa941dad6dd77d68435a783f4f967ef5ba1c4eeec81318ee2557787034fcf9cf03e47db19509120ab94035d95dcfe3656fcbad10ad9f5d60a0a3473f900fca0dc844fecc018e783162fbdd38d2d55f2d220f3d303be2838d5eaf376ad1576e71c4b89b45950ecd855cbda428d1fb6cd94f23cae360732b0c4935692be704eecf1f8f51f82bfb4aaab04c970a82dbd6fc64bd10951ed2fea9bb1adfced083dbf9caa654d55506ffeb6310ab9acd5db2b6191ec27f9fd40017eb20d5e4b19a70960b064a349c39f82c606fea5284b06d698700c6b8897fbdb6132c29102b1cf8c7ec1cfd760cb37930a792bde0f1899675f82bfe77055bb48a3fd4d63838215d67d2f630d333e3bf2e03096c0c729e995aa572adf59cf7168cd6021df7f3dac9b666273754601ecb1e7e0d43419ad0d957fb05eb5d958c49431c342583360b6692689ffe7999ab1351b6af76129eb330ffd61df0f757847866542f4e41dca8b606f308c893c6aafdfca66fccd18d0850aae04db7b47e2f0b13759d88a5ee3a4b02f88fb4458ddb139ee46cda84163f9df7da7109d2fb8416acd389a007293e31439769e7784141e0f94e252be790785c9271f6a15a84bcc62650bbdfc0e7f5ba414f0d55766c393938547cf0f4cb70db5526264cdeaa6e5baabf9612b62a6e3107b3ab233fe24aa6b062919df0f27569b29a49195b96e3a4fcbf2413e5f2b14598f29e615374104dc1c596f55287413216131c96a71e863a9db9e6830b7bec7d9917f505db1770521e8a63e87b403d808dce27f08a76acdec8882f2928584839aac004ed7955b058d703a43bd8f7a2b1c5952e97dad87143ad03d8a7614b83565d0daadfd218d54c203ec1959716ef30406627b48f937d59f87724806d0256f21fabd3241aa54298a760b84b794cbf2d78dc6334f514d8337d7eda1c1f7db62de8d342e3163c2b33497166ed47df2d3fa13abfe7d2a8c24aed9070fde522dcd6f212e9f994f233d83b7e7040717c489d173f97159f96c848ec4d567cd449afbee27efa170194590e5172b033671d8c5780a8e5a25eda8b9ee00762dab937fa82854572a2f01792a7654cfb473755ebb5902191da350015163645f086426cd844260a52f6391bb9a6701b6dde9489eb59bc7f8231a35d831285beea8af9071d96b02eaee963644a62ed04b8a20ff7117b0106b23280175b4c5502353aee8db15083e68dc5561cb3323d49523edf615beb357c580a39a812b92051077646ec447bceeb5d2dc65cb54ddfc306aeb8a5486c9c76ed2696f66be030151b791e85bf5f88c3af9743d924a184b4ee6ed5293c5c77f517a3ec733c9364b5d18724c7aefa5b954961ae87212b2161f10593b18c9e6c99000b5c0632830c430634c291e6cde854fb82518b8042c86efe00a565c8cff9e2e23542012593329dfd3440f538d95ebe3c168833de15d43ce3ca62eb507a32fc5f42596cd701f812cee7342b36038c796c797e6631aadf355f3c0b2841e6d4d204a0de0a56be45bfb37c9a92e15a4ad34b77f5e178010e048a2c40da5f7fcff99a0931500c433dd6b1905efe8df96eea69202eb1f7d0384fa57d3ee07d81f7741f4cdf3f783034f884513ea72a223e7a81ab504978e6ed8ed5878305ff1fe3b9f9769f65bf3e94ca928f156fcda746629539137ac2d1d368c4eda523da97cebbfd638c7bd4bfda38b723277e1b7f806594eb3d941cbc60251af57863a80ee920cd84947c69ee8219ae2272111d8f54a76b4d24af6defbf6962c9b68143cb3a2a1be7f44e067aa70a5fbb1564fa1503ca8e4fae4188ae01a2d95ea582ed2bbb04ae395f3a29b54a8380b3b2323325153da01a45f52dee91349c922e5fc27f93579786fde67547a97e26c3c7def388ea80f9ffd906cf75c3d52ca9b76b15f924c195040f804d545b537ef809230260f4d583f5287ca35c9a6a1279d77f1282732a05f6e6f077b20e2e730f0f05d249c5ff3a4baaf3afe79b72cfec45077188c7b953337172b4272a2143a738e077660ba90a13e0f298e300a138b831faeac171b320cca1666e08d6bc1ebc0fa74d837fa34f92cbc24c914870c487b4d99258b7c8d2d3bc6105fe8276c13527f231dbb6e84086ebd446c10a6fcba7d533991cd5b4929ffb0b2aa1a2420b33c59fe7b062de14c26d4457653d787f60155b7c8903e34fb8c75004f876bf0bcab62dd22ca1512f7e44b7fe86a27db5904b6a6c96a11f2a3ff6beecd6e1bc72050e2e783c7b7c34f2f2418b438423c9e733d6b1524f7a4598be5f4f94ead0ac5a49a8d08ef4583fba3f471884507742bfbf3a05f155503e19674ac480454cfc0f7ad2878191ebbc9a369774271a7c81661c86f3e02e9ff52039b12b344d31524c2026eb2b247e19f48bc5b97dee8e1a97e31a8ba25bb154ddde99b1b9b4f063bd029900f6c796250e5d5066f8dac5f43b1f3623e91d2cccbc6c4ceaa127d9696a99dbb7959d0f5fb484b927773fac0f7e728a3323085af55424a1dae78071fe54c95837614d4fa7a7cc07764bbb0de47ba57062d651293bd32d8fecc89dcb32f25f2c3397493928e900b45a0434db3e801dc2ece869e3574e51b091d76a253946d6ea6e1883870b913c7d63f5d5d2735305605144152d54772113315eaba53b7c4915e52b0917dc79def5fe7019aa83b5ec037631c61675d3d7e8616b23ae5b66d59ba0e7c1e42083755a633dba50e2017539f885408a9760dfe9f538adcb4f6742d5827e1e250bd92b383000263a731729db2f16a056c40ad4de1fb75ad32fd6aa707774e75a1d67d0c2bafc036642d74c57713fe9818a913d7d738ca325e9f52e97a11d6136e0c959de3e8bd5dd4f4bdb0eaf6cf7ef11401ce1b6192fbf20ed175f6c49c67e68877f949e8a8cb113a9e31b390407f4ff0c8abd7a4e57094b1027bdea70489294b1d7dd24558c37f0c5b83ca0845d0ad55c056bd292b06e8dd14e1aa11a5521255fe7587fb63a596e9f508a98b00c0962abb73404031689246279e34d1527f370f9e0a5297045b4bbff9a5f3aa6a14e64190a2a3e7cc84f3d69a5d17b988ca8dfd61099d1a8a4f7c7d15388ef1e2f0cdad9715a3bf7623ba955b4a9719611d6c0d2c142182897b030e0fd12576f28858c532a8aff654548474a092c0083c09f35734fe6e7b0f91db25b0df65a18a6a9a3490f470571cf8fb6e2c6305a6fcd5468fa536d24791e1daf6da9ec63c9d74a375c0572a82c5ed362b8086b19dd93fb6dceabf50fadbc696f38522381e2de079058b55003e6e1f4f0dec9dc0df4f87b9b74087ae6639a98600972df27e2a765a1821c35a5f9938b9e6178f8e5a343a2b17aa9077d59ffc2be6bbedd0ea05b56ad8a0274a2abef1a42d24dde7eb13afb95a860e3634f479b902b1d3f11f98d76c2aa5530fc1203a19d186f1876821854fa6d05629ad4814b46bfab32fd503e0c1928b90a04a69d7cb1180e7d010cba332366c4ad499301d6987ee027ef085a2504856fc88ebad7d894f4a33cea657bd3aa3d1acdfb77221c05385ec050bf6a027bc7330ef953825dfd758eda8f6df68ee136d4b01b145e81603f39467179b8552945460bb0dde377f73dd4032360633845f9eabf19aa5c73d0a45592991d50db4787ac4019bae7e2bcb844439770fd78bac478914af5659b228c95eb9e361a1ba69396fc5c8ed3b8d8b8a7bba8a832e5aa399ac08c46ac99b681b15a2845c0fd03dd208c58aaaa475064441c756602fe7be2138f0a6207d5e02f92bb4f0af4b67831992c193d0023b401cb8a97fecb1b6b81c2bc9654cc7463be785a1ca4c7e63ccc9de1ee6ef89741fa90ddbf031831bbf5768506fa4022e5db3568b4aed7c70b24530accd41e4799c1fa2edb3b46ff574e889cfd28344cc3228df91f96dfc252e469a02754a96edc492f383a0fe40c6005847b7f89b42b50eb66bdca50cfdce59dbebe3e66e21a2bbd48767af8e065353aa8f8147c682a5ecf06205335283eeebd4bfd59a102806ab0644bf0ecf3941c8307d241b2ce25282e8eae502c7fd6cacb82e0b17cc4c37c7a3b544179c620c22366e14117fd3bc79d47a96d78225b9576792ed72ef717a3a89506ec3b022c777ee38f8b4fd6919be02e62a634e30d120f0eeba9a5c2547b00fdf7ce650f8f57d57a1544572181069313e2f1f13a73a64a89641e6304a50d942b8c12cec69ebabbf93e810e8756137843143bff36dcc48d519c9b5914beb1692817fd9cbb1940415343fc4b8486aa3d37f80c53b89eda278db4f6a16e33f1b4ae8598296fdb9174ea87668fc70e0467aecc8527ffbb1f077a1b0bdac8ecd002a8c194b9c7b0ee1f57deb2d7bfa4cf636b55d77874eeed3dbd01a794996f19694d0279aa4fa56b0283b31f881e2f1eef28a973f387c5638bc4903ee2183d4c0e7ed932a9a9a1e2ab3d50e68f5af87bdd0fb5d991339350c4ee1e68a3ead66aaf6a6fd44293c17bbdf9936022c4fc58c33e7aa423673b6eafd2ffd02c2c5ec9a723e7f2b427ead8beb0fbf675940cb1d9e3376776dbe93b50649f6464b2b19da536d402e22cfaa3b0b817630bfc91824f4c9f8a6fdd7ac6b8e6a25205060f9706a588142bb8628b6df65bd2c45207055f6a5bfd269c9b6a4b7b31e9f0feda25e0888d5277bebced12557e32918064ced6efc","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
