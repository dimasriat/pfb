<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5fba16648d90965c75217726683dae86c8aa5d9f9c43d09cdffb092c634e98d0561b1742bc101d8a0e4280c02ba9b688215ac73a15caa3c7bf8981b761bd3f9060baa7104039e6b2e2f001ec4f4ff6027206b6bc1abf671c64ac0474323433394ab9dd7be54005442bf83c39aa1fe67420372d0b92d1616bc3a1f5f8d0ace93690b147619e21a5f8c74a8d9c497092c698d30d9ddcd3087c1500b317207430c2a64608453d812d64fa3c90a07ada5cdf86a29bcb511e9423af73d01961c2a48589bddf1f18226d8b6f455ff005c00b56868bf04aeddd8592a7d98baf58cd1e24ffe5dfafe6dc82d8cfb04ebe7d2e590f72e0955bce85460aff2dd2a1bca989bbe81779fd8040d8a3948d4b66210327775137dc059828bd3c82f7ac36a588594e36e85f5f9d60e08af7d5d6aff64195aba6cbff7ad8e8fd1ede19e1dca755d9881f9653c602bc0655b9feeae36414fb3d9a296c1cc60a87c03c53b4a90498f4728544aa886e834d222d574568150752599251cdc95b05ff33e48c7ee484e00c55cae3c4130e448363ecc11ebb9ff45f99d849921480b5d2cea95c341b8a5c40eac7c4de99726706f8388e50f838a8d2f8834bd33e7423cc33b84e094293b0ee3b36aacb9c140f7c23d9054abe35db455636579bdf2033b05d71bdf6895a09d3742d47cbd16308cf092582a3704251b7377e27817c71832ca31037c4b9af51f7159da9baaf56ed74a0d50e624a566a186c97c4563ad47fabe51cf73777fc4e7e09adbb95b56a99b9be7e3d6ba47922d0ca9f8972a34a54a28f737a37f4eb962bc30d249fdabbae7f8b2ae04b6c55a46ac45e271b6f0fc8baf1eea65ba2a9e7eaf64485a6507e4885e509ce2dc64a044da71a97d71213459cec4002fe178eaf510994cdfcaee955223d41bd9a638045fe889b96329051c053d71dd2a7d917630e5e209e490087ec87a7b2c86b26f87c174b27617150b66fe8588ec8e56353f304c7f595bb8445357ba4a85b2dd407a9654190eed6f3b230f05714af70b68a3996049f33ea413f055b66c8a1fd27fcb96a39262adba36dd5fe05939548424bb1b42a84324a9ee83e55b429654a20024c2d595ac4a2f91f97fdd8b87423bed0cdb8ce02ee228342229c3cd5a116ebb43ac8faf390584d262249aaa4a17223285fc547b173a140f23aa81d2ffa7c8d4763800a8d9ff2c24da3fcb24d39929deff5d1c82e305cbb15e85d915f5fff2f9aa67d053a26f50115de530f884d3c40e4d7c13c2f0cbcb23a6a2e8b5deedb33d74fd07f88f0e97d4c532c9f874d6cbc25653c8ab96980e6b93e1ce9425855e6fb072038c7ea83051a351221d0f5b92949041641d1b258890e6812d12ae11ac91c7360cf39d800b74cd2221e1ff9c73d86de48925bc6a5e9794e4f09fe42bd1c426d11041f9fc4f9a27526222892f1214e8a74e7b7af96be54d353d4913311fcdaacd7593fe1437c2c3fb7baa55f1355be9f38dadc714270bc8cd03b89bfb88c0b3b27da874edea9670669d62cb7289ebff18137d07606808b7bb42cb4a5c0fa86689241d8daf6f71e9b42de47f3b0ca84c83a72f6fa6fb48dc028d834e9afc8cc5d35ff8568e3e9ea55b43ca2c3fb4ffe931aa090dce6825a4c2f6b7a8272bfac54bb1883d1ef32eb69b34e462b9e77efa84bce9c5f6e79ffb2dd324ff13ccf55e8bd1fa5efad85c2d970d4341c44f38a19f68728dd75e6befff2e6ae47aca38dc2fe3b2eb4759240cb735ac794d0e624a14dcf0f394d4c24f57c9dba921c7673fe63100d9cdb09baa9f9421b80fee8850c0ebd70e4086b9f3e84d41fd3b33c9b983b76c59ec96b7e49a8e8e618b7c0304c6e8dcb1a53409326505c200eba9eb4352c1ad5a4bb5e484139241e8af868039f758f25174e6fcac04ba478df5af75653d9b1e3bf69dace9516b93dd01055b2cc4ec2921351a3e09c07b6ff6608309719b5ceeb9cd346c987b35021562df5a551e0bc5fa8716f097a746f9ce0c504cc9502c2f953e471ec3a30f5d819b873aa6bf70532d45017623c9429d3b8e22a04da5853f6c0c86927665e14cf78e4236d09d230dc5c1b5f965484ea5a3c45b99cf6d8744f415777917b13547f88bea76c3f9a41baf34eae682d4c1ccd01cae1e72a1f35c673312af0f08ac2a224af8f0f93fb1694d90c068937c6f2ede8b8a04b6616e624d21f76ef663d2cdac9bf95730d1ec745b46d0f1a160227ceecddfd92fa57662567ccca110ea2dced53cb3961b034e48547ac4e6c50e4499af24249465dd6e8c79fb291e19e6883f714f26816ca0226e87552eeca61876f22a9b7bea17484d5299c088ae954c2608a9ee3661ffc3089e5a73d4d44d969f3002f88f73cc035ae7b4374da5afd84e4713f9601dc38d3c96d22167132d4e7ee127a9d73c9c0633e1206226c50a0e3df627af2d8b76daa13d7b96e2d5a818226c249e52d202cc36886b008a4d41e4e0799a3b60ee66263397a004c8ab9af1d9d92de0bd77a072c546197985903ffc5b70b8a8aac56071e647a210c1190c4cc8d4da7a7efaabf22209f647b4596098128eb9f95a2815539cc3c8ac820acf10f7b177a106bdd310f1f55f00b791da5611fb3ed883c16962a6b59414578c74835e0353285565678611c907920f13886a6dc5a65b71556ddd1f05123451dd7475a53c95d86454564bfdae7c4fc4b9ebe0b4da871d0554abf749ea4bd2067b27bce87540eefaced08d3fc52169b9837aae9c8a71ccfa2eb1d742cf75bd191f6f21cda408e6b6fef5a7d479fb1147a0bc361509b0a7e67c9200924ab0855c27046ec51c29c7650a1ae71e420e5e1a7ecca2dfb6476796a3fa6659e6d02cf46653c3e441c0290b257a66df356b689990b4c2bd35d37788e64201a7fc9d93ed342fd70d6475875dee126f4f4ec486f88afb9d0cdedbf7dbbde121f18c22f0b5e087fe601376ab7cc44556a4ca5f36a7fd0c5e326153ad436149be4ec76029bad8368d9a751b5f07173c1f1b711a9b3feb7ad3601723535dff0572443af87f92bcee7bbaf7b10862bb8a8ff8ab9d2acf1021bac45cbf30cec63222c08462faef86293e77b079c95844ea1b022ffccb77f4f5c6786edf55b56f67f9d4de87e671034372e55985311ade62c2f915456e83ec2504c39213d21adec706e153a5a92453e5bbcc0d99471278a5b1c837cced3acb62547e209c9b8746be539ed489932d9da715fcb9464a4a7eed43c55689c030592593f7916dddc71331d3a945fef92dd84ea18da83f7cda418700a0130cf44acc1c81172f3964456c1fe3dcffc6a22e6043b4f586caa644e43128b1af896009b7778dcb8f87f84a97ccd76ee8f411ed02d871ade572c0d9013b31039e9dfc2609d697bc7e43b36db33b98c080fb141ac2287966d09d55f87f8ba6cc73d014b62adf5a04dbee3f39ba8e3a4d486fc8afb657d177bae1642dc3ad2154d788c0f015aa99dc52dc9deabb3911ded3b24cee794853bd81491b3704d42bec61266092f65f9e8a9b947ea65d20e6c131a05dd994f980ecf1a7fd16c60d0f50f53c5211b3f3c6bac933617e41427a83f316ea956c3ee953aea29836df4b3e241682530009e7f0fd0a86cc264b61b7db825d480e0d13b9a245e1029c676ff38dc3eb56c13c3527d27332f031aaaf8b2631691b6f4f3f03a0b975b31f77bb9b67290751e005ecf0babe55f7845c84b7bd024e86213a05d2a978acbd2e76588e189ac13809c52e13a10332f1bda57c9ef3b548d179c1e75e5c5e683134f326290d3419bed19e5414bdf58c1ef615682bb0d586cc94a7352cf008e2b03bbdc8c3a4b93292981ace27ceca5dac9457c2f3f6a4d09cd4c50132654a5aab1310764d6fd0fc72d17cc7c375fa84a5ad1947a43a16a8aadbd6513e9a5ad50f98b902955f1e358cbeaaee97f0e57b2a599af7cd99ffb0ec0993dce3b769a6e43533e3afcb01a4df76efcf9543bcd4e69ec8d17a43add1f791a8c1ecf9f014cec03a7d02f8e7b660757450c96854d3bcb8fc53f1e0a458daa1805c4bafcea60a3489f018899d8ee4a72445cf17dea24a27e8bfbd00678b3edd7f9f2521c536293755aef88203d9f6fa0cf45d0692608b5d3af0ca502030e01a9dd6592d8747070832ee67aaf8fac8fd531b9c98c11752d15e0dea1a30bd057a2ae854914a4ba3587a2eb1d5d1393aaf544584e4a1b4d3ca586a1dc680b062bd9c399d64c5c6ddc4ec708acb69b279c38dff7bef01eb1941c13248cee11fe6081f9ed370e6ffaba4a16d1bce9c3e08bf07e42a3f47e2e93ae17fe10f6444fe825c4ce7de31658459656d459a831ffbca167d6e70b22893cb11ba966847f49ec6b2182f8b5be7c763db2ea0d416a0dc5e9fc51ccbe3172a8120a3cd4e17a2459b35095ee007d6e845fa63a06b2a15a721b4fea8ab5b1eb2a43196996247e02901fa7da2b8c1e088c4b550ccfa5041e98e2efd20dd443df8a99861cd5a6153a5eb480724114c44919793242bd2deb2a5ffe2d932db3e96b7fd460baed25071e677a4780f72112e17fa0ba6dd53b8cad39217c41e4b9188e902c83b4b77665d3d8c9daeda1b189319934371cfd44cc49b274de499b96333776e32d1dfd9cdbaa0a0e24daa5f49c8ea63c648f5e4ac3429e973aaf559513227d8cdacfadee44988c4da4b9b2e8f52bff0c02c97b99bd4f0ed3659ab196afdb44b73a185695108ad5d4562b1f96f66259c81b3a5e6e773b01ab8c279fbdd40d983209b48858af8f0d956521affeb650d3da3b9b77cf48461a29b29e031cba39d768ad738ab9a47844cd3f27efa2c7149540f746743cbdf49ed9ccc6d6d7cfa2ebe42924ef7aec33caf05bbcead612fb0c2f78e48c75f7ab85e2214ba77c3386eeab47b3199476de97cff495eb2ecd69c211ed2a3ba329a493bdf281c0194f8c0895cbfe72ec185412da544d1d81ada1385e83287cac5fd9e0ffb195a1fc83f2ab571cd5c55d26ca0ef36c8e094e17a4d1d25b17880792b17ae7bc0c9c1db560244dfd134b6a38b306f193f500a53cd18e34c26791bbb842aa98ac7912d8be37f8922f3a735bd5a7d70518a6be20067e8061e8b85b7d476a1c12533846ab6ac2bb08b8fb00a1011bc358c34f6c73989158abccd23a62f39f97456ebde65129bf9ffd67a70c2b60c8ba4904a3a298b103ee40f7333f9c7ed1dca7d8cc52d41914f3d655c97c9e15066dafdbfa8d7d26a07308a09f8ac1a21b02b1b574608aced966d5ec1d2bb0884b4e219e745b94a732b436f2758fdb1c5e33523650a6cb092b86ad4ff60a0d2222f91dcd418fe9b25ecbce4fa3c0409c9c2dfbd191fd4e988e8d9a3c55e1369fb3f3f90d3eb916b7706bae58c35b720a2b91c39462aab5048e93e82fcfea76c9f2123c9ecb545a7f4c7605942449addf0a5bb5bf9713d0cd4f97df8bf733c2f49151909c67195eaff36ff2b0227236711a462015f875aa410c17478151ae73957b35868f9df09af6ed4c67e3d4d1a31c3409e2693608c3f2e2883129ebaf5f4c758fdf0d16f73d6b49650a1896164ea40fac3811b6d04365d5ce5992065c22dddb944b2dd57aee2b95a3e210bbc9c232a7442219173235438a6ef5f0c724f2584b1d197cdcd36c94b1696039c2f4cbf46536ea30739bdd2f5973040c365b00bdcb6cef93bd0bc751abbcfd8f99b8303d790a111e32cf9ac11a26788ca95756054d7ff17360cfcba977cefc8ac5fc06d2e23c5ca78c66506eb7e5278438e65d48f80f34f52561f398e4aba32e7454ef8f3df0a0782b382204fb2fe58d2dcc8b9e043ec2d11638a3dbc4bd04591a51c082db7d1477ccf057e65909364d94d80a5fb1355c6ba776ed2baaa22fbaae4af833c607a9fe39214535b9f6ba40769f31f48252badab67beb3fc115c6c261549e8c1f21d6ff373661d5baf8bd7be2b4e96cc9195b3cd60d5c59722aef9668c3e36d1190f836c111f364df6b8d1570f4bb6d1b6d6cc832f1fbe78be0926bf925f9860be616d1a74fc3de2242483ea7b7890241e0d9068948b64d91fb78070bf39da0e07b14e5ca9002b8c2182f5f1c93f31ea367b0e315265c6b3a706a55a7d77fae34e040a687dca2d6baa994ecf4c225d1ced4c91ee7712a32dba7d6f9042530d73d903fcf0332d911c0a928e8cedd315a58af3d90c1e1429809d52ef7573f79db297fb544b3d6f30c41f2fb524296b60e7490d894e4ac1ca3a8edade673aba5d65398e2411434697f32daa53a07931ac6567cb0138ab6f1f013629f3502d88f7ccc460d99560e075595c3bae368f592b424aa5c91c5f0ca83416f52e485c434b26e6d8831f4ccfbf422f7b1d2c63034cf887fe6984e7e1f23bbb2556214b8995b4a33cbb29e0e511a466b19c78c6a80078e5d4e8a67ef1833eaec5625525ad262b2dd6027fd310972a16cacb1620fd0d80177a5143c2a9a25176172a0820846b01323afe06fd2036b514bf451b63146817379c2427afda83cd730db3f11ea1249714a44570ac45b11a789d9d6efdb659e5c110f519c5128e0edf813ac725e2fab5ebc492b1df5df4bca838c57b5c2cd9c6d89ce98e02a1fab8ec76e779c6f6eb88ec0d1957fd4066ee28e7593433f58126f362651053f1633f011444775f0f5eb74dc12723edee5c1b24bb207aa94191c0701421ef65f74a870c584f64b15453b8ac3c7fb3f228f54eeceec4c2814a39e991982a6bf787ef9a11eedffb0de2a64778b763a16757beea68e15464efd01122d99014f95a6f8f28478d96fda56cc97bea8a2e827c7093ed665b941ddb4644cde399a6862e15e3170a5d569f489f866bbf04041d82b4b5380316a26d25d6aa35ef035a106b9a7a160e25be19996891fec1c801da229081b12803d224c364f6a387bd6025f9b3248d6c6dd2d46a4c003da5671122930e42a93ec244c4a1d65d0bb3bf3e69ceb352fee5ca92850a5ee587571aa644a687e054c03f74009418bb0d3b1d682883379362f62cc8c07fa681caf2741808b5e0a3cc0af1c4ff90a313a9cbeb4072662675496e85f77b4d3ba3acf34b4229d449a0f3389048d1bae693e799e76d7f62a08652ff1a13828b058122164418bdd7953392fd968870d8378d8ae64a5daf29d269d465193669c2027307cc0ae4bd6c4aa22a1508093aff64725b26c8dabd26a285db6ed5d98436412c79b368b996cb05d88e94defce2713b4ed06cfe801fb7871c0e4118787d16361a424315aeea2c32f94a1b98f3bf2c250744b888660176cd67597493b050cd4cbd9a5bf9fe9a747e23f2519261cb0b90af1c8f75e3c53cf1376ff622fdab79ef53f28b9a5a7ddcfe06dec6b09e766604a39a132d752ba5e95a40ed05db6a4b627dbbc7d862911dc4329e96847d5866b3f5cfcd0d4b149c699ff1d4096d7bd1c83125bf914397dd0a39a5cc2445569e53ab3d626aa9586bcc594152d54c14b346e96823b74c12334613aaf7c0cfc01dcbcf6fb4d10f9742e1bc873ad469099313d378069d87204f3d9598fb6de1e3ebd6757e6e09057e669126983e5a5654e8ff6e57fa8777d76fb452c2dccffbfdd92cab59b44f8c6acb3954009bc2c9ca93e44c56b78921d06361e230d133af0b9dc87938d0c1a96a891d4d529d325ce61f294166c77a080dbd73f401c192ff41847aa8e4fd4e0a33890c04f017d1a9dc45a84ed6429d13b13a2d837a8e04a9d5a26fa8a3c622611a14e13d7b2c0ead3f629e0ce2f0885e70f6e0e69af62fb83ceb70039cf616b158d9e6f894b8fb2987f12a70999fe6b71620d5d977cb1b0577c83aa76a4e94e2977cc310a5f2983de0e3e203fbb96a6ff10f065a747bc9f9ad99866edfb555704e1b2189815e552194bad83cea8073fa4e8a70aa927fcab0c4e644bb2d1288b00ddf5be4f8c3838a8924abfb09e0177c43b0d53d754c339b357cc6cf831ffc926baa99b112fe3c283220f1704ffbe9d27ebde8a659f36c6223044bccabe6650e16f35a8f5014e926bfb59d65ad6335de517c5481315c3b9b531bb7de5ebb3c80ea7ca3cb82a3c02a11425f5c620adae3d408f7b36a23c6ad9b8b13c4a3a9271b628f836c46655da123a3418285422e5c2f5fbaad9dbe4f942da9459135b82edd5e3b81301b45171fd8fb911d8b14348b55b89044cd84a95ab1f788101bb19e0ccfba71c6d79cb088dcac5eb76af7ecdc3a8803840ecdd81e5ab238111257f3660419887ff89fe9f9a455aaa5863020116b99e7dbd5248fef8491a9f82c224051df783582ef53155d0a410a4cd122064d1f561e25a374e0b5dbec4a05d9de29b653265bcb651c83f81017bd24c84479edf46a955e9dd87dc4b988dd5ada4d20b83f331ccf45d25c27debde51b93f0e003029758d66e48c1d29c6c9d9139dcb66738ec3d8405528f625eafe4e6aa92fa343e03a06a7ba9947ca0c418074dcef47d881d8b905ed39157fbb8ff7d9a9f3c17697a60f484c5f7a637212e508619e616fb77bc3705f76946c5b34445d3ea9accb0f27f871d5a9557323ad87368e17500e8c949d2889919d3dbf3d16e0992eae1ac106d44116e517f290a301a07f1d5661c8084d797cf4830729e5a3af1adee02d2c2fdec632c5872dd328f41a090d1bf7352f43c57d8f5dba25474809bc54d6d6bbae7ad47191cbed515a9190d3ca33037afcf2d9322312852f8fce3caf07b011b9be571213c9c8dacb4726ddfebc51551e464331d83bae13f7c448b70c8445a3fe8d8132411116f17a18a53e572e75e4abaa8117cbdca7cf5d37a1f6190233dc9e2749f135e1c3480ccb0b142f460d1d0f77d39fc3ca75ffaa1d64dc29fe89a4e27d6e4f80facd24541fd0d4af95fad21d34e227ea33d74a0bcda7bd93c2152cf2e058b3bb7de9a374ae8f2aab4b7d24c233d569e12f7ddbdb4224e52287634c8d7fee73835e8e428f7ca2808e06d29cb01bfca4ab8fdea22e9ee1c0bbe601e87410b5835ca7ef8dbaa308dc069b2a9e1dc5b702c696ffbeb3d5f70f3ba2dd0493abc96f6e11e44c42560552f3da0c58ae928989755b6516b5c668952ef7eafe168a110c711de76f1428241fb45e936ff420715669ce0412f553f6dcedf3f3fb2db805754debfbf228f3b250fa24eb60694807046d9ac61c223f64252234d02216ce8ed2f96f2e9632ac149b09eefd06048a1dd574f6957331026120d158bfd6139031a17d1ae3a2361f21a1125a49f150c088a1e06d206114fdb56e194accef0b61b70276926279440f34812189cec1d0b1946e4421a9af4d73b858d5c744781042cb558b64fb18255d4222b20a777bf48ff67e70ebbf58e51828d8e4e09492eab0062a775f2b71d7330cee8af836bfc91b7b8e70612cc4422aa5075cb87052fd48b11f97119b5c72cc937343be8472a6e7f8dc5b6a5f531c5be69e7b15cc75a08e79cc64a4677d04471dec0f9e8ee0d5b238a55484eaa95b529eb2dc063bee2470656b7f65f136f86b81da837301cddc83dbca3f67d9c262a695a49be70215a5e7db4acd619937520fb7c27a89593fbdd60b337a6e03b9cedfc7d3ce96d7bac774a3891de7d90f2c0e50f45f91f038f65088477d384cc5cadbb07ba0c97291550b8547de0a0fb1ad59d403b1a3a31e1fdde1bd014d157ff99a9e41523877820fae359b42430262f659fadd5e23ca21b420597ba85513a364a11a6154bdb4a87bf2125ead102b331d0269947690154cce3b76059ca5b5080a65f0ba2de022415e6d50bb17fa90663c7dc5852096b7a3d6ade5f1b34480490bccfb61e67cf6faddc54a49f83aae376f05eda5a24d160ce0d4af1aa4648314dd998cf4b29934011aeffd99c6b6aa6724aae9e8d09a68d074084f814e493aab30439f09b0737311335a26d7edc1f211bb872730a12534e1abb5ba8e87d37edf35efeaa54017e02c9c321d84cf1fa8eaf1332d17706ffc7739eb310f24103a586d83afa76c2afdd8cd449563c5d28ea25787fd5188cf156c564167f6489a4a5135d8d4b2faa01e6bf5f6714e42229c2f819a8013ba180d52a96797f98a1795f8a06d8bf06d431215905e740a68c200460e4833bafc658a9b44df79c597e03d5ecb8f581aac10515593fabf2625a79d98a72058a57c068af0c01e016a93bdb2d7476cb6288cfb9766b72461308292eb49620a64952ca927f58371a48f5986cfa467ce0e0580ffb47e80f1ec99acd59d512d19314c9c1c501cdde58f0720df3f3700309b856e1ddf03d545a8dacf1246b07f7b8337a2aed76f0179ec6d633d5908849f63902f60e88635f1e9fa84326a3bb1337485b77602b9db4e292158114451712b9edd439be7f07aa34efe095373c8b8f962baff366a4c9e2c1808ff12f122fee7b76bb6a1ef3d601ef4e96f14d226b4e38807d53ed5df2ab813069c169427e04843ed04f5ed6058e148550be0311e50da3858393ccdaf476466ff7c018041f6e16925df7bff55fa547691e5081260edd84dabde583152fe37c35e0f4b7d56c68c3ef419ef79ea3412b2ba6c0c2c4916f8bbee8ce259c59865f55abe10eb6183fa44d5b994a7fac3a1d6bb92973f3ce091f223f002c35b06a930b212d75d0825f4fa08d54569b99b602143322c8e37bb71c235b529a99bf9d004a3691fb4b603649def566df828c71861d4b94afb8c4c19591c789469ad0111c758a523aa5f226582636c019ce8760a6fc302077901e4291a7f69177ec6b4b2ca1cb4921a85c7b83c2c6d4f200e2d55e8b82b690946cbd52cfb8966c5f5dc65870fb1801a413da6aa53ac5c935e21fccb574f21097beaf9575141771040ac31e813c4001f32bfdecf06bb496288e92168860a2b214107015e74d9125cf7716f782786b5cf271fad4cdb9a2ee9e0008cf439703d28e78dbf2e4ab8fe31c1ce7199d609857ab9d679fd898ce9ae2cf78a5016b59a89bace5decd8c169a210b38c91eefa76568427ec3c0718424ce15dd438fb828b07d6ced8342d7fd344f947b612e2bc80f09976925b849d67ae1ca8ffcc194ea605d17486b62cfb8193044ef8a67ed987f7bae9f933ed06c4818e72e3bd429d6c424518ce7b67e57f2c7d153e07c6b0ac11aa35a25b2f64b32ff56eb0ec4a825bc63c19002ff30fa9cbfd3e07eed5c220bd4e290c3019f172dd0665f47c0e4815984d0303e6c30fc6405afa84b8155ea08846fc791c27d6d059838010a5b16c5e9e0ee6f3d742ff983ab381e0bf9272241981ef92ac8c553bd8504ba62f3419c1e05636ec8e6a02cef69e6c14d2e7a454c586513a9374ef6f1da57343c06805fc748d6ae80b94cd6e06ea056aa5f6b39e507ea1f16dcbbe8cab36159e7e23e9735e573b49f9881ad5c1ac66116fd2d3fb379cd8cccfdf67a480f03664d801c6e70cd3450d036d4e569773866dd9eda2221fb065e077869efdb3ca37e5d7c186f1f3ec466caa7f0857078300becb4216f9130cca499a6d00a741928b7d2cecbdaa8efa915d2cbd5463f1e66bbe5780e82756dd3af33342ca83c6ca735d0649919e62855eb82f1367b8b4b6ee17cc8d1701d8cb6c9bd39b66301ca4a298d54cab9813eef62d940764fdd438dacab8c296bb29c454f4502e0c1192dedfab778c3f93117f946fcf7b35d5610260913dd1ceee234db024a998b8dedeb2019264b175465dd0faec5a8a6ea4182815323de150a291c6a110ad93955854e2e8a15c335c31bf716801009e48b12aa813b0f83dcf9318b6e861695aff8887091a99d63a0dc5874f1eb22b2bc2f22eb1336d46473f3ee3fa2875283a32f56437cc7e8b12737ec9dc45b97090b0504da481d4770d4f3efed1f5774a3930126d319bff19c883950682dff89f73e924e4e1aa4b211918489ea0b45d4778f45e611fd80cde58bf46614d81df2b5e6db1f33eae9e530ee9c1149dd57c91e3d2bfb32ac5e0461f14f754db59a6870b38e31f67f8532f368f977cf8e585921899cfc12da313792eb5a2a26acdd2210cb2ee79700f80e8d2f48ae469bec8b38e17c5c0a43147143ad55eadb27a9d72af2f7a0c2a274fcbec60a6a1fbb72891fd68f2d92cbaeb4ed562ffb2aebf87842a042918554ca6e5fb66c4914558b5bd935ff5c66ac53fdcd2af4dd581ed00838c0c123b94193154d4df7bdf51dfa5965f6e8a815aad213fbb225f860a7e9528674be6f5e40a8f8ccf203b430cf4512cc7b5d85b225e4c6c25a6077e1bb010cb6df0a1e043981220568b69587b7fac7e7b05a500a2f43007f8b0ab31c99ae22f4d715cd9006d309ad679d8c39bda88e4bdf6e70f36936dfb9c6ddac384c04d96","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
