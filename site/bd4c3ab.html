<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"101f7d3bd61e0d3abd914f25861a9a2f28e908324c6fc78f8df510a3279df1ee0dfa65e65be15678f33247ca1014ba86b9bae5917272ccc04f099a287636fd44fc07615cd5e7464ba3e598393c7d7df496dab2de213f8591baf3a7f4233f28cc3c0b0f1d8d9a347e48825a4803ce0cb3615bdd946574cbfaf907f2e98cf1439a247d09c7e887ec9c912efa5a6d37b8caa83f4a4bb2c56350536d9132bd18943961fbc8cecee00a47c3f8c2934b1a1ff4a438cf385a3babbea61538510173703b24113d142ffb46771509247c1eb509fb43acd5ed3269407cf54fe1b91a2f967c8bde272f3515b7d58dc13f01a3cd9d7d7020ccd70d78ef91d1671342a36fb9785d15b693b1df7389e34d032aa3298d48f63fecb6df6f9a9c6f624987406a4581ad2d40572f3fd06a66fabd3ea2bc03b62205fb4e354b688246848beea4f4de34813f97d1ab47aed979d20149495407f6a99492e7bb777826cc8b9383ff67419b15fec7f4b8fc306222c4f5aede113fb6eaeb4b6d6969770cb1f90d442a9fbacb5df70424d8b96c70423016804a773b323456fcfdd7b2cb24a5f8bf90807db63ce09108759cbbec696b0643e29dc247e6dc05b390f6c2448379d8b73f2a56135ad82bd05993cbb380f0d8b98097c40a8a61bfc01a01eaee28171a568d971d7eea6dc5cb3bb4f55373d5ef206e587eebd1389b2d17bfb7657a76409077a87fde39fdb183d76905b7676a0608124236069b864cbb69f34441ff6ad2101a52f2c3c92f4b0d113957bc64305035cc693978f1b2a2ea0b93e6f80597e01c6f4d8cd71e9d9ea8a8d250801563c440957a336143874175423ecea92189d7edd5cb41b6842d818792dcb9b518c1abddad2cbf67e7970f732600659d26e20162632b7eb55fa53f8225e3c7e1680944e73a384e5e9646095f5f0afbf9991406bc88a26788681a5ce1a6a0855211518ae9f336c402e67a470fdf2026a1c4735cbc557e0e220838121f2259f1268fb6d700b2d481ce93577da3900488eaa553007c624dd90f03b7f44ae4b885408d788dcceb98f955f00e9995c936e596d36bd50f6c0f2dd83d48919717d5591e8559e926640ce25397f6fdc48fdb7c5a1888dd43dd27648716583c3f50e7ae610a453c2ff6eed02ceb8df37edae9274670afaa6035ab2220d82e0c4e93c555318964a7e2ef94e6262bb638bb1fbaa6e39d03e005c8bbf522f4043dce937d78d69e2b350409bd0ec5007b762a21ce9ee02d5da49b95abf243f71f7b21972cf898df9583682cf47146b1fe1ea879851262beb8bf4aa4e260a044cd91917ed63f74384f85fa6c4b7726a46aa5bbc3c1cf78b7f47594a7072f5b48ce96ce453193b12d3cf4a0e16ddc5669bd82ccb44be26618ee9d1193c5225933adccf9e65d1b56b5af105c759709c9d289b323987f0da234faf8174daa7e3621bc8495f207213cc89cae610087e91d6891937ed84ac4f13e71b3b1c81c9f87c05da1e4ca5edbf9151663f1376003caf6c797fd89ff2fd4297c4fe8c9ae9ca0609c056a09cb927646551752be556fcaec1ef57a6d08a1a628c6939240b0a9c6de613ee4b4192909d333e2232f2eb2a91c296cd58933deab98cdf4956a0e0c4027befc5fb666c4d40faa3f558d0308cea8cd1aabe9b93995334700da4d3ec264b69abedaef22c63c74034fe32df1c94a670328491f4307711ed3375f6d1257bfd588bb2bfacc66419aa65b86d26c2837f3cdecb2329aceb5303847759f85df63abe511bfdde4c49b7eb479027224cd8a03dd579f0c163ac990c42ca4668d98fcdc30cea350b379b3b1e25ff97e9e72d3306a66155b6ca5d7af16b9f2802e17f01ec2e2c2817bed147fe9d4683e3a745707eef1c0448a825a910c481b79b860b686aeb4846a9f056708b092b9493aff6793f3838742632c831f4c3425e4e5d741d6238812015d91dae692849eee0b673c055a063175fb69ace4c1f6dcf226f87002acd1b688fac4398e9b479ec821af3e3aa42e161ac4c41b2f0ec68f3174a5abaf5b630ec533e4cb1c512521a04514aea60a7766a857de0ee5cb6bdf42bf091e8a121f29b8f4fd95ee4ccf19c37be76389392404fed873864507dd8ac236dcb1014509e31602d3729873526a4752a25a8a912ebb9198e993b1eea787bea4def0aa58e99c99e25ebbafd4bf27f6522ec17cc9abb76a0ae43f42318bce8850e3aab6339d47222ae3164f3025596beec2dfdf8c2988271fd3e2a31455afb3117f693281c08e09ae3e861ebb015dadaecf2b7790384974956c97020fa8349d6026957b33a7bd934eee6fb7eac8eaf32b65ebb2e6b68a93678f55efaec1a4999ed2db3fbeaf8a126328adf691f820ab203424e301de9ab27d18b7c9a32042494d83aba2a67a136191f5601783dacd5d1e1855a5279e85eba41714378477017c2c7571e7c1118d46f8ced5495acc9d133da581baaaed083021735bef02ad8d63ce56cad9a7bfaab96d74c873abf4322fa895dd19046ba7121618f0863f8a1bb626830abd58070bec0da9b781818b2b53bd5a3d089420596ceaabf4d952389e23cb314b182b3d102335bd57a502b2b929134a30d871b3891f7aafade63e7762c0aa871028835595ab4077694ff852479e1e98357c77c0b2afea54103cee1b00f445f6b2cc50ec1df78df415a623e5abbebd8d85c8316f6fe5794b276584b06dc8b8c1a02c410783dbaeccf125f87d1fe433ef7bcd5db3d58495ddb4e372dd778ad1d0955d3321c0fa2692239409852406869fa93e032a888ab8b03ccb81b27a001c7dca9c33a9942c5079716b572065099fcd36e2b20eeb2298218fbc90317d6c60680bfc44434e41ea59c51fcdb5bf5cd3bf9fc073cff62857980cd030e1dc90fb436f08dbc8ed3668fe93cae99f63c2bee7bb9e9ae1fcb838336469fe3f31d45776f43c200ff1798435eddaf73c5c5f8d330e5de932d4daaba87aac9f07357588afb7cc8a0c874f5a609f1ca3fd919cd21a531eba79ec535abe2281c8afc27466d32cceee80af7b852350154dbd48e6997d3dba4bff197b255fa8c8c77699b53373653e7fec20c13a7a7ec3feb343c4cc47c5fdba8cda02585de38316b018c6fb1ce2d3cbd38dbbd2d8b9baf79aade93232f6182e14952d373a80a3436d1bca261b506ffe90e7a39e099f6539c1c25263e7acb24a39b8d362ca5b4259d8549314a981875cc5c26e679ee95eec0f9fb01c0f4afb4b9e024de1eaf631ad907fabb657f5a169ac174e60dc8c946850067f0feb85a6bf1f6077bb9d3b326f4e6ec742c667f26ac52ca38baed3e09ec06eaa207ca486a93802ab87c941994250efaa03037e70fb42ea2afbc6208b14d265b43b4d1fee9c39c47bcbd87a829175320f70dbb72aae46b344a793e95137b9e19ca77b63d42c5da56abb0cdc30e2444421f66b5d53fce38f435baa5b0b407af3c138a4488f124e2618b0d5ea28d863edda414120d6bd0a3f6b5ee2cac666a014b84d62cf63640298aa0d980fab6251a5ba74a419286811a51ef345fb7bc719642109d34264b52f4f961c34a5fd38d334b86e27c00e5d7cf5fa27d61aecd38deda2848c80d89f6927fd50061b00b10c050f5cc31a60a9e3344bd2ae9fad29063e27917c4aa0fb5742e245798aa52a1cf854f94a44f16af06a6905d139fb024055d96c2d1803f7f239638ff705ce6d3a21cdb46aed970904986bba76b6adbbfbd2933b02b759d6593be474ba7f886890f22a749b4c1ceb235aee368b9101268f50d94415afc2fd84173e79803a50954ae39cfd5fced0c3ff06e0103572b4b59553bc979d20b2fe02cceaae638a36913969f7f93f3aa8ac397ce00272b44f5f6d589008b2d2444716641b903d053dbc1a0d13929426b2fcada8c42eadb6ee46f3c7584c5439995573c3ff1461ae5044cb21172dad9d7b1791361a0ee62a74181ae6a3d451c4368d298ed0b1ac1fae3a15a8cdb8561cd12bbc54f5a5c92482aa636ab050fdd6704e5cd236753a7483cf7a0b4bf322504698f9cc85032c650b86fe4f4e4cb4212ffb6d68acc5c47cca5e8c50a2da48f5503f87f0833b60e86f554bd1423a302896ff5c3813b6194d7624e01f94684bbaa47129c54acfce97ad707ef2fbfa1d95f4d4b1adc8e2dd41ed09f4ab2715ef1fa60ee8704b9e9351db7abfedc6bda780755d9942c259eee89e5fc3f7f03ad002e231cec5706110e95c5225e94d3215bb12fae2399a4004a8c86d5bafd7a1769fbc7deebbcd4d347c260c4223e2335b5443fbae63852339359a00729be180f835a7847fc1eaeae1fe7bf03cdc46c5711ddb05b8c730419fa672de12e501039a94d6353f0ad9969993a6e57b0fffaba48943130aa7f2318a143a11d3dc4c610cf6ffa29473036ca393d4ed5be290d13c2583a0b91fd2cf4fa603ae9fd233b1b1be0b7216c52216116009805f1af1d699d2fa7751f1428dbab10f4e0d0f08ef82964d9886e8b41a0564c6dc6c8e90988f60fc082d1b2596c60e84ff3663422f68450b819f02ea73e9c925d074fa28bfd792785c078cc4f5f29a1cd8177b70184cd09de2b3651510ee91a1bdec7fe35d0ab356b88d2940acfb5c0a9d20590f6688ba5caddd5f71a43cf8b271a5f1e7df497394cc6427600c52daa34b5633e7f9af95d352bceb077b14826ba7b2c8ac896f4bba3bfaca3e127237b68d752e91ce5c99f96aa96c904b7a9111f105e8b5abc785861364e625a3da2b8ad7fd9ec61aef0f84ab11cb9054cd8929c622fed5b1128d3d7ade6b2e33ab494ff35b6e9eca1be41972e3c0d172ce6cec6512a03b6ad4814407fa32f2002333aeb83f265b3e8ccf361e9f8615a172d001824273e5aadc3d840ad59918385e0bc656a9c5e4bc6117fa9d03e45ad759752b1b00a3562694569c61b3a97161178bfb6000952c47157d5fe16c96883c211953c371a30cd2702fe94f0547dd6cb446fce54641014ea386046901765ac98b9cbccea8aa163e1e4ebfd231a58ab847485a7060d2c4c2c74bfccbc030bcb07a1fa1bd21ba607c59f76c65cf84f4d5f3795bf0fcd1a672f1eecd2aedef53f2a1034115c45f0982ccc086dac2ec7ede52589696514a21363d697a0f55c6d57807df3ea829006d1444a799875ad333f0bc98758693bca2cf6ef02d329c56094da1a1ef9414fbb71ec1fd138a49a4ee9d3338ff5d82db52fd22e694b8fc497d75e95e4768b949c1ceacc72f54ac64b34a895b33fae843a896b1b8654ba6883264f295cdd9b2b6624430484f88f46e6ff153d540a29b7b523592589001fd990da11dae49322bd0c8dd6d6f27541307ed437cc20eef6e541cc16b9402e36e38e8b4c8b83d260392688f516eaf7fee6c2ddbe192515ebe5aedee3fc94a13140035b55acd56cb7ff9b2c72776263e4cbca87dcc4a6569b4fd555e98caf26ec3041f5f72deb7ffaa4ff0b9875fbf041844b417a4e5d1d2da5047c13ed3acd73ebf724a26b96ea981c379c51fd6ef66a9658138cb127cdf5f2be15f1ab96466ca99a7f48f2fa0df9376df1261888605960298f74d08b1ccc5e60390df4a6e8343872e9f9aed7910c6ce4768b7c6af0ebf63812abafda980717f2e0073fbf150fb6db488353bc46152fab9ea6cf5cbb2dfee4eb0aabbb8bdaccf24b37bbbca425c4c03decde41d7f4d3cf1e3858f4edf299d66d66dac1ca116845a30cb71584828f524c0eba638d550fd83b86a7fa7e234c57f60411f1a98cf2312d4a72f79e4d373f53bb860c1fd06b27816c2d6b020a20f3701eb677af8249d4ca9d35a1eb80ff549e4a2b303c4f41f0393e9d0c7abdad9950e62510a0b66ea4221cc46aa29d217eb86877cf875c4139ffd5cd39dc7bbf70b96c8a7481cd3832ee8fd0a0be023b7c5d5c09897384dc69c39fb389cc24168bb322bebc9ecd2deb021b13f97d3d61833f8115092eeaac55fb452f45f47b4882712be894ce70295688916ffd82e5c468f174cb84951ded35aa2610f0c110014c9112931c8a79eff87cec509889e4279423c7a26012e25833ab779ce449104a355d1cab07037b492f129b96ad454f860b5c55af4275f6e447cbef198a189b5cb124898e215cc826872dbf91502d9c0dbe0b093b6f08820b81d12a4099be717038bdb9dd1ba21e03688f7079673b17390bc1ded828905b94677e93a57ff0a90b23dd61e941426277ec6b3480d48c6f9f57c7979b6746e3b44824cae4f74254109962b5122138182e83a9c9ad99bb88bf43dde4ebd89c8cb45fb7a55ee744907757c82e2902515c50a47e08066549828c2cbc5e2b7fc0f20c75c6e0c66499907a9f0c772d0a8d25b27ed585f9b0d92062e947a1ea4843776a1363d13d2ad870f2d1e3c15edf11af6994498a9be42c25e06c64df15d6f227c576042e89343463f30f05c941c67512ff80702ff9f6ad6a49ce28cb5f8ef739d852c8cfba5c807a0e3efc6ecd9ed09c1160427342e302809db124084d8bbf1bd6237d18ed660397b879c6b841dd09ad719e07d53f678623df845c1f5083c92d7a168ba0826e167008990f1540948261c6262bcff9511ac3ced08ec271924dc3da31154fc3559b9f44cf9ae58e509818e552ea13b4ff34217d509e304a7a68833f21c24e0d3ee92de00dfed2533d5e7e82bcfc1e291ccdddb1386dc7631f498531ed9ed5ae5edfa30b2142668c37e3f113f587a16bc02394dd77bab79a037cb9d38a60ac9919e2210cd648aa59f47b758b4e0d6235d3e28c4c99b5581215c2e128d44ea9ce789b0a06771e96d682ed7288f9aad2b41eabc9adbfc046a2ff364694a5172988b8eb315ad60c48eb42a737f080ac93b01c1e8ae96ea2b92f20ee19a4d99e340324da0f55c768933bf323ce4da11ad758eaf16b1cc8ec766e84d44d6c9984ec41b85ab998b78a3ab2226ce26bf25a403ad071cd8250e07d73476e9b02c332687fb9381a09c1d26354139013e245b2059f9927607be0d15d356958d4f2e0037a8760b006d8495a5385c5f96d2000700ed19a758f168ded1125a624663f4cc15f8f6e61c626116337d8f66a799d1f2e2fbb000add277ffd2f335dabf28f224dc7129475a592e3b1a63912faa2a6cf9b92a70e0e78e0dfdaf329cbfdb225aee849c436aac2279ecdf7e8c3be4e41cdd298deb577719376c03841eb8298b766d9f81bf313cc1c8a8d98e1f9a6ee4ca8644c39e30d0605bd1ef98354a62ea6a4b3dd0629fe167304d1f94136298df9ebb9c1ef810fb43449771f9be8d9e39f90696b98e94cb656fa8408811dd03c3b6d8b6f8db6866f86780c08ab5ae8b366789fff1b229aac884933c7a23c3948c64da8c4eba313f006a890905b791edb31d66c7c7e5c97951f2fcc041544c21dff1e27c49e891ddfa1fd593c2b11c9e187055ef26545a340fe02edde15d2fa5a84b37e7993d0c99a925aff4ad495b12055e23b95a390011fabc6256eed32cf763c97d8f8c7d3a2611d5e5f49e19ddf047c05b14e9a24692aa117f8cb8bec610c4e52d6aa216a15de5d8a11742cc09147bff55de642c09e7b93ce8f25334feebe2ee5aa54fca2a95d02858dacf6ad0972e294cdf5dea3f8709dea1b4f2be8af35888eff9a5b5836d010d420ffbf7d98672f1af712a207d11f2edbd00415024f97fdb7cbff95eac1dd685435912a59d21315709530a9c7d21a359699d1f960aec9311cb87432bb237b7a5d078188084b84ea2d7a4eacf29cb4a909a18d666267812a1c5dbc9445a74288f6b9f10183ac2d3c282a23c36c816824f7414fc283e9a42c7a14c31896572e5b9701f0b7e170309f6038c9d8182a3ad55146c86d7665b86a10ef7cb6a1f8c259cbaa0bc35aae2cefd782a62a3d1703fa42c50ff5be23ce3cd5171546d1dd53fff18a5b509833d22ee2e6acc13e494fbec7c2248f23407ec7cb468881b6235961a6465075af68e0c2937591dfb7009bd18cecfdd5a2d8983861ae5015323678e84b6d6f7291a16b80c6954b2b617b97dbb7cdc55335784ddb77364768c2580fdc7d31d8653fd2a3acd4a8e19b16cd19d915f09a145fc313df6de9f7d8ba61bcdab3c1f296cb05b3fd5a6bd1d520a2de62baf8d9573e13610aa884a75ff50f4044ce04cd01030c34e0698e0659bfe5edf5aa6a6b95bab9dfdc794b7c8dae217eff041af9537bbec112b5ceb1339d903aa37fc437a369cfa8b2f61203de39b2aa87f9194be00797b086740ec8c2a96d02e9c1dd8b7e33553a493b032ba9002f4149cdb961b2ad00c63c29739ed7fc818a827241f63e7e82b3af63a5f27a41644c9c08fa95a787a5103857b1048649a1d47db10fc6c33b3cc037741ba4aaa45b575e384305a56cc9881daec03d4282906c598996f516ce9cf2197308a02bb4f2040607da71bd457b90ed21de7d6912d5b59715e6906339aefb6359510c4a58349d0feae226504b367f77f42ed07183ca0187e95fe867f163583681f2493b357309559df6e7488b83b2b310c084083ba781fda2593fc9a0d5477dcf86ad9ec515590a2b8cbe79c9d07f60d5a0833550c6c93de7bc4ff77f7534ac38360bb471c3386e8f2defb9cd687c6c54d5dc569d6ae55493128926c5a58846c3e93d1ce0dac04f5f7f0fdc79a13d542ea4f29b4e81c85513ae717c49bb9c95c9fe5285de656c0d15a5a2cd166831a960aea3d21c10387d34dc3c5cbe5d2a87b4c188746d740650f603d398191a9d5007659b817e18b132b21c2338abb4f19ab55c427974b3a94c7ffff07220b4c55983864dc926debf3d3270d0658bd8d3e8c77a1e0cfd1cf4f607b8dce34ea2d34d5c784bac5631b23dfb1233b7c54c4cb731821b25b6d9918da1edc9984647d2d17acff3560ffb5460c1fff9fc4df479c17f5b7bebfeb906870213dde21ac2f36df9da2148107222ebfb4a66786b551ca9fef118f7182d8ba8b1d79e576baaeb2acf28ab7e700fb0334fa6202cf582c0a0fbb0fa9c6571672c5d57934d0e25ee4cfd51ce66e6403266e69bf28ac418765b363ebced227d11c4d2f7ee1cac6cdd6062eebcf86ce36e5ebc47a6b2113b8de64eaf689d9e082858e5b5eb2c6bbb3cb2b2df5e1772e512793df2a0efc91dd5fde3fe2d4c930f8d7c1e78ce241cc4fac938b4831dc9b408974d866c8afe244a01c0c7c67cf7b4e6ffb530d19e2bdfc06510583040eed31afefc4188768a389e69ece13a6868c4a98d204f0b998226bdcefd4013d8b615d8583d3bc2a1db1828bc0facf292d9c008429c2e3cfed1dff8b8beafa5b23d7bbef405285cfee3bbe16f46ca5b1ceb511a7d6a5806fa8b10fbc8aea95ab85e184ed42b1cef47db4bbc4957bda5887c016b9cec66efe702e990bfe4801e8fe96c7cd3ca03bb7e2f8ad72e2102c488d58f599e61dc652ef70ece78de4124392abd0fa9e72dd8305c78534c0ba0810798087015e523ab6c88cdd13f563d9a757e3a3fedaccac01f494a5de23dd377f162ec9a960c70a7d978d32c5800fcbe82eb5053de75c95fb9793e94f363f51a3f8a55f926dd1fb2d0b2697ce697a03d991fd868c3a0c7593d8f59846d5236b07779a728968d33947f7499a96aa47aa5274dab3a729072c3dd040d7e37bc9a9d402b572ad08c80bf14b3f725ed50a71fda28f96bb36ad7398ffa41fb84abf45dd1b498a6f2bc53bc85e47cb6d1027d56582bbaf938a637c6c06ec7a595e267e9fc3c396a14f382d58a97ecf806cc1dc13d404c698e78032b0de289072534a90aeab225602cedbc8a14cf2b9424982b7ba98abcca4dae3e3264abda9ba3cc4bff992ebfeec16349b713372f7de01a31464952938c29a903b92c2f8d90740ebbd080c48188049a181e083ad6c0bec949f905b64b3b9d01d458f5ce37ad451ab7ca1232cd8106dd263105662e6382b982710e64c4e499421673e98bfb388063807a5849ae3fbf134a02baff8307f953481a4b9ea5a14a2ba14ac3a849c458c044f6a0b4410f9c0f407d60759d0d78fcae9b8ef26302b8704217457cd89db926b82487a741fc939bbf70c3e61a9f64bc606986e7fa4f379db2be41a58373499635b0b1303cacf7a58e38aef4385171213b5a301872ed128ab9eb102295c32a9d76282ee989f12e59a0ffbb8dd6a662443de01805bb8214713f94958a93b4a8e39413fc730b1dea413e7005aed82133b52ebe52a7f8cec5c5292d51ea25b67eaab886e064eb602abac78f948e020b336ec57c043523076b815956b1aeead449508264ffe91a21c2c6a9ebd7cd45001d9c4f9e8a2242c04b69e4590101b791d1ab739565214ec385b6073e8ce7076e58b94a8fa0f68c15ddb2b444d7fc6c3c541ee2c074dd21565f7bf1146a695b93a4675497128b4c0404269af419e7b601fec0b52a26e15b4118d2f5b43339c7f9f469732ec70b45bee0c2273291c34d5f5f7a613490e52e5faec632040425a9dea9ca80176f71c0ba0e8687299942ef0a01fe9d75a423de5a5ce7e8d6f10878295e99855d00fa66d21d801f7ad563fbde69ce3fd3fcce303f6af8869e28d183ff1809dd8d5680c8a84209f15971df5fe660f626e08b4015639e12d301eece2bc4949a4d9cbde0efd433c58b3613e92d4b929790158890032333a79bdb0cf1659daf017beaa32f33e9b4852b0ec441256c8b6e3bbe57057fc04397930e9717f16f10530cc4076c1c62b8a43dc3951fc0a74b3c625a0cc1535def179b4eeb9f472a350a7d0bc77f544ca76ff4551909ce27aa483945383ebd812749349135998ff895e418fb91b1e85099f86724b60c169378fdffb5c0f4c272eed06e8c0bfd23d19882508010c4de1a042db519808fffee5bf427e208c2cbeaf1b9b014173969d80252e71b0584b5bc0a8d59012f3947deaf3e54791f802f65a886370475509fe07e0bc7521649b9a27f203d1ab9d71a4d0d0a845822d0367ba0fbc68abf849b49e8d5a7f926874dbfbaf594d943b2e1a07a15c850287280cc22b66397238ca93e77080cac3a0e73f54db779058b1c62ec875a5acbbb3f543724716e42283d7d71014b51bfc92af927d0f795ae4fc8b92f01211377bb88c1a94a6db51dfc4c4c0e14153bedc0ccb769880d155300825153fbd6b8aa24cbd764065ed1fe562679fb42bc3c9432d60f2afd4b97f79dbb855e64c82f149b2b15c7e8cbb1af2e82effc564ca83fb52a0f3e898152ab41def7ca00597bc8ce333363d154b7adc7b146c358b800758d8c20b8a86cc2b7559959079df808d4dec425a34335aabccc820142cd53099bb5ef3de4504b47fabe83e482fbebc608097cfbb70ed91496cdeede94fe95d726b593af9e902a20182e3ce3cd1f8c2e7b2d6daf1dd8f71710bd3d8a2b87fda29b55878c6defadbe1c860b1f6f76bcec96c51d39843aa580fe9f8122db19a8ddaed036a6e07121eff569b22608d7650ac4e2d5066c1676b7d1e0678b58d2e0bd61cc977704fca8b769cb6035210f32b5def04e2afb1c728bc9801be4444eff772fbc1de752ff28348c32320a3555ef4c19ac2c35ac5e8f0ca284eadfeea936468f937bc19e536d824aaae069388a3ccc58c1384bb82f63806ac876f3eda474694d8b86cbf871c0f1cc2adf1dedfa329bccc2c76eb13ae151bd66df7cb219e8528131f6923493f1194cf41eed5d726f3e8fc92c27f8b74814e2f2c2fc5e23a27628f8bce13149685619fc77240c2d3b6fd0510a31f124d7d1763ed81053570afdae05776fb125a329d4e15c20b24e1568fd575310cfcce3e85f5fdff70da6f1044795ea95d435e4acdf48e4822087ca97681404c69d52b4f0f7aa7197a25b85e925016c6b80bd8a3b0eb4427c66d5ed9d3fd19b5caae33fa240a4e80ea0649252c9af2370535a3754b33c5d87b74544470b85dc0e88c5cbcb5d6b828595f40ad825c85dcd75e76153d1f75396bb633c2ce6e8b98f42f7871a4ab9f3138fc85ea8deba79c9628c479252d93b1db1719057b7376bcc1ce4d561022da3abea6cb2bdacdf6f3b656b7b4be45a14fd332e2db7dfb77b3d2859aac51dbb4183a81b812f11ff11e08137dd7a3168801ce135b0a544265f16ed8c679554ff4c2c80ba80344d2e05489de40a41bb3f092b41fcb404a82f7ad750dda923fff412d5a60f91485f8669b44a71e7ce200236919ebef5ff82e0d89f052edd3f5d7261b2d6542196665afb2e22497cd6a9be36dde8b6ab07d48ed3c6457a450623284c6b7efac44b81045b80fad4a4290d25688cc6b92d9a85e4de93deec9dfd0e54db524d985039250926eaa41a7afcbbc87d27321ced3ab54356d","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
