<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fcdc1fadf68da441b8b7edf47360bbb5b8cacdde680d454ce75c61fa38f749640ab867f64c5df01f0daae72dbd7cdde5c5df5354932aee8c0cd3110904865d03910574f2af803c0a5175ae9a604f26d9a9956e9c25d967941ccb9c1758651a470e21f7d75fdf706356082f22afc2473c89f2982bb110c81636d1cfc4c2bac0fca8d99d9d15abf3f4b70fd7f80b4cbd7238dd0cef7564f0a2876ad7b40251f9e58355db53f0b949356594cec1e6b868301b99923e734c30a1ef984df9e517c6e8fc7b018b62e073b6aa0cbc672bdb18607af2fe52f48f9a4993a740eab0a9e56091ec40852326834db47540dbf9ef649a269e5b131a363d5e50b9c6586cec579f0bf909c5a145d84dce15f07bfa4f7baaf5bed8c73f9f87981b628e8a173863041ce3b0bbe32d1e0a686668bd2a503ee09d5cefc798cf8c53d9b806713372dc4c8e5acbfd580a5decbcad69ef54245b647dd5e7be6c9b722c18a1d3484d5718e728d22f0513392eefdf96be1ebbb3c0c3d3083cebc2817b0d06177f337751d2dd9aee2e48336341cc0d6f1090ed212478fefac3a831204d2170a48baef7cee12b78a4b5102b7ae5e618071ab76bb872c4011d7b2dd71ff34aa4a13977a3d9b7ca4b3edfa4d99573e59cf6b4e55bf12d41998a64e24958d6393a51a548903f61ddb941d14d61ed4bdda57a1eaf5b79e023edc63f8b42c9d5e6902988cc1d4f19e5b19af8dbfef453ddb80a1b8e921a7238fc182b1a95423b56d8402f90bcd53c7596bf388c97b55bbd030e9cbb115f9c5aefe797db7410f8548569184649f4aed634e95add680ad44c60321aecd3e6cc4466170fd19ad9624eb3ded832c4a2148381699fcde80cf78a7eef3dc984cafda03b0a9bf507b598fbf4adcb60f1f398f757715edad344c351c532ab3149ec4edaf683b12497196a70bbbcd428ea23d4a230e76074f39d58dbff9c147bbf8cc4ecf771b5c69c349700832c49bc2378936c27742d2adbaa90436d239e681aa14291752fbb04f8571d0f0586ff09ac5cb5263114f7239e6275c6411d2d83488d60e03271322c727b37f51b436bd8c7093835d41573554f042c99e8d11de2c5782fc77e404eb5dd1b041fa99ef6e01c8c8fcfc7d5c0436e0eb011d54a74e97d86531640e68a1c02a5b76ce6c8bcbf18072b4c90ed3738807487ea2deabae91ba80e0b0c6916c1ab44c25efa32953a3f489bbd37fa89b95280db72be49d69ee8557db0f3ee016572521b9e3b58e014f9808d1e3c08f898c8eddca7cda3d3c369c6a17ad1115f573df063ad4b2c61552cd34b6a33277725962541fd71c8d73598af57afde8b893aa5d80c9fa73efef6143052c2717683cba69fcc46c6099d9a6744e18a62e6f19110bab954b1461420a8972d44633c9f78786d907ebd927ac5a964c8f85cc57cd939f83384e4b7d3317a05e306415c6966e477ac6c4f61a5f6d05f1b0d963b75dde66e85c0fbc18347c45ee833c2de561f4d7eb469681e5001eb67c13b6263c1917334cef7b4907456da54252283132743735c15ba00a8fd90107b51b6cfc16eed75eb824bcdacef7e0c484df8edd6f7a9701f2bdced1419553380edbd39160b00d28f1dcfca676ff9f87cdbe13c454c9b9706d242be4f98796e04478c869bdd4fb0bcae2b4aa296c8bdd63af243f3246ba6eb10f0d6a34b4f393c7bf27e5f2156541f805fa83c52faa9f95533b5cebf1b8a92474e920c29c65230882e07a0675fffb4c8f0eb22966225518481ce2481a565b61e264fbf8b41cd00efd66e01d262bcf067dfc08ac25c6ed8b7939f56b545e853bcd9088b4e382f59faf350bed7c1d937d892781cb0f18cfbb1291ca4eacae2b5f4f42a91806759f2fce94a9d8da7a276ed168f48d771c3cce587437e4f766fdf222dd859ddd3b0a238a4e4ec88228bd7d4ee677f1aa320a2729f6b248ea7358879a9363ab38999af6a4b496647c8b793a880252bd8cc7149d515c556f8059620664f21d6a638762ba019907064752ae8bd64c0963a2387b43b3ce2eb220a2a3e9a7931a7d16925531f9ebe5f1b635a83c54c2b994a27b5f5a909f457719859b9c0109aec9a0560dfa4839e7031f4306a62c6b2a7329c72bbea8760aa43a91dc50edb743bcbfdbca72da0ea7e7d56c2f1182f4797a182957f1078b618a287133f9bda3826d5ea73c60ce2d2b3d2108dba06646fdc31af92de3bb78129387bba3bf3ed5a8ff65014654d7a4116521a5c4365c729107191f0e955458a4ef29ca6140cb9129c6417a88c4365eae59c5b9c67890f17f0649d59931b8e58dec774810b386a67b488686909c24c09edff4e67ec987cd5bf21f1d7076072b8653e777a1e99818406e6d72da89e6bac026569eab213e0984d8e4cffd6bee1faa67767a3975132863a0235fa268ca883236fd919fd01db31b996cf3afbc58bf0390588379cf760b007d47f4b52c692c3866389537eaeb9ef7e88a88b8a0018b52df76614b3635fe2998320882134095f607eb04d98885b4e36dcd5e927a340a5f3732491dca3f84e89ae724de817126e51258e2b2b12c119b48a312ea3ffc5a164aa59484b19d9768b8af6393d17ecec9240cb1e743689c6a4893ed735c540ac540abd5bd10f8db5064564522306bd05edd0a36516cd420270effa387710a2d66e405d5b1784b2cbd1819cd404f8e4912cd2ac0c17b403fa85767bcd5bde45c68878fdb5a3b11204d0e2e56076e87e17e1dc0e5ed5c740ce7f6720b08e560c4f49262c7f54cdd9b7e445a4044db4c94577a55e109153f33f18d1a38a5af978bc8c8f8b61e802974ba2cd509f3f59b47fe4a847c7fa2e863fe561b783559420ef0ea052999bc81325e74d11fbfd98d0cf7f516b580d83ff44873d4b712c4f0c152d0a897f3aee3b1aa0ac80438dad1990c24889908b42ac3b694a82deea0343c6028a18a26656f0d11bcfd5c37ad48cc11f13bb0a90bf7ddb6d77480631668eea9bfbf46333726f496eb8e1d13988921436595719bb303d4f4080966af74e56e932744159db6e9604c760288e3e56bbd31e99a59666386740da670de107353e7987701dcf8eb18469f5bc282fe29279a8d827a01c4dcad51c1ae144f0be14a05df2cbafb83a34f562301f408f3ebab36f2b29f3ed7ad30afd9a43ad3805b88c09e88367f119a82e784b5cc148f4cca881ab83451332b0642ab3e6e02ec43c77a7499ee020c4995a7278c0fa747224d69f3b68ca6f062cee5e7edae34fa933ef20118b083022887e06ccd660ee9c774ad01683428799e3a9a9bb6751ce8db939d75d6eb8c96dd48e32d7778e7419359d12b8c58a140e3639eabdb7db2e8db061fe0cd28ca2605b13d5001063e4be28786292e8206f97c51c3740e214d9f689cefd3a38646d53ad67398e1f559c97efbf099b46a4f1e971f7dcfc3e04272324c97e9fe5cab4953b8f4280740250887ebb0b3b4ac21995b8b1a4dbb47d36119faa970de1c951b9c2f2ce7511a4c1079dee8bb4975d1a638db6090eacdff7eba47922f020b4fc2ee96e5d0865be41b0ada6a17297e0ab67b1157a2207ec31df188843b2a6891749d9eb099e9841b18894288d665b66d213b70261ff6ab0c4af583c07a6e48ee007686c59717450b124f6201b10034dd2814ddc67710b6c2c456778ec1cb8a8aa2b8f3235274bbce719157d9735dc27d5ac1903871d449bff2d719f765d292ad571c3cbaf1db65e4e43c3a55e7a1e4a688877ac63b60848ba614b00043fc37c4bd11c8998d426131285ed2b53a1c638c690c8d38df35984fcd4d9a778226ecd0acf657cf54a4b72d85dcb798448bf9ff0ab3696bda829df2192904f110ea74701590043665fef7f6950e211f210e2d0aefc88768e7998381f5623498c6d9ee1cacb124d19f701ff2375b1949179ae86a63f174014c95c1a1938c77e22e4941ab35f8a242e3b39a7068709dc453ce9fce94ec7c4d7c15c58e36b07dd077d860caa6e09154dffdcaf231078b1722e68e848c1e8d0c0a035edd5da23db522c90fcd263f401ce8c2050455dcdeec25d65e7622850c61bab4599bbb2c91aec3658e830c0fbb777b346187825eb345ab9bb5b03c334f9cce687bdb4e5d37326289ad67e9d3514da93266da3b57352a4e332a83cd1e90cb13ec0f33c83daa95bba67b0057ffd56defdf44ed9e4c41288f4df6ce189c744c9936a0bd71bc02e2a453efb3d53edc788808f5a50dfb87dcdeb488b5e5887454b4219fc64de00f59c7d2baa7e827ba50c87588d23a962ea1701a2d997a671c8188a06410686075ff91d9159cee603f5494c4ec0c08c931014d5f10349c72c7189d8da11f9aa4d16c00ad80aad281ea189ced7c1485fc747fbef1b742918b401a0559a44626895e319facc0d920e4dbb0ed349f821230e902a9118c9b847e50974c5f1b872bf4110f83a8e286aa1282c3b6b812615d1ab1a7d75610c8218c2b761ea95c438dc3c75a8c92d0d8c359742e2e6097f49bf0bfebccd523ea3ab252c98adb3df7f6309c8e93354036c1078c4b10bc17eaff8a81a1d3a9a0830a680ab3c54d019ebe264e4b964ffe8088bb5f99e4a9f8724adfc7963c465934ca665421be66553b3f2326d166e48b97226893864e0063dd0b99fc3082ec59c35b8a40a648747813b89c42e55c73ad74680c2898e865c40005a79fac136b9011e5473e762b9046038e62654c62d2ee797e954bb83ba1747b21ec802173a54d5920ff0b26c7f7e46304e7de6395974f6524cb0757c187ddc444b5416dd7e2785b801d1061ebeee6a07b36188a51b653a6324e038d12bac7f7a904749fe55d5b4ec44156c1b17769fcd3d1a3960a00852dc3e5574f14e424a8d4d71a9cab321138360c02a3e3eba370ceba9845154a269d344fcc0c44189cc28e7845c3159854f4b52a669d8f017554da266f3d94ba6cd661c0901e3524d579da2875f772fc2dac6be238322dd4ee996e56375738b554d150bbb379e4844ff666be59e1e3c0576d5a826770c8dbd8a340285962bbbcf93e5be1e404b15023cf00aa1cab1266f2bd3e87ebaf28517316f282a67e4201579f1f910093834b45094ce092b9e302b44543e94e148a7dd753f6638be722c95b82628fe6502c76b519859a3672811176357c646a17878e9712b504bfd8c536adce102dbde16a8eb3814d612ef7901414012fbb2330d3d45afe2e872bc7f62e68073e50f01e439a75063fcc0b7b14e6514f6cc4eb44fe00f9868f73bf91651749a2a0d046e8a028d60b88f453e4134b8c781cd48ec8d415cc2bec22c3326c160cfbcf8028cc9b69d072c2d126cc0b837ede5ea160ba8a640b180435cd5b88b7b97cf61c2f0792665140aa1d75fea278ad7acac710961b7594c7baec5903f37a5b7304b516114b0a8e11072f945b45ce8e34bb62ae072938ac7df89dcbec4c34592375d88569b264f641ff490338f19c1136f49fa66629b3ccffc367a7d188a89758b17f0e0f4cb0e6f0c36d6b913859cfbb74a56432be5304ef63d5d9b14f687e81e4a63ef18d1e04ac8a8f064cda06a6e36f47d931e7b8c44c3bdf680328ab342d0aeb0d1f2152057ff86f2e410730097fc436f4d3a49802cb580e39b48fffebba8485fe456f511814d17fb99e7b9c0e8a6274aee8b76ccc7363dd449275d5104cd805d77f4e7039b917c62ca74e22786020a0635370d9d38ce6f3c9c6e38211aaba061266f04544dd01f64248ccbfcd90150e1ebc450bccafc577394481171cd966d401a6eb586b406331a7355338a2475ed29c0e7e66c9ea9fa5e385b08c0c469e7486b2b23496b28641ce8ab7fc5729350b3c621cb969ab43b706ed5954d2f656fbd515e1d8f0e33e45e2b03bb64be42c64507298e655fdfc01e3c4b935db8c9f3383128e61d46fa51fb8eccd71129d36746c13fa2a0040dd122ba44ef8e1f24066bde9f5ebe659c951f8ede2b06955e3d50179cfe52ab82dda1f5499a09ea30534cfb34580319a4feb513a716bb173a77b54b0b0cb699b56664c8a85fa18e086aef1ebf47c11af0ab3c246beb9b27837ec709806cb6ef5e8b301de1fb88fa06af815be1a9881f8735973970cb1d098cb7a022e3c070ee58224037bb9004f32d496caf32780b8fb3220840c96d1b0ae7c45dea3142e52e7613c605a4b575c8208abaf23fc86d55c1a02d0f2f589ba7a73995b0f746c3648f715c52811923032f8004eba43025727aef0561d96a07025739357ebf35ef89f792ee1c0b9c999bbda50d42b455fe085a6f1f1f860067913be5081a239e97c62d5fa5410b9fc8765cc7ba6552f651359ebd255b3d047d7d13a2be1cf5e6234887b4044f1bfede5d914153a48f0eef8bd60a0ae26070da6dc207e405ddea4b03ffa48b7a80218927201e4af59307ea68c1b8656549e4c6e1edbbd1262c925ee212efc1d6b677d356b395d881e2790253c0eda003c6df0e3a1cfc6b4a7a04f524fdcc83bf02b863371a2b0ed1c3136c8fa0edf8494a300111342f6aeb213878a0bb505fcfb1a2235caf625f95e8c4c2a0ab23868ecaab5c84892df72c6640e8142840767ca32357746b2e23e0fec19320dbc837ff16ee587e1acafd9f4c8cd8e6d7c1a33b1b784dda6a8f705c879a40ab80acb7a2cd03f375c70c5d1ae5d1c024550b8ba4b6fff994dd37968f73ed436e0b5ef494112c2402ced2be46528324a739da78962e5f5b4ce2bd16e3f32a0ea3695fdf9f6e75012eaa9b712c5275772fdf52dc44b10df77686edc45ca81d378b8a19ee7d49e7e318eaf9a9d57ad262587fa501fdfce9b6ab92c93e6b22d493e2dbf216ede414bef420a5b6d759d39b798406b82154b25fd1774476d0cec1baf60394a344472ba1adcfe1fcdf7730957df0e484207eab5d0a5cb7f3d110f490ba80801ad1760a450aa229684aff964ed082b85da9fc31a797bf4cb3cbc736f0d784066b7f068dc8e81fdd63e4db080dbdd2f2f27d75778e0da3a312ae606d44b0ceae54c2f81a531d80fb5160923e106b381ca98a8ed9653361dbd12f78bb858b08603a1eea7c10ee2b8e04b39c6e4ccdbde929031a92ce4e89557e82d36791ff1aab0803fde52413cec0c79474b0b2f1b7a883dc9b6db25587c2a962e378bb4599bd9bd7f5bb121ec975de42055d0c0c39cc2346e5c256770a750f5731815745dd6707ff51e97ac225622103c4b9e53184cc84c24640c6c54b104c488f12ce73ad58415e38eea9ca54c621074a95011b749e96890e0b57ef2993a538fd6dba9924ed5b22f22812a83b35e38f4dbef9e5541f810108c0cec1ed5331540b52cc94d37ea39b805a5d1add1f52f2c9b3343d3963850174e75fc742da8fc4e9f1a8779cf1ec65fe2071d5357ed17a96fc55abb09170be3ea00a9cfaff11ecf5257d8725506ed74f163046a1d100422e3f5a89ccbd358b6a68a574c4e72e8eed2f05e26f735e0df3a17046ae539cb275d5b4f0a7a8708b0415e3101e4b81081f4d0f6013f2ec02b6eff319215197827ecf752ec609b6ffe3dba2af32944002daa10e1112ee55bc6973b249640668f2580bd6aa7812f80e49a37f9fadd422ed707555f4e1f5ef130205b25d7e1979bdc47fa847f7a72f61880ff1bedbf86065c671257c60909de441aa07e6530a4688d1d7d1d3a8e2a92e588797e390730f364fd998622efa4fd1f0b3c68046994e305875d90a609a278a9313399835f1eba43de6da9f34f217d9d60b54687d9982bcb1ecc6501264c9fb9666e39b98ba2aeb68f5f893a46744bf21c4cd4c1172f34ad040a53d84c227a9437de1fa1f99342b9acc2ba6a195851a9eb9cf84f640daf940bb158f6429678786bc4ee8495e0ad6e4fa6d870e4df819a56e01c7af679dcb91b38ae9ae6e41045190d94b842a71843a77c92786499b5fc3dd63797601cbd049a191d78cc8b043bfc6ad6f33af724943675efba1a6bd220b1c8b460e2e2a3d1a786f26c2399753d129ad93d7bb06b560305bc877173b8533afbb4ee97a229e89b1a78f3ae5cebb3ce8d981f0f4bd288ed1dffca2ec3096d483b64ef77702b58e1954d80a48ae6f4f4a5cc2851bcbb492339861dbdb31f5583fd7639c210274b5b6501b5cb762b22e5ab06c8957b2423a4893d613dee25bc151bb97d52a815bb55533b7eebd3c25eed97168e40ee07b07619bc3ec3007add19b35df5bc9892d2eaf84497cfd9f476b47567eb3f91e2414d0d0c480d6cae408069a68cce0dfc10d1ffd59f43d1654e061f8bdddefa8a52582456d7500c2922f42df7bbb46e6da5e91bf07c3db8b884cdce6af343c07eb35e8bedfe76cc69eed897979a684ba1ca8947fddbb537f0e385d10f1d1c1e2fbc13d6b200544991da1ed60a3975636eafa78fd24e2fe198867b2eaa2ca7d0e0fd0aa3d23bdfd0d0c930496273a454e4fe881a872cdbe6499cb2f2f3a298f9d26f759a5a8b5b7a41ffd52e70258e348c9ca30f78b2d52006561b453f6a4212e44566c8e6a97ab74a1315648b2a5e2bc1436f996461ea6682f6aadc2446406d5c2af66ba89dee63fc3641039c0799e1463de23a86ab3cf3323a1e3aa0ef83aa21e967ac7d2aa2c2010511571cefdd2e2837bfb327fe21e75eb0c18b11b1f2ed4ce7cb4da16aaf34a184ed381d1a582dc25b371671b94eef548e6f59803914833301201a778c49dd57eaf43c4f8b3716a1c92cc8a7e4d9d48144c46c0ca8f214fd4e8227acc608c5fd71496a01217f2853b5ea77d151ae78deb83642f8f80a11b1c9a4f2c654ed7823bfc15d5f5f8a25b6351e6e6f69d827704bb7853c98ca385a4526e591e4f14b1f85cf5e1245ca331ad3fdb62313383f73d1a5b3b6f7055fd4f7941e56d95dbdf52ac08296aa3c87b40d51f2d94b0b53c0175e70db0ebeb9ce4bfc43c90a0f22901519912f0f22a9aaca7bb9dc9ba3b2cb2b0101582eb55b2fc2deede35c128960a06c8529af0e6689e00f44553b5cad536d5cc811fa6f03c75a7ea2308a8d00d5ed2e41267965d729a104c95a2562fa187ef886eadbe983f856ff7639d9c1841669fe57a02f918f92347fb9dfbd8cfc9f9ef78d4a34bc70450292729da068927f226d40a1714416debec9a2d9765b42305db1be285ba6a6bfc58f055d0b93932eba29bf20cb035f1b7935c104e0c92e4f89e4defa9f4a2f5d48dbbb4d6b8437e7dbead8ae0384f21724344e659fb2aaeff1400ed5f24b3fe449302432b303844ded5c1bb61a1e1ed84eb9c010d71d37e6b6c19ecbc1033e7f0a3756cce6ea6196d3234349def05cb5bbe795210e0b2ef281f4a447b63f2d0b32dc25ffa3aee8b1c91c3d0f2c6cc58e01002748cff4f2dbe3714d85476e0187645583e344cb3a199251862d36f1903ab13e4c583cb8b3cdc57e329cdbf7123277af5db0967571f3182af6b4e0d0ec0643dd238184987975b3044e83365a612aad5bd4c380d03f7123150b39e3f9e593ba76fe13e418c021e69c3ac939f07e97b6b98efcd38fd4bed015c5128bdb909c2deea71c30e91cdc5106849bac0a2ebd6970eada83ec5e7c32809d0201bd8776bc13443b75ae81408be304a03bd8270b64cb3600926619a5c689ff77f9b1d71525f4c1cae9ec70a705095c357aa4e3d2eb350abb3246a93806158fce479f8f1f268b8924012000b782b2cc3f215836227ae20a7645d4c1edb89cbc7fd3dc7dd0b46aaad59400b1341a1aee76318c8f1e369af6301b7473b58dafa1f2173ac5ee8dad82b2d86beb9ecb088bf357b1d41ef3ca3b41b132dd82400acfc532d02230fb9b062728441bff41f0369083dd1c40fdb3a20d9e2b6dc905504a467bbcc8c8ca3cfd0c3963fe7ae167b5598a02d624e12927accc561a0a43c501097243b8bfa33224eee75293c6d02a4603a1af63ae1a73218d1d69e4d6aa6aa1928e92f239323f40045f10060afb7a5e271689b801c24c2fb118c55f6f62e45b1c4c27a71a083ac6fce48f2b296a6148e6898247e9f6d92add74761a83bf45bbb4ef152e243d0e1eded25311c4b33ca9c6bc1deef94f0d38077544cd654081ee08900e2df11819f4c09d05a6e199a7e89359a5f2b4923ea5e9ced0f8929f648517513f75bc07186bad6da0500d0db38308f8b268803dff65df51f13c987371e1c87e07ace5f5f98e4699766f405fbef6766616aa9c18392463aeeff15b27f6c0fd112ea6af01963ecf182992e66fbe2ff03d60140a8c65b7d6315d4229a72b4e5921b342621cf5649069e302f41022c91fa3f1bb1df5a52557a2c20154f942b74edc60214c655c5a2f5b73b729d17d4df7e12245645bc3cc3645ae933d99823f542546a4d961bd69b0ceb6ee90b68c2b1cb7f5092bc9d9f78dc34f27702eb11dd2301b1cc74fa8644f5066e04ee03ade4c5890342ee6d96114df2ce5504e2a2664eece2b5372c3bcd6d137ac2e4cdb220fa7fed8c402d0a94fac1f86e24991f82bb702324e5a394b632889942e02836cc033e9f6eb89dd51fc6fc26c658f0aa0d65be04c9604e56e645376a62b06b1241dd1fe31e9170e24656aac81f7253f908fe0832489740c783aed456104222b309619bd78da9d97eecf71117335602945e99a77fb3c51b19c86382af15210db19821942bf73a26afdf996e8c04d40f5c2939745ada7da859d9ff90be4cc00d1c85c11802133c76faaaeec13ee96073ea49d8e2f4b0aba6b42d06e057859ed765d82d41ec20bf1fcb3e3bcc7c8b8c29154f215f78d08c16b852dc6e307bbffb3f3d7da42bf234bb529fb13fbe05b6ed3eba185e761b09e794f87e65cb387c283b55e5b8b8e50d4096cfa0cb5378734ec3fb37d617dfba90df011d8664cb81ca8bea71730dacd8214055923f8bc97676a1a90980f48155147a06df8244e48394cc89270c83a8a55a3e336016aec254b6ee3850ee0833bdd9ed6dbd92b44b96af193392cc6f6aa9604a0fa808f65182bcc16d70a3808009826e3c0be4a6313e275918ecbea42bef6c820390ee70e9d099bcecd8463f242d9ff21a8872840f4220581be7dae55a756aa5901131219628539a9867e5fc4a0e5d634eac4d5ac3d4f68eca71311ed4bdaee2fb5b92f66cd997d0abe69ed7f0f1092e63b2510c47143be5be9cae028d1f0aa235743592cbd350ed50002975dc64c0bdb4724f3ebefe3880274aab5a51a103feb1008b37ff1c9b7da48b5274ce7feb14f5081358072ea078430cb5aa0c4692fd5a6112041512eb3464ee1d33405802f7b0e10d12e5832f46fb6f2284af2d5e6e82faecdc23e8072fd6d9f1bde07e4970b840ba3d23cc88a3f526f6883ed3d75ea1bd6393ad2851ae4740ef4b53589d0dfae4b8074b99133f120b36c03fd72469b049c0189077f604f3fa39a07aeca09c61e9967727296f4547ad8e2d62cf5488d1192275fe470be765998c9ea4d95d52b8f8048f6043113bb8f487b4dcbb45caf73eaee34b3e1fc3a343da16ca5d3612e67413ca108ca0f2ea70c5ee063b93460d8e4470c2c3b0efd5c20fcee3fdeab67bf4f147cef93490105bbfddf7d8ae3815cfbd62ebbaad3e17c8a757ff6965d0767f710ce0d1838d48e8e6b00a6a3ad371ae18ec6a97b93a0f30c6d38a425fd8b2f56942d29d4fad89870622acec59fa24fd0a84609f7f6998e49cf95db8ad43b704ad964ae62efb5140fe5bf0e32702afe24ddd6815ac0d631d7cd291bb33acfdb9a12e04ace1350197a7b36b40559a564777575208a14768177aa99f3c182fad742b8fbfdc6501de38c18153dde64417eff253e5ac51382f1bda8918f3576e43d4931b65829115d212fd42d171716a09a0e684f6d3a66d8d4cae631b42d75a2b6d405e5830d0c9c64ab1de3830925f340233891045d1791ddb6fd47d9ab8bdb35813818a46098428004754e90d75086a39ee398d33acd882439b65a2d2fd786582a060b2aa16a704c3592eba572ba9b491309f59982dc95d644c6fe492f9b7d1df424b2aef3fbe23c5065a88e8a848f472191b8d004188c6d4c75883606662aa00801d141f9352fd98540b3496c511d9d2a952618e0e7bf9f9f291afc83d55fe83b47f6b2013679a2dd9940eab001dfda26d7ad098eeec1ccf80ad7c92a7433ab47e2f7d48588de680cdff4e43150be22932f15457e79c4a542979de46fa5cde9dc841f183da6d6c34c3c6c386f14042c090dcb3aa7e28475d1dbf760df95a666ce0e838029b8f7be28dbea0fbab0ea0b8c9100ab755ec5fea5d628b9c59bdd897bb5a313af67b96eb52e9566d6bf0621508db2f2f064ae1463fbf32b19462f07c6f2f213a","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
