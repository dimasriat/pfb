<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ae0f1680c889fa356948b442ac16096b92b25d7eae2f568fc84946e4a8a00a983765dacc9b81bbdb56ca23214a2c75ba633ebb4a246171280e6c658f1081ada3275180917d0a37f5854b862a984cde85e8101c50981f6d1dd9ad8e0615a575d0d253fcf2d20d9028b6a69efb5288a751cc259ead072631d2dae2387d3d19c31a56099da586bd296d2e2f8d2157eb3be7216c18974fbaf27d8eb63c2bdcddddffa885d16a37afa8a494dd05b47ce0665b6a1c5a50fe14574c2f85d6ef4ab1232a761cfa67ac9941fda7f3106ed07d221297109030423e1fddce42eb46b09364b26581415e5fe4a299206563c389967865bf5b25785fa49852e4ef5d4255a7ea6ae13e78086b213ef94941668b5deec1c24fdf73d51e81331a99e1d68949e33e2b5abd3da15baf4cb2e01242126ae7f87e928705aa519c285d91500d54a42eefb74a9082bcda95cbbe49481c246ac56b706e2cf980a2502fb327e3af8b9f5987fdee87dee441eca7c2e177b8ac25f7ff5ca583889ae0424fa2a2a8373999efbc538000ef9ecb11bdf924c12e3dec2b75f3fd08b72c38f2a4fe90e50d67d3934aefdf36b47377788ffb05731a75fb221b6bdd27fc21becc860c157edf59c25ff7aaec1d34a7a05ed59a6d655351ce3a69765e5693d2a2b2832d67fa0ac739e166acc0cc0bd662e86e213f468cec0e4076724ff8423a3134a08978ffb3988de59457805292c98180a9334ca6fff1a56635d403c34afcc6bab9be00a0951406868071bb76774f99a821f41f18ced53a348754910f1eac2ffef6f788063866a293a9b418dd569979f4aa0268755c544b96d7480612e79dc23238db19ac8ebf076e2ae6c92cf04d9e9a0adc8249f0fa8f7dd63b7814c358cc6649cc3447a9dff77fc7046ab554a3efabb21f945a543d868ae0955319582d172fa7ecd6a50dfae23e182bc14b4e7c3a4a27cf30e2a8854a87d34d9f9b1f0bb99261fab2149f69390e5bba74c295defb83440ceb21ad61ba4f9979d452730131cd49851fa59542056730fed251358a2cbd438d34012b869dbfd7696db94c4c8e43acba9b5d1b02bf81320720579e7c8895ff820f2e2f3ffaa12b6310e6f919ec8fe6576bf5770baa47f6134c5ec751a1abe31c2ac4f86405b047fd1ec403b716bec47f7a44630fabeaf2d92b94c660932f17ccb3695f901b91859e7d391f21302ecb78e45690bf951c8f0b1e4dea67bac22710729d158405b596bc54eddb21d3235d5168185bb0d23df662a82411546fece40f0bccd0c9178c3a2d6409df694651bd3410da17ef935f2ad0ce098becd9f965b8c53f1c6c09a92591ddf0bcb47bf5b0f52ad50d2150bc88f82bd2bd50efe4a4f0e081a68d607ecf428146670d71ce58b5ec0faa7e05a77361d756bc2183c5432389a863f40713c383f74c19d34d37fc4013634795f7b684c57b2a3063976925f1068e4fce909144ad8bd71cfde61d32ea6fc07168001816edbd43b950d9c1c2dd402b980e4b7ef34ba59ed8faa0e21a69dedea6adfc84eef3bff93a9ed22ed3fdd0f05fc2c08b630ea2153d012d3bb233dac4be83ddef98b8d34937d48405a26c8e05ad088266ff020e50fcdb656f1a40bb2f8e0595eb5410ff694de7e8f6a8b32c5a13f8c2f79d34f0723629204f49338da2978c07c9901eed0826d77b08267e5f13816892b9cf77134ef7647016443bef369cae408cbcb125479987b64b9b8daf8996e50c62fc987175837f43924c46b4224f59a81c9d0fb3a8188386b97b00346de271b31860d34d386f3b15d2b1081e80adc23692f3c4254cb43bf185096e0fb7b4ce5238f07b0f3e70bcc6f7e21ad670d30c4a5f96de9cadea9e88b27d70f715f35d72d352a9841af65bb0254ae833fc32ae934734484f7329bb12c1334cf9682e884cfbceb64e7bdf1f9b603225e78a9984f0f466e04c9860ca1dae5d75e4d7254dee87199be842de684d955095a49d312deea50e0a24352b6f430a3d905365ad5cb4e241568d1cb95328d8b72eeee73ec0f3256dafd7a931c9c428cf3d3dc97e547fcfa06b93775984bffc7cb49b3e32401b8a8e119c244e860677636f34a3184217a36823225d46137e5189185836d3d954e607bf3b442354d0d8193c1a6b78813dbeada6fd8b8b5cd5e14a4e4b523e047d4aee098c7317586224d2d752fb75ccc76bc4140f1b6613067f08baa9d3785d0229b4e99c5e7d8e4e694f31fdb7249e8b5895f31a664ceb46042521435583bb80f58086ce70fdb8c94c1939a48a1c4fd2c22ac68239a74e429c50a4efdfa9a777e94a3ed8f251f1af206bad58e700160234d5e556502b5364663cf20701f2234bcb76a7dad3eddebceabd7e3237b823851e3678631b8f4926b43613f985c31e8db5a6711dca005bfc271ba4337994f7067078eaba2434ba42c8d0974e6941d12cd74ffedcbcf38893ee51c2eadb6752c91aa1f3d2fc0765447a7533b37c9233403843950911afad5cdd8eb8bcf69ecb663088a58202e9fcea5bf15b605b71a7a6edc8b2161c5e538d1ec3ada2b0e39967d2e5b8d82e927d47b73c1249db173ea2627618ec16530cf6c45a4a67923e35810a9b896b0e887c74800e7b18b191392ff4eff14ee1a6026590c78b38fe9cb5118cacabc6b23134331e031fc483dd5ad29ad87a161b95860b43ef4a147c2385d386c2359a514d9dc1bac19ba8df84bff949f0bf97bae23e810d7b3cbfe5e7b41a3d32a9d02a6b6e346d76e0b6d393d91c5481c1591ec65ee2cb84583efcd96e9c9c7706aa3f96e9b36614168ba05a475c759c5bef2766e8e7d59c9c259f55ef194658cedd5c563f9cc4f74bdfacbc1ce7715a6899d7c0a2d2b5e97445d0de995bef829453994a6dbea43c67fce66ad49ef07e759f378df8cdd645e5f5d7129b5a7d46c9d0c5ca06d2cbbd4b42c8ee425c7b512c21d4196951e1ad81d1057989d7ba643d30a6bae422dd3b98e26371381cf9978bf6a72c0b38ddbddff050944f893f2ed1a05234918069fb707a22e6dc1078e6c76dc4a20c8e419b452b0da1531ce13e5185bc3b66d64a6547124ae33af2d8c5cadd02de1c2974bbc95f8d0aa3c3b9368b34c2c8609e097e25c7d815cc1d4fbef9387900de086fe1f5b57bce94056d26d95393db426ed6f533c626179574b710e043fbbb235b7720e8cb281b91c325b9b913c4f8c5327381f176f72f2fa2b410970257015528609479163f8ae6bffa441023537a9035e273235cdec1169b38fc57d521937a39b0e4070874f31212ad51de14aa835c3b243351b148a095ab805bc4b5ac81d52388bc5fec84f31ef94c42de1c9cb5230ce5b889e3f60ad40dfe5cf2a7bc52022d09b08f5ff3fa5cfe41c59246e44aa16f0cd31d03a4b1c4cddcfdfcdffed1355629be4950e1843c5fb2fb3dfcc79975a31323e51850ef58e8bae0f93d69e3098d7b74828c15c8fdfa166e3e81f375064cd0b3381f637b3d4a38837cb0a35d2eef6c2275d6154122a7b457bd63bef1634597edb2bef52a3628f2235b302861bdcb09f5c4fb06a3d2a7b16edf09231fda0c8d3e25037ef0aae37ecd094144b49d686d691996ba8a4e32ef2195d1b02fb1a058d904ffa741eecf0d304bf4f01ce1cdddae7633f70e2b97cd0a280606a87b9dddae9e62f8dbec5285fe8599a1193577bad96ee02986c3d8bf288c91bc6f62926e37c9c965b26d7509a783ab2c67a2a979740a85962e69ab0e0b501af29e53cb50941beb87602f945f344c3e3972881bbc5e30ece5ccb15f03d7cf4bda3b139afb0990bf5d6035dd675c19d3a23b2086a1e3dd05e8567b9cdd358e96bc1bf0dcf1f2860686d3e104d49a9a104e5f4ce45c72bb0d88fdfb07502505eecd5da9f40c0a4ad5b58eeee40335ef4132997a16d0f72cae2785b2b92ff951c3180f228259c8c0b5618838aecb2f508e1c96c7e76e8358b33a7a466cd6dab68c16ec38bb1965289c7ff121d84c5c7fe2d186a00779cfa07d4d0e98e56bdea640a50cd57032118be3f7c5b86d1bac8eb54acf74c7740badb510fac23c650d4f332c64108125423c4df91479383fb8d1f0cab27fcbdc099de92e265cd0abc5d81b88c354d3763fba218d6b0c4e46023488b8892d0b7dbdd82f7795e2cf309b8d736195b06a80d2b9cb320e29f0a3e711c8ac78dad48a52da2002437475df564ecc46c737bb664b9a600ba179362c80e5494ca1c2d8fa4bc6f6b1ee1900c695dcf2244a0b0f392a6f1ce763c37f86b0ea275704c30eef348db4850370d9ff77f1641e01ec6a0f6d997a39fb3706afc6962c23bbb63e72bc411f5724463b2559353405340e54c40eaeabf96b1fe44d1fea692b86d82fa4dd892a50e6acd7c1de57544145efc65a11678a0227ddebca984429d8ee8341c1f49b93fdc404685f582da9a2dd77bc81db5d443ba3b97d870a658712bfccce1b647e39fd29b830824aa79732063557d70bb6f7064bbdfda8f2c5ed91fc42601c113cc58e22a004afda9f06512f89d9f44718db8befae964e25c9370ee3746b690bed40ad7f326be0cb9fb3acf6189c05cfc90f5fa3065a1dba376727385025904396e2ecc8d03ef7d086a6ea48959c7e6491af4cd73068d6d1b071933841ddd818663f4b0c6c09a233de67b9cdfc852da7f6fe33a4e43d4a1163c0c7189b8594b38da3b23ea18144c9f586f1381c5c483d91ccbea8ed1be43b1b6506a46274f6187509ea12936b8adc3929f39f67117ed850e6a8a120e8fd3f1570f587abe5b1140287267b31ecf2854d61b655ba1ec6dbacd372f19aa5238acd86f9a6f69f396f3f06b4b4362c4aec8d03bcc2aaeb39e5c078ec3ffcfdc00cefb90bf8ad7f414337d4d5106df172094fbe339869ac7206453ee2a84f18e987fd94ed341a4184f40e864e6c603a2f1352750edb9c01c7a8df0a85c55ef6f62faa9880391ac091dd5d119c9d566b4b985a818622cc9eadb3ecf1e4ec6471b806fb125d3959bbbeb43b5f9b01220d36ac2720d279b860e891a1de444fb9671d2861e9aad4f720b81f3769be2926f54e35a364a3e08a60e8b87016672c0dd711026ef4456f72568e4b0c3e8550fafa1680c7ffe2894bd93e4cd932f648bfb118e9127852c356974f26e030e1a75bbfeb152d8d86372eaa91927a61447d8b9d56d3cd2bdded4bf7bcc783211617875015d0ff0807c3ae0f5bc48839cbc45e5be38f95a716653bc3cfe89f9f35e70f8d33271492320fd9486ebfb02d01f36265f4912c82e6be072520215c93e5fae12dd8e2edd4fccdbe3ab18830bdb466229a5155c09c74b37e6c0e0aef4ee17b3514aa9806da29bd99125efdd6d496c87565080b4b45394061c4340efcdb66fc1207cf5ae9c14b320b9a5145ddf7e1929ce958868cc7279329b0cb74bb3ba02e6cb26e54ecf49c3696a12dde99d8e92ce4392fc2a0864830ac1287fd64ec98bc4364d5ff802efe06ad977fca7cfb9ef972079a3d9002a0a3b2fa5a8175cab15bfb950d1a8b5a547989dc07a8a39fac80271cd92fe74088d4cf05a90588f7a489ff81054f041e01f9b09771dc636c460ea8e9d02ac437e6601cb22b527ccbb1b2ad8afddfe9dfb987082d87570161ab2f10ea4cfa6f698e8d87a29a1f0cac833465b30537065931979c2d153052d953ed6da87dc08a680c41d1dd2edebe14a4cbb6c4628657f174fac6fc01568998f708a57cc3fe49d16b550f1dda3bde53c3ae236363e6a79d6bf6ec339cdd9fc88e9b7a04863429121ea0afa92787981fed3ed00d636faa20826b20c93253b6f39199ead8ff628ab950c7cebeb201d75b245897018ff25dc940536c4b8dc0c303271c42cc9a3c559ba62087b1f25faac8814dd3a7e727a65839f6c6db91aec608432bd03e37d75b22eb53a45d388c8cc14204670104fe46a5aa55e347baa80085f1c1a1fb2a27a65e34a92cd4bc449c807969949d6a6a1d3d7d9fa7e96278e884b3610a615f3741b1da8811abf370a3c44bab6847314a040e8c5e03f097beab72954cdfcd9a48223dc7a09938cd7c3d5de45946865c418772f8660fe162497902e6ec7d65fa934af9d10db6fb9c49f72a32f2a843ef2838b2f74b02f1a66fd32459e57b4490c4b8c6b11abca902acb65ca67efda835d4edeb10bf9874f2307660275068d42723824b50bf4a9e60409483cb095e3fe718bc1a818131cf4c94e4883806599acdd3b33e01616df2b782f74e98591f55dc91d025f8830e7c10395fa1c8eecf8892fe165ecfaab5768ad07a00122df4f3ab5229581fb5c1e7dc122b31c9a1f227656118e3de78dfd337f6eead0311eeb265e562f7eeeacc65798a2f4fa6f0de678469be08a3e4080d55e56633f4e3b629f8426148e53ba9ddf08fb186aa89ed5965613e6e78c650252a049be5fd891c0d6590d65befc4978023fa89b2c44694b5e84a9a54604ca3fb6ae28248ca3723eced54c88cf5b03f475e3c4d6ac8051c2b6c8831cf396f3ab014de92b7aed453b98499322e4a3ac08223017abf9660a13bf7fe3a570a8bbb37bd1c3d8670e2c0c0bb9b83293bc366dd58dd1248877aa5f1d38e0c82aab55c06b6ad65914c59a86574d907a1d3f362893667d31a6d66ba401460d57c107cd39bf474adcfb86fb7b21d53d24a45cb9f0641ba829b3fd4a4c68007f8706c9eb15e9eac9cc9e161d744a4a17462685810662a440f601f8ff51bdd15b259c7c1471fe9a2998abcabdb18b41a051a37df1c0f1dc740ddfb1b22ea58f37489011e4ea7550b6b58ff3d992c5e16f0961bc1af3ec6e742fd2178837e9e6ead24a7895da5b8a84242f2e34d595dcebb42fc6da0b99bfbd255806f37478229f202f47da5a586db370eba7c53fdd32a14a504d24ee0c378528238fcbd170745ebdc8d2242e058505d5279f7c892214fe229b4d46238ef54b68ba89a47b0d8252b4f2f9249190b505fc3e3abdbfd53e241eecdd6a1c14f7a16b4dd8c3459deacd7d9d03c797cf44debc8c2bbfdeb26306642d9d5a9009a99b7d48852f59c9901deb26c9a4f060871e338141a80a2b95c5923ab5d5b1b0c6eaad1fbfc5494ea217c930d16e5d0a2fe9aadc159ad12cd9101422cd30600540c31ce2d4da78a299c5ea9fa295b80d916e0e0f6b538ad19bed8df89e82c231ec7352a0ce138dd04e5449bb55ef84d042b6628ecb99262259baaeab801758dc5ca301608d12440e9e53e94e5fccc9a3bc359fd5938f5d53224105a772f19c29f1998254c6541c6b32828d29f6e134f49bb562f1ae4c2c36d66f00f67bab22850522483640219c8d7a6523f185cffce9af82fbc87e71bfe9fd093e41ec321b674c06e204a8bd9a491cf1fbab182c7631b178fb2674b8b3a2e9ec61e94ac60e5a8c7aef3351cd20b3769c4bc90f433e7f5f020f4f40bb78d48805edcd55762b587f597fdf06d93a2e44c8d59b2e7e8bea506a07da869c53b5690ac54c34212476c8569882ef3086b59c7309fd13ba01aa542a5c20445ec4b0bfea4c15328ef60c033c92f7b08a365a339c390e2fab4194a0c0ab235680f9148d491393abe710d328ced83560fe60620e427570701fcfd44a5bf236f8ba5eb20b5a25084d1e601ef30320dcbc37f2b0590c1f3eadff76980e3fc6fddb6d65d4fe2f15ac9b660d336a0db4e3c185cc4ff6b0403f7f18383d02cf678d0c8d106b946ebe9ae86740fcaafc9f2eff5789e9d8d3ddedf251457b7ee67303d149d48ba75e15d5f95705a835799a3c9385f58a31cf8114926a484dcd3fb732631aaca3399c1a5403470cbefd84ddee6e0e5f66d196b97a6ba507601e080c9bc0a598f18ae00e5a3c5e120453a1b6fce69340f92f94e8a903c73093d8cb41ec21aae04728aae8c6462afebe8d6edab7f8c1f2f32f3f7ea2b86de9aa947a66b46e19205713d4284a358f595ef7739d4110940ad44df54a91ec2541cd0741e791cb69d16a6359e8a40110919357b1bc4571a68be36d329aa9518d9dc4a23017f2bd8d8608b27acfa9c3b73b30c4eff7dc900b730e5994c670c2f9380589bfc407bb8984ae630df311924baa1b853615bd079e1b3db1a3738a17e9fe855772d4466ac7efce3bd75fb67b58df40d410db3edff3fbbcefea2c061f43842235c9617c15943739b77863fe653ee3c9363e6500bd7b0d71591e3535c16a7a5956153bba65f5ab75d698830bd2082face0848026c7dab3d6d965f9ca5c291f7548fe3cedbeb9cdca65ad7acebe7f5680751bfd591a29ab6dfc3a26ec657d009de6a744ab010c34651026d523da564aa8d8a8dfa4d844584759046eeaf59591a8813a6f1badd5f4c0694dc4ef4ee71a067393605d0b53240b52568cbf7c96b1f5cc8075a036361b8cbd11d2a641917f7db4ed6ef1085fa483c348e0938916cdd5b1495a28f4410b5ac8903a0f7b11d2c4dec2d2a948b5dacaa9afcc6109d3158ed1faf6f022d4e4a055a3e1bc85c2aa7ff22cddd1192610b0c2c4b166010720d8cb6882087e0390fd1bf0c8c6b85403d595d6d3ffe87df92e2aa22c9983fdd622a1862f21c254f9b8150c64ffcbefdc39f8513073dc3aee35747afb2e04400f744143e1a94ed13babdf973a22650e7c2212264e9533beb1621553e65ca224ef264287f8aaf9ffedc9729bd604d30ed8eabc643d5e6737d750e90af58a9f4078b453b365963d49fb7d6e8be08a856c25ccb22b91ff88f46e19c0c8b959eed12faceb441f5935a37770460c8f21410ffefae9f235bb48883d4f293039e9fb73df123366ae04860d7c621d5c883154c045b4323c9078e56756c1b9728a097d17aa7f8f13a49364321958ec6ce58d626aad20473bdf4c5bfc409cb9b67ba230610e6c9cf7ce1890b761b627e77a7ee366dfd577f2dde8808c8942c64c268b002437f6e0fd53b0fc746991c58498b26a4d3d7805e556d69c84929842ff671b7374fd28f9febec73ede35d30444f99af52921ddcc0b8e4e1a810914229e84cf8e5c72b969c00370b1330f86471350edb8dcfe593b5664f874e94957cd8735b085e8cea7869289a6c259cd4b26494ee02e7839d2e5f1b165230f81e99a50164d1ebb8f48d092dcda7c31539c272841d25b04564147c6a6606137cbef1dfb6b5cf134928e7633ffa6419eb098618522c81b5033d662cd79bfab3415ba3c399c54c0e3f47e7fccd3567e251def92f7a27e55269cf88236afb0687308196c6012fcd3789cec7ef8a2b66ac37b7fd24d0919ea99774937b5edfc4464c68bf5cc18cd7f4e3964dfdfa9591dc6cdfd8fcca7d7a5244cb7edfc7e3bcdd972cae67c665f771dd233bd8d4d048bb04b58b1d6be197994dc4214fd47446e718201e9fcd62630010659304c3cdf6bac9cee33bc1c040a9528381bc09eab97dc5d6bb3e8101e6d60b99113d2e42223127f06da2e7f016f7c54f9332e693bbaf9ca2e5a17dd8ef85790b7ce6a06fe360a3d62bf6b8185b753381dfa17232a34d7e8cc8972bd140a95bb01fa4461fcd030e8f8d2da2a1ab1dc6def2411b7f11bd745c799a0b4d49586a3daa103a5e756090bdf8ce24703e36d833c5593a7f325af56b17b16665358a70c51a4af999dfb1517e22cae077ed40ac6cc84da93a69f96254fb81a1c37900e5b7f80a6fd57a186dbffcc438eafd6f038eb794d2027ebddc5fab867e1d0b62179d65b31e2e1248a82c07ec25d54a4f7923e5b65084b70d21ef2e1216f9cadb0650a77593a6f818c45acf7c28360ef2e1e1765d364e231198cd4c4699ec5b7dfc2833efb2cf337c3ebf396da2c461ceffecf9a6163cac2ae97c6143f434d3a5bf2cfca2e2bd841c9fba6187fbaeb73b36802ef020ce2af4bd70900ea195524414517c3c55bd745b3598181bb33e814b0025550b1ba75189377b70e936d1be5f734da76eb3a0b75171c1c9eaf875d2f2474be962dc76236293319eda0b2477ec4e41e44576e61512f1d1f3b733c8aa88584baf8a53087ea3a0aac7cd2e5aaf15f6091e54d080b23d23329706846cc60858b61b92747a82626265fa9106e6c158eb7f52f9db5e0d0848e2821fa78f15b504e5a008f59849aee6c8f5299a9e0c6036af197a84e1cf5ce9aa4a1f1d511995f0dc190d165d1e7d79e25c728fda05a73a32ed377381f0e9144941b03b0b8fc6b528a81d63eb1aa4e1fd350bcbef56e225e29c28bb85460a06a7cae2c69451f7bfe4c947a7bdb9bbd5a3dbf0bc1010b4f06f893b106cd587e0064b3694f0515f53ecc56379ec48ceb16b2a2fdaa8a7a7b5039dde805bdb41af9ce9e20e9af33df28de56742ee2a808b8fa656ac916deefde16642363baff6d8648a8783e7ce65d834ea5c4cd1cbbd58983c276aa9ab8c68a167583d0e133fe0ced010d231de17c03f918478c800ae2ae0f9ce96d498f86689568e2ac4f30b26da1233e76b0965b467bac1a839b1b2b98c9f7222dbfab6b814dc420f1c1047c4c02cb8872e4d0399f4efbce81431d2230ed35b6094c7e0f68440f7bbbe9afb3e6433c183ae60472cc5d5a40fdebb809f92cc3abc5e9c48c6605cf71b569ff978ee39508a0b2dd74cb1aa6c9394a02b4f0633c9fa50abeeecb2f3c3d7eb0d98114c6740a8b27ed5fe23be517ade64642da3bacefc6c7036035cf2495037ced5fb4dd61a8ddde93a7ffb5aa1571e2bc040f2faea64e9d35b100de4a82051a57dfb5e4ec7a7b2742833d42aace862b087cd642ff03a6f41649022799b02831c084405a67cc0aea9476dd65bc02d11f76360de9acc92a374f96c4b619f28f970aafdc517a7d862004e258d2f96075b7cd5e84cb025336155248c21cd430ddc82367b1e74e7bc460c1012d3c5830724aef4b1910bd78cf02bab3a5e489c61eb605e239e15c91ab0d94e4d381612a7329fa4a3b7ea0f99c3d573951a4e197f21bac792631e36312b506381971b377c38a46c59375e06726ca5800bc3b2edab64c9941eb25ad917d69fe2fb6f738361dcb07e287cdf8f4f22c55bf9866ae809dd13efbea79a956b21d9d593f8c17ca343b938598e4a9d9b5561492d7c33cd3d57bd9ee16f2e94344bd1f9e3df225b526c6821a0fa8c045afc97b4585dfee0d3c71d4f82f99760b18eb865e2e23164a71a269dbf8e2fd6730dc744d4df382d7dad5c6215faaf2fa188fd547686afea802fb24caef95da378e7467ef5676c333a37b0b527157d5315e158957cafa270ae75511be5ecbe4e2603eab78bc43be6abae665c9e5675621b197afc15532d02db2ef635f2309bf2b32c4c6145293b4cd6aa6c3b2ee9f7eee96d98ef176cad65932a9f827094f3b7de947ed7b8cf07cd21282086fe5c60a20f22345ff45ce61d2fa506c1b01bd95b5811a32e166db1e11db9ed57621888631c93c0eae4d69e437ddef1ae4a6d8fbcf5eb7b7c5d2e83389d1c6a4839aa7c63cee62fae9ac61e7288900979e7517f2d54ddd69a74c3abff60ba2c103c1703c43766536d8bf81404a8ffd5a52a73980f4ebb6415302f630da29cbbacadbc9f9194480fd2602b65c6c15eb3a50170b90bda819e9e24af424e4b71b4c4378e673e99cdce5c605e8b361f748c87e88aca1cb8ccc8ca56afff938465cfdf2410ba65c4ea3d1187bdfad5847a8dc0e989a2122336bfdfb5f77cc4725a2fd5e712ab81b8d25d42a41dbed8eb21ade0b6d92a7c223469a784a548196a1fa0325c33cd44ecbb00a1b9a5ba8bcaa631e4fdf625e7c1720c6495899ba564d6891b383dfd355fdeff4d21d924c91bcf3548c5e07205c1798330b90ffaeed6838951d36d1f1ce7a30f38908eb3cc7d19366566f21f1c7f7f10e68f7ebab26233c23eb2bb2517d72bece9696917b516ed06d1d1103a435fca6ca4f53099cd5d8559eee6632a29bc965e4d09666cb241932108799be19a02785f3559536a6256bb00e4b54cd0a2c36df2d8c75faf0a5fab06d7579d00f1cc7214a7e2f2474ff0db2ab60f1bf504654c37f12f4c6c98c7ef7230caf10444ab43ed7fdaac67d39560553c95ddb7e7a401e2ffdb00033f3aa8aa8dfc22c6e1a4a97f0d61ea098fa452e41fea9352cfde7a7ee6319a83c2a0c26525de1e5e1421f3ab50e19149db8c00654290ebe1b25cfc40228fbed3ad880f6717d98e40bdadf51edf188d9a9e85ba92fbc8efc3d0ca31f721db2a521549dc2b3ad6c0938f176f9ad4fec697776fa0d0e29a89ed21025ee2207b952160ea3a3db6d150c9298d29d0896dbfb7d8b17a653e45a8155fb99bac94da976282d2eeed331f3e379bffadcfeb7ed70a4f373e11b3dfff1651776bcd32194142c85878ebf915004c257","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
