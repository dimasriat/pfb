<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a94a0932bef9abd582d5a122c7d5692b6bb93bd5134a23882a1a09349b81561afe33c20762d4b329c0828e81362b87f53cb54b88919f32d79ff67929d091bba025ec91ab19d9c06153446163cbac6a19d5a1a3a3f0ccc14364a9d5e616581b410a2b392eae123ad78ea65bff97c857949ca9d609249e11fab286ee08e3bd7264f67bb79fe1334b7057ab3231124954663e4707e4dad2a24d8c4dd0de0b705e53e9cc959a1365462baa56acfab0b92deb368d0050d3ec238efd263a545408271b985210b0de5e0af9064bbd184ce000fa78dfb9ed2dcb6a48d9cc4a46aa9f15104beba0de78ae5b47ea32681eb21619fb86587e9cfdd61ce45319dd1432984c2c8102cd3d06aceb086e3cb1f0b76c4730db92ddf193f352c03caf2194fa4c6440215d3f844022f97df545e2e554c55017344316d5124dfd6d645ce95499ef0a40f4663dd655d90ce39109716367eb043306dd95900d322190e3b2c3c5a64e0f234bedb1bc63598affbd3f78b18e4e493d5db9baee74f857b088c8489823d851083ab85e6b2e5b72873cfec7a10007b582de72c428f428a29cab4e0e044b0b4c1c15b93bafe9f18777c80dacc54b5f13167fca7454e0e8c59269d16eb115ab5b9e8c306a0add85fece39917dc9b9989d4c8b68a8acff48680b050d4d10eaa5430354fa093e54d5218aee6772351dc1b0e73099baa273ddb717d93bebf132c55b28ee97d538d45fbf0619d7e6b2fbbdca4654a6b0613ae3b61fe10b048bfe227e8c1540ead09497a5eee8a5d322bdc8d373949010044382db84212fb302710bc5bdb95abffde755f8c9e25fa9a5cdfb9fa781dfb4386910989282df965ce62152eb0b3d171af5230f6a7566b4469d459e2ab78beed5c96e30ac946491188e5f83b077eb4d4304fbcaa1ba1c7cf9c399216e3c9a8a140512be5e0636508db488711a05fd6cfc732567222c7e0890f78ae4a63230325baea5aaa165c41f485f9fae0ce3775f8455e9d0d86b6b38363f90db5073949aecb55ce12b1e239d9e788af8612c5613afd2d6c300291d76be48ee5f92ecbd9155a1fdbce017e57a7b6d4e216571aa939332bfc4c954737db8568c827bdffea8e711da2ebab030f87427e719aab77564ed3626e864decf5b4247d5e508a96f84e483d709c2097f71ca0d216eda6b99becb9a3652b1c9198cebadc91e7589ae302326ac15d15a60a5d76f658659ceaa3eae418561925d15fae8439f3a7db787cf8959169ee35f83443dc8702d2859d99b021d8aefa080e82b216f266cb7c4637506fe2f47e3712e6b7c2243042bb1f2e7130cb51aca402cefb2d3fdbac78767c90e15cfddaad05f98da0ad7b162f21bf978217b4d41c02732ad82136d7a82548c03496c84d8ad02b23d7b2a6c144fd9d5f6e87bc8c66ebbcc964ae752217329daa5339f12a3b34de34785912b4577e338577c7167df59e614a2eeaa652a1cde48d3ae3f6e798e4ef3687d46ea093e04a521d2f29c2313f3948945b476d77d0af945a770659b24f7c1048a8843efd8ebf4ba37562186c54ad097bf0c3f408d2e52e0428a5901dce8bd141bb6f4ad674cf3fb5449cb51af665b0258cc208f9d0715a4a22c4546045b24f136db38eed0c58fd352481298e8c25ed25ac02e4596d170524667715740370de2deb4bc020fdedcd4f7560ea125bd054c8a21968931dddb0dae8b4724a742393bb2dbb8860d76e425088a9bb677adeb167fc5a52dc2cf0d007116fa5a67a6bc8976d538db86fba0bb6702f1c8a3512348776c215e74ccd0144f59d983a1e9f85efe6e0730db45803da5789ad4c3189f1e91fcd71baece96cc1a6efe67b51fb2803b4f59863a3bb9e615b9a1366b9a593370eff7576675abe9065d761bfa306c939a240419b17b5dff722c7a4494bed4c8c33aca15201f75a328865ecf1a5c5c8845abf2f8210ef1816d40eff3fd9fba18758aa4e9a3f9838de60a0d6605c907088aef6253c58176430d62a8aebd7a1a4842fd08dd8ec0bf0786bfe16b1480ebeabf19239755382dd79d435031993d6ad3796dde3e0f23249a269af0939ceec0c17dc38e091f719333356516bfa4562f9bd81078475a25844652d7169100e10c5e52153d8363ca48e89a54f82b4f0492e643c08fc6426734997d5d5c26ddcda966a4d184e0ef7f39533323ab7a5a7c1dde3383d18c4b84349da2858309ecb050d6c3c4fcb2d944e24f939d9d5180c9856e9d2960d751dd40753f3d879d858b1689a09c7e1536957e8edbc47bbf758bc118c22d9d1feaf150ec3284049b7771127a92a0c08c86c49926610a24ad1f7b405228b3ce901a5d9c8fd275e4e5f1ed67507ecead2fd40769f1ed98457d3064d29a29663595fdf699064bc57210d0effd4a50ff96f8c535344f22cd10be01437f5582d424b77528ae0cb83f29be98861509fd60cee0497f4d8b08818b1bcc16f2a402df9816b3030587d772ec6354d2f9922365cb38e71b505c74ad4189b8e9671cde127dd500f29da9410ad64127e14eb3a0ace897f7a5e756ab04059b8cb339ecfb25e3e8cd8d0caabc312a7791d4e8f0cc2334aae6ebdb4f7823687bd3eeb7d6ab0757e87aff2fba75b5b5e3b9024d8c83d02f0ee353bbba1466d7102b7b3077702bfff2ce37796fdb89cd56f198ce6a458cfad42d9ef3d90ab3ce2ccb6caa33b3ff6b7dd80bec5d9cb4f5d920a25275512e60111906a31a17f1f128f0a1ef72b6535f1e6ed28cbb5151f33fdf39832ed6d2d53d329c7180b4bef73c1ff282065e4a9659c018133a472f15c8a1bb97f4dbff7242cd3f5714c3dd191f32080e7de6946aed078e3f7e0701f3ae1c9c2a0e6e66aea134c3920cdffe46189936438069859054ce5a1877442ee3716e5388b1ed375d6af3980fdc22471be19e36b9a3966df316937d0d476bc5903050cf9cbd369c66f348861e6ba8f61685c5bdd890ffbe798d0401a90aa546dbf34df81d1f2ef5b0d5247c0d516c2fe87ba09ba09829f086993c9933b95ff41c31773ad1d1daace486c1b2499a81d8518792dceb0bc04d121f5c76c85fc96482e952cd7bd15e62ba749d9739292f185406dba5912f23b2fc26043e03ef0a8e04704b401c510ffa4cd7cb2ab82366ea828ecc27f19c4f4af3ab7ed3dbed6c287426ff1b53042ed6bbf2b213c45b653be5cbe1307d3cc6758e790cd9d18f7d8c8d7e36e6f897b4f5b5b7ea1f87a146f7316290e68479ce283eb87e6cc873f029bff8290826c1c4f53b2701e9bed7d4f53c885f192a32c6822215b1b7b84d04b300e108760ded795d0be0288eb09109d07f94d7e14ccfd9dc65b9f01ef9f4961f32109646158e8e115b0a3b6b1a251efc61264d98bfef4a1287b23d56b60d275320e3a57162febaf0e965ff273a95c1f632278ac18655b23f569c8f8c8711670315af539a3284b3c81fba5a50d34fb5f983cac0fb50015bbe988034603c096abd39dad8fcab690e311f35da4f15d5d6064c77fd8dd52af8be353c67a8c1a376c4aac728878e75507dbba221b58916f7cb19019f45b25c1019ab39501a179978eea749c2b7a13e0a4579cf847c345d9dbe4cc4fa8d0d119d561839f28a33e9b58c39bc03bf15dffefe63f1c53be6d6039749a7fc7671cccf73fe849f43280c880ed229ff76943811792be8f64920ea410282a642395d680e520014e6822e5bdf4c6b863b72e1caec6d1920a406c130351f5fd5f3fbc7af003373357c95b7cce53bfe907bc70d5f8968b1f2c9e477bc02baa62f287aa98f39a80c9bc6e2026dd3e0d787110a99394679e1ec1bf1cb3acbad2d8d388d0630d04017e06abe7ad27cb45d2673a93aa6f4415e80f668fcc808396ff72d8c70ba8b7ccfded7e4f6404c3df2854e5ba41ac7cfd0af7a654cd325ba24d2e220045676630b004f5269bdd3c9cfeecb4bfecf189797c429e783d9408b7e60057a17cd0a1083bbc3ec818b681eb3892da00b607e406942c173677c8aee5693b486dadef57594bab2cd4831508293361fc0fd3f40536c1fef419452f87c43f13f2412cfafdf5a096781d4399d1d638cf3b449e936e3798e41a647ff4b040a412831a2ce340b89605094ed8a8b649238df8806d4037c5963c57739fc8f706276fdccdc429d9a2f303f6a54d138bf37d4cb0f258c27e4671f37f985148fe9bbb1c003083ef52251287d526d9c94d42aa0e47bcae9bfcdd864a7681935ffdd534db225efd1849094084ffed83564a8e3c7693cb93457ff3665e4c5f5fe942ac2b0f2a74159f82f8519d4a68e88ea2d7e37dd29b9f7a4aa2bf1b4eb6074480f7ac557d18d0b1b593f54a6f2ad65f3e5f6d5a6af1ab3dfe6d9282cd092363200a08f4505f21d2962b224880b667bd8e1f8298485c228d4c988f7d4c1eaf809a3aace906cdb98c803a7285dba21e0b89c49a4e755594fd86b1f44dc61dc2d55755fd4d8872361fa2b6cdc6f594b1daa173e0058df96cec083490b280c775780570171dcad457b8b0bf47050836ea3613ffd40254c462438049c796c20d763727ddaa69d34c98015e236d91b5202092538b1f8c95b2cda0af0166a743835333b85d117a18123650e3cc34acd42f633c0a8b50e64b3740f7e1431d0f646f64919ee0b425bbe47f813c14eba9094aab278ad8bc5846134ab330fa9a0bfb7bc0c07e095bc6b0524e3963d8a26304964db3d0d70d868e03aa9c2ac2f428c801ab9364dcd43d513a77fc9bf3a72a347abe31a7480b852078d3ffff5795482389cfc2621c8f82912c743745bff9d219a6f584fed291bf97894c6f069fcd8d02473cf43372b1c0bc31959fcc32b561c37efa905fa31df2afc787eb1e3ad06791ed4b6188a05dd9498f077f1bfeb2a1f45e51053be1d7cdc0d8538d4f62f01418328d4ef9376883ad57dcf068741efc3395bfec664ec4c3abd433e97a18f408386b3c6576bce68e8e1088ca2d66956008dcc62c5a6a1e510c90f37eb741443e6adb75734f2936ed4d0cacfe112456636e0b12d1f33f4c24f6079b23daf9996b2490034f2730acfe26061e45d2dfc1f689b0199fc7a1a9a5bcd26749c10265bb46deec8def04f4a5ffe8dfb9066deb8934070c6f597793125f49755666ad0d25aee22b709a4679c5ad9876fe3a9741f608d1c86648381a35927fa9c0b492d17dddca1c3db62bb820ed954bcd7a96916d230ec51d98546ee1c3303f2a4f9038f79451e109d660721d3e781bb922a02b8935d4d537ee2adaeebbc4d813c376d3ecbe670b3a5b8a8f672ff9caa1d7585d01544dba2c161bb52bbfcb4494b7c386a6bfaf72f33cb864f512d5e26337d45bcbaaa0582d55aa65193e60ac4dff6d9e174951136c95ec1629febf11df2d53246fdcb41ddd25f928965f26ac5d9dd73e21c1508cef384a4f1a24ff1f9f8695ed64fb14ee83766b244dfdb84f472feee24b63598c8a52eaea2eed24438a5e898ab1371ef955b5e94f4f7c46c11efd2a73d336e7c921b03c2d5719437712407d1b1be199a38c7c8813e13355fd692577bd7a2b57266f0cfe99a5ccb10285418e1e0689bec2f417215f8853cf7f9bfe2b1731cf7fd0ef47d58f831ba98f18147807fae5e4e89e1335b298d4883d83d8716b17b250c5f78213404f26ae9bd247c1e2dd2369a5e258e884494a9ef68e173bb1e01b7f8234d6367e235286d270469d454750e00db0a2139e707c8310947232a01aaadd4ae1b2e3a83410238c621cfbab5dc42f7d5d3be846ab4e35e2c6cbadd380e7130d220847bbd423d494fd0841c3d03b3cdd088117fc296b7446ddfffc961b431e959d03bbba2b92ae399f7905aa3948af2eb27817606674de15d820caf832afd16fce92b26947fc8bc1e194f9e46564920ab4e0c0c5e1804fbd989db07d19a1f5077c42abf482a0d85e5d32da0b90a955f39b2eb9c848ea60d2d5e1559e4c80172bbbba91a09e13069e380e8697b0510d1b2714322975b1adda06c40668d00d95e8063e7dbaac666de29f49c46882a0f0adb53073d0d43565d97990f65eb4b380c571ea569b0be0034e85c5a80b2f7ebb72f7d225746085d29d88d8b05b2ea33c31f5e82d3a46d478a958a929f467b82149d6234bc85b2ee83d89d6ed9aee81811a24c823a3132a89c4b389f800aca28f18816674be66552c264c76fd9418632537a4826599558c32651b5d3299d5828aa5c58f807ec43254ee48439b1eed5adc4f28482803923fcd33e55dd0be106524efb47816de0d9dc5d54b0e75ea621cd5d5d0e28b1749d2dacc2eeeaf7eeea6e77ff206147e7745867d61e46249e207076954cca920b822db4ebbbe3699b5901ac065cd81ae13af7306fedf8b01ca3f49fb8d18841adc5d19179ffa9d7c62ec6d39d06ee8e73d2672669f649d3236a41139a174d79e42c349e7ee0c93568c699a3c9d9dc6f7e728902cb1fb630b1de65a8ad4510306856aac48f75de197ce711824258ba2db34b78e84747355f38b73cafebac055f709ceec1bf18fbde3cc7279b70f2ea25a1f3273a36926f2aaa11d8e04b493db4e0b84497b779b56256b9aafb7c48a85fd2c9c8aada4d66732893907cb104eb1f3736b70ccdb0f5d9c2a5fe5df9f219e2f915a885756e2a6e8bbcd11f584b69fba94960aa89f36e95f3524f0827c374e279375ff5a4cd973dcc2504d5bcdfd66035c24578a1e5aefe0586db62671ad0767b67247babbff696eb0cdd4b29627efb4881e4b7d2d7b4bc5f067ff88fc09ff5b614ba42dec30bd046d659d6db260770e28e582ad4d116b3b457e06028df6db6d60caf8a3b0c725109834aeb51507269a421160d2bb99ae0672f8c0a8124f1a015da633a87dc23ba5dafb222ffbb072da3602c1c50c75e20b2fdee78b5b17199219f8f22af17cd63e08a22433813d2cccc0224bf3e545b6b51e3d1dde0ac2bf312f56b37ce1784d215bf3e645b4f721178901486e2ed1eaebdd844022bcce3c0f26424775e6660cdf6155870af3c27654ebfa13b9b1ae54c3ed9bb5562c53b1e0f465a58a48ba562e41c7b39c08671759a1afb3d1a8706f49c691bd96a29ea4e339a468cadef8eae5dbe165cfd6f2f5c0f6407cd34ec4726a434c03de9975f96c7b1de9676ac34f35e81a2d67f574bf1f0d977c65489765498335cd9f760afb4d336a0aabf1c5f998c0c528107e236191bb5c7e8157f9caaceacd9e432abac2e57a29ef68a0b5e470d1cd6438c868ad883a656002f9c0c564947059f7fa12f6d9e05bd8688286d9529401062b23566872dba4209e744488c07eb1a6c9fe3a76ffd2c038e08f6c5a931dc7feaa7135aae45caf8189455bd6474ce1378441c50439cf0724d35487d75b31267d261feb00d67c8ed0999a8543462ac9ea6521d502523e64540011eb5a85d3a48501f5ee451d6192a5924d7df0d2e4785a5dd80c8c8f334d4f65476e550a865be68bd6be6747122f55d4c539d8dacc7d22c6d1d805d5e5d8fb510bf7787db17f063c6e6ef4c8dc0615a32f7fbd7cf0f50b527d8422762d014f38a647d71c2fa82334398f277fc2eda18316dbdb1cf91089ce258e39016483d2f66f469da466190f06cec8a40c6b1377f11b6e46e24f5b1449dde076739d16e6672cfd4d94ec4c4d3c363f3660f48aaecda7a4df29db62eb3d200a8c6c8929f9a5a721196afa14ec93e7c551bb717d39e184dd2139f9a8cc2e8206b63ccfeff87845394d9e66f5f4b8a94d8ad548b9ef49d42d849c17c65adff64190f49b1e8ff7a0bc814b9e234b647f1abdecf3f79cacd3870cd7d0db6823caceb6fcd76c1802a7359309e398f176b0eea53e3fce24a07d0b95db1a07a301784277da972c16932c29a0916c761086ee82ccfa0aa0f3c13c7f37c70c88b2c94dc260128e597a40f36018cf847fc71a10abdc188e218136449dad3613a85f01418e387e75ab991e04acbf139c564a5aeeb53244195b3c02ecacd290ff936d06149ee262e912bd095ed4bdc53192a6285e7caaf19e579e46780d2a82c1f7730a207fda95255fec25f9c45b8abccbeb91625cd067afb7a4176003714701e4451d92f4934ec65ef8f81d13151d50a00104c920d53e1d53b272544749e84b209cb702ac6ebc1dfa6bfcc28fb36219538f6336d8904db55c7c95b104c10cea0356d2cd52dfc47ffe6341088b844058a7520da4224be0643d189bedc2745290ee3c5df0f4e3900b97588ac7bdf057b6d84e987db82374fdd9ca89b6181ee26f479ba4e9de651102153546cd25e79e0cce326c3befb000d9739d364131f69f2fe0e3678519e2cbd3a90a34be0d780a4169f822ec29cbca5860d8cfcd8cf6a90eb0284dd8db1f793a1ff4ce22d907923098032b6ddc8bea130f823c823ccdf3f1899a11508c9d53d9f9360023af04a3cf5140b58f1c7c610de5d7bd527533a4164eaca36025a9edd260046d7571ddc201f743a953b306cf3c577f070b98e93ab7063282bc7c1ac3d0cd4bd0441b163dda7e631a4bc8262c49cd44ce9379d73ff3bb9a2acd7db90cd8d953d9d60906cea7fae14301a5d7714bf7e84043b2eaf0c0a58661d76bc7a16a616728c70d05fca0296d4d8a5a00141ab3b68f8fdf6dcefaf47c5265f9df6a4d30969b51911148bf49fc348ca4bf9c85f7d9b79f1b0486486cdd000c0b5c49aa94e807658f026c06a019b75e0d1df240092c0d3d32ec7f009fc36f112ecdf2dfd647efd0d6683ab3ec1c3cfdebe7c473b111e46d854b2536070ba0c4c82203bfb6791ebd1104a16fa0f5847da220fb017e818294a71e21b4257a00fd1d23d7c1aa6e8fa2f5818e439a68fa7fcc770367df22e1175b9c6dbab9f1f7233d65bb0aeba938849d742caaa235172e7bdb3b1b6f76f256eb4d7aaf51aef1d2014ecd862be4802494cd9bdb176705e7262e6b928b7616ef46037164175dc760afff5a093f5cb9c42898db83e020f14d96ca193f4450646c92dfa902c0bd535b4b8d122d5c01494266339e57d7c48baf75a5fd11e1f23f051d9c9710f2be4d0fdd1407bf277959b925c272ed5245afbd4e0735bce539619dbb067714a70bc5e7d3bddc03f69eb24599f53d7b397078f28320e509bfab42c249a99d9d17fd0e6acf5782761123117aa45e07e1c1744c2959158b87a39157b5fe79871f06ab15783d8cdde581e5772c770ce88ff239341c75e75a717f6c688fcd3ada8abe351d354dd9e9ffa1acbe021285b827670aae71d281f1791c1a6170d2c539d2511e6c4e4dd9c997414d7212b35b2e1626135899d261f39cbdec081599cfa16d144a809e80e761b97abcb239e9cc850f28685e9694a973a55ac3e3bb3da894ed6c60674600b0bb5ae2d781639ceb69380397612cc4a3e758c684aea5d3823cd762716ba45299aadcecdb0f3472859fa10c65ba7d09a9bae56d93acb7267cc5ec8dba105fc60cc8a1f85bf8c253a6fe34aaf3a5e559a0e7296cb818a116d3e14b8130e03c1a122c24785878c52e1aa421928d381ae21a85c95ec0729fed47613cba67b54f5a0291edfd649e93610e96d23139a25d66f30e8d0178195bdc180d95b7285066a5ba10116cc63ebe834b4d9b92057ba87611507e163802f767b5280c2409f38de8dcbe4ffb67d2958b411b71f812c803e3275d754d6eb0866e029053c96dcd163a63ed3abc9ec4760f559e1e4bb213bf66074e6d0771228a24b6aa335bdf1b9d45e0e7a6a53efc4b23f2290332dc36fccf7e3763c505ee2efff2eeddc536f133c13ebb9161bee6c7158223ab5603a498e4c68c5bb72bc962ccd6b0016d18bd527dbe9240ea79a6b98ff4657d2ffe4cb3c8ec12785314003c9f72fc581385830cb609ef946c275cd75ee6b40d3ee862ebea145bf109a9ac84bf5d977dd58002026c6361258150a8d1e3a936c865dadcb421dc309ab26dedc2dc94104af199e21bf38db40fa8600d509cded2b5c3dbbf22fe7e72a191a61ca1440a9b3a5e03aa4db0ff593cb6cf0aa1fa0d1f006bfd4304cf458c2a69a477df3058e83f1ca59b1807a096eab1d331240c0fa58020ee58d8eae91f5401239aea0f79ec4dfcd72e982abd6f8b469f05bd022501329980b0fef274e91c786cefbbd91a17f191b447ed0adaaec5c948e165a731031d6547258820f54f42f40f833db87b2551c60e7a3825deeaf0fce2d2921dda134bac8a0915356af81565d279a8a217bcf6463adece2f2cbde60e17cdecabf97518a73c63c95a83ce63823ec1e0a9899c6deb6b0ec49f9194d096361e3f06018c28ccc0f9c0ee3ad5d14a029bd2fcff849c6d06f7d12866f8291f71fa02789b49743c05a6122da15cf20ae24253576e12f8798c8dce00f18379cb14dca8ed04ceb8c2b7840f8ede259321343d6e59dab8b11e4a528b8b68926134b20fba02b1c373bb6fe5bd6e0baf6fdd2ca64a8953cb1d69b8ef0460042e33a5875b1f8a8b9f3593abfb31bf7c1ece5b400febddab9ab3897e7a8b3c399c67a611c38b534f7bc61d728368f775a0c8d21b8bfd1d551488ecaf4a9eb2e496003abb7741e54e36ad37e503d15f9383cf4fb2bf7b8f31a1ef5bd365091e554b4a175aff84b08c353c67c2f2441e957a7108d214f6a6f9d15aa8ca3414669b96811958d4b0ee4169ee489bb5101dbd2d880022e18ae5226c9e3bef81fe9d0f367688ea05637dc6e117b2b3ce49d29694ef9422076cbce5e1b412746f6ea8cf2d57eab90de234fd445d21cbc50bd4c6e126b4857a81b0790e2948b1c917839b554529f5cd9c88013d18833bcf7739bb6c72c704976089de89f53aa85e752f483ac7355d6ff231595e380d53e17b6c0014572cbb5551bc7b12ac978226b57e42bdf6e1ded0b10a28d3dda3981b5588ffb1208694a87dbebd5c77cd97a9ecf59df7c80fb4f3fdf01e735b293cde619b5d53d27421642cc52237001e1593715664d25df58c4ca7a6aeb70d026f3bb8978a2f686b8258e36dac86d55e92d6e3e486aa600f6505223cb79091ba66e4ec755b502b27c7ab23739c67f10a446f49cbf6559583dc45ec0534f82268385b1f364e0212dcee31a209fa892b0da55a51c2e2068f2eb7ae18b4520d9bce4f2d7a2f8c4ab926000337450b354f535e43489781da388755ea2b344e64c83c3c4c959c44943145793e43d3150790a7292293a98924f07f1ae5d218a0bbd1823476af3124fbbbfb8ad6139f5a4f25f7e840f3c70e92434c7c4830f7ee989d6802da7229e4677705ebd46df73ceeb52396a9ffa425131a2319045e5a967d34913753dab5617bb92a4d4b53e82751cfcd3bd1c7cc271d5b79baf5e1c1aef50429b0343010be9fbf8d1e4d706531c83d5024f86d96790d5412ad20cf642c4885ad85493a9d49fcd48c08c8d1285fa83643b63991c5e5d4bda7d413c7412cd733bd516374abb924d5518274a75e889403e1a548be5c58073371982d069c72eefbb6a6c6fae7019e3b3bbdcb1d308acdf74ca0d6a9d67f8c48c43b32c941d1f97de6d3cafb819f93437c5944feee1aafacdd455358a84cffe6aa040ff12be85cad88922e0c41790ae0809cf3985db3c0fc30448e9663c39dbd7f00d209a63d776dc4710efe19d9a6b1d9b22a7ae69eda058e44b9c2e0ca0e95dd0ff1da368a2c625d8b6e97c2ae1f80797a10eb32eb6645c4356fd2cfcf77c74c68e0f6adb29f8e7f1fa7908bb914b176fabc7b5771187275e808cb4019cd05fdaf12373ed13f33db5c86423ece5fbd88499597b2188ff54b37dfb92b1888eff8b0de13f82534dad8ce0787897cfc75778a6c315ca56a873f098e0d2fa61b5bcbea24c3f7b83093190439e3fe021ee584a37446679f1fd4d9d913ef4d424c5a37d4255a1326ee15116296eed8d1b6734ffd18295515d6aa3066010a8fd364b2a4540bf2522e88ecde383e47cb931bc0c66983ce0742351a3f08901bfdd97f4e9c4033fecaefd40ea89b758ced6e4745c0805320bc6b4c747a8c2de9014dfa50d5d478e05ba09959e22c2b9c040df6a0147e65e11900afb6e1f95b3cf44ac05bbcc4ab6d14f4e7f67a25d11eeae54dc3b91762b6d2c37b9da34c53896fc72105d956a7921c4258ed1c0c8e15f3d7c84f6b5180a6cd65e1785eb21e398343acb7fc053c68199b3d052cd3ece5525fff51c42a0d9b6f39c58f978443a4178e22d982c0d4e4360918d8213f0594aea32e2111989b0fecc35059e2b0ef0e4214877aae9ffa17661ff7b5ed8fd4d8f82a8539d096faa2a8276559cdf346bedad0bb7da17e10b3b85655e5a9d442dea81c64308fb7ecfe05a29f19aa9ab40b84111b3413fe33de4be419","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
