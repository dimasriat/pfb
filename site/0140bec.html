<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad83d0d0faf0f0af4e0997a815e2966c1f292a757f08c8a8a5bab081d210b67e0fec5329ccef00e5454521e2783792022803a25b396c20451a3ccb300e73e43905f5b57bbae12750758d7547f92a407090aaed98498ab7df9cac45e436512bfccd90202ce2c896129f13654f1abbd9f8b02eb2f47f55bc5c364d4dc640d17cdf11a178add8808dadc8722a8688efab28be9769a6b509bb6022b55fd56267fa7d97dcbf2aea93ac780c555d44f1b17d8b04b7a1cd43d8c32e9d5db70442db90e11bcb88d419d23f7c3407794c57087be057c1b1f4452480e2e2386e8da3741662af8a4edfd21604ae95c6991e47443d3782f512ccc405182a3c2f45a22921440d5d02e1d495daeee78285f92c100c518fd8610efff5af20705c53c707a0a245ec227de35ed91cefcb8130aec451e93643fbb85260e983df69ca709a05073bedf0e0d3400a7a436d0438a16c8614a58544fb27b2c9b5afac0cb23d0b981a203ca14b6781cb148cd8349436a9c7f6ab44797082af452d7f8f046641fbad476c3921fa44e1d39b8a12cfde9bfbc599eb79822915472e635bb1991d2cb55ac24ed766df14e5a7b009f067ade8150efd1293cd77603443840f2bd95f4a8a689bbb2a83eddf4a4e565d12217c443ee838ae672def47ed07375c117ba3fa8d3480c08dc483b8aafb9a244dd6d2bf1f022e3595ae84d53d858c7b65b47cbb454bd3e1c823c1604374ae1c1beb8541e923579cf3d2f0aa7635ab8801df61e5e0eba346ab7cb035095bf4bfbf6ba8f118af4c54abde2d6fed49cffd26f8283c6d524df53d4182691bb1c8cc1de8c8869599722084f1e3909e8e95b642b61facef7c14cf58e4b6a9bb64526ecf8a64df2b2378b2850371bbfbf23f5c71d00b63bb606cdf7151582fed5b0175a67dff781aa1572b29e3ae6b5b47aad5a7fd7912885619f113450cc43917e09c1d82498a5e6888061fc483d39281ddc8bead0f99a2b9497c412e5eda5d5a971435e36745378df01cd95ec42691df144ece59c5aea29328071a21e21994a45ecd42314df4784c133b4bf7de9d4b3b5badc829477561e758a61ad45990acc3572ff0ac4c3176d34dafed11bc9693a98588f8662b9cc63b320034cd8d459789500ea6d66609366505ab82b09505447d0e0e6aa76eee614c3eb738e433467f7975bc9f9a9becc30d2d2fe9617a9fe56e7c9250f02246b6c974446b0d7291f581ca1dfa2e694eb2e672d40b9f7954b388d53a13e730e90d96808d12dace21eac1ebba553b481718bdb097ce574c5773f9a382e0d869485d8c19782251668610dfa1d59428b9ac7b563bb5166ab673ca13d421d026c26d935838b54011ba35b1198a454957804527e0db97090dee7babab610ea47c974358cefd1fdffced1a1b89631e757724cd95d595c1959a686c161759cc46b113027d6fc5ab3a73aa204536ec6c1308e192187904bf3ec4be5352e49a5fad4aa39905acb9da015babe5c0bcf5cf990504df823bbce394ef90e2ed41c629fec6c6596fb7f4624d2b5a1dbe22f3b73b2e47ccf9baa1ca99d18854352fa7d6d7f5b069e3dca3d63177accb6f8540aa8ba3d67253a96c200051000e997c37cb2a0f95e755c6da049fb29a7be4bc9b2d8c7721a73d3a4086b5e9018658f016bfe610fed7fb518e35251582dbdfdc4f48b827cdf9666ed19133a313f12cb1a140655666fbea13fb6b4ecfb185d2872ca3fa6490ffdb376593c27736c922cc0d1018a75714e3bb56dcf7a09cf9ca7a46987db50773a349924d7b39b54b95cbe161c3eaabb8c5ff31f4ef830d6bdd94962421aeb949a45ee358c22c9b968e49b3826bdc90c112198d270ab3f4aca116322a829948f2e88469bbe3a4bf4097e5dbdbb2ab648c4c57ca2695d7efcfea807eb2bb673125dc0bbbaaa99b42c21d2a06aca8edc2333d124ef94417ce50742f6055e90ecf9da6fb9445f88f7268c1b192a9c866d765e976f45be77d1b6f50826e24aac3e3b151628f8c2e4a996358f790593f2d69edbf694d6869bb9685d19da4562f775d147209f29c495d8a043adfbf428fff467e91493685acc850b3b0170895448dcdeea2dc5032fcbea0e86a307571115ea7f5c12c667daaf039b955b87fa348aa9508bdfdc2074f5b24989dc2e61c6f3d469240d64ff6ac506db4019f6947726f7ae33c516af94f201dbcd05139763dcdba7cc0e75036006e58c69ab60a55207e6c9e500dbb2f46afcafd673e863d0f03eca9bca225f3733642f65a31e53b22f793f08b0366c91339f877c7af4cc9700122b4d79d2839611afb0da2c88a0453a4d1812c18b40a3fc23867ca1f00649b14ca70f6931498a7eacce0d3804db51106977683c8a32f899c7f8779f613867eb3605635a763e01ea5381961c544bd97729961b5933d6240c81f880eeb274d85cf9bfb256c9d91f797cc2c1909d2aaaab5ebb5b65537fff46d485463d1ec946341918341064803940ff178f31e2bb23f70a4af725b4738a820a3a8088124cedef036490ced7650d00fd3c5689bbaeaed3d0d7431a8aad4a22513ee9bfec2f8a8862b918d2fd6cd348309f3214334f1066fd30eb8f0d922fe1641e3f38f02dff10906ddf2f2ea1c2139a850737bce655fcc5da57b021b307fb4bc2b8f412f9e84673fba840203c9aa5a355d6167d1f0fdaf0ab2661892ee37fe979cd44aeeae3c44020c25c9aa000e99ff38feb004e2470ff96019de5447f786fd36f691c5eea0cd88f1171725390d6997ab10caf06fed571dc4619b8c8e6a6dd7665e66bc73362990b2865bec10102a9f3f2558caed8d8881f9bcea7f700b93b5934acfd0d8b017ae60a4c895221533a6e070ef3df9c5a3dc498a0ebe2f6b2f0230025737b42464a368c488d388691b533563bf17460fb4108ec82baf2c105cb1f4d1e7aadf1630e621b9a24068a4f9d62bdf753af736e943239aaa4f80cbd74a29d14022e841d7da0d8c7276424d8de8261d06233254e0598431f9b5f5db86adfa6e5079c39e6ad29d61be245fe5fb6118f4c9f8711de65a8f403bfb6250f8803f8001589945541aa93df40f3ff4d5c93748e28de4b619b74b8238f7ba80366f8aa91ae0544107dfcaa398446312e4f0ee2503dd7e99149b425629922bcc9c577342a7ae1b66735647942dba9331e42d36700b573aca286d3cfd5295e799bd01c02346b76e14c0173a48281d4b2c753b39ca3737eb3e145a70301b6ad61396e9830983814416eeeb38f36ba74f688b0bb26426c6d40bd5e89b7dbc150b13d84b654b2b6a306baa5f470733ec3acf365e02ac054d42b06aa569ae4f9e66e34c3a7022ecf28b95a901dcd092587822a9a45f21f453fb5e0b1a3a707503f426dc2ef9bef8d59d15234d4a70fe68fd00fabc2ce0dff78ba2da32e7ec54cb66494e0dc73d1f5b70d01b5424a624544bdd656b54df218eac5764f45346c0bf163bd92eee6bc5d4ab426f6b221feef8b6e1d4309465d114a9d46d3507a1160be17aeb7b1e7cc07c1798c194fd9cd27e88eea3194e5600951b3ecd46c4cb3959aea6125d5f469c6a91aa0474e8958bb95d58b6b9ee809813684954d0b023dcc12f145b94546a4cb69bb9c89e40081367a048c076d752e7b805165ebebe421eb8cecbf7c343ed265be43f57e71e0c0ed98e60a03853610be07d8d297a904ac9d7b927360ac56beb31944a248574156446fbc6128b1cb7be93f7ab1dba39790eb074396b33cba528a255ed6c69afba3db0d89a85f81127f9eb3e3a969768eba7bf80ffe47ec50312faffd0867dbafd6f297c102c8b162fa8280fcdeafacde19788349a5603e2f1b5000eae1802106a535320556c72846180a9193a3faa632306d93b92933303c33594aa5acaef5ca229c5e305a794523f4ebe96d9620bf9b117baaa1b5746e7005cfc7c383894e4ab60215ca51ddfc85aa0464df34023c10709efe967373deb37badf4875a26c151cf02a64489551fee468000a2d2aeaaafd2466b56259f101a522661bd068a5c8122f7c17de8280a82cc55cec926c6912101f0dbc1db43f0ca326bdf29ea00dc9f0c486d5e8024234ed6f982dc4739eb496fc2beadc88c89795c4258fdd28c9cc371209588fcb739c212bede4911f84b9131fff5e7de52da29c45b43899e3a661979c9b497fdfaa43526117d245f98d3e565405c4c1a003d5fb5c243320e659e014301df4306f27db0f91cc99b5490fc86d0c2c97542a292cf47fa6b2b656aa5cf29819525320f4926f9aa5a4b7b569b360b758397d323222d1c6d1c15562672b339a44c153edc2ae787fc0c5761bb06049e336ac6392b90fd55d903e24d11bad46a80ce6483dab0bc60b421b455d3db5ada95372b5adadeec36e3d72097705ac5382202c1e970c3711ff459928fb3f64b9fb0de247f9698ed9548e85b4f97fba5830eed985e46fe131a9aaccc1efb2dedddbadbef11b8b2842a0b4965179c14483165237c3de3f9698f9640f4fb891b83b1b7568e630ebf2e1bb9aa75485c717c7d46a3e35d3dd323aaa6e47d85ec162a086206f6cae158f87d7ca754876701eed5b10c8e7ad055983ecb28d9f34189e60b8d1661e6b0ab39fa2e746768415e10df146491532b979e2532bf303f2366b7463d37b8d70a21cc4519495a0994ff08cb947cf526856187dd3ffa94206374918715dd10b0c5514ab7cc3dce580a1d518daf0652b203db815a35c1094784a774103f321e6718c95f4279da82df27073bf2a9b370415dbd73c8bfc126acb5b6949e6fd2a9b6810310ed61bf2de7127af52b947b11a0aee2f177650f14ee3e267d5cc6aa391e6a4a94695651a55a1fc3815ab4660cdb7671c8c9254c2d554da0cdfbb7b166ea58a90ecfe5638c0e6d97f55fb6814c1afa7bc8323ba07e5411f510c6de9e2906aaaed5cec1e8cba1263a02f2333026bbd9b742789fd7e76d6bebd3b7e5146b4470444fed0e5b3559a9364a0f6fa2ea9479ef6cc0901b535dbd35894f81316e978c87ea8e5131cf9ad85b7a261a58fe8ff53c93e8b5ae79bb08a5fb2064deffa10ea85cd2bf306bc5781c41e90131f36371c8acf8df3f9693e1803e83c717731c0735d8246fbcafd2951c66a329baeb8360c4fc14f53a3c09021e54b2b6ce6e4644a5ed69391fc8b41bb9cc44d4a3e68a2175d94bcef7fedfd13e600d194f184748a609b07d675f775f6dda49909a2c8bb22d8be2961aaab313d8702da4c78775f002fe79707454f44e201b61b713e8de17361cca381ca69d39d32296def05bf0e532e9f60349629690820c8d4481431c3f88f430697d5e7dfcc55199ca501ed80ffcdff1d4f736cf9dfd398e0f8d3c4aa44b6d01a653a3a6871a678272592d7ff6129187753d30f1d55fafb2f75bc3d2979890c3ff9c8cd717be65c1a2c43ca95d7283022b3bffd698e969be2ac7f8b59d714f89c89bfe5c50cdbb3cc3cdb4b4114679c257e780dff55ec2c197472dc88f3388f0e6d2321e4c7790a4636d79e1088b60244aef6712c18f5475069483347ac630eddead107b57118aeffec542b33289fb1809cb60b6d34e70d311f772cfe352bb86d52e63c0b85ef7db2449858ffd0e5103fe058f643422bbcd72f6c2239ce6ff069c40c31054bc1074dccf8ab707476455542bc1ad76b408b1ce3bb7da3110cfbeb8b55145293c5f2b905c23032f6bf0dd07197b3597404ea11b0eb0a3f85a2d92bbd065be70f4740fb896395b8e9929bd39b85eea61bda56c75c97609158d2702eb4ddb34254a31059055fdbb427f2d6afae337acae88d79713e6f80806fea531bcbe25fd3cb61d0c15cc50d789eeafe6bf650ae213f805de93b0b52f1bf646ac6db30da5ece5525bfbffab3c52982dc9766d69f6b76dc74de81594e737fb8927f8e67c977dda838c2b8c659abd127153cea216222f54f7b89aefe4fb0696c423e82d4c48c3c4633bafdf0c9706413bb5aef937a048f7d243509a694baf4bccf43071aa4f4b67c08e3596fcc27c603afea626cb88097aff84faa57d27b2fdb3d9edbd7ac877c9206481c2306a257fef1cbf4e99fe9a048871fb4e0cacb907c90c3dae6fba2cc3ad6adb5bf16999cdcc5832a4e59b2e617ea58cae98c7982934919ba9cc606ce7e95b357cce9673800fdab67fb8b70017702ad42c6db7c540070eb44db2a307962e8463e223887665e1883d661d5c6b835dc5752f3d8fb1982664df65989aff830da6ccfca8961375dcd08c8883d086ce4123c24698f1897591467c1d53327cd43d3bcfb9eb41378392739c34900be636664a79452b527b9fccdb3624cc12f58880f088e4424328dd12c5eb6a9694ecb926e1de4f6ed82e1bf78198c67e8412a4d225ea4c8bd49631d9d3e293fb3e455339d486d8825073f9ceb7d9b4aa391378cf9b8dbdff22bd8cec71d95aa5bc30e795b81c0914c39dcd0b25589a65eec896f69b62307e05b4b5de8c0bbd202d5f5706c9cbab4b71bf6ec650c2a19576ab8f0ce6740afcc2411071e309bf7007691ccdd66f74e649503c54ee0bec1e3164ea1e3d0ae9a4cac69729e94ad06cdae94688a32ff6235f89c903e167dff96c6a654463ad0f80a3f96925d9656ef5708efb82fb7e32c6bc267488bdd8bc049f32381c2faa7fd5d3855863a47e239e07268a63dec34b2b3427629dd7a8e51c5b67d5d4af683571ae007481886ec6be6d801c83a89189f353a6cbe8258b9200d81637178ed152a0fe3b21fa1d65f49246c490ad66fd0d6668992867ef953fa5f8208baecbe104d278e5915f8943fc302249fd0bfad8d45b0da1acbb3aff833e8222bc99511d168b60c7c61496b45ff3bc4a9bf06ef600bda122f68bdaf38fec02afccfdc267ac02f342b66a6756ee88520f46dc7c6a45de8e1e8e49c8ff1dbd3461cd2c0ddb0c23bd984d76253b57c2d8e96dd0d79b806bebdf515e931788687e7d7878837a7dbb27e24c3c02e2079aaa32b713586af48acbe1e46cba4829b651caecc67dc516314424638e7a318b9c4e8dfe1dc28a299bcd2999c5e73d9f2655656b77623e7fbfc29b8efdf972afec76d30d4b65698851ea982d8c07937a57b9a6075e64dd7d72c9ef53e1d5f53876e61dd7a4e793f6b60e4e21001cb822bef73c815063ea0be0f9a1f22bc9b243cfc564b7899b3f57623297ac94d2227312f39a50ab1bccf2a6d85aff9606d2743cceb64b447d2eeda2975e2a53b8c1444707daeadb52f64e2d8a195e8d48797cc106f63c2918801c800609918353bb1bcf2533e07eeee86d3e2f88c471b243f8fc356c7ed20c55658326517a02dd30350286d70197ad988bcc3582ff161a8b5b76dfb20d32f82d9a613baf9047665aab6f92d342a10aba55019c66c8094dd9bc661a73cc65bfb885ffe7f50f888904d47e3905db5dc99ece63286e509f78ef1b309c580fe11bf6da6d3a5b474dfb1899a7c5d3e467cbda968e5609deb501c367b2944f1e3f29938e56d4859d2887fa31d28691575934f1fedbff0e7fc15914a3bf26a8adb732bcc47b1f3d96d07305e847e05e0f7870b9ee88522ebefaa58438c5c0e740ed48acd72e1866f312539b924cd5ea60ff8aa13186cdce18fe1f8955a4c4b08d37ad1f6fa3d1957fa0de811c1a046f79593b54fa48109715e564a0482bd53b7509055e1b282d763016824f2ee402bc31d790601aa8a765583f54e98c0448ee77e2a26096dd497bbbd045e316d961abacedcdcd4c8bf7f6341c8b69fe4ffbd3c927c0d0632bf5000ac931ad044bf68c7ec96d768aef4c92da0ce9a7703c287bc3921d69f4aa7514f2215698b6e7bf2aed3bf4a282c9d7d324f3c14a770c194f549f27ce1817c308812912fcf3a4fe60f8acd8a17857f74fb34fdea94fe0a34b0b99fb01673fc7da2583465fe01d73cab4091135a1442964d5a62f223a41f3f50a57a1c6240a4dac3e401c31c88b39d2d079e3d3b4ffbdcf3cb8d02e485472194e04503f003b0765abb53e768e2e90bf032405783509f0030ce3a9a6a95a53b6d0ef5751277a782b8c0b0613f6dedc1462258700e9aa8ff6234cb320225b733b99ff4b2bd80cfa3404de91e53ed67524fd7bca1ade583d9b4e5e6a0dbf41980dd65cdf96dc3322738c0412840b3832d3d133bc9061e299458d60d325129829c733028040ed79dae8da5d362949686e2864394942d68de2de734df38a2b179192f3d9eccfc4a35317dcb0e5157e7092d8523327642f249f8e2ba03fc90e1e6756c7a319e95aad47eaecb9e171d8e590273a7f82f5d2445302793cb17b25a2913b0b2f34b4c12bbea98874da2a4cff668d17cedd15e79cc645db79a627fdc55a3d3140c30cf730050f12d0b6baa494590278e5614c2c7735575d89c95fd7fdb6b7fabe75f761ab224c7c940851cdb21844005047e97be8a68848eee3f26f20c90823618b00184a6272f25d24352f49e6200888a9328c92ed7ab209829c6d133d94e403512eb01f0e9b8a891d9affe686166b04088c7123849a37df7c17c94f13be8d7798612d9195c89e124c3f95bd2fd9b3ae66370854d8284e0dba3148e9ae3b6fd7711799ea78667dbc8aa79dd61a8bcbb7e9250cd0ccddbe104c7b7614d39e9665387f3dcc36d0bc41f3f0c44898d3264ece966a97e77a8589084c7b6f28995e3df9bfcbae38298eb1bb0c9a64393017afd92029582563d25194191ed191cc237ba3adf81e188b2788d50bcd8a842bd2936ff82b915b7368305e4aec3e878a3b3e7c16503d865395909c879548b313affa88f8124da053bd3fe5e6b2737176abe9ae4bde79a2df34cb66cf9a682307d565196632d21e394aee9b4d2f5a901862168b22d065fd5cd03b672c38d8b732d4a6b3aab1145ce9ef50d37b11c5d74ba5b041ef64de8e916cc47fe302f2ff31a60da0683b85cc203aaacdabf31d37024340cd75e30ab48eb953dc7006cc0960836f35ed059f5895bddcad489af27264285c751368bb3c7d4777d6111935f7e89d26a80766a34b58fadb0a0b3300aaf1d958af3e26a9442707bc4223eecd6e655737faf6d479f28e4ca1e9e135cf9f09d6dc5cda659e82ba47ce4039301f91b64f5170a36918dcfac431326852f106f7396c2dab005a8fe96ea4a6c2a0c6bea9d027796677daff13b805727b402b868c723060a369aecfc6780df43955ac8732706ee24f94479ae931a914a44df7bdb57bbf2905c97c959a9f6266793dcff62a708657d20886386fc6c1201f296ce18eac0ff849f65ba919ed42fb5d017f6edcce332b083506a5a4f7d750224d0b3b22201a6056e0750c242699a39b8d4b0c089f9d1dcc366a4a623a3a661a18e799c14729a3b5373416151ee885752733608de77ef38a84b3a32e285ab8a2bd19646de3359b7c4c4bc8c0c4395c6491f1702e27cbfbd14460db5e01fdc4ad4efc6efc459d09c7ef5b142a546ea05d4e0ba70ab2a09ebeb535534bcd375ec9d265982bfe604e99926831545dcaf0ca4122f42911f6ff7bca3b8fe9990bf042ec7ffd67f4469b4a116bae4da9389db9b10dd21cd0ad321e906f2f654b0f58da64e6037c61ff691b2e208e3c124bd1b830736c520c102fd20dc2c6b48a3c05ef8f51f7a770e80a78d6e3fa7d06f7ca14f0687f3f367eef1ad29616487e00bdfdf3e851c6faa4f119153c6f4d4d41d898231a68b781eeda60d6252aa2938833909e285d47f549589f368f530e1c094cc1d7b1c431bd74eb968ac477c5577a7abe79218b680940bc730c59ba4194ce12b61ac385c57095ca19203d1e0de799ee6757cb4be6cca865a7dbf11b4713b654a97c0a18974802b62bebf78f56968fd12e0d96ed9b163fe77d3bd83ceb9571e03a1e94f81a5b5754ba2c48d7c956f2833fbc5c9503e0b5ca56ada4441dc93f360a75820652325e67cfb308643d7db9f08195ec32d33081d67589ffff9f8ffcd2ef8e58089bae4d137aaa6a5b663d529d433274fed77deb3dfd227c4e8f178df6673a80b4365ae3f2b993a67a1054e661fb7403d2e95ef1606178240c828930eefc761b30500b9fbf0e2f9b25977dec13c5fbafcd9decdb8fd3917b22a7e45d23dc302b3f48a1d3b17cefb7dd0647c4d5f3217a2aebe0622da254304042699a1c1f083f720f027e9f41122ac1800f30d9336db4a55f041a61aff4740a2ff6cf2f9b18e563ff7557bc0b334ec91550b11cbab8a7d864bb754ce14a6184d02f229de97fe0c21585426265b5f802c28cda68a94c07299601880792d9ceaa4ec484bff275789a333696e93e1f812fb309aa2b362dfff7aa0c2ecae6f7dceba78b86f3fed53eb1d3c3d05aa6f565eea21149852c279198530a38c5a4e0da57a72c1ef1447c1a964d0097fbea1af08dd7b330364675d8b5e32a37a0d74c2e9d7f5540268c4f425cb23b56104c1eed2d9a17ba8cb5cb4a3433471d060b58620c583b410f9b8e4db8f731584c1bf416f5a52e6c1fdd43d1dc3970ab946a36e1dd7ae19ef2f35017358dfc8a2c8ec82c96c49cddb076651d6caddde632af3608326a1da000036fe06c9792e707763c8876274a81f79d01abca2c62ff486680f5230d57f9376d2a6242db184ea8fcce9a575e0b3020c6fa9553ad066aa8d697e39df0a7553fbe2865bbf460387321cbe7d0ece5dcc7f36bfc12dc5c89313fbf97f8e86fcddfc41c56dd453a2b7658fb4f13ded2904b68f27796746a065e5d6c88306bddf50e15ca232f4d1abf654665c54014f06fa587b2a6dab38d7c533de42ce67514bebc9c1cf9c9df6638591a46b6853703c63fec8876907abaf2eca4af899004d368cd315617bd35258c511e38d030a36ed338196bfa18a25b70bbf0fad00962cee558faac5b28346ae53ca08c62efb93fead1850eb2b6a00027aed7cb5d62b11c98566e859215adddbd3322d37b549d41e40bececfd4f7c33392727dcf68605beb60b821c383af7f560afd7d61298312592976fb6f08409c82b3415a2ee6e0cdd0f67a8fef412ca6f8701051fcb7b468b3cd09b5768d697b8e4f309decac0245d195f9df5aad7b37d557bb19e1e673ad1f11f2c908bfdd555363701c8a9ddbb53f08dec6aacc010bc6945a448e433f78d8faaee5f4ec9168e117b2bd656439f32ca4f6c76f1e8bcef35caa910ab4b5d519475651b5ea923fb24e11671a99c6c1ddfbd4a7bbcc16778836a2f88b24b90e9fcf45d29c6384ecdd6fda8673cc00907672ed5cb1e8c1ab4023a52cfb267ac8862105ac7e592a19595f342f31a244ca4804f1bc1cdea8a6dacb3d0444557ec07d8b591ff314b04589ad36ce27bd3ec312594ade6ba624c32465fd7966425c4a367a87dbc079b22bb1f5eb7cb86c538bd28d51fa1857b0885dfb80da3d5819b996c4527d2ec8efe2d0555d3e726b4091aa3acffc118eae67994947c1cbf803e47315ba3868626ad1e287431881a4debd2d0c65d7706c00713f744da5e091b1beb9ed5fe0704ff1703d70bc53e5414b42f141d967ff86a18e685d5f618bab69","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
