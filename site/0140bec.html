<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22642312f189eebf6624fa538f4109ce2e2c2243176fb04554df2b48fa722cd96160756a0827c71aabd850057832c68ac0bc7afc0ae6f2c37620a2ce746fcb839a6cc359525b95ac099aa9633e0869b910d944d9ddf2edea895ed07ee50530dcbd0edbbcd6918f043979a3e0767f79ac5ffff61e0d7d9d32ca72a20ee5acfdcb13a3a3e051f4c59676ec16ee615b91be46359d5b6b3640367dd39a8353c80d26e126cc9a5739a70f06285beaf6e872ebc190a165e30501023b5c489789dd942c692467e92edce7dd42b01baec1d2305e9312c224ca78c405c6f74c6a5529f6476669bb232ecd2ef0edac94e292695144066b54fa8324408b51d2bf0c14534ae800f92f9c023d8df90c9fcc31818d493940230c0605f4b878826beac8caca76fce39d451559379071fc93016ed87b29004360dc7e5209fcd12195fd8264ac1c8053169fddb2cd6f9fd840a3d4acce546306a1bdebe675ab8be55b61d2288285f8c9ab793f745978946e46800abbfaeae28ab196a3356e40d50d462c918b2ceb62f323ed3a7c4bceb5b228093dbe5492abf6f1435d9cceda66d48466d6f242711d5a5332ac5b4c3b7bbea2d830c799b7db2a7e74463a66d81a74da0ec175867e7f75eb1fae2c01e8d573fdbce4d51ebc8bda8b9858392017b53aea4386205c1977b6cfb8fb5f349ee80f48d47dab33b7efc99bf021c857813f4b59e58d95cebc1b8b9f15c5ffe54d39e9daa5f175f779779a8fa3167eb7cb806ba1d7946f44b4d261dfc42a3c0a62cb8e643475f316a1199f9e726c8a376e4cb5b39daa7e6fe9635556624c3f99da0c33c3bfd227eae1d30ad0bc71cebeb0c588fe0c62dfcc251386c8af740bc014fabf851fca712c71fe39bdd71a0e7538dbb396a439d19d87bd2bf04dec2cfd782484a91f7422958c4d17f1dfa4c05d1950f3bbe0d68ba33f1f91732d0da85ad05717e6b77d900eb78e42d095951b1705eb279cdcf81749fb3c178be45b839fcc36347da51533af94934ee23754a88c7f7103c52df6779ee92de07fdd8f42ea1df337d275c1878eacacb592d6b5b7e34c3c3e2a0e25b35c0e3eef72ea4475691f5fe26754d349c549a992ae1e00b4cc2a83cc8f97694aae093129e42930266521eef3df573b4ad6bec23c2b16472dea746944b48056d06f2a2149689088b670523027aa42efdd75b3ef5f20042b598d51dc675b5d663172e37879ea7eeec009cf4398db0662ddcb43bcbdb7728323fff72909587968c6b81ca6afddeec09708e3be57650cef234ed35a335e6828972feacb7dfac58783b1c354aacc6cb140e9ac911be6477cbbeeeed1359983cf05cac695aa9be4d4da5ee67ab4ba47d96381355d3dc16023e09a0a17f69b23e7068a4ba537b4c1f67093d0c46442b59f4d6bc6432dfff3c8414ada43fc5f10b0878f664e1dade2037f11a52ea3c71b6df1ae917c0f1ad622e24ee7c6a0fc6ac5c6ee525e49758e637b895be51400c0306de77e53d1236ad5da613a9acd3db19d766107a30361827be2248ce2b3919832a7a6e9287654ce901a8163fb621bd3171ac731126dac4c431ff84083fd8632df2f62e3225821e093aad02a4ab0b3d7f9c04621a0ddbdb27fc16c313189ad898888251d142947734409720347bb59baefbdf5e32d4bccd15f972cad1f4163cb53f141410e569c82daa34027b001c72137ada7e10fb5f10f5c6ca67762f8722d6068a401fb4e16aee2c7a91e50e6c5c1c61f3fd13a1de740765e08210ce64b60587f7651a5f21ea2234dff79c5ecfcf2cca60657a2dda77d8fc81c70cac24cb20439dd5728daef555dd31d07ae105d90c48750167846e229570b3807eba3f1b55db2c0d4fa910093a69809e71185757479f627e7322192e82c3a51adbb7e1ae68a9cf1c8b37c190c87460bfe3961fe028523991830c25a54836a9ceecf123bdfd770daeac9c4d22d1609bdd04d5a4d6e3c69de6115d54582b3f80001a5214119925164195bb12199b93678d8119ed3769ff5920ad176407226c886f66c6bc6b7460aac95ee9c524eef5efcddde41c651a328f39782817a611db3be79f79a0cf60b8743ab54972c542bb661ce2d12168f44b65ebe147f5ee2ef7e62c7fa0537e8c850721eb2da0136472e95e2a260f18de29aeb3fde415d8f7127a33c3fd9abc8fd32563ae8e8374ac1cd933a268cef2dd8e5f65ce15e29d44ec3e7a84e7fec15434a9852e0d4bc28a5e29f5dd7b340dbeb3d04635b1963bf0b93bba8ff20cf8f3f966c018c4f42cfaefb4f03b2c2793834bf219044c0ae592cac4227db10737923dbe0329f820b19ec781721986365e97c4341c11fa9aecd20ca0277bd568a54f52e19a8fafc0b44c2a27865436dc7d92365ef6d50ad2768d079b8dba7056ce5a947569ed0f7d99fafe0ccdf46f7f5c8f5c128cf7c9d35b67a1219ccd5a5eeeb846e75e4a546ceb4f46e5d54f5cf5ace3643fd7c34b55c2391654711a50b8649355e2c7d0585ff139a6ef7c96c3ef0bafb6510af98b2fe7a415fbbbcbd7e7ef0849f08b81c935d377940b85e3a1ffb7053a9c5193f0756ffc0ab6aa245c002399fa2c3b40beaf56f6ac7db1ae0ba573f3767206f4034a42e96a9f6086252871335b41d54791b8f05e2696841e79bb774046209778bdba0012596275148ecbe13cbbd759eb056cccf996a59c34a6d45551ce6eeb9b027074d48ef2f17532a1be482a51636b41e1bd77e8105cf0c61e8ed70b16615d026202dbd189b4e923db0d9e7dcaa3ffb54dcc51cf093c88d9723825f505d95e49a23dae220af5f21782843d8f298553dd0589b29b130aad0f0a814737da30b9eb037713a31e1f1d4d6c2c5ed563bcdd5954f3843604fa8498c2ac4104031500d1d28a118f81eb1517c1b242ecfa3f5f8164cf84913fc51a6e99bc97855968508f531aa5dd46d888211c231a23598254699b967bf893c572a3b1ee54f77af8295661205c5fcf2eb5a92d9be52975790dc279044056e6fbbb5125714548a711ec27099d2c0ca1285daae05b628b4307ecda1086bdb1de6e8cbb632708e2a05b1d9bedcbb931ace39bd48cd128c892f455b8b323600b700169621073c8260d60fd66cce70dc4fb3d9ced07f53f7771515adbd5329c6c7ceb59de9666b1cfe992ceff10e46838eda6a20ca03350eff0fd6819c9ae8e2adaf4cd0623b4ca1faa9b03a1758aa9e1a7f3ef879676a73d638eaaf80a923612e4f01a9de045fe59929d476901125863263d47f629ee2edfc13f598c0d862aef0c71eebac3312cf57f77bc571e78a4b68ab61d2d4085e2f313008bce74ef38d62b1143f772231ad84e7d422c2a1838dbf66edbd18f67d8bbcdfeb0a58b8b3847324ba2eb89fe5b945017f11c262de63311972688711a79601ddb7e1657f86f0d0af4e149290dd224c6fe9ae55c03cb19b0a67fed8fe8529c87d96448c3e9ea56597cc6766410893ff9152d2145acf5e3159c990bce954ab72b79e16bec8ef2f71eb81002d684ea808b984ddfba648f9c458614c950c4ea9276129b4636a225496d1ecdbbd7e8bb52cc39d7bd5e61fabbf76765e588e8f354e09567fc55787038f07a22597dbce32273e3ccb0216bc56d9464bde243f8667cf0aa5729253a43842d2dfae811c2cbe638364a1eeb122215b84ca820685a0ef9ecb89b2ce41695820bcf795be1a60c39064ca75279615d5cc4c30d76f8e3eb7a28b8e4b292a2a14e5b35d72670e776a1caa842dadf6dd25ff16c3e4d396eb3f27e5d90287b275ed05491626ecb58759299fe118ff6af61b35e4926fb0146c6da57d5dd4557d1b139602c1a5edd1ba17845559f52630e5f026a1216872aad094f863c212b969193492644be9115ad96bc5c73ac12f52c558aa994792bb12ac08b785f040e95e57d3437fee048f7ad6a53870a9bf26d4b8dffa8970db41508286840c54ebb7bdcda69690c62e4716b68491db93025d46e5d704a132b3d7b3478cfd6ac9a9e51c3c7e02914bbec1a8a540b49d5156da3f8fb84f364df1a4fac5cd7f1b87f001e7a93df28c7c2b195cb49da7eb415d02ff6490395d3bd112eece86b8fa429b9756fa1073e1f9130cf2dc96738a96cfcdef03b117a047b4c7589c568c8faf890d513eb41c4cdf9ddb8909d53687ea91149031b7d6f8b355cfc7e87b690157348062176f4c8f0923f9d3c171076689da05255b484f469747ece50f7c9fb083790d92cd58ca9337d78d2942b7a7288ae1f1d6e7c2673ef731337d31dcd93f01bf2bedcbb74d5a062c8b9e0f40d39d06e4611d4550fe725be821ca6456105c09c55064a8c35e784786d07a13a0d80dc767cc2f805116a1cf4e0dbe2aec0d7a6030bb1466e1adf223cffc16c7550be131b2fdb1e68710007d9d55b0151510237f87267ecc716561ecf3592b85699a126b08667a9e080ede2dbc7ae4438aefe53a94ec22d8cb14ed0a64c87525bdba1e0a78c1aa7f51220e5f33820535145022464e858fdf6c97274e69112ef26c5f1eba3149abd720a9288fa444be6d13d34aa7e3a5e96c25a2a8706681310800c0dfee6b1be44dda28384443f58fac60a611de5d84977dce5a04b448319c01e765c7e3c5f168f53465b5c0595f1b1ddd728b081641abf32241ac8fab08c68d0500c92e39d853b4427e5003dd51fbfea56e0e957a2096dc8f4a15a608069a127657e2752713741da98b2ed8cfaee385d45ed61da4149cc9a61b8979872ed7108902e26589c693771a62a7314dcae633d3bab9ef8e5acee5ec8bafddf772a54b05953ce2ffb9ba6245bb4167d63f6e5a0479de735e0138744118dfd2386238a1292c18268dbc913e8881ef028f98e10243ca2d140a0d4e4f9b42f159cf31443b989633a85948366dbe39ebec59f5a7a6c0e0bab9fc45f8f85d20ab1998c4ea83aea124623a8578ee6d57940f7ea79c09ff870e648e45a555945b3ea37ab1a0c7751982b23a1befd2be7ed44cd024fbd834ea4f9b4ae112d169ba4080eb60047452dd16efafc4c3b852ac44ddd615bc47020bfdf9750fc8813ac8714249c85aa39e2d79b82f1156ecca8dda854c5102b0ffafe55e86eb7c60ec7e5100ff911f76d89ccfbdb613135e776445ced25107835da385e6be32defada9726a5641e5bde0e7433aad39545587a72298ff56db9dec304b999c4f38eda3668b76a4be97d077ff99d58bdfd525d861229606559aa0f6f2b1249b8421a76a3d03d399e1c64f75666afed7c60c6524881ddcbbdba3c4269cbe2f9281db3994f0d956128232f605985d6234364784ab85254c37f45414cb8b3bfffea09d89b1ca1e250c2cfea87c449b39db89d31a0d171f0dac01d427428225cf88d195719d60b8794b77c290483ced2e70c5da33e21b4dbf1333fa0dc88e4a20a5423f71da994af28c2457e5805c371ca5498661a641de630cd1ceed3aad91c94103ae9bd2424ee6ed83c38db68df8664f9a3b4ed497088e7d479ac19ce50c7e6b155d6a6bb7c5b485fe6740def308de58d0799f308a6cd47a4647920477c596415ade701059c05151a28d687aaed401dd353e131545d2727b03dd4ed8927c0d36267a4d0082c93ccfdb408680a29d391377496c00d7707240794a76f25aaaecdffa48713212fb864285485c4ab191cff29c4d9c4692096932e5d171574bcd917bdffb8eb77c82d13c0c1355a66cf2c199c48cd77abd7fa42aa72d2c964239b3e8da713873953beec2023c82388df683ac575f073c407b1e7323673d519ee7d3f7971400427819352d405e2b1b066a3ac00b374e2d0a85a090ecd208c087f6b91c9f0fdf5fb21ca410156fa7fee75e9e7da2326325a620bff2999fff31176269984965d47452acc24a6b205c58731e922dcbd6f1bd09a066018802860a2e104dd37ec0c7f9c067e5373d912cc251b21e679de337f7c6ee6c3afa18b1bedc09cebd5103471507fa507d27b69df3a3ebfcab6bfd86ab5482ebab7c7250a029f0a7b75c870282a0f22959074c1640f289afc273945168771bfec0cc23e8e90826c54e360e04180bb5bbc30fd94aa1840d302f45da8841c27916c4ea6ed19dbf008e2e676bae4d1af49fa5a0811c31b74a6b863e597b8fcd25081a9d42353532bad21e48cb48ffdc37c1288d8c802f091be0205b2ae9ea955a6883d5d9fe902a5c03e1be3d5594ba063c3af6bcfe02fb38db97a0131069b40ca63b1fb42d13b37ad25d8c32ebacc2219f54c5c43fa8d132488e1ed8adf4f5fae1838a32377c85176841692287512a9d8d6eb5bd21f2446dfaa227c55e28a8da395162dafe0f455fb7a09489aec78eab5a97206ef7bb0b0c677449b56eb9a3f33e288e37160717a418cf625fa8afe9e2a289b4cc47f51931c9f4ea1166e38cc0616e9010d1c39ad1073b873834b223e0992699011b112d23c8615c7ffecdc1105e8a3806d587f46906dfc43dd03b76e0348dfaedce4b4371ff8014324fdadb3d1508a45f4e67c51d0bd3241e21f4c8d2b9298e1a75facf00166f9ad8e2dee0eac8fe45cf13e55f7bed0bdff64204e6119eacaea0dd434806e0cfa634b24066f5650d3f3459a66d5c6c572ec678a33892b92eaf1a91fa4fa3349161133d0bc7755dad6b66fbee1f4f109e1454263e83652ce45ef1860962558d571dcfd0b741d8e9358501776d12abd9a5109ab7236ee0e34ad9a6c94746723932cbb86d3ecddb95b6614fabbde08e3a1e69ff617231651b15c4b59dc603ae3ebf48492e6f0e25f41547d85a515fc2595823fe946058296ff1e9472b15fc1e8544366751bccb1318dacb9c8dc231ce72483b3ceaec6f45133c78d0d80a7bf6a03f5afe3e48132b78f38f2bdbaffb869d04902dbb1045d6f1b3d68c2dac928af9e4ab846741939f3098af717c9bd0692407e39b0a2f158a096cc0ed48284928cc0cce1e779c38378ea7f2e2001621a2c9238adc2ba4cc24744f09a4154188bd21492a5ecd7e1ae2e6143d20ade9e4061510e400f773033431adceee10d7a745877d931d8f4c4ec63703b4e1e0aaaa2c6c79f403f3b219b8cf611ff0b7725de3719e4c228a7f6c245cd68f5492638e17faa56d8239270f95e64984d2159b77e30cf4355cd1bf9c34ada2b3128aec14ff8df225fe630ef901b6a5ef68ee7252231b1c03faae3e747b166b819ce246a96fe8a9759731a20b4f106891dfed86453d9bc1534864091e03d434a44c82f72d871b44d27ef10b66f7cf2857ff70050c238f1c9d1571d266dcda56b007782a3abcedab282f9de2edab0c264b5398b5faaa9563c6e30b4db5357fa925920668f4a4f170553531a066c4e80d739236497132282d6c2a313515ccc246ba09a1efb9db5da171c420e7a14edecc36207e07175a7518d66ef03b37809d282378a5d620f0f9664c59c6d0a5879b144a65776b8353fcac74e52ba161237c945880f52197a76a037da91909c65ba4074879f1af2193d05d5b702d50fa6946c6114cc9a28916b58b3937cd62843691631f76094235c0c28e2b0ea1748e2bd2a14d0a48661ae85b0e393844200a0b02e8becaee59e249e789fdd50dd1fc89c3823544a66ccf86e8b1cbf653accf206d467d9a46e063611885278ab03f2bd20d131a8bb38b5aa24a2a7476471b48016a24fc336f0af0004ff6faafea14909ef8b5b9c39d2a5a1a067de462e4dceef210bde4bc128cb8095170dc9f164e89e96402f46894d23aeb937167ef4587b90c5900cb5cc95aeb1be8855c7ad8d4a2a5fb4a0c8ab36e78f7e121184dcf8edca0d3391bf703fd4e907fcadd36ff5b8b6e3136dd137c172ffd70a4d17cc3c79b8cc121cf01346d5961a391ed2a3bd901ee016788a98338cebe8e969adc1e09222022c232ff7c787042711dc22cbf8cbbe71f1054b79099634c9484fa9c3200127d2264bce51f23ff77c6d07c792bb31c36b4e07b217867e1d4236d64281fa8c5f1adb21a1831aebfa2b1c9e068f94cb9af99e7d89fa328cccdf746fa68076db07c526ec782f4016746642e76510c48184e3338c6bb6f836b8308fa34cc1d594fc6f9999930420728042a3d4486bec6ebab92ed4dc9d5fb6bee965a0a3df6c5d3ab931e368f25d6d910840177dff11b095b94d755a623d6deaef2d490cefd300959728241f0d6b627fb314a2db8986cd4384b525cc316988238eb5cc917dbdbed44bcd1c39a51597bb03ebf2148e5e82146b7d0fd57c399c0ecade9f7f4b2543075a38218d7c407d19ae03b03bdb3d83360dad04c669a39addb1af1293a722f76ddba91a396c27f68ef7fe3e609607af4651a589926bcfd8ecd86fba60d46c54f87d1efa2feb20de0a67b132cf006e48981f085d202a897e30cbdd14c1ecdbeb7479843e0c79e363c37d111339fad7799a62d10202d91a2fe0649b9b1e8645ede8f2008a37d355351268a07911ca3b7da214c01422c589acebeb1542fc80052eb59591f90a680c94897023cd4e7774629890c3e529ef43f87bd031bba5530f33a3dea83b05d047d706583e12109bd7307c75295abf6a50fb1f71f23a3d6bc6ae5e17034be554986108e71b9fe33f4227c7b08ff58bd849c09afbae79af07a7037e2df56db4ba6a72dc19a08f35ccc5480de6e7cdac26d6e3f9f0074a372df91c9d9b0f4e63c26158325dcd229969e699493be2280620527a5d21ce593387124f49167bbaf02a0a15b2dbb4146c5329490b4c6cd85ef4bae35327ba9ae5cef7664c5abde44a3b01274718e716554c61aba4ce58cc6dcb63673db0da2f51193f53d7c9ddbcac24552241acb29a8fae838b3b2b6fabac88df9dffdfc420bd3071a62e0f077c81dc019aa3e7bd0fd9ec7cd588e6f2007024c2a8412ae4f96176e5d72aaf5081d7bd4ddf79e7e2042cdc3a9e9ba2ce4175dc9901dc0e6ee0c26375ec722edc2ce195e5166efedfe7743eb537103cda70188efbc0edfd3a6f108dfe13d75a14c027e04c4bdbbb0036c0c904ade07a0b1740c6f34378686068ee9defb104261f40098af6fb9245d984b6aa35f1fff8273a34477e98883044a9dfb0c9c7767dc50e07ec2ae4d4894affcdcdf53d3fe6908b682296d4d096174d03faa8ac35ab08720054064054b51c214410b9a4dff7462b11a002c1c241114dfc1d7d427bf93ce5aaef67635cf14fcd47863a9d84d7c6ce8c1d15da2db4a98818dcdb64d188334d1f0e76d883f00f08437eefe5783bf844ddb5060337eacfb2d3c8cfe0b611bb63318989dd9ac33e91da17fec87b00fa826e4fd3e5e9c4079f3a8186babc3d1d784b8b39004ac35de35ab61229858fc326e19cf7d973893e3b4889d194a1ab9d7713e4f99f9f75357f503a627a66ac015e58aeb1b71b0fe952a5d941bda7487462b0fedfec827074894ff77dbaa5d89936734781d75c691610c2c5ec8ef3c77f3d3b98c2e81d16ebf3233bab6bc154fa047e51874bb527efb82477e153548369f25e3c6e9aed648632d71c838a1565e06b07038644860d9791a48e6f1f8feb22124a02f7ca3c19d102d4a2453fd00cb150227296726ea8bc6cd4a0f7fbed45ab0390f012aafccb5c7451cda1dba89693e4bda7acdc47c3272bb980a272bd9565e5bc7cbe2716e7d9922672c27083fde273ff8688925b90995ed3a99740bbd4592d96f4ae6a90997dfa0696138d7ddbeb7b0139d4a7dcb0cee1d49366c35ef97484c0dab023f16bec706ee2c1c03e96bbb3312d7ca7e7b1000bcb3241279f70a9a4f981524e2f533bf334acb1bda3d68aa30aaacfadc5d5ec589a563778ad5f0d1237da1e99600c6fc3b0a2cc4b596288c17ac98bb0e52878b6f9a17b0aded3de60b4774d142e002aa07509d2f7cce6f88ee3c660416d2d199fb83006ef1c35d01ca9ccb16cf5868faa28b8529d64a4c11a0bb1bd1d3422b2aba2f36e841f51e4d63f5014dd396639d8c0f349434a5ef1cb92567be71ee2353b7327003086056d28d66ce3bfcccb420d97332bfd6e2a3aa38f9114337eaa4a2eae25b529cf21cd617b82430681b11588be7c11c92f675016b44dd6903d6f0870eb6a7c6a8f5499c47f1f36c6fceb91c3f3284b3c648fbd5d6ea237eefc637b165e1a8586c671abf8724687f213e197b43a776ba64038d904915e888f695af1aae0ac5501fef830f6b06789f8b7e29f2ad089d4ddcd30d4b878b4d5f990ad47e0a4af69f779254141f57250f3df752c55295f6e612e768c1eafbdb6b09bc6a99b70a8a24aea2dccddc3ed4e210d215c7b292d453fe054241dabc723ece072273ad877e8072d3c8beb33a4adc16a76acc638a6db1e0d59017649add565fa860e1188c0e4e8c8b591791b2a2dd903b590722d59ae8425e6dc0e91c6e32b61d584242dd20750f7783c2c761f49d7599ea8c1ac878d7fd7afc4adcccae88da066954a4ad506371a82a864869fe3f0b6b33bea85e21c530ddf681d4be12467bf7bfd064a7042af4e3aa64a19cdd4e5406123ebacd7f3f499e3d1b50b896af58d9bc8f94b71dea95b321ab4919a77dc58f14a57b632ceb5da1806e21c199190d3ca26b03542a6adf94a99d957b5f7ea0f1b9c5f9fc6e8038b68200024c8a3dc3a2c39172afa4d4f61beef1aa5de2aa4b76cc432d74515b4b5daa019df0568aaab37cfc916c93ed3fb7297d076c250b955bf2fac6126ef2ba4084b2c370fc2aa8e20f72d0daa22f7943fd2950a9a6404d407ce7e4b59344a014354e1caac8293ad7c472a88bc2bcaf52ab6a7370c030acd2cf58a6003d12ab52c834e67deef9b91509d94578abe6a19590b1b34b6b1550135b50b78217a8ec426b18b332b71040b5b2e55c3f92811e910d84a70852bf31c2e7c10b1fbe3da75644169e22652c9f182543668d2dcf3b8e443316fc31b973072c18080cfc903ffe6b72337fe5dd7869bdcdc5a0bfeadc3c299368c67ab71438c56b84719bdbf1f85c453607983f8cf50f52f4f43b4a2ba1ee97cb1af85f8a67bc09db0d21a6268f5b0f1a1489ceeba64a22c00c5e9d7c9af3eb1419d59cc21f40c06b7ae8bbfaa2373a9baa03a2a218de65607c1dcdc1f44d3bf0545c80587c7391e71dbd0f2f4299ecf156d0819b124342eea5d5ae355b84071c65654935e9f69e5ea65960832f7838b9a6c1ea9a2ae0a8b791132876cd70b3271a18086a63183a8459087edef1219c335fac64660638eb342969caf598f4e801f7e35023c3a91f42d12a1f9c6ccb81399bc3da61165ac2bd8772c2cef9a8c7e970164d053d8b322c7dcd0a328c4b9d384b8cca25d29b8c56cda42c8b7cc3852af16b37d49d1b0797c275beac0ca89d024ecfbb4ba11556e6de919b02febed63524ee18508503573abec681c3312a2f5798542180c75bbf655395776964cde97abb7a51bfaedf6e3ae7ceb55e6fdd243b923d270a01a212eebb0c4cc6967b9b498dd3374d327ff17d854ab6ae674daf6115a15260fe7dfac15bde8555aacf99c9a85ef4621c2e8e089af560269806a4640523f7cb045e672d6ab01682e7892c3f3352021908ebab16456f574ed0e97d811c419d10f0532da4a8e60b6d8304af7648420235d4cff4d71b8cb37282a49627434086a5f8310a9e57d23f4ce749a43a946b577e7175fde8674f6aeff768ac1d8f5f004a6f112f584a8ed6b4586e3c3e31d92b3e79bcc5b065707151f57767684ee3fdbad30d31d4fc4009e40f09f30424f0c9a4a25bc977eb28856fbeff2cc1e7c39cc7742fb2b65f1bf40b6e97a29ec6b3a1641e97723a5979f7cd5fb92b312b195b57dd7ee34430751b88ff495daee4ce30f3b387c7339bbec5b3f1b3f621f3d4cbdee0f015f7b7eeb37746baf9cfcd171ccdff34e81e497900b9532682a831d960ec0cbd79ccef069a21ce81c69e279ce59abeaa9dfeb6d6779d174fe0ff4df32324c8f55606b4ddd0331607effb79ebb8768d133b222c62d2253920b6ac06dad61720e820f801d950a1fe4a19ca076d4e6922878df1c082accc1403ea08a82f2a843e846d577d4a2e0580661bf3bdc04e3d5707ed8a925e7077f682d3335c8e419faaafd3eb167611502581a25004616af9c38759604e7d12d053092b180dc34f3c3f0110d66b54a57da0e0480ee22c8fa98652aeb1e691a3fbb095c9729f8a20889d385e281cabb587356a0d7dbd82f04b7b63418d7800ef57b68d29a23e770de5c49a9d0c1a5bdc887013f371b18b20d7d7e9282e0eaf4fbc6fa6a44563788ab46d8f5a574ece50010a07f4d0ecce32e39c433e1688c6596f9b5decd7ab0d2ddf113b01f66e385fc1599c8bad6f9ca41935d2ca3fc830b041b47732043a4048abfdfe80e80574e69f6397fd29df6164b6ea4adf02defbf80870b1a9c45c24672680ee4583ba0b783e04a33022a49111d421c1cf1a95d7823ac31a3ce3e6ca2333169e1ec7db8a5f61f5ac240b333df15815dc65c185d236ce7d54967","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
