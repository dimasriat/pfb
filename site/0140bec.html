<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            * { box-sizing: border-box; }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                max-width: 768px;
                margin: 0 auto;
                padding: 16px;
                font-size: 18px;
                line-height: 1.6;
                height: 100%;
            }

            .staticrypt-content {
                height: 100%;
            }

            .staticrypt-page {
                padding-top: 20%;
            }

            .staticrypt-title {
                font-size: 1.5em;
                font-weight: bold;
                margin: 0 0 0.5em 0;
            }

            .staticrypt-instructions {
                margin-bottom: 1em;
            }

            .staticrypt-hr {
                border: 0;
                border-top: 1px solid black;
                margin: 1em 0;
            }

            .staticrypt-password-container {
                position: relative;
                margin-bottom: 1em;
            }

            .staticrypt-form input[type="password"],
            .staticrypt-form input[type="text"] {
                width: 100%;
                padding: 8px;
                font-size: 18px;
                border: 1px solid black;
                background: inherit;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                width: 20px;
                opacity: 60%;
                padding: 10px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }

            .staticrypt-decrypt-button {
                padding: 8px 16px;
                font-size: 18px;
                border: 1px solid black;
                background: white;
                color: black;
                cursor: pointer;
            }

            .staticrypt-decrypt-button:hover {
                background: black;
                color: white;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf0e0f5dece49c99b312365c7a69d3ba14c9b5b29a9b35820d093ced15b3fde4ffadff2b8e58dedc5512e557c33293f25ef14f3094d20c38affd6ae46c8cdb20297b0eec79f1f10f0d596210eec34fed09e3594702a51f3b47386c59ba991dbb64daaad54e89f4af8357500650a902079f734edfd1de7f88699e0daa526019a5f241f4dad69f82d1d1385289f30c0be3f90fc7eee026180b51288244bb4322e45e39690e8491bebef969cb60ecedede0829917720a7ff62524d0b8a63849bb315d038288ab8e9c2f05b09fa7b94207f3d0878c569c3469cdcf0684e26269e04e011b0c6066a30ae534f6c13ecc4f81ce3fdcaaab4d0e182ab3c41e394a8c982fab04514ac5fc32b409b650ac822d457a7f263cdcbd6060caea75230ce26f2748ce0b2bcbbc31810613d2bb0b818b4eb77ab99504851d07a09a4967c396bef8e2d43a8ee1a576c7c5020eab1b86526701ddc345330713fa18f3e244d4055989a739073a1c470cfae7284019b9aa6ce0fb3dba2067f918f2504cf5977457d4e7789b7a42e62b0dbaacc1a642a43a3d5e0d77df659ebf5f124fdd1e658249e4c39766260e8fcfdc9381451250df33bbc61c17fb692765b3ecebd05f13ca25820bcf8e94cbab7ce87c00e1c078067c3f8664e0454b5190cc0092ddd12c30efc70785c43401097b07138d396d0856a6aab06923dee5ef2fa55e9ea8f55d1a35574e03c70420b47bcaefe42e94cf95b5f9e89a36f9bdf1f02ce86dad8777f799c542e23bd35493d0362d89c7377ca88f2cce77b9c45984368bd6fcea033b32522bae974d1b518a3dd253656edbb1e294521ccd7df2f96b941c0de89014cb15372cca32081ad4fa37e463c26d6ae3375ae5d0b76a4edc2750d3c9332414262aefc671eb7f2d79b82b81bc74c8ecd0f4b7cded351371376a95df8716883d26b54d0e78f282444368a456916ab0b378ced4d8d40836194d5a6c3a2b7d67f278fbb3158e76a8c3ef11fd5f9f4eb8e1cab187c5ae93193bfc236ef059e3c9a9228c167d156a319a772ead5c816f1e0bc99ddc5dbb0199fec67ce86a9e75968402d83a856d27f285c25729386217d43906bed62ba9778377336952c8bb42f020dfc948fd62d15edad36e2860e8b937a041393dc254f59e3363f20bb25b3729215142b5eabc304e0d10644aa81cc12a4e0547ba74ff2d05be2006df790fe408412ba334ac9acce22f3d4d2424d59283b65bd84ac7126e939573f3ef61b5add067c8c8e68b22753d1cedbd5d52a0401f273a7cd4d968ea2e121de1bd7b03d21370034877fa6b85afeb3f3c2d4399b3cffbe15a8faac1086fba9374cf0d77f013772c97e0a7527c1cb85cf1cba71fec0b0bc23125980be75ded8275b34db413bd46050a636c13ea565f4c28401932948e3401e8abf22006d8a5fef9b4893b2e3087fc9042e74c5fffcc95d441d07ec2589724ce1966d473553f6735f0ca39d7da1d2dd8c412dbd8dacbc9f08c4b5a0dfcf8859561d4eab958f627ff5b18eb8eaa9cb864cd6980163b741cd374cd7295084d8044466404be76f1921c953e6e92ff1d1f790a6eaa54a104cc44255191ddd9937d456393ab900697b05d641a4199fc7bc30b28ccf3968830a7e193d80f1750751a7862bc602dcd5fb6f61f8ea4b557a527b8d0cf21f4cc652b72bdabeed1e4e46da74f0d51f39ea52a97236294cae4ab72b9626b992fbba6948d613baf6159d02318623da5dff9dbd0ab9a19dca29f873a4dd26c0fd7158c60ee35519f17a5ab58f67dbf1743314e735ae4a65626a5fabe4c7a7dfef405aaca084259828bb79626867f31cc8c27661710d0a13b327a0b52336ab1743f3d857d85b52970c470d675ff6879165d0c6745f0ae41635a5803ab433b8d37b9fbc5532ade366ea531daacce1239afb865e9673744e8b3ef3f98ee8fd93eea5c2c0008ee99f4cade1d9e91f08d191ff9bde6741f3a1880193f6b0e38ef20fde7b662711ccea55340207fe9e0d047e834cbd1dab13e8e73a86e6845ce5b8ffd23b52f4b2a9df8ecb20066936f9c327f587dfbbfa6297db7cfd4869fda5b63f02a5fce64e44a8395a507a4124c834af948195385cad3cea9915573a691bccf94df095c57fc81a3033a4a4e101579eb9e090bcb19b6fa903d366793c35377512ce75259e5c5e7add9dda624e4a632026d0cc87f33af02382669cab6e04dabf52b6b3859e3f5abd0ce95eaa94ad36ca1070261a3e4c239b8c7c9213109896e403bfc07417d85e21f5a2e74a811c39600db06670d824c3c3e69c542504f418479b64d6005b3693a4f176d13048821db8fde50c7322907336f16009a2cab794d53baebd7af7262d614463a0aa769b8ddcd5d452ce30a9172c09efb674846712873a792c7d4839ed5bd59d8dc4c26fd950721b74a7a95154030362e6d195b1cc8d5588ad273ef564dc9e85fa1f64eca9c6353441bd7ef41015dca924d44736beabd8fd9298079a9551b1f4e99759d80f382555417623a1276ff1727b62d073f1e159c79d311aff8928e59d5a0587e84e76026d49ba75b1f1dcde62b5616aca124e607568a5698d56893183bbe3928dd7220df936d5b40907cea3be2741e09d9bd81d2c13afc6a53ae316cf32b72bfb293c6c1b8692b6d967061c47b944514e31321850f5bb35a12d605e2c74bd94f4e56f7dc4cb2d497af6a046269691d8cdb6e99c07e2a855d792210110a50e897767e5fa5bb446068300a3f98ca20b8eaacb7562d714d212b88b922b605c3a13eddb5692f20705f6a365bfb77f1c45a0b4b105e450a61cc9101a5722f62871cac45272319de4edfc568cc8cad7c73414b7a248d463210f53f32545c2e48fb05dd4818224b033b77617796e4c604b5eac1c237866f944b225f28c0c73b5f8269248eab579a212a2d76825896bdcfc29c80aa0695f884d1eff049b54705dcbfea56275efbc02d342cb13510ccf33dd0bf6881fc16b143c3bff1b42609a9a475a63d9ab2327449f17215f4b7e5a9d467694b7eb94530dd6edde886d1e69124caff53e6b45aefc79452e330fe401e7db2fb8597e4f33dcea3ec94c211c91f4b260ec6eadcb471e48dca70ed22fabf3fd3691fd7f289b224e51043076f641183a91c9617579b3f97d913f5d7abfedbaa9438205099bb923028a24875f725d6d89d4f24ed1345d57c2a1bf421c23958db6755cbbc0e732635716f2f7435f6af52c182c169f5c7300302d05cf317e31491b247f49dbca98434742f02459997d2d515439d538625a71e51b1e2cafdfb39f62cb0ba54c069a658c49d65e78bed476150833892c743ff04878a75a35ffa447d488aec740f7210432f9ebd8147a5902c366b7c15d064f3bfd3a0cabb14b18eeca504f62226d75127307ead3eae97c2e43d418cdb55bc6f7823de7750f7b52f6176b5971cd27949b844b43f02957f158946a29e6c1621d5a9442086956dfa9e27a42bc14cb3ace2174cafef216c2fc2ff8007653bbeacd39540061d26e3e44cc189fc13a1bfa2a179ed6ef5e4ea9705a14b0f60a04fa1c1ddbc3524aceaf2cb15b756fb934c505b4c5b50e0b75e304cd0e8930b2d3a81bc588605f77feab1b90b783782d9e10dbb3f59ed249ea137fe56ecb76c3bffbbd5baed1230ac20cdd6130790737096fb5989fda8f1b648fd048a09f0819d5c2242666676cb4a41dc7a097ec445c48b9cdfab08484a7c9562db2c1ff221c2685dc756f5369dbc4f91019af5c754731021fce4bae155b910cdac845bcd70645ccbde2260c859dac503ed18471db5fce65b3b4811b1a2f75c49ff5ba0b69fb4e3da0af2ed6efabd90d9db0cd67ea09fefd809069241c8ecea68bd82f416f1eb643738515a0f7fd0b07bfcf6cce351d5c6913a9fbe08a639baf566d8f6d53f553339de6551f864e187c5d36c3768256332160f66dfbd7e8795c13f0d992717752365c4d611fbdadfd8acb3e2dc99b42ff2ebfca228c6a2a2d7dea3f5ded5b7f5d3d1c023a57dc454ca3cb3bb5b6a2d053aefe59422200e337d4a7683d11d826e6697c2790d90fa0c9623b82b0b5e889c3e08a7a6f7caf3a368942f968e2d0a50d8271b5b9f912a1b573c6e0292be7de735df48f9d0aa105e19feb84c67e466ee64d36ecce59b07efc4622499705b1cd674fda3d6a250237a289962bf9a0dd2300089b452f485cecc5a7f4e3cb990e67511a6951ff42dc9573d6222dd4a56f6dd1c4315af1c77863c378d4f05409900315c8f9531318f2100b31fe262a016efe0b89119f4cf63b1f733290d4032b2b0b9b0fa289c83bfb7849a24496384b00f3a4fd949796a26dacef519f523e2ff86ddf941e5d0825fea40356809cdc78e0762d4cf2f62960294b5b94bb9f29eefc81b62fa3c0fedaf4697d254447419bee00c616105313532107671f09b1f84b5ddfb1db0949083a2c8409caf947945f487810c385016dd8b70c59d306a1342e5390fb8609580e624114337d8dac8e9976327eaee4eb49e6c75df5b7be9fca1e70d61e4544c3151a4ca20de5827f2dae220baa63f4d676501bf53faf294d96d9eea8fd23bf7bd70b02d305ee87d8d545dde27bf86e406cfcf3ebfde12e73b0dc31b673585eba5ea150a4b0decf4b8df4ee8e413a688c4c8da8233aecb4c8c9318c45162f173760f0f24be5a9381202749ec04d2d880905701a4e2993c4a16d6d296446458613bf307b9f2d8159d6255785e27695bcdc06ef873754c2657bdf96cc0897ff3b9019d2f30685a4b7283d901d3874adf45d749796507fdd8b88aa673364f17b66a57a915c13719553d155b22edd96a6f34cadf8de53d67a88ef8db357148f040e241f87f67ec203425080a00394e6d6e6811447f5c26cb64b6645d1ae551801cd8ca85a5196ae16b348f919ad1b6717093fb5b3b3fe3cc0673109e5bf55668e7e3ed1298dd039c5071d66cb017deb8256fe50c78fd5836e78b206efd823c9ecd16b23daedcb4474e06002b8c58836ae7c884c652e1dd1874786a3f3c943624e4377aec8a86beac15ac846056b57137b712ade40b175ebea32b33ea97204a0c9ef0e4c243c3eb867e2e89b5e0408738737f5fb41599badbdbe8e8a729583bef760b6a55bd0d5aed744ddc06e024456ef6a702c527d2a2841543ff37af40d04bec0fa4562e776007d4516757652a5441cacf638b59869b5f2902c877beeaa714a02eab9c38ba3bd44a3dcb4e74f617287dfef205a78a4844f7d8f96bcaa660ecadde25cbe439373aafca55e4af0fe7259c5d7e3271f672bed03cdd24f74a7189b97f8cbbfbaf34124b5853b448e2e9fd26a19e3616904dff1859e421be203949425d17af01c5c94f76a209b2edd929b2f0f903f17fd582e05c5e9a605e848210ec5a5062ec74315300616b759b3600f814d829f896e8812e2dd64e660561f59544b48aa6a8d6e2ea2606c2b04addce23b7b2ff88012dff2c04550c3d4aec1740af5591de062d858b813c2118a968ed7b5820868fc2b061ecd8cf929daebc36cc5afd42cafcd05674521b114f2a3dcb9b30157df09698b4bf6d2b2fefd90834981fa95beb00833323767098efe223d903e63e39a7ffe23ba5906ad08f098b63fec1fb3d0ef5b0da752672ac547de03a49acd8b7382abe020d018a47774bacb82c3f3fb5fb61c1d1d77604aa36140cadc2067e17be37a9eba5d411b009027dda0fe949a629d72c954a3ecfd25eadab735f9414f19e26b5deb3df406ec80fbc3493885466077ff1f6fbc5733e2f656153170cd45af989a69b8a2ac7a3d5ef194abb8cbc9aa86f4d5dca167e54a3937dee37d5647a9fad62c544e242c852170ab167b1f35070e9de207e4b3a083734467921d3175ad343dbd87a906afa65750e40298330abb908a5ba61e5c57b8f1b807411ab39e88fa1ea7d2de41dd2fb7f39ba7287858b3b1ebc9ba50e4a9e310c36d2244dee2b67be653f509eb994e0bc2365e2ad29af9fe37534d5ab93a0a805948a6b48a11de72789a8dd502b6df36656ad7bafa931447d3a117358084c0365f1f9ad0163d8934222fa931bdf100e602f85d302cc1fadfbfd8c9d1473f049c742a4b23087b93ec296fad1d3fb484eb10afd73e0e917f38d176e5d7fe120e37f99fdcbb5d34a9f4357b2fa7a605c3c757fa5a8a251c457b2dacf3595425738303d2acd253137c806acf0998f30b323ce7c2238b736fa33ac1b990348c0bb0a1e045c3005f8bb9b739342586e1bcb09d0e360620c282a4a8454e5ef5375f42a89867cc13ed8e1a218c5b652e3d735259d18a7e1bf2b47ab07e4dc607c901617a733bd8a588f107f9b67b1f4bce5f35f6f4f52715936eb03349c61e1fdd206ca9ca07827f8e379951680f4095792ed5c3c0e798c6d790a2e954b23aa17b8132571c80551bb3d72cb65914438930b31db47936bad6f55e8ff2ec953fa1c9f43e6b309b0abb90e83e6af8626d8bd420a0ee5353aca1dd8bde8297cd41776f4bf4ee3ce7fd8d334506154d4a436b16d854f1af3baf7a805af00ca420676051d0fd512ccb7f3ae53314c599246c503e2ea7e0a61d95bc0027f85063f6ef1a11647aa3fcea1413e0933052271a659911b234242aa7d342a12d0b67eeafc002d9752ce80cb9c30af7cb73032bcf2ccf80f578085ea134d2c283353dd107f03301beb70d3c6f0f1f0eb8220db6d6a278a49590a4105e069d30986b9dbafc580bdbbd559ff56dcaf3afb4eaa7cc1fcedfa27cfef2d2384aa28c8ebbf6250882ee8dbb9618e80ad4af78c9a729a447017841a026c9e7c819ed208a54227d3d6e3f85ce9b164e5170a0aaa4b8cfd35a5482ce3c88c6b4a0b43d742b92be6017c2d0751e41d5d2fa23711871c5ffbb8f0d8b30d79d9cd289e1e6537f8f02f6d8765ae8d0d6be2e61e81ed5bf7ae9cce236f5bc61ade60322da39431d4e1307c254bd65f65251f00893ea2154c3ed716427085cf075f3f4a6388682e46de557f598e472861549f1c9e814232db6c2c8d44aacc56e177af6cd80f38d38c42b194d43d20c8e3c753d264fa6b26719e4f36692d910ade5dc73363bcbcf19b8b7884ddb958f7b9d2f62f4bfc57e50e23c9b62559b6e580c3f36da56a334a6a3ba4528e78c19d9fe4f491998dc7540b222733eb55654e3771d530376a8f7d5dbc12eacf426d11aeeb62f9daece2aba10bb88943773221be837a1df88bfcc0056392619828f3cd45d7935928d72511c6b6bb1252657e3f8c129290a42394f26f115448a9fe50b9776d43d17eab9462f3e9a11c2317e58b4565afea02006e75b0c7b727f0b8111f275533d9e5b41bb02b06b4c67d1d60ec3834d4db3579b9af2db843abd2aa9da18a0855da99b5be0707b1fe897140195ce115c81b439a8de6ee1192ff9df2fdc4c8c872df6345b9e456c9a2916c251f89df63bfbcee85997a89823f17c29052e1e41aa881720bbad2e9d9cf5ecaef6934d3a1ea8692a8ae555ba7cb8dbc8f7cf97e0eee387804aec3eb7452731867028d9d740a99df59d1ccdc9ba02e6b7b5d7b35b09e3f8040fad2fdfc56d7dc90826525a82e239d1383d32c61aa8055d7e9cb8c6179be464e18a125c0a0582d8592ee1f517ce3bf9853cc741bf46e2c274304ada905915b4eb48c070c207ea40f74aa19762b05f92a94a0c25cb548044aabe48857decf663b24b76ccaa60547526d72e7158d6803f8d818c29cd20333ae0520689b06920d1e35f89fefd150588f0a94189c27f12a1fd6d4a6aa10b21d446d6f224be2fe98d74175d67216335c978e89a4998e9dc6539363a79512808f11bae726991b29ddf56b29fc247b68ac8b180ebb520afde35c9a24b6965355a4c5c0fcc749c2853d655cef61bddd55360b1cc96290d77360f317b16620e0580d8a4085db517882780b78dff203f24ad640de474cd1d2a7d7e6fc76aed097929ac5c21d4d16a18243a3f0be5402b07d6346dd9a80d754e94f9cb544050eb701c8dfc55adaede1134dfb546f8ebeeb23822be1e4880e77c104ae177d670b12b3fc40cb23a8f0465f8806d6e524bceccf7b9597add442af4e0ef79f66c6dfef286bf8f8420c632d81adefbb4571d6b76b5a9fb6a4f44f2c3862520f3d6d51e5200df885748e8e6cb3074adf92058574b7ac3ada4bda3bbdca04fd17cce2769c0b9aaab0e6c8b04f7e37315851fc2aaa4d51cb8bcb55fcbb59e8d9635e7b136a82b251c647653a5a518a0510746f76a1ab451a50e581d7c58e34548bbf2525cd75e4f8d2cec90b5d9c7244d12bf71e5ddb0578303f3c3c018ea28c44dfe39a8e63858b308972be57c7de5767bf92c8d427cd9c2cf08b9f09c086274f86a37e17552fe482adc02a5c0fd16b67eb711a6d0bcd66884c04e6a65734f5f7961c6b0ea325b25794c8af06896f5c2fb1c4de61d644cceae25d106643db8a510a550106fd70b4ffa41f4a61a15a4fe0a5e356d713226e1e09d3bb1eb726fbe059be632ddea3ca645821cb2fc2a2f886715e5b1772b351199c011cc8828d0fcf080606cd25346ad01da76b3480b866008be20e819b1009422c0855109b6e26554141f7e1556c10aa7efa4082293ca1d987927ad6bd23c8e26be834fc5824ff4fd1cedc696fe8d052ab8ee4c4436bed0c6bbb8a5c2010d2d15d583bc30d60e6979c5c5013373ae2a440c0ef4111cec369c0135e3d33776455cedbbe3986b1637e435ef03b6bc5fc16541931e1988b2c63740eb8b10ab2df8db4183de92f702501ea811605575d629dde2fb32b6f3f88240db040c4a32d5cddb5fc3afdca8c85f0a414fdf2333f1b669e809409f7995ed6ef5c626b5b9d4d2ef143e27fbe80933dfa448fe457f14973a35d22a1668a22e3875d9552b21804a20108f3619134bb43105951b8113d476de8eb1086c505031c1dd49e4684d1ee1747e3c75c6ee2ccf49b07896d8a17d96fd8d9b90cfc360e91783902f4f67e054373c436ecb20fc2446550450424c2587bceb90252fcb5a2285a19707cea614dc3ac2d4ea68f9a323a6c6ad6a4bc8578fd621c044eaa915da7796d7504793c94cac673e6083aaa223e2a804def7e736f8db957313450587abe2aa1268dcb527d2412d832cbdd8d4ee15b231722f9b7ce9c673b91e8364c637bd0dab5f16ee804fa33392a0166ebea7a07fad3c336682a6650eccedcdb5325dc0866bd5a959edc455f679bde8f98db67a34d7f0479613ff5a48fef44e917965a3963d291eccb8cf76d1f4040896ba7fe5fceb57bedbcc17eff6cb4ad26648d63b02c358476826ebf207494b1510425ed414fe395dc3e8f077c990bb24f8a15b08edaa88d1ff099b4e53b9394ed160b6334e84e40d880f3d333019b0faeca2780e308c9b4ca379aef782bc631b90a1cd0c9a245e5bbf4c6f5a94889b4afeb0bd21cacee9886c87661853b1be41b8d691f914451a1322cc0de3dc9de0feb9b9802a125c1eb9a5868a237fd4c30e36311372565ff3de7c197084fdc2ed388eea72d7891bfd72c72514e12f1bfdaa083747d27aeece23e3e52758805614b612bdb16c089aa43edf399af2eb9688c410fe1036f90521016c53dcf5529215762bc2d91a7785e20afb0795abd3e4ebef33481c779e7b7cc6745d114cec706e824c29d5c38f0eb3833305a62605fc6bfebae43151340656c20aba4ed9c0ee0b949044a10b63add45acc7702da4440d57932a655ca86be9a13e7f476dfe03383aad8baf64d1fc9e81fa3016fc95eaf8db1c36bfc7874775672a2df2cd893041454a75e44742ed57fa4d193edd6f33eb7ee8bcf2febf6c9a51c95d81dc772d8f3d53660a4b5003aed92873cf0b12012951fd3b12a98793c030af0fb51f622e0ef4ab02fab32acef7aa36afb6585e0a86d87c64e69be4265c92b12cfa0b31f85e1e0a820ec1f052b893755c232ee4c54516eecb0c9061374e5f76584fb6336f8de414235cf44ee02fb85fd1f339a9d7632cbe81541bff52da3fdcbac591faeac60e125da95a0dca24d7d07d6dd4ed7a164654cdbe18e6d8a75d551c27856b4b19919c659ca3a8b86dbaec4cc2f2895582b8fda8a57757aa0ea33c717dc8a294fe9e696f04027a06748325fb7884fd71324a51e9c58a19a69775122c9ad0f8575c92cf529fa7114d6857c8f81d07855743d5acccea978ac43069d45c48472b5caf276af480acb4ef82be351c614936423f22be5fa7fb06f269a8f0122a16a98e4dd608410731490d6a3563d55ffaf1e1e47e1f6d535bcc71b4ee19ce1a253547dd3e8a492f96b9b6c1b97e4eaac2449aa12f271254ffbab81daa9203ed75eed81f6ff7c0138769314d2c0cb0c901a7ed4b8e17922c16375ae183b28829dc0bde943114eb1ba2224123c5d30fe241264b3f32b18c7eb0a6ec7d2413804fe450829772a6acf4324c150087b69b7465f5fbfe8a4f5d53c26b9682715623c7a9a183f51becaaadbbde0af0a9fbfae35f61f86b9e2b5b6da2629a2c4ccca4bdcf969d22907c8cb622240ac82e951f41b9e6304ad6aa3dfb74143d081658cebcb987d8ba5ece4ec0f617db54afefecb67d4460613f29fc2da5db0370ba864eeaf18ec3c915b4335b5e85af465c8980489733ba8ebda942e0a85d50275fbfe281fb797be7c76da22eb47c829a6f2c763da939b879a195a07900352da755670be915e5e458dba1496c2882a5793fed1bb5c93010580c6151d5f4a8939f4979ff182c5c8028f6f03781be84dc1537571d3a38ba729e29765a40889895dc1683eb9aaf5f25caa31be28cae83a0dbd4eb893d2acaac3e4737ba3d41c83515eae42f9bb726c6e5b9a0127f411da60aa7566f7d71570f915ce561b802caf052e47621dd123d9399efbefa04f49f6d099a2bca3f99188e5eaf4fc633a8c42a3a238ac88d2b6deb2c7c5b60889feb2b6ee478d90caaaa30516b18e027320be8dba69e89630b21adb60f6037179bee2df2d45ebdb840f2a29f8ee2043d6e6834a11c5a6c77a6a8414769eac42acb8578db76ebfe0a844266656ba65eb3e64aaf70b3ee28d1eb80fbdbf94f8915bac11b14b10878146502c94526998085ecb89bcaebbf6a2711ad81b627e61c0dd29f6b7521672a76a080331c7260aaa28a3d42095eacc3895e129937d5297e467a17aa5c832114d84be66380430e85df0c3cc9a02e6c6f5c421c85caacae933f4c22ddbb21d591c72b30479a99bd2ba8f9f66b331b6ef5b5f18e0e245f9aedef8777863489f3ff686225cc54e53a7897603628acc82db5651d6827621ec6b8d52404b0682af3304caa3cf2d1451061da0d2de7dd634edbc67daeebd839cd81f47e663b8c7c31d5547de6ea82d4296e2685202120abe6bc88cdf8e86ff7acc1d62e206015f56b8d41884bef12dc15083220c74992cfb9a85870f8df58ab78b1b65287060fd9795deb5d6c566943da3c9df66300f0ccedb9c1618dd7594099d316e80f05b6393344f48eca44cef95d37e458dbf6001c3ddc244919c56e8b6f1a74ea4f48b9a49f8aaf1052867f95e915b673d4b4c2700cfae1ae83f3c310cb51c3c3a49d23c6adca8ef9e42deb2dbace4b9612298a0a6e49ca08ed3f0b33dbcffd06caff95c3b3cfafc89fb23f87d4188b07f6a478b6e39c3affd165874434fd2e2316c4e188d9a140670d10d84dd6a8b4ddfd11f35150aef648dfa042d88454e8156b1a85f454e04d1852d9ef1c88085b7115f85ca9183ab511ede3b36989ed74d3769e8e1fdd60cb70299eaa16842be1d138249d9be68b5a10ba8f814746a7731d8ba153911122cd426a5961a1bb7d35236ed34c15a17d61f5477a5b95e01d5206c5804dd0b5472b53aafd70214c6e918e00dfbc8c4a67a4444b0dd2e58e87bcdf4ffdea52678b879ce202beeb2e1a9492c02217b02fb8bb88c2ad2fadc89b99ce4446a3cd3a61af2ec0f4c1ce86cfd594e33a2e49f093c489ba153146389366bce8f280abf8a9917124ffb2ef25e3a093e9f1578ddcde0b59fc290cad8c04a961659345869d8abd7502edb5efcf023246de8c20f342bcf3410cfd0aab8df013e36b4f8f0ffea345368917675fe0d6f36d6775b08ee443f3c8772ca3d2a3ba60a24c8aa6299183ffe7f3e5354eecc9a7623b69bc6af49ab9c9f5b0942c34c5e5de0bfab3ac2a0c389a4304d7b6e651593f6b08f2d2daf9cce89c698125fca9af432d48f102f2ba42135ae40a71a0caa838ae55b25d258f2ad0c2e3e315ba27b236ec631223d0d95a0e2e9718db170af0ebae47f587bccde81601c37edec7d831ee88a35d370276200223dc2419258f0186bdb0edf758aeb9b30bca22efb0ebc692758506031540562380d4b5d776af33548b462ef4605f2cedff1f60e35f97c756d1936a2683ee1ecf66bfac750387c691007a90f733884731186a801a4c4dd8aab8a59f204e2b982c5f756edd2dc6d4a1406993e019a66903c67a251ed2177b48a7f51961a0806b9a02c6478d6532a720fe4ec3547240a5d6d1eb98f17e3275296fbe1326d4d552522e8bec094160bc004ea5945aab0277d21305ea4072871efc6ae53a00a9e95ef836e9aa6d8aef9cecb6b7e2a7898df37da9abb6fb243d0e0b7142acfa89a1973b79cd715effd5f083bfbbfaa72f012a8a77819af71f45ed78fa2295794a6c7590a6b7e2119bf3396d682d06846b1e16274c4600882c00f8295becbfa115ca5c5168d7cd4da4ebefd79b374c8a6199d19e9f028960b195cf1dac72523136d995c5db6ddb8ea82f03cb7f5d5599d0ecc1d45023c552d37d7a054921026e472c6348268cb42c512d11d926581b1a2fd740a8236bd93445cbb815b14990f6f7587d551db9cdc7d063be4cbce2d1605558b4beb2b4e74013459bad135f588646226a7c8daacad18cc13a1695b7d53ef9b9c6588f7d04c086f2a915fd6057a1d7094ddf33c918a0f94df2013b457b0c009e1b368ee766c878458e2c2af5e3d7935924f12c0149e10be6e2db997aea4db051b6f5dd9759d2b8307d99f36c","isRememberEnabled":true,"rememberDurationInDays":1,"staticryptSaltUniqueVariableName":"ab7e469948e4989d322e29867cb59cf1"};

            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                if (!isSuccessful) {
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
